
Prj_Murata_L462.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002a51c  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000c0e8  0802a6c0  0802a6c0  0003a6c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080367a8  080367a8  00050904  2**0
                  CONTENTS
  4 .ARM          00000008  080367a8  080367a8  000467a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080367b0  080367b0  00050904  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  080367b0  080367b0  000467b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080367b8  080367b8  000467b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000904  20000000  080367bc  00050000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000117a4  20000904  080370c0  00050904  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200120a8  080370c0  000520a8  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00050904  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00050934  2**0
                  CONTENTS, READONLY
 13 .debug_line   0007b907  00000000  00000000  00050977  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 00000094  00000000  00000000  000cc27e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   000972f1  00000000  00000000  000cc312  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000e344  00000000  00000000  00163603  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00003eb8  00000000  00000000  00171948  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0011c10c  00000000  00000000  00175800  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00003854  00000000  00000000  0029190c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loclists 00027fc8  00000000  00000000  00295160  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0003cb84  00000000  00000000  002bd128  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_frame  0000caec  00000000  00000000  002f9cac  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000904 	.word	0x20000904
 80001bc:	00000000 	.word	0x00000000
 80001c0:	0802a6a4 	.word	0x0802a6a4

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000908 	.word	0x20000908
 80001dc:	0802a6a4 	.word	0x0802a6a4

080001e0 <strcmp>:
 80001e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001e8:	2a01      	cmp	r2, #1
 80001ea:	bf28      	it	cs
 80001ec:	429a      	cmpcs	r2, r3
 80001ee:	d0f7      	beq.n	80001e0 <strcmp>
 80001f0:	1ad0      	subs	r0, r2, r3
 80001f2:	4770      	bx	lr

080001f4 <strlen>:
 80001f4:	4603      	mov	r3, r0
 80001f6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001fa:	2a00      	cmp	r2, #0
 80001fc:	d1fb      	bne.n	80001f6 <strlen+0x2>
 80001fe:	1a18      	subs	r0, r3, r0
 8000200:	3801      	subs	r0, #1
 8000202:	4770      	bx	lr
	...

08000210 <memchr>:
 8000210:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000214:	2a10      	cmp	r2, #16
 8000216:	db2b      	blt.n	8000270 <memchr+0x60>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	d008      	beq.n	8000230 <memchr+0x20>
 800021e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000222:	3a01      	subs	r2, #1
 8000224:	428b      	cmp	r3, r1
 8000226:	d02d      	beq.n	8000284 <memchr+0x74>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	b342      	cbz	r2, 8000280 <memchr+0x70>
 800022e:	d1f6      	bne.n	800021e <memchr+0xe>
 8000230:	b4f0      	push	{r4, r5, r6, r7}
 8000232:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000236:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800023a:	f022 0407 	bic.w	r4, r2, #7
 800023e:	f07f 0700 	mvns.w	r7, #0
 8000242:	2300      	movs	r3, #0
 8000244:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000248:	3c08      	subs	r4, #8
 800024a:	ea85 0501 	eor.w	r5, r5, r1
 800024e:	ea86 0601 	eor.w	r6, r6, r1
 8000252:	fa85 f547 	uadd8	r5, r5, r7
 8000256:	faa3 f587 	sel	r5, r3, r7
 800025a:	fa86 f647 	uadd8	r6, r6, r7
 800025e:	faa5 f687 	sel	r6, r5, r7
 8000262:	b98e      	cbnz	r6, 8000288 <memchr+0x78>
 8000264:	d1ee      	bne.n	8000244 <memchr+0x34>
 8000266:	bcf0      	pop	{r4, r5, r6, r7}
 8000268:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800026c:	f002 0207 	and.w	r2, r2, #7
 8000270:	b132      	cbz	r2, 8000280 <memchr+0x70>
 8000272:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000276:	3a01      	subs	r2, #1
 8000278:	ea83 0301 	eor.w	r3, r3, r1
 800027c:	b113      	cbz	r3, 8000284 <memchr+0x74>
 800027e:	d1f8      	bne.n	8000272 <memchr+0x62>
 8000280:	2000      	movs	r0, #0
 8000282:	4770      	bx	lr
 8000284:	3801      	subs	r0, #1
 8000286:	4770      	bx	lr
 8000288:	2d00      	cmp	r5, #0
 800028a:	bf06      	itte	eq
 800028c:	4635      	moveq	r5, r6
 800028e:	3803      	subeq	r0, #3
 8000290:	3807      	subne	r0, #7
 8000292:	f015 0f01 	tst.w	r5, #1
 8000296:	d107      	bne.n	80002a8 <memchr+0x98>
 8000298:	3001      	adds	r0, #1
 800029a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800029e:	bf02      	ittt	eq
 80002a0:	3001      	addeq	r0, #1
 80002a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002a6:	3001      	addeq	r0, #1
 80002a8:	bcf0      	pop	{r4, r5, r6, r7}
 80002aa:	3801      	subs	r0, #1
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop

080002b0 <__aeabi_drsub>:
 80002b0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002b4:	e002      	b.n	80002bc <__adddf3>
 80002b6:	bf00      	nop

080002b8 <__aeabi_dsub>:
 80002b8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002bc <__adddf3>:
 80002bc:	b530      	push	{r4, r5, lr}
 80002be:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002c2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002c6:	ea94 0f05 	teq	r4, r5
 80002ca:	bf08      	it	eq
 80002cc:	ea90 0f02 	teqeq	r0, r2
 80002d0:	bf1f      	itttt	ne
 80002d2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002d6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002da:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002de:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002e2:	f000 80e2 	beq.w	80004aa <__adddf3+0x1ee>
 80002e6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ea:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ee:	bfb8      	it	lt
 80002f0:	426d      	neglt	r5, r5
 80002f2:	dd0c      	ble.n	800030e <__adddf3+0x52>
 80002f4:	442c      	add	r4, r5
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	ea82 0000 	eor.w	r0, r2, r0
 8000302:	ea83 0101 	eor.w	r1, r3, r1
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	2d36      	cmp	r5, #54	; 0x36
 8000310:	bf88      	it	hi
 8000312:	bd30      	pophi	{r4, r5, pc}
 8000314:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000318:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800031c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000320:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x70>
 8000326:	4240      	negs	r0, r0
 8000328:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800032c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000330:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000334:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000338:	d002      	beq.n	8000340 <__adddf3+0x84>
 800033a:	4252      	negs	r2, r2
 800033c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000340:	ea94 0f05 	teq	r4, r5
 8000344:	f000 80a7 	beq.w	8000496 <__adddf3+0x1da>
 8000348:	f1a4 0401 	sub.w	r4, r4, #1
 800034c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000350:	db0d      	blt.n	800036e <__adddf3+0xb2>
 8000352:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000356:	fa22 f205 	lsr.w	r2, r2, r5
 800035a:	1880      	adds	r0, r0, r2
 800035c:	f141 0100 	adc.w	r1, r1, #0
 8000360:	fa03 f20e 	lsl.w	r2, r3, lr
 8000364:	1880      	adds	r0, r0, r2
 8000366:	fa43 f305 	asr.w	r3, r3, r5
 800036a:	4159      	adcs	r1, r3
 800036c:	e00e      	b.n	800038c <__adddf3+0xd0>
 800036e:	f1a5 0520 	sub.w	r5, r5, #32
 8000372:	f10e 0e20 	add.w	lr, lr, #32
 8000376:	2a01      	cmp	r2, #1
 8000378:	fa03 fc0e 	lsl.w	ip, r3, lr
 800037c:	bf28      	it	cs
 800037e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000382:	fa43 f305 	asr.w	r3, r3, r5
 8000386:	18c0      	adds	r0, r0, r3
 8000388:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800038c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000390:	d507      	bpl.n	80003a2 <__adddf3+0xe6>
 8000392:	f04f 0e00 	mov.w	lr, #0
 8000396:	f1dc 0c00 	rsbs	ip, ip, #0
 800039a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800039e:	eb6e 0101 	sbc.w	r1, lr, r1
 80003a2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003a6:	d31b      	bcc.n	80003e0 <__adddf3+0x124>
 80003a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003ac:	d30c      	bcc.n	80003c8 <__adddf3+0x10c>
 80003ae:	0849      	lsrs	r1, r1, #1
 80003b0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003b4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003b8:	f104 0401 	add.w	r4, r4, #1
 80003bc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003c0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003c4:	f080 809a 	bcs.w	80004fc <__adddf3+0x240>
 80003c8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003cc:	bf08      	it	eq
 80003ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003d2:	f150 0000 	adcs.w	r0, r0, #0
 80003d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003da:	ea41 0105 	orr.w	r1, r1, r5
 80003de:	bd30      	pop	{r4, r5, pc}
 80003e0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003e4:	4140      	adcs	r0, r0
 80003e6:	eb41 0101 	adc.w	r1, r1, r1
 80003ea:	3c01      	subs	r4, #1
 80003ec:	bf28      	it	cs
 80003ee:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80003f2:	d2e9      	bcs.n	80003c8 <__adddf3+0x10c>
 80003f4:	f091 0f00 	teq	r1, #0
 80003f8:	bf04      	itt	eq
 80003fa:	4601      	moveq	r1, r0
 80003fc:	2000      	moveq	r0, #0
 80003fe:	fab1 f381 	clz	r3, r1
 8000402:	bf08      	it	eq
 8000404:	3320      	addeq	r3, #32
 8000406:	f1a3 030b 	sub.w	r3, r3, #11
 800040a:	f1b3 0220 	subs.w	r2, r3, #32
 800040e:	da0c      	bge.n	800042a <__adddf3+0x16e>
 8000410:	320c      	adds	r2, #12
 8000412:	dd08      	ble.n	8000426 <__adddf3+0x16a>
 8000414:	f102 0c14 	add.w	ip, r2, #20
 8000418:	f1c2 020c 	rsb	r2, r2, #12
 800041c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000420:	fa21 f102 	lsr.w	r1, r1, r2
 8000424:	e00c      	b.n	8000440 <__adddf3+0x184>
 8000426:	f102 0214 	add.w	r2, r2, #20
 800042a:	bfd8      	it	le
 800042c:	f1c2 0c20 	rsble	ip, r2, #32
 8000430:	fa01 f102 	lsl.w	r1, r1, r2
 8000434:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000438:	bfdc      	itt	le
 800043a:	ea41 010c 	orrle.w	r1, r1, ip
 800043e:	4090      	lslle	r0, r2
 8000440:	1ae4      	subs	r4, r4, r3
 8000442:	bfa2      	ittt	ge
 8000444:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000448:	4329      	orrge	r1, r5
 800044a:	bd30      	popge	{r4, r5, pc}
 800044c:	ea6f 0404 	mvn.w	r4, r4
 8000450:	3c1f      	subs	r4, #31
 8000452:	da1c      	bge.n	800048e <__adddf3+0x1d2>
 8000454:	340c      	adds	r4, #12
 8000456:	dc0e      	bgt.n	8000476 <__adddf3+0x1ba>
 8000458:	f104 0414 	add.w	r4, r4, #20
 800045c:	f1c4 0220 	rsb	r2, r4, #32
 8000460:	fa20 f004 	lsr.w	r0, r0, r4
 8000464:	fa01 f302 	lsl.w	r3, r1, r2
 8000468:	ea40 0003 	orr.w	r0, r0, r3
 800046c:	fa21 f304 	lsr.w	r3, r1, r4
 8000470:	ea45 0103 	orr.w	r1, r5, r3
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f1c4 040c 	rsb	r4, r4, #12
 800047a:	f1c4 0220 	rsb	r2, r4, #32
 800047e:	fa20 f002 	lsr.w	r0, r0, r2
 8000482:	fa01 f304 	lsl.w	r3, r1, r4
 8000486:	ea40 0003 	orr.w	r0, r0, r3
 800048a:	4629      	mov	r1, r5
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	fa21 f004 	lsr.w	r0, r1, r4
 8000492:	4629      	mov	r1, r5
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f094 0f00 	teq	r4, #0
 800049a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800049e:	bf06      	itte	eq
 80004a0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004a4:	3401      	addeq	r4, #1
 80004a6:	3d01      	subne	r5, #1
 80004a8:	e74e      	b.n	8000348 <__adddf3+0x8c>
 80004aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ae:	bf18      	it	ne
 80004b0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004b4:	d029      	beq.n	800050a <__adddf3+0x24e>
 80004b6:	ea94 0f05 	teq	r4, r5
 80004ba:	bf08      	it	eq
 80004bc:	ea90 0f02 	teqeq	r0, r2
 80004c0:	d005      	beq.n	80004ce <__adddf3+0x212>
 80004c2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004c6:	bf04      	itt	eq
 80004c8:	4619      	moveq	r1, r3
 80004ca:	4610      	moveq	r0, r2
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	ea91 0f03 	teq	r1, r3
 80004d2:	bf1e      	ittt	ne
 80004d4:	2100      	movne	r1, #0
 80004d6:	2000      	movne	r0, #0
 80004d8:	bd30      	popne	{r4, r5, pc}
 80004da:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004de:	d105      	bne.n	80004ec <__adddf3+0x230>
 80004e0:	0040      	lsls	r0, r0, #1
 80004e2:	4149      	adcs	r1, r1
 80004e4:	bf28      	it	cs
 80004e6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ea:	bd30      	pop	{r4, r5, pc}
 80004ec:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004f0:	bf3c      	itt	cc
 80004f2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004f6:	bd30      	popcc	{r4, r5, pc}
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000500:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000504:	f04f 0000 	mov.w	r0, #0
 8000508:	bd30      	pop	{r4, r5, pc}
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf1a      	itte	ne
 8000510:	4619      	movne	r1, r3
 8000512:	4610      	movne	r0, r2
 8000514:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000518:	bf1c      	itt	ne
 800051a:	460b      	movne	r3, r1
 800051c:	4602      	movne	r2, r0
 800051e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000522:	bf06      	itte	eq
 8000524:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000528:	ea91 0f03 	teqeq	r1, r3
 800052c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	bf00      	nop

08000534 <__aeabi_ui2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f04f 0500 	mov.w	r5, #0
 800054c:	f04f 0100 	mov.w	r1, #0
 8000550:	e750      	b.n	80003f4 <__adddf3+0x138>
 8000552:	bf00      	nop

08000554 <__aeabi_i2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800056c:	bf48      	it	mi
 800056e:	4240      	negmi	r0, r0
 8000570:	f04f 0100 	mov.w	r1, #0
 8000574:	e73e      	b.n	80003f4 <__adddf3+0x138>
 8000576:	bf00      	nop

08000578 <__aeabi_f2d>:
 8000578:	0042      	lsls	r2, r0, #1
 800057a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800057e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000582:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000586:	bf1f      	itttt	ne
 8000588:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000594:	4770      	bxne	lr
 8000596:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800059a:	bf08      	it	eq
 800059c:	4770      	bxeq	lr
 800059e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005a2:	bf04      	itt	eq
 80005a4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005a8:	4770      	bxeq	lr
 80005aa:	b530      	push	{r4, r5, lr}
 80005ac:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005b0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005b4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005b8:	e71c      	b.n	80003f4 <__adddf3+0x138>
 80005ba:	bf00      	nop

080005bc <__aeabi_ul2d>:
 80005bc:	ea50 0201 	orrs.w	r2, r0, r1
 80005c0:	bf08      	it	eq
 80005c2:	4770      	bxeq	lr
 80005c4:	b530      	push	{r4, r5, lr}
 80005c6:	f04f 0500 	mov.w	r5, #0
 80005ca:	e00a      	b.n	80005e2 <__aeabi_l2d+0x16>

080005cc <__aeabi_l2d>:
 80005cc:	ea50 0201 	orrs.w	r2, r0, r1
 80005d0:	bf08      	it	eq
 80005d2:	4770      	bxeq	lr
 80005d4:	b530      	push	{r4, r5, lr}
 80005d6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005da:	d502      	bpl.n	80005e2 <__aeabi_l2d+0x16>
 80005dc:	4240      	negs	r0, r0
 80005de:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005e2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005e6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005ea:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005ee:	f43f aed8 	beq.w	80003a2 <__adddf3+0xe6>
 80005f2:	f04f 0203 	mov.w	r2, #3
 80005f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005fa:	bf18      	it	ne
 80005fc:	3203      	addne	r2, #3
 80005fe:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000602:	bf18      	it	ne
 8000604:	3203      	addne	r2, #3
 8000606:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800060a:	f1c2 0320 	rsb	r3, r2, #32
 800060e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000612:	fa20 f002 	lsr.w	r0, r0, r2
 8000616:	fa01 fe03 	lsl.w	lr, r1, r3
 800061a:	ea40 000e 	orr.w	r0, r0, lr
 800061e:	fa21 f102 	lsr.w	r1, r1, r2
 8000622:	4414      	add	r4, r2
 8000624:	e6bd      	b.n	80003a2 <__adddf3+0xe6>
 8000626:	bf00      	nop

08000628 <__aeabi_dmul>:
 8000628:	b570      	push	{r4, r5, r6, lr}
 800062a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800062e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000632:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000636:	bf1d      	ittte	ne
 8000638:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800063c:	ea94 0f0c 	teqne	r4, ip
 8000640:	ea95 0f0c 	teqne	r5, ip
 8000644:	f000 f8de 	bleq	8000804 <__aeabi_dmul+0x1dc>
 8000648:	442c      	add	r4, r5
 800064a:	ea81 0603 	eor.w	r6, r1, r3
 800064e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000652:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000656:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800065a:	bf18      	it	ne
 800065c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000660:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000664:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000668:	d038      	beq.n	80006dc <__aeabi_dmul+0xb4>
 800066a:	fba0 ce02 	umull	ip, lr, r0, r2
 800066e:	f04f 0500 	mov.w	r5, #0
 8000672:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000676:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800067a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800067e:	f04f 0600 	mov.w	r6, #0
 8000682:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000686:	f09c 0f00 	teq	ip, #0
 800068a:	bf18      	it	ne
 800068c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000690:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000694:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000698:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800069c:	d204      	bcs.n	80006a8 <__aeabi_dmul+0x80>
 800069e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006a2:	416d      	adcs	r5, r5
 80006a4:	eb46 0606 	adc.w	r6, r6, r6
 80006a8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006ac:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006b0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006b4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006b8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006bc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006c0:	bf88      	it	hi
 80006c2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006c6:	d81e      	bhi.n	8000706 <__aeabi_dmul+0xde>
 80006c8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006cc:	bf08      	it	eq
 80006ce:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006d2:	f150 0000 	adcs.w	r0, r0, #0
 80006d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006da:	bd70      	pop	{r4, r5, r6, pc}
 80006dc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006e0:	ea46 0101 	orr.w	r1, r6, r1
 80006e4:	ea40 0002 	orr.w	r0, r0, r2
 80006e8:	ea81 0103 	eor.w	r1, r1, r3
 80006ec:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006f0:	bfc2      	ittt	gt
 80006f2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006f6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006fa:	bd70      	popgt	{r4, r5, r6, pc}
 80006fc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000700:	f04f 0e00 	mov.w	lr, #0
 8000704:	3c01      	subs	r4, #1
 8000706:	f300 80ab 	bgt.w	8000860 <__aeabi_dmul+0x238>
 800070a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800070e:	bfde      	ittt	le
 8000710:	2000      	movle	r0, #0
 8000712:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000716:	bd70      	pople	{r4, r5, r6, pc}
 8000718:	f1c4 0400 	rsb	r4, r4, #0
 800071c:	3c20      	subs	r4, #32
 800071e:	da35      	bge.n	800078c <__aeabi_dmul+0x164>
 8000720:	340c      	adds	r4, #12
 8000722:	dc1b      	bgt.n	800075c <__aeabi_dmul+0x134>
 8000724:	f104 0414 	add.w	r4, r4, #20
 8000728:	f1c4 0520 	rsb	r5, r4, #32
 800072c:	fa00 f305 	lsl.w	r3, r0, r5
 8000730:	fa20 f004 	lsr.w	r0, r0, r4
 8000734:	fa01 f205 	lsl.w	r2, r1, r5
 8000738:	ea40 0002 	orr.w	r0, r0, r2
 800073c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000740:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000744:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000748:	fa21 f604 	lsr.w	r6, r1, r4
 800074c:	eb42 0106 	adc.w	r1, r2, r6
 8000750:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000754:	bf08      	it	eq
 8000756:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800075a:	bd70      	pop	{r4, r5, r6, pc}
 800075c:	f1c4 040c 	rsb	r4, r4, #12
 8000760:	f1c4 0520 	rsb	r5, r4, #32
 8000764:	fa00 f304 	lsl.w	r3, r0, r4
 8000768:	fa20 f005 	lsr.w	r0, r0, r5
 800076c:	fa01 f204 	lsl.w	r2, r1, r4
 8000770:	ea40 0002 	orr.w	r0, r0, r2
 8000774:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000778:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800077c:	f141 0100 	adc.w	r1, r1, #0
 8000780:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000784:	bf08      	it	eq
 8000786:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800078a:	bd70      	pop	{r4, r5, r6, pc}
 800078c:	f1c4 0520 	rsb	r5, r4, #32
 8000790:	fa00 f205 	lsl.w	r2, r0, r5
 8000794:	ea4e 0e02 	orr.w	lr, lr, r2
 8000798:	fa20 f304 	lsr.w	r3, r0, r4
 800079c:	fa01 f205 	lsl.w	r2, r1, r5
 80007a0:	ea43 0302 	orr.w	r3, r3, r2
 80007a4:	fa21 f004 	lsr.w	r0, r1, r4
 80007a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007ac:	fa21 f204 	lsr.w	r2, r1, r4
 80007b0:	ea20 0002 	bic.w	r0, r0, r2
 80007b4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007b8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007bc:	bf08      	it	eq
 80007be:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007c2:	bd70      	pop	{r4, r5, r6, pc}
 80007c4:	f094 0f00 	teq	r4, #0
 80007c8:	d10f      	bne.n	80007ea <__aeabi_dmul+0x1c2>
 80007ca:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007ce:	0040      	lsls	r0, r0, #1
 80007d0:	eb41 0101 	adc.w	r1, r1, r1
 80007d4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007d8:	bf08      	it	eq
 80007da:	3c01      	subeq	r4, #1
 80007dc:	d0f7      	beq.n	80007ce <__aeabi_dmul+0x1a6>
 80007de:	ea41 0106 	orr.w	r1, r1, r6
 80007e2:	f095 0f00 	teq	r5, #0
 80007e6:	bf18      	it	ne
 80007e8:	4770      	bxne	lr
 80007ea:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007ee:	0052      	lsls	r2, r2, #1
 80007f0:	eb43 0303 	adc.w	r3, r3, r3
 80007f4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007f8:	bf08      	it	eq
 80007fa:	3d01      	subeq	r5, #1
 80007fc:	d0f7      	beq.n	80007ee <__aeabi_dmul+0x1c6>
 80007fe:	ea43 0306 	orr.w	r3, r3, r6
 8000802:	4770      	bx	lr
 8000804:	ea94 0f0c 	teq	r4, ip
 8000808:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800080c:	bf18      	it	ne
 800080e:	ea95 0f0c 	teqne	r5, ip
 8000812:	d00c      	beq.n	800082e <__aeabi_dmul+0x206>
 8000814:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000818:	bf18      	it	ne
 800081a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800081e:	d1d1      	bne.n	80007c4 <__aeabi_dmul+0x19c>
 8000820:	ea81 0103 	eor.w	r1, r1, r3
 8000824:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000828:	f04f 0000 	mov.w	r0, #0
 800082c:	bd70      	pop	{r4, r5, r6, pc}
 800082e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000832:	bf06      	itte	eq
 8000834:	4610      	moveq	r0, r2
 8000836:	4619      	moveq	r1, r3
 8000838:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800083c:	d019      	beq.n	8000872 <__aeabi_dmul+0x24a>
 800083e:	ea94 0f0c 	teq	r4, ip
 8000842:	d102      	bne.n	800084a <__aeabi_dmul+0x222>
 8000844:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000848:	d113      	bne.n	8000872 <__aeabi_dmul+0x24a>
 800084a:	ea95 0f0c 	teq	r5, ip
 800084e:	d105      	bne.n	800085c <__aeabi_dmul+0x234>
 8000850:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000854:	bf1c      	itt	ne
 8000856:	4610      	movne	r0, r2
 8000858:	4619      	movne	r1, r3
 800085a:	d10a      	bne.n	8000872 <__aeabi_dmul+0x24a>
 800085c:	ea81 0103 	eor.w	r1, r1, r3
 8000860:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000864:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000868:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800086c:	f04f 0000 	mov.w	r0, #0
 8000870:	bd70      	pop	{r4, r5, r6, pc}
 8000872:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000876:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800087a:	bd70      	pop	{r4, r5, r6, pc}

0800087c <__aeabi_ddiv>:
 800087c:	b570      	push	{r4, r5, r6, lr}
 800087e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000882:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000886:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800088a:	bf1d      	ittte	ne
 800088c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000890:	ea94 0f0c 	teqne	r4, ip
 8000894:	ea95 0f0c 	teqne	r5, ip
 8000898:	f000 f8a7 	bleq	80009ea <__aeabi_ddiv+0x16e>
 800089c:	eba4 0405 	sub.w	r4, r4, r5
 80008a0:	ea81 0e03 	eor.w	lr, r1, r3
 80008a4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008ac:	f000 8088 	beq.w	80009c0 <__aeabi_ddiv+0x144>
 80008b0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008b4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008b8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008bc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008c0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008c4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008c8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008cc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008d0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008d4:	429d      	cmp	r5, r3
 80008d6:	bf08      	it	eq
 80008d8:	4296      	cmpeq	r6, r2
 80008da:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008de:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008e2:	d202      	bcs.n	80008ea <__aeabi_ddiv+0x6e>
 80008e4:	085b      	lsrs	r3, r3, #1
 80008e6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ea:	1ab6      	subs	r6, r6, r2
 80008ec:	eb65 0503 	sbc.w	r5, r5, r3
 80008f0:	085b      	lsrs	r3, r3, #1
 80008f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008f6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008fa:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008fe:	ebb6 0e02 	subs.w	lr, r6, r2
 8000902:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000906:	bf22      	ittt	cs
 8000908:	1ab6      	subcs	r6, r6, r2
 800090a:	4675      	movcs	r5, lr
 800090c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	ebb6 0e02 	subs.w	lr, r6, r2
 800091a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800091e:	bf22      	ittt	cs
 8000920:	1ab6      	subcs	r6, r6, r2
 8000922:	4675      	movcs	r5, lr
 8000924:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000928:	085b      	lsrs	r3, r3, #1
 800092a:	ea4f 0232 	mov.w	r2, r2, rrx
 800092e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000932:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000936:	bf22      	ittt	cs
 8000938:	1ab6      	subcs	r6, r6, r2
 800093a:	4675      	movcs	r5, lr
 800093c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000940:	085b      	lsrs	r3, r3, #1
 8000942:	ea4f 0232 	mov.w	r2, r2, rrx
 8000946:	ebb6 0e02 	subs.w	lr, r6, r2
 800094a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800094e:	bf22      	ittt	cs
 8000950:	1ab6      	subcs	r6, r6, r2
 8000952:	4675      	movcs	r5, lr
 8000954:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000958:	ea55 0e06 	orrs.w	lr, r5, r6
 800095c:	d018      	beq.n	8000990 <__aeabi_ddiv+0x114>
 800095e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000962:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000966:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800096a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800096e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000972:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000976:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800097a:	d1c0      	bne.n	80008fe <__aeabi_ddiv+0x82>
 800097c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000980:	d10b      	bne.n	800099a <__aeabi_ddiv+0x11e>
 8000982:	ea41 0100 	orr.w	r1, r1, r0
 8000986:	f04f 0000 	mov.w	r0, #0
 800098a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800098e:	e7b6      	b.n	80008fe <__aeabi_ddiv+0x82>
 8000990:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000994:	bf04      	itt	eq
 8000996:	4301      	orreq	r1, r0
 8000998:	2000      	moveq	r0, #0
 800099a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800099e:	bf88      	it	hi
 80009a0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009a4:	f63f aeaf 	bhi.w	8000706 <__aeabi_dmul+0xde>
 80009a8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009ac:	bf04      	itt	eq
 80009ae:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009b2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009b6:	f150 0000 	adcs.w	r0, r0, #0
 80009ba:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009be:	bd70      	pop	{r4, r5, r6, pc}
 80009c0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009c4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009c8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009cc:	bfc2      	ittt	gt
 80009ce:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009d2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009d6:	bd70      	popgt	{r4, r5, r6, pc}
 80009d8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009dc:	f04f 0e00 	mov.w	lr, #0
 80009e0:	3c01      	subs	r4, #1
 80009e2:	e690      	b.n	8000706 <__aeabi_dmul+0xde>
 80009e4:	ea45 0e06 	orr.w	lr, r5, r6
 80009e8:	e68d      	b.n	8000706 <__aeabi_dmul+0xde>
 80009ea:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009ee:	ea94 0f0c 	teq	r4, ip
 80009f2:	bf08      	it	eq
 80009f4:	ea95 0f0c 	teqeq	r5, ip
 80009f8:	f43f af3b 	beq.w	8000872 <__aeabi_dmul+0x24a>
 80009fc:	ea94 0f0c 	teq	r4, ip
 8000a00:	d10a      	bne.n	8000a18 <__aeabi_ddiv+0x19c>
 8000a02:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a06:	f47f af34 	bne.w	8000872 <__aeabi_dmul+0x24a>
 8000a0a:	ea95 0f0c 	teq	r5, ip
 8000a0e:	f47f af25 	bne.w	800085c <__aeabi_dmul+0x234>
 8000a12:	4610      	mov	r0, r2
 8000a14:	4619      	mov	r1, r3
 8000a16:	e72c      	b.n	8000872 <__aeabi_dmul+0x24a>
 8000a18:	ea95 0f0c 	teq	r5, ip
 8000a1c:	d106      	bne.n	8000a2c <__aeabi_ddiv+0x1b0>
 8000a1e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a22:	f43f aefd 	beq.w	8000820 <__aeabi_dmul+0x1f8>
 8000a26:	4610      	mov	r0, r2
 8000a28:	4619      	mov	r1, r3
 8000a2a:	e722      	b.n	8000872 <__aeabi_dmul+0x24a>
 8000a2c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a30:	bf18      	it	ne
 8000a32:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a36:	f47f aec5 	bne.w	80007c4 <__aeabi_dmul+0x19c>
 8000a3a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a3e:	f47f af0d 	bne.w	800085c <__aeabi_dmul+0x234>
 8000a42:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a46:	f47f aeeb 	bne.w	8000820 <__aeabi_dmul+0x1f8>
 8000a4a:	e712      	b.n	8000872 <__aeabi_dmul+0x24a>

08000a4c <__gedf2>:
 8000a4c:	f04f 3cff 	mov.w	ip, #4294967295
 8000a50:	e006      	b.n	8000a60 <__cmpdf2+0x4>
 8000a52:	bf00      	nop

08000a54 <__ledf2>:
 8000a54:	f04f 0c01 	mov.w	ip, #1
 8000a58:	e002      	b.n	8000a60 <__cmpdf2+0x4>
 8000a5a:	bf00      	nop

08000a5c <__cmpdf2>:
 8000a5c:	f04f 0c01 	mov.w	ip, #1
 8000a60:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a64:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a68:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a6c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a70:	bf18      	it	ne
 8000a72:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a76:	d01b      	beq.n	8000ab0 <__cmpdf2+0x54>
 8000a78:	b001      	add	sp, #4
 8000a7a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a7e:	bf0c      	ite	eq
 8000a80:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a84:	ea91 0f03 	teqne	r1, r3
 8000a88:	bf02      	ittt	eq
 8000a8a:	ea90 0f02 	teqeq	r0, r2
 8000a8e:	2000      	moveq	r0, #0
 8000a90:	4770      	bxeq	lr
 8000a92:	f110 0f00 	cmn.w	r0, #0
 8000a96:	ea91 0f03 	teq	r1, r3
 8000a9a:	bf58      	it	pl
 8000a9c:	4299      	cmppl	r1, r3
 8000a9e:	bf08      	it	eq
 8000aa0:	4290      	cmpeq	r0, r2
 8000aa2:	bf2c      	ite	cs
 8000aa4:	17d8      	asrcs	r0, r3, #31
 8000aa6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000aaa:	f040 0001 	orr.w	r0, r0, #1
 8000aae:	4770      	bx	lr
 8000ab0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000ab4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ab8:	d102      	bne.n	8000ac0 <__cmpdf2+0x64>
 8000aba:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000abe:	d107      	bne.n	8000ad0 <__cmpdf2+0x74>
 8000ac0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ac4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ac8:	d1d6      	bne.n	8000a78 <__cmpdf2+0x1c>
 8000aca:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000ace:	d0d3      	beq.n	8000a78 <__cmpdf2+0x1c>
 8000ad0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000ad4:	4770      	bx	lr
 8000ad6:	bf00      	nop

08000ad8 <__aeabi_cdrcmple>:
 8000ad8:	4684      	mov	ip, r0
 8000ada:	4610      	mov	r0, r2
 8000adc:	4662      	mov	r2, ip
 8000ade:	468c      	mov	ip, r1
 8000ae0:	4619      	mov	r1, r3
 8000ae2:	4663      	mov	r3, ip
 8000ae4:	e000      	b.n	8000ae8 <__aeabi_cdcmpeq>
 8000ae6:	bf00      	nop

08000ae8 <__aeabi_cdcmpeq>:
 8000ae8:	b501      	push	{r0, lr}
 8000aea:	f7ff ffb7 	bl	8000a5c <__cmpdf2>
 8000aee:	2800      	cmp	r0, #0
 8000af0:	bf48      	it	mi
 8000af2:	f110 0f00 	cmnmi.w	r0, #0
 8000af6:	bd01      	pop	{r0, pc}

08000af8 <__aeabi_dcmpeq>:
 8000af8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000afc:	f7ff fff4 	bl	8000ae8 <__aeabi_cdcmpeq>
 8000b00:	bf0c      	ite	eq
 8000b02:	2001      	moveq	r0, #1
 8000b04:	2000      	movne	r0, #0
 8000b06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b0a:	bf00      	nop

08000b0c <__aeabi_dcmplt>:
 8000b0c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b10:	f7ff ffea 	bl	8000ae8 <__aeabi_cdcmpeq>
 8000b14:	bf34      	ite	cc
 8000b16:	2001      	movcc	r0, #1
 8000b18:	2000      	movcs	r0, #0
 8000b1a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b1e:	bf00      	nop

08000b20 <__aeabi_dcmple>:
 8000b20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b24:	f7ff ffe0 	bl	8000ae8 <__aeabi_cdcmpeq>
 8000b28:	bf94      	ite	ls
 8000b2a:	2001      	movls	r0, #1
 8000b2c:	2000      	movhi	r0, #0
 8000b2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b32:	bf00      	nop

08000b34 <__aeabi_dcmpge>:
 8000b34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b38:	f7ff ffce 	bl	8000ad8 <__aeabi_cdrcmple>
 8000b3c:	bf94      	ite	ls
 8000b3e:	2001      	movls	r0, #1
 8000b40:	2000      	movhi	r0, #0
 8000b42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b46:	bf00      	nop

08000b48 <__aeabi_dcmpgt>:
 8000b48:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b4c:	f7ff ffc4 	bl	8000ad8 <__aeabi_cdrcmple>
 8000b50:	bf34      	ite	cc
 8000b52:	2001      	movcc	r0, #1
 8000b54:	2000      	movcs	r0, #0
 8000b56:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b5a:	bf00      	nop

08000b5c <__aeabi_dcmpun>:
 8000b5c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b64:	d102      	bne.n	8000b6c <__aeabi_dcmpun+0x10>
 8000b66:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b6a:	d10a      	bne.n	8000b82 <__aeabi_dcmpun+0x26>
 8000b6c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b70:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b74:	d102      	bne.n	8000b7c <__aeabi_dcmpun+0x20>
 8000b76:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b7a:	d102      	bne.n	8000b82 <__aeabi_dcmpun+0x26>
 8000b7c:	f04f 0000 	mov.w	r0, #0
 8000b80:	4770      	bx	lr
 8000b82:	f04f 0001 	mov.w	r0, #1
 8000b86:	4770      	bx	lr

08000b88 <__aeabi_d2iz>:
 8000b88:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b8c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000b90:	d215      	bcs.n	8000bbe <__aeabi_d2iz+0x36>
 8000b92:	d511      	bpl.n	8000bb8 <__aeabi_d2iz+0x30>
 8000b94:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000b98:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b9c:	d912      	bls.n	8000bc4 <__aeabi_d2iz+0x3c>
 8000b9e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ba2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000ba6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000baa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000bae:	fa23 f002 	lsr.w	r0, r3, r2
 8000bb2:	bf18      	it	ne
 8000bb4:	4240      	negne	r0, r0
 8000bb6:	4770      	bx	lr
 8000bb8:	f04f 0000 	mov.w	r0, #0
 8000bbc:	4770      	bx	lr
 8000bbe:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000bc2:	d105      	bne.n	8000bd0 <__aeabi_d2iz+0x48>
 8000bc4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000bc8:	bf08      	it	eq
 8000bca:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000bce:	4770      	bx	lr
 8000bd0:	f04f 0000 	mov.w	r0, #0
 8000bd4:	4770      	bx	lr
 8000bd6:	bf00      	nop

08000bd8 <__aeabi_uldivmod>:
 8000bd8:	b953      	cbnz	r3, 8000bf0 <__aeabi_uldivmod+0x18>
 8000bda:	b94a      	cbnz	r2, 8000bf0 <__aeabi_uldivmod+0x18>
 8000bdc:	2900      	cmp	r1, #0
 8000bde:	bf08      	it	eq
 8000be0:	2800      	cmpeq	r0, #0
 8000be2:	bf1c      	itt	ne
 8000be4:	f04f 31ff 	movne.w	r1, #4294967295
 8000be8:	f04f 30ff 	movne.w	r0, #4294967295
 8000bec:	f000 b970 	b.w	8000ed0 <__aeabi_idiv0>
 8000bf0:	f1ad 0c08 	sub.w	ip, sp, #8
 8000bf4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000bf8:	f000 f806 	bl	8000c08 <__udivmoddi4>
 8000bfc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000c00:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000c04:	b004      	add	sp, #16
 8000c06:	4770      	bx	lr

08000c08 <__udivmoddi4>:
 8000c08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000c0c:	9e08      	ldr	r6, [sp, #32]
 8000c0e:	460d      	mov	r5, r1
 8000c10:	4604      	mov	r4, r0
 8000c12:	460f      	mov	r7, r1
 8000c14:	2b00      	cmp	r3, #0
 8000c16:	d14a      	bne.n	8000cae <__udivmoddi4+0xa6>
 8000c18:	428a      	cmp	r2, r1
 8000c1a:	4694      	mov	ip, r2
 8000c1c:	d965      	bls.n	8000cea <__udivmoddi4+0xe2>
 8000c1e:	fab2 f382 	clz	r3, r2
 8000c22:	b143      	cbz	r3, 8000c36 <__udivmoddi4+0x2e>
 8000c24:	fa02 fc03 	lsl.w	ip, r2, r3
 8000c28:	f1c3 0220 	rsb	r2, r3, #32
 8000c2c:	409f      	lsls	r7, r3
 8000c2e:	fa20 f202 	lsr.w	r2, r0, r2
 8000c32:	4317      	orrs	r7, r2
 8000c34:	409c      	lsls	r4, r3
 8000c36:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000c3a:	fa1f f58c 	uxth.w	r5, ip
 8000c3e:	fbb7 f1fe 	udiv	r1, r7, lr
 8000c42:	0c22      	lsrs	r2, r4, #16
 8000c44:	fb0e 7711 	mls	r7, lr, r1, r7
 8000c48:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000c4c:	fb01 f005 	mul.w	r0, r1, r5
 8000c50:	4290      	cmp	r0, r2
 8000c52:	d90a      	bls.n	8000c6a <__udivmoddi4+0x62>
 8000c54:	eb1c 0202 	adds.w	r2, ip, r2
 8000c58:	f101 37ff 	add.w	r7, r1, #4294967295
 8000c5c:	f080 811c 	bcs.w	8000e98 <__udivmoddi4+0x290>
 8000c60:	4290      	cmp	r0, r2
 8000c62:	f240 8119 	bls.w	8000e98 <__udivmoddi4+0x290>
 8000c66:	3902      	subs	r1, #2
 8000c68:	4462      	add	r2, ip
 8000c6a:	1a12      	subs	r2, r2, r0
 8000c6c:	b2a4      	uxth	r4, r4
 8000c6e:	fbb2 f0fe 	udiv	r0, r2, lr
 8000c72:	fb0e 2210 	mls	r2, lr, r0, r2
 8000c76:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000c7a:	fb00 f505 	mul.w	r5, r0, r5
 8000c7e:	42a5      	cmp	r5, r4
 8000c80:	d90a      	bls.n	8000c98 <__udivmoddi4+0x90>
 8000c82:	eb1c 0404 	adds.w	r4, ip, r4
 8000c86:	f100 32ff 	add.w	r2, r0, #4294967295
 8000c8a:	f080 8107 	bcs.w	8000e9c <__udivmoddi4+0x294>
 8000c8e:	42a5      	cmp	r5, r4
 8000c90:	f240 8104 	bls.w	8000e9c <__udivmoddi4+0x294>
 8000c94:	4464      	add	r4, ip
 8000c96:	3802      	subs	r0, #2
 8000c98:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000c9c:	1b64      	subs	r4, r4, r5
 8000c9e:	2100      	movs	r1, #0
 8000ca0:	b11e      	cbz	r6, 8000caa <__udivmoddi4+0xa2>
 8000ca2:	40dc      	lsrs	r4, r3
 8000ca4:	2300      	movs	r3, #0
 8000ca6:	e9c6 4300 	strd	r4, r3, [r6]
 8000caa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000cae:	428b      	cmp	r3, r1
 8000cb0:	d908      	bls.n	8000cc4 <__udivmoddi4+0xbc>
 8000cb2:	2e00      	cmp	r6, #0
 8000cb4:	f000 80ed 	beq.w	8000e92 <__udivmoddi4+0x28a>
 8000cb8:	2100      	movs	r1, #0
 8000cba:	e9c6 0500 	strd	r0, r5, [r6]
 8000cbe:	4608      	mov	r0, r1
 8000cc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000cc4:	fab3 f183 	clz	r1, r3
 8000cc8:	2900      	cmp	r1, #0
 8000cca:	d149      	bne.n	8000d60 <__udivmoddi4+0x158>
 8000ccc:	42ab      	cmp	r3, r5
 8000cce:	d302      	bcc.n	8000cd6 <__udivmoddi4+0xce>
 8000cd0:	4282      	cmp	r2, r0
 8000cd2:	f200 80f8 	bhi.w	8000ec6 <__udivmoddi4+0x2be>
 8000cd6:	1a84      	subs	r4, r0, r2
 8000cd8:	eb65 0203 	sbc.w	r2, r5, r3
 8000cdc:	2001      	movs	r0, #1
 8000cde:	4617      	mov	r7, r2
 8000ce0:	2e00      	cmp	r6, #0
 8000ce2:	d0e2      	beq.n	8000caa <__udivmoddi4+0xa2>
 8000ce4:	e9c6 4700 	strd	r4, r7, [r6]
 8000ce8:	e7df      	b.n	8000caa <__udivmoddi4+0xa2>
 8000cea:	b902      	cbnz	r2, 8000cee <__udivmoddi4+0xe6>
 8000cec:	deff      	udf	#255	; 0xff
 8000cee:	fab2 f382 	clz	r3, r2
 8000cf2:	2b00      	cmp	r3, #0
 8000cf4:	f040 8090 	bne.w	8000e18 <__udivmoddi4+0x210>
 8000cf8:	1a8a      	subs	r2, r1, r2
 8000cfa:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000cfe:	fa1f fe8c 	uxth.w	lr, ip
 8000d02:	2101      	movs	r1, #1
 8000d04:	fbb2 f5f7 	udiv	r5, r2, r7
 8000d08:	fb07 2015 	mls	r0, r7, r5, r2
 8000d0c:	0c22      	lsrs	r2, r4, #16
 8000d0e:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000d12:	fb0e f005 	mul.w	r0, lr, r5
 8000d16:	4290      	cmp	r0, r2
 8000d18:	d908      	bls.n	8000d2c <__udivmoddi4+0x124>
 8000d1a:	eb1c 0202 	adds.w	r2, ip, r2
 8000d1e:	f105 38ff 	add.w	r8, r5, #4294967295
 8000d22:	d202      	bcs.n	8000d2a <__udivmoddi4+0x122>
 8000d24:	4290      	cmp	r0, r2
 8000d26:	f200 80cb 	bhi.w	8000ec0 <__udivmoddi4+0x2b8>
 8000d2a:	4645      	mov	r5, r8
 8000d2c:	1a12      	subs	r2, r2, r0
 8000d2e:	b2a4      	uxth	r4, r4
 8000d30:	fbb2 f0f7 	udiv	r0, r2, r7
 8000d34:	fb07 2210 	mls	r2, r7, r0, r2
 8000d38:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000d3c:	fb0e fe00 	mul.w	lr, lr, r0
 8000d40:	45a6      	cmp	lr, r4
 8000d42:	d908      	bls.n	8000d56 <__udivmoddi4+0x14e>
 8000d44:	eb1c 0404 	adds.w	r4, ip, r4
 8000d48:	f100 32ff 	add.w	r2, r0, #4294967295
 8000d4c:	d202      	bcs.n	8000d54 <__udivmoddi4+0x14c>
 8000d4e:	45a6      	cmp	lr, r4
 8000d50:	f200 80bb 	bhi.w	8000eca <__udivmoddi4+0x2c2>
 8000d54:	4610      	mov	r0, r2
 8000d56:	eba4 040e 	sub.w	r4, r4, lr
 8000d5a:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8000d5e:	e79f      	b.n	8000ca0 <__udivmoddi4+0x98>
 8000d60:	f1c1 0720 	rsb	r7, r1, #32
 8000d64:	408b      	lsls	r3, r1
 8000d66:	fa22 fc07 	lsr.w	ip, r2, r7
 8000d6a:	ea4c 0c03 	orr.w	ip, ip, r3
 8000d6e:	fa05 f401 	lsl.w	r4, r5, r1
 8000d72:	fa20 f307 	lsr.w	r3, r0, r7
 8000d76:	40fd      	lsrs	r5, r7
 8000d78:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8000d7c:	4323      	orrs	r3, r4
 8000d7e:	fbb5 f8f9 	udiv	r8, r5, r9
 8000d82:	fa1f fe8c 	uxth.w	lr, ip
 8000d86:	fb09 5518 	mls	r5, r9, r8, r5
 8000d8a:	0c1c      	lsrs	r4, r3, #16
 8000d8c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000d90:	fb08 f50e 	mul.w	r5, r8, lr
 8000d94:	42a5      	cmp	r5, r4
 8000d96:	fa02 f201 	lsl.w	r2, r2, r1
 8000d9a:	fa00 f001 	lsl.w	r0, r0, r1
 8000d9e:	d90b      	bls.n	8000db8 <__udivmoddi4+0x1b0>
 8000da0:	eb1c 0404 	adds.w	r4, ip, r4
 8000da4:	f108 3aff 	add.w	sl, r8, #4294967295
 8000da8:	f080 8088 	bcs.w	8000ebc <__udivmoddi4+0x2b4>
 8000dac:	42a5      	cmp	r5, r4
 8000dae:	f240 8085 	bls.w	8000ebc <__udivmoddi4+0x2b4>
 8000db2:	f1a8 0802 	sub.w	r8, r8, #2
 8000db6:	4464      	add	r4, ip
 8000db8:	1b64      	subs	r4, r4, r5
 8000dba:	b29d      	uxth	r5, r3
 8000dbc:	fbb4 f3f9 	udiv	r3, r4, r9
 8000dc0:	fb09 4413 	mls	r4, r9, r3, r4
 8000dc4:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8000dc8:	fb03 fe0e 	mul.w	lr, r3, lr
 8000dcc:	45a6      	cmp	lr, r4
 8000dce:	d908      	bls.n	8000de2 <__udivmoddi4+0x1da>
 8000dd0:	eb1c 0404 	adds.w	r4, ip, r4
 8000dd4:	f103 35ff 	add.w	r5, r3, #4294967295
 8000dd8:	d26c      	bcs.n	8000eb4 <__udivmoddi4+0x2ac>
 8000dda:	45a6      	cmp	lr, r4
 8000ddc:	d96a      	bls.n	8000eb4 <__udivmoddi4+0x2ac>
 8000dde:	3b02      	subs	r3, #2
 8000de0:	4464      	add	r4, ip
 8000de2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000de6:	fba3 9502 	umull	r9, r5, r3, r2
 8000dea:	eba4 040e 	sub.w	r4, r4, lr
 8000dee:	42ac      	cmp	r4, r5
 8000df0:	46c8      	mov	r8, r9
 8000df2:	46ae      	mov	lr, r5
 8000df4:	d356      	bcc.n	8000ea4 <__udivmoddi4+0x29c>
 8000df6:	d053      	beq.n	8000ea0 <__udivmoddi4+0x298>
 8000df8:	b156      	cbz	r6, 8000e10 <__udivmoddi4+0x208>
 8000dfa:	ebb0 0208 	subs.w	r2, r0, r8
 8000dfe:	eb64 040e 	sbc.w	r4, r4, lr
 8000e02:	fa04 f707 	lsl.w	r7, r4, r7
 8000e06:	40ca      	lsrs	r2, r1
 8000e08:	40cc      	lsrs	r4, r1
 8000e0a:	4317      	orrs	r7, r2
 8000e0c:	e9c6 7400 	strd	r7, r4, [r6]
 8000e10:	4618      	mov	r0, r3
 8000e12:	2100      	movs	r1, #0
 8000e14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000e18:	f1c3 0120 	rsb	r1, r3, #32
 8000e1c:	fa02 fc03 	lsl.w	ip, r2, r3
 8000e20:	fa20 f201 	lsr.w	r2, r0, r1
 8000e24:	fa25 f101 	lsr.w	r1, r5, r1
 8000e28:	409d      	lsls	r5, r3
 8000e2a:	432a      	orrs	r2, r5
 8000e2c:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000e30:	fa1f fe8c 	uxth.w	lr, ip
 8000e34:	fbb1 f0f7 	udiv	r0, r1, r7
 8000e38:	fb07 1510 	mls	r5, r7, r0, r1
 8000e3c:	0c11      	lsrs	r1, r2, #16
 8000e3e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000e42:	fb00 f50e 	mul.w	r5, r0, lr
 8000e46:	428d      	cmp	r5, r1
 8000e48:	fa04 f403 	lsl.w	r4, r4, r3
 8000e4c:	d908      	bls.n	8000e60 <__udivmoddi4+0x258>
 8000e4e:	eb1c 0101 	adds.w	r1, ip, r1
 8000e52:	f100 38ff 	add.w	r8, r0, #4294967295
 8000e56:	d22f      	bcs.n	8000eb8 <__udivmoddi4+0x2b0>
 8000e58:	428d      	cmp	r5, r1
 8000e5a:	d92d      	bls.n	8000eb8 <__udivmoddi4+0x2b0>
 8000e5c:	3802      	subs	r0, #2
 8000e5e:	4461      	add	r1, ip
 8000e60:	1b49      	subs	r1, r1, r5
 8000e62:	b292      	uxth	r2, r2
 8000e64:	fbb1 f5f7 	udiv	r5, r1, r7
 8000e68:	fb07 1115 	mls	r1, r7, r5, r1
 8000e6c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000e70:	fb05 f10e 	mul.w	r1, r5, lr
 8000e74:	4291      	cmp	r1, r2
 8000e76:	d908      	bls.n	8000e8a <__udivmoddi4+0x282>
 8000e78:	eb1c 0202 	adds.w	r2, ip, r2
 8000e7c:	f105 38ff 	add.w	r8, r5, #4294967295
 8000e80:	d216      	bcs.n	8000eb0 <__udivmoddi4+0x2a8>
 8000e82:	4291      	cmp	r1, r2
 8000e84:	d914      	bls.n	8000eb0 <__udivmoddi4+0x2a8>
 8000e86:	3d02      	subs	r5, #2
 8000e88:	4462      	add	r2, ip
 8000e8a:	1a52      	subs	r2, r2, r1
 8000e8c:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000e90:	e738      	b.n	8000d04 <__udivmoddi4+0xfc>
 8000e92:	4631      	mov	r1, r6
 8000e94:	4630      	mov	r0, r6
 8000e96:	e708      	b.n	8000caa <__udivmoddi4+0xa2>
 8000e98:	4639      	mov	r1, r7
 8000e9a:	e6e6      	b.n	8000c6a <__udivmoddi4+0x62>
 8000e9c:	4610      	mov	r0, r2
 8000e9e:	e6fb      	b.n	8000c98 <__udivmoddi4+0x90>
 8000ea0:	4548      	cmp	r0, r9
 8000ea2:	d2a9      	bcs.n	8000df8 <__udivmoddi4+0x1f0>
 8000ea4:	ebb9 0802 	subs.w	r8, r9, r2
 8000ea8:	eb65 0e0c 	sbc.w	lr, r5, ip
 8000eac:	3b01      	subs	r3, #1
 8000eae:	e7a3      	b.n	8000df8 <__udivmoddi4+0x1f0>
 8000eb0:	4645      	mov	r5, r8
 8000eb2:	e7ea      	b.n	8000e8a <__udivmoddi4+0x282>
 8000eb4:	462b      	mov	r3, r5
 8000eb6:	e794      	b.n	8000de2 <__udivmoddi4+0x1da>
 8000eb8:	4640      	mov	r0, r8
 8000eba:	e7d1      	b.n	8000e60 <__udivmoddi4+0x258>
 8000ebc:	46d0      	mov	r8, sl
 8000ebe:	e77b      	b.n	8000db8 <__udivmoddi4+0x1b0>
 8000ec0:	3d02      	subs	r5, #2
 8000ec2:	4462      	add	r2, ip
 8000ec4:	e732      	b.n	8000d2c <__udivmoddi4+0x124>
 8000ec6:	4608      	mov	r0, r1
 8000ec8:	e70a      	b.n	8000ce0 <__udivmoddi4+0xd8>
 8000eca:	4464      	add	r4, ip
 8000ecc:	3802      	subs	r0, #2
 8000ece:	e742      	b.n	8000d56 <__udivmoddi4+0x14e>

08000ed0 <__aeabi_idiv0>:
 8000ed0:	4770      	bx	lr
 8000ed2:	bf00      	nop

08000ed4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Set stack pointer */
 8000ed4:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000f0c <LoopForever+0x2>

/* Call the clock system initialization function.*/
    bl  SystemInit
 8000ed8:	f006 f81e 	bl	8006f18 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8000edc:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8000ede:	e003      	b.n	8000ee8 <LoopCopyDataInit>

08000ee0 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000ee0:	4b0b      	ldr	r3, [pc, #44]	; (8000f10 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8000ee2:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000ee4:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8000ee6:	3104      	adds	r1, #4

08000ee8 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8000ee8:	480a      	ldr	r0, [pc, #40]	; (8000f14 <LoopForever+0xa>)
	ldr	r3, =_edata
 8000eea:	4b0b      	ldr	r3, [pc, #44]	; (8000f18 <LoopForever+0xe>)
	adds	r2, r0, r1
 8000eec:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000eee:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8000ef0:	d3f6      	bcc.n	8000ee0 <CopyDataInit>
	ldr	r2, =_sbss
 8000ef2:	4a0a      	ldr	r2, [pc, #40]	; (8000f1c <LoopForever+0x12>)
	b	LoopFillZerobss
 8000ef4:	e002      	b.n	8000efc <LoopFillZerobss>

08000ef6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8000ef6:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8000ef8:	f842 3b04 	str.w	r3, [r2], #4

08000efc <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8000efc:	4b08      	ldr	r3, [pc, #32]	; (8000f20 <LoopForever+0x16>)
	cmp	r2, r3
 8000efe:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8000f00:	d3f9      	bcc.n	8000ef6 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8000f02:	f024 ffd5 	bl	8025eb0 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000f06:	f000 fa29 	bl	800135c <main>

08000f0a <LoopForever>:

LoopForever:
    b LoopForever
 8000f0a:	e7fe      	b.n	8000f0a <LoopForever>
  ldr   sp, =_estack    /* Set stack pointer */
 8000f0c:	20028000 	.word	0x20028000
	ldr	r3, =_sidata
 8000f10:	080367bc 	.word	0x080367bc
	ldr	r0, =_sdata
 8000f14:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8000f18:	20000904 	.word	0x20000904
	ldr	r2, =_sbss
 8000f1c:	20000904 	.word	0x20000904
	ldr	r3, = _ebss
 8000f20:	200120a8 	.word	0x200120a8

08000f24 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000f24:	e7fe      	b.n	8000f24 <ADC1_IRQHandler>
	...

08000f28 <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8000f28:	b500      	push	{lr}
 8000f2a:	b087      	sub	sp, #28
  ADC_ChannelConfTypeDef sConfig = {0};
 8000f2c:	2300      	movs	r3, #0
 8000f2e:	9300      	str	r3, [sp, #0]
 8000f30:	9301      	str	r3, [sp, #4]
 8000f32:	9302      	str	r3, [sp, #8]
 8000f34:	9303      	str	r3, [sp, #12]
 8000f36:	9304      	str	r3, [sp, #16]
 8000f38:	9305      	str	r3, [sp, #20]

  /** Common config 
  */
  hadc1.Instance = ADC1;
 8000f3a:	4819      	ldr	r0, [pc, #100]	; (8000fa0 <MX_ADC1_Init+0x78>)
 8000f3c:	4a19      	ldr	r2, [pc, #100]	; (8000fa4 <MX_ADC1_Init+0x7c>)
 8000f3e:	6002      	str	r2, [r0, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8000f40:	6043      	str	r3, [r0, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000f42:	6083      	str	r3, [r0, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000f44:	60c3      	str	r3, [r0, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000f46:	6103      	str	r3, [r0, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000f48:	2204      	movs	r2, #4
 8000f4a:	6142      	str	r2, [r0, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000f4c:	7603      	strb	r3, [r0, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000f4e:	7643      	strb	r3, [r0, #25]
  hadc1.Init.NbrOfConversion = 1;
 8000f50:	2201      	movs	r2, #1
 8000f52:	61c2      	str	r2, [r0, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000f54:	f880 3020 	strb.w	r3, [r0, #32]
  hadc1.Init.NbrOfDiscConversion = 1;
 8000f58:	6242      	str	r2, [r0, #36]	; 0x24
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000f5a:	6283      	str	r3, [r0, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000f5c:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8000f5e:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000f62:	6343      	str	r3, [r0, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 8000f64:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000f68:	f006 f830 	bl	8006fcc <HAL_ADC_Init>
 8000f6c:	b990      	cbnz	r0, 8000f94 <MX_ADC1_Init+0x6c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_1;
 8000f6e:	4b0e      	ldr	r3, [pc, #56]	; (8000fa8 <MX_ADC1_Init+0x80>)
 8000f70:	9300      	str	r3, [sp, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000f72:	2306      	movs	r3, #6
 8000f74:	9301      	str	r3, [sp, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 8000f76:	2300      	movs	r3, #0
 8000f78:	9302      	str	r3, [sp, #8]
  sConfig.SingleDiff = ADC_DIFFERENTIAL_ENDED;
 8000f7a:	4a0c      	ldr	r2, [pc, #48]	; (8000fac <MX_ADC1_Init+0x84>)
 8000f7c:	9203      	str	r2, [sp, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000f7e:	2204      	movs	r2, #4
 8000f80:	9204      	str	r2, [sp, #16]
  sConfig.Offset = 0;
 8000f82:	9305      	str	r3, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f84:	4669      	mov	r1, sp
 8000f86:	4806      	ldr	r0, [pc, #24]	; (8000fa0 <MX_ADC1_Init+0x78>)
 8000f88:	f006 f90e 	bl	80071a8 <HAL_ADC_ConfigChannel>
 8000f8c:	b928      	cbnz	r0, 8000f9a <MX_ADC1_Init+0x72>
  {
    Error_Handler();
  }

}
 8000f8e:	b007      	add	sp, #28
 8000f90:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8000f94:	f000 f950 	bl	8001238 <Error_Handler>
 8000f98:	e7e9      	b.n	8000f6e <MX_ADC1_Init+0x46>
    Error_Handler();
 8000f9a:	f000 f94d 	bl	8001238 <Error_Handler>
}
 8000f9e:	e7f6      	b.n	8000f8e <MX_ADC1_Init+0x66>
 8000fa0:	20000920 	.word	0x20000920
 8000fa4:	50040000 	.word	0x50040000
 8000fa8:	04300002 	.word	0x04300002
 8000fac:	407f0000 	.word	0x407f0000

08000fb0 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8000fb0:	b500      	push	{lr}
 8000fb2:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000fb4:	2300      	movs	r3, #0
 8000fb6:	9301      	str	r3, [sp, #4]
 8000fb8:	9302      	str	r3, [sp, #8]
 8000fba:	9303      	str	r3, [sp, #12]
 8000fbc:	9304      	str	r3, [sp, #16]
 8000fbe:	9305      	str	r3, [sp, #20]
  if(adcHandle->Instance==ADC1)
 8000fc0:	6802      	ldr	r2, [r0, #0]
 8000fc2:	4b0e      	ldr	r3, [pc, #56]	; (8000ffc <HAL_ADC_MspInit+0x4c>)
 8000fc4:	429a      	cmp	r2, r3
 8000fc6:	d002      	beq.n	8000fce <HAL_ADC_MspInit+0x1e>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8000fc8:	b007      	add	sp, #28
 8000fca:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_ADC_CLK_ENABLE();
 8000fce:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 8000fd2:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
 8000fd6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fd8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000fdc:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fde:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fe0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000fe4:	9300      	str	r3, [sp, #0]
 8000fe6:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = ARD_A4_Pin|ARD_A2_Pin|ARD_A5_Pin|ARD_A3_Pin;
 8000fe8:	230f      	movs	r3, #15
 8000fea:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 8000fec:	230b      	movs	r3, #11
 8000fee:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ff0:	a901      	add	r1, sp, #4
 8000ff2:	4803      	ldr	r0, [pc, #12]	; (8001000 <HAL_ADC_MspInit+0x50>)
 8000ff4:	f006 fbf8 	bl	80077e8 <HAL_GPIO_Init>
}
 8000ff8:	e7e6      	b.n	8000fc8 <HAL_ADC_MspInit+0x18>
 8000ffa:	bf00      	nop
 8000ffc:	50040000 	.word	0x50040000
 8001000:	48000800 	.word	0x48000800

08001004 <MX_GPIO_Init>:
        * Free pins are configured automatically as Analog (this feature is enabled through 
        * the Code Generation settings)
     PA8   ------> RCC_MCO
*/
void MX_GPIO_Init(void)
{
 8001004:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001008:	b08a      	sub	sp, #40	; 0x28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800100a:	2400      	movs	r4, #0
 800100c:	9405      	str	r4, [sp, #20]
 800100e:	9406      	str	r4, [sp, #24]
 8001010:	9407      	str	r4, [sp, #28]
 8001012:	9408      	str	r4, [sp, #32]
 8001014:	9409      	str	r4, [sp, #36]	; 0x24

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001016:	4b43      	ldr	r3, [pc, #268]	; (8001124 <MX_GPIO_Init+0x120>)
 8001018:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800101a:	f042 0201 	orr.w	r2, r2, #1
 800101e:	64da      	str	r2, [r3, #76]	; 0x4c
 8001020:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001022:	f002 0201 	and.w	r2, r2, #1
 8001026:	9200      	str	r2, [sp, #0]
 8001028:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800102a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800102c:	f042 0204 	orr.w	r2, r2, #4
 8001030:	64da      	str	r2, [r3, #76]	; 0x4c
 8001032:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001034:	f002 0204 	and.w	r2, r2, #4
 8001038:	9201      	str	r2, [sp, #4]
 800103a:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800103c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800103e:	f042 0202 	orr.w	r2, r2, #2
 8001042:	64da      	str	r2, [r3, #76]	; 0x4c
 8001044:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001046:	f002 0202 	and.w	r2, r2, #2
 800104a:	9202      	str	r2, [sp, #8]
 800104c:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800104e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001050:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001054:	64da      	str	r2, [r3, #76]	; 0x4c
 8001056:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001058:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800105c:	9203      	str	r2, [sp, #12]
 800105e:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8001060:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001062:	f042 0208 	orr.w	r2, r2, #8
 8001066:	64da      	str	r2, [r3, #76]	; 0x4c
 8001068:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800106a:	f003 0308 	and.w	r3, r3, #8
 800106e:	9304      	str	r3, [sp, #16]
 8001070:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, MDM_PWR_EN_OUT_Pin|MDM_RST_OUT_Pin|LED2_Pin|LED3_Pin 
 8001072:	4d2d      	ldr	r5, [pc, #180]	; (8001128 <MX_GPIO_Init+0x124>)
 8001074:	4622      	mov	r2, r4
 8001076:	f24c 01c4 	movw	r1, #49348	; 0xc0c4
 800107a:	4628      	mov	r0, r5
 800107c:	f006 fd13 	bl	8007aa6 <HAL_GPIO_WritePin>
                          |ST33_VCC_CTRL_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, LED1_Pin|MDM_DTR_OUT_Pin, GPIO_PIN_RESET);
 8001080:	4e2a      	ldr	r6, [pc, #168]	; (800112c <MX_GPIO_Init+0x128>)
 8001082:	4622      	mov	r2, r4
 8001084:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8001088:	4630      	mov	r0, r6
 800108a:	f006 fd0c 	bl	8007aa6 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin 
                           PBPin */
  GPIO_InitStruct.Pin = MDM_PWR_EN_OUT_Pin|MDM_RST_OUT_Pin|LED2_Pin|LED3_Pin 
 800108e:	f24c 03c4 	movw	r3, #49348	; 0xc0c4
 8001092:	9305      	str	r3, [sp, #20]
                          |ST33_VCC_CTRL_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001094:	2701      	movs	r7, #1
 8001096:	9706      	str	r7, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001098:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800109a:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800109c:	a905      	add	r1, sp, #20
 800109e:	4628      	mov	r0, r5
 80010a0:	f006 fba2 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PH3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 80010a4:	2308      	movs	r3, #8
 80010a6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80010a8:	f04f 0803 	mov.w	r8, #3
 80010ac:	f8cd 8018 	str.w	r8, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010b0:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80010b2:	a905      	add	r1, sp, #20
 80010b4:	481e      	ldr	r0, [pc, #120]	; (8001130 <MX_GPIO_Init+0x12c>)
 80010b6:	f006 fb97 	bl	80077e8 <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct); */

  /*Configure GPIO pin : PC7 */
  GPIO_InitStruct.Pin = GPIO_PIN_7;
 80010ba:	2380      	movs	r3, #128	; 0x80
 80010bc:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80010be:	f8cd 8018 	str.w	r8, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010c2:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80010c4:	a905      	add	r1, sp, #20
 80010c6:	4630      	mov	r0, r6
 80010c8:	f006 fb8e 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = ARD_D7_Pin;
 80010cc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80010d0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010d2:	2302      	movs	r3, #2
 80010d4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010d6:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80010d8:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 80010da:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(ARD_D7_GPIO_Port, &GPIO_InitStruct);
 80010dc:	a905      	add	r1, sp, #20
 80010de:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80010e2:	f006 fb81 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = LED1_Pin|MDM_DTR_OUT_Pin;
 80010e6:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80010ea:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80010ec:	9706      	str	r7, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010ee:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80010f0:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80010f2:	a905      	add	r1, sp, #20
 80010f4:	4630      	mov	r0, r6
 80010f6:	f006 fb77 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = MDM_RING_Pin;
 80010fa:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010fe:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8001100:	4b0c      	ldr	r3, [pc, #48]	; (8001134 <MX_GPIO_Init+0x130>)
 8001102:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001104:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(MDM_RING_GPIO_Port, &GPIO_InitStruct);
 8001106:	a905      	add	r1, sp, #20
 8001108:	4628      	mov	r0, r5
 800110a:	f006 fb6d 	bl	80077e8 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0);
 800110e:	4622      	mov	r2, r4
 8001110:	2105      	movs	r1, #5
 8001112:	2028      	movs	r0, #40	; 0x28
 8001114:	f006 fac4 	bl	80076a0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8001118:	2028      	movs	r0, #40	; 0x28
 800111a:	f006 faf9 	bl	8007710 <HAL_NVIC_EnableIRQ>

}
 800111e:	b00a      	add	sp, #40	; 0x28
 8001120:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001124:	40021000 	.word	0x40021000
 8001128:	48000400 	.word	0x48000400
 800112c:	48000800 	.word	0x48000800
 8001130:	48001c00 	.word	0x48001c00
 8001134:	10110000 	.word	0x10110000

08001138 <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 8001138:	b508      	push	{r3, lr}

  hi2c1.Instance = I2C1;
 800113a:	4812      	ldr	r0, [pc, #72]	; (8001184 <MX_I2C1_Init+0x4c>)
 800113c:	4b12      	ldr	r3, [pc, #72]	; (8001188 <MX_I2C1_Init+0x50>)
 800113e:	6003      	str	r3, [r0, #0]
  hi2c1.Init.Timing = 0x10909CEC;
 8001140:	4b12      	ldr	r3, [pc, #72]	; (800118c <MX_I2C1_Init+0x54>)
 8001142:	6043      	str	r3, [r0, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8001144:	2300      	movs	r3, #0
 8001146:	6083      	str	r3, [r0, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8001148:	2201      	movs	r2, #1
 800114a:	60c2      	str	r2, [r0, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800114c:	6103      	str	r3, [r0, #16]
  hi2c1.Init.OwnAddress2 = 0;
 800114e:	6143      	str	r3, [r0, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8001150:	6183      	str	r3, [r0, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8001152:	61c3      	str	r3, [r0, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8001154:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8001156:	f006 fe27 	bl	8007da8 <HAL_I2C_Init>
 800115a:	b950      	cbnz	r0, 8001172 <MX_I2C1_Init+0x3a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800115c:	2100      	movs	r1, #0
 800115e:	4809      	ldr	r0, [pc, #36]	; (8001184 <MX_I2C1_Init+0x4c>)
 8001160:	f007 f846 	bl	80081f0 <HAL_I2CEx_ConfigAnalogFilter>
 8001164:	b940      	cbnz	r0, 8001178 <MX_I2C1_Init+0x40>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8001166:	2100      	movs	r1, #0
 8001168:	4806      	ldr	r0, [pc, #24]	; (8001184 <MX_I2C1_Init+0x4c>)
 800116a:	f007 f86f 	bl	800824c <HAL_I2CEx_ConfigDigitalFilter>
 800116e:	b930      	cbnz	r0, 800117e <MX_I2C1_Init+0x46>
  {
    Error_Handler();
  }

}
 8001170:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001172:	f000 f861 	bl	8001238 <Error_Handler>
 8001176:	e7f1      	b.n	800115c <MX_I2C1_Init+0x24>
    Error_Handler();
 8001178:	f000 f85e 	bl	8001238 <Error_Handler>
 800117c:	e7f3      	b.n	8001166 <MX_I2C1_Init+0x2e>
    Error_Handler();
 800117e:	f000 f85b 	bl	8001238 <Error_Handler>
}
 8001182:	e7f5      	b.n	8001170 <MX_I2C1_Init+0x38>
 8001184:	20000988 	.word	0x20000988
 8001188:	40005400 	.word	0x40005400
 800118c:	10909cec 	.word	0x10909cec

08001190 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8001190:	b500      	push	{lr}
 8001192:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001194:	2300      	movs	r3, #0
 8001196:	9301      	str	r3, [sp, #4]
 8001198:	9302      	str	r3, [sp, #8]
 800119a:	9303      	str	r3, [sp, #12]
 800119c:	9304      	str	r3, [sp, #16]
 800119e:	9305      	str	r3, [sp, #20]
  if(i2cHandle->Instance==I2C1)
 80011a0:	6802      	ldr	r2, [r0, #0]
 80011a2:	4b10      	ldr	r3, [pc, #64]	; (80011e4 <HAL_I2C_MspInit+0x54>)
 80011a4:	429a      	cmp	r2, r3
 80011a6:	d002      	beq.n	80011ae <HAL_I2C_MspInit+0x1e>
    __HAL_RCC_I2C1_CLK_ENABLE();
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 80011a8:	b007      	add	sp, #28
 80011aa:	f85d fb04 	ldr.w	pc, [sp], #4
    GPIO_InitStruct.Pin = ARD_D15_Pin|ARD_D14_Pin;
 80011ae:	f44f 7340 	mov.w	r3, #768	; 0x300
 80011b2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80011b4:	2312      	movs	r3, #18
 80011b6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80011b8:	2301      	movs	r3, #1
 80011ba:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80011bc:	2303      	movs	r3, #3
 80011be:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80011c0:	2304      	movs	r3, #4
 80011c2:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80011c4:	eb0d 0103 	add.w	r1, sp, r3
 80011c8:	4807      	ldr	r0, [pc, #28]	; (80011e8 <HAL_I2C_MspInit+0x58>)
 80011ca:	f006 fb0d 	bl	80077e8 <HAL_GPIO_Init>
    __HAL_RCC_I2C1_CLK_ENABLE();
 80011ce:	4b07      	ldr	r3, [pc, #28]	; (80011ec <HAL_I2C_MspInit+0x5c>)
 80011d0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80011d2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80011d6:	659a      	str	r2, [r3, #88]	; 0x58
 80011d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80011da:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80011de:	9300      	str	r3, [sp, #0]
 80011e0:	9b00      	ldr	r3, [sp, #0]
}
 80011e2:	e7e1      	b.n	80011a8 <HAL_I2C_MspInit+0x18>
 80011e4:	40005400 	.word	0x40005400
 80011e8:	48000400 	.word	0x48000400
 80011ec:	40021000 	.word	0x40021000

080011f0 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
 80011f0:	b508      	push	{r3, lr}

  if(i2cHandle->Instance==I2C1)
 80011f2:	6802      	ldr	r2, [r0, #0]
 80011f4:	4b07      	ldr	r3, [pc, #28]	; (8001214 <HAL_I2C_MspDeInit+0x24>)
 80011f6:	429a      	cmp	r2, r3
 80011f8:	d000      	beq.n	80011fc <HAL_I2C_MspDeInit+0xc>

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
  }
} 
 80011fa:	bd08      	pop	{r3, pc}
    __HAL_RCC_I2C1_CLK_DISABLE();
 80011fc:	4a06      	ldr	r2, [pc, #24]	; (8001218 <HAL_I2C_MspDeInit+0x28>)
 80011fe:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001200:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001204:	6593      	str	r3, [r2, #88]	; 0x58
    HAL_GPIO_DeInit(GPIOB, ARD_D15_Pin|ARD_D14_Pin);
 8001206:	f44f 7140 	mov.w	r1, #768	; 0x300
 800120a:	4804      	ldr	r0, [pc, #16]	; (800121c <HAL_I2C_MspDeInit+0x2c>)
 800120c:	f006 fbbe 	bl	800798c <HAL_GPIO_DeInit>
} 
 8001210:	e7f3      	b.n	80011fa <HAL_I2C_MspDeInit+0xa>
 8001212:	bf00      	nop
 8001214:	40005400 	.word	0x40005400
 8001218:	40021000 	.word	0x40021000
 800121c:	48000400 	.word	0x48000400

08001220 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8001220:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 8001222:	6802      	ldr	r2, [r0, #0]
 8001224:	4b03      	ldr	r3, [pc, #12]	; (8001234 <HAL_TIM_PeriodElapsedCallback+0x14>)
 8001226:	429a      	cmp	r2, r3
 8001228:	d000      	beq.n	800122c <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 800122a:	bd08      	pop	{r3, pc}
    HAL_IncTick();
 800122c:	f005 fea8 	bl	8006f80 <HAL_IncTick>
}
 8001230:	e7fb      	b.n	800122a <HAL_TIM_PeriodElapsedCallback+0xa>
 8001232:	bf00      	nop
 8001234:	40012c00 	.word	0x40012c00

08001238 <Error_Handler>:
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
 8001238:	e7fe      	b.n	8001238 <Error_Handler>
	...

0800123c <SystemClock_Config>:
{
 800123c:	b510      	push	{r4, lr}
 800123e:	b0b0      	sub	sp, #192	; 0xc0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001240:	2244      	movs	r2, #68	; 0x44
 8001242:	2100      	movs	r1, #0
 8001244:	a81f      	add	r0, sp, #124	; 0x7c
 8001246:	f024 fd86 	bl	8025d56 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800124a:	2400      	movs	r4, #0
 800124c:	941a      	str	r4, [sp, #104]	; 0x68
 800124e:	941b      	str	r4, [sp, #108]	; 0x6c
 8001250:	941c      	str	r4, [sp, #112]	; 0x70
 8001252:	941d      	str	r4, [sp, #116]	; 0x74
 8001254:	941e      	str	r4, [sp, #120]	; 0x78
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8001256:	2268      	movs	r2, #104	; 0x68
 8001258:	4621      	mov	r1, r4
 800125a:	4668      	mov	r0, sp
 800125c:	f024 fd7b 	bl	8025d56 <memset>
  HAL_PWR_EnableBkUpAccess();
 8001260:	f007 f8ca 	bl	80083f8 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8001264:	4a3a      	ldr	r2, [pc, #232]	; (8001350 <SystemClock_Config+0x114>)
 8001266:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800126a:	f023 0318 	bic.w	r3, r3, #24
 800126e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 8001272:	2314      	movs	r3, #20
 8001274:	931f      	str	r3, [sp, #124]	; 0x7c
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001276:	2301      	movs	r3, #1
 8001278:	9321      	str	r3, [sp, #132]	; 0x84
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800127a:	9325      	str	r3, [sp, #148]	; 0x94
  RCC_OscInitStruct.MSICalibrationValue = 0;
 800127c:	9426      	str	r4, [sp, #152]	; 0x98
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 800127e:	2260      	movs	r2, #96	; 0x60
 8001280:	9227      	str	r2, [sp, #156]	; 0x9c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001282:	2202      	movs	r2, #2
 8001284:	9229      	str	r2, [sp, #164]	; 0xa4
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8001286:	932a      	str	r3, [sp, #168]	; 0xa8
  RCC_OscInitStruct.PLL.PLLM = 1;
 8001288:	932b      	str	r3, [sp, #172]	; 0xac
  RCC_OscInitStruct.PLL.PLLN = 40;
 800128a:	2328      	movs	r3, #40	; 0x28
 800128c:	932c      	str	r3, [sp, #176]	; 0xb0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 800128e:	2307      	movs	r3, #7
 8001290:	932d      	str	r3, [sp, #180]	; 0xb4
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8001292:	922e      	str	r2, [sp, #184]	; 0xb8
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8001294:	922f      	str	r2, [sp, #188]	; 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001296:	a81f      	add	r0, sp, #124	; 0x7c
 8001298:	f007 fa52 	bl	8008740 <HAL_RCC_OscConfig>
 800129c:	2800      	cmp	r0, #0
 800129e:	d14f      	bne.n	8001340 <SystemClock_Config+0x104>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80012a0:	230f      	movs	r3, #15
 80012a2:	931a      	str	r3, [sp, #104]	; 0x68
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80012a4:	2303      	movs	r3, #3
 80012a6:	931b      	str	r3, [sp, #108]	; 0x6c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80012a8:	2300      	movs	r3, #0
 80012aa:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80012ac:	931d      	str	r3, [sp, #116]	; 0x74
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80012ae:	931e      	str	r3, [sp, #120]	; 0x78
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80012b0:	2104      	movs	r1, #4
 80012b2:	a81a      	add	r0, sp, #104	; 0x68
 80012b4:	f007 fd84 	bl	8008dc0 <HAL_RCC_ClockConfig>
 80012b8:	2800      	cmp	r0, #0
 80012ba:	d143      	bne.n	8001344 <SystemClock_Config+0x108>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART1
 80012bc:	4b25      	ldr	r3, [pc, #148]	; (8001354 <SystemClock_Config+0x118>)
 80012be:	9300      	str	r3, [sp, #0]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 80012c0:	2300      	movs	r3, #0
 80012c2:	9308      	str	r3, [sp, #32]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80012c4:	9309      	str	r3, [sp, #36]	; 0x24
  PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 80012c6:	930a      	str	r3, [sp, #40]	; 0x28
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 80012c8:	930d      	str	r3, [sp, #52]	; 0x34
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 80012ca:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80012ce:	9317      	str	r3, [sp, #92]	; 0x5c
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 80012d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80012d4:	9319      	str	r3, [sp, #100]	; 0x64
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 80012d6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80012da:	9314      	str	r3, [sp, #80]	; 0x50
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
 80012dc:	9316      	str	r3, [sp, #88]	; 0x58
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
 80012de:	2301      	movs	r3, #1
 80012e0:	9301      	str	r3, [sp, #4]
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
 80012e2:	9302      	str	r3, [sp, #8]
  PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
 80012e4:	2318      	movs	r3, #24
 80012e6:	9303      	str	r3, [sp, #12]
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 80012e8:	2307      	movs	r3, #7
 80012ea:	9304      	str	r3, [sp, #16]
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 80012ec:	2302      	movs	r3, #2
 80012ee:	9305      	str	r3, [sp, #20]
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 80012f0:	9306      	str	r3, [sp, #24]
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
 80012f2:	f04f 7388 	mov.w	r3, #17825792	; 0x1100000
 80012f6:	9307      	str	r3, [sp, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80012f8:	4668      	mov	r0, sp
 80012fa:	f007 ff0d 	bl	8009118 <HAL_RCCEx_PeriphCLKConfig>
 80012fe:	bb18      	cbnz	r0, 8001348 <SystemClock_Config+0x10c>
  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_SYSCLK, RCC_MCODIV_1);
 8001300:	2200      	movs	r2, #0
 8001302:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8001306:	4610      	mov	r0, r2
 8001308:	f007 f99a 	bl	8008640 <HAL_RCC_MCOConfig>
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 800130c:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001310:	f007 f882 	bl	8008418 <HAL_PWREx_ControlVoltageScaling>
 8001314:	b9d0      	cbnz	r0, 800134c <SystemClock_Config+0x110>
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001316:	f007 fe01 	bl	8008f1c <HAL_RCC_GetHCLKFreq>
 800131a:	4b0f      	ldr	r3, [pc, #60]	; (8001358 <SystemClock_Config+0x11c>)
 800131c:	fba3 3000 	umull	r3, r0, r3, r0
 8001320:	0980      	lsrs	r0, r0, #6
 8001322:	f006 fa15 	bl	8007750 <HAL_SYSTICK_Config>
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8001326:	2004      	movs	r0, #4
 8001328:	f006 fa26 	bl	8007778 <HAL_SYSTICK_CLKSourceConfig>
  HAL_RCCEx_EnableMSIPLLMode();
 800132c:	f008 f8c0 	bl	80094b0 <HAL_RCCEx_EnableMSIPLLMode>
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8001330:	2200      	movs	r2, #0
 8001332:	210f      	movs	r1, #15
 8001334:	f04f 30ff 	mov.w	r0, #4294967295
 8001338:	f006 f9b2 	bl	80076a0 <HAL_NVIC_SetPriority>
}
 800133c:	b030      	add	sp, #192	; 0xc0
 800133e:	bd10      	pop	{r4, pc}
    Error_Handler();
 8001340:	f7ff ff7a 	bl	8001238 <Error_Handler>
    Error_Handler();
 8001344:	f7ff ff78 	bl	8001238 <Error_Handler>
    Error_Handler();
 8001348:	f7ff ff76 	bl	8001238 <Error_Handler>
    Error_Handler();
 800134c:	f7ff ff74 	bl	8001238 <Error_Handler>
 8001350:	40021000 	.word	0x40021000
 8001354:	00066047 	.word	0x00066047
 8001358:	10624dd3 	.word	0x10624dd3

0800135c <main>:
{
 800135c:	b508      	push	{r3, lr}
HAL_Init();
 800135e:	f005 fdff 	bl	8006f60 <HAL_Init>
  SystemClock_Config();
 8001362:	f7ff ff6b 	bl	800123c <SystemClock_Config>
  MX_GPIO_Init();
 8001366:	f7ff fe4d 	bl	8001004 <MX_GPIO_Init>
  MX_ADC1_Init();
 800136a:	f7ff fddd 	bl	8000f28 <MX_ADC1_Init>
  MX_I2C1_Init();
 800136e:	f7ff fee3 	bl	8001138 <MX_I2C1_Init>
  MX_QUADSPI_Init();
 8001372:	f000 f819 	bl	80013a8 <MX_QUADSPI_Init>
  MX_RTC_Init();
 8001376:	f000 f893 	bl	80014a0 <MX_RTC_Init>
  MX_SPI1_Init();
 800137a:	f000 f8bd 	bl	80014f8 <MX_SPI1_Init>
  MX_SPI3_Init();
 800137e:	f000 f8e1 	bl	8001544 <MX_SPI3_Init>
  MX_TIM2_Init();
 8001382:	f000 fad9 	bl	8001938 <MX_TIM2_Init>
  MX_TIM3_Init();
 8001386:	f000 fb15 	bl	80019b4 <MX_TIM3_Init>
  MX_USART1_UART_Init();
 800138a:	f000 fb53 	bl	8001a34 <MX_USART1_UART_Init>
  MX_USART2_UART_Init();
 800138e:	f000 fb6d 	bl	8001a6c <MX_USART2_UART_Init>
  MX_USB_PCD_Init();
 8001392:	f000 fc73 	bl	8001c7c <MX_USB_PCD_Init>
  MX_RNG_Init();
 8001396:	f000 f85b 	bl	8001450 <MX_RNG_Init>
  MX_I2C1_Init();
 800139a:	f7ff fecd 	bl	8001138 <MX_I2C1_Init>
  MX_FREERTOS_Init(); 
 800139e:	f022 f909 	bl	80235b4 <MX_FREERTOS_Init>
  osKernelStart();
 80013a2:	f022 f933 	bl	802360c <osKernelStart>
  while (1)
 80013a6:	e7fe      	b.n	80013a6 <main+0x4a>

080013a8 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
 80013a8:	b508      	push	{r3, lr}

  hqspi.Instance = QUADSPI;
 80013aa:	480a      	ldr	r0, [pc, #40]	; (80013d4 <MX_QUADSPI_Init+0x2c>)
 80013ac:	4b0a      	ldr	r3, [pc, #40]	; (80013d8 <MX_QUADSPI_Init+0x30>)
 80013ae:	6003      	str	r3, [r0, #0]
  hqspi.Init.ClockPrescaler = 255;
 80013b0:	23ff      	movs	r3, #255	; 0xff
 80013b2:	6043      	str	r3, [r0, #4]
  hqspi.Init.FifoThreshold = 1;
 80013b4:	2201      	movs	r2, #1
 80013b6:	6082      	str	r2, [r0, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 80013b8:	2300      	movs	r3, #0
 80013ba:	60c3      	str	r3, [r0, #12]
  hqspi.Init.FlashSize = 1;
 80013bc:	6102      	str	r2, [r0, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
 80013be:	6143      	str	r3, [r0, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
 80013c0:	6183      	str	r3, [r0, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
 80013c2:	61c3      	str	r3, [r0, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
 80013c4:	6203      	str	r3, [r0, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
 80013c6:	f007 f89b 	bl	8008500 <HAL_QSPI_Init>
 80013ca:	b900      	cbnz	r0, 80013ce <MX_QUADSPI_Init+0x26>
  {
    Error_Handler();
  }

}
 80013cc:	bd08      	pop	{r3, pc}
    Error_Handler();
 80013ce:	f7ff ff33 	bl	8001238 <Error_Handler>
}
 80013d2:	e7fb      	b.n	80013cc <MX_QUADSPI_Init+0x24>
 80013d4:	200009d4 	.word	0x200009d4
 80013d8:	a0001000 	.word	0xa0001000

080013dc <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
 80013dc:	b570      	push	{r4, r5, r6, lr}
 80013de:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80013e0:	2300      	movs	r3, #0
 80013e2:	9301      	str	r3, [sp, #4]
 80013e4:	9302      	str	r3, [sp, #8]
 80013e6:	9303      	str	r3, [sp, #12]
 80013e8:	9304      	str	r3, [sp, #16]
 80013ea:	9305      	str	r3, [sp, #20]
  if(qspiHandle->Instance==QUADSPI)
 80013ec:	6802      	ldr	r2, [r0, #0]
 80013ee:	4b16      	ldr	r3, [pc, #88]	; (8001448 <HAL_QSPI_MspInit+0x6c>)
 80013f0:	429a      	cmp	r2, r3
 80013f2:	d001      	beq.n	80013f8 <HAL_QSPI_MspInit+0x1c>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
 80013f4:	b006      	add	sp, #24
 80013f6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_QSPI_CLK_ENABLE();
 80013f8:	f103 4320 	add.w	r3, r3, #2684354560	; 0xa0000000
 80013fc:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8001400:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001402:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001406:	651a      	str	r2, [r3, #80]	; 0x50
 8001408:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800140a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800140e:	9300      	str	r3, [sp, #0]
 8001410:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6;
 8001412:	23c0      	movs	r3, #192	; 0xc0
 8001414:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001416:	2602      	movs	r6, #2
 8001418:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800141a:	2503      	movs	r5, #3
 800141c:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800141e:	240a      	movs	r4, #10
 8001420:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001422:	a901      	add	r1, sp, #4
 8001424:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001428:	f006 f9de 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_11|GPIO_PIN_10|GPIO_PIN_0;
 800142c:	f640 4303 	movw	r3, #3075	; 0xc03
 8001430:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001432:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001434:	2300      	movs	r3, #0
 8001436:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001438:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800143a:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800143c:	a901      	add	r1, sp, #4
 800143e:	4803      	ldr	r0, [pc, #12]	; (800144c <HAL_QSPI_MspInit+0x70>)
 8001440:	f006 f9d2 	bl	80077e8 <HAL_GPIO_Init>
}
 8001444:	e7d6      	b.n	80013f4 <HAL_QSPI_MspInit+0x18>
 8001446:	bf00      	nop
 8001448:	a0001000 	.word	0xa0001000
 800144c:	48000400 	.word	0x48000400

08001450 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
 8001450:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
 8001452:	4805      	ldr	r0, [pc, #20]	; (8001468 <MX_RNG_Init+0x18>)
 8001454:	4b05      	ldr	r3, [pc, #20]	; (800146c <MX_RNG_Init+0x1c>)
 8001456:	6003      	str	r3, [r0, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 8001458:	f008 f832 	bl	80094c0 <HAL_RNG_Init>
 800145c:	b900      	cbnz	r0, 8001460 <MX_RNG_Init+0x10>
  {
    Error_Handler();
  }

}
 800145e:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001460:	f7ff feea 	bl	8001238 <Error_Handler>
}
 8001464:	e7fb      	b.n	800145e <MX_RNG_Init+0xe>
 8001466:	bf00      	nop
 8001468:	20000a20 	.word	0x20000a20
 800146c:	50060800 	.word	0x50060800

08001470 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
 8001470:	6802      	ldr	r2, [r0, #0]
 8001472:	4b0a      	ldr	r3, [pc, #40]	; (800149c <HAL_RNG_MspInit+0x2c>)
 8001474:	429a      	cmp	r2, r3
 8001476:	d000      	beq.n	800147a <HAL_RNG_MspInit+0xa>
 8001478:	4770      	bx	lr
{
 800147a:	b082      	sub	sp, #8
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 800147c:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 8001480:	f5a3 337e 	sub.w	r3, r3, #260096	; 0x3f800
 8001484:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001486:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800148a:	64da      	str	r2, [r3, #76]	; 0x4c
 800148c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800148e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001492:	9301      	str	r3, [sp, #4]
 8001494:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
 8001496:	b002      	add	sp, #8
 8001498:	4770      	bx	lr
 800149a:	bf00      	nop
 800149c:	50060800 	.word	0x50060800

080014a0 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80014a0:	b508      	push	{r3, lr}

  /** Initialize RTC Only 
  */
  hrtc.Instance = RTC;
 80014a2:	480a      	ldr	r0, [pc, #40]	; (80014cc <MX_RTC_Init+0x2c>)
 80014a4:	4b0a      	ldr	r3, [pc, #40]	; (80014d0 <MX_RTC_Init+0x30>)
 80014a6:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80014a8:	2300      	movs	r3, #0
 80014aa:	6043      	str	r3, [r0, #4]
  hrtc.Init.AsynchPrediv = 127;
 80014ac:	227f      	movs	r2, #127	; 0x7f
 80014ae:	6082      	str	r2, [r0, #8]
  hrtc.Init.SynchPrediv = 255;
 80014b0:	22ff      	movs	r2, #255	; 0xff
 80014b2:	60c2      	str	r2, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80014b4:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 80014b6:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 80014b8:	6183      	str	r3, [r0, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80014ba:	61c3      	str	r3, [r0, #28]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 80014bc:	f008 f8c6 	bl	800964c <HAL_RTC_Init>
 80014c0:	b900      	cbnz	r0, 80014c4 <MX_RTC_Init+0x24>
  {
    Error_Handler();
  }

}
 80014c2:	bd08      	pop	{r3, pc}
    Error_Handler();
 80014c4:	f7ff feb8 	bl	8001238 <Error_Handler>
}
 80014c8:	e7fb      	b.n	80014c2 <MX_RTC_Init+0x22>
 80014ca:	bf00      	nop
 80014cc:	20000a30 	.word	0x20000a30
 80014d0:	40002800 	.word	0x40002800

080014d4 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{

  if(rtcHandle->Instance==RTC)
 80014d4:	6802      	ldr	r2, [r0, #0]
 80014d6:	4b06      	ldr	r3, [pc, #24]	; (80014f0 <HAL_RTC_MspInit+0x1c>)
 80014d8:	429a      	cmp	r2, r3
 80014da:	d000      	beq.n	80014de <HAL_RTC_MspInit+0xa>
    __HAL_RCC_RTC_ENABLE();
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 80014dc:	4770      	bx	lr
    __HAL_RCC_RTC_ENABLE();
 80014de:	4a05      	ldr	r2, [pc, #20]	; (80014f4 <HAL_RTC_MspInit+0x20>)
 80014e0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80014e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80014e8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 80014ec:	e7f6      	b.n	80014dc <HAL_RTC_MspInit+0x8>
 80014ee:	bf00      	nop
 80014f0:	40002800 	.word	0x40002800
 80014f4:	40021000 	.word	0x40021000

080014f8 <MX_SPI1_Init>:
SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi3;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 80014f8:	b508      	push	{r3, lr}

  hspi1.Instance = SPI1;
 80014fa:	4810      	ldr	r0, [pc, #64]	; (800153c <MX_SPI1_Init+0x44>)
 80014fc:	4b10      	ldr	r3, [pc, #64]	; (8001540 <MX_SPI1_Init+0x48>)
 80014fe:	6003      	str	r3, [r0, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8001500:	f44f 7382 	mov.w	r3, #260	; 0x104
 8001504:	6043      	str	r3, [r0, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8001506:	2300      	movs	r3, #0
 8001508:	6083      	str	r3, [r0, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
 800150a:	f44f 7240 	mov.w	r2, #768	; 0x300
 800150e:	60c2      	str	r2, [r0, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8001510:	6103      	str	r3, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8001512:	6143      	str	r3, [r0, #20]
  hspi1.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8001514:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001518:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800151a:	61c3      	str	r3, [r0, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800151c:	6203      	str	r3, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800151e:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001520:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8001522:	2207      	movs	r2, #7
 8001524:	62c2      	str	r2, [r0, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8001526:	6303      	str	r3, [r0, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8001528:	2308      	movs	r3, #8
 800152a:	6343      	str	r3, [r0, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800152c:	f008 f8db 	bl	80096e6 <HAL_SPI_Init>
 8001530:	b900      	cbnz	r0, 8001534 <MX_SPI1_Init+0x3c>
  {
    Error_Handler();
  }

}
 8001532:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001534:	f7ff fe80 	bl	8001238 <Error_Handler>
}
 8001538:	e7fb      	b.n	8001532 <MX_SPI1_Init+0x3a>
 800153a:	bf00      	nop
 800153c:	20000a54 	.word	0x20000a54
 8001540:	40013000 	.word	0x40013000

08001544 <MX_SPI3_Init>:
/* SPI3 init function */
void MX_SPI3_Init(void)
{
 8001544:	b508      	push	{r3, lr}

  hspi3.Instance = SPI3;
 8001546:	4810      	ldr	r0, [pc, #64]	; (8001588 <MX_SPI3_Init+0x44>)
 8001548:	4b10      	ldr	r3, [pc, #64]	; (800158c <MX_SPI3_Init+0x48>)
 800154a:	6003      	str	r3, [r0, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 800154c:	f44f 7382 	mov.w	r3, #260	; 0x104
 8001550:	6043      	str	r3, [r0, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 8001552:	2300      	movs	r3, #0
 8001554:	6083      	str	r3, [r0, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
 8001556:	f44f 7240 	mov.w	r2, #768	; 0x300
 800155a:	60c2      	str	r2, [r0, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 800155c:	6103      	str	r3, [r0, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 800155e:	6143      	str	r3, [r0, #20]
  hspi3.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8001560:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001564:	6182      	str	r2, [r0, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8001566:	61c3      	str	r3, [r0, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8001568:	6203      	str	r3, [r0, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 800156a:	6243      	str	r3, [r0, #36]	; 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800156c:	6283      	str	r3, [r0, #40]	; 0x28
  hspi3.Init.CRCPolynomial = 7;
 800156e:	2207      	movs	r2, #7
 8001570:	62c2      	str	r2, [r0, #44]	; 0x2c
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8001572:	6303      	str	r3, [r0, #48]	; 0x30
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8001574:	2308      	movs	r3, #8
 8001576:	6343      	str	r3, [r0, #52]	; 0x34
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 8001578:	f008 f8b5 	bl	80096e6 <HAL_SPI_Init>
 800157c:	b900      	cbnz	r0, 8001580 <MX_SPI3_Init+0x3c>
  {
    Error_Handler();
  }

}
 800157e:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001580:	f7ff fe5a 	bl	8001238 <Error_Handler>
}
 8001584:	e7fb      	b.n	800157e <MX_SPI3_Init+0x3a>
 8001586:	bf00      	nop
 8001588:	20000ab8 	.word	0x20000ab8
 800158c:	40003c00 	.word	0x40003c00

08001590 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8001590:	b570      	push	{r4, r5, r6, lr}
 8001592:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001594:	2300      	movs	r3, #0
 8001596:	9303      	str	r3, [sp, #12]
 8001598:	9304      	str	r3, [sp, #16]
 800159a:	9305      	str	r3, [sp, #20]
 800159c:	9306      	str	r3, [sp, #24]
 800159e:	9307      	str	r3, [sp, #28]
  if(spiHandle->Instance==SPI1)
 80015a0:	6803      	ldr	r3, [r0, #0]
 80015a2:	4a28      	ldr	r2, [pc, #160]	; (8001644 <HAL_SPI_MspInit+0xb4>)
 80015a4:	4293      	cmp	r3, r2
 80015a6:	d004      	beq.n	80015b2 <HAL_SPI_MspInit+0x22>

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
  else if(spiHandle->Instance==SPI3)
 80015a8:	4a27      	ldr	r2, [pc, #156]	; (8001648 <HAL_SPI_MspInit+0xb8>)
 80015aa:	4293      	cmp	r3, r2
 80015ac:	d025      	beq.n	80015fa <HAL_SPI_MspInit+0x6a>

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}
 80015ae:	b008      	add	sp, #32
 80015b0:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_SPI1_CLK_ENABLE();
 80015b2:	4b26      	ldr	r3, [pc, #152]	; (800164c <HAL_SPI_MspInit+0xbc>)
 80015b4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80015b6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80015ba:	661a      	str	r2, [r3, #96]	; 0x60
 80015bc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80015be:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80015c2:	9301      	str	r3, [sp, #4]
 80015c4:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = ARD_D10_Pin|ARD_D13_Pin;
 80015c6:	f248 0320 	movw	r3, #32800	; 0x8020
 80015ca:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015cc:	2602      	movs	r6, #2
 80015ce:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80015d0:	2503      	movs	r5, #3
 80015d2:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80015d4:	2405      	movs	r4, #5
 80015d6:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80015d8:	a903      	add	r1, sp, #12
 80015da:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80015de:	f006 f903 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = ARD_D12_Pin|ARD_D11_Pin;
 80015e2:	2330      	movs	r3, #48	; 0x30
 80015e4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015e6:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80015e8:	2300      	movs	r3, #0
 80015ea:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80015ec:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80015ee:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80015f0:	a903      	add	r1, sp, #12
 80015f2:	4817      	ldr	r0, [pc, #92]	; (8001650 <HAL_SPI_MspInit+0xc0>)
 80015f4:	f006 f8f8 	bl	80077e8 <HAL_GPIO_Init>
 80015f8:	e7d9      	b.n	80015ae <HAL_SPI_MspInit+0x1e>
    __HAL_RCC_SPI3_CLK_ENABLE();
 80015fa:	4b14      	ldr	r3, [pc, #80]	; (800164c <HAL_SPI_MspInit+0xbc>)
 80015fc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80015fe:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001602:	659a      	str	r2, [r3, #88]	; 0x58
 8001604:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001606:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800160a:	9302      	str	r3, [sp, #8]
 800160c:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = ST33_MOSI_Pin|ST33_MISO_Pin|ST33_SCK_Pin;
 800160e:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8001612:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001614:	2602      	movs	r6, #2
 8001616:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001618:	2503      	movs	r5, #3
 800161a:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 800161c:	2406      	movs	r4, #6
 800161e:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001620:	a903      	add	r1, sp, #12
 8001622:	480c      	ldr	r0, [pc, #48]	; (8001654 <HAL_SPI_MspInit+0xc4>)
 8001624:	f006 f8e0 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = ST33_CS_Pin;
 8001628:	2310      	movs	r3, #16
 800162a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800162c:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800162e:	2300      	movs	r3, #0
 8001630:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001632:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8001634:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(ST33_CS_GPIO_Port, &GPIO_InitStruct);
 8001636:	a903      	add	r1, sp, #12
 8001638:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800163c:	f006 f8d4 	bl	80077e8 <HAL_GPIO_Init>
}
 8001640:	e7b5      	b.n	80015ae <HAL_SPI_MspInit+0x1e>
 8001642:	bf00      	nop
 8001644:	40013000 	.word	0x40013000
 8001648:	40003c00 	.word	0x40003c00
 800164c:	40021000 	.word	0x40021000
 8001650:	48000400 	.word	0x48000400
 8001654:	48000800 	.word	0x48000800

08001658 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001658:	b500      	push	{lr}
 800165a:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800165c:	4b21      	ldr	r3, [pc, #132]	; (80016e4 <HAL_MspInit+0x8c>)
 800165e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001660:	f042 0201 	orr.w	r2, r2, #1
 8001664:	661a      	str	r2, [r3, #96]	; 0x60
 8001666:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001668:	f002 0201 	and.w	r2, r2, #1
 800166c:	9200      	str	r2, [sp, #0]
 800166e:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001670:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001672:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001676:	659a      	str	r2, [r3, #88]	; 0x58
 8001678:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800167a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800167e:	9301      	str	r3, [sp, #4]
 8001680:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001682:	2003      	movs	r0, #3
 8001684:	f005 fffa 	bl	800767c <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8001688:	2200      	movs	r2, #0
 800168a:	4611      	mov	r1, r2
 800168c:	f06f 000b 	mvn.w	r0, #11
 8001690:	f006 f806 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8001694:	2200      	movs	r2, #0
 8001696:	4611      	mov	r1, r2
 8001698:	f06f 000a 	mvn.w	r0, #10
 800169c:	f006 f800 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80016a0:	2200      	movs	r2, #0
 80016a2:	4611      	mov	r1, r2
 80016a4:	f06f 0009 	mvn.w	r0, #9
 80016a8:	f005 fffa 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80016ac:	2200      	movs	r2, #0
 80016ae:	4611      	mov	r1, r2
 80016b0:	f06f 0004 	mvn.w	r0, #4
 80016b4:	f005 fff4 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80016b8:	2200      	movs	r2, #0
 80016ba:	4611      	mov	r1, r2
 80016bc:	f06f 0003 	mvn.w	r0, #3
 80016c0:	f005 ffee 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80016c4:	2200      	movs	r2, #0
 80016c6:	210f      	movs	r1, #15
 80016c8:	f06f 0001 	mvn.w	r0, #1
 80016cc:	f005 ffe8 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 80016d0:	2200      	movs	r2, #0
 80016d2:	210f      	movs	r1, #15
 80016d4:	f04f 30ff 	mov.w	r0, #4294967295
 80016d8:	f005 ffe2 	bl	80076a0 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80016dc:	b003      	add	sp, #12
 80016de:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e2:	bf00      	nop
 80016e4:	40021000 	.word	0x40021000

080016e8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80016e8:	b500      	push	{lr}
 80016ea:	b089      	sub	sp, #36	; 0x24
 80016ec:	4601      	mov	r1, r0
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, TickPriority ,0); 
 80016ee:	2200      	movs	r2, #0
 80016f0:	2019      	movs	r0, #25
 80016f2:	f005 ffd5 	bl	80076a0 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); 
 80016f6:	2019      	movs	r0, #25
 80016f8:	f006 f80a 	bl	8007710 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 80016fc:	4b14      	ldr	r3, [pc, #80]	; (8001750 <HAL_InitTick+0x68>)
 80016fe:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001700:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001704:	661a      	str	r2, [r3, #96]	; 0x60
 8001706:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001708:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800170c:	9301      	str	r3, [sp, #4]
 800170e:	9b01      	ldr	r3, [sp, #4]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001710:	a902      	add	r1, sp, #8
 8001712:	a803      	add	r0, sp, #12
 8001714:	f007 fc2c 	bl	8008f70 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 8001718:	f007 fc18 	bl	8008f4c <HAL_RCC_GetPCLK2Freq>
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800171c:	4b0d      	ldr	r3, [pc, #52]	; (8001754 <HAL_InitTick+0x6c>)
 800171e:	fba3 2300 	umull	r2, r3, r3, r0
 8001722:	0c9b      	lsrs	r3, r3, #18
 8001724:	3b01      	subs	r3, #1
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8001726:	480c      	ldr	r0, [pc, #48]	; (8001758 <HAL_InitTick+0x70>)
 8001728:	4a0c      	ldr	r2, [pc, #48]	; (800175c <HAL_InitTick+0x74>)
 800172a:	6002      	str	r2, [r0, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 800172c:	f240 32e7 	movw	r2, #999	; 0x3e7
 8001730:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8001732:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 8001734:	2300      	movs	r3, #0
 8001736:	6103      	str	r3, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001738:	6083      	str	r3, [r0, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 800173a:	f008 fa91 	bl	8009c60 <HAL_TIM_Base_Init>
 800173e:	b118      	cbz	r0, 8001748 <HAL_InitTick+0x60>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }
  
  /* Return function status */
  return HAL_ERROR;
 8001740:	2001      	movs	r0, #1
}
 8001742:	b009      	add	sp, #36	; 0x24
 8001744:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_TIM_Base_Start_IT(&htim1);
 8001748:	4803      	ldr	r0, [pc, #12]	; (8001758 <HAL_InitTick+0x70>)
 800174a:	f008 f93d 	bl	80099c8 <HAL_TIM_Base_Start_IT>
 800174e:	e7f8      	b.n	8001742 <HAL_InitTick+0x5a>
 8001750:	40021000 	.word	0x40021000
 8001754:	431bde83 	.word	0x431bde83
 8001758:	20000b1c 	.word	0x20000b1c
 800175c:	40012c00 	.word	0x40012c00

08001760 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8001760:	4770      	bx	lr

08001762 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001762:	e7fe      	b.n	8001762 <HardFault_Handler>

08001764 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001764:	e7fe      	b.n	8001764 <MemManage_Handler>

08001766 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001766:	e7fe      	b.n	8001766 <BusFault_Handler>

08001768 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001768:	e7fe      	b.n	8001768 <UsageFault_Handler>

0800176a <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800176a:	4770      	bx	lr

0800176c <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 800176c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 800176e:	f023 fe15 	bl	802539c <xTaskGetSchedulerState>
 8001772:	2801      	cmp	r0, #1
 8001774:	d100      	bne.n	8001778 <SysTick_Handler+0xc>
    xPortSysTickHandler();
  }
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001776:	bd08      	pop	{r3, pc}
    xPortSysTickHandler();
 8001778:	f022 fb7c 	bl	8023e74 <xPortSysTickHandler>
}
 800177c:	e7fb      	b.n	8001776 <SysTick_Handler+0xa>
	...

08001780 <TIM1_UP_TIM16_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM16 global interrupt.
  */
void TIM1_UP_TIM16_IRQHandler(void)
{
 8001780:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8001782:	4802      	ldr	r0, [pc, #8]	; (800178c <TIM1_UP_TIM16_IRQHandler+0xc>)
 8001784:	f008 f95e 	bl	8009a44 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 1 */
}
 8001788:	bd08      	pop	{r3, pc}
 800178a:	bf00      	nop
 800178c:	20000b1c 	.word	0x20000b1c

08001790 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8001790:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8001792:	4802      	ldr	r0, [pc, #8]	; (800179c <USART1_IRQHandler+0xc>)
 8001794:	f008 fd58 	bl	800a248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8001798:	bd08      	pop	{r3, pc}
 800179a:	bf00      	nop
 800179c:	20000c04 	.word	0x20000c04

080017a0 <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 80017a0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 80017a2:	4802      	ldr	r0, [pc, #8]	; (80017ac <USART2_IRQHandler+0xc>)
 80017a4:	f008 fd50 	bl	800a248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 80017a8:	bd08      	pop	{r3, pc}
 80017aa:	bf00      	nop
 80017ac:	20000c84 	.word	0x20000c84

080017b0 <USART3_IRQHandler>:

/**
  * @brief This function handles USART3 global interrupt.
  */
void USART3_IRQHandler(void)
{
 80017b0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
 80017b2:	4802      	ldr	r0, [pc, #8]	; (80017bc <USART3_IRQHandler+0xc>)
 80017b4:	f008 fd48 	bl	800a248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
 80017b8:	bd08      	pop	{r3, pc}
 80017ba:	bf00      	nop
 80017bc:	20000d04 	.word	0x20000d04

080017c0 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 80017c0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
 80017c2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80017c6:	f006 f973 	bl	8007ab0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 80017ca:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80017ce:	f006 f96f 	bl	8007ab0 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 80017d2:	bd08      	pop	{r3, pc}

080017d4 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 80017d4:	2001      	movs	r0, #1
 80017d6:	4770      	bx	lr

080017d8 <_kill>:

int _kill(int pid, int sig)
{
 80017d8:	b508      	push	{r3, lr}
	errno = EINVAL;
 80017da:	f024 fb63 	bl	8025ea4 <__errno>
 80017de:	2316      	movs	r3, #22
 80017e0:	6003      	str	r3, [r0, #0]
	return -1;
}
 80017e2:	f04f 30ff 	mov.w	r0, #4294967295
 80017e6:	bd08      	pop	{r3, pc}

080017e8 <_exit>:

void _exit (int status)
{
 80017e8:	b508      	push	{r3, lr}
	_kill(status, -1);
 80017ea:	f04f 31ff 	mov.w	r1, #4294967295
 80017ee:	f7ff fff3 	bl	80017d8 <_kill>
	while (1) {}		/* Make sure we hang here */
 80017f2:	e7fe      	b.n	80017f2 <_exit+0xa>

080017f4 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80017f4:	b570      	push	{r4, r5, r6, lr}
 80017f6:	460c      	mov	r4, r1
 80017f8:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80017fa:	2500      	movs	r5, #0
 80017fc:	e006      	b.n	800180c <_read+0x18>
	{
		*ptr++ = __io_getchar();
 80017fe:	f3af 8000 	nop.w
 8001802:	4621      	mov	r1, r4
 8001804:	f801 0b01 	strb.w	r0, [r1], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001808:	3501      	adds	r5, #1
		*ptr++ = __io_getchar();
 800180a:	460c      	mov	r4, r1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800180c:	42b5      	cmp	r5, r6
 800180e:	dbf6      	blt.n	80017fe <_read+0xa>
	}

return len;
}
 8001810:	4630      	mov	r0, r6
 8001812:	bd70      	pop	{r4, r5, r6, pc}

08001814 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001814:	b570      	push	{r4, r5, r6, lr}
 8001816:	460c      	mov	r4, r1
 8001818:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800181a:	2500      	movs	r5, #0
 800181c:	e004      	b.n	8001828 <_write+0x14>
	{
		__io_putchar(*ptr++);
 800181e:	f814 0b01 	ldrb.w	r0, [r4], #1
 8001822:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001826:	3501      	adds	r5, #1
 8001828:	42b5      	cmp	r5, r6
 800182a:	dbf8      	blt.n	800181e <_write+0xa>
	}
	return len;
}
 800182c:	4630      	mov	r0, r6
 800182e:	bd70      	pop	{r4, r5, r6, pc}

08001830 <_close>:

int _close(int file)
{
	return -1;
}
 8001830:	f04f 30ff 	mov.w	r0, #4294967295
 8001834:	4770      	bx	lr

08001836 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8001836:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800183a:	604b      	str	r3, [r1, #4]
	return 0;
}
 800183c:	2000      	movs	r0, #0
 800183e:	4770      	bx	lr

08001840 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8001840:	2001      	movs	r0, #1
 8001842:	4770      	bx	lr

08001844 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8001844:	2000      	movs	r0, #0
 8001846:	4770      	bx	lr

08001848 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001848:	b510      	push	{r4, lr}
 800184a:	4603      	mov	r3, r0
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800184c:	4a0c      	ldr	r2, [pc, #48]	; (8001880 <_sbrk+0x38>)
 800184e:	490d      	ldr	r1, [pc, #52]	; (8001884 <_sbrk+0x3c>)
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initalize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001850:	480d      	ldr	r0, [pc, #52]	; (8001888 <_sbrk+0x40>)
 8001852:	6800      	ldr	r0, [r0, #0]
 8001854:	b140      	cbz	r0, 8001868 <_sbrk+0x20>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001856:	480c      	ldr	r0, [pc, #48]	; (8001888 <_sbrk+0x40>)
 8001858:	6800      	ldr	r0, [r0, #0]
 800185a:	4403      	add	r3, r0
 800185c:	1a52      	subs	r2, r2, r1
 800185e:	4293      	cmp	r3, r2
 8001860:	d806      	bhi.n	8001870 <_sbrk+0x28>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8001862:	4a09      	ldr	r2, [pc, #36]	; (8001888 <_sbrk+0x40>)
 8001864:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
}
 8001866:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8001868:	4807      	ldr	r0, [pc, #28]	; (8001888 <_sbrk+0x40>)
 800186a:	4c08      	ldr	r4, [pc, #32]	; (800188c <_sbrk+0x44>)
 800186c:	6004      	str	r4, [r0, #0]
 800186e:	e7f2      	b.n	8001856 <_sbrk+0xe>
    errno = ENOMEM;
 8001870:	f024 fb18 	bl	8025ea4 <__errno>
 8001874:	230c      	movs	r3, #12
 8001876:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8001878:	f04f 30ff 	mov.w	r0, #4294967295
 800187c:	e7f3      	b.n	8001866 <_sbrk+0x1e>
 800187e:	bf00      	nop
 8001880:	20028000 	.word	0x20028000
 8001884:	00000400 	.word	0x00000400
 8001888:	20000b68 	.word	0x20000b68
 800188c:	200120a8 	.word	0x200120a8

08001890 <HAL_TIM_PWM_MspInit>:
  HAL_TIM_MspPostInit(&htim3);

}

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle)
{
 8001890:	b082      	sub	sp, #8

  if(tim_pwmHandle->Instance==TIM2)
 8001892:	6803      	ldr	r3, [r0, #0]
 8001894:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001898:	d004      	beq.n	80018a4 <HAL_TIM_PWM_MspInit+0x14>
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(tim_pwmHandle->Instance==TIM3)
 800189a:	4a0e      	ldr	r2, [pc, #56]	; (80018d4 <HAL_TIM_PWM_MspInit+0x44>)
 800189c:	4293      	cmp	r3, r2
 800189e:	d00d      	beq.n	80018bc <HAL_TIM_PWM_MspInit+0x2c>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
}
 80018a0:	b002      	add	sp, #8
 80018a2:	4770      	bx	lr
    __HAL_RCC_TIM2_CLK_ENABLE();
 80018a4:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80018a8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80018aa:	f042 0201 	orr.w	r2, r2, #1
 80018ae:	659a      	str	r2, [r3, #88]	; 0x58
 80018b0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80018b2:	f003 0301 	and.w	r3, r3, #1
 80018b6:	9300      	str	r3, [sp, #0]
 80018b8:	9b00      	ldr	r3, [sp, #0]
 80018ba:	e7f1      	b.n	80018a0 <HAL_TIM_PWM_MspInit+0x10>
    __HAL_RCC_TIM3_CLK_ENABLE();
 80018bc:	4b06      	ldr	r3, [pc, #24]	; (80018d8 <HAL_TIM_PWM_MspInit+0x48>)
 80018be:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80018c0:	f042 0202 	orr.w	r2, r2, #2
 80018c4:	659a      	str	r2, [r3, #88]	; 0x58
 80018c6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80018c8:	f003 0302 	and.w	r3, r3, #2
 80018cc:	9301      	str	r3, [sp, #4]
 80018ce:	9b01      	ldr	r3, [sp, #4]
}
 80018d0:	e7e6      	b.n	80018a0 <HAL_TIM_PWM_MspInit+0x10>
 80018d2:	bf00      	nop
 80018d4:	40000400 	.word	0x40000400
 80018d8:	40021000 	.word	0x40021000

080018dc <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 80018dc:	b500      	push	{lr}
 80018de:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018e0:	2300      	movs	r3, #0
 80018e2:	9301      	str	r3, [sp, #4]
 80018e4:	9302      	str	r3, [sp, #8]
 80018e6:	9303      	str	r3, [sp, #12]
 80018e8:	9304      	str	r3, [sp, #16]
 80018ea:	9305      	str	r3, [sp, #20]
  if(timHandle->Instance==TIM2)
 80018ec:	6803      	ldr	r3, [r0, #0]
 80018ee:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80018f2:	d005      	beq.n	8001900 <HAL_TIM_MspPostInit+0x24>

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM3)
 80018f4:	4a0d      	ldr	r2, [pc, #52]	; (800192c <HAL_TIM_MspPostInit+0x50>)
 80018f6:	4293      	cmp	r3, r2
 80018f8:	d00d      	beq.n	8001916 <HAL_TIM_MspPostInit+0x3a>
  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }

}
 80018fa:	b007      	add	sp, #28
 80018fc:	f85d fb04 	ldr.w	pc, [sp], #4
    GPIO_InitStruct.Pin = ARD_D3_Pin;
 8001900:	2308      	movs	r3, #8
 8001902:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001904:	2302      	movs	r3, #2
 8001906:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8001908:	2301      	movs	r3, #1
 800190a:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(ARD_D3_GPIO_Port, &GPIO_InitStruct);
 800190c:	a901      	add	r1, sp, #4
 800190e:	4808      	ldr	r0, [pc, #32]	; (8001930 <HAL_TIM_MspPostInit+0x54>)
 8001910:	f005 ff6a 	bl	80077e8 <HAL_GPIO_Init>
 8001914:	e7f1      	b.n	80018fa <HAL_TIM_MspPostInit+0x1e>
    GPIO_InitStruct.Pin = ARD_D6_Pin;
 8001916:	f44f 7300 	mov.w	r3, #512	; 0x200
 800191a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800191c:	2302      	movs	r3, #2
 800191e:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8001920:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(ARD_D6_GPIO_Port, &GPIO_InitStruct);
 8001922:	a901      	add	r1, sp, #4
 8001924:	4803      	ldr	r0, [pc, #12]	; (8001934 <HAL_TIM_MspPostInit+0x58>)
 8001926:	f005 ff5f 	bl	80077e8 <HAL_GPIO_Init>
}
 800192a:	e7e6      	b.n	80018fa <HAL_TIM_MspPostInit+0x1e>
 800192c:	40000400 	.word	0x40000400
 8001930:	48000400 	.word	0x48000400
 8001934:	48000800 	.word	0x48000800

08001938 <MX_TIM2_Init>:
{
 8001938:	b500      	push	{lr}
 800193a:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800193c:	2300      	movs	r3, #0
 800193e:	9307      	str	r3, [sp, #28]
 8001940:	9308      	str	r3, [sp, #32]
 8001942:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 8001944:	9300      	str	r3, [sp, #0]
 8001946:	9301      	str	r3, [sp, #4]
 8001948:	9302      	str	r3, [sp, #8]
 800194a:	9303      	str	r3, [sp, #12]
 800194c:	9304      	str	r3, [sp, #16]
 800194e:	9305      	str	r3, [sp, #20]
 8001950:	9306      	str	r3, [sp, #24]
  htim2.Instance = TIM2;
 8001952:	4817      	ldr	r0, [pc, #92]	; (80019b0 <MX_TIM2_Init+0x78>)
 8001954:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001958:	6002      	str	r2, [r0, #0]
  htim2.Init.Prescaler = 0;
 800195a:	6043      	str	r3, [r0, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 800195c:	6083      	str	r3, [r0, #8]
  htim2.Init.Period = 0;
 800195e:	60c3      	str	r3, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001960:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001962:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 8001964:	f008 f9ac 	bl	8009cc0 <HAL_TIM_PWM_Init>
 8001968:	b9c8      	cbnz	r0, 800199e <MX_TIM2_Init+0x66>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800196a:	2300      	movs	r3, #0
 800196c:	9307      	str	r3, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800196e:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8001970:	a907      	add	r1, sp, #28
 8001972:	480f      	ldr	r0, [pc, #60]	; (80019b0 <MX_TIM2_Init+0x78>)
 8001974:	f008 faa4 	bl	8009ec0 <HAL_TIMEx_MasterConfigSynchronization>
 8001978:	b9a0      	cbnz	r0, 80019a4 <MX_TIM2_Init+0x6c>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800197a:	2360      	movs	r3, #96	; 0x60
 800197c:	9300      	str	r3, [sp, #0]
  sConfigOC.Pulse = 0;
 800197e:	2300      	movs	r3, #0
 8001980:	9301      	str	r3, [sp, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001982:	9302      	str	r3, [sp, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001984:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8001986:	2204      	movs	r2, #4
 8001988:	4669      	mov	r1, sp
 800198a:	4809      	ldr	r0, [pc, #36]	; (80019b0 <MX_TIM2_Init+0x78>)
 800198c:	f008 fa04 	bl	8009d98 <HAL_TIM_PWM_ConfigChannel>
 8001990:	b958      	cbnz	r0, 80019aa <MX_TIM2_Init+0x72>
  HAL_TIM_MspPostInit(&htim2);
 8001992:	4807      	ldr	r0, [pc, #28]	; (80019b0 <MX_TIM2_Init+0x78>)
 8001994:	f7ff ffa2 	bl	80018dc <HAL_TIM_MspPostInit>
}
 8001998:	b00b      	add	sp, #44	; 0x2c
 800199a:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 800199e:	f7ff fc4b 	bl	8001238 <Error_Handler>
 80019a2:	e7e2      	b.n	800196a <MX_TIM2_Init+0x32>
    Error_Handler();
 80019a4:	f7ff fc48 	bl	8001238 <Error_Handler>
 80019a8:	e7e7      	b.n	800197a <MX_TIM2_Init+0x42>
    Error_Handler();
 80019aa:	f7ff fc45 	bl	8001238 <Error_Handler>
 80019ae:	e7f0      	b.n	8001992 <MX_TIM2_Init+0x5a>
 80019b0:	20000b6c 	.word	0x20000b6c

080019b4 <MX_TIM3_Init>:
{
 80019b4:	b500      	push	{lr}
 80019b6:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80019b8:	2300      	movs	r3, #0
 80019ba:	9307      	str	r3, [sp, #28]
 80019bc:	9308      	str	r3, [sp, #32]
 80019be:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 80019c0:	9300      	str	r3, [sp, #0]
 80019c2:	9301      	str	r3, [sp, #4]
 80019c4:	9302      	str	r3, [sp, #8]
 80019c6:	9303      	str	r3, [sp, #12]
 80019c8:	9304      	str	r3, [sp, #16]
 80019ca:	9305      	str	r3, [sp, #20]
 80019cc:	9306      	str	r3, [sp, #24]
  htim3.Instance = TIM3;
 80019ce:	4817      	ldr	r0, [pc, #92]	; (8001a2c <MX_TIM3_Init+0x78>)
 80019d0:	4a17      	ldr	r2, [pc, #92]	; (8001a30 <MX_TIM3_Init+0x7c>)
 80019d2:	6002      	str	r2, [r0, #0]
  htim3.Init.Prescaler = 0;
 80019d4:	6043      	str	r3, [r0, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 80019d6:	6083      	str	r3, [r0, #8]
  htim3.Init.Period = 0;
 80019d8:	60c3      	str	r3, [r0, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80019da:	6103      	str	r3, [r0, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80019dc:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 80019de:	f008 f96f 	bl	8009cc0 <HAL_TIM_PWM_Init>
 80019e2:	b9c8      	cbnz	r0, 8001a18 <MX_TIM3_Init+0x64>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80019e4:	2300      	movs	r3, #0
 80019e6:	9307      	str	r3, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80019e8:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80019ea:	a907      	add	r1, sp, #28
 80019ec:	480f      	ldr	r0, [pc, #60]	; (8001a2c <MX_TIM3_Init+0x78>)
 80019ee:	f008 fa67 	bl	8009ec0 <HAL_TIMEx_MasterConfigSynchronization>
 80019f2:	b9a0      	cbnz	r0, 8001a1e <MX_TIM3_Init+0x6a>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80019f4:	2360      	movs	r3, #96	; 0x60
 80019f6:	9300      	str	r3, [sp, #0]
  sConfigOC.Pulse = 0;
 80019f8:	2300      	movs	r3, #0
 80019fa:	9301      	str	r3, [sp, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80019fc:	9302      	str	r3, [sp, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80019fe:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8001a00:	220c      	movs	r2, #12
 8001a02:	4669      	mov	r1, sp
 8001a04:	4809      	ldr	r0, [pc, #36]	; (8001a2c <MX_TIM3_Init+0x78>)
 8001a06:	f008 f9c7 	bl	8009d98 <HAL_TIM_PWM_ConfigChannel>
 8001a0a:	b958      	cbnz	r0, 8001a24 <MX_TIM3_Init+0x70>
  HAL_TIM_MspPostInit(&htim3);
 8001a0c:	4807      	ldr	r0, [pc, #28]	; (8001a2c <MX_TIM3_Init+0x78>)
 8001a0e:	f7ff ff65 	bl	80018dc <HAL_TIM_MspPostInit>
}
 8001a12:	b00b      	add	sp, #44	; 0x2c
 8001a14:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8001a18:	f7ff fc0e 	bl	8001238 <Error_Handler>
 8001a1c:	e7e2      	b.n	80019e4 <MX_TIM3_Init+0x30>
    Error_Handler();
 8001a1e:	f7ff fc0b 	bl	8001238 <Error_Handler>
 8001a22:	e7e7      	b.n	80019f4 <MX_TIM3_Init+0x40>
    Error_Handler();
 8001a24:	f7ff fc08 	bl	8001238 <Error_Handler>
 8001a28:	e7f0      	b.n	8001a0c <MX_TIM3_Init+0x58>
 8001a2a:	bf00      	nop
 8001a2c:	20000bb8 	.word	0x20000bb8
 8001a30:	40000400 	.word	0x40000400

08001a34 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart3;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8001a34:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
 8001a36:	480b      	ldr	r0, [pc, #44]	; (8001a64 <MX_USART1_UART_Init+0x30>)
 8001a38:	4b0b      	ldr	r3, [pc, #44]	; (8001a68 <MX_USART1_UART_Init+0x34>)
 8001a3a:	6003      	str	r3, [r0, #0]
  huart1.Init.BaudRate = 115200;
 8001a3c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8001a40:	6043      	str	r3, [r0, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8001a42:	2300      	movs	r3, #0
 8001a44:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001a46:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8001a48:	6103      	str	r3, [r0, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8001a4a:	220c      	movs	r2, #12
 8001a4c:	6142      	str	r2, [r0, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001a4e:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8001a50:	61c3      	str	r3, [r0, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001a52:	6203      	str	r3, [r0, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001a54:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8001a56:	f008 ffc8 	bl	800a9ea <HAL_UART_Init>
 8001a5a:	b900      	cbnz	r0, 8001a5e <MX_USART1_UART_Init+0x2a>
  {
    Error_Handler();
  }

}
 8001a5c:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001a5e:	f7ff fbeb 	bl	8001238 <Error_Handler>
}
 8001a62:	e7fb      	b.n	8001a5c <MX_USART1_UART_Init+0x28>
 8001a64:	20000c04 	.word	0x20000c04
 8001a68:	40013800 	.word	0x40013800

08001a6c <MX_USART2_UART_Init>:
/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 8001a6c:	b508      	push	{r3, lr}

  huart2.Instance = USART2;
 8001a6e:	480b      	ldr	r0, [pc, #44]	; (8001a9c <MX_USART2_UART_Init+0x30>)
 8001a70:	4b0b      	ldr	r3, [pc, #44]	; (8001aa0 <MX_USART2_UART_Init+0x34>)
 8001a72:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = 115200;
 8001a74:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8001a78:	6043      	str	r3, [r0, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8001a7a:	2300      	movs	r3, #0
 8001a7c:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001a7e:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8001a80:	6103      	str	r3, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001a82:	220c      	movs	r2, #12
 8001a84:	6142      	str	r2, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001a86:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8001a88:	61c3      	str	r3, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001a8a:	6203      	str	r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001a8c:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001a8e:	f008 ffac 	bl	800a9ea <HAL_UART_Init>
 8001a92:	b900      	cbnz	r0, 8001a96 <MX_USART2_UART_Init+0x2a>
  {
    Error_Handler();
  }

}
 8001a94:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001a96:	f7ff fbcf 	bl	8001238 <Error_Handler>
}
 8001a9a:	e7fb      	b.n	8001a94 <MX_USART2_UART_Init+0x28>
 8001a9c:	20000c84 	.word	0x20000c84
 8001aa0:	40004400 	.word	0x40004400

08001aa4 <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001aa6:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001aa8:	2300      	movs	r3, #0
 8001aaa:	9303      	str	r3, [sp, #12]
 8001aac:	9304      	str	r3, [sp, #16]
 8001aae:	9305      	str	r3, [sp, #20]
 8001ab0:	9306      	str	r3, [sp, #24]
 8001ab2:	9307      	str	r3, [sp, #28]
  if(uartHandle->Instance==USART1)
 8001ab4:	6803      	ldr	r3, [r0, #0]
 8001ab6:	4a43      	ldr	r2, [pc, #268]	; (8001bc4 <HAL_UART_MspInit+0x120>)
 8001ab8:	4293      	cmp	r3, r2
 8001aba:	d007      	beq.n	8001acc <HAL_UART_MspInit+0x28>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
  else if(uartHandle->Instance==USART2)
 8001abc:	4a42      	ldr	r2, [pc, #264]	; (8001bc8 <HAL_UART_MspInit+0x124>)
 8001abe:	4293      	cmp	r3, r2
 8001ac0:	d025      	beq.n	8001b0e <HAL_UART_MspInit+0x6a>

    /* will be reactivated later */
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE END USART2_MspInit 1 */
  }
  else if(uartHandle->Instance==USART3)
 8001ac2:	4a42      	ldr	r2, [pc, #264]	; (8001bcc <HAL_UART_MspInit+0x128>)
 8001ac4:	4293      	cmp	r3, r2
 8001ac6:	d045      	beq.n	8001b54 <HAL_UART_MspInit+0xb0>
  /* USER CODE BEGIN USART3_MspInit 1 */
    /* disable IRQ to avoid problems with IPC - will be reactivated later */
    HAL_NVIC_DisableIRQ(USART3_IRQn);
  /* USER CODE END USART3_MspInit 1 */
  }
}
 8001ac8:	b009      	add	sp, #36	; 0x24
 8001aca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_USART1_CLK_ENABLE();
 8001acc:	4b40      	ldr	r3, [pc, #256]	; (8001bd0 <HAL_UART_MspInit+0x12c>)
 8001ace:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001ad0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001ad4:	661a      	str	r2, [r3, #96]	; 0x60
 8001ad6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001ad8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001adc:	9300      	str	r3, [sp, #0]
 8001ade:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = ARD_D2_Pin|ARD_D8_Pin;
 8001ae0:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001ae4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001ae6:	2302      	movs	r3, #2
 8001ae8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001aea:	2303      	movs	r3, #3
 8001aec:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8001aee:	2307      	movs	r3, #7
 8001af0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001af2:	a903      	add	r1, sp, #12
 8001af4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001af8:	f005 fe76 	bl	80077e8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 8001afc:	2200      	movs	r2, #0
 8001afe:	2105      	movs	r1, #5
 8001b00:	2025      	movs	r0, #37	; 0x25
 8001b02:	f005 fdcd 	bl	80076a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8001b06:	2025      	movs	r0, #37	; 0x25
 8001b08:	f005 fe02 	bl	8007710 <HAL_NVIC_EnableIRQ>
 8001b0c:	e7dc      	b.n	8001ac8 <HAL_UART_MspInit+0x24>
    __HAL_RCC_USART2_CLK_ENABLE();
 8001b0e:	4b30      	ldr	r3, [pc, #192]	; (8001bd0 <HAL_UART_MspInit+0x12c>)
 8001b10:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001b12:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001b16:	659a      	str	r2, [r3, #88]	; 0x58
 8001b18:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b1a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001b1e:	9301      	str	r3, [sp, #4]
 8001b20:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = ARD_A1_Pin|ARD_D0_Pin|ARD_D1_Pin|ARD_A0_Pin;
 8001b22:	230f      	movs	r3, #15
 8001b24:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b26:	2302      	movs	r3, #2
 8001b28:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b2a:	2303      	movs	r3, #3
 8001b2c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8001b2e:	2307      	movs	r3, #7
 8001b30:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b32:	a903      	add	r1, sp, #12
 8001b34:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001b38:	f005 fe56 	bl	80077e8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
 8001b3c:	2200      	movs	r2, #0
 8001b3e:	2105      	movs	r1, #5
 8001b40:	2026      	movs	r0, #38	; 0x26
 8001b42:	f005 fdad 	bl	80076a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8001b46:	2026      	movs	r0, #38	; 0x26
 8001b48:	f005 fde2 	bl	8007710 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 8001b4c:	2026      	movs	r0, #38	; 0x26
 8001b4e:	f005 fded 	bl	800772c <HAL_NVIC_DisableIRQ>
 8001b52:	e7b9      	b.n	8001ac8 <HAL_UART_MspInit+0x24>
    __HAL_RCC_USART3_CLK_ENABLE();
 8001b54:	4b1e      	ldr	r3, [pc, #120]	; (8001bd0 <HAL_UART_MspInit+0x12c>)
 8001b56:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001b58:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001b5c:	659a      	str	r2, [r3, #88]	; 0x58
 8001b5e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b60:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001b64:	9302      	str	r3, [sp, #8]
 8001b66:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = MDM_UART_RTS_Pin;
 8001b68:	2304      	movs	r3, #4
 8001b6a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b6c:	2702      	movs	r7, #2
 8001b6e:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b70:	2603      	movs	r6, #3
 8001b72:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001b74:	2507      	movs	r5, #7
 8001b76:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(MDM_UART_RTS_GPIO_Port, &GPIO_InitStruct);
 8001b78:	a903      	add	r1, sp, #12
 8001b7a:	4816      	ldr	r0, [pc, #88]	; (8001bd4 <HAL_UART_MspInit+0x130>)
 8001b7c:	f005 fe34 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = MDM_UART_TX_Pin|MDM_UART_RX_Pin;
 8001b80:	2330      	movs	r3, #48	; 0x30
 8001b82:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b84:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b86:	2400      	movs	r4, #0
 8001b88:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b8a:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001b8c:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001b8e:	a903      	add	r1, sp, #12
 8001b90:	4811      	ldr	r0, [pc, #68]	; (8001bd8 <HAL_UART_MspInit+0x134>)
 8001b92:	f005 fe29 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = MDM_UART_CTS_Pin;
 8001b96:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001b9a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b9c:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b9e:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001ba0:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001ba2:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(MDM_UART_CTS_GPIO_Port, &GPIO_InitStruct);
 8001ba4:	a903      	add	r1, sp, #12
 8001ba6:	480d      	ldr	r0, [pc, #52]	; (8001bdc <HAL_UART_MspInit+0x138>)
 8001ba8:	f005 fe1e 	bl	80077e8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
 8001bac:	4622      	mov	r2, r4
 8001bae:	2105      	movs	r1, #5
 8001bb0:	2027      	movs	r0, #39	; 0x27
 8001bb2:	f005 fd75 	bl	80076a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 8001bb6:	2027      	movs	r0, #39	; 0x27
 8001bb8:	f005 fdaa 	bl	8007710 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
 8001bbc:	2027      	movs	r0, #39	; 0x27
 8001bbe:	f005 fdb5 	bl	800772c <HAL_NVIC_DisableIRQ>
}
 8001bc2:	e781      	b.n	8001ac8 <HAL_UART_MspInit+0x24>
 8001bc4:	40013800 	.word	0x40013800
 8001bc8:	40004400 	.word	0x40004400
 8001bcc:	40004800 	.word	0x40004800
 8001bd0:	40021000 	.word	0x40021000
 8001bd4:	48000c00 	.word	0x48000c00
 8001bd8:	48000800 	.word	0x48000800
 8001bdc:	48000400 	.word	0x48000400

08001be0 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{
 8001be0:	b508      	push	{r3, lr}

  if(uartHandle->Instance==USART1)
 8001be2:	6803      	ldr	r3, [r0, #0]
 8001be4:	4a1f      	ldr	r2, [pc, #124]	; (8001c64 <HAL_UART_MspDeInit+0x84>)
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d006      	beq.n	8001bf8 <HAL_UART_MspDeInit+0x18>
    HAL_NVIC_DisableIRQ(USART1_IRQn);
  /* USER CODE BEGIN USART1_MspDeInit 1 */

  /* USER CODE END USART1_MspDeInit 1 */
  }
  else if(uartHandle->Instance==USART2)
 8001bea:	4a1f      	ldr	r2, [pc, #124]	; (8001c68 <HAL_UART_MspDeInit+0x88>)
 8001bec:	4293      	cmp	r3, r2
 8001bee:	d013      	beq.n	8001c18 <HAL_UART_MspDeInit+0x38>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
  else if(uartHandle->Instance==USART3)
 8001bf0:	4a1e      	ldr	r2, [pc, #120]	; (8001c6c <HAL_UART_MspDeInit+0x8c>)
 8001bf2:	4293      	cmp	r3, r2
 8001bf4:	d01f      	beq.n	8001c36 <HAL_UART_MspDeInit+0x56>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
  /* USER CODE BEGIN USART3_MspDeInit 1 */

  /* USER CODE END USART3_MspDeInit 1 */
  }
} 
 8001bf6:	bd08      	pop	{r3, pc}
    __HAL_RCC_USART1_CLK_DISABLE();
 8001bf8:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
 8001bfc:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8001bfe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001c02:	6613      	str	r3, [r2, #96]	; 0x60
    HAL_GPIO_DeInit(GPIOA, ARD_D2_Pin|ARD_D8_Pin);
 8001c04:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8001c08:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001c0c:	f005 febe 	bl	800798c <HAL_GPIO_DeInit>
    HAL_NVIC_DisableIRQ(USART1_IRQn);
 8001c10:	2025      	movs	r0, #37	; 0x25
 8001c12:	f005 fd8b 	bl	800772c <HAL_NVIC_DisableIRQ>
 8001c16:	e7ee      	b.n	8001bf6 <HAL_UART_MspDeInit+0x16>
    __HAL_RCC_USART2_CLK_DISABLE();
 8001c18:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 8001c1c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001c1e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001c22:	6593      	str	r3, [r2, #88]	; 0x58
    HAL_GPIO_DeInit(GPIOA, ARD_A1_Pin|ARD_D0_Pin|ARD_D1_Pin|ARD_A0_Pin);
 8001c24:	210f      	movs	r1, #15
 8001c26:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001c2a:	f005 feaf 	bl	800798c <HAL_GPIO_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 8001c2e:	2026      	movs	r0, #38	; 0x26
 8001c30:	f005 fd7c 	bl	800772c <HAL_NVIC_DisableIRQ>
 8001c34:	e7df      	b.n	8001bf6 <HAL_UART_MspDeInit+0x16>
    __HAL_RCC_USART3_CLK_DISABLE();
 8001c36:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 8001c3a:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001c3c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001c40:	6593      	str	r3, [r2, #88]	; 0x58
    HAL_GPIO_DeInit(MDM_UART_RTS_GPIO_Port, MDM_UART_RTS_Pin);
 8001c42:	2104      	movs	r1, #4
 8001c44:	480a      	ldr	r0, [pc, #40]	; (8001c70 <HAL_UART_MspDeInit+0x90>)
 8001c46:	f005 fea1 	bl	800798c <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOC, MDM_UART_TX_Pin|MDM_UART_RX_Pin);
 8001c4a:	2130      	movs	r1, #48	; 0x30
 8001c4c:	4809      	ldr	r0, [pc, #36]	; (8001c74 <HAL_UART_MspDeInit+0x94>)
 8001c4e:	f005 fe9d 	bl	800798c <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(MDM_UART_CTS_GPIO_Port, MDM_UART_CTS_Pin);
 8001c52:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001c56:	4808      	ldr	r0, [pc, #32]	; (8001c78 <HAL_UART_MspDeInit+0x98>)
 8001c58:	f005 fe98 	bl	800798c <HAL_GPIO_DeInit>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
 8001c5c:	2027      	movs	r0, #39	; 0x27
 8001c5e:	f005 fd65 	bl	800772c <HAL_NVIC_DisableIRQ>
} 
 8001c62:	e7c8      	b.n	8001bf6 <HAL_UART_MspDeInit+0x16>
 8001c64:	40013800 	.word	0x40013800
 8001c68:	40004400 	.word	0x40004400
 8001c6c:	40004800 	.word	0x40004800
 8001c70:	48000c00 	.word	0x48000c00
 8001c74:	48000800 	.word	0x48000800
 8001c78:	48000400 	.word	0x48000400

08001c7c <MX_USB_PCD_Init>:
PCD_HandleTypeDef hpcd_USB_FS;

/* USB init function */

void MX_USB_PCD_Init(void)
{
 8001c7c:	b508      	push	{r3, lr}

  hpcd_USB_FS.Instance = USB;
 8001c7e:	480a      	ldr	r0, [pc, #40]	; (8001ca8 <MX_USB_PCD_Init+0x2c>)
 8001c80:	4b0a      	ldr	r3, [pc, #40]	; (8001cac <MX_USB_PCD_Init+0x30>)
 8001c82:	6003      	str	r3, [r0, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8001c84:	2308      	movs	r3, #8
 8001c86:	6043      	str	r3, [r0, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8001c88:	2202      	movs	r2, #2
 8001c8a:	6082      	str	r2, [r0, #8]
  hpcd_USB_FS.Init.ep0_mps = EP_MPS_64;
 8001c8c:	2300      	movs	r3, #0
 8001c8e:	60c3      	str	r3, [r0, #12]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8001c90:	6102      	str	r2, [r0, #16]
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
 8001c92:	6143      	str	r3, [r0, #20]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8001c94:	6183      	str	r3, [r0, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8001c96:	61c3      	str	r3, [r0, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8001c98:	6203      	str	r3, [r0, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8001c9a:	f006 fb03 	bl	80082a4 <HAL_PCD_Init>
 8001c9e:	b900      	cbnz	r0, 8001ca2 <MX_USB_PCD_Init+0x26>
  {
    Error_Handler();
  }

}
 8001ca0:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001ca2:	f7ff fac9 	bl	8001238 <Error_Handler>
}
 8001ca6:	e7fb      	b.n	8001ca0 <MX_USB_PCD_Init+0x24>
 8001ca8:	20000d84 	.word	0x20000d84
 8001cac:	40006800 	.word	0x40006800

08001cb0 <HAL_PCD_MspInit>:

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8001cb0:	b500      	push	{lr}
 8001cb2:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001cb4:	2300      	movs	r3, #0
 8001cb6:	9301      	str	r3, [sp, #4]
 8001cb8:	9302      	str	r3, [sp, #8]
 8001cba:	9303      	str	r3, [sp, #12]
 8001cbc:	9304      	str	r3, [sp, #16]
 8001cbe:	9305      	str	r3, [sp, #20]
  if(pcdHandle->Instance==USB)
 8001cc0:	6802      	ldr	r2, [r0, #0]
 8001cc2:	4b0f      	ldr	r3, [pc, #60]	; (8001d00 <HAL_PCD_MspInit+0x50>)
 8001cc4:	429a      	cmp	r2, r3
 8001cc6:	d002      	beq.n	8001cce <HAL_PCD_MspInit+0x1e>
    __HAL_RCC_USB_CLK_ENABLE();
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8001cc8:	b007      	add	sp, #28
 8001cca:	f85d fb04 	ldr.w	pc, [sp], #4
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8001cce:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8001cd2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001cd4:	2302      	movs	r3, #2
 8001cd6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001cd8:	2303      	movs	r3, #3
 8001cda:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
 8001cdc:	230a      	movs	r3, #10
 8001cde:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ce0:	a901      	add	r1, sp, #4
 8001ce2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001ce6:	f005 fd7f 	bl	80077e8 <HAL_GPIO_Init>
    __HAL_RCC_USB_CLK_ENABLE();
 8001cea:	4b06      	ldr	r3, [pc, #24]	; (8001d04 <HAL_PCD_MspInit+0x54>)
 8001cec:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001cee:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001cf2:	659a      	str	r2, [r3, #88]	; 0x58
 8001cf4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001cf6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8001cfa:	9300      	str	r3, [sp, #0]
 8001cfc:	9b00      	ldr	r3, [sp, #0]
}
 8001cfe:	e7e3      	b.n	8001cc8 <HAL_PCD_MspInit+0x18>
 8001d00:	40006800 	.word	0x40006800
 8001d04:	40021000 	.word	0x40021000

08001d08 <I2Cx_Error>:
  * @param  i2c_handler : I2C handler
  * @param  Addr: I2C Address
  * @retval None
  */
static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
{
 8001d08:	b508      	push	{r3, lr}
  /* De-initialize the I2C communication bus */
  HAL_I2C_DeInit(i2c_handler);
 8001d0a:	f006 f8ab 	bl	8007e64 <HAL_I2C_DeInit>
}
 8001d0e:	bd08      	pop	{r3, pc}

08001d10 <I2Cx_WriteMultiple>:
{
 8001d10:	b570      	push	{r4, r5, r6, lr}
 8001d12:	b084      	sub	sp, #16
 8001d14:	4605      	mov	r5, r0
 8001d16:	460c      	mov	r4, r1
  status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8001d18:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001d1c:	9102      	str	r1, [sp, #8]
 8001d1e:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8001d22:	9101      	str	r1, [sp, #4]
 8001d24:	9908      	ldr	r1, [sp, #32]
 8001d26:	9100      	str	r1, [sp, #0]
 8001d28:	4621      	mov	r1, r4
 8001d2a:	f006 f8b4 	bl	8007e96 <HAL_I2C_Mem_Write>
  if (status != HAL_OK)
 8001d2e:	4606      	mov	r6, r0
 8001d30:	b910      	cbnz	r0, 8001d38 <I2Cx_WriteMultiple+0x28>
}
 8001d32:	4630      	mov	r0, r6
 8001d34:	b004      	add	sp, #16
 8001d36:	bd70      	pop	{r4, r5, r6, pc}
    I2Cx_Error(i2c_handler, Addr);
 8001d38:	4621      	mov	r1, r4
 8001d3a:	4628      	mov	r0, r5
 8001d3c:	f7ff ffe4 	bl	8001d08 <I2Cx_Error>
 8001d40:	e7f7      	b.n	8001d32 <I2Cx_WriteMultiple+0x22>

08001d42 <I2Cx_ReadMultiple>:
{
 8001d42:	b570      	push	{r4, r5, r6, lr}
 8001d44:	b084      	sub	sp, #16
 8001d46:	4605      	mov	r5, r0
 8001d48:	460c      	mov	r4, r1
  status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8001d4a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001d4e:	9102      	str	r1, [sp, #8]
 8001d50:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8001d54:	9101      	str	r1, [sp, #4]
 8001d56:	9908      	ldr	r1, [sp, #32]
 8001d58:	9100      	str	r1, [sp, #0]
 8001d5a:	4621      	mov	r1, r4
 8001d5c:	f006 f970 	bl	8008040 <HAL_I2C_Mem_Read>
  if (status != HAL_OK)
 8001d60:	4606      	mov	r6, r0
 8001d62:	b910      	cbnz	r0, 8001d6a <I2Cx_ReadMultiple+0x28>
}
 8001d64:	4630      	mov	r0, r6
 8001d66:	b004      	add	sp, #16
 8001d68:	bd70      	pop	{r4, r5, r6, pc}
    I2Cx_Error(i2c_handler, Addr);
 8001d6a:	4621      	mov	r1, r4
 8001d6c:	4628      	mov	r0, r5
 8001d6e:	f7ff ffcb 	bl	8001d08 <I2Cx_Error>
 8001d72:	e7f7      	b.n	8001d64 <I2Cx_ReadMultiple+0x22>

08001d74 <BSP_LED_Init>:
{
 8001d74:	b570      	push	{r4, r5, r6, lr}
 8001d76:	b088      	sub	sp, #32
  LEDx_GPIO_CLK_ENABLE(Led);
 8001d78:	4604      	mov	r4, r0
 8001d7a:	bb10      	cbnz	r0, 8001dc2 <BSP_LED_Init+0x4e>
 8001d7c:	4b1e      	ldr	r3, [pc, #120]	; (8001df8 <BSP_LED_Init+0x84>)
 8001d7e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001d80:	f042 0204 	orr.w	r2, r2, #4
 8001d84:	64da      	str	r2, [r3, #76]	; 0x4c
 8001d86:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001d88:	f003 0304 	and.w	r3, r3, #4
 8001d8c:	9300      	str	r3, [sp, #0]
 8001d8e:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Pin   = GPIO_PIN[Led];
 8001d90:	4b1a      	ldr	r3, [pc, #104]	; (8001dfc <BSP_LED_Init+0x88>)
 8001d92:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8001d96:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 8001d98:	2301      	movs	r3, #1
 8001d9a:	9304      	str	r3, [sp, #16]
  gpio_init_structure.Pull  = GPIO_NOPULL;
 8001d9c:	2600      	movs	r6, #0
 8001d9e:	9605      	str	r6, [sp, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8001da0:	2302      	movs	r3, #2
 8001da2:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIO_PORT[Led], &gpio_init_structure);
 8001da4:	4d16      	ldr	r5, [pc, #88]	; (8001e00 <BSP_LED_Init+0x8c>)
 8001da6:	a903      	add	r1, sp, #12
 8001da8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8001dac:	f005 fd1c 	bl	80077e8 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIO_PORT[Led], gpio_init_structure.Pin, GPIO_PIN_RESET);
 8001db0:	4632      	mov	r2, r6
 8001db2:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 8001db6:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8001dba:	f005 fe74 	bl	8007aa6 <HAL_GPIO_WritePin>
}
 8001dbe:	b008      	add	sp, #32
 8001dc0:	bd70      	pop	{r4, r5, r6, pc}
  LEDx_GPIO_CLK_ENABLE(Led);
 8001dc2:	2801      	cmp	r0, #1
 8001dc4:	d00c      	beq.n	8001de0 <BSP_LED_Init+0x6c>
 8001dc6:	2802      	cmp	r0, #2
 8001dc8:	d1e2      	bne.n	8001d90 <BSP_LED_Init+0x1c>
 8001dca:	4b0b      	ldr	r3, [pc, #44]	; (8001df8 <BSP_LED_Init+0x84>)
 8001dcc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001dce:	f042 0202 	orr.w	r2, r2, #2
 8001dd2:	64da      	str	r2, [r3, #76]	; 0x4c
 8001dd4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001dd6:	f003 0302 	and.w	r3, r3, #2
 8001dda:	9302      	str	r3, [sp, #8]
 8001ddc:	9b02      	ldr	r3, [sp, #8]
 8001dde:	e7d7      	b.n	8001d90 <BSP_LED_Init+0x1c>
 8001de0:	4b05      	ldr	r3, [pc, #20]	; (8001df8 <BSP_LED_Init+0x84>)
 8001de2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001de4:	f042 0202 	orr.w	r2, r2, #2
 8001de8:	64da      	str	r2, [r3, #76]	; 0x4c
 8001dea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001dec:	f003 0302 	and.w	r3, r3, #2
 8001df0:	9301      	str	r3, [sp, #4]
 8001df2:	9b01      	ldr	r3, [sp, #4]
 8001df4:	e7cc      	b.n	8001d90 <BSP_LED_Init+0x1c>
 8001df6:	bf00      	nop
 8001df8:	40021000 	.word	0x40021000
 8001dfc:	0802a6c0 	.word	0x0802a6c0
 8001e00:	20000000 	.word	0x20000000

08001e04 <SENSOR_IO_Init>:
  * @brief  Initializes Sensors low level.
  * @retval None
  */
void SENSOR_IO_Init(void)
{
  __NOP();
 8001e04:	bf00      	nop
}
 8001e06:	4770      	bx	lr

08001e08 <SENSOR_IO_Write>:
  * @param  Reg: Reg address
  * @param  Value: Data to be written
  * @retval None
  */
void SENSOR_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 8001e08:	b500      	push	{lr}
 8001e0a:	b085      	sub	sp, #20
 8001e0c:	f88d 200f 	strb.w	r2, [sp, #15]
  I2Cx_WriteMultiple(&hi2c1, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t *)&Value, 1);
 8001e10:	2301      	movs	r3, #1
 8001e12:	9301      	str	r3, [sp, #4]
 8001e14:	f10d 020f 	add.w	r2, sp, #15
 8001e18:	9200      	str	r2, [sp, #0]
 8001e1a:	460a      	mov	r2, r1
 8001e1c:	4601      	mov	r1, r0
 8001e1e:	4803      	ldr	r0, [pc, #12]	; (8001e2c <SENSOR_IO_Write+0x24>)
 8001e20:	f7ff ff76 	bl	8001d10 <I2Cx_WriteMultiple>
}
 8001e24:	b005      	add	sp, #20
 8001e26:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e2a:	bf00      	nop
 8001e2c:	20000988 	.word	0x20000988

08001e30 <SENSOR_IO_Read>:
  * @param  Addr: I2C address
  * @param  Reg: Reg address
  * @retval Data to be read
  */
uint8_t SENSOR_IO_Read(uint8_t Addr, uint8_t Reg)
{
 8001e30:	b500      	push	{lr}
 8001e32:	b085      	sub	sp, #20
 8001e34:	460a      	mov	r2, r1
  uint8_t read_value = 0;
 8001e36:	2300      	movs	r3, #0
 8001e38:	f88d 300f 	strb.w	r3, [sp, #15]

  I2Cx_ReadMultiple(&hi2c1, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t *)&read_value, 1);
 8001e3c:	2301      	movs	r3, #1
 8001e3e:	9301      	str	r3, [sp, #4]
 8001e40:	f10d 010f 	add.w	r1, sp, #15
 8001e44:	9100      	str	r1, [sp, #0]
 8001e46:	4601      	mov	r1, r0
 8001e48:	4803      	ldr	r0, [pc, #12]	; (8001e58 <SENSOR_IO_Read+0x28>)
 8001e4a:	f7ff ff7a 	bl	8001d42 <I2Cx_ReadMultiple>

  return read_value;
}
 8001e4e:	f89d 000f 	ldrb.w	r0, [sp, #15]
 8001e52:	b005      	add	sp, #20
 8001e54:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e58:	20000988 	.word	0x20000988

08001e5c <SENSOR_IO_ReadMultiple>:
  * @param  Buffer: Pointer to data buffer
  * @param  Length: Length of the data
  * @retval HAL status
  */
uint16_t SENSOR_IO_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t *Buffer, uint16_t Length)
{
 8001e5c:	b500      	push	{lr}
 8001e5e:	b083      	sub	sp, #12
  return I2Cx_ReadMultiple(&hi2c1, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
 8001e60:	9301      	str	r3, [sp, #4]
 8001e62:	9200      	str	r2, [sp, #0]
 8001e64:	2301      	movs	r3, #1
 8001e66:	460a      	mov	r2, r1
 8001e68:	4601      	mov	r1, r0
 8001e6a:	4803      	ldr	r0, [pc, #12]	; (8001e78 <SENSOR_IO_ReadMultiple+0x1c>)
 8001e6c:	f7ff ff69 	bl	8001d42 <I2Cx_ReadMultiple>
}
 8001e70:	b280      	uxth	r0, r0
 8001e72:	b003      	add	sp, #12
 8001e74:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e78:	20000988 	.word	0x20000988

08001e7c <BSP_HSENSOR_Init>:
/**
  * @brief  Initializes peripherals used by the I2C Humidity Sensor driver.
  * @retval HSENSOR status
  */
uint32_t BSP_HSENSOR_Init(void)
{
 8001e7c:	b508      	push	{r3, lr}
  uint32_t ret;

  if (HTS221_H_Drv.ReadID(HTS221_I2C_ADDRESS) != HTS221_WHO_AM_I_VAL)
 8001e7e:	4b08      	ldr	r3, [pc, #32]	; (8001ea0 <BSP_HSENSOR_Init+0x24>)
 8001e80:	685b      	ldr	r3, [r3, #4]
 8001e82:	20be      	movs	r0, #190	; 0xbe
 8001e84:	4798      	blx	r3
 8001e86:	28bc      	cmp	r0, #188	; 0xbc
 8001e88:	d001      	beq.n	8001e8e <BSP_HSENSOR_Init+0x12>
  {
    ret = HSENSOR_ERROR;
 8001e8a:	2001      	movs	r0, #1
    Hsensor_drv->Init(HTS221_I2C_ADDRESS);
    ret = HSENSOR_OK;
  }

  return ret;
}
 8001e8c:	bd08      	pop	{r3, pc}
    Hsensor_drv = &HTS221_H_Drv;
 8001e8e:	4b04      	ldr	r3, [pc, #16]	; (8001ea0 <BSP_HSENSOR_Init+0x24>)
 8001e90:	4a04      	ldr	r2, [pc, #16]	; (8001ea4 <BSP_HSENSOR_Init+0x28>)
 8001e92:	6013      	str	r3, [r2, #0]
    Hsensor_drv->Init(HTS221_I2C_ADDRESS);
 8001e94:	681b      	ldr	r3, [r3, #0]
 8001e96:	20be      	movs	r0, #190	; 0xbe
 8001e98:	4798      	blx	r3
    ret = HSENSOR_OK;
 8001e9a:	2000      	movs	r0, #0
 8001e9c:	e7f6      	b.n	8001e8c <BSP_HSENSOR_Init+0x10>
 8001e9e:	bf00      	nop
 8001ea0:	2000000c 	.word	0x2000000c
 8001ea4:	20001078 	.word	0x20001078

08001ea8 <BSP_HSENSOR_ReadHumidity>:
/**
  * @brief  Read Humidity register of HTS221.
  * @retval HTS221 measured humidity value.
  */
float BSP_HSENSOR_ReadHumidity(void)
{
 8001ea8:	b508      	push	{r3, lr}
  return Hsensor_drv->ReadHumidity(HTS221_I2C_ADDRESS);
 8001eaa:	4b03      	ldr	r3, [pc, #12]	; (8001eb8 <BSP_HSENSOR_ReadHumidity+0x10>)
 8001eac:	681b      	ldr	r3, [r3, #0]
 8001eae:	689b      	ldr	r3, [r3, #8]
 8001eb0:	20be      	movs	r0, #190	; 0xbe
 8001eb2:	4798      	blx	r3
}
 8001eb4:	bd08      	pop	{r3, pc}
 8001eb6:	bf00      	nop
 8001eb8:	20001078 	.word	0x20001078

08001ebc <BSP_PSENSOR_Init>:
/**
  * @brief  Initializes peripherals used by the I2C Pressure Sensor driver.
  * @retval PSENSOR status
  */
uint32_t BSP_PSENSOR_Init(void)
{
 8001ebc:	b508      	push	{r3, lr}
  uint32_t ret;

  if (LPS22HB_P_Drv.ReadID(LPS22HB_I2C_ADDRESS) != LPS22HB_WHO_AM_I_VAL)
 8001ebe:	4b08      	ldr	r3, [pc, #32]	; (8001ee0 <BSP_PSENSOR_Init+0x24>)
 8001ec0:	685b      	ldr	r3, [r3, #4]
 8001ec2:	20ba      	movs	r0, #186	; 0xba
 8001ec4:	4798      	blx	r3
 8001ec6:	28b1      	cmp	r0, #177	; 0xb1
 8001ec8:	d001      	beq.n	8001ece <BSP_PSENSOR_Init+0x12>
  {
    ret = PSENSOR_ERROR;
 8001eca:	2001      	movs	r0, #1
    Psensor_drv->Init(LPS22HB_I2C_ADDRESS);
    ret = PSENSOR_OK;
  }

  return ret;
}
 8001ecc:	bd08      	pop	{r3, pc}
    Psensor_drv = &LPS22HB_P_Drv;
 8001ece:	4b04      	ldr	r3, [pc, #16]	; (8001ee0 <BSP_PSENSOR_Init+0x24>)
 8001ed0:	4a04      	ldr	r2, [pc, #16]	; (8001ee4 <BSP_PSENSOR_Init+0x28>)
 8001ed2:	6013      	str	r3, [r2, #0]
    Psensor_drv->Init(LPS22HB_I2C_ADDRESS);
 8001ed4:	681b      	ldr	r3, [r3, #0]
 8001ed6:	20ba      	movs	r0, #186	; 0xba
 8001ed8:	4798      	blx	r3
    ret = PSENSOR_OK;
 8001eda:	2000      	movs	r0, #0
 8001edc:	e7f6      	b.n	8001ecc <BSP_PSENSOR_Init+0x10>
 8001ede:	bf00      	nop
 8001ee0:	20000028 	.word	0x20000028
 8001ee4:	2000107c 	.word	0x2000107c

08001ee8 <BSP_PSENSOR_ReadPressure>:
/**
  * @brief  Read Pressure register of LPS22HB.
  * @retval LPS22HB measured pressure value.
  */
float BSP_PSENSOR_ReadPressure(void)
{
 8001ee8:	b508      	push	{r3, lr}
  return Psensor_drv->ReadPressure(LPS22HB_I2C_ADDRESS);
 8001eea:	4b03      	ldr	r3, [pc, #12]	; (8001ef8 <BSP_PSENSOR_ReadPressure+0x10>)
 8001eec:	681b      	ldr	r3, [r3, #0]
 8001eee:	689b      	ldr	r3, [r3, #8]
 8001ef0:	20ba      	movs	r0, #186	; 0xba
 8001ef2:	4798      	blx	r3
}
 8001ef4:	bd08      	pop	{r3, pc}
 8001ef6:	bf00      	nop
 8001ef8:	2000107c 	.word	0x2000107c

08001efc <BSP_TSENSOR_Init>:
/**
  * @brief  Initializes peripherals used by the I2C Temperature Sensor driver.
  * @retval TSENSOR status
  */
uint32_t BSP_TSENSOR_Init(void)
{
 8001efc:	b510      	push	{r4, lr}
  uint8_t ret = TSENSOR_ERROR;

#ifdef USE_LPS22HB_TEMP
  tsensor_drv = &LPS22HB_T_Drv;
#else  /* USE_HTS221_TEMP */
  tsensor_drv = &HTS221_T_Drv;
 8001efe:	4c06      	ldr	r4, [pc, #24]	; (8001f18 <BSP_TSENSOR_Init+0x1c>)
 8001f00:	4b06      	ldr	r3, [pc, #24]	; (8001f1c <BSP_TSENSOR_Init+0x20>)
 8001f02:	6023      	str	r3, [r4, #0]
#endif /* USE_LPS22HB_TEMP */

  /* Low level init */
  SENSOR_IO_Init();
 8001f04:	f7ff ff7e 	bl	8001e04 <SENSOR_IO_Init>

  /* TSENSOR Init */
  tsensor_drv->Init(TSENSOR_I2C_ADDRESS, NULL);
 8001f08:	6823      	ldr	r3, [r4, #0]
 8001f0a:	681b      	ldr	r3, [r3, #0]
 8001f0c:	2100      	movs	r1, #0
 8001f0e:	20be      	movs	r0, #190	; 0xbe
 8001f10:	4798      	blx	r3

  ret = TSENSOR_OK;

  return ret;
}
 8001f12:	2000      	movs	r0, #0
 8001f14:	bd10      	pop	{r4, pc}
 8001f16:	bf00      	nop
 8001f18:	20001080 	.word	0x20001080
 8001f1c:	20000018 	.word	0x20000018

08001f20 <BSP_TSENSOR_ReadTemp>:
/**
  * @brief  Read Temperature register of TS751.
  * @retval STTS751 measured temperature value.
  */
float BSP_TSENSOR_ReadTemp(void)
{
 8001f20:	b508      	push	{r3, lr}
  return tsensor_drv->ReadTemp(TSENSOR_I2C_ADDRESS);
 8001f22:	4b03      	ldr	r3, [pc, #12]	; (8001f30 <BSP_TSENSOR_ReadTemp+0x10>)
 8001f24:	681b      	ldr	r3, [r3, #0]
 8001f26:	68db      	ldr	r3, [r3, #12]
 8001f28:	20be      	movs	r0, #190	; 0xbe
 8001f2a:	4798      	blx	r3
}
 8001f2c:	bd08      	pop	{r3, pc}
 8001f2e:	bf00      	nop
 8001f30:	20001080 	.word	0x20001080

08001f34 <HTS221_H_Init>:
  */
/**
  * @brief  Set HTS221 humidity sensor Initialization.
  */
void HTS221_H_Init(uint16_t DeviceAddr)
{
 8001f34:	b510      	push	{r4, lr}
  uint8_t tmp;
  
  /* Read CTRL_REG1 */
  tmp = SENSOR_IO_Read(DeviceAddr, HTS221_CTRL_REG1);
 8001f36:	b2c4      	uxtb	r4, r0
 8001f38:	2120      	movs	r1, #32
 8001f3a:	4620      	mov	r0, r4
 8001f3c:	f7ff ff78 	bl	8001e30 <SENSOR_IO_Read>
  /* Enable BDU */
  tmp &= ~HTS221_BDU_MASK;
  tmp |= (1 << HTS221_BDU_BIT);
  
  /* Set default ODR */
  tmp &= ~HTS221_ODR_MASK;
 8001f40:	f000 02f8 	and.w	r2, r0, #248	; 0xf8
  
  /* Activate the device */
  tmp |= HTS221_PD_MASK;
  
  /* Apply settings to CTRL_REG1 */
  SENSOR_IO_Write(DeviceAddr, HTS221_CTRL_REG1, tmp);
 8001f44:	f042 0285 	orr.w	r2, r2, #133	; 0x85
 8001f48:	2120      	movs	r1, #32
 8001f4a:	4620      	mov	r0, r4
 8001f4c:	f7ff ff5c 	bl	8001e08 <SENSOR_IO_Write>
}
 8001f50:	bd10      	pop	{r4, pc}

08001f52 <HTS221_T_Init>:
  * @param  DeviceAddr: I2C device address
  * @param  InitStruct: pointer to a TSENSOR_InitTypeDef structure 
  *         that contains the configuration setting for the HTS221.
  */
void HTS221_T_Init(uint16_t DeviceAddr, TSENSOR_InitTypeDef *pInitStruct)
{  
 8001f52:	b510      	push	{r4, lr}
  uint8_t tmp;
  
  /* Read CTRL_REG1 */
  tmp = SENSOR_IO_Read(DeviceAddr, HTS221_CTRL_REG1);
 8001f54:	b2c4      	uxtb	r4, r0
 8001f56:	2120      	movs	r1, #32
 8001f58:	4620      	mov	r0, r4
 8001f5a:	f7ff ff69 	bl	8001e30 <SENSOR_IO_Read>
  /* Enable BDU */
  tmp &= ~HTS221_BDU_MASK;
  tmp |= (1 << HTS221_BDU_BIT);
  
  /* Set default ODR */
  tmp &= ~HTS221_ODR_MASK;
 8001f5e:	f000 02f8 	and.w	r2, r0, #248	; 0xf8
  
  /* Activate the device */
  tmp |= HTS221_PD_MASK;
  
  /* Apply settings to CTRL_REG1 */
  SENSOR_IO_Write(DeviceAddr, HTS221_CTRL_REG1, tmp);
 8001f62:	f042 0285 	orr.w	r2, r2, #133	; 0x85
 8001f66:	2120      	movs	r1, #32
 8001f68:	4620      	mov	r0, r4
 8001f6a:	f7ff ff4d 	bl	8001e08 <SENSOR_IO_Write>
}
 8001f6e:	bd10      	pop	{r4, pc}

08001f70 <HTS221_H_ReadID>:
{  
 8001f70:	b510      	push	{r4, lr}
 8001f72:	4604      	mov	r4, r0
  SENSOR_IO_Init(); 
 8001f74:	f7ff ff46 	bl	8001e04 <SENSOR_IO_Init>
  ctrl = SENSOR_IO_Read(DeviceAddr, HTS221_WHO_AM_I_REG);
 8001f78:	210f      	movs	r1, #15
 8001f7a:	b2e0      	uxtb	r0, r4
 8001f7c:	f7ff ff58 	bl	8001e30 <SENSOR_IO_Read>
}
 8001f80:	bd10      	pop	{r4, pc}
	...

08001f84 <HTS221_H_ReadHumidity>:
{
 8001f84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001f88:	b083      	sub	sp, #12
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_H0_RH_X2 | 0x80), buffer, 2);
 8001f8a:	fa5f f980 	uxtb.w	r9, r0
 8001f8e:	2302      	movs	r3, #2
 8001f90:	aa01      	add	r2, sp, #4
 8001f92:	21b0      	movs	r1, #176	; 0xb0
 8001f94:	4648      	mov	r0, r9
 8001f96:	f7ff ff61 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H0_rh = buffer[0] >> 1;
 8001f9a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001f9e:	085f      	lsrs	r7, r3, #1
  H1_rh = buffer[1] >> 1;
 8001fa0:	f89d 6005 	ldrb.w	r6, [sp, #5]
 8001fa4:	0876      	lsrs	r6, r6, #1
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_H0_T0_OUT_L | 0x80), buffer, 2);
 8001fa6:	2302      	movs	r3, #2
 8001fa8:	aa01      	add	r2, sp, #4
 8001faa:	21b6      	movs	r1, #182	; 0xb6
 8001fac:	4648      	mov	r0, r9
 8001fae:	f7ff ff55 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8001fb2:	f89d 5005 	ldrb.w	r5, [sp, #5]
 8001fb6:	022d      	lsls	r5, r5, #8
 8001fb8:	b22d      	sxth	r5, r5
 8001fba:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001fbe:	431d      	orrs	r5, r3
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_H1_T0_OUT_L | 0x80), buffer, 2);
 8001fc0:	2302      	movs	r3, #2
 8001fc2:	aa01      	add	r2, sp, #4
 8001fc4:	21ba      	movs	r1, #186	; 0xba
 8001fc6:	4648      	mov	r0, r9
 8001fc8:	f7ff ff48 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8001fcc:	f89d 4005 	ldrb.w	r4, [sp, #5]
 8001fd0:	0224      	lsls	r4, r4, #8
 8001fd2:	b224      	sxth	r4, r4
 8001fd4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001fd8:	431c      	orrs	r4, r3
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_HR_OUT_L_REG | 0x80), buffer, 2);
 8001fda:	2302      	movs	r3, #2
 8001fdc:	aa01      	add	r2, sp, #4
 8001fde:	21a8      	movs	r1, #168	; 0xa8
 8001fe0:	4648      	mov	r0, r9
 8001fe2:	f7ff ff3b 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8001fe6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8001fea:	021b      	lsls	r3, r3, #8
 8001fec:	b21b      	sxth	r3, r3
 8001fee:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8001ff2:	4313      	orrs	r3, r2
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8001ff4:	1b5b      	subs	r3, r3, r5
 8001ff6:	ee07 3a90 	vmov	s15, r3
 8001ffa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001ffe:	1bf6      	subs	r6, r6, r7
 8002000:	ee07 6a10 	vmov	s14, r6
 8002004:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002008:	ee67 7a87 	vmul.f32	s15, s15, s14
 800200c:	1b64      	subs	r4, r4, r5
 800200e:	ee07 4a10 	vmov	s14, r4
 8002012:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002016:	ee87 0a87 	vdiv.f32	s0, s15, s14
 800201a:	ee07 7a90 	vmov	s15, r7
 800201e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002022:	ee70 7a27 	vadd.f32	s15, s0, s15
  tmp_f *= 10.0f;
 8002026:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800202a:	ee67 7a87 	vmul.f32	s15, s15, s14
        : ( tmp_f <    0.0f ) ?    0.0f
 800202e:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 8002060 <HTS221_H_ReadHumidity+0xdc>
 8002032:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002036:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800203a:	dc07      	bgt.n	800204c <HTS221_H_ReadHumidity+0xc8>
        : tmp_f;
 800203c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8002040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002044:	d504      	bpl.n	8002050 <HTS221_H_ReadHumidity+0xcc>
 8002046:	eddf 7a07 	vldr	s15, [pc, #28]	; 8002064 <HTS221_H_ReadHumidity+0xe0>
 800204a:	e001      	b.n	8002050 <HTS221_H_ReadHumidity+0xcc>
        : ( tmp_f <    0.0f ) ?    0.0f
 800204c:	eddf 7a04 	vldr	s15, [pc, #16]	; 8002060 <HTS221_H_ReadHumidity+0xdc>
}
 8002050:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8002054:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8002058:	b003      	add	sp, #12
 800205a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800205e:	bf00      	nop
 8002060:	447a0000 	.word	0x447a0000
 8002064:	00000000 	.word	0x00000000

08002068 <HTS221_T_ReadTemp>:
  * @brief  Read temperature value of HTS221
  * @param  DeviceAddr: I2C device address
  * @retval temperature value
  */
float HTS221_T_ReadTemp(uint16_t DeviceAddr)
{
 8002068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800206c:	b082      	sub	sp, #8
  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;
  int16_t T0_degC, T1_degC;
  uint8_t buffer[4], tmp;
  float tmp_f;

  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_T0_DEGC_X8 | 0x80), buffer, 2);
 800206e:	fa5f f880 	uxtb.w	r8, r0
 8002072:	2302      	movs	r3, #2
 8002074:	aa01      	add	r2, sp, #4
 8002076:	21b2      	movs	r1, #178	; 0xb2
 8002078:	4640      	mov	r0, r8
 800207a:	f7ff feef 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  tmp = SENSOR_IO_Read(DeviceAddr, HTS221_T0_T1_DEGC_H2);
 800207e:	2135      	movs	r1, #53	; 0x35
 8002080:	4640      	mov	r0, r8
 8002082:	f7ff fed5 	bl	8001e30 <SENSOR_IO_Read>

  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8002086:	0207      	lsls	r7, r0, #8
 8002088:	f407 7740 	and.w	r7, r7, #768	; 0x300
 800208c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8002090:	431f      	orrs	r7, r3
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8002092:	0184      	lsls	r4, r0, #6
 8002094:	f404 7440 	and.w	r4, r4, #768	; 0x300
 8002098:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800209c:	431c      	orrs	r4, r3
  T0_degC = T0_degC_x8_u16 >> 3;
 800209e:	08ff      	lsrs	r7, r7, #3
  T1_degC = T1_degC_x8_u16 >> 3;
 80020a0:	08e4      	lsrs	r4, r4, #3

  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_T0_OUT_L | 0x80), buffer, 4);
 80020a2:	2304      	movs	r3, #4
 80020a4:	eb0d 0203 	add.w	r2, sp, r3
 80020a8:	21bc      	movs	r1, #188	; 0xbc
 80020aa:	4640      	mov	r0, r8
 80020ac:	f7ff fed6 	bl	8001e5c <SENSOR_IO_ReadMultiple>

  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 80020b0:	f89d 6005 	ldrb.w	r6, [sp, #5]
 80020b4:	0236      	lsls	r6, r6, #8
 80020b6:	b236      	sxth	r6, r6
 80020b8:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80020bc:	431e      	orrs	r6, r3
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 80020be:	f89d 5007 	ldrb.w	r5, [sp, #7]
 80020c2:	022d      	lsls	r5, r5, #8
 80020c4:	b22d      	sxth	r5, r5
 80020c6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80020ca:	431d      	orrs	r5, r3

  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_TEMP_OUT_L_REG | 0x80), buffer, 2);
 80020cc:	2302      	movs	r3, #2
 80020ce:	aa01      	add	r2, sp, #4
 80020d0:	21aa      	movs	r1, #170	; 0xaa
 80020d2:	4640      	mov	r0, r8
 80020d4:	f7ff fec2 	bl	8001e5c <SENSOR_IO_ReadMultiple>

  T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 80020d8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80020dc:	021b      	lsls	r3, r3, #8
 80020de:	b21b      	sxth	r3, r3
 80020e0:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80020e4:	4313      	orrs	r3, r2

  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 80020e6:	1b9b      	subs	r3, r3, r6
 80020e8:	ee07 3a90 	vmov	s15, r3
 80020ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80020f0:	1be4      	subs	r4, r4, r7
 80020f2:	ee07 4a10 	vmov	s14, r4
 80020f6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80020fa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80020fe:	1bad      	subs	r5, r5, r6
 8002100:	ee07 5a10 	vmov	s14, r5
 8002104:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002108:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800210c:	ee07 7a90 	vmov	s15, r7
 8002110:	eeb8 0ae7 	vcvt.f32.s32	s0, s15

  return tmp_f;
}
 8002114:	ee36 0a80 	vadd.f32	s0, s13, s0
 8002118:	b002      	add	sp, #8
 800211a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08002120 <LPS22HB_P_ReadPressure>:
/**
  * @brief  Read pressure value of LPS22HB
  * @retval pressure value
  */
float LPS22HB_P_ReadPressure(uint16_t DeviceAddr)
{
 8002120:	b530      	push	{r4, r5, lr}
 8002122:	b083      	sub	sp, #12
 8002124:	4605      	mov	r5, r0
  int32_t raw_press;
  uint8_t buffer[3];
  uint32_t tmp = 0;
  uint8_t i;

  for(i = 0; i < 3; i++)
 8002126:	2400      	movs	r4, #0
 8002128:	e00c      	b.n	8002144 <LPS22HB_P_ReadPressure+0x24>
  {
    buffer[i] = SENSOR_IO_Read(DeviceAddr, (LPS22HB_PRESS_OUT_XL_REG + i));
 800212a:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800212e:	b2c9      	uxtb	r1, r1
 8002130:	b2e8      	uxtb	r0, r5
 8002132:	f7ff fe7d 	bl	8001e30 <SENSOR_IO_Read>
 8002136:	f104 0308 	add.w	r3, r4, #8
 800213a:	446b      	add	r3, sp
 800213c:	f803 0c04 	strb.w	r0, [r3, #-4]
  for(i = 0; i < 3; i++)
 8002140:	3401      	adds	r4, #1
 8002142:	b2e4      	uxtb	r4, r4
 8002144:	2c02      	cmp	r4, #2
 8002146:	d9f0      	bls.n	800212a <LPS22HB_P_ReadPressure+0xa>
  }

  /* Build the raw data */
  for(i = 0; i < 3; i++)
 8002148:	2300      	movs	r3, #0
  uint32_t tmp = 0;
 800214a:	461a      	mov	r2, r3
 800214c:	e009      	b.n	8002162 <LPS22HB_P_ReadPressure+0x42>
    tmp |= (((uint32_t)buffer[i]) << (8 * i));
 800214e:	f103 0108 	add.w	r1, r3, #8
 8002152:	4469      	add	r1, sp
 8002154:	f811 1c04 	ldrb.w	r1, [r1, #-4]
 8002158:	00d8      	lsls	r0, r3, #3
 800215a:	4081      	lsls	r1, r0
 800215c:	430a      	orrs	r2, r1
  for(i = 0; i < 3; i++)
 800215e:	3301      	adds	r3, #1
 8002160:	b2db      	uxtb	r3, r3
 8002162:	2b02      	cmp	r3, #2
 8002164:	d9f3      	bls.n	800214e <LPS22HB_P_ReadPressure+0x2e>

  /* convert the 2's complement 24 bit to 2's complement 32 bit */
  if(tmp & 0x00800000)
 8002166:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
 800216a:	d001      	beq.n	8002170 <LPS22HB_P_ReadPressure+0x50>
    tmp |= 0xFF000000;
 800216c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000

  raw_press = ((int32_t)tmp);

  raw_press = (raw_press * 100) / 4096;
 8002170:	2364      	movs	r3, #100	; 0x64
 8002172:	fb03 f202 	mul.w	r2, r3, r2
 8002176:	2a00      	cmp	r2, #0
 8002178:	db0a      	blt.n	8002190 <LPS22HB_P_ReadPressure+0x70>
 800217a:	1312      	asrs	r2, r2, #12

  return (float)((float)raw_press / 100.0f);
 800217c:	ee07 2a90 	vmov	s15, r2
 8002180:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
}
 8002184:	eddf 7a04 	vldr	s15, [pc, #16]	; 8002198 <LPS22HB_P_ReadPressure+0x78>
 8002188:	ee80 0a27 	vdiv.f32	s0, s0, s15
 800218c:	b003      	add	sp, #12
 800218e:	bd30      	pop	{r4, r5, pc}
  raw_press = (raw_press * 100) / 4096;
 8002190:	f602 72ff 	addw	r2, r2, #4095	; 0xfff
 8002194:	e7f1      	b.n	800217a <LPS22HB_P_ReadPressure+0x5a>
 8002196:	bf00      	nop
 8002198:	42c80000 	.word	0x42c80000

0800219c <LPS22HB_Init>:
  * @brief  Set LPS22HB Initialization.
  * @param  DeviceAddr: I2C device address
  * @retval None
  */
static void LPS22HB_Init(uint16_t DeviceAddr)
{
 800219c:	b510      	push	{r4, lr}
  uint8_t tmp;

  /* Set Power mode */
  tmp = SENSOR_IO_Read(DeviceAddr, LPS22HB_RES_CONF_REG);
 800219e:	b2c4      	uxtb	r4, r0
 80021a0:	211a      	movs	r1, #26
 80021a2:	4620      	mov	r0, r4
 80021a4:	f7ff fe44 	bl	8001e30 <SENSOR_IO_Read>

  tmp &= ~LPS22HB_LCEN_MASK;
 80021a8:	f000 02fe 	and.w	r2, r0, #254	; 0xfe
  tmp |= (uint8_t)0x01; /* Set low current mode */

  SENSOR_IO_Write(DeviceAddr, LPS22HB_RES_CONF_REG, tmp);
 80021ac:	f042 0201 	orr.w	r2, r2, #1
 80021b0:	211a      	movs	r1, #26
 80021b2:	4620      	mov	r0, r4
 80021b4:	f7ff fe28 	bl	8001e08 <SENSOR_IO_Write>

  /* Read CTRL_REG1 */
  tmp = SENSOR_IO_Read(DeviceAddr, LPS22HB_CTRL_REG1);
 80021b8:	2110      	movs	r1, #16
 80021ba:	4620      	mov	r0, r4
 80021bc:	f7ff fe38 	bl	8001e30 <SENSOR_IO_Read>
  /* Set default ODR */
  tmp &= ~LPS22HB_ODR_MASK;
  tmp |= (uint8_t)0x30; /* Set ODR to 25Hz */

  /* Enable BDU */
  tmp &= ~LPS22HB_BDU_MASK;
 80021c0:	f000 028d 	and.w	r2, r0, #141	; 0x8d
  tmp |= ((uint8_t)0x02);

  /* Apply settings to CTRL_REG1 */
  SENSOR_IO_Write(DeviceAddr, LPS22HB_CTRL_REG1, tmp);
 80021c4:	f042 0232 	orr.w	r2, r2, #50	; 0x32
 80021c8:	2110      	movs	r1, #16
 80021ca:	4620      	mov	r0, r4
 80021cc:	f7ff fe1c 	bl	8001e08 <SENSOR_IO_Write>
}  
 80021d0:	bd10      	pop	{r4, pc}

080021d2 <LPS22HB_P_Init>:
{
 80021d2:	b508      	push	{r3, lr}
  LPS22HB_Init(DeviceAddr);
 80021d4:	f7ff ffe2 	bl	800219c <LPS22HB_Init>
}
 80021d8:	bd08      	pop	{r3, pc}

080021da <LPS22HB_P_ReadID>:
{  
 80021da:	b510      	push	{r4, lr}
 80021dc:	4604      	mov	r4, r0
  SENSOR_IO_Init();  
 80021de:	f7ff fe11 	bl	8001e04 <SENSOR_IO_Init>
  ctrl = SENSOR_IO_Read(DeviceAddr, LPS22HB_WHO_AM_I_REG);
 80021e2:	210f      	movs	r1, #15
 80021e4:	b2e0      	uxtb	r0, r4
 80021e6:	f7ff fe23 	bl	8001e30 <SENSOR_IO_Read>
}
 80021ea:	bd10      	pop	{r4, pc}

080021ec <atcma_init_at_func_ptrs>:
/* Functions Definition ------------------------------------------------------*/
void atcma_init_at_func_ptrs(atcustom_funcPtrs_t *funcPtrs)
{
#if defined(USE_MODEM_TYPE1SC)
  /* init function pointers with TYPE1SC functions */
  funcPtrs->f_init = ATCustom_TYPE1SC_init;
 80021ec:	4b0b      	ldr	r3, [pc, #44]	; (800221c <atcma_init_at_func_ptrs+0x30>)
 80021ee:	6043      	str	r3, [r0, #4]
  funcPtrs->f_checkEndOfMsgCallback = ATCustom_TYPE1SC_checkEndOfMsgCallback;
 80021f0:	4b0b      	ldr	r3, [pc, #44]	; (8002220 <atcma_init_at_func_ptrs+0x34>)
 80021f2:	6083      	str	r3, [r0, #8]
  funcPtrs->f_getCmd = ATCustom_TYPE1SC_getCmd;
 80021f4:	4b0b      	ldr	r3, [pc, #44]	; (8002224 <atcma_init_at_func_ptrs+0x38>)
 80021f6:	60c3      	str	r3, [r0, #12]
  funcPtrs->f_extractElement = ATCustom_TYPE1SC_extractElement;
 80021f8:	4b0b      	ldr	r3, [pc, #44]	; (8002228 <atcma_init_at_func_ptrs+0x3c>)
 80021fa:	6103      	str	r3, [r0, #16]
  funcPtrs->f_analyzeCmd = ATCustom_TYPE1SC_analyzeCmd;
 80021fc:	4b0b      	ldr	r3, [pc, #44]	; (800222c <atcma_init_at_func_ptrs+0x40>)
 80021fe:	6143      	str	r3, [r0, #20]
  funcPtrs->f_analyzeParam = ATCustom_TYPE1SC_analyzeParam;
 8002200:	4b0b      	ldr	r3, [pc, #44]	; (8002230 <atcma_init_at_func_ptrs+0x44>)
 8002202:	6183      	str	r3, [r0, #24]
  funcPtrs->f_terminateCmd = ATCustom_TYPE1SC_terminateCmd;
 8002204:	4b0b      	ldr	r3, [pc, #44]	; (8002234 <atcma_init_at_func_ptrs+0x48>)
 8002206:	61c3      	str	r3, [r0, #28]
  funcPtrs->f_get_rsp = ATCustom_TYPE1SC_get_rsp;
 8002208:	4b0b      	ldr	r3, [pc, #44]	; (8002238 <atcma_init_at_func_ptrs+0x4c>)
 800220a:	6203      	str	r3, [r0, #32]
  funcPtrs->f_get_urc = ATCustom_TYPE1SC_get_urc;
 800220c:	4b0b      	ldr	r3, [pc, #44]	; (800223c <atcma_init_at_func_ptrs+0x50>)
 800220e:	6243      	str	r3, [r0, #36]	; 0x24
  funcPtrs->f_get_error = ATCustom_TYPE1SC_get_error;
 8002210:	4b0b      	ldr	r3, [pc, #44]	; (8002240 <atcma_init_at_func_ptrs+0x54>)
 8002212:	6283      	str	r3, [r0, #40]	; 0x28
  funcPtrs->f_hw_event = ATCustom_TYPE1SC_hw_event;
 8002214:	4b0b      	ldr	r3, [pc, #44]	; (8002244 <atcma_init_at_func_ptrs+0x58>)
 8002216:	62c3      	str	r3, [r0, #44]	; 0x2c
#else
#error AT custom does not match with selected modem
#endif /* USE_MODEM_TYPE1SC */
}
 8002218:	4770      	bx	lr
 800221a:	bf00      	nop
 800221c:	080046ad 	.word	0x080046ad
 8002220:	080046d9 	.word	0x080046d9
 8002224:	08004739 	.word	0x08004739
 8002228:	08005759 	.word	0x08005759
 800222c:	080058c5 	.word	0x080058c5
 8002230:	08005d31 	.word	0x08005d31
 8002234:	08005dad 	.word	0x08005dad
 8002238:	08005ed1 	.word	0x08005ed1
 800223c:	08005ff9 	.word	0x08005ff9
 8002240:	0800606d 	.word	0x0800606d
 8002244:	080060d5 	.word	0x080060d5

08002248 <atcma_init_sysctrl_func_ptrs>:

void atcma_init_sysctrl_func_ptrs(sysctrl_funcPtrs_t *funcPtrs)
{
#if defined(USE_MODEM_TYPE1SC)
  /* init function pointers with TYPE1SC functions */
  funcPtrs->f_getDeviceDescriptor = SysCtrl_TYPE1SC_getDeviceDescriptor;
 8002248:	4b07      	ldr	r3, [pc, #28]	; (8002268 <atcma_init_sysctrl_func_ptrs+0x20>)
 800224a:	6043      	str	r3, [r0, #4]
  funcPtrs->f_open_channel =  SysCtrl_TYPE1SC_open_channel;
 800224c:	4b07      	ldr	r3, [pc, #28]	; (800226c <atcma_init_sysctrl_func_ptrs+0x24>)
 800224e:	6083      	str	r3, [r0, #8]
  funcPtrs->f_close_channel =  SysCtrl_TYPE1SC_close_channel;
 8002250:	4b07      	ldr	r3, [pc, #28]	; (8002270 <atcma_init_sysctrl_func_ptrs+0x28>)
 8002252:	60c3      	str	r3, [r0, #12]
  funcPtrs->f_power_on =  SysCtrl_TYPE1SC_power_on;
 8002254:	4b07      	ldr	r3, [pc, #28]	; (8002274 <atcma_init_sysctrl_func_ptrs+0x2c>)
 8002256:	6103      	str	r3, [r0, #16]
  funcPtrs->f_power_off = SysCtrl_TYPE1SC_power_off;
 8002258:	4b07      	ldr	r3, [pc, #28]	; (8002278 <atcma_init_sysctrl_func_ptrs+0x30>)
 800225a:	6143      	str	r3, [r0, #20]
  funcPtrs->f_reset_device = SysCtrl_TYPE1SC_reset;
 800225c:	4b07      	ldr	r3, [pc, #28]	; (800227c <atcma_init_sysctrl_func_ptrs+0x34>)
 800225e:	6183      	str	r3, [r0, #24]
  funcPtrs->f_sim_select = SysCtrl_TYPE1SC_sim_select;
 8002260:	4b07      	ldr	r3, [pc, #28]	; (8002280 <atcma_init_sysctrl_func_ptrs+0x38>)
 8002262:	61c3      	str	r3, [r0, #28]
#else
#error SysCtrl does not match with selected modem
#endif /* USE_MODEM_TYPE1SC */
}
 8002264:	4770      	bx	lr
 8002266:	bf00      	nop
 8002268:	080063b1 	.word	0x080063b1
 800226c:	08006b81 	.word	0x08006b81
 8002270:	080063e1 	.word	0x080063e1
 8002274:	0800652d 	.word	0x0800652d
 8002278:	08006609 	.word	0x08006609
 800227c:	080066dd 	.word	0x080066dd
 8002280:	08006761 	.word	0x08006761

08002284 <fCmdBuild_ATD_TYPE1SC>:
/* Private function prototypes -----------------------------------------------*/

/* Functions Definition ------------------------------------------------------*/
/* Build command functions ---------------------------------------------------*/
at_status_t fCmdBuild_ATD_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 8002284:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002288:	4606      	mov	r6, r0
 800228a:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATD_TYPE1SC()")
 800228c:	4c2a      	ldr	r4, [pc, #168]	; (8002338 <fCmdBuild_ATD_TYPE1SC+0xb4>)
 800228e:	4d2b      	ldr	r5, [pc, #172]	; (800233c <fCmdBuild_ATD_TYPE1SC+0xb8>)
 8002290:	f104 0e20 	add.w	lr, r4, #32
 8002294:	46a4      	mov	ip, r4
 8002296:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800229a:	6028      	str	r0, [r5, #0]
 800229c:	6069      	str	r1, [r5, #4]
 800229e:	60aa      	str	r2, [r5, #8]
 80022a0:	60eb      	str	r3, [r5, #12]
 80022a2:	4664      	mov	r4, ip
 80022a4:	3510      	adds	r5, #16
 80022a6:	45f4      	cmp	ip, lr
 80022a8:	d1f4      	bne.n	8002294 <fCmdBuild_ATD_TYPE1SC+0x10>
 80022aa:	cc07      	ldmia	r4!, {r0, r1, r2}
 80022ac:	6028      	str	r0, [r5, #0]
 80022ae:	6069      	str	r1, [r5, #4]
 80022b0:	60aa      	str	r2, [r5, #8]
 80022b2:	4c22      	ldr	r4, [pc, #136]	; (800233c <fCmdBuild_ATD_TYPE1SC+0xb8>)
 80022b4:	4620      	mov	r0, r4
 80022b6:	f01c ff2c 	bl	801f112 <crs_strlen>
 80022ba:	b283      	uxth	r3, r0
 80022bc:	4622      	mov	r2, r4
 80022be:	2104      	movs	r1, #4
 80022c0:	2002      	movs	r0, #2
 80022c2:	f01c ff69 	bl	801f198 <traceIF_itmPrint>
 80022c6:	4620      	mov	r0, r4
 80022c8:	f01c ff23 	bl	801f112 <crs_strlen>
 80022cc:	b283      	uxth	r3, r0
 80022ce:	4622      	mov	r2, r4
 80022d0:	2104      	movs	r1, #4
 80022d2:	2002      	movs	r0, #2
 80022d4:	f01c ff82 	bl	801f1dc <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 80022d8:	8933      	ldrh	r3, [r6, #8]
 80022da:	2b04      	cmp	r3, #4
 80022dc:	d002      	beq.n	80022e4 <fCmdBuild_ATD_TYPE1SC+0x60>
    PRINT_INFO("Activate PDN (user cid = %d, modem cid = %d)", (uint8_t)current_conf_id, modem_cid)

    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "*99***%d#", modem_cid);
  }
  return (retval);
}
 80022de:	2000      	movs	r0, #0
 80022e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 80022e4:	4638      	mov	r0, r7
 80022e6:	f00a fae5 	bl	800c8b4 <atcm_get_cid_current_SID>
 80022ea:	4680      	mov	r8, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 80022ec:	4601      	mov	r1, r0
 80022ee:	f107 000c 	add.w	r0, r7, #12
 80022f2:	f00b fb67 	bl	800d9c4 <atcm_get_affected_modem_cid>
 80022f6:	4605      	mov	r5, r0
    PRINT_INFO("Activate PDN (user cid = %d, modem cid = %d)", (uint8_t)current_conf_id, modem_cid)
 80022f8:	4603      	mov	r3, r0
 80022fa:	4642      	mov	r2, r8
 80022fc:	4910      	ldr	r1, [pc, #64]	; (8002340 <fCmdBuild_ATD_TYPE1SC+0xbc>)
 80022fe:	4620      	mov	r0, r4
 8002300:	f023 fcb6 	bl	8025c70 <sprintf>
 8002304:	4620      	mov	r0, r4
 8002306:	f01c ff04 	bl	801f112 <crs_strlen>
 800230a:	b283      	uxth	r3, r0
 800230c:	4622      	mov	r2, r4
 800230e:	2101      	movs	r1, #1
 8002310:	2002      	movs	r0, #2
 8002312:	f01c ff41 	bl	801f198 <traceIF_itmPrint>
 8002316:	4620      	mov	r0, r4
 8002318:	f01c fefb 	bl	801f112 <crs_strlen>
 800231c:	b283      	uxth	r3, r0
 800231e:	4622      	mov	r2, r4
 8002320:	2101      	movs	r1, #1
 8002322:	2002      	movs	r0, #2
 8002324:	f01c ff5a 	bl	801f1dc <traceIF_uartPrint>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "*99***%d#", modem_cid);
 8002328:	462a      	mov	r2, r5
 800232a:	4906      	ldr	r1, [pc, #24]	; (8002344 <fCmdBuild_ATD_TYPE1SC+0xc0>)
 800232c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8002330:	f023 fc9e 	bl	8025c70 <sprintf>
 8002334:	e7d3      	b.n	80022de <fCmdBuild_ATD_TYPE1SC+0x5a>
 8002336:	bf00      	nop
 8002338:	0802a6cc 	.word	0x0802a6cc
 800233c:	200048dc 	.word	0x200048dc
 8002340:	0802a6f8 	.word	0x0802a6f8
 8002344:	0802a730 	.word	0x0802a730

08002348 <fCmdBuild_SETCFG_TYPE1SC>:

at_status_t fCmdBuild_SETCFG_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 8002348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800234a:	4606      	mov	r6, r0
 800234c:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_SETCFG_TYPE1SC()")
 800234e:	4c68      	ldr	r4, [pc, #416]	; (80024f0 <fCmdBuild_SETCFG_TYPE1SC+0x1a8>)
 8002350:	4d68      	ldr	r5, [pc, #416]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002352:	f104 0e20 	add.w	lr, r4, #32
 8002356:	46a4      	mov	ip, r4
 8002358:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800235c:	6028      	str	r0, [r5, #0]
 800235e:	6069      	str	r1, [r5, #4]
 8002360:	60aa      	str	r2, [r5, #8]
 8002362:	60eb      	str	r3, [r5, #12]
 8002364:	4664      	mov	r4, ip
 8002366:	3510      	adds	r5, #16
 8002368:	45f4      	cmp	ip, lr
 800236a:	d1f4      	bne.n	8002356 <fCmdBuild_SETCFG_TYPE1SC+0xe>
 800236c:	4663      	mov	r3, ip
 800236e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8002370:	6028      	str	r0, [r5, #0]
 8002372:	6069      	str	r1, [r5, #4]
 8002374:	60aa      	str	r2, [r5, #8]
 8002376:	881a      	ldrh	r2, [r3, #0]
 8002378:	789b      	ldrb	r3, [r3, #2]
 800237a:	81aa      	strh	r2, [r5, #12]
 800237c:	73ab      	strb	r3, [r5, #14]
 800237e:	4c5d      	ldr	r4, [pc, #372]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002380:	4620      	mov	r0, r4
 8002382:	f01c fec6 	bl	801f112 <crs_strlen>
 8002386:	b283      	uxth	r3, r0
 8002388:	4622      	mov	r2, r4
 800238a:	2104      	movs	r1, #4
 800238c:	2002      	movs	r0, #2
 800238e:	f01c ff03 	bl	801f198 <traceIF_itmPrint>
 8002392:	4620      	mov	r0, r4
 8002394:	f01c febd 	bl	801f112 <crs_strlen>
 8002398:	b283      	uxth	r3, r0
 800239a:	4622      	mov	r2, r4
 800239c:	2104      	movs	r1, #4
 800239e:	2002      	movs	r0, #2
 80023a0:	f01c ff1c 	bl	801f1dc <traceIF_uartPrint>

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80023a4:	8933      	ldrh	r3, [r6, #8]
 80023a6:	2b03      	cmp	r3, #3
 80023a8:	d002      	beq.n	80023b0 <fCmdBuild_SETCFG_TYPE1SC+0x68>
  at_status_t retval = ATSTATUS_OK;
 80023aa:	2400      	movs	r4, #0
      retval = ATSTATUS_ERROR;
    }
  }

  return (retval);
}
 80023ac:	4620      	mov	r0, r4
 80023ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (type1sc_shared.setcfg_function == SETGETCFG_SIM_POLICY)
 80023b0:	4b51      	ldr	r3, [pc, #324]	; (80024f8 <fCmdBuild_SETCFG_TYPE1SC+0x1b0>)
 80023b2:	f893 4042 	ldrb.w	r4, [r3, #66]	; 0x42
 80023b6:	2c01      	cmp	r4, #1
 80023b8:	d031      	beq.n	800241e <fCmdBuild_SETCFG_TYPE1SC+0xd6>
    else if (type1sc_shared.setcfg_function == SETGETCFG_HIFC_MODE)
 80023ba:	2c04      	cmp	r4, #4
 80023bc:	d066      	beq.n	800248c <fCmdBuild_SETCFG_TYPE1SC+0x144>
    else if (type1sc_shared.setcfg_function == SETGETCFG_BOOT_EVENT_TRUE)
 80023be:	2c07      	cmp	r4, #7
 80023c0:	d06f      	beq.n	80024a2 <fCmdBuild_SETCFG_TYPE1SC+0x15a>
    else if (type1sc_shared.setcfg_function == SETGETCFG_BOOT_EVENT_FALSE)
 80023c2:	2c08      	cmp	r4, #8
 80023c4:	f000 8081 	beq.w	80024ca <fCmdBuild_SETCFG_TYPE1SC+0x182>
      PRINT_ERR("setcfg value not implemented !")
 80023c8:	4d4c      	ldr	r5, [pc, #304]	; (80024fc <fCmdBuild_SETCFG_TYPE1SC+0x1b4>)
 80023ca:	4c4a      	ldr	r4, [pc, #296]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 80023cc:	f105 0720 	add.w	r7, r5, #32
 80023d0:	462e      	mov	r6, r5
 80023d2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80023d4:	6020      	str	r0, [r4, #0]
 80023d6:	6061      	str	r1, [r4, #4]
 80023d8:	60a2      	str	r2, [r4, #8]
 80023da:	60e3      	str	r3, [r4, #12]
 80023dc:	4635      	mov	r5, r6
 80023de:	3410      	adds	r4, #16
 80023e0:	42be      	cmp	r6, r7
 80023e2:	d1f5      	bne.n	80023d0 <fCmdBuild_SETCFG_TYPE1SC+0x88>
 80023e4:	cd07      	ldmia	r5!, {r0, r1, r2}
 80023e6:	6020      	str	r0, [r4, #0]
 80023e8:	6061      	str	r1, [r4, #4]
 80023ea:	60a2      	str	r2, [r4, #8]
 80023ec:	882a      	ldrh	r2, [r5, #0]
 80023ee:	78ab      	ldrb	r3, [r5, #2]
 80023f0:	81a2      	strh	r2, [r4, #12]
 80023f2:	73a3      	strb	r3, [r4, #14]
 80023f4:	4c3f      	ldr	r4, [pc, #252]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 80023f6:	4620      	mov	r0, r4
 80023f8:	f01c fe8b 	bl	801f112 <crs_strlen>
 80023fc:	b283      	uxth	r3, r0
 80023fe:	4622      	mov	r2, r4
 8002400:	2110      	movs	r1, #16
 8002402:	2002      	movs	r0, #2
 8002404:	f01c fec8 	bl	801f198 <traceIF_itmPrint>
 8002408:	4620      	mov	r0, r4
 800240a:	f01c fe82 	bl	801f112 <crs_strlen>
 800240e:	b283      	uxth	r3, r0
 8002410:	4622      	mov	r2, r4
 8002412:	2110      	movs	r1, #16
 8002414:	2002      	movs	r0, #2
 8002416:	f01c fee1 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800241a:	2401      	movs	r4, #1
 800241c:	e7c6      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      switch (p_modem_ctxt->persist.sim_selected)
 800241e:	f897 3512 	ldrb.w	r3, [r7, #1298]	; 0x512
 8002422:	2b01      	cmp	r3, #1
 8002424:	d030      	beq.n	8002488 <fCmdBuild_SETCFG_TYPE1SC+0x140>
 8002426:	2b02      	cmp	r3, #2
 8002428:	d00a      	beq.n	8002440 <fCmdBuild_SETCFG_TYPE1SC+0xf8>
 800242a:	b103      	cbz	r3, 800242e <fCmdBuild_SETCFG_TYPE1SC+0xe6>
          asim_selected = 0;
 800242c:	2400      	movs	r4, #0
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",\"%d\"",
 800242e:	4623      	mov	r3, r4
 8002430:	4a33      	ldr	r2, [pc, #204]	; (8002500 <fCmdBuild_SETCFG_TYPE1SC+0x1b8>)
 8002432:	4934      	ldr	r1, [pc, #208]	; (8002504 <fCmdBuild_SETCFG_TYPE1SC+0x1bc>)
 8002434:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8002438:	f023 fc1a 	bl	8025c70 <sprintf>
 800243c:	2400      	movs	r4, #0
 800243e:	e7b5      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
          PRINT_ERR("not supported yet");
 8002440:	4f31      	ldr	r7, [pc, #196]	; (8002508 <fCmdBuild_SETCFG_TYPE1SC+0x1c0>)
 8002442:	4e2c      	ldr	r6, [pc, #176]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002444:	f107 0c20 	add.w	ip, r7, #32
 8002448:	463d      	mov	r5, r7
 800244a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800244c:	6030      	str	r0, [r6, #0]
 800244e:	6071      	str	r1, [r6, #4]
 8002450:	60b2      	str	r2, [r6, #8]
 8002452:	60f3      	str	r3, [r6, #12]
 8002454:	462f      	mov	r7, r5
 8002456:	3610      	adds	r6, #16
 8002458:	4565      	cmp	r5, ip
 800245a:	d1f5      	bne.n	8002448 <fCmdBuild_SETCFG_TYPE1SC+0x100>
 800245c:	882b      	ldrh	r3, [r5, #0]
 800245e:	8033      	strh	r3, [r6, #0]
 8002460:	4d24      	ldr	r5, [pc, #144]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002462:	4628      	mov	r0, r5
 8002464:	f01c fe55 	bl	801f112 <crs_strlen>
 8002468:	b283      	uxth	r3, r0
 800246a:	462a      	mov	r2, r5
 800246c:	2110      	movs	r1, #16
 800246e:	2002      	movs	r0, #2
 8002470:	f01c fe92 	bl	801f198 <traceIF_itmPrint>
 8002474:	4628      	mov	r0, r5
 8002476:	f01c fe4c 	bl	801f112 <crs_strlen>
 800247a:	b283      	uxth	r3, r0
 800247c:	462a      	mov	r2, r5
 800247e:	2110      	movs	r1, #16
 8002480:	2002      	movs	r0, #2
 8002482:	f01c feab 	bl	801f1dc <traceIF_uartPrint>
      if (retval != ATSTATUS_ERROR)
 8002486:	e791      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      switch (p_modem_ctxt->persist.sim_selected)
 8002488:	2402      	movs	r4, #2
 800248a:	e7d0      	b.n	800242e <fCmdBuild_SETCFG_TYPE1SC+0xe6>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.hifc.mode,A\"");
 800248c:	4c1f      	ldr	r4, [pc, #124]	; (800250c <fCmdBuild_SETCFG_TYPE1SC+0x1c4>)
 800248e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002490:	6330      	str	r0, [r6, #48]	; 0x30
 8002492:	6371      	str	r1, [r6, #52]	; 0x34
 8002494:	63b2      	str	r2, [r6, #56]	; 0x38
 8002496:	63f3      	str	r3, [r6, #60]	; 0x3c
 8002498:	7823      	ldrb	r3, [r4, #0]
 800249a:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
  at_status_t retval = ATSTATUS_OK;
 800249e:	2400      	movs	r4, #0
 80024a0:	e784      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"manager.urcBootEv.enabled\",\"true\"");
 80024a2:	4d1b      	ldr	r5, [pc, #108]	; (8002510 <fCmdBuild_SETCFG_TYPE1SC+0x1c8>)
 80024a4:	3630      	adds	r6, #48	; 0x30
 80024a6:	f105 0720 	add.w	r7, r5, #32
 80024aa:	462c      	mov	r4, r5
 80024ac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80024ae:	6030      	str	r0, [r6, #0]
 80024b0:	6071      	str	r1, [r6, #4]
 80024b2:	60b2      	str	r2, [r6, #8]
 80024b4:	60f3      	str	r3, [r6, #12]
 80024b6:	4625      	mov	r5, r4
 80024b8:	3610      	adds	r6, #16
 80024ba:	42bc      	cmp	r4, r7
 80024bc:	d1f5      	bne.n	80024aa <fCmdBuild_SETCFG_TYPE1SC+0x162>
 80024be:	8822      	ldrh	r2, [r4, #0]
 80024c0:	78a3      	ldrb	r3, [r4, #2]
 80024c2:	8032      	strh	r2, [r6, #0]
 80024c4:	70b3      	strb	r3, [r6, #2]
  at_status_t retval = ATSTATUS_OK;
 80024c6:	2400      	movs	r4, #0
 80024c8:	e770      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"manager.urcBootEv.enabled\",\"false\"");
 80024ca:	4d12      	ldr	r5, [pc, #72]	; (8002514 <fCmdBuild_SETCFG_TYPE1SC+0x1cc>)
 80024cc:	3630      	adds	r6, #48	; 0x30
 80024ce:	f105 0720 	add.w	r7, r5, #32
 80024d2:	462c      	mov	r4, r5
 80024d4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80024d6:	6030      	str	r0, [r6, #0]
 80024d8:	6071      	str	r1, [r6, #4]
 80024da:	60b2      	str	r2, [r6, #8]
 80024dc:	60f3      	str	r3, [r6, #12]
 80024de:	4625      	mov	r5, r4
 80024e0:	3610      	adds	r6, #16
 80024e2:	42bc      	cmp	r4, r7
 80024e4:	d1f5      	bne.n	80024d2 <fCmdBuild_SETCFG_TYPE1SC+0x18a>
 80024e6:	6820      	ldr	r0, [r4, #0]
 80024e8:	6030      	str	r0, [r6, #0]
  at_status_t retval = ATSTATUS_OK;
 80024ea:	2400      	movs	r4, #0
 80024ec:	e75e      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
 80024ee:	bf00      	nop
 80024f0:	0802a73c 	.word	0x0802a73c
 80024f4:	200048dc 	.word	0x200048dc
 80024f8:	20001838 	.word	0x20001838
 80024fc:	0802a7fc 	.word	0x0802a7fc
 8002500:	0802a790 	.word	0x0802a790
 8002504:	0802a7a8 	.word	0x0802a7a8
 8002508:	0802a76c 	.word	0x0802a76c
 800250c:	08032c74 	.word	0x08032c74
 8002510:	0802a7b4 	.word	0x0802a7b4
 8002514:	0802a7d8 	.word	0x0802a7d8

08002518 <fCmdBuild_GETCFG_TYPE1SC>:

at_status_t fCmdBuild_GETCFG_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 8002518:	b570      	push	{r4, r5, r6, lr}
 800251a:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_GETCFG_TYPE1SC()")
 800251c:	4c42      	ldr	r4, [pc, #264]	; (8002628 <fCmdBuild_GETCFG_TYPE1SC+0x110>)
 800251e:	4d43      	ldr	r5, [pc, #268]	; (800262c <fCmdBuild_GETCFG_TYPE1SC+0x114>)
 8002520:	f104 0e20 	add.w	lr, r4, #32
 8002524:	46a4      	mov	ip, r4
 8002526:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800252a:	6028      	str	r0, [r5, #0]
 800252c:	6069      	str	r1, [r5, #4]
 800252e:	60aa      	str	r2, [r5, #8]
 8002530:	60eb      	str	r3, [r5, #12]
 8002532:	4664      	mov	r4, ip
 8002534:	3510      	adds	r5, #16
 8002536:	45f4      	cmp	ip, lr
 8002538:	d1f4      	bne.n	8002524 <fCmdBuild_GETCFG_TYPE1SC+0xc>
 800253a:	4663      	mov	r3, ip
 800253c:	cb07      	ldmia	r3!, {r0, r1, r2}
 800253e:	6028      	str	r0, [r5, #0]
 8002540:	6069      	str	r1, [r5, #4]
 8002542:	60aa      	str	r2, [r5, #8]
 8002544:	881a      	ldrh	r2, [r3, #0]
 8002546:	789b      	ldrb	r3, [r3, #2]
 8002548:	81aa      	strh	r2, [r5, #12]
 800254a:	73ab      	strb	r3, [r5, #14]
 800254c:	4c37      	ldr	r4, [pc, #220]	; (800262c <fCmdBuild_GETCFG_TYPE1SC+0x114>)
 800254e:	4620      	mov	r0, r4
 8002550:	f01c fddf 	bl	801f112 <crs_strlen>
 8002554:	b283      	uxth	r3, r0
 8002556:	4622      	mov	r2, r4
 8002558:	2104      	movs	r1, #4
 800255a:	2002      	movs	r0, #2
 800255c:	f01c fe1c 	bl	801f198 <traceIF_itmPrint>
 8002560:	4620      	mov	r0, r4
 8002562:	f01c fdd6 	bl	801f112 <crs_strlen>
 8002566:	b283      	uxth	r3, r0
 8002568:	4622      	mov	r2, r4
 800256a:	2104      	movs	r1, #4
 800256c:	2002      	movs	r0, #2
 800256e:	f01c fe35 	bl	801f1dc <traceIF_uartPrint>

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002572:	8933      	ldrh	r3, [r6, #8]
 8002574:	2b03      	cmp	r3, #3
 8002576:	d001      	beq.n	800257c <fCmdBuild_GETCFG_TYPE1SC+0x64>
  at_status_t retval = ATSTATUS_OK;
 8002578:	2000      	movs	r0, #0
        break;
    }
  }

  return (retval);
}
 800257a:	bd70      	pop	{r4, r5, r6, pc}
    switch (type1sc_shared.getcfg_function)
 800257c:	4b2c      	ldr	r3, [pc, #176]	; (8002630 <fCmdBuild_GETCFG_TYPE1SC+0x118>)
 800257e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002582:	3b02      	subs	r3, #2
 8002584:	2b07      	cmp	r3, #7
 8002586:	d84d      	bhi.n	8002624 <fCmdBuild_GETCFG_TYPE1SC+0x10c>
 8002588:	e8df f003 	tbb	[pc, r3]
 800258c:	24180e04 	.word	0x24180e04
 8002590:	404c4c31 	.word	0x404c4c31
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"BAND\"");
 8002594:	4b27      	ldr	r3, [pc, #156]	; (8002634 <fCmdBuild_GETCFG_TYPE1SC+0x11c>)
 8002596:	6818      	ldr	r0, [r3, #0]
 8002598:	6330      	str	r0, [r6, #48]	; 0x30
 800259a:	889a      	ldrh	r2, [r3, #4]
 800259c:	799b      	ldrb	r3, [r3, #6]
 800259e:	86b2      	strh	r2, [r6, #52]	; 0x34
 80025a0:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
  at_status_t retval = ATSTATUS_OK;
 80025a4:	2000      	movs	r0, #0
        break;
 80025a6:	e7e8      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"OPER\"");
 80025a8:	4b23      	ldr	r3, [pc, #140]	; (8002638 <fCmdBuild_GETCFG_TYPE1SC+0x120>)
 80025aa:	6818      	ldr	r0, [r3, #0]
 80025ac:	6330      	str	r0, [r6, #48]	; 0x30
 80025ae:	889a      	ldrh	r2, [r3, #4]
 80025b0:	799b      	ldrb	r3, [r3, #6]
 80025b2:	86b2      	strh	r2, [r6, #52]	; 0x34
 80025b4:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
  at_status_t retval = ATSTATUS_OK;
 80025b8:	2000      	movs	r0, #0
        break;
 80025ba:	e7de      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.hifc.mode\"");
 80025bc:	4b1f      	ldr	r3, [pc, #124]	; (800263c <fCmdBuild_GETCFG_TYPE1SC+0x124>)
 80025be:	cb07      	ldmia	r3!, {r0, r1, r2}
 80025c0:	6330      	str	r0, [r6, #48]	; 0x30
 80025c2:	6371      	str	r1, [r6, #52]	; 0x34
 80025c4:	63b2      	str	r2, [r6, #56]	; 0x38
 80025c6:	881a      	ldrh	r2, [r3, #0]
 80025c8:	789b      	ldrb	r3, [r3, #2]
 80025ca:	87b2      	strh	r2, [r6, #60]	; 0x3c
 80025cc:	f886 303e 	strb.w	r3, [r6, #62]	; 0x3e
  at_status_t retval = ATSTATUS_OK;
 80025d0:	2000      	movs	r0, #0
        break;
 80025d2:	e7d2      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.conf.sleep_mode\"");
 80025d4:	4c1a      	ldr	r4, [pc, #104]	; (8002640 <fCmdBuild_GETCFG_TYPE1SC+0x128>)
 80025d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80025d8:	6330      	str	r0, [r6, #48]	; 0x30
 80025da:	6371      	str	r1, [r6, #52]	; 0x34
 80025dc:	63b2      	str	r2, [r6, #56]	; 0x38
 80025de:	63f3      	str	r3, [r6, #60]	; 0x3c
 80025e0:	6820      	ldr	r0, [r4, #0]
 80025e2:	6430      	str	r0, [r6, #64]	; 0x40
 80025e4:	7923      	ldrb	r3, [r4, #4]
 80025e6:	f886 3044 	strb.w	r3, [r6, #68]	; 0x44
  at_status_t retval = ATSTATUS_OK;
 80025ea:	2000      	movs	r0, #0
        break;
 80025ec:	e7c5      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.conf.max_allowed_pm_mode\"");
 80025ee:	4c15      	ldr	r4, [pc, #84]	; (8002644 <fCmdBuild_GETCFG_TYPE1SC+0x12c>)
 80025f0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80025f2:	6330      	str	r0, [r6, #48]	; 0x30
 80025f4:	6371      	str	r1, [r6, #52]	; 0x34
 80025f6:	63b2      	str	r2, [r6, #56]	; 0x38
 80025f8:	63f3      	str	r3, [r6, #60]	; 0x3c
 80025fa:	cc07      	ldmia	r4!, {r0, r1, r2}
 80025fc:	6430      	str	r0, [r6, #64]	; 0x40
 80025fe:	6471      	str	r1, [r6, #68]	; 0x44
 8002600:	64b2      	str	r2, [r6, #72]	; 0x48
 8002602:	8823      	ldrh	r3, [r4, #0]
 8002604:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
  at_status_t retval = ATSTATUS_OK;
 8002608:	2000      	movs	r0, #0
        break;
 800260a:	e7b6      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"manager.uartB.flowcontrol\"");
 800260c:	4c0e      	ldr	r4, [pc, #56]	; (8002648 <fCmdBuild_GETCFG_TYPE1SC+0x130>)
 800260e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002610:	6330      	str	r0, [r6, #48]	; 0x30
 8002612:	6371      	str	r1, [r6, #52]	; 0x34
 8002614:	63b2      	str	r2, [r6, #56]	; 0x38
 8002616:	63f3      	str	r3, [r6, #60]	; 0x3c
 8002618:	cc07      	ldmia	r4!, {r0, r1, r2}
 800261a:	6430      	str	r0, [r6, #64]	; 0x40
 800261c:	6471      	str	r1, [r6, #68]	; 0x44
 800261e:	64b2      	str	r2, [r6, #72]	; 0x48
  at_status_t retval = ATSTATUS_OK;
 8002620:	2000      	movs	r0, #0
        break;
 8002622:	e7aa      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
    switch (type1sc_shared.getcfg_function)
 8002624:	2001      	movs	r0, #1
 8002626:	e7a8      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
 8002628:	0802a82c 	.word	0x0802a82c
 800262c:	200048dc 	.word	0x200048dc
 8002630:	20001838 	.word	0x20001838
 8002634:	0802a85c 	.word	0x0802a85c
 8002638:	0802a864 	.word	0x0802a864
 800263c:	0802a86c 	.word	0x0802a86c
 8002640:	0802a87c 	.word	0x0802a87c
 8002644:	0802a894 	.word	0x0802a894
 8002648:	0802a8b4 	.word	0x0802a8b4

0800264c <fCmdBuild_SETBDELAY_TYPE1SC>:

at_status_t fCmdBuild_SETBDELAY_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800264c:	b570      	push	{r4, r5, r6, lr}
 800264e:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_SETBDELAY_TYPE1SC()")
 8002650:	4d14      	ldr	r5, [pc, #80]	; (80026a4 <fCmdBuild_SETBDELAY_TYPE1SC+0x58>)
 8002652:	4c15      	ldr	r4, [pc, #84]	; (80026a8 <fCmdBuild_SETBDELAY_TYPE1SC+0x5c>)
 8002654:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002658:	46ac      	mov	ip, r5
 800265a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800265e:	6020      	str	r0, [r4, #0]
 8002660:	6061      	str	r1, [r4, #4]
 8002662:	60a2      	str	r2, [r4, #8]
 8002664:	60e3      	str	r3, [r4, #12]
 8002666:	4665      	mov	r5, ip
 8002668:	3410      	adds	r4, #16
 800266a:	45f4      	cmp	ip, lr
 800266c:	d1f4      	bne.n	8002658 <fCmdBuild_SETBDELAY_TYPE1SC+0xc>
 800266e:	f8bc 3000 	ldrh.w	r3, [ip]
 8002672:	8023      	strh	r3, [r4, #0]
 8002674:	4c0c      	ldr	r4, [pc, #48]	; (80026a8 <fCmdBuild_SETBDELAY_TYPE1SC+0x5c>)
 8002676:	4620      	mov	r0, r4
 8002678:	f01c fd4b 	bl	801f112 <crs_strlen>
 800267c:	b283      	uxth	r3, r0
 800267e:	4622      	mov	r2, r4
 8002680:	2104      	movs	r1, #4
 8002682:	2002      	movs	r0, #2
 8002684:	f01c fd88 	bl	801f198 <traceIF_itmPrint>
 8002688:	4620      	mov	r0, r4
 800268a:	f01c fd42 	bl	801f112 <crs_strlen>
 800268e:	b283      	uxth	r3, r0
 8002690:	4622      	mov	r2, r4
 8002692:	2104      	movs	r1, #4
 8002694:	2002      	movs	r0, #2
 8002696:	f01c fda1 	bl	801f1dc <traceIF_uartPrint>

  (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800269a:	4b04      	ldr	r3, [pc, #16]	; (80026ac <fCmdBuild_SETBDELAY_TYPE1SC+0x60>)
 800269c:	881b      	ldrh	r3, [r3, #0]
 800269e:	8633      	strh	r3, [r6, #48]	; 0x30

  return (retval);
}
 80026a0:	2000      	movs	r0, #0
 80026a2:	bd70      	pop	{r4, r5, r6, pc}
 80026a4:	0802a8d0 	.word	0x0802a8d0
 80026a8:	200048dc 	.word	0x200048dc
 80026ac:	080335d8 	.word	0x080335d8

080026b0 <fCmdBuild_PDNSET_TYPE1SC>:


at_status_t fCmdBuild_PDNSET_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 80026b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80026b4:	b085      	sub	sp, #20
 80026b6:	4607      	mov	r7, r0
 80026b8:	460e      	mov	r6, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_PDNSET_TYPE1SC()")
 80026ba:	4c5f      	ldr	r4, [pc, #380]	; (8002838 <fCmdBuild_PDNSET_TYPE1SC+0x188>)
 80026bc:	4d5f      	ldr	r5, [pc, #380]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 80026be:	f104 0e20 	add.w	lr, r4, #32
 80026c2:	46a4      	mov	ip, r4
 80026c4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80026c8:	6028      	str	r0, [r5, #0]
 80026ca:	6069      	str	r1, [r5, #4]
 80026cc:	60aa      	str	r2, [r5, #8]
 80026ce:	60eb      	str	r3, [r5, #12]
 80026d0:	4664      	mov	r4, ip
 80026d2:	3510      	adds	r5, #16
 80026d4:	45f4      	cmp	ip, lr
 80026d6:	d1f4      	bne.n	80026c2 <fCmdBuild_PDNSET_TYPE1SC+0x12>
 80026d8:	4663      	mov	r3, ip
 80026da:	cb07      	ldmia	r3!, {r0, r1, r2}
 80026dc:	6028      	str	r0, [r5, #0]
 80026de:	6069      	str	r1, [r5, #4]
 80026e0:	60aa      	str	r2, [r5, #8]
 80026e2:	881a      	ldrh	r2, [r3, #0]
 80026e4:	789b      	ldrb	r3, [r3, #2]
 80026e6:	81aa      	strh	r2, [r5, #12]
 80026e8:	73ab      	strb	r3, [r5, #14]
 80026ea:	4c54      	ldr	r4, [pc, #336]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 80026ec:	4620      	mov	r0, r4
 80026ee:	f01c fd10 	bl	801f112 <crs_strlen>
 80026f2:	b283      	uxth	r3, r0
 80026f4:	4622      	mov	r2, r4
 80026f6:	2104      	movs	r1, #4
 80026f8:	2002      	movs	r0, #2
 80026fa:	f01c fd4d 	bl	801f198 <traceIF_itmPrint>
 80026fe:	4620      	mov	r0, r4
 8002700:	f01c fd07 	bl	801f112 <crs_strlen>
 8002704:	b283      	uxth	r3, r0
 8002706:	4622      	mov	r2, r4
 8002708:	2104      	movs	r1, #4
 800270a:	2002      	movs	r0, #2
 800270c:	f01c fd66 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002710:	893b      	ldrh	r3, [r7, #8]
 8002712:	2b03      	cmp	r3, #3
 8002714:	d004      	beq.n	8002720 <fCmdBuild_PDNSET_TYPE1SC+0x70>
  at_status_t retval = ATSTATUS_OK;
 8002716:	2500      	movs	r5, #0
      PRINT_ERR("PDP context not defined for conf_id %d", current_conf_id)
      retval = ATSTATUS_ERROR;
    }
  }
  return (retval);
}
 8002718:	4628      	mov	r0, r5
 800271a:	b005      	add	sp, #20
 800271c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 8002720:	4630      	mov	r0, r6
 8002722:	f00a f8c7 	bl	800c8b4 <atcm_get_cid_current_SID>
 8002726:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 8002728:	4601      	mov	r1, r0
 800272a:	f106 000c 	add.w	r0, r6, #12
 800272e:	f00b f949 	bl	800d9c4 <atcm_get_affected_modem_cid>
 8002732:	4680      	mov	r8, r0
    PRINT_INFO("user cid = %d, modem cid = %d", (uint8_t)current_conf_id, modem_cid)
 8002734:	4d41      	ldr	r5, [pc, #260]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 8002736:	4603      	mov	r3, r0
 8002738:	4622      	mov	r2, r4
 800273a:	4941      	ldr	r1, [pc, #260]	; (8002840 <fCmdBuild_PDNSET_TYPE1SC+0x190>)
 800273c:	4628      	mov	r0, r5
 800273e:	f023 fa97 	bl	8025c70 <sprintf>
 8002742:	4628      	mov	r0, r5
 8002744:	f01c fce5 	bl	801f112 <crs_strlen>
 8002748:	b283      	uxth	r3, r0
 800274a:	462a      	mov	r2, r5
 800274c:	2101      	movs	r1, #1
 800274e:	2002      	movs	r0, #2
 8002750:	f01c fd22 	bl	801f198 <traceIF_itmPrint>
 8002754:	4628      	mov	r0, r5
 8002756:	f01c fcdc 	bl	801f112 <crs_strlen>
 800275a:	b283      	uxth	r3, r0
 800275c:	462a      	mov	r2, r5
 800275e:	2101      	movs	r1, #1
 8002760:	2002      	movs	r0, #2
 8002762:	f01c fd3b 	bl	801f1dc <traceIF_uartPrint>
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id != CS_PDN_NOT_DEFINED)
 8002766:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800276a:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800276e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8002772:	2b0c      	cmp	r3, #12
 8002774:	d045      	beq.n	8002802 <fCmdBuild_PDNSET_TYPE1SC+0x152>
      if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].pdn_conf.username[0] == 0U)
 8002776:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800277a:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800277e:	f893 5092 	ldrb.w	r5, [r3, #146]	; 0x92
 8002782:	b9ad      	cbnz	r5, 80027b0 <fCmdBuild_PDNSET_TYPE1SC+0x100>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 8002784:	3730      	adds	r7, #48	; 0x30
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].apn,
 8002786:	eb04 1984 	add.w	r9, r4, r4, lsl #6
 800278a:	ea4f 0949 	mov.w	r9, r9, lsl #1
 800278e:	f109 0948 	add.w	r9, r9, #72	; 0x48
 8002792:	44b1      	add	r9, r6
 8002794:	f109 0909 	add.w	r9, r9, #9
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 8002798:	f893 0091 	ldrb.w	r0, [r3, #145]	; 0x91
 800279c:	f00a f938 	bl	800ca10 <atcm_get_PDPtypeStr>
 80027a0:	9000      	str	r0, [sp, #0]
 80027a2:	464b      	mov	r3, r9
 80027a4:	4642      	mov	r2, r8
 80027a6:	4927      	ldr	r1, [pc, #156]	; (8002844 <fCmdBuild_PDNSET_TYPE1SC+0x194>)
 80027a8:	4638      	mov	r0, r7
 80027aa:	f023 fa61 	bl	8025c70 <sprintf>
 80027ae:	e7b3      	b.n	8002718 <fCmdBuild_PDNSET_TYPE1SC+0x68>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\",\"PAP\",\"%s\",\"%s\"",
 80027b0:	3730      	adds	r7, #48	; 0x30
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].apn,
 80027b2:	ea4f 1984 	mov.w	r9, r4, lsl #6
 80027b6:	eb04 1584 	add.w	r5, r4, r4, lsl #6
 80027ba:	006d      	lsls	r5, r5, #1
 80027bc:	3548      	adds	r5, #72	; 0x48
 80027be:	4435      	add	r5, r6
 80027c0:	3509      	adds	r5, #9
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\",\"PAP\",\"%s\",\"%s\"",
 80027c2:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 80027c6:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 80027ca:	f893 0091 	ldrb.w	r0, [r3, #145]	; 0x91
 80027ce:	f00a f91f 	bl	800ca10 <atcm_get_PDPtypeStr>
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].pdn_conf.username,
 80027d2:	eb09 0304 	add.w	r3, r9, r4
 80027d6:	005b      	lsls	r3, r3, #1
 80027d8:	3388      	adds	r3, #136	; 0x88
 80027da:	4433      	add	r3, r6
 80027dc:	330a      	adds	r3, #10
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].pdn_conf.password);
 80027de:	44a1      	add	r9, r4
 80027e0:	ea4f 0949 	mov.w	r9, r9, lsl #1
 80027e4:	f109 09a8 	add.w	r9, r9, #168	; 0xa8
 80027e8:	444e      	add	r6, r9
 80027ea:	360a      	adds	r6, #10
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\",\"PAP\",\"%s\",\"%s\"",
 80027ec:	9602      	str	r6, [sp, #8]
 80027ee:	9301      	str	r3, [sp, #4]
 80027f0:	9000      	str	r0, [sp, #0]
 80027f2:	462b      	mov	r3, r5
 80027f4:	4642      	mov	r2, r8
 80027f6:	4914      	ldr	r1, [pc, #80]	; (8002848 <fCmdBuild_PDNSET_TYPE1SC+0x198>)
 80027f8:	4638      	mov	r0, r7
 80027fa:	f023 fa39 	bl	8025c70 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 80027fe:	2500      	movs	r5, #0
 8002800:	e78a      	b.n	8002718 <fCmdBuild_PDNSET_TYPE1SC+0x68>
      PRINT_ERR("PDP context not defined for conf_id %d", current_conf_id)
 8002802:	4d0e      	ldr	r5, [pc, #56]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 8002804:	4622      	mov	r2, r4
 8002806:	4911      	ldr	r1, [pc, #68]	; (800284c <fCmdBuild_PDNSET_TYPE1SC+0x19c>)
 8002808:	4628      	mov	r0, r5
 800280a:	f023 fa31 	bl	8025c70 <sprintf>
 800280e:	4628      	mov	r0, r5
 8002810:	f01c fc7f 	bl	801f112 <crs_strlen>
 8002814:	b283      	uxth	r3, r0
 8002816:	462a      	mov	r2, r5
 8002818:	2110      	movs	r1, #16
 800281a:	2002      	movs	r0, #2
 800281c:	f01c fcbc 	bl	801f198 <traceIF_itmPrint>
 8002820:	4628      	mov	r0, r5
 8002822:	f01c fc76 	bl	801f112 <crs_strlen>
 8002826:	b283      	uxth	r3, r0
 8002828:	462a      	mov	r2, r5
 800282a:	2110      	movs	r1, #16
 800282c:	2002      	movs	r0, #2
 800282e:	f01c fcd5 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 8002832:	2501      	movs	r5, #1
 8002834:	e770      	b.n	8002718 <fCmdBuild_PDNSET_TYPE1SC+0x68>
 8002836:	bf00      	nop
 8002838:	0802a904 	.word	0x0802a904
 800283c:	200048dc 	.word	0x200048dc
 8002840:	0802a934 	.word	0x0802a934
 8002844:	0802a95c 	.word	0x0802a95c
 8002848:	0802a96c 	.word	0x0802a96c
 800284c:	0802a98c 	.word	0x0802a98c

08002850 <fRspAnalyze_Error_TYPE1SC>:


/* Analyze command functions -------------------------------------------------*/
at_action_rsp_t fRspAnalyze_Error_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                          const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002850:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002854:	4605      	mov	r5, r0
 8002856:	460e      	mov	r6, r1
 8002858:	4617      	mov	r7, r2
 800285a:	4698      	mov	r8, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval;
  PRINT_API("enter fRspAnalyze_Error_TYPE1SC()")
 800285c:	f8df e08c 	ldr.w	lr, [pc, #140]	; 80028ec <fRspAnalyze_Error_TYPE1SC+0x9c>
 8002860:	4c21      	ldr	r4, [pc, #132]	; (80028e8 <fRspAnalyze_Error_TYPE1SC+0x98>)
 8002862:	f10e 0930 	add.w	r9, lr, #48	; 0x30
 8002866:	46f4      	mov	ip, lr
 8002868:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800286c:	6020      	str	r0, [r4, #0]
 800286e:	6061      	str	r1, [r4, #4]
 8002870:	60a2      	str	r2, [r4, #8]
 8002872:	60e3      	str	r3, [r4, #12]
 8002874:	46e6      	mov	lr, ip
 8002876:	3410      	adds	r4, #16
 8002878:	45cc      	cmp	ip, r9
 800287a:	d1f4      	bne.n	8002866 <fRspAnalyze_Error_TYPE1SC+0x16>
 800287c:	4c1a      	ldr	r4, [pc, #104]	; (80028e8 <fRspAnalyze_Error_TYPE1SC+0x98>)
 800287e:	4620      	mov	r0, r4
 8002880:	f01c fc47 	bl	801f112 <crs_strlen>
 8002884:	b283      	uxth	r3, r0
 8002886:	4622      	mov	r2, r4
 8002888:	2104      	movs	r1, #4
 800288a:	2002      	movs	r0, #2
 800288c:	f01c fc84 	bl	801f198 <traceIF_itmPrint>
 8002890:	4620      	mov	r0, r4
 8002892:	f01c fc3e 	bl	801f112 <crs_strlen>
 8002896:	b283      	uxth	r3, r0
 8002898:	4622      	mov	r2, r4
 800289a:	2104      	movs	r1, #4
 800289c:	2002      	movs	r0, #2
 800289e:	f01c fc9d 	bl	801f1dc <traceIF_uartPrint>

  switch (p_atp_ctxt->current_SID)
 80028a2:	8a2b      	ldrh	r3, [r5, #16]
 80028a4:	2b79      	cmp	r3, #121	; 0x79
 80028a6:	d009      	beq.n	80028bc <fRspAnalyze_Error_TYPE1SC+0x6c>
      /* nothing to do */
      break;
  }

  /* analyze Error for TYPE1SC */
  switch (p_atp_ctxt->current_atcmd.id)
 80028a8:	69ec      	ldr	r4, [r5, #28]
 80028aa:	2c32      	cmp	r4, #50	; 0x32
 80028ac:	d019      	beq.n	80028e2 <fRspAnalyze_Error_TYPE1SC+0x92>
 80028ae:	d80c      	bhi.n	80028ca <fRspAnalyze_Error_TYPE1SC+0x7a>
 80028b0:	3c17      	subs	r4, #23
 80028b2:	2c02      	cmp	r4, #2
 80028b4:	d80e      	bhi.n	80028d4 <fRspAnalyze_Error_TYPE1SC+0x84>
 80028b6:	2001      	movs	r0, #1
      retval = fRspAnalyze_Error(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
      break;
  }

  return (retval);
}
 80028b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      (void) atcm_socket_release_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 80028bc:	f8d6 3740 	ldr.w	r3, [r6, #1856]	; 0x740
 80028c0:	6819      	ldr	r1, [r3, #0]
 80028c2:	4630      	mov	r0, r6
 80028c4:	f011 fbf6 	bl	80140b4 <atcm_socket_release_modem_cid>
      break;
 80028c8:	e7ee      	b.n	80028a8 <fRspAnalyze_Error_TYPE1SC+0x58>
  switch (p_atp_ctxt->current_atcmd.id)
 80028ca:	3c3a      	subs	r4, #58	; 0x3a
 80028cc:	2c04      	cmp	r4, #4
 80028ce:	d801      	bhi.n	80028d4 <fRspAnalyze_Error_TYPE1SC+0x84>
 80028d0:	2001      	movs	r0, #1
 80028d2:	e7f1      	b.n	80028b8 <fRspAnalyze_Error_TYPE1SC+0x68>
      retval = fRspAnalyze_Error(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 80028d4:	4643      	mov	r3, r8
 80028d6:	463a      	mov	r2, r7
 80028d8:	4631      	mov	r1, r6
 80028da:	4628      	mov	r0, r5
 80028dc:	f00d fe8e 	bl	80105fc <fRspAnalyze_Error>
      break;
 80028e0:	e7ea      	b.n	80028b8 <fRspAnalyze_Error_TYPE1SC+0x68>
  switch (p_atp_ctxt->current_atcmd.id)
 80028e2:	2001      	movs	r0, #1
 80028e4:	e7e8      	b.n	80028b8 <fRspAnalyze_Error_TYPE1SC+0x68>
 80028e6:	bf00      	nop
 80028e8:	200048dc 	.word	0x200048dc
 80028ec:	0802a9c4 	.word	0x0802a9c4

080028f0 <fRspAnalyze_CPIN_TYPE1SC>:

at_action_rsp_t fRspAnalyze_CPIN_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                         const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80028f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80028f4:	4605      	mov	r5, r0
 80028f6:	4688      	mov	r8, r1
 80028f8:	4617      	mov	r7, r2
 80028fa:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CPIN_TYPE1SC()")
 80028fc:	f8df c100 	ldr.w	ip, [pc, #256]	; 8002a00 <fRspAnalyze_CPIN_TYPE1SC+0x110>
 8002900:	4c3e      	ldr	r4, [pc, #248]	; (80029fc <fRspAnalyze_CPIN_TYPE1SC+0x10c>)
 8002902:	f10c 0920 	add.w	r9, ip, #32
 8002906:	46e6      	mov	lr, ip
 8002908:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800290c:	6020      	str	r0, [r4, #0]
 800290e:	6061      	str	r1, [r4, #4]
 8002910:	60a2      	str	r2, [r4, #8]
 8002912:	60e3      	str	r3, [r4, #12]
 8002914:	46f4      	mov	ip, lr
 8002916:	3410      	adds	r4, #16
 8002918:	45ce      	cmp	lr, r9
 800291a:	d1f4      	bne.n	8002906 <fRspAnalyze_CPIN_TYPE1SC+0x16>
 800291c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8002920:	6020      	str	r0, [r4, #0]
 8002922:	6061      	str	r1, [r4, #4]
 8002924:	60a2      	str	r2, [r4, #8]
 8002926:	f8bc 2000 	ldrh.w	r2, [ip]
 800292a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800292e:	81a2      	strh	r2, [r4, #12]
 8002930:	73a3      	strb	r3, [r4, #14]
 8002932:	4c32      	ldr	r4, [pc, #200]	; (80029fc <fRspAnalyze_CPIN_TYPE1SC+0x10c>)
 8002934:	4620      	mov	r0, r4
 8002936:	f01c fbec 	bl	801f112 <crs_strlen>
 800293a:	b283      	uxth	r3, r0
 800293c:	4622      	mov	r2, r4
 800293e:	2104      	movs	r1, #4
 8002940:	2002      	movs	r0, #2
 8002942:	f01c fc29 	bl	801f198 <traceIF_itmPrint>
 8002946:	4620      	mov	r0, r4
 8002948:	f01c fbe3 	bl	801f112 <crs_strlen>
 800294c:	b283      	uxth	r3, r0
 800294e:	4622      	mov	r2, r4
 8002950:	2104      	movs	r1, #4
 8002952:	2002      	movs	r0, #2
 8002954:	f01c fc42 	bl	801f1dc <traceIF_uartPrint>
  /*
  *   analyze parameters for +CPIN
  *
  *   if +CPIN is not received after AT+CPIN request, it's an URC
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CPIN)
 8002958:	69eb      	ldr	r3, [r5, #28]
 800295a:	2b12      	cmp	r3, #18
 800295c:	d107      	bne.n	800296e <fRspAnalyze_CPIN_TYPE1SC+0x7e>
  {
    retval = fRspAnalyze_CPIN(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 800295e:	4633      	mov	r3, r6
 8002960:	463a      	mov	r2, r7
 8002962:	4641      	mov	r1, r8
 8002964:	4628      	mov	r0, r5
 8002966:	f00e f9bb 	bl	8010ce0 <fRspAnalyze_CPIN>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 800296a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 800296e:	2400      	movs	r4, #0
 8002970:	4632      	mov	r2, r6
 8002972:	4639      	mov	r1, r7
 8002974:	4628      	mov	r0, r5
 8002976:	f009 fd67 	bl	800c448 <atcc_extractElement>
 800297a:	2801      	cmp	r0, #1
 800297c:	d000      	beq.n	8002980 <fRspAnalyze_CPIN_TYPE1SC+0x90>
 800297e:	2401      	movs	r4, #1
 8002980:	89f3      	ldrh	r3, [r6, #14]
 8002982:	b113      	cbz	r3, 800298a <fRspAnalyze_CPIN_TYPE1SC+0x9a>
    if (element_infos->param_rank == 2U)
 8002984:	8933      	ldrh	r3, [r6, #8]
 8002986:	2b02      	cmp	r3, #2
 8002988:	d003      	beq.n	8002992 <fRspAnalyze_CPIN_TYPE1SC+0xa2>
    END_PARAM_LOOP()
 800298a:	2c00      	cmp	r4, #0
 800298c:	d0f0      	beq.n	8002970 <fRspAnalyze_CPIN_TYPE1SC+0x80>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 800298e:	2010      	movs	r0, #16
 8002990:	e7eb      	b.n	800296a <fRspAnalyze_CPIN_TYPE1SC+0x7a>
      PRINT_DBG("URC +CPIN received")
 8002992:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80029fc <fRspAnalyze_CPIN_TYPE1SC+0x10c>
 8002996:	f8df c06c 	ldr.w	ip, [pc, #108]	; 8002a04 <fRspAnalyze_CPIN_TYPE1SC+0x114>
 800299a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800299e:	f8c8 0000 	str.w	r0, [r8]
 80029a2:	f8c8 1004 	str.w	r1, [r8, #4]
 80029a6:	f8c8 2008 	str.w	r2, [r8, #8]
 80029aa:	f8c8 300c 	str.w	r3, [r8, #12]
 80029ae:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80029b2:	f8c8 0010 	str.w	r0, [r8, #16]
 80029b6:	f8c8 1014 	str.w	r1, [r8, #20]
 80029ba:	f8c8 2018 	str.w	r2, [r8, #24]
 80029be:	f89c 3000 	ldrb.w	r3, [ip]
 80029c2:	f888 301c 	strb.w	r3, [r8, #28]
 80029c6:	4640      	mov	r0, r8
 80029c8:	f01c fba3 	bl	801f112 <crs_strlen>
 80029cc:	b283      	uxth	r3, r0
 80029ce:	4642      	mov	r2, r8
 80029d0:	2102      	movs	r1, #2
 80029d2:	4608      	mov	r0, r1
 80029d4:	f01c fbe0 	bl	801f198 <traceIF_itmPrint>
 80029d8:	4640      	mov	r0, r8
 80029da:	f01c fb9a 	bl	801f112 <crs_strlen>
 80029de:	b283      	uxth	r3, r0
 80029e0:	4642      	mov	r2, r8
 80029e2:	2102      	movs	r1, #2
 80029e4:	4608      	mov	r0, r1
 80029e6:	f01c fbf9 	bl	801f1dc <traceIF_uartPrint>
      PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 80029ea:	8972      	ldrh	r2, [r6, #10]
 80029ec:	89f3      	ldrh	r3, [r6, #14]
 80029ee:	443a      	add	r2, r7
 80029f0:	2102      	movs	r1, #2
 80029f2:	4608      	mov	r0, r1
 80029f4:	f01c febe 	bl	801f774 <traceIF_BufCharPrint>
 80029f8:	e7c7      	b.n	800298a <fRspAnalyze_CPIN_TYPE1SC+0x9a>
 80029fa:	bf00      	nop
 80029fc:	200048dc 	.word	0x200048dc
 8002a00:	0802a9f4 	.word	0x0802a9f4
 8002a04:	0802aa24 	.word	0x0802aa24

08002a08 <fRspAnalyze_CFUN_TYPE1SC>:

at_action_rsp_t fRspAnalyze_CFUN_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                         const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002a08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a0c:	4680      	mov	r8, r0
 8002a0e:	4617      	mov	r7, r2
 8002a10:	461e      	mov	r6, r3
  UNUSED(p_at_ctxt);
  UNUSED(p_modem_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CFUN_TYPE1SC()")
 8002a12:	4c34      	ldr	r4, [pc, #208]	; (8002ae4 <fRspAnalyze_CFUN_TYPE1SC+0xdc>)
 8002a14:	4d34      	ldr	r5, [pc, #208]	; (8002ae8 <fRspAnalyze_CFUN_TYPE1SC+0xe0>)
 8002a16:	f104 0e20 	add.w	lr, r4, #32
 8002a1a:	46a4      	mov	ip, r4
 8002a1c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002a20:	6028      	str	r0, [r5, #0]
 8002a22:	6069      	str	r1, [r5, #4]
 8002a24:	60aa      	str	r2, [r5, #8]
 8002a26:	60eb      	str	r3, [r5, #12]
 8002a28:	4664      	mov	r4, ip
 8002a2a:	3510      	adds	r5, #16
 8002a2c:	45f4      	cmp	ip, lr
 8002a2e:	d1f4      	bne.n	8002a1a <fRspAnalyze_CFUN_TYPE1SC+0x12>
 8002a30:	cc07      	ldmia	r4!, {r0, r1, r2}
 8002a32:	6028      	str	r0, [r5, #0]
 8002a34:	6069      	str	r1, [r5, #4]
 8002a36:	60aa      	str	r2, [r5, #8]
 8002a38:	8822      	ldrh	r2, [r4, #0]
 8002a3a:	78a3      	ldrb	r3, [r4, #2]
 8002a3c:	81aa      	strh	r2, [r5, #12]
 8002a3e:	73ab      	strb	r3, [r5, #14]
 8002a40:	4c29      	ldr	r4, [pc, #164]	; (8002ae8 <fRspAnalyze_CFUN_TYPE1SC+0xe0>)
 8002a42:	4620      	mov	r0, r4
 8002a44:	f01c fb65 	bl	801f112 <crs_strlen>
 8002a48:	b283      	uxth	r3, r0
 8002a4a:	4622      	mov	r2, r4
 8002a4c:	2104      	movs	r1, #4
 8002a4e:	2002      	movs	r0, #2
 8002a50:	f01c fba2 	bl	801f198 <traceIF_itmPrint>
 8002a54:	4620      	mov	r0, r4
 8002a56:	f01c fb5c 	bl	801f112 <crs_strlen>
 8002a5a:	b283      	uxth	r3, r0
 8002a5c:	4622      	mov	r2, r4
 8002a5e:	2104      	movs	r1, #4
 8002a60:	2002      	movs	r0, #2
 8002a62:	f01c fbbb 	bl	801f1dc <traceIF_uartPrint>

  /* this is an URC */
  START_PARAM_LOOP()
 8002a66:	2400      	movs	r4, #0
 8002a68:	4632      	mov	r2, r6
 8002a6a:	4639      	mov	r1, r7
 8002a6c:	4640      	mov	r0, r8
 8002a6e:	f009 fceb 	bl	800c448 <atcc_extractElement>
 8002a72:	2801      	cmp	r0, #1
 8002a74:	d000      	beq.n	8002a78 <fRspAnalyze_CFUN_TYPE1SC+0x70>
 8002a76:	2401      	movs	r4, #1
 8002a78:	89f3      	ldrh	r3, [r6, #14]
 8002a7a:	b113      	cbz	r3, 8002a82 <fRspAnalyze_CFUN_TYPE1SC+0x7a>
  if (element_infos->param_rank == 2U)
 8002a7c:	8933      	ldrh	r3, [r6, #8]
 8002a7e:	2b02      	cmp	r3, #2
 8002a80:	d004      	beq.n	8002a8c <fRspAnalyze_CFUN_TYPE1SC+0x84>
  {
    PRINT_DBG("URC +CFUN received")
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
  }
  END_PARAM_LOOP()
 8002a82:	2c00      	cmp	r4, #0
 8002a84:	d0f0      	beq.n	8002a68 <fRspAnalyze_CFUN_TYPE1SC+0x60>

  return (retval);
}
 8002a86:	2010      	movs	r0, #16
 8002a88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    PRINT_DBG("URC +CFUN received")
 8002a8c:	4d16      	ldr	r5, [pc, #88]	; (8002ae8 <fRspAnalyze_CFUN_TYPE1SC+0xe0>)
 8002a8e:	f8df c05c 	ldr.w	ip, [pc, #92]	; 8002aec <fRspAnalyze_CFUN_TYPE1SC+0xe4>
 8002a92:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002a96:	6028      	str	r0, [r5, #0]
 8002a98:	6069      	str	r1, [r5, #4]
 8002a9a:	60aa      	str	r2, [r5, #8]
 8002a9c:	60eb      	str	r3, [r5, #12]
 8002a9e:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8002aa2:	6128      	str	r0, [r5, #16]
 8002aa4:	6169      	str	r1, [r5, #20]
 8002aa6:	61aa      	str	r2, [r5, #24]
 8002aa8:	f89c 3000 	ldrb.w	r3, [ip]
 8002aac:	772b      	strb	r3, [r5, #28]
 8002aae:	4628      	mov	r0, r5
 8002ab0:	f01c fb2f 	bl	801f112 <crs_strlen>
 8002ab4:	b283      	uxth	r3, r0
 8002ab6:	462a      	mov	r2, r5
 8002ab8:	2102      	movs	r1, #2
 8002aba:	4608      	mov	r0, r1
 8002abc:	f01c fb6c 	bl	801f198 <traceIF_itmPrint>
 8002ac0:	4628      	mov	r0, r5
 8002ac2:	f01c fb26 	bl	801f112 <crs_strlen>
 8002ac6:	b283      	uxth	r3, r0
 8002ac8:	462a      	mov	r2, r5
 8002aca:	2102      	movs	r1, #2
 8002acc:	4608      	mov	r0, r1
 8002ace:	f01c fb85 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8002ad2:	8972      	ldrh	r2, [r6, #10]
 8002ad4:	89f3      	ldrh	r3, [r6, #14]
 8002ad6:	443a      	add	r2, r7
 8002ad8:	2102      	movs	r1, #2
 8002ada:	4608      	mov	r0, r1
 8002adc:	f01c fe4a 	bl	801f774 <traceIF_BufCharPrint>
 8002ae0:	e7cf      	b.n	8002a82 <fRspAnalyze_CFUN_TYPE1SC+0x7a>
 8002ae2:	bf00      	nop
 8002ae4:	0802aa44 	.word	0x0802aa44
 8002ae8:	200048dc 	.word	0x200048dc
 8002aec:	0802aa74 	.word	0x0802aa74

08002af0 <fRspAnalyze_CCID_TYPE1SC>:

at_action_rsp_t fRspAnalyze_CCID_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                         const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002af0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002af4:	4680      	mov	r8, r0
 8002af6:	4689      	mov	r9, r1
 8002af8:	4617      	mov	r7, r2
 8002afa:	461e      	mov	r6, r3
  UNUSED(p_at_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_INTERMEDIATE; /* received a valid intermediate answer */
  PRINT_API("enter fRspAnalyze_QCCID_TYPE1SC()")
 8002afc:	4d35      	ldr	r5, [pc, #212]	; (8002bd4 <fRspAnalyze_CCID_TYPE1SC+0xe4>)
 8002afe:	4c36      	ldr	r4, [pc, #216]	; (8002bd8 <fRspAnalyze_CCID_TYPE1SC+0xe8>)
 8002b00:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002b04:	46ac      	mov	ip, r5
 8002b06:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002b0a:	6020      	str	r0, [r4, #0]
 8002b0c:	6061      	str	r1, [r4, #4]
 8002b0e:	60a2      	str	r2, [r4, #8]
 8002b10:	60e3      	str	r3, [r4, #12]
 8002b12:	4665      	mov	r5, ip
 8002b14:	3410      	adds	r4, #16
 8002b16:	45f4      	cmp	ip, lr
 8002b18:	d1f4      	bne.n	8002b04 <fRspAnalyze_CCID_TYPE1SC+0x14>
 8002b1a:	4c2f      	ldr	r4, [pc, #188]	; (8002bd8 <fRspAnalyze_CCID_TYPE1SC+0xe8>)
 8002b1c:	4620      	mov	r0, r4
 8002b1e:	f01c faf8 	bl	801f112 <crs_strlen>
 8002b22:	b283      	uxth	r3, r0
 8002b24:	4622      	mov	r2, r4
 8002b26:	2104      	movs	r1, #4
 8002b28:	2002      	movs	r0, #2
 8002b2a:	f01c fb35 	bl	801f198 <traceIF_itmPrint>
 8002b2e:	4620      	mov	r0, r4
 8002b30:	f01c faef 	bl	801f112 <crs_strlen>
 8002b34:	b283      	uxth	r3, r0
 8002b36:	4622      	mov	r2, r4
 8002b38:	2104      	movs	r1, #4
 8002b3a:	2002      	movs	r0, #2
 8002b3c:	f01c fb4e 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +QCCID */
  START_PARAM_LOOP()
 8002b40:	2400      	movs	r4, #0
 8002b42:	4632      	mov	r2, r6
 8002b44:	4639      	mov	r1, r7
 8002b46:	4640      	mov	r0, r8
 8002b48:	f009 fc7e 	bl	800c448 <atcc_extractElement>
 8002b4c:	2801      	cmp	r0, #1
 8002b4e:	d000      	beq.n	8002b52 <fRspAnalyze_CCID_TYPE1SC+0x62>
 8002b50:	2401      	movs	r4, #1
 8002b52:	89f3      	ldrh	r3, [r6, #14]
 8002b54:	b113      	cbz	r3, 8002b5c <fRspAnalyze_CCID_TYPE1SC+0x6c>
  if (element_infos->param_rank == 2U)
 8002b56:	8933      	ldrh	r3, [r6, #8]
 8002b58:	2b02      	cmp	r3, #2
 8002b5a:	d004      	beq.n	8002b66 <fRspAnalyze_CCID_TYPE1SC+0x76>
  }
  else
  {
    /* other parameters ignored */
  }
  END_PARAM_LOOP()
 8002b5c:	2c00      	cmp	r4, #0
 8002b5e:	d0f0      	beq.n	8002b42 <fRspAnalyze_CCID_TYPE1SC+0x52>

  return (retval);
}
 8002b60:	2008      	movs	r0, #8
 8002b62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("ICCID:")
 8002b66:	4d1c      	ldr	r5, [pc, #112]	; (8002bd8 <fRspAnalyze_CCID_TYPE1SC+0xe8>)
 8002b68:	f8df c070 	ldr.w	ip, [pc, #112]	; 8002bdc <fRspAnalyze_CCID_TYPE1SC+0xec>
 8002b6c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002b70:	6028      	str	r0, [r5, #0]
 8002b72:	6069      	str	r1, [r5, #4]
 8002b74:	60aa      	str	r2, [r5, #8]
 8002b76:	60eb      	str	r3, [r5, #12]
 8002b78:	f89c 3000 	ldrb.w	r3, [ip]
 8002b7c:	742b      	strb	r3, [r5, #16]
 8002b7e:	4628      	mov	r0, r5
 8002b80:	f01c fac7 	bl	801f112 <crs_strlen>
 8002b84:	b283      	uxth	r3, r0
 8002b86:	462a      	mov	r2, r5
 8002b88:	2102      	movs	r1, #2
 8002b8a:	4608      	mov	r0, r1
 8002b8c:	f01c fb04 	bl	801f198 <traceIF_itmPrint>
 8002b90:	4628      	mov	r0, r5
 8002b92:	f01c fabe 	bl	801f112 <crs_strlen>
 8002b96:	b283      	uxth	r3, r0
 8002b98:	462a      	mov	r2, r5
 8002b9a:	2102      	movs	r1, #2
 8002b9c:	4608      	mov	r0, r1
 8002b9e:	f01c fb1d 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8002ba2:	8972      	ldrh	r2, [r6, #10]
 8002ba4:	89f3      	ldrh	r3, [r6, #14]
 8002ba6:	443a      	add	r2, r7
 8002ba8:	2102      	movs	r1, #2
 8002baa:	4608      	mov	r0, r1
 8002bac:	f01c fde2 	bl	801f774 <traceIF_BufCharPrint>
    uint16_t src_idx = element_infos->str_start_idx;
 8002bb0:	8971      	ldrh	r1, [r6, #10]
    size_t ccid_size = element_infos->str_size;
 8002bb2:	89f2      	ldrh	r2, [r6, #14]
    if ((p_msg_in->buffer[src_idx] == 0x20U) &&
 8002bb4:	5c7b      	ldrb	r3, [r7, r1]
 8002bb6:	2b20      	cmp	r3, #32
 8002bb8:	d006      	beq.n	8002bc8 <fRspAnalyze_CCID_TYPE1SC+0xd8>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.iccid),
 8002bba:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
 8002bbe:	4439      	add	r1, r7
 8002bc0:	3002      	adds	r0, #2
 8002bc2:	f023 f9a5 	bl	8025f10 <memcpy>
 8002bc6:	e7c9      	b.n	8002b5c <fRspAnalyze_CCID_TYPE1SC+0x6c>
    if ((p_msg_in->buffer[src_idx] == 0x20U) &&
 8002bc8:	2a01      	cmp	r2, #1
 8002bca:	d9f6      	bls.n	8002bba <fRspAnalyze_CCID_TYPE1SC+0xca>
      ccid_size -= 1U;
 8002bcc:	3a01      	subs	r2, #1
      src_idx += 1U;
 8002bce:	3101      	adds	r1, #1
 8002bd0:	b289      	uxth	r1, r1
 8002bd2:	e7f2      	b.n	8002bba <fRspAnalyze_CCID_TYPE1SC+0xca>
 8002bd4:	0802aa94 	.word	0x0802aa94
 8002bd8:	200048dc 	.word	0x200048dc
 8002bdc:	0802aac4 	.word	0x0802aac4

08002be0 <fCmdpAnalyze_GETCFG_TYPE1SC>:

at_action_rsp_t fCmdpAnalyze_GETCFG_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                            const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002be4:	460e      	mov	r6, r1
 8002be6:	4690      	mov	r8, r2
 8002be8:	461f      	mov	r7, r3
  UNUSED(p_at_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_INTERMEDIATE; /* received a valid intermediate answer */
  PRINT_API("enter fCmdpAnalyze_GETCFG_TYPE1SC()")
 8002bea:	4d50      	ldr	r5, [pc, #320]	; (8002d2c <fCmdpAnalyze_GETCFG_TYPE1SC+0x14c>)
 8002bec:	4c50      	ldr	r4, [pc, #320]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002bee:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002bf2:	46ac      	mov	ip, r5
 8002bf4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002bf8:	6020      	str	r0, [r4, #0]
 8002bfa:	6061      	str	r1, [r4, #4]
 8002bfc:	60a2      	str	r2, [r4, #8]
 8002bfe:	60e3      	str	r3, [r4, #12]
 8002c00:	4665      	mov	r5, ip
 8002c02:	3410      	adds	r4, #16
 8002c04:	45f4      	cmp	ip, lr
 8002c06:	d1f4      	bne.n	8002bf2 <fCmdpAnalyze_GETCFG_TYPE1SC+0x12>
 8002c08:	f8bc 3000 	ldrh.w	r3, [ip]
 8002c0c:	8023      	strh	r3, [r4, #0]
 8002c0e:	4c48      	ldr	r4, [pc, #288]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002c10:	4620      	mov	r0, r4
 8002c12:	f01c fa7e 	bl	801f112 <crs_strlen>
 8002c16:	b283      	uxth	r3, r0
 8002c18:	4622      	mov	r2, r4
 8002c1a:	2104      	movs	r1, #4
 8002c1c:	2002      	movs	r0, #2
 8002c1e:	f01c fabb 	bl	801f198 <traceIF_itmPrint>
 8002c22:	4620      	mov	r0, r4
 8002c24:	f01c fa75 	bl	801f112 <crs_strlen>
 8002c28:	b283      	uxth	r3, r0
 8002c2a:	4622      	mov	r2, r4
 8002c2c:	2104      	movs	r1, #4
 8002c2e:	2002      	movs	r0, #2
 8002c30:	f01c fad4 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for GETCFG or GETACFG */
  if (type1sc_shared.getcfg_function == SETGETCFG_UART_FLOW_CONTROL)
 8002c34:	4b3f      	ldr	r3, [pc, #252]	; (8002d34 <fCmdpAnalyze_GETCFG_TYPE1SC+0x154>)
 8002c36:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002c3a:	2b09      	cmp	r3, #9
 8002c3c:	d002      	beq.n	8002c44 <fCmdpAnalyze_GETCFG_TYPE1SC+0x64>
      p_modem_ctxt->persist.flowCtrl_CTS = 0U;
    }
  }

  return (retval);
}
 8002c3e:	2008      	movs	r0, #8
 8002c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t hwFC_status = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8002c44:	8978      	ldrh	r0, [r7, #10]
 8002c46:	89f9      	ldrh	r1, [r7, #14]
 8002c48:	4440      	add	r0, r8
 8002c4a:	f012 f873 	bl	8014d34 <ATutil_convertStringToInt>
 8002c4e:	4605      	mov	r5, r0
    PRINT_DBG("GETCFG/GETACFG: Hw Flow Control setting = %ld", hwFC_status)
 8002c50:	4602      	mov	r2, r0
 8002c52:	4939      	ldr	r1, [pc, #228]	; (8002d38 <fCmdpAnalyze_GETCFG_TYPE1SC+0x158>)
 8002c54:	4620      	mov	r0, r4
 8002c56:	f023 f80b 	bl	8025c70 <sprintf>
 8002c5a:	4620      	mov	r0, r4
 8002c5c:	f01c fa59 	bl	801f112 <crs_strlen>
 8002c60:	b283      	uxth	r3, r0
 8002c62:	4622      	mov	r2, r4
 8002c64:	2102      	movs	r1, #2
 8002c66:	4608      	mov	r0, r1
 8002c68:	f01c fa96 	bl	801f198 <traceIF_itmPrint>
 8002c6c:	4620      	mov	r0, r4
 8002c6e:	f01c fa50 	bl	801f112 <crs_strlen>
 8002c72:	b283      	uxth	r3, r0
 8002c74:	4622      	mov	r2, r4
 8002c76:	2102      	movs	r1, #2
 8002c78:	4608      	mov	r0, r1
 8002c7a:	f01c faaf 	bl	801f1dc <traceIF_uartPrint>
    if (hwFC_status == 1U)
 8002c7e:	2d01      	cmp	r5, #1
 8002c80:	d02b      	beq.n	8002cda <fCmdpAnalyze_GETCFG_TYPE1SC+0xfa>
      PRINT_DBG("Hw Flow Control setting is OFF")
 8002c82:	4d2e      	ldr	r5, [pc, #184]	; (8002d3c <fCmdpAnalyze_GETCFG_TYPE1SC+0x15c>)
 8002c84:	4c2a      	ldr	r4, [pc, #168]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002c86:	f105 0c20 	add.w	ip, r5, #32
 8002c8a:	462f      	mov	r7, r5
 8002c8c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8002c8e:	6020      	str	r0, [r4, #0]
 8002c90:	6061      	str	r1, [r4, #4]
 8002c92:	60a2      	str	r2, [r4, #8]
 8002c94:	60e3      	str	r3, [r4, #12]
 8002c96:	463d      	mov	r5, r7
 8002c98:	3410      	adds	r4, #16
 8002c9a:	4567      	cmp	r7, ip
 8002c9c:	d1f5      	bne.n	8002c8a <fCmdpAnalyze_GETCFG_TYPE1SC+0xaa>
 8002c9e:	cd03      	ldmia	r5!, {r0, r1}
 8002ca0:	6020      	str	r0, [r4, #0]
 8002ca2:	6061      	str	r1, [r4, #4]
 8002ca4:	782b      	ldrb	r3, [r5, #0]
 8002ca6:	7223      	strb	r3, [r4, #8]
 8002ca8:	4c21      	ldr	r4, [pc, #132]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002caa:	4620      	mov	r0, r4
 8002cac:	f01c fa31 	bl	801f112 <crs_strlen>
 8002cb0:	b283      	uxth	r3, r0
 8002cb2:	4622      	mov	r2, r4
 8002cb4:	2102      	movs	r1, #2
 8002cb6:	4608      	mov	r0, r1
 8002cb8:	f01c fa6e 	bl	801f198 <traceIF_itmPrint>
 8002cbc:	4620      	mov	r0, r4
 8002cbe:	f01c fa28 	bl	801f112 <crs_strlen>
 8002cc2:	b283      	uxth	r3, r0
 8002cc4:	4622      	mov	r2, r4
 8002cc6:	2102      	movs	r1, #2
 8002cc8:	4608      	mov	r0, r1
 8002cca:	f01c fa87 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->persist.flowCtrl_RTS = 0U;
 8002cce:	2300      	movs	r3, #0
 8002cd0:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
      p_modem_ctxt->persist.flowCtrl_CTS = 0U;
 8002cd4:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 8002cd8:	e7b1      	b.n	8002c3e <fCmdpAnalyze_GETCFG_TYPE1SC+0x5e>
      PRINT_DBG("Hw Flow Control setting is ON")
 8002cda:	4f19      	ldr	r7, [pc, #100]	; (8002d40 <fCmdpAnalyze_GETCFG_TYPE1SC+0x160>)
 8002cdc:	f107 0c20 	add.w	ip, r7, #32
 8002ce0:	463d      	mov	r5, r7
 8002ce2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002ce4:	6020      	str	r0, [r4, #0]
 8002ce6:	6061      	str	r1, [r4, #4]
 8002ce8:	60a2      	str	r2, [r4, #8]
 8002cea:	60e3      	str	r3, [r4, #12]
 8002cec:	462f      	mov	r7, r5
 8002cee:	3410      	adds	r4, #16
 8002cf0:	4565      	cmp	r5, ip
 8002cf2:	d1f5      	bne.n	8002ce0 <fCmdpAnalyze_GETCFG_TYPE1SC+0x100>
 8002cf4:	cf03      	ldmia	r7!, {r0, r1}
 8002cf6:	6020      	str	r0, [r4, #0]
 8002cf8:	6061      	str	r1, [r4, #4]
 8002cfa:	4c0d      	ldr	r4, [pc, #52]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002cfc:	4620      	mov	r0, r4
 8002cfe:	f01c fa08 	bl	801f112 <crs_strlen>
 8002d02:	b283      	uxth	r3, r0
 8002d04:	4622      	mov	r2, r4
 8002d06:	2102      	movs	r1, #2
 8002d08:	4608      	mov	r0, r1
 8002d0a:	f01c fa45 	bl	801f198 <traceIF_itmPrint>
 8002d0e:	4620      	mov	r0, r4
 8002d10:	f01c f9ff 	bl	801f112 <crs_strlen>
 8002d14:	b283      	uxth	r3, r0
 8002d16:	4622      	mov	r2, r4
 8002d18:	2102      	movs	r1, #2
 8002d1a:	4608      	mov	r0, r1
 8002d1c:	f01c fa5e 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->persist.flowCtrl_RTS = 2U;
 8002d20:	2302      	movs	r3, #2
 8002d22:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
      p_modem_ctxt->persist.flowCtrl_CTS = 2U;
 8002d26:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 8002d2a:	e788      	b.n	8002c3e <fCmdpAnalyze_GETCFG_TYPE1SC+0x5e>
 8002d2c:	0802aad8 	.word	0x0802aad8
 8002d30:	200048dc 	.word	0x200048dc
 8002d34:	20001838 	.word	0x20001838
 8002d38:	0802ab0c 	.word	0x0802ab0c
 8002d3c:	0802ab6c 	.word	0x0802ab6c
 8002d40:	0802ab44 	.word	0x0802ab44

08002d44 <convertToASCII>:
  */
static uint8_t convertToASCII(uint8_t nbr)
{
  uint8_t ascii;

  if (nbr <= 9U)
 8002d44:	2809      	cmp	r0, #9
 8002d46:	d802      	bhi.n	8002d4e <convertToASCII+0xa>
  {
    ascii = nbr + 48U;
 8002d48:	3030      	adds	r0, #48	; 0x30
 8002d4a:	b2c0      	uxtb	r0, r0
 8002d4c:	4770      	bx	lr
  }
  else
  {
    ascii = nbr + 87U; /* 87 = 97 -10 (where 97 correspond to 'a') */
 8002d4e:	3057      	adds	r0, #87	; 0x57
 8002d50:	b2c0      	uxtb	r0, r0
  }
  return (ascii);
}
 8002d52:	4770      	bx	lr

08002d54 <convertCharToHEX>:
  * @param  p_msb ptr to Most significant Digit of HEX value
  * @param  p_lsb ptr to Less significant Digit of HEX value
  * @retval none.
  */
static void convertCharToHEX(uint8_t val, uint8_t *p_msd, uint8_t *p_lsd)
{
 8002d54:	b570      	push	{r4, r5, r6, lr}
 8002d56:	4604      	mov	r4, r0
 8002d58:	460e      	mov	r6, r1
 8002d5a:	4615      	mov	r5, r2
  *p_msd = convertToASCII(val / 16U);
 8002d5c:	0900      	lsrs	r0, r0, #4
 8002d5e:	f7ff fff1 	bl	8002d44 <convertToASCII>
 8002d62:	7030      	strb	r0, [r6, #0]
  *p_lsd = convertToASCII(val % 16U);
 8002d64:	f004 000f 	and.w	r0, r4, #15
 8002d68:	f7ff ffec 	bl	8002d44 <convertToASCII>
 8002d6c:	7028      	strb	r0, [r5, #0]
}
 8002d6e:	bd70      	pop	{r4, r5, r6, pc}

08002d70 <convertDigitToValue>:
  */
static at_status_t convertDigitToValue(uint8_t digit, uint8_t *p_res)
{
  at_status_t retval = ATSTATUS_OK;

  if ((digit >= 48U) && (digit <= 57U))
 8002d70:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 8002d74:	b2db      	uxtb	r3, r3
 8002d76:	2b09      	cmp	r3, #9
 8002d78:	d802      	bhi.n	8002d80 <convertDigitToValue+0x10>
  {
    /* 0 to 9 */
    *p_res = digit - 48U;
 8002d7a:	700b      	strb	r3, [r1, #0]
  at_status_t retval = ATSTATUS_OK;
 8002d7c:	2000      	movs	r0, #0
 8002d7e:	4770      	bx	lr
  }
  else if ((digit >= 97U) && (digit <= 102U))
 8002d80:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 8002d84:	b2db      	uxtb	r3, r3
 8002d86:	2b05      	cmp	r3, #5
 8002d88:	d803      	bhi.n	8002d92 <convertDigitToValue+0x22>
  {
    /* a to f */
    *p_res = digit - 87U; /* 87 = -97+10 */
 8002d8a:	3857      	subs	r0, #87	; 0x57
 8002d8c:	7008      	strb	r0, [r1, #0]
  at_status_t retval = ATSTATUS_OK;
 8002d8e:	2000      	movs	r0, #0
 8002d90:	4770      	bx	lr
  }
  else if ((digit >= 65U) && (digit <= 70U))
 8002d92:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 8002d96:	b2db      	uxtb	r3, r3
 8002d98:	2b05      	cmp	r3, #5
 8002d9a:	d803      	bhi.n	8002da4 <convertDigitToValue+0x34>
  {
    /* A to F */
    *p_res = digit - 55U; /* 55 = -65+10*/
 8002d9c:	3837      	subs	r0, #55	; 0x37
 8002d9e:	7008      	strb	r0, [r1, #0]
  at_status_t retval = ATSTATUS_OK;
 8002da0:	2000      	movs	r0, #0
 8002da2:	4770      	bx	lr
  }
  else
  {
    *p_res = 0;
 8002da4:	2300      	movs	r3, #0
 8002da6:	700b      	strb	r3, [r1, #0]
    retval = ATSTATUS_ERROR;
 8002da8:	2001      	movs	r0, #1
  }
  return (retval);
}
 8002daa:	4770      	bx	lr

08002dac <convertHEXToChar>:
  * @param  lsd Less significant Digit of HEX value.
  * @param  p_conv ptr to converted Character value.
  * @retval at_status_t.
  */
static at_status_t convertHEXToChar(uint8_t msd, uint8_t lsd, uint8_t *p_conv)
{
 8002dac:	b530      	push	{r4, r5, lr}
 8002dae:	b083      	sub	sp, #12
 8002db0:	460c      	mov	r4, r1
 8002db2:	4615      	mov	r5, r2
  at_status_t retval = ATSTATUS_OK;
  uint8_t convMSD;
  uint8_t convLSD;

  /* convert Most significant digit */
  if (convertDigitToValue(msd, &convMSD) == ATSTATUS_OK)
 8002db4:	f10d 0107 	add.w	r1, sp, #7
 8002db8:	f7ff ffda 	bl	8002d70 <convertDigitToValue>
 8002dbc:	b110      	cbz	r0, 8002dc4 <convertHEXToChar+0x18>
      retval = ATSTATUS_ERROR;
    }
  }
  else
  {
    retval = ATSTATUS_ERROR;
 8002dbe:	2001      	movs	r0, #1
  }
  return (retval);
}
 8002dc0:	b003      	add	sp, #12
 8002dc2:	bd30      	pop	{r4, r5, pc}
    if (convertDigitToValue(lsd, &convLSD) == ATSTATUS_OK)
 8002dc4:	f10d 0106 	add.w	r1, sp, #6
 8002dc8:	4620      	mov	r0, r4
 8002dca:	f7ff ffd1 	bl	8002d70 <convertDigitToValue>
 8002dce:	b940      	cbnz	r0, 8002de2 <convertHEXToChar+0x36>
      *p_conv = (convMSD << 4) + convLSD;
 8002dd0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002dd4:	011b      	lsls	r3, r3, #4
 8002dd6:	b2db      	uxtb	r3, r3
 8002dd8:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8002ddc:	4413      	add	r3, r2
 8002dde:	702b      	strb	r3, [r5, #0]
 8002de0:	e7ee      	b.n	8002dc0 <convertHEXToChar+0x14>
      retval = ATSTATUS_ERROR;
 8002de2:	2001      	movs	r0, #1
 8002de4:	e7ec      	b.n	8002dc0 <convertHEXToChar+0x14>
	...

08002de8 <fCmdBuild_PDNACT>:
{
 8002de8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002dec:	4606      	mov	r6, r0
 8002dee:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_PDNACT()")
 8002df0:	4d34      	ldr	r5, [pc, #208]	; (8002ec4 <fCmdBuild_PDNACT+0xdc>)
 8002df2:	4c35      	ldr	r4, [pc, #212]	; (8002ec8 <fCmdBuild_PDNACT+0xe0>)
 8002df4:	f105 0e20 	add.w	lr, r5, #32
 8002df8:	46ac      	mov	ip, r5
 8002dfa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002dfe:	6020      	str	r0, [r4, #0]
 8002e00:	6061      	str	r1, [r4, #4]
 8002e02:	60a2      	str	r2, [r4, #8]
 8002e04:	60e3      	str	r3, [r4, #12]
 8002e06:	4665      	mov	r5, ip
 8002e08:	3410      	adds	r4, #16
 8002e0a:	45f4      	cmp	ip, lr
 8002e0c:	d1f4      	bne.n	8002df8 <fCmdBuild_PDNACT+0x10>
 8002e0e:	f8dc 0000 	ldr.w	r0, [ip]
 8002e12:	6020      	str	r0, [r4, #0]
 8002e14:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8002e18:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8002e1c:	80a2      	strh	r2, [r4, #4]
 8002e1e:	71a3      	strb	r3, [r4, #6]
 8002e20:	4c29      	ldr	r4, [pc, #164]	; (8002ec8 <fCmdBuild_PDNACT+0xe0>)
 8002e22:	4620      	mov	r0, r4
 8002e24:	f01c f975 	bl	801f112 <crs_strlen>
 8002e28:	b283      	uxth	r3, r0
 8002e2a:	4622      	mov	r2, r4
 8002e2c:	2104      	movs	r1, #4
 8002e2e:	2002      	movs	r0, #2
 8002e30:	f01c f9b2 	bl	801f198 <traceIF_itmPrint>
 8002e34:	4620      	mov	r0, r4
 8002e36:	f01c f96c 	bl	801f112 <crs_strlen>
 8002e3a:	b283      	uxth	r3, r0
 8002e3c:	4622      	mov	r2, r4
 8002e3e:	2104      	movs	r1, #4
 8002e40:	2002      	movs	r0, #2
 8002e42:	f01c f9cb 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002e46:	8933      	ldrh	r3, [r6, #8]
 8002e48:	2b03      	cmp	r3, #3
 8002e4a:	d002      	beq.n	8002e52 <fCmdBuild_PDNACT+0x6a>
}
 8002e4c:	2000      	movs	r0, #0
 8002e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 8002e52:	4638      	mov	r0, r7
 8002e54:	f009 fd2e 	bl	800c8b4 <atcm_get_cid_current_SID>
 8002e58:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 8002e5a:	4601      	mov	r1, r0
 8002e5c:	f107 000c 	add.w	r0, r7, #12
 8002e60:	f00a fdb0 	bl	800d9c4 <atcm_get_affected_modem_cid>
 8002e64:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 8002e66:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 8002e6a:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 8002e6e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8002e72:	2b0c      	cmp	r3, #12
 8002e74:	d00c      	beq.n	8002e90 <fCmdBuild_PDNACT+0xa8>
                   ((p_modem_ctxt->CMD_ctxt.pdn_state == PDN_STATE_ACTIVATE) ? 1 : 0),
 8002e76:	f897 2731 	ldrb.w	r2, [r7, #1841]	; 0x731
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d",
 8002e7a:	462b      	mov	r3, r5
 8002e7c:	2a01      	cmp	r2, #1
 8002e7e:	bf14      	ite	ne
 8002e80:	2200      	movne	r2, #0
 8002e82:	2201      	moveq	r2, #1
 8002e84:	4911      	ldr	r1, [pc, #68]	; (8002ecc <fCmdBuild_PDNACT+0xe4>)
 8002e86:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8002e8a:	f022 fef1 	bl	8025c70 <sprintf>
 8002e8e:	e7dd      	b.n	8002e4c <fCmdBuild_PDNACT+0x64>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 8002e90:	f8df 8034 	ldr.w	r8, [pc, #52]	; 8002ec8 <fCmdBuild_PDNACT+0xe0>
 8002e94:	4622      	mov	r2, r4
 8002e96:	490e      	ldr	r1, [pc, #56]	; (8002ed0 <fCmdBuild_PDNACT+0xe8>)
 8002e98:	4640      	mov	r0, r8
 8002e9a:	f022 fee9 	bl	8025c70 <sprintf>
 8002e9e:	4640      	mov	r0, r8
 8002ea0:	f01c f937 	bl	801f112 <crs_strlen>
 8002ea4:	b283      	uxth	r3, r0
 8002ea6:	4642      	mov	r2, r8
 8002ea8:	2101      	movs	r1, #1
 8002eaa:	2002      	movs	r0, #2
 8002eac:	f01c f974 	bl	801f198 <traceIF_itmPrint>
 8002eb0:	4640      	mov	r0, r8
 8002eb2:	f01c f92e 	bl	801f112 <crs_strlen>
 8002eb6:	b283      	uxth	r3, r0
 8002eb8:	4642      	mov	r2, r8
 8002eba:	2101      	movs	r1, #1
 8002ebc:	2002      	movs	r0, #2
 8002ebe:	f01c f98d 	bl	801f1dc <traceIF_uartPrint>
 8002ec2:	e7d8      	b.n	8002e76 <fCmdBuild_PDNACT+0x8e>
 8002ec4:	0802ab98 	.word	0x0802ab98
 8002ec8:	200048dc 	.word	0x200048dc
 8002ecc:	0802ac14 	.word	0x0802ac14
 8002ed0:	0802abc0 	.word	0x0802abc0

08002ed4 <fCmdBuild_SOCKETCMD_ALLOCATE>:
{
 8002ed4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ed6:	b087      	sub	sp, #28
 8002ed8:	4606      	mov	r6, r0
 8002eda:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_ALLOCATE()")
 8002edc:	4d5a      	ldr	r5, [pc, #360]	; (8003048 <fCmdBuild_SOCKETCMD_ALLOCATE+0x174>)
 8002ede:	4c5b      	ldr	r4, [pc, #364]	; (800304c <fCmdBuild_SOCKETCMD_ALLOCATE+0x178>)
 8002ee0:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002ee4:	46ac      	mov	ip, r5
 8002ee6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002eea:	6020      	str	r0, [r4, #0]
 8002eec:	6061      	str	r1, [r4, #4]
 8002eee:	60a2      	str	r2, [r4, #8]
 8002ef0:	60e3      	str	r3, [r4, #12]
 8002ef2:	4665      	mov	r5, ip
 8002ef4:	3410      	adds	r4, #16
 8002ef6:	45f4      	cmp	ip, lr
 8002ef8:	d1f4      	bne.n	8002ee4 <fCmdBuild_SOCKETCMD_ALLOCATE+0x10>
 8002efa:	f8bc 2000 	ldrh.w	r2, [ip]
 8002efe:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8002f02:	8022      	strh	r2, [r4, #0]
 8002f04:	70a3      	strb	r3, [r4, #2]
 8002f06:	4c51      	ldr	r4, [pc, #324]	; (800304c <fCmdBuild_SOCKETCMD_ALLOCATE+0x178>)
 8002f08:	4620      	mov	r0, r4
 8002f0a:	f01c f902 	bl	801f112 <crs_strlen>
 8002f0e:	b283      	uxth	r3, r0
 8002f10:	4622      	mov	r2, r4
 8002f12:	2104      	movs	r1, #4
 8002f14:	2002      	movs	r0, #2
 8002f16:	f01c f93f 	bl	801f198 <traceIF_itmPrint>
 8002f1a:	4620      	mov	r0, r4
 8002f1c:	f01c f8f9 	bl	801f112 <crs_strlen>
 8002f20:	b283      	uxth	r3, r0
 8002f22:	4622      	mov	r2, r4
 8002f24:	2104      	movs	r1, #4
 8002f26:	2002      	movs	r0, #2
 8002f28:	f01c f958 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002f2c:	8933      	ldrh	r3, [r6, #8]
 8002f2e:	2b03      	cmp	r3, #3
 8002f30:	d002      	beq.n	8002f38 <fCmdBuild_SOCKETCMD_ALLOCATE+0x64>
}
 8002f32:	2000      	movs	r0, #0
 8002f34:	b007      	add	sp, #28
 8002f36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 8002f38:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 8002f3c:	2b00      	cmp	r3, #0
 8002f3e:	d06a      	beq.n	8003016 <fCmdBuild_SOCKETCMD_ALLOCATE+0x142>
      uint8_t pdp_modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist,
 8002f40:	7b19      	ldrb	r1, [r3, #12]
 8002f42:	f107 000c 	add.w	r0, r7, #12
 8002f46:	f00a fd3d 	bl	800d9c4 <atcm_get_affected_modem_cid>
 8002f4a:	4605      	mov	r5, r0
      PRINT_INFO("user cid = %d, PDP modem cid = %d", (uint8_t)p_modem_ctxt->socket_ctxt.socket_info->conf_id,
 8002f4c:	f8d7 2740 	ldr.w	r2, [r7, #1856]	; 0x740
 8002f50:	4603      	mov	r3, r0
 8002f52:	7b12      	ldrb	r2, [r2, #12]
 8002f54:	493e      	ldr	r1, [pc, #248]	; (8003050 <fCmdBuild_SOCKETCMD_ALLOCATE+0x17c>)
 8002f56:	4620      	mov	r0, r4
 8002f58:	f022 fe8a 	bl	8025c70 <sprintf>
 8002f5c:	4620      	mov	r0, r4
 8002f5e:	f01c f8d8 	bl	801f112 <crs_strlen>
 8002f62:	b283      	uxth	r3, r0
 8002f64:	4622      	mov	r2, r4
 8002f66:	2101      	movs	r1, #1
 8002f68:	2002      	movs	r0, #2
 8002f6a:	f01c f915 	bl	801f198 <traceIF_itmPrint>
 8002f6e:	4620      	mov	r0, r4
 8002f70:	f01c f8cf 	bl	801f112 <crs_strlen>
 8002f74:	b283      	uxth	r3, r0
 8002f76:	4622      	mov	r2, r4
 8002f78:	2101      	movs	r1, #1
 8002f7a:	2002      	movs	r0, #2
 8002f7c:	f01c f92e 	bl	801f1dc <traceIF_uartPrint>
      if (strcmp((CRC_CHAR_t const *)p_modem_ctxt->socket_ctxt.socket_info->ip_addr_value,
 8002f80:	f8d7 4740 	ldr.w	r4, [r7, #1856]	; 0x740
 8002f84:	f104 070e 	add.w	r7, r4, #14
 8002f88:	4932      	ldr	r1, [pc, #200]	; (8003054 <fCmdBuild_SOCKETCMD_ALLOCATE+0x180>)
 8002f8a:	4638      	mov	r0, r7
 8002f8c:	f7fd f928 	bl	80001e0 <strcmp>
 8002f90:	b918      	cbnz	r0, 8002f9a <fCmdBuild_SOCKETCMD_ALLOCATE+0xc6>
        service_type_index = ((p_modem_ctxt->socket_ctxt.socket_info->protocol) == CS_TCP_PROTOCOL) ? \
 8002f92:	7a63      	ldrb	r3, [r4, #9]
 8002f94:	bb1b      	cbnz	r3, 8002fde <fCmdBuild_SOCKETCMD_ALLOCATE+0x10a>
 8002f96:	2202      	movs	r2, #2
 8002f98:	e003      	b.n	8002fa2 <fCmdBuild_SOCKETCMD_ALLOCATE+0xce>
        service_type_index = ((p_modem_ctxt->socket_ctxt.socket_info->protocol) == CS_TCP_PROTOCOL) ? \
 8002f9a:	7a62      	ldrb	r2, [r4, #9]
                             ATSOCKET_SERVICETYPE_TCP_CLIENT : ATSOCKET_SERVICETYPE_UDP_CLIENT;
 8002f9c:	3a00      	subs	r2, #0
 8002f9e:	bf18      	it	ne
 8002fa0:	2201      	movne	r2, #1
          || (service_type_index == ATSOCKET_SERVICETYPE_UDP_SERVICE))
 8002fa2:	1e93      	subs	r3, r2, #2
 8002fa4:	b2db      	uxtb	r3, r3
      if ((service_type_index == ATSOCKET_SERVICETYPE_TCP_SERVER)
 8002fa6:	2b01      	cmp	r3, #1
 8002fa8:	d91b      	bls.n	8002fe2 <fCmdBuild_SOCKETCMD_ALLOCATE+0x10e>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8002faa:	f106 0030 	add.w	r0, r6, #48	; 0x30
                       ((p_modem_ctxt->socket_ctxt.socket_info->protocol == CS_TCP_PROTOCOL) ? "TCP" : "UDP"),
 8002fae:	7a63      	ldrb	r3, [r4, #9]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8002fb0:	2b00      	cmp	r3, #0
 8002fb2:	d12e      	bne.n	8003012 <fCmdBuild_SOCKETCMD_ALLOCATE+0x13e>
 8002fb4:	4b28      	ldr	r3, [pc, #160]	; (8003058 <fCmdBuild_SOCKETCMD_ALLOCATE+0x184>)
                       type1sc_array_ALLOCATE_service_type[service_type_index],
 8002fb6:	4929      	ldr	r1, [pc, #164]	; (800305c <fCmdBuild_SOCKETCMD_ALLOCATE+0x188>)
 8002fb8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
                       p_modem_ctxt->socket_ctxt.socket_info->remote_port,
 8002fbc:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
                       p_modem_ctxt->socket_ctxt.socket_info->local_port,
 8002fc0:	8964      	ldrh	r4, [r4, #10]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8002fc2:	f240 26c6 	movw	r6, #710	; 0x2c6
 8002fc6:	9605      	str	r6, [sp, #20]
 8002fc8:	9404      	str	r4, [sp, #16]
 8002fca:	9103      	str	r1, [sp, #12]
 8002fcc:	9702      	str	r7, [sp, #8]
 8002fce:	9201      	str	r2, [sp, #4]
 8002fd0:	9300      	str	r3, [sp, #0]
 8002fd2:	462b      	mov	r3, r5
 8002fd4:	4a22      	ldr	r2, [pc, #136]	; (8003060 <fCmdBuild_SOCKETCMD_ALLOCATE+0x18c>)
 8002fd6:	4923      	ldr	r1, [pc, #140]	; (8003064 <fCmdBuild_SOCKETCMD_ALLOCATE+0x190>)
 8002fd8:	f022 fe4a 	bl	8025c70 <sprintf>
 8002fdc:	e7a9      	b.n	8002f32 <fCmdBuild_SOCKETCMD_ALLOCATE+0x5e>
        service_type_index = ((p_modem_ctxt->socket_ctxt.socket_info->protocol) == CS_TCP_PROTOCOL) ? \
 8002fde:	2203      	movs	r2, #3
 8002fe0:	e7df      	b.n	8002fa2 <fCmdBuild_SOCKETCMD_ALLOCATE+0xce>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",,%d,%ld",
 8002fe2:	f106 0030 	add.w	r0, r6, #48	; 0x30
                       ((p_modem_ctxt->socket_ctxt.socket_info->protocol == CS_TCP_PROTOCOL) ? "TCP" : "UDP"),
 8002fe6:	7a63      	ldrb	r3, [r4, #9]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",,%d,%ld",
 8002fe8:	b98b      	cbnz	r3, 800300e <fCmdBuild_SOCKETCMD_ALLOCATE+0x13a>
 8002fea:	4e1b      	ldr	r6, [pc, #108]	; (8003058 <fCmdBuild_SOCKETCMD_ALLOCATE+0x184>)
                       type1sc_array_ALLOCATE_service_type[service_type_index],
 8002fec:	4b1b      	ldr	r3, [pc, #108]	; (800305c <fCmdBuild_SOCKETCMD_ALLOCATE+0x188>)
 8002fee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
                       p_modem_ctxt->socket_ctxt.socket_info->local_port,
 8002ff2:	8962      	ldrh	r2, [r4, #10]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",,%d,%ld",
 8002ff4:	f240 21c6 	movw	r1, #710	; 0x2c6
 8002ff8:	9104      	str	r1, [sp, #16]
 8002ffa:	9203      	str	r2, [sp, #12]
 8002ffc:	9702      	str	r7, [sp, #8]
 8002ffe:	9301      	str	r3, [sp, #4]
 8003000:	9600      	str	r6, [sp, #0]
 8003002:	462b      	mov	r3, r5
 8003004:	4a16      	ldr	r2, [pc, #88]	; (8003060 <fCmdBuild_SOCKETCMD_ALLOCATE+0x18c>)
 8003006:	4918      	ldr	r1, [pc, #96]	; (8003068 <fCmdBuild_SOCKETCMD_ALLOCATE+0x194>)
 8003008:	f022 fe32 	bl	8025c70 <sprintf>
 800300c:	e791      	b.n	8002f32 <fCmdBuild_SOCKETCMD_ALLOCATE+0x5e>
 800300e:	4e17      	ldr	r6, [pc, #92]	; (800306c <fCmdBuild_SOCKETCMD_ALLOCATE+0x198>)
 8003010:	e7ec      	b.n	8002fec <fCmdBuild_SOCKETCMD_ALLOCATE+0x118>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8003012:	4b16      	ldr	r3, [pc, #88]	; (800306c <fCmdBuild_SOCKETCMD_ALLOCATE+0x198>)
 8003014:	e7cf      	b.n	8002fb6 <fCmdBuild_SOCKETCMD_ALLOCATE+0xe2>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_ALLOCATE")
 8003016:	4c0d      	ldr	r4, [pc, #52]	; (800304c <fCmdBuild_SOCKETCMD_ALLOCATE+0x178>)
 8003018:	2243      	movs	r2, #67	; 0x43
 800301a:	4915      	ldr	r1, [pc, #84]	; (8003070 <fCmdBuild_SOCKETCMD_ALLOCATE+0x19c>)
 800301c:	4620      	mov	r0, r4
 800301e:	f022 ff77 	bl	8025f10 <memcpy>
 8003022:	4620      	mov	r0, r4
 8003024:	f01c f875 	bl	801f112 <crs_strlen>
 8003028:	b283      	uxth	r3, r0
 800302a:	4622      	mov	r2, r4
 800302c:	2110      	movs	r1, #16
 800302e:	2002      	movs	r0, #2
 8003030:	f01c f8b2 	bl	801f198 <traceIF_itmPrint>
 8003034:	4620      	mov	r0, r4
 8003036:	f01c f86c 	bl	801f112 <crs_strlen>
 800303a:	b283      	uxth	r3, r0
 800303c:	4622      	mov	r2, r4
 800303e:	2110      	movs	r1, #16
 8003040:	2002      	movs	r0, #2
 8003042:	f01c f8cb 	bl	801f1dc <traceIF_uartPrint>
 8003046:	e774      	b.n	8002f32 <fCmdBuild_SOCKETCMD_ALLOCATE+0x5e>
 8003048:	0802ac24 	.word	0x0802ac24
 800304c:	200048dc 	.word	0x200048dc
 8003050:	0802ac58 	.word	0x0802ac58
 8003054:	0802ac84 	.word	0x0802ac84
 8003058:	0802ac1c 	.word	0x0802ac1c
 800305c:	0802b7b0 	.word	0x0802b7b0
 8003060:	0802ac8c 	.word	0x0802ac8c
 8003064:	0802acb8 	.word	0x0802acb8
 8003068:	0802ac98 	.word	0x0802ac98
 800306c:	0802ac20 	.word	0x0802ac20
 8003070:	0802acdc 	.word	0x0802acdc

08003074 <fCmdBuild_SOCKETCMD_ACTIVATE>:
{
 8003074:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003076:	4606      	mov	r6, r0
 8003078:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_ACTIVATE()")
 800307a:	4d2a      	ldr	r5, [pc, #168]	; (8003124 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb0>)
 800307c:	4c2a      	ldr	r4, [pc, #168]	; (8003128 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb4>)
 800307e:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8003082:	46ac      	mov	ip, r5
 8003084:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003088:	6020      	str	r0, [r4, #0]
 800308a:	6061      	str	r1, [r4, #4]
 800308c:	60a2      	str	r2, [r4, #8]
 800308e:	60e3      	str	r3, [r4, #12]
 8003090:	4665      	mov	r5, ip
 8003092:	3410      	adds	r4, #16
 8003094:	45f4      	cmp	ip, lr
 8003096:	d1f4      	bne.n	8003082 <fCmdBuild_SOCKETCMD_ACTIVATE+0xe>
 8003098:	f8bc 2000 	ldrh.w	r2, [ip]
 800309c:	f89c 3002 	ldrb.w	r3, [ip, #2]
 80030a0:	8022      	strh	r2, [r4, #0]
 80030a2:	70a3      	strb	r3, [r4, #2]
 80030a4:	4c20      	ldr	r4, [pc, #128]	; (8003128 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb4>)
 80030a6:	4620      	mov	r0, r4
 80030a8:	f01c f833 	bl	801f112 <crs_strlen>
 80030ac:	b283      	uxth	r3, r0
 80030ae:	4622      	mov	r2, r4
 80030b0:	2104      	movs	r1, #4
 80030b2:	2002      	movs	r0, #2
 80030b4:	f01c f870 	bl	801f198 <traceIF_itmPrint>
 80030b8:	4620      	mov	r0, r4
 80030ba:	f01c f82a 	bl	801f112 <crs_strlen>
 80030be:	b283      	uxth	r3, r0
 80030c0:	4622      	mov	r2, r4
 80030c2:	2104      	movs	r1, #4
 80030c4:	2002      	movs	r0, #2
 80030c6:	f01c f889 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80030ca:	8933      	ldrh	r3, [r6, #8]
 80030cc:	2b03      	cmp	r3, #3
 80030ce:	d001      	beq.n	80030d4 <fCmdBuild_SOCKETCMD_ACTIVATE+0x60>
}
 80030d0:	2000      	movs	r0, #0
 80030d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 80030d4:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 80030d8:	b15b      	cbz	r3, 80030f2 <fCmdBuild_SOCKETCMD_ACTIVATE+0x7e>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 80030da:	6819      	ldr	r1, [r3, #0]
 80030dc:	4638      	mov	r0, r7
 80030de:	f011 f845 	bl	801416c <atcm_socket_get_modem_cid>
 80030e2:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 80030e4:	4a11      	ldr	r2, [pc, #68]	; (800312c <fCmdBuild_SOCKETCMD_ACTIVATE+0xb8>)
 80030e6:	4912      	ldr	r1, [pc, #72]	; (8003130 <fCmdBuild_SOCKETCMD_ACTIVATE+0xbc>)
 80030e8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80030ec:	f022 fdc0 	bl	8025c70 <sprintf>
 80030f0:	e7ee      	b.n	80030d0 <fCmdBuild_SOCKETCMD_ACTIVATE+0x5c>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_ACTIVATE")
 80030f2:	4c0d      	ldr	r4, [pc, #52]	; (8003128 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb4>)
 80030f4:	2243      	movs	r2, #67	; 0x43
 80030f6:	490f      	ldr	r1, [pc, #60]	; (8003134 <fCmdBuild_SOCKETCMD_ACTIVATE+0xc0>)
 80030f8:	4620      	mov	r0, r4
 80030fa:	f022 ff09 	bl	8025f10 <memcpy>
 80030fe:	4620      	mov	r0, r4
 8003100:	f01c f807 	bl	801f112 <crs_strlen>
 8003104:	b283      	uxth	r3, r0
 8003106:	4622      	mov	r2, r4
 8003108:	2110      	movs	r1, #16
 800310a:	2002      	movs	r0, #2
 800310c:	f01c f844 	bl	801f198 <traceIF_itmPrint>
 8003110:	4620      	mov	r0, r4
 8003112:	f01b fffe 	bl	801f112 <crs_strlen>
 8003116:	b283      	uxth	r3, r0
 8003118:	4622      	mov	r2, r4
 800311a:	2110      	movs	r1, #16
 800311c:	2002      	movs	r0, #2
 800311e:	f01c f85d 	bl	801f1dc <traceIF_uartPrint>
 8003122:	e7d5      	b.n	80030d0 <fCmdBuild_SOCKETCMD_ACTIVATE+0x5c>
 8003124:	0802ad20 	.word	0x0802ad20
 8003128:	200048dc 	.word	0x200048dc
 800312c:	0802ad54 	.word	0x0802ad54
 8003130:	0802ad60 	.word	0x0802ad60
 8003134:	0802ad6c 	.word	0x0802ad6c

08003138 <fCmdBuild_SOCKETCMD_INFO>:
{
 8003138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800313a:	4606      	mov	r6, r0
 800313c:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_INFO()")
 800313e:	4c35      	ldr	r4, [pc, #212]	; (8003214 <fCmdBuild_SOCKETCMD_INFO+0xdc>)
 8003140:	4d35      	ldr	r5, [pc, #212]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 8003142:	f104 0e20 	add.w	lr, r4, #32
 8003146:	46a4      	mov	ip, r4
 8003148:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800314c:	6028      	str	r0, [r5, #0]
 800314e:	6069      	str	r1, [r5, #4]
 8003150:	60aa      	str	r2, [r5, #8]
 8003152:	60eb      	str	r3, [r5, #12]
 8003154:	4664      	mov	r4, ip
 8003156:	3510      	adds	r5, #16
 8003158:	45f4      	cmp	ip, lr
 800315a:	d1f4      	bne.n	8003146 <fCmdBuild_SOCKETCMD_INFO+0xe>
 800315c:	4663      	mov	r3, ip
 800315e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8003160:	6028      	str	r0, [r5, #0]
 8003162:	6069      	str	r1, [r5, #4]
 8003164:	60aa      	str	r2, [r5, #8]
 8003166:	881a      	ldrh	r2, [r3, #0]
 8003168:	789b      	ldrb	r3, [r3, #2]
 800316a:	81aa      	strh	r2, [r5, #12]
 800316c:	73ab      	strb	r3, [r5, #14]
 800316e:	4c2a      	ldr	r4, [pc, #168]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 8003170:	4620      	mov	r0, r4
 8003172:	f01b ffce 	bl	801f112 <crs_strlen>
 8003176:	b283      	uxth	r3, r0
 8003178:	4622      	mov	r2, r4
 800317a:	2104      	movs	r1, #4
 800317c:	2002      	movs	r0, #2
 800317e:	f01c f80b 	bl	801f198 <traceIF_itmPrint>
 8003182:	4620      	mov	r0, r4
 8003184:	f01b ffc5 	bl	801f112 <crs_strlen>
 8003188:	b283      	uxth	r3, r0
 800318a:	4622      	mov	r2, r4
 800318c:	2104      	movs	r1, #4
 800318e:	2002      	movs	r0, #2
 8003190:	f01c f824 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8003194:	8933      	ldrh	r3, [r6, #8]
 8003196:	2b03      	cmp	r3, #3
 8003198:	d001      	beq.n	800319e <fCmdBuild_SOCKETCMD_INFO+0x66>
}
 800319a:	2000      	movs	r0, #0
 800319c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 800319e:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 80031a2:	b16b      	cbz	r3, 80031c0 <fCmdBuild_SOCKETCMD_INFO+0x88>
                                                    p_modem_ctxt->socket_ctxt.socket_cnx_infos->socket_handle);
 80031a4:	f8d7 37a8 	ldr.w	r3, [r7, #1960]	; 0x7a8
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 80031a8:	6819      	ldr	r1, [r3, #0]
 80031aa:	4638      	mov	r0, r7
 80031ac:	f010 ffde 	bl	801416c <atcm_socket_get_modem_cid>
 80031b0:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 80031b2:	4a1a      	ldr	r2, [pc, #104]	; (800321c <fCmdBuild_SOCKETCMD_INFO+0xe4>)
 80031b4:	491a      	ldr	r1, [pc, #104]	; (8003220 <fCmdBuild_SOCKETCMD_INFO+0xe8>)
 80031b6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80031ba:	f022 fd59 	bl	8025c70 <sprintf>
 80031be:	e7ec      	b.n	800319a <fCmdBuild_SOCKETCMD_INFO+0x62>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_INFO")
 80031c0:	4d18      	ldr	r5, [pc, #96]	; (8003224 <fCmdBuild_SOCKETCMD_INFO+0xec>)
 80031c2:	4c15      	ldr	r4, [pc, #84]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 80031c4:	f105 0730 	add.w	r7, r5, #48	; 0x30
 80031c8:	462e      	mov	r6, r5
 80031ca:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80031cc:	6020      	str	r0, [r4, #0]
 80031ce:	6061      	str	r1, [r4, #4]
 80031d0:	60a2      	str	r2, [r4, #8]
 80031d2:	60e3      	str	r3, [r4, #12]
 80031d4:	4635      	mov	r5, r6
 80031d6:	3410      	adds	r4, #16
 80031d8:	42be      	cmp	r6, r7
 80031da:	d1f5      	bne.n	80031c8 <fCmdBuild_SOCKETCMD_INFO+0x90>
 80031dc:	cd07      	ldmia	r5!, {r0, r1, r2}
 80031de:	6020      	str	r0, [r4, #0]
 80031e0:	6061      	str	r1, [r4, #4]
 80031e2:	60a2      	str	r2, [r4, #8]
 80031e4:	882a      	ldrh	r2, [r5, #0]
 80031e6:	78ab      	ldrb	r3, [r5, #2]
 80031e8:	81a2      	strh	r2, [r4, #12]
 80031ea:	73a3      	strb	r3, [r4, #14]
 80031ec:	4c0a      	ldr	r4, [pc, #40]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 80031ee:	4620      	mov	r0, r4
 80031f0:	f01b ff8f 	bl	801f112 <crs_strlen>
 80031f4:	b283      	uxth	r3, r0
 80031f6:	4622      	mov	r2, r4
 80031f8:	2110      	movs	r1, #16
 80031fa:	2002      	movs	r0, #2
 80031fc:	f01b ffcc 	bl	801f198 <traceIF_itmPrint>
 8003200:	4620      	mov	r0, r4
 8003202:	f01b ff86 	bl	801f112 <crs_strlen>
 8003206:	b283      	uxth	r3, r0
 8003208:	4622      	mov	r2, r4
 800320a:	2110      	movs	r1, #16
 800320c:	2002      	movs	r0, #2
 800320e:	f01b ffe5 	bl	801f1dc <traceIF_uartPrint>
 8003212:	e7c2      	b.n	800319a <fCmdBuild_SOCKETCMD_INFO+0x62>
 8003214:	0802adb0 	.word	0x0802adb0
 8003218:	200048dc 	.word	0x200048dc
 800321c:	0802ade0 	.word	0x0802ade0
 8003220:	0802ad60 	.word	0x0802ad60
 8003224:	0802ade8 	.word	0x0802ade8

08003228 <fCmdBuild_SOCKETCMD_DEACTIVATE>:
{
 8003228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800322a:	4606      	mov	r6, r0
 800322c:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_DEACTIVATE()")
 800322e:	4d2a      	ldr	r5, [pc, #168]	; (80032d8 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb0>)
 8003230:	4c2a      	ldr	r4, [pc, #168]	; (80032dc <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb4>)
 8003232:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8003236:	46ac      	mov	ip, r5
 8003238:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800323c:	6020      	str	r0, [r4, #0]
 800323e:	6061      	str	r1, [r4, #4]
 8003240:	60a2      	str	r2, [r4, #8]
 8003242:	60e3      	str	r3, [r4, #12]
 8003244:	4665      	mov	r5, ip
 8003246:	3410      	adds	r4, #16
 8003248:	45f4      	cmp	ip, lr
 800324a:	d1f4      	bne.n	8003236 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xe>
 800324c:	f8dc 0000 	ldr.w	r0, [ip]
 8003250:	6020      	str	r0, [r4, #0]
 8003252:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8003256:	7123      	strb	r3, [r4, #4]
 8003258:	4c20      	ldr	r4, [pc, #128]	; (80032dc <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb4>)
 800325a:	4620      	mov	r0, r4
 800325c:	f01b ff59 	bl	801f112 <crs_strlen>
 8003260:	b283      	uxth	r3, r0
 8003262:	4622      	mov	r2, r4
 8003264:	2104      	movs	r1, #4
 8003266:	2002      	movs	r0, #2
 8003268:	f01b ff96 	bl	801f198 <traceIF_itmPrint>
 800326c:	4620      	mov	r0, r4
 800326e:	f01b ff50 	bl	801f112 <crs_strlen>
 8003272:	b283      	uxth	r3, r0
 8003274:	4622      	mov	r2, r4
 8003276:	2104      	movs	r1, #4
 8003278:	2002      	movs	r0, #2
 800327a:	f01b ffaf 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800327e:	8933      	ldrh	r3, [r6, #8]
 8003280:	2b03      	cmp	r3, #3
 8003282:	d001      	beq.n	8003288 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x60>
}
 8003284:	2000      	movs	r0, #0
 8003286:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 8003288:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 800328c:	b15b      	cbz	r3, 80032a6 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x7e>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 800328e:	6819      	ldr	r1, [r3, #0]
 8003290:	4638      	mov	r0, r7
 8003292:	f010 ff6b 	bl	801416c <atcm_socket_get_modem_cid>
 8003296:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 8003298:	4a11      	ldr	r2, [pc, #68]	; (80032e0 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb8>)
 800329a:	4912      	ldr	r1, [pc, #72]	; (80032e4 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xbc>)
 800329c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80032a0:	f022 fce6 	bl	8025c70 <sprintf>
 80032a4:	e7ee      	b.n	8003284 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x5c>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_DEACTIVATE")
 80032a6:	4c0d      	ldr	r4, [pc, #52]	; (80032dc <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb4>)
 80032a8:	2245      	movs	r2, #69	; 0x45
 80032aa:	490f      	ldr	r1, [pc, #60]	; (80032e8 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xc0>)
 80032ac:	4620      	mov	r0, r4
 80032ae:	f022 fe2f 	bl	8025f10 <memcpy>
 80032b2:	4620      	mov	r0, r4
 80032b4:	f01b ff2d 	bl	801f112 <crs_strlen>
 80032b8:	b283      	uxth	r3, r0
 80032ba:	4622      	mov	r2, r4
 80032bc:	2110      	movs	r1, #16
 80032be:	2002      	movs	r0, #2
 80032c0:	f01b ff6a 	bl	801f198 <traceIF_itmPrint>
 80032c4:	4620      	mov	r0, r4
 80032c6:	f01b ff24 	bl	801f112 <crs_strlen>
 80032ca:	b283      	uxth	r3, r0
 80032cc:	4622      	mov	r2, r4
 80032ce:	2110      	movs	r1, #16
 80032d0:	2002      	movs	r0, #2
 80032d2:	f01b ff83 	bl	801f1dc <traceIF_uartPrint>
 80032d6:	e7d5      	b.n	8003284 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x5c>
 80032d8:	0802ae28 	.word	0x0802ae28
 80032dc:	200048dc 	.word	0x200048dc
 80032e0:	0802ae60 	.word	0x0802ae60
 80032e4:	0802ad60 	.word	0x0802ad60
 80032e8:	0802ae6c 	.word	0x0802ae6c

080032ec <fCmdBuild_SOCKETCMD_DELETE>:
{
 80032ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80032ee:	4606      	mov	r6, r0
 80032f0:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_DELETE()")
 80032f2:	4d29      	ldr	r5, [pc, #164]	; (8003398 <fCmdBuild_SOCKETCMD_DELETE+0xac>)
 80032f4:	4c29      	ldr	r4, [pc, #164]	; (800339c <fCmdBuild_SOCKETCMD_DELETE+0xb0>)
 80032f6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80032fa:	46ac      	mov	ip, r5
 80032fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003300:	6020      	str	r0, [r4, #0]
 8003302:	6061      	str	r1, [r4, #4]
 8003304:	60a2      	str	r2, [r4, #8]
 8003306:	60e3      	str	r3, [r4, #12]
 8003308:	4665      	mov	r5, ip
 800330a:	3410      	adds	r4, #16
 800330c:	45f4      	cmp	ip, lr
 800330e:	d1f4      	bne.n	80032fa <fCmdBuild_SOCKETCMD_DELETE+0xe>
 8003310:	f89c 3000 	ldrb.w	r3, [ip]
 8003314:	7023      	strb	r3, [r4, #0]
 8003316:	4c21      	ldr	r4, [pc, #132]	; (800339c <fCmdBuild_SOCKETCMD_DELETE+0xb0>)
 8003318:	4620      	mov	r0, r4
 800331a:	f01b fefa 	bl	801f112 <crs_strlen>
 800331e:	b283      	uxth	r3, r0
 8003320:	4622      	mov	r2, r4
 8003322:	2104      	movs	r1, #4
 8003324:	2002      	movs	r0, #2
 8003326:	f01b ff37 	bl	801f198 <traceIF_itmPrint>
 800332a:	4620      	mov	r0, r4
 800332c:	f01b fef1 	bl	801f112 <crs_strlen>
 8003330:	b283      	uxth	r3, r0
 8003332:	4622      	mov	r2, r4
 8003334:	2104      	movs	r1, #4
 8003336:	2002      	movs	r0, #2
 8003338:	f01b ff50 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800333c:	8933      	ldrh	r3, [r6, #8]
 800333e:	2b03      	cmp	r3, #3
 8003340:	d001      	beq.n	8003346 <fCmdBuild_SOCKETCMD_DELETE+0x5a>
}
 8003342:	2000      	movs	r0, #0
 8003344:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 8003346:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 800334a:	b15b      	cbz	r3, 8003364 <fCmdBuild_SOCKETCMD_DELETE+0x78>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 800334c:	6819      	ldr	r1, [r3, #0]
 800334e:	4638      	mov	r0, r7
 8003350:	f010 ff0c 	bl	801416c <atcm_socket_get_modem_cid>
 8003354:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 8003356:	4a12      	ldr	r2, [pc, #72]	; (80033a0 <fCmdBuild_SOCKETCMD_DELETE+0xb4>)
 8003358:	4912      	ldr	r1, [pc, #72]	; (80033a4 <fCmdBuild_SOCKETCMD_DELETE+0xb8>)
 800335a:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800335e:	f022 fc87 	bl	8025c70 <sprintf>
 8003362:	e7ee      	b.n	8003342 <fCmdBuild_SOCKETCMD_DELETE+0x56>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_DELETE")
 8003364:	4c0d      	ldr	r4, [pc, #52]	; (800339c <fCmdBuild_SOCKETCMD_DELETE+0xb0>)
 8003366:	2241      	movs	r2, #65	; 0x41
 8003368:	490f      	ldr	r1, [pc, #60]	; (80033a8 <fCmdBuild_SOCKETCMD_DELETE+0xbc>)
 800336a:	4620      	mov	r0, r4
 800336c:	f022 fdd0 	bl	8025f10 <memcpy>
 8003370:	4620      	mov	r0, r4
 8003372:	f01b fece 	bl	801f112 <crs_strlen>
 8003376:	b283      	uxth	r3, r0
 8003378:	4622      	mov	r2, r4
 800337a:	2110      	movs	r1, #16
 800337c:	2002      	movs	r0, #2
 800337e:	f01b ff0b 	bl	801f198 <traceIF_itmPrint>
 8003382:	4620      	mov	r0, r4
 8003384:	f01b fec5 	bl	801f112 <crs_strlen>
 8003388:	b283      	uxth	r3, r0
 800338a:	4622      	mov	r2, r4
 800338c:	2110      	movs	r1, #16
 800338e:	2002      	movs	r0, #2
 8003390:	f01b ff24 	bl	801f1dc <traceIF_uartPrint>
 8003394:	e7d5      	b.n	8003342 <fCmdBuild_SOCKETCMD_DELETE+0x56>
 8003396:	bf00      	nop
 8003398:	0802aeb4 	.word	0x0802aeb4
 800339c:	200048dc 	.word	0x200048dc
 80033a0:	0802aee8 	.word	0x0802aee8
 80033a4:	0802ad60 	.word	0x0802ad60
 80033a8:	0802aef0 	.word	0x0802aef0

080033ac <fCmdBuild_SOCKETDATA_SEND>:
{
 80033ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80033b0:	b085      	sub	sp, #20
 80033b2:	4605      	mov	r5, r0
 80033b4:	460e      	mov	r6, r1
  PRINT_API("enter fCmdBuild_SOCKETDATA_SEND()")
 80033b6:	f8df c18c 	ldr.w	ip, [pc, #396]	; 8003544 <fCmdBuild_SOCKETDATA_SEND+0x198>
 80033ba:	4f5d      	ldr	r7, [pc, #372]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 80033bc:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 80033c0:	4664      	mov	r4, ip
 80033c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80033c4:	6038      	str	r0, [r7, #0]
 80033c6:	6079      	str	r1, [r7, #4]
 80033c8:	60ba      	str	r2, [r7, #8]
 80033ca:	60fb      	str	r3, [r7, #12]
 80033cc:	46a4      	mov	ip, r4
 80033ce:	3710      	adds	r7, #16
 80033d0:	4574      	cmp	r4, lr
 80033d2:	d1f5      	bne.n	80033c0 <fCmdBuild_SOCKETDATA_SEND+0x14>
 80033d4:	4c56      	ldr	r4, [pc, #344]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 80033d6:	4620      	mov	r0, r4
 80033d8:	f01b fe9b 	bl	801f112 <crs_strlen>
 80033dc:	b283      	uxth	r3, r0
 80033de:	4622      	mov	r2, r4
 80033e0:	2104      	movs	r1, #4
 80033e2:	2002      	movs	r0, #2
 80033e4:	f01b fed8 	bl	801f198 <traceIF_itmPrint>
 80033e8:	4620      	mov	r0, r4
 80033ea:	f01b fe92 	bl	801f112 <crs_strlen>
 80033ee:	b283      	uxth	r3, r0
 80033f0:	4622      	mov	r2, r4
 80033f2:	2104      	movs	r1, #4
 80033f4:	2002      	movs	r0, #2
 80033f6:	f01b fef1 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80033fa:	892b      	ldrh	r3, [r5, #8]
 80033fc:	2b03      	cmp	r3, #3
 80033fe:	d003      	beq.n	8003408 <fCmdBuild_SOCKETDATA_SEND+0x5c>
  at_status_t retval = ATSTATUS_OK;
 8003400:	2000      	movs	r0, #0
}
 8003402:	b005      	add	sp, #20
 8003404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p_modem_ctxt->SID_ctxt.socketSendData_struct.p_buffer_addr_send != NULL)
 8003408:	f8d6 3674 	ldr.w	r3, [r6, #1652]	; 0x674
 800340c:	2b00      	cmp	r3, #0
 800340e:	d067      	beq.n	80034e0 <fCmdBuild_SOCKETDATA_SEND+0x134>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 8003410:	f8d6 1670 	ldr.w	r1, [r6, #1648]	; 0x670
 8003414:	4630      	mov	r0, r6
 8003416:	f010 fea9 	bl	801416c <atcm_socket_get_modem_cid>
 800341a:	4602      	mov	r2, r0
      uint16_t str_size = (uint16_t) p_modem_ctxt->SID_ctxt.socketSendData_struct.buffer_size;
 800341c:	f8b6 767c 	ldrh.w	r7, [r6, #1660]	; 0x67c
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"SEND\",%ld,%d,\"",
 8003420:	f105 0430 	add.w	r4, r5, #48	; 0x30
 8003424:	463b      	mov	r3, r7
 8003426:	4943      	ldr	r1, [pc, #268]	; (8003534 <fCmdBuild_SOCKETDATA_SEND+0x188>)
 8003428:	4620      	mov	r0, r4
 800342a:	f022 fc21 	bl	8025c70 <sprintf>
      uint16_t cmd_params_size = (uint16_t) strlen((CRC_CHAR_t *)&p_atp_ctxt->current_atcmd.params);
 800342e:	4620      	mov	r0, r4
 8003430:	f7fc fee0 	bl	80001f4 <strlen>
 8003434:	4680      	mov	r8, r0
 8003436:	fa1f f980 	uxth.w	r9, r0
      for (uint16_t idx = 0U; idx < str_size; idx++)
 800343a:	2400      	movs	r4, #0
 800343c:	e037      	b.n	80034ae <fCmdBuild_SOCKETDATA_SEND+0x102>
        uint8_t onechar = p_modem_ctxt->SID_ctxt.socketSendData_struct.p_buffer_addr_send[idx];
 800343e:	f8d6 3674 	ldr.w	r3, [r6, #1652]	; 0x674
 8003442:	f813 b004 	ldrb.w	fp, [r3, r4]
        PRINT_DBG("[ %c -> HEX= %2x / DEC= %2d]", onechar, onechar, onechar)
 8003446:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>
 800344a:	f8cd b000 	str.w	fp, [sp]
 800344e:	465b      	mov	r3, fp
 8003450:	465a      	mov	r2, fp
 8003452:	4939      	ldr	r1, [pc, #228]	; (8003538 <fCmdBuild_SOCKETDATA_SEND+0x18c>)
 8003454:	4650      	mov	r0, sl
 8003456:	f022 fc0b 	bl	8025c70 <sprintf>
 800345a:	4650      	mov	r0, sl
 800345c:	f01b fe59 	bl	801f112 <crs_strlen>
 8003460:	b283      	uxth	r3, r0
 8003462:	4652      	mov	r2, sl
 8003464:	2102      	movs	r1, #2
 8003466:	4608      	mov	r0, r1
 8003468:	f01b fe96 	bl	801f198 <traceIF_itmPrint>
 800346c:	4650      	mov	r0, sl
 800346e:	f01b fe50 	bl	801f112 <crs_strlen>
 8003472:	b283      	uxth	r3, r0
 8003474:	4652      	mov	r2, sl
 8003476:	2102      	movs	r1, #2
 8003478:	4608      	mov	r0, r1
 800347a:	f01b feaf 	bl	801f1dc <traceIF_uartPrint>
        convertCharToHEX(onechar, &ms, &ls);
 800347e:	f10d 020f 	add.w	r2, sp, #15
 8003482:	f10d 010e 	add.w	r1, sp, #14
 8003486:	4658      	mov	r0, fp
 8003488:	f7ff fc64 	bl	8002d54 <convertCharToHEX>
        (void) memcpy((void *) &p_atp_ctxt->current_atcmd.params[cmd_params_size + (2U * idx)],
 800348c:	fa1f f388 	uxth.w	r3, r8
 8003490:	eb03 0344 	add.w	r3, r3, r4, lsl #1
 8003494:	18ea      	adds	r2, r5, r3
 8003496:	f89d 100e 	ldrb.w	r1, [sp, #14]
 800349a:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
        (void) memcpy((void *) &p_atp_ctxt->current_atcmd.params[cmd_params_size + (1U + (2U * idx))],
 800349e:	3301      	adds	r3, #1
 80034a0:	442b      	add	r3, r5
 80034a2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80034a6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      for (uint16_t idx = 0U; idx < str_size; idx++)
 80034aa:	3401      	adds	r4, #1
 80034ac:	b2a4      	uxth	r4, r4
 80034ae:	42bc      	cmp	r4, r7
 80034b0:	d3c5      	bcc.n	800343e <fCmdBuild_SOCKETDATA_SEND+0x92>
      cmd_params_size += (2U * str_size);
 80034b2:	007b      	lsls	r3, r7, #1
 80034b4:	b29b      	uxth	r3, r3
 80034b6:	444b      	add	r3, r9
 80034b8:	b29b      	uxth	r3, r3
      if (p_modem_ctxt->SID_ctxt.socketSendData_struct.ip_addr_type != CS_IPAT_INVALID)
 80034ba:	f896 0684 	ldrb.w	r0, [r6, #1668]	; 0x684
 80034be:	b158      	cbz	r0, 80034d8 <fCmdBuild_SOCKETDATA_SEND+0x12c>
        (void) sprintf((CRC_CHAR_t *)(&(p_atp_ctxt->current_atcmd.params[cmd_params_size])),
 80034c0:	f103 0030 	add.w	r0, r3, #48	; 0x30
 80034c4:	f8b6 36c6 	ldrh.w	r3, [r6, #1734]	; 0x6c6
 80034c8:	f206 6285 	addw	r2, r6, #1669	; 0x685
 80034cc:	491b      	ldr	r1, [pc, #108]	; (800353c <fCmdBuild_SOCKETDATA_SEND+0x190>)
 80034ce:	4428      	add	r0, r5
 80034d0:	f022 fbce 	bl	8025c70 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 80034d4:	2000      	movs	r0, #0
 80034d6:	e794      	b.n	8003402 <fCmdBuild_SOCKETDATA_SEND+0x56>
        (void) memcpy((void *) &p_atp_ctxt->current_atcmd.params[cmd_params_size],
 80034d8:	3330      	adds	r3, #48	; 0x30
 80034da:	2222      	movs	r2, #34	; 0x22
 80034dc:	54ea      	strb	r2, [r5, r3]
 80034de:	e790      	b.n	8003402 <fCmdBuild_SOCKETDATA_SEND+0x56>
      PRINT_ERR("ERROR, send buffer is a NULL ptr !!!")
 80034e0:	4e17      	ldr	r6, [pc, #92]	; (8003540 <fCmdBuild_SOCKETDATA_SEND+0x194>)
 80034e2:	4c13      	ldr	r4, [pc, #76]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 80034e4:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80034e8:	4635      	mov	r5, r6
 80034ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80034ec:	6020      	str	r0, [r4, #0]
 80034ee:	6061      	str	r1, [r4, #4]
 80034f0:	60a2      	str	r2, [r4, #8]
 80034f2:	60e3      	str	r3, [r4, #12]
 80034f4:	462e      	mov	r6, r5
 80034f6:	3410      	adds	r4, #16
 80034f8:	42bd      	cmp	r5, r7
 80034fa:	d1f5      	bne.n	80034e8 <fCmdBuild_SOCKETDATA_SEND+0x13c>
 80034fc:	6828      	ldr	r0, [r5, #0]
 80034fe:	6020      	str	r0, [r4, #0]
 8003500:	792b      	ldrb	r3, [r5, #4]
 8003502:	7123      	strb	r3, [r4, #4]
 8003504:	4c0a      	ldr	r4, [pc, #40]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 8003506:	4620      	mov	r0, r4
 8003508:	f01b fe03 	bl	801f112 <crs_strlen>
 800350c:	b283      	uxth	r3, r0
 800350e:	4622      	mov	r2, r4
 8003510:	2110      	movs	r1, #16
 8003512:	2002      	movs	r0, #2
 8003514:	f01b fe40 	bl	801f198 <traceIF_itmPrint>
 8003518:	4620      	mov	r0, r4
 800351a:	f01b fdfa 	bl	801f112 <crs_strlen>
 800351e:	b283      	uxth	r3, r0
 8003520:	4622      	mov	r2, r4
 8003522:	2110      	movs	r1, #16
 8003524:	2002      	movs	r0, #2
 8003526:	f01b fe59 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800352a:	2001      	movs	r0, #1
 800352c:	e769      	b.n	8003402 <fCmdBuild_SOCKETDATA_SEND+0x56>
 800352e:	bf00      	nop
 8003530:	200048dc 	.word	0x200048dc
 8003534:	0802af64 	.word	0x0802af64
 8003538:	0802af74 	.word	0x0802af74
 800353c:	0802af9c 	.word	0x0802af9c
 8003540:	0802afa8 	.word	0x0802afa8
 8003544:	0802af34 	.word	0x0802af34

08003548 <fCmdBuild_SOCKETDATA_RECEIVE>:
{
 8003548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800354a:	4606      	mov	r6, r0
 800354c:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETDATA_RECEIVE()")
 800354e:	4d1d      	ldr	r5, [pc, #116]	; (80035c4 <fCmdBuild_SOCKETDATA_RECEIVE+0x7c>)
 8003550:	4c1d      	ldr	r4, [pc, #116]	; (80035c8 <fCmdBuild_SOCKETDATA_RECEIVE+0x80>)
 8003552:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8003556:	46ac      	mov	ip, r5
 8003558:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800355c:	6020      	str	r0, [r4, #0]
 800355e:	6061      	str	r1, [r4, #4]
 8003560:	60a2      	str	r2, [r4, #8]
 8003562:	60e3      	str	r3, [r4, #12]
 8003564:	4665      	mov	r5, ip
 8003566:	3410      	adds	r4, #16
 8003568:	45f4      	cmp	ip, lr
 800356a:	d1f4      	bne.n	8003556 <fCmdBuild_SOCKETDATA_RECEIVE+0xe>
 800356c:	f8bc 2000 	ldrh.w	r2, [ip]
 8003570:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8003574:	8022      	strh	r2, [r4, #0]
 8003576:	70a3      	strb	r3, [r4, #2]
 8003578:	4c13      	ldr	r4, [pc, #76]	; (80035c8 <fCmdBuild_SOCKETDATA_RECEIVE+0x80>)
 800357a:	4620      	mov	r0, r4
 800357c:	f01b fdc9 	bl	801f112 <crs_strlen>
 8003580:	b283      	uxth	r3, r0
 8003582:	4622      	mov	r2, r4
 8003584:	2104      	movs	r1, #4
 8003586:	2002      	movs	r0, #2
 8003588:	f01b fe06 	bl	801f198 <traceIF_itmPrint>
 800358c:	4620      	mov	r0, r4
 800358e:	f01b fdc0 	bl	801f112 <crs_strlen>
 8003592:	b283      	uxth	r3, r0
 8003594:	4622      	mov	r2, r4
 8003596:	2104      	movs	r1, #4
 8003598:	2002      	movs	r0, #2
 800359a:	f01b fe1f 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800359e:	8933      	ldrh	r3, [r6, #8]
 80035a0:	2b03      	cmp	r3, #3
 80035a2:	d001      	beq.n	80035a8 <fCmdBuild_SOCKETDATA_RECEIVE+0x60>
}
 80035a4:	2000      	movs	r0, #0
 80035a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 80035a8:	f8d7 1744 	ldr.w	r1, [r7, #1860]	; 0x744
 80035ac:	4638      	mov	r0, r7
 80035ae:	f010 fddd 	bl	801416c <atcm_socket_get_modem_cid>
 80035b2:	4602      	mov	r2, r0
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"RECEIVE\",%ld,%ld",
 80035b4:	f8d7 3754 	ldr.w	r3, [r7, #1876]	; 0x754
 80035b8:	4904      	ldr	r1, [pc, #16]	; (80035cc <fCmdBuild_SOCKETDATA_RECEIVE+0x84>)
 80035ba:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80035be:	f022 fb57 	bl	8025c70 <sprintf>
 80035c2:	e7ef      	b.n	80035a4 <fCmdBuild_SOCKETDATA_RECEIVE+0x5c>
 80035c4:	0802afe0 	.word	0x0802afe0
 80035c8:	200048dc 	.word	0x200048dc
 80035cc:	0802b014 	.word	0x0802b014

080035d0 <fCmdBuild_DNSRSLV>:
{
 80035d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80035d2:	4606      	mov	r6, r0
 80035d4:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_DNSRSLV()")
 80035d6:	4c1e      	ldr	r4, [pc, #120]	; (8003650 <fCmdBuild_DNSRSLV+0x80>)
 80035d8:	4d1e      	ldr	r5, [pc, #120]	; (8003654 <fCmdBuild_DNSRSLV+0x84>)
 80035da:	f104 0e20 	add.w	lr, r4, #32
 80035de:	46a4      	mov	ip, r4
 80035e0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80035e4:	6028      	str	r0, [r5, #0]
 80035e6:	6069      	str	r1, [r5, #4]
 80035e8:	60aa      	str	r2, [r5, #8]
 80035ea:	60eb      	str	r3, [r5, #12]
 80035ec:	4664      	mov	r4, ip
 80035ee:	3510      	adds	r5, #16
 80035f0:	45f4      	cmp	ip, lr
 80035f2:	d1f4      	bne.n	80035de <fCmdBuild_DNSRSLV+0xe>
 80035f4:	cc03      	ldmia	r4!, {r0, r1}
 80035f6:	6028      	str	r0, [r5, #0]
 80035f8:	6069      	str	r1, [r5, #4]
 80035fa:	4c16      	ldr	r4, [pc, #88]	; (8003654 <fCmdBuild_DNSRSLV+0x84>)
 80035fc:	4620      	mov	r0, r4
 80035fe:	f01b fd88 	bl	801f112 <crs_strlen>
 8003602:	b283      	uxth	r3, r0
 8003604:	4622      	mov	r2, r4
 8003606:	2104      	movs	r1, #4
 8003608:	2002      	movs	r0, #2
 800360a:	f01b fdc5 	bl	801f198 <traceIF_itmPrint>
 800360e:	4620      	mov	r0, r4
 8003610:	f01b fd7f 	bl	801f112 <crs_strlen>
 8003614:	b283      	uxth	r3, r0
 8003616:	4622      	mov	r2, r4
 8003618:	2104      	movs	r1, #4
 800361a:	2002      	movs	r0, #2
 800361c:	f01b fdde 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8003620:	8933      	ldrh	r3, [r6, #8]
 8003622:	2b03      	cmp	r3, #3
 8003624:	d001      	beq.n	800362a <fCmdBuild_DNSRSLV+0x5a>
}
 8003626:	2000      	movs	r0, #0
 8003628:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800362a:	4638      	mov	r0, r7
 800362c:	f009 f942 	bl	800c8b4 <atcm_get_cid_current_SID>
 8003630:	4601      	mov	r1, r0
    uint8_t pdp_modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 8003632:	f107 000c 	add.w	r0, r7, #12
 8003636:	f00a f9c5 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800363a:	4602      	mov	r2, r0
                   p_modem_ctxt->SID_ctxt.dns_request_infos->dns_req.host_name);
 800363c:	f8d7 36cc 	ldr.w	r3, [r7, #1740]	; 0x6cc
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\"",
 8003640:	3341      	adds	r3, #65	; 0x41
 8003642:	4905      	ldr	r1, [pc, #20]	; (8003658 <fCmdBuild_DNSRSLV+0x88>)
 8003644:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8003648:	f022 fb12 	bl	8025c70 <sprintf>
 800364c:	e7eb      	b.n	8003626 <fCmdBuild_DNSRSLV+0x56>
 800364e:	bf00      	nop
 8003650:	0802b028 	.word	0x0802b028
 8003654:	200048dc 	.word	0x200048dc
 8003658:	0802b050 	.word	0x0802b050

0800365c <fCmdBuild_PINGCMD>:
{
 800365c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800365e:	b085      	sub	sp, #20
 8003660:	4606      	mov	r6, r0
 8003662:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_PINGCMD()")
 8003664:	4c1f      	ldr	r4, [pc, #124]	; (80036e4 <fCmdBuild_PINGCMD+0x88>)
 8003666:	4d20      	ldr	r5, [pc, #128]	; (80036e8 <fCmdBuild_PINGCMD+0x8c>)
 8003668:	f104 0e20 	add.w	lr, r4, #32
 800366c:	46a4      	mov	ip, r4
 800366e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003672:	6028      	str	r0, [r5, #0]
 8003674:	6069      	str	r1, [r5, #4]
 8003676:	60aa      	str	r2, [r5, #8]
 8003678:	60eb      	str	r3, [r5, #12]
 800367a:	4664      	mov	r4, ip
 800367c:	3510      	adds	r5, #16
 800367e:	45f4      	cmp	ip, lr
 8003680:	d1f4      	bne.n	800366c <fCmdBuild_PINGCMD+0x10>
 8003682:	cc03      	ldmia	r4!, {r0, r1}
 8003684:	6028      	str	r0, [r5, #0]
 8003686:	6069      	str	r1, [r5, #4]
 8003688:	4c17      	ldr	r4, [pc, #92]	; (80036e8 <fCmdBuild_PINGCMD+0x8c>)
 800368a:	4620      	mov	r0, r4
 800368c:	f01b fd41 	bl	801f112 <crs_strlen>
 8003690:	b283      	uxth	r3, r0
 8003692:	4622      	mov	r2, r4
 8003694:	2104      	movs	r1, #4
 8003696:	2002      	movs	r0, #2
 8003698:	f01b fd7e 	bl	801f198 <traceIF_itmPrint>
 800369c:	4620      	mov	r0, r4
 800369e:	f01b fd38 	bl	801f112 <crs_strlen>
 80036a2:	b283      	uxth	r3, r0
 80036a4:	4622      	mov	r2, r4
 80036a6:	2104      	movs	r1, #4
 80036a8:	2002      	movs	r0, #2
 80036aa:	f01b fd97 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80036ae:	8933      	ldrh	r3, [r6, #8]
 80036b0:	2b03      	cmp	r3, #3
 80036b2:	d002      	beq.n	80036ba <fCmdBuild_PINGCMD+0x5e>
}
 80036b4:	2000      	movs	r0, #0
 80036b6:	b005      	add	sp, #20
 80036b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    atcm_validate_ping_request(p_modem_ctxt);
 80036ba:	4638      	mov	r0, r7
 80036bc:	f009 fd6f 	bl	800d19e <atcm_validate_ping_request>
                   p_modem_ctxt->SID_ctxt.ping_infos.ping_params.pingnum,
 80036c0:	f897 3712 	ldrb.w	r3, [r7, #1810]	; 0x712
                   p_modem_ctxt->SID_ctxt.ping_infos.ping_params.timeout);
 80036c4:	f897 2711 	ldrb.w	r2, [r7, #1809]	; 0x711
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",%d,%d,%d",
 80036c8:	9202      	str	r2, [sp, #8]
 80036ca:	2238      	movs	r2, #56	; 0x38
 80036cc:	9201      	str	r2, [sp, #4]
 80036ce:	9300      	str	r3, [sp, #0]
 80036d0:	f207 63d1 	addw	r3, r7, #1745	; 0x6d1
 80036d4:	2200      	movs	r2, #0
 80036d6:	4905      	ldr	r1, [pc, #20]	; (80036ec <fCmdBuild_PINGCMD+0x90>)
 80036d8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80036dc:	f022 fac8 	bl	8025c70 <sprintf>
 80036e0:	e7e8      	b.n	80036b4 <fCmdBuild_PINGCMD+0x58>
 80036e2:	bf00      	nop
 80036e4:	0802b058 	.word	0x0802b058
 80036e8:	200048dc 	.word	0x200048dc
 80036ec:	0802b080 	.word	0x0802b080

080036f0 <fRspAnalyze_PDNACT>:
{
 80036f0:	b538      	push	{r3, r4, r5, lr}
  PRINT_API("enter fRspAnalyze_PDNACT()")
 80036f2:	4c14      	ldr	r4, [pc, #80]	; (8003744 <fRspAnalyze_PDNACT+0x54>)
 80036f4:	4d14      	ldr	r5, [pc, #80]	; (8003748 <fRspAnalyze_PDNACT+0x58>)
 80036f6:	f104 0e20 	add.w	lr, r4, #32
 80036fa:	46a4      	mov	ip, r4
 80036fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003700:	6028      	str	r0, [r5, #0]
 8003702:	6069      	str	r1, [r5, #4]
 8003704:	60aa      	str	r2, [r5, #8]
 8003706:	60eb      	str	r3, [r5, #12]
 8003708:	4664      	mov	r4, ip
 800370a:	3510      	adds	r5, #16
 800370c:	45f4      	cmp	ip, lr
 800370e:	d1f4      	bne.n	80036fa <fRspAnalyze_PDNACT+0xa>
 8003710:	cc03      	ldmia	r4!, {r0, r1}
 8003712:	6028      	str	r0, [r5, #0]
 8003714:	6069      	str	r1, [r5, #4]
 8003716:	7823      	ldrb	r3, [r4, #0]
 8003718:	722b      	strb	r3, [r5, #8]
 800371a:	4c0b      	ldr	r4, [pc, #44]	; (8003748 <fRspAnalyze_PDNACT+0x58>)
 800371c:	4620      	mov	r0, r4
 800371e:	f01b fcf8 	bl	801f112 <crs_strlen>
 8003722:	b283      	uxth	r3, r0
 8003724:	4622      	mov	r2, r4
 8003726:	2104      	movs	r1, #4
 8003728:	2002      	movs	r0, #2
 800372a:	f01b fd35 	bl	801f198 <traceIF_itmPrint>
 800372e:	4620      	mov	r0, r4
 8003730:	f01b fcef 	bl	801f112 <crs_strlen>
 8003734:	b283      	uxth	r3, r0
 8003736:	4622      	mov	r2, r4
 8003738:	2104      	movs	r1, #4
 800373a:	2002      	movs	r0, #2
 800373c:	f01b fd4e 	bl	801f1dc <traceIF_uartPrint>
}
 8003740:	2010      	movs	r0, #16
 8003742:	bd38      	pop	{r3, r4, r5, pc}
 8003744:	0802b094 	.word	0x0802b094
 8003748:	200048dc 	.word	0x200048dc

0800374c <fRspAnalyze_SOCKETCMD>:
{
 800374c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003750:	4607      	mov	r7, r0
 8003752:	4689      	mov	r9, r1
 8003754:	4690      	mov	r8, r2
 8003756:	461e      	mov	r6, r3
  PRINT_API("enter fRspAnalyze_SOCKETCMD()")
 8003758:	4cb6      	ldr	r4, [pc, #728]	; (8003a34 <fRspAnalyze_SOCKETCMD+0x2e8>)
 800375a:	4db7      	ldr	r5, [pc, #732]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 800375c:	f104 0e20 	add.w	lr, r4, #32
 8003760:	46a4      	mov	ip, r4
 8003762:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003766:	6028      	str	r0, [r5, #0]
 8003768:	6069      	str	r1, [r5, #4]
 800376a:	60aa      	str	r2, [r5, #8]
 800376c:	60eb      	str	r3, [r5, #12]
 800376e:	4664      	mov	r4, ip
 8003770:	3510      	adds	r5, #16
 8003772:	45f4      	cmp	ip, lr
 8003774:	d1f4      	bne.n	8003760 <fRspAnalyze_SOCKETCMD+0x14>
 8003776:	cc07      	ldmia	r4!, {r0, r1, r2}
 8003778:	6028      	str	r0, [r5, #0]
 800377a:	6069      	str	r1, [r5, #4]
 800377c:	60aa      	str	r2, [r5, #8]
 800377e:	4cae      	ldr	r4, [pc, #696]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 8003780:	4620      	mov	r0, r4
 8003782:	f01b fcc6 	bl	801f112 <crs_strlen>
 8003786:	b283      	uxth	r3, r0
 8003788:	4622      	mov	r2, r4
 800378a:	2104      	movs	r1, #4
 800378c:	2002      	movs	r0, #2
 800378e:	f01b fd03 	bl	801f198 <traceIF_itmPrint>
 8003792:	4620      	mov	r0, r4
 8003794:	f01b fcbd 	bl	801f112 <crs_strlen>
 8003798:	b283      	uxth	r3, r0
 800379a:	4622      	mov	r2, r4
 800379c:	2104      	movs	r1, #4
 800379e:	2002      	movs	r0, #2
 80037a0:	f01b fd1c 	bl	801f1dc <traceIF_uartPrint>
  START_PARAM_LOOP()
 80037a4:	2400      	movs	r4, #0
 80037a6:	4632      	mov	r2, r6
 80037a8:	4641      	mov	r1, r8
 80037aa:	4638      	mov	r0, r7
 80037ac:	f008 fe4c 	bl	800c448 <atcc_extractElement>
 80037b0:	2801      	cmp	r0, #1
 80037b2:	d000      	beq.n	80037b6 <fRspAnalyze_SOCKETCMD+0x6a>
 80037b4:	2401      	movs	r4, #1
 80037b6:	89f1      	ldrh	r1, [r6, #14]
 80037b8:	b191      	cbz	r1, 80037e0 <fRspAnalyze_SOCKETCMD+0x94>
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETCMD_ALLOCATE)
 80037ba:	69fb      	ldr	r3, [r7, #28]
 80037bc:	2b42      	cmp	r3, #66	; 0x42
 80037be:	d00c      	beq.n	80037da <fRspAnalyze_SOCKETCMD+0x8e>
  else if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETCMD_INFO)
 80037c0:	3b44      	subs	r3, #68	; 0x44
 80037c2:	2b06      	cmp	r3, #6
 80037c4:	f200 8111 	bhi.w	80039ea <fRspAnalyze_SOCKETCMD+0x29e>
 80037c8:	e8df f013 	tbh	[pc, r3, lsl #1]
 80037cc:	010f0038 	.word	0x010f0038
 80037d0:	010f00e3 	.word	0x010f00e3
 80037d4:	00e30099 	.word	0x00e30099
 80037d8:	00e3      	.short	0x00e3
    if (element_infos->param_rank == 2U)
 80037da:	8933      	ldrh	r3, [r6, #8]
 80037dc:	2b02      	cmp	r3, #2
 80037de:	d004      	beq.n	80037ea <fRspAnalyze_SOCKETCMD+0x9e>
  END_PARAM_LOOP()
 80037e0:	2c00      	cmp	r4, #0
 80037e2:	d0e0      	beq.n	80037a6 <fRspAnalyze_SOCKETCMD+0x5a>
}
 80037e4:	2010      	movs	r0, #16
 80037e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      uint32_t affected_socket_ID = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80037ea:	8970      	ldrh	r0, [r6, #10]
 80037ec:	4440      	add	r0, r8
 80037ee:	f011 faa1 	bl	8014d34 <ATutil_convertStringToInt>
 80037f2:	4682      	mov	sl, r0
      PRINT_INFO("<affected socket_id> = %ld", affected_socket_ID)
 80037f4:	4d90      	ldr	r5, [pc, #576]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80037f6:	4602      	mov	r2, r0
 80037f8:	4990      	ldr	r1, [pc, #576]	; (8003a3c <fRspAnalyze_SOCKETCMD+0x2f0>)
 80037fa:	4628      	mov	r0, r5
 80037fc:	f022 fa38 	bl	8025c70 <sprintf>
 8003800:	4628      	mov	r0, r5
 8003802:	f01b fc86 	bl	801f112 <crs_strlen>
 8003806:	b283      	uxth	r3, r0
 8003808:	462a      	mov	r2, r5
 800380a:	2101      	movs	r1, #1
 800380c:	2002      	movs	r0, #2
 800380e:	f01b fcc3 	bl	801f198 <traceIF_itmPrint>
 8003812:	4628      	mov	r0, r5
 8003814:	f01b fc7d 	bl	801f112 <crs_strlen>
 8003818:	b283      	uxth	r3, r0
 800381a:	462a      	mov	r2, r5
 800381c:	2101      	movs	r1, #1
 800381e:	2002      	movs	r0, #2
 8003820:	f01b fcdc 	bl	801f1dc <traceIF_uartPrint>
      type1sc_shared.SocketCmd_Allocated_SocketID = AT_TRUE;
 8003824:	4b86      	ldr	r3, [pc, #536]	; (8003a40 <fRspAnalyze_SOCKETCMD+0x2f4>)
 8003826:	2201      	movs	r2, #1
 8003828:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      (void) atcm_socket_set_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle,
 800382c:	f8d9 3740 	ldr.w	r3, [r9, #1856]	; 0x740
 8003830:	4652      	mov	r2, sl
 8003832:	6819      	ldr	r1, [r3, #0]
 8003834:	4648      	mov	r0, r9
 8003836:	f010 fcc1 	bl	80141bc <atcm_socket_set_modem_cid>
 800383a:	e7d1      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    if (element_infos->param_rank == 2U)
 800383c:	8933      	ldrh	r3, [r6, #8]
 800383e:	2b02      	cmp	r3, #2
 8003840:	d0ce      	beq.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    else if (element_infos->param_rank == 3U)
 8003842:	3b04      	subs	r3, #4
 8003844:	2b03      	cmp	r3, #3
 8003846:	d8cb      	bhi.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
 8003848:	e8df f003 	tbb	[pc, r3]
 800384c:	36130a02 	.word	0x36130a02
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003850:	8970      	ldrh	r0, [r6, #10]
                              (uint8_t *)p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->loc_ip_addr_value);
 8003852:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003856:	685a      	ldr	r2, [r3, #4]
 8003858:	4440      	add	r0, r8
 800385a:	f009 f80a 	bl	800c872 <atcm_extract_IP_address>
 800385e:	e7bf      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003860:	8970      	ldrh	r0, [r6, #10]
                              (uint8_t *)p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->rem_ip_addr_value);
 8003862:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
 8003866:	685a      	ldr	r2, [r3, #4]
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003868:	3242      	adds	r2, #66	; 0x42
 800386a:	4440      	add	r0, r8
 800386c:	f009 f801 	bl	800c872 <atcm_extract_IP_address>
 8003870:	e7b6      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      uint32_t src_port = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003872:	8970      	ldrh	r0, [r6, #10]
 8003874:	4440      	add	r0, r8
 8003876:	f011 fa5d 	bl	8014d34 <ATutil_convertStringToInt>
 800387a:	4682      	mov	sl, r0
      PRINT_DBG("<src_port>=%ld", src_port)
 800387c:	4d6e      	ldr	r5, [pc, #440]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 800387e:	4602      	mov	r2, r0
 8003880:	4970      	ldr	r1, [pc, #448]	; (8003a44 <fRspAnalyze_SOCKETCMD+0x2f8>)
 8003882:	4628      	mov	r0, r5
 8003884:	f022 f9f4 	bl	8025c70 <sprintf>
 8003888:	4628      	mov	r0, r5
 800388a:	f01b fc42 	bl	801f112 <crs_strlen>
 800388e:	b283      	uxth	r3, r0
 8003890:	462a      	mov	r2, r5
 8003892:	2102      	movs	r1, #2
 8003894:	4608      	mov	r0, r1
 8003896:	f01b fc7f 	bl	801f198 <traceIF_itmPrint>
 800389a:	4628      	mov	r0, r5
 800389c:	f01b fc39 	bl	801f112 <crs_strlen>
 80038a0:	b283      	uxth	r3, r0
 80038a2:	462a      	mov	r2, r5
 80038a4:	2102      	movs	r1, #2
 80038a6:	4608      	mov	r0, r1
 80038a8:	f01b fc98 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->loc_port = (uint16_t) src_port;
 80038ac:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
 80038b0:	685b      	ldr	r3, [r3, #4]
 80038b2:	f8a3 a040 	strh.w	sl, [r3, #64]	; 0x40
 80038b6:	e793      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      uint32_t dst_port = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80038b8:	8970      	ldrh	r0, [r6, #10]
 80038ba:	4440      	add	r0, r8
 80038bc:	f011 fa3a 	bl	8014d34 <ATutil_convertStringToInt>
 80038c0:	4682      	mov	sl, r0
      PRINT_DBG("<dst_port>=%ld", dst_port)
 80038c2:	4d5d      	ldr	r5, [pc, #372]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80038c4:	4602      	mov	r2, r0
 80038c6:	4960      	ldr	r1, [pc, #384]	; (8003a48 <fRspAnalyze_SOCKETCMD+0x2fc>)
 80038c8:	4628      	mov	r0, r5
 80038ca:	f022 f9d1 	bl	8025c70 <sprintf>
 80038ce:	4628      	mov	r0, r5
 80038d0:	f01b fc1f 	bl	801f112 <crs_strlen>
 80038d4:	b283      	uxth	r3, r0
 80038d6:	462a      	mov	r2, r5
 80038d8:	2102      	movs	r1, #2
 80038da:	4608      	mov	r0, r1
 80038dc:	f01b fc5c 	bl	801f198 <traceIF_itmPrint>
 80038e0:	4628      	mov	r0, r5
 80038e2:	f01b fc16 	bl	801f112 <crs_strlen>
 80038e6:	b283      	uxth	r3, r0
 80038e8:	462a      	mov	r2, r5
 80038ea:	2102      	movs	r1, #2
 80038ec:	4608      	mov	r0, r1
 80038ee:	f01b fc75 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->rem_port = (uint16_t) dst_port;
 80038f2:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
 80038f6:	685b      	ldr	r3, [r3, #4]
 80038f8:	f8a3 a082 	strh.w	sl, [r3, #130]	; 0x82
 80038fc:	e770      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    PRINT_INFO("CMD_AT_SOCKETCMD_LASTERROR")
 80038fe:	f8df e150 	ldr.w	lr, [pc, #336]	; 8003a50 <fRspAnalyze_SOCKETCMD+0x304>
 8003902:	4d4d      	ldr	r5, [pc, #308]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 8003904:	f10e 0a20 	add.w	sl, lr, #32
 8003908:	46f4      	mov	ip, lr
 800390a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800390e:	6028      	str	r0, [r5, #0]
 8003910:	6069      	str	r1, [r5, #4]
 8003912:	60aa      	str	r2, [r5, #8]
 8003914:	60eb      	str	r3, [r5, #12]
 8003916:	46e6      	mov	lr, ip
 8003918:	3510      	adds	r5, #16
 800391a:	45d4      	cmp	ip, sl
 800391c:	d1f4      	bne.n	8003908 <fRspAnalyze_SOCKETCMD+0x1bc>
 800391e:	f8dc 0000 	ldr.w	r0, [ip]
 8003922:	6028      	str	r0, [r5, #0]
 8003924:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8003928:	712b      	strb	r3, [r5, #4]
 800392a:	4d43      	ldr	r5, [pc, #268]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 800392c:	4628      	mov	r0, r5
 800392e:	f01b fbf0 	bl	801f112 <crs_strlen>
 8003932:	b283      	uxth	r3, r0
 8003934:	462a      	mov	r2, r5
 8003936:	2101      	movs	r1, #1
 8003938:	2002      	movs	r0, #2
 800393a:	f01b fc2d 	bl	801f198 <traceIF_itmPrint>
 800393e:	4628      	mov	r0, r5
 8003940:	f01b fbe7 	bl	801f112 <crs_strlen>
 8003944:	b283      	uxth	r3, r0
 8003946:	462a      	mov	r2, r5
 8003948:	2101      	movs	r1, #1
 800394a:	2002      	movs	r0, #2
 800394c:	f01b fc46 	bl	801f1dc <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 8003950:	8933      	ldrh	r3, [r6, #8]
 8003952:	2b02      	cmp	r3, #2
 8003954:	f47f af44 	bne.w	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      PRINT_INFO("<last socket_err> = %ld", ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003958:	8970      	ldrh	r0, [r6, #10]
 800395a:	89f1      	ldrh	r1, [r6, #14]
 800395c:	4440      	add	r0, r8
 800395e:	f011 f9e9 	bl	8014d34 <ATutil_convertStringToInt>
 8003962:	4602      	mov	r2, r0
 8003964:	4939      	ldr	r1, [pc, #228]	; (8003a4c <fRspAnalyze_SOCKETCMD+0x300>)
 8003966:	4628      	mov	r0, r5
 8003968:	f022 f982 	bl	8025c70 <sprintf>
 800396c:	4628      	mov	r0, r5
 800396e:	f01b fbd0 	bl	801f112 <crs_strlen>
 8003972:	b283      	uxth	r3, r0
 8003974:	462a      	mov	r2, r5
 8003976:	2101      	movs	r1, #1
 8003978:	2002      	movs	r0, #2
 800397a:	f01b fc0d 	bl	801f198 <traceIF_itmPrint>
 800397e:	4628      	mov	r0, r5
 8003980:	f01b fbc7 	bl	801f112 <crs_strlen>
 8003984:	b283      	uxth	r3, r0
 8003986:	462a      	mov	r2, r5
 8003988:	2101      	movs	r1, #1
 800398a:	2002      	movs	r0, #2
 800398c:	f01b fc26 	bl	801f1dc <traceIF_uartPrint>
 8003990:	e726      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    PRINT_INFO("analyze of this command not implemented")
 8003992:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 8003a54 <fRspAnalyze_SOCKETCMD+0x308>
 8003996:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>
 800399a:	f10e 0a30 	add.w	sl, lr, #48	; 0x30
 800399e:	4675      	mov	r5, lr
 80039a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80039a2:	f8cc 0000 	str.w	r0, [ip]
 80039a6:	f8cc 1004 	str.w	r1, [ip, #4]
 80039aa:	f8cc 2008 	str.w	r2, [ip, #8]
 80039ae:	f8cc 300c 	str.w	r3, [ip, #12]
 80039b2:	46ae      	mov	lr, r5
 80039b4:	f10c 0c10 	add.w	ip, ip, #16
 80039b8:	4555      	cmp	r5, sl
 80039ba:	d1f0      	bne.n	800399e <fRspAnalyze_SOCKETCMD+0x252>
 80039bc:	882b      	ldrh	r3, [r5, #0]
 80039be:	f8ac 3000 	strh.w	r3, [ip]
 80039c2:	4d1d      	ldr	r5, [pc, #116]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80039c4:	4628      	mov	r0, r5
 80039c6:	f01b fba4 	bl	801f112 <crs_strlen>
 80039ca:	b283      	uxth	r3, r0
 80039cc:	462a      	mov	r2, r5
 80039ce:	2101      	movs	r1, #1
 80039d0:	2002      	movs	r0, #2
 80039d2:	f01b fbe1 	bl	801f198 <traceIF_itmPrint>
 80039d6:	4628      	mov	r0, r5
 80039d8:	f01b fb9b 	bl	801f112 <crs_strlen>
 80039dc:	b283      	uxth	r3, r0
 80039de:	462a      	mov	r2, r5
 80039e0:	2101      	movs	r1, #1
 80039e2:	2002      	movs	r0, #2
 80039e4:	f01b fbfa 	bl	801f1dc <traceIF_uartPrint>
 80039e8:	e6fa      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    PRINT_INFO("unexpected command")
 80039ea:	4d13      	ldr	r5, [pc, #76]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80039ec:	f8df c068 	ldr.w	ip, [pc, #104]	; 8003a58 <fRspAnalyze_SOCKETCMD+0x30c>
 80039f0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80039f4:	6028      	str	r0, [r5, #0]
 80039f6:	6069      	str	r1, [r5, #4]
 80039f8:	60aa      	str	r2, [r5, #8]
 80039fa:	60eb      	str	r3, [r5, #12]
 80039fc:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8003a00:	6128      	str	r0, [r5, #16]
 8003a02:	6169      	str	r1, [r5, #20]
 8003a04:	61aa      	str	r2, [r5, #24]
 8003a06:	f89c 3000 	ldrb.w	r3, [ip]
 8003a0a:	772b      	strb	r3, [r5, #28]
 8003a0c:	4628      	mov	r0, r5
 8003a0e:	f01b fb80 	bl	801f112 <crs_strlen>
 8003a12:	b283      	uxth	r3, r0
 8003a14:	462a      	mov	r2, r5
 8003a16:	2101      	movs	r1, #1
 8003a18:	2002      	movs	r0, #2
 8003a1a:	f01b fbbd 	bl	801f198 <traceIF_itmPrint>
 8003a1e:	4628      	mov	r0, r5
 8003a20:	f01b fb77 	bl	801f112 <crs_strlen>
 8003a24:	b283      	uxth	r3, r0
 8003a26:	462a      	mov	r2, r5
 8003a28:	2101      	movs	r1, #1
 8003a2a:	2002      	movs	r0, #2
 8003a2c:	f01b fbd6 	bl	801f1dc <traceIF_uartPrint>
 8003a30:	e6d6      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
 8003a32:	bf00      	nop
 8003a34:	0802b0c0 	.word	0x0802b0c0
 8003a38:	200048dc 	.word	0x200048dc
 8003a3c:	0802b0ec 	.word	0x0802b0ec
 8003a40:	20001838 	.word	0x20001838
 8003a44:	0802b114 	.word	0x0802b114
 8003a48:	0802b130 	.word	0x0802b130
 8003a4c:	0802b174 	.word	0x0802b174
 8003a50:	0802b14c 	.word	0x0802b14c
 8003a54:	0802b198 	.word	0x0802b198
 8003a58:	0802b1cc 	.word	0x0802b1cc

08003a5c <fRspAnalyze_SOCKETDATA>:
{
 8003a5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003a60:	b085      	sub	sp, #20
 8003a62:	4606      	mov	r6, r0
 8003a64:	468a      	mov	sl, r1
 8003a66:	4615      	mov	r5, r2
 8003a68:	461c      	mov	r4, r3
  PRINT_API("enter fRspAnalyze_SOCKETDATA()")
 8003a6a:	4fc1      	ldr	r7, [pc, #772]	; (8003d70 <fRspAnalyze_SOCKETDATA+0x314>)
 8003a6c:	f8df c304 	ldr.w	ip, [pc, #772]	; 8003d74 <fRspAnalyze_SOCKETDATA+0x318>
 8003a70:	f107 0820 	add.w	r8, r7, #32
 8003a74:	46be      	mov	lr, r7
 8003a76:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8003a7a:	f8cc 0000 	str.w	r0, [ip]
 8003a7e:	f8cc 1004 	str.w	r1, [ip, #4]
 8003a82:	f8cc 2008 	str.w	r2, [ip, #8]
 8003a86:	f8cc 300c 	str.w	r3, [ip, #12]
 8003a8a:	4677      	mov	r7, lr
 8003a8c:	f10c 0c10 	add.w	ip, ip, #16
 8003a90:	45c6      	cmp	lr, r8
 8003a92:	d1ef      	bne.n	8003a74 <fRspAnalyze_SOCKETDATA+0x18>
 8003a94:	cf07      	ldmia	r7!, {r0, r1, r2}
 8003a96:	f8cc 0000 	str.w	r0, [ip]
 8003a9a:	f8cc 1004 	str.w	r1, [ip, #4]
 8003a9e:	f8cc 2008 	str.w	r2, [ip, #8]
 8003aa2:	783b      	ldrb	r3, [r7, #0]
 8003aa4:	f88c 300c 	strb.w	r3, [ip, #12]
 8003aa8:	4fb2      	ldr	r7, [pc, #712]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003aaa:	4638      	mov	r0, r7
 8003aac:	f01b fb31 	bl	801f112 <crs_strlen>
 8003ab0:	b283      	uxth	r3, r0
 8003ab2:	463a      	mov	r2, r7
 8003ab4:	2104      	movs	r1, #4
 8003ab6:	2002      	movs	r0, #2
 8003ab8:	f01b fb6e 	bl	801f198 <traceIF_itmPrint>
 8003abc:	4638      	mov	r0, r7
 8003abe:	f01b fb28 	bl	801f112 <crs_strlen>
 8003ac2:	b283      	uxth	r3, r0
 8003ac4:	463a      	mov	r2, r7
 8003ac6:	2104      	movs	r1, #4
 8003ac8:	2002      	movs	r0, #2
 8003aca:	f01b fb87 	bl	801f1dc <traceIF_uartPrint>
  START_PARAM_LOOP()
 8003ace:	f04f 0800 	mov.w	r8, #0
  uint32_t rlength = 0U;
 8003ad2:	f8cd 8004 	str.w	r8, [sp, #4]
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8003ad6:	f04f 0910 	mov.w	r9, #16
  START_PARAM_LOOP()
 8003ada:	4622      	mov	r2, r4
 8003adc:	4629      	mov	r1, r5
 8003ade:	4630      	mov	r0, r6
 8003ae0:	f008 fcb2 	bl	800c448 <atcc_extractElement>
 8003ae4:	2801      	cmp	r0, #1
 8003ae6:	d001      	beq.n	8003aec <fRspAnalyze_SOCKETDATA+0x90>
 8003ae8:	f04f 0801 	mov.w	r8, #1
 8003aec:	89e1      	ldrh	r1, [r4, #14]
 8003aee:	2900      	cmp	r1, #0
 8003af0:	f000 81e5 	beq.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETDATA_SEND)
 8003af4:	69f3      	ldr	r3, [r6, #28]
 8003af6:	2b4b      	cmp	r3, #75	; 0x4b
 8003af8:	d010      	beq.n	8003b1c <fRspAnalyze_SOCKETDATA+0xc0>
  else if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETDATA_RECEIVE)
 8003afa:	2b4c      	cmp	r3, #76	; 0x4c
 8003afc:	f040 81b6 	bne.w	8003e6c <fRspAnalyze_SOCKETDATA+0x410>
    if (element_infos->param_rank == 2U)
 8003b00:	8923      	ldrh	r3, [r4, #8]
 8003b02:	2b02      	cmp	r3, #2
 8003b04:	d04a      	beq.n	8003b9c <fRspAnalyze_SOCKETDATA+0x140>
    else if (element_infos->param_rank == 3U)
 8003b06:	3b03      	subs	r3, #3
 8003b08:	2b04      	cmp	r3, #4
 8003b0a:	f200 81d8 	bhi.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
 8003b0e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003b12:	0086      	.short	0x0086
 8003b14:	00c100a4 	.word	0x00c100a4
 8003b18:	01a60190 	.word	0x01a60190
    if (element_infos->param_rank == 2U)
 8003b1c:	8923      	ldrh	r3, [r4, #8]
 8003b1e:	2b02      	cmp	r3, #2
 8003b20:	d01f      	beq.n	8003b62 <fRspAnalyze_SOCKETDATA+0x106>
    else if (element_infos->param_rank == 3U)
 8003b22:	2b03      	cmp	r3, #3
 8003b24:	f040 81cb 	bne.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      PRINT_DBG("<SOCKETDATA_SEND: wlength> = %ld",
 8003b28:	8960      	ldrh	r0, [r4, #10]
 8003b2a:	4428      	add	r0, r5
 8003b2c:	f011 f902 	bl	8014d34 <ATutil_convertStringToInt>
 8003b30:	4602      	mov	r2, r0
 8003b32:	4f90      	ldr	r7, [pc, #576]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003b34:	4990      	ldr	r1, [pc, #576]	; (8003d78 <fRspAnalyze_SOCKETDATA+0x31c>)
 8003b36:	4638      	mov	r0, r7
 8003b38:	f022 f89a 	bl	8025c70 <sprintf>
 8003b3c:	4638      	mov	r0, r7
 8003b3e:	f01b fae8 	bl	801f112 <crs_strlen>
 8003b42:	b283      	uxth	r3, r0
 8003b44:	463a      	mov	r2, r7
 8003b46:	2102      	movs	r1, #2
 8003b48:	4608      	mov	r0, r1
 8003b4a:	f01b fb25 	bl	801f198 <traceIF_itmPrint>
 8003b4e:	4638      	mov	r0, r7
 8003b50:	f01b fadf 	bl	801f112 <crs_strlen>
 8003b54:	b283      	uxth	r3, r0
 8003b56:	463a      	mov	r2, r7
 8003b58:	2102      	movs	r1, #2
 8003b5a:	4608      	mov	r0, r1
 8003b5c:	f01b fb3e 	bl	801f1dc <traceIF_uartPrint>
 8003b60:	e1ad      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      PRINT_DBG("<SOCKETDATA_SEND: socket_id> = %ld",
 8003b62:	8960      	ldrh	r0, [r4, #10]
 8003b64:	4428      	add	r0, r5
 8003b66:	f011 f8e5 	bl	8014d34 <ATutil_convertStringToInt>
 8003b6a:	4602      	mov	r2, r0
 8003b6c:	4f81      	ldr	r7, [pc, #516]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003b6e:	4983      	ldr	r1, [pc, #524]	; (8003d7c <fRspAnalyze_SOCKETDATA+0x320>)
 8003b70:	4638      	mov	r0, r7
 8003b72:	f022 f87d 	bl	8025c70 <sprintf>
 8003b76:	4638      	mov	r0, r7
 8003b78:	f01b facb 	bl	801f112 <crs_strlen>
 8003b7c:	b283      	uxth	r3, r0
 8003b7e:	463a      	mov	r2, r7
 8003b80:	2102      	movs	r1, #2
 8003b82:	4608      	mov	r0, r1
 8003b84:	f01b fb08 	bl	801f198 <traceIF_itmPrint>
 8003b88:	4638      	mov	r0, r7
 8003b8a:	f01b fac2 	bl	801f112 <crs_strlen>
 8003b8e:	b283      	uxth	r3, r0
 8003b90:	463a      	mov	r2, r7
 8003b92:	2102      	movs	r1, #2
 8003b94:	4608      	mov	r0, r1
 8003b96:	f01b fb21 	bl	801f1dc <traceIF_uartPrint>
 8003b9a:	e190      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      uint32_t socketId =  ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003b9c:	8960      	ldrh	r0, [r4, #10]
 8003b9e:	4428      	add	r0, r5
 8003ba0:	f011 f8c8 	bl	8014d34 <ATutil_convertStringToInt>
 8003ba4:	4683      	mov	fp, r0
      PRINT_DBG("<SOCKETDATA_RECEIVE: socket_id> = %ld", socketId)
 8003ba6:	4f73      	ldr	r7, [pc, #460]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003ba8:	4602      	mov	r2, r0
 8003baa:	4975      	ldr	r1, [pc, #468]	; (8003d80 <fRspAnalyze_SOCKETDATA+0x324>)
 8003bac:	4638      	mov	r0, r7
 8003bae:	f022 f85f 	bl	8025c70 <sprintf>
 8003bb2:	4638      	mov	r0, r7
 8003bb4:	f01b faad 	bl	801f112 <crs_strlen>
 8003bb8:	b283      	uxth	r3, r0
 8003bba:	463a      	mov	r2, r7
 8003bbc:	2102      	movs	r1, #2
 8003bbe:	4608      	mov	r0, r1
 8003bc0:	f01b faea 	bl	801f198 <traceIF_itmPrint>
 8003bc4:	4638      	mov	r0, r7
 8003bc6:	f01b faa4 	bl	801f112 <crs_strlen>
 8003bca:	b283      	uxth	r3, r0
 8003bcc:	463a      	mov	r2, r7
 8003bce:	2102      	movs	r1, #2
 8003bd0:	4608      	mov	r0, r1
 8003bd2:	f01b fb03 	bl	801f1dc <traceIF_uartPrint>
      uint32_t expected_socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 8003bd6:	f8da 1744 	ldr.w	r1, [sl, #1860]	; 0x744
 8003bda:	4650      	mov	r0, sl
 8003bdc:	f010 fac6 	bl	801416c <atcm_socket_get_modem_cid>
      if (socketId != expected_socketID)
 8003be0:	4583      	cmp	fp, r0
 8003be2:	f000 816c 	beq.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
        PRINT_ERR("<SOCKETDATA_RECEIVE> on socket_id= %ld whereas expected socket_id= %ld",
 8003be6:	f8da 3744 	ldr.w	r3, [sl, #1860]	; 0x744
 8003bea:	465a      	mov	r2, fp
 8003bec:	4965      	ldr	r1, [pc, #404]	; (8003d84 <fRspAnalyze_SOCKETDATA+0x328>)
 8003bee:	4638      	mov	r0, r7
 8003bf0:	f022 f83e 	bl	8025c70 <sprintf>
 8003bf4:	4638      	mov	r0, r7
 8003bf6:	f01b fa8c 	bl	801f112 <crs_strlen>
 8003bfa:	b283      	uxth	r3, r0
 8003bfc:	463a      	mov	r2, r7
 8003bfe:	2110      	movs	r1, #16
 8003c00:	2002      	movs	r0, #2
 8003c02:	f01b fac9 	bl	801f198 <traceIF_itmPrint>
 8003c06:	4638      	mov	r0, r7
 8003c08:	f01b fa83 	bl	801f112 <crs_strlen>
 8003c0c:	b283      	uxth	r3, r0
 8003c0e:	463a      	mov	r2, r7
 8003c10:	2110      	movs	r1, #16
 8003c12:	2002      	movs	r0, #2
 8003c14:	f01b fae2 	bl	801f1dc <traceIF_uartPrint>
        retval = ATACTION_RSP_ERROR;
 8003c18:	f04f 0904 	mov.w	r9, #4
 8003c1c:	e156      	b.n	8003ecc <fRspAnalyze_SOCKETDATA+0x470>
      rlength = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 8003c1e:	8960      	ldrh	r0, [r4, #10]
 8003c20:	4428      	add	r0, r5
 8003c22:	f011 f887 	bl	8014d34 <ATutil_convertStringToInt>
 8003c26:	4602      	mov	r2, r0
 8003c28:	9001      	str	r0, [sp, #4]
      PRINT_DBG("<SOCKETDATA_RECEIVE: rlength> = %ld", rlength)
 8003c2a:	4f52      	ldr	r7, [pc, #328]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003c2c:	4956      	ldr	r1, [pc, #344]	; (8003d88 <fRspAnalyze_SOCKETDATA+0x32c>)
 8003c2e:	4638      	mov	r0, r7
 8003c30:	f022 f81e 	bl	8025c70 <sprintf>
 8003c34:	4638      	mov	r0, r7
 8003c36:	f01b fa6c 	bl	801f112 <crs_strlen>
 8003c3a:	b283      	uxth	r3, r0
 8003c3c:	463a      	mov	r2, r7
 8003c3e:	2102      	movs	r1, #2
 8003c40:	4608      	mov	r0, r1
 8003c42:	f01b faa9 	bl	801f198 <traceIF_itmPrint>
 8003c46:	4638      	mov	r0, r7
 8003c48:	f01b fa63 	bl	801f112 <crs_strlen>
 8003c4c:	b283      	uxth	r3, r0
 8003c4e:	463a      	mov	r2, r7
 8003c50:	2102      	movs	r1, #2
 8003c52:	4608      	mov	r0, r1
 8003c54:	f01b fac2 	bl	801f1dc <traceIF_uartPrint>
 8003c58:	e131      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      PRINT_DBG("<SOCKETDATA_RECEIVE: moreData> = %ld",
 8003c5a:	8960      	ldrh	r0, [r4, #10]
 8003c5c:	4428      	add	r0, r5
 8003c5e:	f011 f869 	bl	8014d34 <ATutil_convertStringToInt>
 8003c62:	4602      	mov	r2, r0
 8003c64:	4f43      	ldr	r7, [pc, #268]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003c66:	4949      	ldr	r1, [pc, #292]	; (8003d8c <fRspAnalyze_SOCKETDATA+0x330>)
 8003c68:	4638      	mov	r0, r7
 8003c6a:	f022 f801 	bl	8025c70 <sprintf>
 8003c6e:	4638      	mov	r0, r7
 8003c70:	f01b fa4f 	bl	801f112 <crs_strlen>
 8003c74:	b283      	uxth	r3, r0
 8003c76:	463a      	mov	r2, r7
 8003c78:	2102      	movs	r1, #2
 8003c7a:	4608      	mov	r0, r1
 8003c7c:	f01b fa8c 	bl	801f198 <traceIF_itmPrint>
 8003c80:	4638      	mov	r0, r7
 8003c82:	f01b fa46 	bl	801f112 <crs_strlen>
 8003c86:	b283      	uxth	r3, r0
 8003c88:	463a      	mov	r2, r7
 8003c8a:	2102      	movs	r1, #2
 8003c8c:	4608      	mov	r0, r1
 8003c8e:	f01b faa5 	bl	801f1dc <traceIF_uartPrint>
 8003c92:	e114      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      uint16_t data_size = (element_infos->str_size - 2U) >> 1; /* remove first and last quote (-2) then divide by 2 */
 8003c94:	3902      	subs	r1, #2
 8003c96:	f3c1 074f 	ubfx	r7, r1, #1, #16
      if (rlength != data_size)
 8003c9a:	9b01      	ldr	r3, [sp, #4]
 8003c9c:	42bb      	cmp	r3, r7
 8003c9e:	d120      	bne.n	8003ce2 <fRspAnalyze_SOCKETDATA+0x286>
      PRINT_DBG("<SOCKETDATA_RECEIVE: rdata> computed data_size = %d", data_size)
 8003ca0:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8003d74 <fRspAnalyze_SOCKETDATA+0x318>
 8003ca4:	463a      	mov	r2, r7
 8003ca6:	493a      	ldr	r1, [pc, #232]	; (8003d90 <fRspAnalyze_SOCKETDATA+0x334>)
 8003ca8:	4658      	mov	r0, fp
 8003caa:	f021 ffe1 	bl	8025c70 <sprintf>
 8003cae:	4658      	mov	r0, fp
 8003cb0:	f01b fa2f 	bl	801f112 <crs_strlen>
 8003cb4:	b283      	uxth	r3, r0
 8003cb6:	465a      	mov	r2, fp
 8003cb8:	2102      	movs	r1, #2
 8003cba:	4608      	mov	r0, r1
 8003cbc:	f01b fa6c 	bl	801f198 <traceIF_itmPrint>
 8003cc0:	4658      	mov	r0, fp
 8003cc2:	f01b fa26 	bl	801f112 <crs_strlen>
 8003cc6:	b283      	uxth	r3, r0
 8003cc8:	465a      	mov	r2, fp
 8003cca:	2102      	movs	r1, #2
 8003ccc:	4608      	mov	r0, r1
 8003cce:	f01b fa85 	bl	801f1dc <traceIF_uartPrint>
      if (data_size <= p_modem_ctxt->socket_ctxt.socketReceivedata.max_buffer_size)
 8003cd2:	f8da 3754 	ldr.w	r3, [sl, #1876]	; 0x754
 8003cd6:	42bb      	cmp	r3, r7
 8003cd8:	f0c0 8090 	bcc.w	8003dfc <fRspAnalyze_SOCKETDATA+0x3a0>
        for (idx = 0U; ((idx < data_size) && (retval != ATACTION_RSP_ERROR)); idx++)
 8003cdc:	f04f 0b00 	mov.w	fp, #0
 8003ce0:	e01f      	b.n	8003d22 <fRspAnalyze_SOCKETDATA+0x2c6>
        PRINT_ERR("Buffer size received (%d) does not match expected size (%ld)", data_size, rlength)
 8003ce2:	f8df b090 	ldr.w	fp, [pc, #144]	; 8003d74 <fRspAnalyze_SOCKETDATA+0x318>
 8003ce6:	463a      	mov	r2, r7
 8003ce8:	492a      	ldr	r1, [pc, #168]	; (8003d94 <fRspAnalyze_SOCKETDATA+0x338>)
 8003cea:	4658      	mov	r0, fp
 8003cec:	f021 ffc0 	bl	8025c70 <sprintf>
 8003cf0:	4658      	mov	r0, fp
 8003cf2:	f01b fa0e 	bl	801f112 <crs_strlen>
 8003cf6:	b283      	uxth	r3, r0
 8003cf8:	465a      	mov	r2, fp
 8003cfa:	2110      	movs	r1, #16
 8003cfc:	2002      	movs	r0, #2
 8003cfe:	f01b fa4b 	bl	801f198 <traceIF_itmPrint>
 8003d02:	4658      	mov	r0, fp
 8003d04:	f01b fa05 	bl	801f112 <crs_strlen>
 8003d08:	b283      	uxth	r3, r0
 8003d0a:	465a      	mov	r2, fp
 8003d0c:	2110      	movs	r1, #16
 8003d0e:	2002      	movs	r0, #2
 8003d10:	f01b fa64 	bl	801f1dc <traceIF_uartPrint>
 8003d14:	e7c4      	b.n	8003ca0 <fRspAnalyze_SOCKETDATA+0x244>
            retval = ATACTION_RSP_ERROR;
 8003d16:	f04f 0904 	mov.w	r9, #4
        for (idx = 0U; ((idx < data_size) && (retval != ATACTION_RSP_ERROR)); idx++)
 8003d1a:	f10b 0b01 	add.w	fp, fp, #1
 8003d1e:	fa1f fb8b 	uxth.w	fp, fp
 8003d22:	45bb      	cmp	fp, r7
 8003d24:	d216      	bcs.n	8003d54 <fRspAnalyze_SOCKETDATA+0x2f8>
 8003d26:	f1b9 0f04 	cmp.w	r9, #4
 8003d2a:	d013      	beq.n	8003d54 <fRspAnalyze_SOCKETDATA+0x2f8>
          if (convertHEXToChar((uint8_t)p_msg_in->buffer[element_infos->str_start_idx + 1U + (idx * 2U)],
 8003d2c:	8963      	ldrh	r3, [r4, #10]
 8003d2e:	eb03 034b 	add.w	r3, r3, fp, lsl #1
 8003d32:	1c58      	adds	r0, r3, #1
                               (uint8_t)p_msg_in->buffer[element_infos->str_start_idx + 2U + (idx * 2U)],
 8003d34:	3302      	adds	r3, #2
          if (convertHEXToChar((uint8_t)p_msg_in->buffer[element_infos->str_start_idx + 1U + (idx * 2U)],
 8003d36:	f10d 020f 	add.w	r2, sp, #15
 8003d3a:	5ce9      	ldrb	r1, [r5, r3]
 8003d3c:	5c28      	ldrb	r0, [r5, r0]
 8003d3e:	f7ff f835 	bl	8002dac <convertHEXToChar>
 8003d42:	2800      	cmp	r0, #0
 8003d44:	d1e7      	bne.n	8003d16 <fRspAnalyze_SOCKETDATA+0x2ba>
            p_modem_ctxt->socket_ctxt.socketReceivedata.p_buffer_addr_rcv[idx] = conVal;
 8003d46:	f8da 374c 	ldr.w	r3, [sl, #1868]	; 0x74c
 8003d4a:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8003d4e:	f803 200b 	strb.w	r2, [r3, fp]
 8003d52:	e7e2      	b.n	8003d1a <fRspAnalyze_SOCKETDATA+0x2be>
        if (retval != ATACTION_RSP_ERROR)
 8003d54:	f1b9 0f04 	cmp.w	r9, #4
 8003d58:	d01e      	beq.n	8003d98 <fRspAnalyze_SOCKETDATA+0x33c>
          p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size = data_size;
 8003d5a:	f8ca 7750 	str.w	r7, [sl, #1872]	; 0x750
          PRINT_BUF((const uint8_t *)&p_modem_ctxt->socket_ctxt.socketReceivedata.p_buffer_addr_rcv[0], data_size)
 8003d5e:	463b      	mov	r3, r7
 8003d60:	f8da 274c 	ldr.w	r2, [sl, #1868]	; 0x74c
 8003d64:	2102      	movs	r1, #2
 8003d66:	4608      	mov	r0, r1
 8003d68:	f01b fd04 	bl	801f774 <traceIF_BufCharPrint>
 8003d6c:	e0a7      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
 8003d6e:	bf00      	nop
 8003d70:	0802b1ec 	.word	0x0802b1ec
 8003d74:	200048dc 	.word	0x200048dc
 8003d78:	0802b24c 	.word	0x0802b24c
 8003d7c:	0802b21c 	.word	0x0802b21c
 8003d80:	0802b278 	.word	0x0802b278
 8003d84:	0802b2a8 	.word	0x0802b2a8
 8003d88:	0802b300 	.word	0x0802b300
 8003d8c:	0802b330 	.word	0x0802b330
 8003d90:	0802b3b0 	.word	0x0802b3b0
 8003d94:	0802b360 	.word	0x0802b360
          PRINT_ERR("error occurred during string conversion")
 8003d98:	f8df e140 	ldr.w	lr, [pc, #320]	; 8003edc <fRspAnalyze_SOCKETDATA+0x480>
 8003d9c:	f8df c134 	ldr.w	ip, [pc, #308]	; 8003ed4 <fRspAnalyze_SOCKETDATA+0x478>
 8003da0:	f10e 0b30 	add.w	fp, lr, #48	; 0x30
 8003da4:	4677      	mov	r7, lr
 8003da6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8003da8:	f8cc 0000 	str.w	r0, [ip]
 8003dac:	f8cc 1004 	str.w	r1, [ip, #4]
 8003db0:	f8cc 2008 	str.w	r2, [ip, #8]
 8003db4:	f8cc 300c 	str.w	r3, [ip, #12]
 8003db8:	46be      	mov	lr, r7
 8003dba:	f10c 0c10 	add.w	ip, ip, #16
 8003dbe:	455f      	cmp	r7, fp
 8003dc0:	d1f0      	bne.n	8003da4 <fRspAnalyze_SOCKETDATA+0x348>
 8003dc2:	e8be 0003 	ldmia.w	lr!, {r0, r1}
 8003dc6:	f8cc 0000 	str.w	r0, [ip]
 8003dca:	f8cc 1004 	str.w	r1, [ip, #4]
 8003dce:	4f41      	ldr	r7, [pc, #260]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003dd0:	4638      	mov	r0, r7
 8003dd2:	f01b f99e 	bl	801f112 <crs_strlen>
 8003dd6:	b283      	uxth	r3, r0
 8003dd8:	463a      	mov	r2, r7
 8003dda:	2110      	movs	r1, #16
 8003ddc:	2002      	movs	r0, #2
 8003dde:	f01b f9db 	bl	801f198 <traceIF_itmPrint>
 8003de2:	4638      	mov	r0, r7
 8003de4:	f01b f995 	bl	801f112 <crs_strlen>
 8003de8:	b283      	uxth	r3, r0
 8003dea:	463a      	mov	r2, r7
 8003dec:	2110      	movs	r1, #16
 8003dee:	2002      	movs	r0, #2
 8003df0:	f01b f9f4 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size = 0;
 8003df4:	2300      	movs	r3, #0
 8003df6:	f8ca 3750 	str.w	r3, [sl, #1872]	; 0x750
 8003dfa:	e060      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
        PRINT_ERR("Size of received buffer (%d) exceed client buffer size (%ld)", data_size,
 8003dfc:	4c35      	ldr	r4, [pc, #212]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003dfe:	463a      	mov	r2, r7
 8003e00:	4935      	ldr	r1, [pc, #212]	; (8003ed8 <fRspAnalyze_SOCKETDATA+0x47c>)
 8003e02:	4620      	mov	r0, r4
 8003e04:	f021 ff34 	bl	8025c70 <sprintf>
 8003e08:	4620      	mov	r0, r4
 8003e0a:	f01b f982 	bl	801f112 <crs_strlen>
 8003e0e:	b283      	uxth	r3, r0
 8003e10:	4622      	mov	r2, r4
 8003e12:	2110      	movs	r1, #16
 8003e14:	2002      	movs	r0, #2
 8003e16:	f01b f9bf 	bl	801f198 <traceIF_itmPrint>
 8003e1a:	4620      	mov	r0, r4
 8003e1c:	f01b f979 	bl	801f112 <crs_strlen>
 8003e20:	b283      	uxth	r3, r0
 8003e22:	4622      	mov	r2, r4
 8003e24:	2110      	movs	r1, #16
 8003e26:	2002      	movs	r0, #2
 8003e28:	f01b f9d8 	bl	801f1dc <traceIF_uartPrint>
        retval = ATACTION_RSP_ERROR;
 8003e2c:	f04f 0904 	mov.w	r9, #4
 8003e30:	e04c      	b.n	8003ecc <fRspAnalyze_SOCKETDATA+0x470>
      (void) memset((void *)&p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value[0],
 8003e32:	f20a 7759 	addw	r7, sl, #1881	; 0x759
 8003e36:	2240      	movs	r2, #64	; 0x40
 8003e38:	2100      	movs	r1, #0
 8003e3a:	4638      	mov	r0, r7
 8003e3c:	f021 ff8b 	bl	8025d56 <memset>
      p_modem_ctxt->socket_ctxt.socketReceivedata.remote_port = 0U;
 8003e40:	2300      	movs	r3, #0
 8003e42:	f8aa 379a 	strh.w	r3, [sl, #1946]	; 0x79a
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003e46:	8960      	ldrh	r0, [r4, #10]
 8003e48:	463a      	mov	r2, r7
 8003e4a:	89e1      	ldrh	r1, [r4, #14]
 8003e4c:	4428      	add	r0, r5
 8003e4e:	f008 fd10 	bl	800c872 <atcm_extract_IP_address>
        atcm_get_ip_address_type((AT_CHAR_t *)&p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value);
 8003e52:	4638      	mov	r0, r7
 8003e54:	f008 fce0 	bl	800c818 <atcm_get_ip_address_type>
      p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_type =
 8003e58:	f88a 0758 	strb.w	r0, [sl, #1880]	; 0x758
 8003e5c:	e02f      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
        (uint16_t) ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003e5e:	8960      	ldrh	r0, [r4, #10]
 8003e60:	4428      	add	r0, r5
 8003e62:	f010 ff67 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->socket_ctxt.socketReceivedata.remote_port =
 8003e66:	f8aa 079a 	strh.w	r0, [sl, #1946]	; 0x79a
 8003e6a:	e028      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
    PRINT_ERR("unexpected command")
 8003e6c:	f8df e070 	ldr.w	lr, [pc, #112]	; 8003ee0 <fRspAnalyze_SOCKETDATA+0x484>
 8003e70:	4f18      	ldr	r7, [pc, #96]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003e72:	f10e 0b20 	add.w	fp, lr, #32
 8003e76:	46f4      	mov	ip, lr
 8003e78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003e7c:	6038      	str	r0, [r7, #0]
 8003e7e:	6079      	str	r1, [r7, #4]
 8003e80:	60ba      	str	r2, [r7, #8]
 8003e82:	60fb      	str	r3, [r7, #12]
 8003e84:	46e6      	mov	lr, ip
 8003e86:	3710      	adds	r7, #16
 8003e88:	45dc      	cmp	ip, fp
 8003e8a:	d1f4      	bne.n	8003e76 <fRspAnalyze_SOCKETDATA+0x41a>
 8003e8c:	f8bc 2000 	ldrh.w	r2, [ip]
 8003e90:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8003e94:	803a      	strh	r2, [r7, #0]
 8003e96:	70bb      	strb	r3, [r7, #2]
 8003e98:	4f0e      	ldr	r7, [pc, #56]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003e9a:	4638      	mov	r0, r7
 8003e9c:	f01b f939 	bl	801f112 <crs_strlen>
 8003ea0:	b283      	uxth	r3, r0
 8003ea2:	463a      	mov	r2, r7
 8003ea4:	2110      	movs	r1, #16
 8003ea6:	2002      	movs	r0, #2
 8003ea8:	f01b f976 	bl	801f198 <traceIF_itmPrint>
 8003eac:	4638      	mov	r0, r7
 8003eae:	f01b f930 	bl	801f112 <crs_strlen>
 8003eb2:	b283      	uxth	r3, r0
 8003eb4:	463a      	mov	r2, r7
 8003eb6:	2110      	movs	r1, #16
 8003eb8:	2002      	movs	r0, #2
 8003eba:	f01b f98f 	bl	801f1dc <traceIF_uartPrint>
  END_PARAM_LOOP()
 8003ebe:	f1b9 0f04 	cmp.w	r9, #4
 8003ec2:	d003      	beq.n	8003ecc <fRspAnalyze_SOCKETDATA+0x470>
 8003ec4:	f1b8 0f00 	cmp.w	r8, #0
 8003ec8:	f43f ae07 	beq.w	8003ada <fRspAnalyze_SOCKETDATA+0x7e>
}
 8003ecc:	4648      	mov	r0, r9
 8003ece:	b005      	add	sp, #20
 8003ed0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003ed4:	200048dc 	.word	0x200048dc
 8003ed8:	0802b428 	.word	0x0802b428
 8003edc:	0802b3f0 	.word	0x0802b3f0
 8003ee0:	0802b478 	.word	0x0802b478

08003ee4 <fRspAnalyze_SOCKETEV>:
{
 8003ee4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003ee8:	b083      	sub	sp, #12
 8003eea:	4604      	mov	r4, r0
 8003eec:	9101      	str	r1, [sp, #4]
 8003eee:	4616      	mov	r6, r2
 8003ef0:	461d      	mov	r5, r3
  PRINT_API("enter fRspAnalyze_SOCKETEV()")
 8003ef2:	f8df c224 	ldr.w	ip, [pc, #548]	; 8004118 <fRspAnalyze_SOCKETEV+0x234>
 8003ef6:	4f7f      	ldr	r7, [pc, #508]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8003ef8:	f10c 0920 	add.w	r9, ip, #32
 8003efc:	46e0      	mov	r8, ip
 8003efe:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 8003f02:	6038      	str	r0, [r7, #0]
 8003f04:	6079      	str	r1, [r7, #4]
 8003f06:	60ba      	str	r2, [r7, #8]
 8003f08:	60fb      	str	r3, [r7, #12]
 8003f0a:	46c4      	mov	ip, r8
 8003f0c:	3710      	adds	r7, #16
 8003f0e:	45c8      	cmp	r8, r9
 8003f10:	d1f4      	bne.n	8003efc <fRspAnalyze_SOCKETEV+0x18>
 8003f12:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 8003f16:	6038      	str	r0, [r7, #0]
 8003f18:	6079      	str	r1, [r7, #4]
 8003f1a:	f8bc 2000 	ldrh.w	r2, [ip]
 8003f1e:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8003f22:	813a      	strh	r2, [r7, #8]
 8003f24:	72bb      	strb	r3, [r7, #10]
 8003f26:	4f73      	ldr	r7, [pc, #460]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8003f28:	4638      	mov	r0, r7
 8003f2a:	f01b f8f2 	bl	801f112 <crs_strlen>
 8003f2e:	b283      	uxth	r3, r0
 8003f30:	463a      	mov	r2, r7
 8003f32:	2104      	movs	r1, #4
 8003f34:	2002      	movs	r0, #2
 8003f36:	f01b f92f 	bl	801f198 <traceIF_itmPrint>
 8003f3a:	4638      	mov	r0, r7
 8003f3c:	f01b f8e9 	bl	801f112 <crs_strlen>
 8003f40:	b283      	uxth	r3, r0
 8003f42:	463a      	mov	r2, r7
 8003f44:	2104      	movs	r1, #4
 8003f46:	2002      	movs	r0, #2
 8003f48:	f01b f948 	bl	801f1dc <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.id != (CMD_ID_t) CMD_AT_SOCKETEV)
 8003f4c:	69e3      	ldr	r3, [r4, #28]
 8003f4e:	2b4d      	cmp	r3, #77	; 0x4d
 8003f50:	d105      	bne.n	8003f5e <fRspAnalyze_SOCKETEV+0x7a>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8003f52:	f04f 0810 	mov.w	r8, #16
}
 8003f56:	4640      	mov	r0, r8
 8003f58:	b003      	add	sp, #12
 8003f5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    START_PARAM_LOOP()
 8003f5e:	f04f 0900 	mov.w	r9, #0
  uint32_t event_id = 0U; /* initialize to a invalid value */
 8003f62:	46ca      	mov	sl, r9
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8003f64:	f04f 0810 	mov.w	r8, #16
    START_PARAM_LOOP()
 8003f68:	462a      	mov	r2, r5
 8003f6a:	4631      	mov	r1, r6
 8003f6c:	4620      	mov	r0, r4
 8003f6e:	f008 fa6b 	bl	800c448 <atcc_extractElement>
 8003f72:	2801      	cmp	r0, #1
 8003f74:	d001      	beq.n	8003f7a <fRspAnalyze_SOCKETEV+0x96>
 8003f76:	f04f 0901 	mov.w	r9, #1
 8003f7a:	89e9      	ldrh	r1, [r5, #14]
 8003f7c:	b139      	cbz	r1, 8003f8e <fRspAnalyze_SOCKETEV+0xaa>
    if (element_infos->param_rank == 2U)
 8003f7e:	892b      	ldrh	r3, [r5, #8]
 8003f80:	2b02      	cmp	r3, #2
 8003f82:	d008      	beq.n	8003f96 <fRspAnalyze_SOCKETEV+0xb2>
    else if (element_infos->param_rank == 3U)
 8003f84:	2b03      	cmp	r3, #3
 8003f86:	d02d      	beq.n	8003fe4 <fRspAnalyze_SOCKETEV+0x100>
    else if (element_infos->param_rank == 4U)
 8003f88:	2b04      	cmp	r3, #4
 8003f8a:	f000 8096 	beq.w	80040ba <fRspAnalyze_SOCKETEV+0x1d6>
    END_PARAM_LOOP()
 8003f8e:	f1b9 0f00 	cmp.w	r9, #0
 8003f92:	d1e0      	bne.n	8003f56 <fRspAnalyze_SOCKETEV+0x72>
 8003f94:	e7e8      	b.n	8003f68 <fRspAnalyze_SOCKETEV+0x84>
      event_id = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 8003f96:	8968      	ldrh	r0, [r5, #10]
 8003f98:	4430      	add	r0, r6
 8003f9a:	f010 fecb 	bl	8014d34 <ATutil_convertStringToInt>
 8003f9e:	4682      	mov	sl, r0
      PRINT_DBG("SOCKET_EVENT <event_id> = %ld : %s", event_id,
 8003fa0:	2801      	cmp	r0, #1
 8003fa2:	d01d      	beq.n	8003fe0 <fRspAnalyze_SOCKETEV+0xfc>
 8003fa4:	2802      	cmp	r0, #2
 8003fa6:	d019      	beq.n	8003fdc <fRspAnalyze_SOCKETEV+0xf8>
 8003fa8:	4b53      	ldr	r3, [pc, #332]	; (80040f8 <fRspAnalyze_SOCKETEV+0x214>)
 8003faa:	4f52      	ldr	r7, [pc, #328]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8003fac:	4652      	mov	r2, sl
 8003fae:	4953      	ldr	r1, [pc, #332]	; (80040fc <fRspAnalyze_SOCKETEV+0x218>)
 8003fb0:	4638      	mov	r0, r7
 8003fb2:	f021 fe5d 	bl	8025c70 <sprintf>
 8003fb6:	4638      	mov	r0, r7
 8003fb8:	f01b f8ab 	bl	801f112 <crs_strlen>
 8003fbc:	b283      	uxth	r3, r0
 8003fbe:	463a      	mov	r2, r7
 8003fc0:	2102      	movs	r1, #2
 8003fc2:	4608      	mov	r0, r1
 8003fc4:	f01b f8e8 	bl	801f198 <traceIF_itmPrint>
 8003fc8:	4638      	mov	r0, r7
 8003fca:	f01b f8a2 	bl	801f112 <crs_strlen>
 8003fce:	b283      	uxth	r3, r0
 8003fd0:	463a      	mov	r2, r7
 8003fd2:	2102      	movs	r1, #2
 8003fd4:	4608      	mov	r0, r1
 8003fd6:	f01b f901 	bl	801f1dc <traceIF_uartPrint>
 8003fda:	e7d8      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
 8003fdc:	4b48      	ldr	r3, [pc, #288]	; (8004100 <fRspAnalyze_SOCKETEV+0x21c>)
 8003fde:	e7e4      	b.n	8003faa <fRspAnalyze_SOCKETEV+0xc6>
 8003fe0:	4b48      	ldr	r3, [pc, #288]	; (8004104 <fRspAnalyze_SOCKETEV+0x220>)
 8003fe2:	e7e2      	b.n	8003faa <fRspAnalyze_SOCKETEV+0xc6>
      uint32_t socket_id = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003fe4:	8968      	ldrh	r0, [r5, #10]
 8003fe6:	4430      	add	r0, r6
 8003fe8:	f010 fea4 	bl	8014d34 <ATutil_convertStringToInt>
 8003fec:	4683      	mov	fp, r0
      socket_handle_t sockHandle = atcm_socket_get_socket_handle(p_modem_ctxt, socket_id);
 8003fee:	4601      	mov	r1, r0
 8003ff0:	9801      	ldr	r0, [sp, #4]
 8003ff2:	f010 f90d 	bl	8014210 <atcm_socket_get_socket_handle>
 8003ff6:	4603      	mov	r3, r0
      if (event_id == 1U)
 8003ff8:	f1ba 0f01 	cmp.w	sl, #1
 8003ffc:	d01b      	beq.n	8004036 <fRspAnalyze_SOCKETEV+0x152>
      else if (event_id == 3U)
 8003ffe:	f1ba 0f03 	cmp.w	sl, #3
 8004002:	d039      	beq.n	8004078 <fRspAnalyze_SOCKETEV+0x194>
        PRINT_DBG("SOCKET_EVENT: on socket %ld (handle=%ld) ignored", socket_id, sockHandle)
 8004004:	4f3b      	ldr	r7, [pc, #236]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8004006:	465a      	mov	r2, fp
 8004008:	493f      	ldr	r1, [pc, #252]	; (8004108 <fRspAnalyze_SOCKETEV+0x224>)
 800400a:	4638      	mov	r0, r7
 800400c:	f021 fe30 	bl	8025c70 <sprintf>
 8004010:	4638      	mov	r0, r7
 8004012:	f01b f87e 	bl	801f112 <crs_strlen>
 8004016:	b283      	uxth	r3, r0
 8004018:	463a      	mov	r2, r7
 800401a:	2102      	movs	r1, #2
 800401c:	4608      	mov	r0, r1
 800401e:	f01b f8bb 	bl	801f198 <traceIF_itmPrint>
 8004022:	4638      	mov	r0, r7
 8004024:	f01b f875 	bl	801f112 <crs_strlen>
 8004028:	b283      	uxth	r3, r0
 800402a:	463a      	mov	r2, r7
 800402c:	2102      	movs	r1, #2
 800402e:	4608      	mov	r0, r1
 8004030:	f01b f8d4 	bl	801f1dc <traceIF_uartPrint>
 8004034:	e7ab      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
        (void) atcm_socket_set_urc_data_pending(p_modem_ctxt, sockHandle);
 8004036:	4680      	mov	r8, r0
 8004038:	4601      	mov	r1, r0
 800403a:	9801      	ldr	r0, [sp, #4]
 800403c:	f010 f91e 	bl	801427c <atcm_socket_set_urc_data_pending>
        PRINT_INFO("SOCKET_EVENT: RX data available on socket %ld (handle=%ld) ", socket_id, sockHandle)
 8004040:	4f2c      	ldr	r7, [pc, #176]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8004042:	4643      	mov	r3, r8
 8004044:	465a      	mov	r2, fp
 8004046:	4931      	ldr	r1, [pc, #196]	; (800410c <fRspAnalyze_SOCKETEV+0x228>)
 8004048:	4638      	mov	r0, r7
 800404a:	f021 fe11 	bl	8025c70 <sprintf>
 800404e:	4638      	mov	r0, r7
 8004050:	f01b f85f 	bl	801f112 <crs_strlen>
 8004054:	b283      	uxth	r3, r0
 8004056:	463a      	mov	r2, r7
 8004058:	2101      	movs	r1, #1
 800405a:	2002      	movs	r0, #2
 800405c:	f01b f89c 	bl	801f198 <traceIF_itmPrint>
 8004060:	4638      	mov	r0, r7
 8004062:	f01b f856 	bl	801f112 <crs_strlen>
 8004066:	b283      	uxth	r3, r0
 8004068:	463a      	mov	r2, r7
 800406a:	2101      	movs	r1, #1
 800406c:	2002      	movs	r0, #2
 800406e:	f01b f8b5 	bl	801f1dc <traceIF_uartPrint>
        retval = ATACTION_RSP_URC_FORWARDED;
 8004072:	f04f 0840 	mov.w	r8, #64	; 0x40
 8004076:	e78a      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
        (void) atcm_socket_set_urc_closed_by_remote(p_modem_ctxt, sockHandle);
 8004078:	4680      	mov	r8, r0
 800407a:	4601      	mov	r1, r0
 800407c:	9801      	ldr	r0, [sp, #4]
 800407e:	f010 f92b 	bl	80142d8 <atcm_socket_set_urc_closed_by_remote>
        PRINT_INFO("SOCKET_EVENT: socket %ld (handle=%ld) closed by remote", socket_id, sockHandle)
 8004082:	4f1c      	ldr	r7, [pc, #112]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8004084:	4643      	mov	r3, r8
 8004086:	465a      	mov	r2, fp
 8004088:	4921      	ldr	r1, [pc, #132]	; (8004110 <fRspAnalyze_SOCKETEV+0x22c>)
 800408a:	4638      	mov	r0, r7
 800408c:	f021 fdf0 	bl	8025c70 <sprintf>
 8004090:	4638      	mov	r0, r7
 8004092:	f01b f83e 	bl	801f112 <crs_strlen>
 8004096:	b283      	uxth	r3, r0
 8004098:	463a      	mov	r2, r7
 800409a:	2101      	movs	r1, #1
 800409c:	2002      	movs	r0, #2
 800409e:	f01b f87b 	bl	801f198 <traceIF_itmPrint>
 80040a2:	4638      	mov	r0, r7
 80040a4:	f01b f835 	bl	801f112 <crs_strlen>
 80040a8:	b283      	uxth	r3, r0
 80040aa:	463a      	mov	r2, r7
 80040ac:	2101      	movs	r1, #1
 80040ae:	2002      	movs	r0, #2
 80040b0:	f01b f894 	bl	801f1dc <traceIF_uartPrint>
        retval = ATACTION_RSP_URC_FORWARDED;
 80040b4:	f04f 0840 	mov.w	r8, #64	; 0x40
 80040b8:	e769      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
      PRINT_INFO("SOCKET_EVENT <connected_socket_id> = %ld",
 80040ba:	8968      	ldrh	r0, [r5, #10]
 80040bc:	4430      	add	r0, r6
 80040be:	f010 fe39 	bl	8014d34 <ATutil_convertStringToInt>
 80040c2:	4602      	mov	r2, r0
 80040c4:	4f0b      	ldr	r7, [pc, #44]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 80040c6:	4913      	ldr	r1, [pc, #76]	; (8004114 <fRspAnalyze_SOCKETEV+0x230>)
 80040c8:	4638      	mov	r0, r7
 80040ca:	f021 fdd1 	bl	8025c70 <sprintf>
 80040ce:	4638      	mov	r0, r7
 80040d0:	f01b f81f 	bl	801f112 <crs_strlen>
 80040d4:	b283      	uxth	r3, r0
 80040d6:	463a      	mov	r2, r7
 80040d8:	2101      	movs	r1, #1
 80040da:	2002      	movs	r0, #2
 80040dc:	f01b f85c 	bl	801f198 <traceIF_itmPrint>
 80040e0:	4638      	mov	r0, r7
 80040e2:	f01b f816 	bl	801f112 <crs_strlen>
 80040e6:	b283      	uxth	r3, r0
 80040e8:	463a      	mov	r2, r7
 80040ea:	2101      	movs	r1, #1
 80040ec:	2002      	movs	r0, #2
 80040ee:	f01b f875 	bl	801f1dc <traceIF_uartPrint>
    END_PARAM_LOOP()
 80040f2:	e74c      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
 80040f4:	200048dc 	.word	0x200048dc
 80040f8:	0802b49c 	.word	0x0802b49c
 80040fc:	0802b518 	.word	0x0802b518
 8004100:	0802b4d0 	.word	0x0802b4d0
 8004104:	0802b4ac 	.word	0x0802b4ac
 8004108:	0802b5d4 	.word	0x0802b5d4
 800410c:	0802b548 	.word	0x0802b548
 8004110:	0802b590 	.word	0x0802b590
 8004114:	0802b610 	.word	0x0802b610
 8004118:	0802b4ec 	.word	0x0802b4ec

0800411c <fRspAnalyze_DNSRSLV>:
{
 800411c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004120:	b092      	sub	sp, #72	; 0x48
 8004122:	4680      	mov	r8, r0
 8004124:	4617      	mov	r7, r2
 8004126:	461e      	mov	r6, r3
  PRINT_API("enter fRspAnalyze_DNSRSLV()")
 8004128:	4c66      	ldr	r4, [pc, #408]	; (80042c4 <fRspAnalyze_DNSRSLV+0x1a8>)
 800412a:	4d67      	ldr	r5, [pc, #412]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 800412c:	f104 0e20 	add.w	lr, r4, #32
 8004130:	46a4      	mov	ip, r4
 8004132:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004136:	6028      	str	r0, [r5, #0]
 8004138:	6069      	str	r1, [r5, #4]
 800413a:	60aa      	str	r2, [r5, #8]
 800413c:	60eb      	str	r3, [r5, #12]
 800413e:	4664      	mov	r4, ip
 8004140:	3510      	adds	r5, #16
 8004142:	45f4      	cmp	ip, lr
 8004144:	d1f4      	bne.n	8004130 <fRspAnalyze_DNSRSLV+0x14>
 8004146:	cc03      	ldmia	r4!, {r0, r1}
 8004148:	6028      	str	r0, [r5, #0]
 800414a:	6069      	str	r1, [r5, #4]
 800414c:	8823      	ldrh	r3, [r4, #0]
 800414e:	812b      	strh	r3, [r5, #8]
 8004150:	4c5d      	ldr	r4, [pc, #372]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004152:	4620      	mov	r0, r4
 8004154:	f01a ffdd 	bl	801f112 <crs_strlen>
 8004158:	b283      	uxth	r3, r0
 800415a:	4622      	mov	r2, r4
 800415c:	2104      	movs	r1, #4
 800415e:	2002      	movs	r0, #2
 8004160:	f01b f81a 	bl	801f198 <traceIF_itmPrint>
 8004164:	4620      	mov	r0, r4
 8004166:	f01a ffd4 	bl	801f112 <crs_strlen>
 800416a:	b283      	uxth	r3, r0
 800416c:	4622      	mov	r2, r4
 800416e:	2104      	movs	r1, #4
 8004170:	2002      	movs	r0, #2
 8004172:	f01b f833 	bl	801f1dc <traceIF_uartPrint>
  START_PARAM_LOOP()
 8004176:	2400      	movs	r4, #0
  uint32_t ip_type = 0U;
 8004178:	46a1      	mov	r9, r4
  START_PARAM_LOOP()
 800417a:	4632      	mov	r2, r6
 800417c:	4639      	mov	r1, r7
 800417e:	4640      	mov	r0, r8
 8004180:	f008 f962 	bl	800c448 <atcc_extractElement>
 8004184:	2801      	cmp	r0, #1
 8004186:	d000      	beq.n	800418a <fRspAnalyze_DNSRSLV+0x6e>
 8004188:	2401      	movs	r4, #1
 800418a:	89f1      	ldrh	r1, [r6, #14]
 800418c:	b121      	cbz	r1, 8004198 <fRspAnalyze_DNSRSLV+0x7c>
  if (element_infos->param_rank == 2U)
 800418e:	8933      	ldrh	r3, [r6, #8]
 8004190:	2b02      	cmp	r3, #2
 8004192:	d007      	beq.n	80041a4 <fRspAnalyze_DNSRSLV+0x88>
  else if (element_infos->param_rank == 3U)
 8004194:	2b03      	cmp	r3, #3
 8004196:	d023      	beq.n	80041e0 <fRspAnalyze_DNSRSLV+0xc4>
  END_PARAM_LOOP()
 8004198:	2c00      	cmp	r4, #0
 800419a:	d0ee      	beq.n	800417a <fRspAnalyze_DNSRSLV+0x5e>
}
 800419c:	2010      	movs	r0, #16
 800419e:	b012      	add	sp, #72	; 0x48
 80041a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ip_type = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 80041a4:	8970      	ldrh	r0, [r6, #10]
 80041a6:	4438      	add	r0, r7
 80041a8:	f010 fdc4 	bl	8014d34 <ATutil_convertStringToInt>
 80041ac:	4681      	mov	r9, r0
    PRINT_INFO("<ip_type> = %ld", ip_type);
 80041ae:	4d46      	ldr	r5, [pc, #280]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 80041b0:	4602      	mov	r2, r0
 80041b2:	4946      	ldr	r1, [pc, #280]	; (80042cc <fRspAnalyze_DNSRSLV+0x1b0>)
 80041b4:	4628      	mov	r0, r5
 80041b6:	f021 fd5b 	bl	8025c70 <sprintf>
 80041ba:	4628      	mov	r0, r5
 80041bc:	f01a ffa9 	bl	801f112 <crs_strlen>
 80041c0:	b283      	uxth	r3, r0
 80041c2:	462a      	mov	r2, r5
 80041c4:	2101      	movs	r1, #1
 80041c6:	2002      	movs	r0, #2
 80041c8:	f01a ffe6 	bl	801f198 <traceIF_itmPrint>
 80041cc:	4628      	mov	r0, r5
 80041ce:	f01a ffa0 	bl	801f112 <crs_strlen>
 80041d2:	b283      	uxth	r3, r0
 80041d4:	462a      	mov	r2, r5
 80041d6:	2101      	movs	r1, #1
 80041d8:	2002      	movs	r0, #2
 80041da:	f01a ffff 	bl	801f1dc <traceIF_uartPrint>
 80041de:	e7db      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
    if (ip_type == 0U)
 80041e0:	f1b9 0f00 	cmp.w	r9, #0
 80041e4:	d142      	bne.n	800426c <fRspAnalyze_DNSRSLV+0x150>
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 80041e6:	2241      	movs	r2, #65	; 0x41
 80041e8:	2100      	movs	r1, #0
 80041ea:	a801      	add	r0, sp, #4
 80041ec:	f021 fdb3 	bl	8025d56 <memset>
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 80041f0:	8971      	ldrh	r1, [r6, #10]
      (void) memcpy((void *) & (ip_addr_info.ip_addr_value),
 80041f2:	89f2      	ldrh	r2, [r6, #14]
 80041f4:	4439      	add	r1, r7
 80041f6:	f10d 0005 	add.w	r0, sp, #5
 80041fa:	f021 fe89 	bl	8025f10 <memcpy>
      if (atcm_get_ip_address_type((AT_CHAR_t *)&ip_addr_info.ip_addr_value) == CS_IPAT_IPV4)
 80041fe:	f10d 0005 	add.w	r0, sp, #5
 8004202:	f008 fb09 	bl	800c818 <atcm_get_ip_address_type>
 8004206:	2801      	cmp	r0, #1
 8004208:	d029      	beq.n	800425e <fRspAnalyze_DNSRSLV+0x142>
        PRINT_ERR("error, invalid IPv4 address format")
 800420a:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 80042d4 <fRspAnalyze_DNSRSLV+0x1b8>
 800420e:	4d2e      	ldr	r5, [pc, #184]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004210:	f10e 0a30 	add.w	sl, lr, #48	; 0x30
 8004214:	46f4      	mov	ip, lr
 8004216:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800421a:	6028      	str	r0, [r5, #0]
 800421c:	6069      	str	r1, [r5, #4]
 800421e:	60aa      	str	r2, [r5, #8]
 8004220:	60eb      	str	r3, [r5, #12]
 8004222:	46e6      	mov	lr, ip
 8004224:	3510      	adds	r5, #16
 8004226:	45d4      	cmp	ip, sl
 8004228:	d1f4      	bne.n	8004214 <fRspAnalyze_DNSRSLV+0xf8>
 800422a:	f8bc 2000 	ldrh.w	r2, [ip]
 800422e:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8004232:	802a      	strh	r2, [r5, #0]
 8004234:	70ab      	strb	r3, [r5, #2]
 8004236:	4d24      	ldr	r5, [pc, #144]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004238:	4628      	mov	r0, r5
 800423a:	f01a ff6a 	bl	801f112 <crs_strlen>
 800423e:	b283      	uxth	r3, r0
 8004240:	462a      	mov	r2, r5
 8004242:	2110      	movs	r1, #16
 8004244:	2002      	movs	r0, #2
 8004246:	f01a ffa7 	bl	801f198 <traceIF_itmPrint>
 800424a:	4628      	mov	r0, r5
 800424c:	f01a ff61 	bl	801f112 <crs_strlen>
 8004250:	b283      	uxth	r3, r0
 8004252:	462a      	mov	r2, r5
 8004254:	2110      	movs	r1, #16
 8004256:	2002      	movs	r0, #2
 8004258:	f01a ffc0 	bl	801f1dc <traceIF_uartPrint>
 800425c:	e79c      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
                      (const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 800425e:	8971      	ldrh	r1, [r6, #10]
        (void) memcpy((void *)type1sc_shared.DNSRSLV_dns_info.hostIPaddr,
 8004260:	89f2      	ldrh	r2, [r6, #14]
 8004262:	4439      	add	r1, r7
 8004264:	481a      	ldr	r0, [pc, #104]	; (80042d0 <fRspAnalyze_DNSRSLV+0x1b4>)
 8004266:	f021 fe53 	bl	8025f10 <memcpy>
 800426a:	e795      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
      PRINT_ERR("error, IPv6 address format not supported yet")
 800426c:	f8df c068 	ldr.w	ip, [pc, #104]	; 80042d8 <fRspAnalyze_DNSRSLV+0x1bc>
 8004270:	4d15      	ldr	r5, [pc, #84]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004272:	f10c 0a30 	add.w	sl, ip, #48	; 0x30
 8004276:	46e6      	mov	lr, ip
 8004278:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800427c:	6028      	str	r0, [r5, #0]
 800427e:	6069      	str	r1, [r5, #4]
 8004280:	60aa      	str	r2, [r5, #8]
 8004282:	60eb      	str	r3, [r5, #12]
 8004284:	46f4      	mov	ip, lr
 8004286:	3510      	adds	r5, #16
 8004288:	45d6      	cmp	lr, sl
 800428a:	d1f4      	bne.n	8004276 <fRspAnalyze_DNSRSLV+0x15a>
 800428c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8004290:	6028      	str	r0, [r5, #0]
 8004292:	6069      	str	r1, [r5, #4]
 8004294:	60aa      	str	r2, [r5, #8]
 8004296:	f89c 3000 	ldrb.w	r3, [ip]
 800429a:	732b      	strb	r3, [r5, #12]
 800429c:	4d0a      	ldr	r5, [pc, #40]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 800429e:	4628      	mov	r0, r5
 80042a0:	f01a ff37 	bl	801f112 <crs_strlen>
 80042a4:	b283      	uxth	r3, r0
 80042a6:	462a      	mov	r2, r5
 80042a8:	2110      	movs	r1, #16
 80042aa:	2002      	movs	r0, #2
 80042ac:	f01a ff74 	bl	801f198 <traceIF_itmPrint>
 80042b0:	4628      	mov	r0, r5
 80042b2:	f01a ff2e 	bl	801f112 <crs_strlen>
 80042b6:	b283      	uxth	r3, r0
 80042b8:	462a      	mov	r2, r5
 80042ba:	2110      	movs	r1, #16
 80042bc:	2002      	movs	r0, #2
 80042be:	f01a ff8d 	bl	801f1dc <traceIF_uartPrint>
 80042c2:	e769      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
 80042c4:	0802b644 	.word	0x0802b644
 80042c8:	200048dc 	.word	0x200048dc
 80042cc:	0802b670 	.word	0x0802b670
 80042d0:	20001838 	.word	0x20001838
 80042d4:	0802b68c 	.word	0x0802b68c
 80042d8:	0802b6c0 	.word	0x0802b6c0

080042dc <clear_ping_resp_struct>:
{
 80042dc:	b538      	push	{r3, r4, r5, lr}
 80042de:	4604      	mov	r4, r0
  p_modem_ctxt->persist.ping_resp_urc.ping_status = CELLULAR_ERROR;
 80042e0:	2301      	movs	r3, #1
 80042e2:	f880 355d 	strb.w	r3, [r0, #1373]	; 0x55d
  p_modem_ctxt->persist.ping_resp_urc.is_final_report = CELLULAR_FALSE;
 80042e6:	2500      	movs	r5, #0
 80042e8:	f880 555e 	strb.w	r5, [r0, #1374]	; 0x55e
  (void) memset((void *)&p_modem_ctxt->persist.ping_resp_urc.ping_addr[0], 0U, MAX_SIZE_IPADDR);
 80042ec:	2240      	movs	r2, #64	; 0x40
 80042ee:	4629      	mov	r1, r5
 80042f0:	f200 505f 	addw	r0, r0, #1375	; 0x55f
 80042f4:	f021 fd2f 	bl	8025d56 <memset>
  p_modem_ctxt->persist.ping_resp_urc.ping_size = 0U;
 80042f8:	f8a4 55a0 	strh.w	r5, [r4, #1440]	; 0x5a0
  p_modem_ctxt->persist.ping_resp_urc.time = 0U;
 80042fc:	f8c4 55a4 	str.w	r5, [r4, #1444]	; 0x5a4
  p_modem_ctxt->persist.ping_resp_urc.ttl = 0U;
 8004300:	f884 55a8 	strb.w	r5, [r4, #1448]	; 0x5a8
}
 8004304:	bd38      	pop	{r3, r4, r5, pc}
	...

08004308 <fRspAnalyze_PINGCMD>:
{
 8004308:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800430c:	4680      	mov	r8, r0
 800430e:	4689      	mov	r9, r1
 8004310:	4617      	mov	r7, r2
 8004312:	461e      	mov	r6, r3
  PRINT_API("enter fRspAnalyze_PINGCMD()")
 8004314:	4c71      	ldr	r4, [pc, #452]	; (80044dc <fRspAnalyze_PINGCMD+0x1d4>)
 8004316:	4d72      	ldr	r5, [pc, #456]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 8004318:	f104 0e20 	add.w	lr, r4, #32
 800431c:	46a4      	mov	ip, r4
 800431e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004322:	6028      	str	r0, [r5, #0]
 8004324:	6069      	str	r1, [r5, #4]
 8004326:	60aa      	str	r2, [r5, #8]
 8004328:	60eb      	str	r3, [r5, #12]
 800432a:	4664      	mov	r4, ip
 800432c:	3510      	adds	r5, #16
 800432e:	45f4      	cmp	ip, lr
 8004330:	d1f4      	bne.n	800431c <fRspAnalyze_PINGCMD+0x14>
 8004332:	cc03      	ldmia	r4!, {r0, r1}
 8004334:	6028      	str	r0, [r5, #0]
 8004336:	6069      	str	r1, [r5, #4]
 8004338:	8823      	ldrh	r3, [r4, #0]
 800433a:	812b      	strh	r3, [r5, #8]
 800433c:	4c68      	ldr	r4, [pc, #416]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 800433e:	4620      	mov	r0, r4
 8004340:	f01a fee7 	bl	801f112 <crs_strlen>
 8004344:	b283      	uxth	r3, r0
 8004346:	4622      	mov	r2, r4
 8004348:	2104      	movs	r1, #4
 800434a:	2002      	movs	r0, #2
 800434c:	f01a ff24 	bl	801f198 <traceIF_itmPrint>
 8004350:	4620      	mov	r0, r4
 8004352:	f01a fede 	bl	801f112 <crs_strlen>
 8004356:	b283      	uxth	r3, r0
 8004358:	4622      	mov	r2, r4
 800435a:	2104      	movs	r1, #4
 800435c:	2002      	movs	r0, #2
 800435e:	f01a ff3d 	bl	801f1dc <traceIF_uartPrint>
  START_PARAM_LOOP()
 8004362:	2500      	movs	r5, #0
 8004364:	4632      	mov	r2, r6
 8004366:	4639      	mov	r1, r7
 8004368:	4640      	mov	r0, r8
 800436a:	f008 f86d 	bl	800c448 <atcc_extractElement>
 800436e:	2801      	cmp	r0, #1
 8004370:	d000      	beq.n	8004374 <fRspAnalyze_PINGCMD+0x6c>
 8004372:	2501      	movs	r5, #1
 8004374:	89f1      	ldrh	r1, [r6, #14]
 8004376:	b149      	cbz	r1, 800438c <fRspAnalyze_PINGCMD+0x84>
  if (element_infos->param_rank == 2U)
 8004378:	8933      	ldrh	r3, [r6, #8]
 800437a:	2b02      	cmp	r3, #2
 800437c:	d00b      	beq.n	8004396 <fRspAnalyze_PINGCMD+0x8e>
  else if (element_infos->param_rank == 3U)
 800437e:	2b03      	cmp	r3, #3
 8004380:	d061      	beq.n	8004446 <fRspAnalyze_PINGCMD+0x13e>
  else if (element_infos->param_rank == 4U)
 8004382:	2b04      	cmp	r3, #4
 8004384:	d066      	beq.n	8004454 <fRspAnalyze_PINGCMD+0x14c>
  else if (element_infos->param_rank == 5U)
 8004386:	2b05      	cmp	r3, #5
 8004388:	f000 8084 	beq.w	8004494 <fRspAnalyze_PINGCMD+0x18c>
  END_PARAM_LOOP()
 800438c:	2d00      	cmp	r5, #0
 800438e:	d0e9      	beq.n	8004364 <fRspAnalyze_PINGCMD+0x5c>
}
 8004390:	2040      	movs	r0, #64	; 0x40
 8004392:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    clear_ping_resp_struct(p_modem_ctxt);
 8004396:	4648      	mov	r0, r9
 8004398:	f7ff ffa0 	bl	80042dc <clear_ping_resp_struct>
    p_modem_ctxt->persist.ping_resp_urc.ping_status = CELLULAR_ERROR; /* will be updated if all params are correct */
 800439c:	f04f 0b01 	mov.w	fp, #1
 80043a0:	f889 b55d 	strb.w	fp, [r9, #1373]	; 0x55d
    uint32_t ping_id = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80043a4:	8970      	ldrh	r0, [r6, #10]
 80043a6:	89f1      	ldrh	r1, [r6, #14]
 80043a8:	4438      	add	r0, r7
 80043aa:	f010 fcc3 	bl	8014d34 <ATutil_convertStringToInt>
 80043ae:	4682      	mov	sl, r0
    PRINT_DBG("<id> = %ld", ping_id)
 80043b0:	4c4b      	ldr	r4, [pc, #300]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 80043b2:	4602      	mov	r2, r0
 80043b4:	494b      	ldr	r1, [pc, #300]	; (80044e4 <fRspAnalyze_PINGCMD+0x1dc>)
 80043b6:	4620      	mov	r0, r4
 80043b8:	f021 fc5a 	bl	8025c70 <sprintf>
 80043bc:	4620      	mov	r0, r4
 80043be:	f01a fea8 	bl	801f112 <crs_strlen>
 80043c2:	b283      	uxth	r3, r0
 80043c4:	4622      	mov	r2, r4
 80043c6:	2102      	movs	r1, #2
 80043c8:	4608      	mov	r0, r1
 80043ca:	f01a fee5 	bl	801f198 <traceIF_itmPrint>
 80043ce:	4620      	mov	r0, r4
 80043d0:	f01a fe9f 	bl	801f112 <crs_strlen>
 80043d4:	b283      	uxth	r3, r0
 80043d6:	4622      	mov	r2, r4
 80043d8:	2102      	movs	r1, #2
 80043da:	4608      	mov	r0, r1
 80043dc:	f01a fefe 	bl	801f1dc <traceIF_uartPrint>
    p_modem_ctxt->persist.urc_avail_ping_rsp = AT_TRUE;
 80043e0:	f889 b5ac 	strb.w	fp, [r9, #1452]	; 0x5ac
    p_modem_ctxt->persist.ping_resp_urc.index = (uint8_t)ping_id;
 80043e4:	f889 a55c 	strb.w	sl, [r9, #1372]	; 0x55c
    PRINT_DBG("intermediate ping report")
 80043e8:	f8df e104 	ldr.w	lr, [pc, #260]	; 80044f0 <fRspAnalyze_PINGCMD+0x1e8>
 80043ec:	f10e 0a20 	add.w	sl, lr, #32
 80043f0:	46f4      	mov	ip, lr
 80043f2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80043f6:	6020      	str	r0, [r4, #0]
 80043f8:	6061      	str	r1, [r4, #4]
 80043fa:	60a2      	str	r2, [r4, #8]
 80043fc:	60e3      	str	r3, [r4, #12]
 80043fe:	46e6      	mov	lr, ip
 8004400:	3410      	adds	r4, #16
 8004402:	45d4      	cmp	ip, sl
 8004404:	d1f4      	bne.n	80043f0 <fRspAnalyze_PINGCMD+0xe8>
 8004406:	f8bc 2000 	ldrh.w	r2, [ip]
 800440a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800440e:	8022      	strh	r2, [r4, #0]
 8004410:	70a3      	strb	r3, [r4, #2]
 8004412:	4c33      	ldr	r4, [pc, #204]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 8004414:	4620      	mov	r0, r4
 8004416:	f01a fe7c 	bl	801f112 <crs_strlen>
 800441a:	b283      	uxth	r3, r0
 800441c:	4622      	mov	r2, r4
 800441e:	2102      	movs	r1, #2
 8004420:	4608      	mov	r0, r1
 8004422:	f01a feb9 	bl	801f198 <traceIF_itmPrint>
 8004426:	4620      	mov	r0, r4
 8004428:	f01a fe73 	bl	801f112 <crs_strlen>
 800442c:	b283      	uxth	r3, r0
 800442e:	4622      	mov	r2, r4
 8004430:	2102      	movs	r1, #2
 8004432:	4608      	mov	r0, r1
 8004434:	f01a fed2 	bl	801f1dc <traceIF_uartPrint>
    p_modem_ctxt->persist.ping_resp_urc.is_final_report = CELLULAR_FALSE;
 8004438:	2300      	movs	r3, #0
 800443a:	f889 355e 	strb.w	r3, [r9, #1374]	; 0x55e
    p_modem_ctxt->persist.ping_resp_urc.ping_size = TYPE1SC_PING_LENGTH;
 800443e:	2338      	movs	r3, #56	; 0x38
 8004440:	f8a9 35a0 	strh.w	r3, [r9, #1440]	; 0x5a0
 8004444:	e7a2      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
    atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8004446:	8970      	ldrh	r0, [r6, #10]
 8004448:	f209 525f 	addw	r2, r9, #1375	; 0x55f
 800444c:	4438      	add	r0, r7
 800444e:	f008 fa10 	bl	800c872 <atcm_extract_IP_address>
 8004452:	e79b      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
    uint32_t rtt = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8004454:	8970      	ldrh	r0, [r6, #10]
 8004456:	4438      	add	r0, r7
 8004458:	f010 fc6c 	bl	8014d34 <ATutil_convertStringToInt>
 800445c:	4682      	mov	sl, r0
    PRINT_DBG("<rtt> = %ld", rtt);
 800445e:	4c20      	ldr	r4, [pc, #128]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 8004460:	4602      	mov	r2, r0
 8004462:	4921      	ldr	r1, [pc, #132]	; (80044e8 <fRspAnalyze_PINGCMD+0x1e0>)
 8004464:	4620      	mov	r0, r4
 8004466:	f021 fc03 	bl	8025c70 <sprintf>
 800446a:	4620      	mov	r0, r4
 800446c:	f01a fe51 	bl	801f112 <crs_strlen>
 8004470:	b283      	uxth	r3, r0
 8004472:	4622      	mov	r2, r4
 8004474:	2102      	movs	r1, #2
 8004476:	4608      	mov	r0, r1
 8004478:	f01a fe8e 	bl	801f198 <traceIF_itmPrint>
 800447c:	4620      	mov	r0, r4
 800447e:	f01a fe48 	bl	801f112 <crs_strlen>
 8004482:	b283      	uxth	r3, r0
 8004484:	4622      	mov	r2, r4
 8004486:	2102      	movs	r1, #2
 8004488:	4608      	mov	r0, r1
 800448a:	f01a fea7 	bl	801f1dc <traceIF_uartPrint>
    p_modem_ctxt->persist.ping_resp_urc.time = (uint32_t)rtt;
 800448e:	f8c9 a5a4 	str.w	sl, [r9, #1444]	; 0x5a4
 8004492:	e77b      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
    uint32_t ttl = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8004494:	8970      	ldrh	r0, [r6, #10]
 8004496:	4438      	add	r0, r7
 8004498:	f010 fc4c 	bl	8014d34 <ATutil_convertStringToInt>
 800449c:	4682      	mov	sl, r0
    PRINT_INFO("<ttl> = %ld", ttl);
 800449e:	4c10      	ldr	r4, [pc, #64]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 80044a0:	4602      	mov	r2, r0
 80044a2:	4912      	ldr	r1, [pc, #72]	; (80044ec <fRspAnalyze_PINGCMD+0x1e4>)
 80044a4:	4620      	mov	r0, r4
 80044a6:	f021 fbe3 	bl	8025c70 <sprintf>
 80044aa:	4620      	mov	r0, r4
 80044ac:	f01a fe31 	bl	801f112 <crs_strlen>
 80044b0:	b283      	uxth	r3, r0
 80044b2:	4622      	mov	r2, r4
 80044b4:	2101      	movs	r1, #1
 80044b6:	2002      	movs	r0, #2
 80044b8:	f01a fe6e 	bl	801f198 <traceIF_itmPrint>
 80044bc:	4620      	mov	r0, r4
 80044be:	f01a fe28 	bl	801f112 <crs_strlen>
 80044c2:	b283      	uxth	r3, r0
 80044c4:	4622      	mov	r2, r4
 80044c6:	2101      	movs	r1, #1
 80044c8:	2002      	movs	r0, #2
 80044ca:	f01a fe87 	bl	801f1dc <traceIF_uartPrint>
    p_modem_ctxt->persist.ping_resp_urc.ttl = (uint8_t)ttl;
 80044ce:	f889 a5a8 	strb.w	sl, [r9, #1448]	; 0x5a8
    p_modem_ctxt->persist.ping_resp_urc.ping_status = CELLULAR_OK;
 80044d2:	2300      	movs	r3, #0
 80044d4:	f889 355d 	strb.w	r3, [r9, #1373]	; 0x55d
 80044d8:	e758      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
 80044da:	bf00      	nop
 80044dc:	0802b700 	.word	0x0802b700
 80044e0:	200048dc 	.word	0x200048dc
 80044e4:	0802b72c 	.word	0x0802b72c
 80044e8:	0802b768 	.word	0x0802b768
 80044ec:	0802b780 	.word	0x0802b780
 80044f0:	0802b744 	.word	0x0802b744

080044f4 <reinitSyntaxAutomaton_TYPE1SC>:
}

/* Private function Definition -----------------------------------------------*/
static void reinitSyntaxAutomaton_TYPE1SC(void)
{
  TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_INIT_CR;
 80044f4:	4b01      	ldr	r3, [pc, #4]	; (80044fc <reinitSyntaxAutomaton_TYPE1SC+0x8>)
 80044f6:	2200      	movs	r2, #0
 80044f8:	721a      	strb	r2, [r3, #8]
}
 80044fa:	4770      	bx	lr
 80044fc:	20001084 	.word	0x20001084

08004500 <reset_variables_TYPE1SC>:

static void reset_variables_TYPE1SC(void)
{
  /* Set default values of TYPE1SC specific variables after SWITCH ON or RESET */
  type1sc_shared.wait_for_modem_low_power_ack = false;
 8004500:	4b05      	ldr	r3, [pc, #20]	; (8004518 <reset_variables_TYPE1SC+0x18>)
 8004502:	2200      	movs	r2, #0
 8004504:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  type1sc_shared.modem_in_low_power_state = false;
 8004508:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  type1sc_shared.modem_waiting_for_bootev = false;
 800450c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  type1sc_shared.modem_bootev_received = false;
 8004510:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
}
 8004514:	4770      	bx	lr
 8004516:	bf00      	nop
 8004518:	20001838 	.word	0x20001838

0800451c <init_type1sc_low_power>:

static at_bool_t init_type1sc_low_power(void)
{
  at_bool_t lp_enabled;

  if (TYPE1SC_ctxt.SID_ctxt.init_power_config.low_power_enable == CELLULAR_TRUE)
 800451c:	4b0f      	ldr	r3, [pc, #60]	; (800455c <init_type1sc_low_power+0x40>)
 800451e:	f893 3718 	ldrb.w	r3, [r3, #1816]	; 0x718
 8004522:	2b01      	cmp	r3, #1
 8004524:	d004      	beq.n	8004530 <init_type1sc_low_power+0x14>

  }
  else
  {
    /* this parameter is used in CGREG/CEREG to not enable PSM (value = 2) */
    TYPE1SC_ctxt.persist.psm_urc_requested = AT_FALSE;
 8004526:	2000      	movs	r0, #0
 8004528:	4b0c      	ldr	r3, [pc, #48]	; (800455c <init_type1sc_low_power+0x40>)
 800452a:	f883 050d 	strb.w	r0, [r3, #1293]	; 0x50d
    /* do not send PSM and EDRX commands */
    lp_enabled = AT_FALSE;
  }

  return (lp_enabled);
}
 800452e:	4770      	bx	lr
    TYPE1SC_ctxt.persist.psm_urc_requested = AT_TRUE;
 8004530:	4b0a      	ldr	r3, [pc, #40]	; (800455c <init_type1sc_low_power+0x40>)
 8004532:	2001      	movs	r0, #1
 8004534:	f883 050d 	strb.w	r0, [r3, #1293]	; 0x50d
    TYPE1SC_ctxt.SID_ctxt.set_power_config.psm_present = CELLULAR_TRUE;
 8004538:	f883 071f 	strb.w	r0, [r3, #1823]	; 0x71f
    TYPE1SC_ctxt.SID_ctxt.set_power_config.psm_mode = PSM_MODE_ENABLE;
 800453c:	f883 0721 	strb.w	r0, [r3, #1825]	; 0x721
    (void) memcpy((void *) &TYPE1SC_ctxt.SID_ctxt.set_power_config.psm,
 8004540:	f8d3 2719 	ldr.w	r2, [r3, #1817]	; 0x719
 8004544:	f8c3 2722 	str.w	r2, [r3, #1826]	; 0x722
    TYPE1SC_ctxt.SID_ctxt.set_power_config.edrx_present = CELLULAR_TRUE;
 8004548:	f883 0720 	strb.w	r0, [r3, #1824]	; 0x720
    TYPE1SC_ctxt.SID_ctxt.set_power_config.edrx_mode = EDRX_MODE_DISABLE;
 800454c:	2200      	movs	r2, #0
 800454e:	f883 2726 	strb.w	r2, [r3, #1830]	; 0x726
    (void) memcpy((void *) &TYPE1SC_ctxt.SID_ctxt.set_power_config.edrx,
 8004552:	f8b3 271d 	ldrh.w	r2, [r3, #1821]	; 0x71d
 8004556:	f8a3 2727 	strh.w	r2, [r3, #1831]	; 0x727
    lp_enabled = AT_TRUE;
 800455a:	4770      	bx	lr
 800455c:	20001084 	.word	0x20001084

08004560 <low_power_state_requested>:

static void low_power_state_requested(void)
{
  /* activate interrupt detection for RING */
  type1sc_shared.wait_for_modem_low_power_ack = true;
 8004560:	4b02      	ldr	r3, [pc, #8]	; (800456c <low_power_state_requested+0xc>)
 8004562:	2201      	movs	r2, #1
 8004564:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
}
 8004568:	4770      	bx	lr
 800456a:	bf00      	nop
 800456c:	20001838 	.word	0x20001838

08004570 <low_power_state_enter>:

static void low_power_state_enter(void)
{
  type1sc_shared.modem_in_low_power_state = true;
 8004570:	4b03      	ldr	r3, [pc, #12]	; (8004580 <low_power_state_enter+0x10>)
 8004572:	2201      	movs	r2, #1
 8004574:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  type1sc_shared.wait_for_modem_low_power_ack = false;
 8004578:	2200      	movs	r2, #0
 800457a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
}
 800457e:	4770      	bx	lr
 8004580:	20001838 	.word	0x20001838

08004584 <low_power_state_cancel>:

static void low_power_state_cancel(void)
{
  type1sc_shared.modem_in_low_power_state = false;
 8004584:	4b03      	ldr	r3, [pc, #12]	; (8004594 <low_power_state_cancel+0x10>)
 8004586:	2200      	movs	r2, #0
 8004588:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  type1sc_shared.wait_for_modem_low_power_ack = false;
 800458c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
}
 8004590:	4770      	bx	lr
 8004592:	bf00      	nop
 8004594:	20001838 	.word	0x20001838

08004598 <is_waiting_modem_low_power_ack>:

static bool is_waiting_modem_low_power_ack(void)
{
  return (type1sc_shared.wait_for_modem_low_power_ack == true);
}
 8004598:	4b01      	ldr	r3, [pc, #4]	; (80045a0 <is_waiting_modem_low_power_ack+0x8>)
 800459a:	f893 0043 	ldrb.w	r0, [r3, #67]	; 0x43
 800459e:	4770      	bx	lr
 80045a0:	20001838 	.word	0x20001838

080045a4 <is_modem_in_low_power_state>:

static bool is_modem_in_low_power_state(void)
{
  return (type1sc_shared.modem_in_low_power_state == true);
}
 80045a4:	4b01      	ldr	r3, [pc, #4]	; (80045ac <is_modem_in_low_power_state+0x8>)
 80045a6:	f893 0044 	ldrb.w	r0, [r3, #68]	; 0x44
 80045aa:	4770      	bx	lr
 80045ac:	20001838 	.word	0x20001838

080045b0 <type1sc_modem_init>:
{
 80045b0:	b570      	push	{r4, r5, r6, lr}
 80045b2:	4606      	mov	r6, r0
  PRINT_API("enter type1sc_modem_init")
 80045b4:	4d1d      	ldr	r5, [pc, #116]	; (800462c <type1sc_modem_init+0x7c>)
 80045b6:	4c1e      	ldr	r4, [pc, #120]	; (8004630 <type1sc_modem_init+0x80>)
 80045b8:	f105 0e20 	add.w	lr, r5, #32
 80045bc:	46ac      	mov	ip, r5
 80045be:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80045c2:	6020      	str	r0, [r4, #0]
 80045c4:	6061      	str	r1, [r4, #4]
 80045c6:	60a2      	str	r2, [r4, #8]
 80045c8:	60e3      	str	r3, [r4, #12]
 80045ca:	4665      	mov	r5, ip
 80045cc:	3410      	adds	r4, #16
 80045ce:	45f4      	cmp	ip, lr
 80045d0:	d1f4      	bne.n	80045bc <type1sc_modem_init+0xc>
 80045d2:	f8dc 0000 	ldr.w	r0, [ip]
 80045d6:	6020      	str	r0, [r4, #0]
 80045d8:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 80045dc:	f89c 3006 	ldrb.w	r3, [ip, #6]
 80045e0:	80a2      	strh	r2, [r4, #4]
 80045e2:	71a3      	strb	r3, [r4, #6]
 80045e4:	4c12      	ldr	r4, [pc, #72]	; (8004630 <type1sc_modem_init+0x80>)
 80045e6:	4620      	mov	r0, r4
 80045e8:	f01a fd93 	bl	801f112 <crs_strlen>
 80045ec:	b283      	uxth	r3, r0
 80045ee:	4622      	mov	r2, r4
 80045f0:	2104      	movs	r1, #4
 80045f2:	2002      	movs	r0, #2
 80045f4:	f01a fdd0 	bl	801f198 <traceIF_itmPrint>
 80045f8:	4620      	mov	r0, r4
 80045fa:	f01a fd8a 	bl	801f112 <crs_strlen>
 80045fe:	b283      	uxth	r3, r0
 8004600:	4622      	mov	r2, r4
 8004602:	2104      	movs	r1, #4
 8004604:	2002      	movs	r0, #2
 8004606:	f01a fde9 	bl	801f1dc <traceIF_uartPrint>
  atcm_modem_init(p_modem_ctxt);
 800460a:	4630      	mov	r0, r6
 800460c:	f009 ff38 	bl	800e480 <atcm_modem_init>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004610:	2300      	movs	r3, #0
 8004612:	e007      	b.n	8004624 <type1sc_modem_init+0x74>
    p_tmp->socket_connId_value = ((uint8_t)UNDEFINED_MODEM_SOCKET_ID);
 8004614:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8004618:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 800461c:	21ff      	movs	r1, #255	; 0xff
 800461e:	7151      	strb	r1, [r2, #5]
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004620:	3301      	adds	r3, #1
 8004622:	b2db      	uxtb	r3, r3
 8004624:	2b05      	cmp	r3, #5
 8004626:	d9f5      	bls.n	8004614 <type1sc_modem_init+0x64>
}
 8004628:	bd70      	pop	{r4, r5, r6, pc}
 800462a:	bf00      	nop
 800462c:	0802b7c0 	.word	0x0802b7c0
 8004630:	200048dc 	.word	0x200048dc

08004634 <type1sc_modem_reset>:
{
 8004634:	b570      	push	{r4, r5, r6, lr}
 8004636:	4606      	mov	r6, r0
  PRINT_API("enter type1sc_modem_reset")
 8004638:	4d1a      	ldr	r5, [pc, #104]	; (80046a4 <type1sc_modem_reset+0x70>)
 800463a:	4c1b      	ldr	r4, [pc, #108]	; (80046a8 <type1sc_modem_reset+0x74>)
 800463c:	f105 0e20 	add.w	lr, r5, #32
 8004640:	46ac      	mov	ip, r5
 8004642:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004646:	6020      	str	r0, [r4, #0]
 8004648:	6061      	str	r1, [r4, #4]
 800464a:	60a2      	str	r2, [r4, #8]
 800464c:	60e3      	str	r3, [r4, #12]
 800464e:	4665      	mov	r5, ip
 8004650:	3410      	adds	r4, #16
 8004652:	45f4      	cmp	ip, lr
 8004654:	d1f4      	bne.n	8004640 <type1sc_modem_reset+0xc>
 8004656:	cd03      	ldmia	r5!, {r0, r1}
 8004658:	6020      	str	r0, [r4, #0]
 800465a:	6061      	str	r1, [r4, #4]
 800465c:	4c12      	ldr	r4, [pc, #72]	; (80046a8 <type1sc_modem_reset+0x74>)
 800465e:	4620      	mov	r0, r4
 8004660:	f01a fd57 	bl	801f112 <crs_strlen>
 8004664:	b283      	uxth	r3, r0
 8004666:	4622      	mov	r2, r4
 8004668:	2104      	movs	r1, #4
 800466a:	2002      	movs	r0, #2
 800466c:	f01a fd94 	bl	801f198 <traceIF_itmPrint>
 8004670:	4620      	mov	r0, r4
 8004672:	f01a fd4e 	bl	801f112 <crs_strlen>
 8004676:	b283      	uxth	r3, r0
 8004678:	4622      	mov	r2, r4
 800467a:	2104      	movs	r1, #4
 800467c:	2002      	movs	r0, #2
 800467e:	f01a fdad 	bl	801f1dc <traceIF_uartPrint>
  atcm_modem_reset(p_modem_ctxt);
 8004682:	4630      	mov	r0, r6
 8004684:	f009 ff3c 	bl	800e500 <atcm_modem_reset>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004688:	2300      	movs	r3, #0
 800468a:	e007      	b.n	800469c <type1sc_modem_reset+0x68>
    p_tmp->socket_connId_value = ((uint8_t)UNDEFINED_MODEM_SOCKET_ID);
 800468c:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8004690:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8004694:	21ff      	movs	r1, #255	; 0xff
 8004696:	7151      	strb	r1, [r2, #5]
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004698:	3301      	adds	r3, #1
 800469a:	b2db      	uxtb	r3, r3
 800469c:	2b05      	cmp	r3, #5
 800469e:	d9f5      	bls.n	800468c <type1sc_modem_reset+0x58>
}
 80046a0:	bd70      	pop	{r4, r5, r6, pc}
 80046a2:	bf00      	nop
 80046a4:	0802b7e8 	.word	0x0802b7e8
 80046a8:	200048dc 	.word	0x200048dc

080046ac <ATCustom_TYPE1SC_init>:
{
 80046ac:	b538      	push	{r3, r4, r5, lr}
 80046ae:	4604      	mov	r4, r0
  type1sc_modem_init(&TYPE1SC_ctxt);
 80046b0:	4d06      	ldr	r5, [pc, #24]	; (80046cc <ATCustom_TYPE1SC_init+0x20>)
 80046b2:	4628      	mov	r0, r5
 80046b4:	f7ff ff7c 	bl	80045b0 <type1sc_modem_init>
  TYPE1SC_ctxt.modem_LUT_size = SIZE_ATCMD_TYPE1SC_LUT;
 80046b8:	2349      	movs	r3, #73	; 0x49
 80046ba:	602b      	str	r3, [r5, #0]
  TYPE1SC_ctxt.p_modem_LUT = (const atcustom_LUT_t *)ATCMD_TYPE1SC_LUT;
 80046bc:	4b04      	ldr	r3, [pc, #16]	; (80046d0 <ATCustom_TYPE1SC_init+0x24>)
 80046be:	606b      	str	r3, [r5, #4]
  (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->endstr, "\r");
 80046c0:	4b04      	ldr	r3, [pc, #16]	; (80046d4 <ATCustom_TYPE1SC_init+0x28>)
 80046c2:	881b      	ldrh	r3, [r3, #0]
 80046c4:	f8a4 3674 	strh.w	r3, [r4, #1652]	; 0x674
}
 80046c8:	bd38      	pop	{r3, r4, r5, pc}
 80046ca:	bf00      	nop
 80046cc:	20001084 	.word	0x20001084
 80046d0:	0802be8c 	.word	0x0802be8c
 80046d4:	08032b40 	.word	0x08032b40

080046d8 <ATCustom_TYPE1SC_checkEndOfMsgCallback>:
{
 80046d8:	4603      	mov	r3, r0
  if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_INIT_CR)
 80046da:	4a16      	ldr	r2, [pc, #88]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 80046dc:	7a10      	ldrb	r0, [r2, #8]
 80046de:	b930      	cbnz	r0, 80046ee <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x16>
    if ((AT_CHAR_t)('\r') == rxChar)
 80046e0:	2b0d      	cmp	r3, #13
 80046e2:	d000      	beq.n	80046e6 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0xe>
}
 80046e4:	4770      	bx	lr
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_LF;
 80046e6:	4613      	mov	r3, r2
 80046e8:	2203      	movs	r2, #3
 80046ea:	721a      	strb	r2, [r3, #8]
 80046ec:	4770      	bx	lr
  else if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_CR)
 80046ee:	2802      	cmp	r0, #2
 80046f0:	d006      	beq.n	8004700 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x28>
  else if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_LF)
 80046f2:	2803      	cmp	r0, #3
 80046f4:	d00d      	beq.n	8004712 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x3a>
  else if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_FIRST_CHAR)
 80046f6:	2801      	cmp	r0, #1
 80046f8:	d013      	beq.n	8004722 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x4a>
    __NOP();
 80046fa:	bf00      	nop
  uint8_t last_char = 0U;
 80046fc:	2000      	movs	r0, #0
 80046fe:	4770      	bx	lr
    if ((AT_CHAR_t)('\r') == rxChar)
 8004700:	2b0d      	cmp	r3, #13
 8004702:	d001      	beq.n	8004708 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x30>
  uint8_t last_char = 0U;
 8004704:	2000      	movs	r0, #0
 8004706:	4770      	bx	lr
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_LF;
 8004708:	4b0a      	ldr	r3, [pc, #40]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 800470a:	2203      	movs	r2, #3
 800470c:	721a      	strb	r2, [r3, #8]
  uint8_t last_char = 0U;
 800470e:	2000      	movs	r0, #0
 8004710:	4770      	bx	lr
    if ((AT_CHAR_t)('\n') == rxChar)
 8004712:	2b0a      	cmp	r3, #10
 8004714:	d001      	beq.n	800471a <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x42>
  uint8_t last_char = 0U;
 8004716:	2000      	movs	r0, #0
 8004718:	4770      	bx	lr
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_FIRST_CHAR;
 800471a:	2001      	movs	r0, #1
 800471c:	4b05      	ldr	r3, [pc, #20]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 800471e:	7218      	strb	r0, [r3, #8]
      last_char = 1U;
 8004720:	4770      	bx	lr
    if ((AT_CHAR_t)('\r') == rxChar)
 8004722:	2b0d      	cmp	r3, #13
 8004724:	d001      	beq.n	800472a <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x52>
  uint8_t last_char = 0U;
 8004726:	2000      	movs	r0, #0
 8004728:	e7dc      	b.n	80046e4 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0xc>
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_LF;
 800472a:	4b02      	ldr	r3, [pc, #8]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 800472c:	2203      	movs	r2, #3
 800472e:	721a      	strb	r2, [r3, #8]
  uint8_t last_char = 0U;
 8004730:	2000      	movs	r0, #0
 8004732:	4770      	bx	lr
 8004734:	20001084 	.word	0x20001084

08004738 <ATCustom_TYPE1SC_getCmd>:
{
 8004738:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800473c:	b083      	sub	sp, #12
 800473e:	4605      	mov	r5, r0
 8004740:	460e      	mov	r6, r1
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
 8004742:	f100 0810 	add.w	r8, r0, #16
  at_msg_t curSID = p_atp_ctxt->current_SID;
 8004746:	8a07      	ldrh	r7, [r0, #16]
  PRINT_API("enter ATCustom_TYPE1SC_getCmd() for SID %d", curSID)
 8004748:	4ca7      	ldr	r4, [pc, #668]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 800474a:	463a      	mov	r2, r7
 800474c:	49a7      	ldr	r1, [pc, #668]	; (80049ec <ATCustom_TYPE1SC_getCmd+0x2b4>)
 800474e:	4620      	mov	r0, r4
 8004750:	f021 fa8e 	bl	8025c70 <sprintf>
 8004754:	4620      	mov	r0, r4
 8004756:	f01a fcdc 	bl	801f112 <crs_strlen>
 800475a:	b283      	uxth	r3, r0
 800475c:	4622      	mov	r2, r4
 800475e:	2104      	movs	r1, #4
 8004760:	2002      	movs	r0, #2
 8004762:	f01a fd19 	bl	801f198 <traceIF_itmPrint>
 8004766:	4620      	mov	r0, r4
 8004768:	f01a fcd3 	bl	801f112 <crs_strlen>
 800476c:	b283      	uxth	r3, r0
 800476e:	4622      	mov	r2, r4
 8004770:	2104      	movs	r1, #4
 8004772:	2002      	movs	r0, #2
 8004774:	f01a fd32 	bl	801f1dc <traceIF_uartPrint>
  if (atcm_retrieve_SID_parameters(&TYPE1SC_ctxt, p_atp_ctxt) != ATSTATUS_OK)
 8004778:	4641      	mov	r1, r8
 800477a:	489d      	ldr	r0, [pc, #628]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 800477c:	f008 fef2 	bl	800d564 <atcm_retrieve_SID_parameters>
 8004780:	b120      	cbz	r0, 800478c <ATCustom_TYPE1SC_getCmd+0x54>
    retval = ATSTATUS_ERROR;
 8004782:	2401      	movs	r4, #1
}
 8004784:	4620      	mov	r0, r4
 8004786:	b003      	add	sp, #12
 8004788:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800478c:	4604      	mov	r4, r0
  atcm_reset_CMD_context(&TYPE1SC_ctxt.CMD_ctxt);
 800478e:	4899      	ldr	r0, [pc, #612]	; (80049f4 <ATCustom_TYPE1SC_getCmd+0x2bc>)
 8004790:	f008 fda4 	bl	800d2dc <atcm_reset_CMD_context>
  if (curSID == (at_msg_t) SID_CS_CHECK_CNX)
 8004794:	2f64      	cmp	r7, #100	; 0x64
 8004796:	d030      	beq.n	80047fa <ATCustom_TYPE1SC_getCmd+0xc2>
  else if (curSID == (at_msg_t) SID_CS_MODEM_CONFIG)
 8004798:	f1a7 0365 	sub.w	r3, r7, #101	; 0x65
 800479c:	2b29      	cmp	r3, #41	; 0x29
 800479e:	f200 8799 	bhi.w	80056d4 <ATCustom_TYPE1SC_getCmd+0xf9c>
 80047a2:	e8df f013 	tbh	[pc, r3, lsl #1]
 80047a6:	004c      	.short	0x004c
 80047a8:	02cf02b4 	.word	0x02cf02b4
 80047ac:	04140373 	.word	0x04140373
 80047b0:	04a6047e 	.word	0x04a6047e
 80047b4:	04070456 	.word	0x04070456
 80047b8:	052203fa 	.word	0x052203fa
 80047bc:	051004ff 	.word	0x051004ff
 80047c0:	04ce0533 	.word	0x04ce0533
 80047c4:	057004e6 	.word	0x057004e6
 80047c8:	056b0545 	.word	0x056b0545
 80047cc:	057f0797 	.word	0x057f0797
 80047d0:	060505d3 	.word	0x060505d3
 80047d4:	06140605 	.word	0x06140605
 80047d8:	0665063f 	.word	0x0665063f
 80047dc:	0630004c 	.word	0x0630004c
 80047e0:	0736003f 	.word	0x0736003f
 80047e4:	0745074a 	.word	0x0745074a
 80047e8:	0776075f 	.word	0x0776075f
 80047ec:	06740788 	.word	0x06740788
 80047f0:	06ea06bb 	.word	0x06ea06bb
 80047f4:	07100702 	.word	0x07100702
 80047f8:	0721      	.short	0x0721
    if (p_atp_ctxt->step == 0U)
 80047fa:	7cac      	ldrb	r4, [r5, #18]
 80047fc:	b14c      	cbz	r4, 8004812 <ATCustom_TYPE1SC_getCmd+0xda>
      retval = ATSTATUS_ERROR;
 80047fe:	2401      	movs	r4, #1
  if (retval == ATSTATUS_OK)
 8004800:	2c00      	cmp	r4, #0
 8004802:	d1bf      	bne.n	8004784 <ATCustom_TYPE1SC_getCmd+0x4c>
    retval = atcm_modem_build_cmd(&TYPE1SC_ctxt, p_atp_ctxt, p_ATcmdTimeout);
 8004804:	4632      	mov	r2, r6
 8004806:	4641      	mov	r1, r8
 8004808:	4879      	ldr	r0, [pc, #484]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 800480a:	f008 f995 	bl	800cb38 <atcm_modem_build_cmd>
 800480e:	4604      	mov	r4, r0
 8004810:	e7b8      	b.n	8004784 <ATCustom_TYPE1SC_getCmd+0x4c>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT, FINAL_CMD);
 8004812:	2301      	movs	r3, #1
 8004814:	9300      	str	r3, [sp, #0]
 8004816:	2300      	movs	r3, #0
 8004818:	2204      	movs	r2, #4
 800481a:	4641      	mov	r1, r8
 800481c:	4874      	ldr	r0, [pc, #464]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 800481e:	f008 f917 	bl	800ca50 <atcm_program_AT_CMD>
 8004822:	e7ed      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004824:	7cac      	ldrb	r4, [r5, #18]
 8004826:	b10c      	cbz	r4, 800482c <ATCustom_TYPE1SC_getCmd+0xf4>
      retval = ATSTATUS_ERROR;
 8004828:	2401      	movs	r4, #1
 800482a:	e7e9      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT, FINAL_CMD);
 800482c:	2301      	movs	r3, #1
 800482e:	9300      	str	r3, [sp, #0]
 8004830:	2300      	movs	r3, #0
 8004832:	2204      	movs	r2, #4
 8004834:	4641      	mov	r1, r8
 8004836:	486e      	ldr	r0, [pc, #440]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 8004838:	f008 f90a 	bl	800ca50 <atcm_program_AT_CMD>
 800483c:	e7e0      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if ((curSID == (at_msg_t) SID_CS_RESET) && (TYPE1SC_ctxt.SID_ctxt.reset_type != CS_RESET_HW))
 800483e:	2f80      	cmp	r7, #128	; 0x80
 8004840:	d034      	beq.n	80048ac <ATCustom_TYPE1SC_getCmd+0x174>
      if (p_atp_ctxt->step == 0U)
 8004842:	f895 9012 	ldrb.w	r9, [r5, #18]
 8004846:	f1b9 0f00 	cmp.w	r9, #0
 800484a:	d04d      	beq.n	80048e8 <ATCustom_TYPE1SC_getCmd+0x1b0>
      else if ((p_atp_ctxt->step >= 1U) && (p_atp_ctxt->step < TYPE1SC_MODEM_SYNCHRO_AT_MAX_RETRIES))
 800484c:	f109 33ff 	add.w	r3, r9, #4294967295
 8004850:	b2db      	uxtb	r3, r3
 8004852:	2b1c      	cmp	r3, #28
 8004854:	d87b      	bhi.n	800494e <ATCustom_TYPE1SC_getCmd+0x216>
        if (p_atp_ctxt->step >= 11U)
 8004856:	f1b9 0f0a 	cmp.w	r9, #10
 800485a:	d902      	bls.n	8004862 <ATCustom_TYPE1SC_getCmd+0x12a>
          reprogram_bdelay = true;
 800485c:	4b66      	ldr	r3, [pc, #408]	; (80049f8 <ATCustom_TYPE1SC_getCmd+0x2c0>)
 800485e:	2201      	movs	r2, #1
 8004860:	701a      	strb	r2, [r3, #0]
        if (TYPE1SC_ctxt.persist.modem_at_ready == AT_FALSE)
 8004862:	4b63      	ldr	r3, [pc, #396]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 8004864:	f893 350e 	ldrb.w	r3, [r3, #1294]	; 0x50e
 8004868:	2b00      	cmp	r3, #0
 800486a:	d152      	bne.n	8004912 <ATCustom_TYPE1SC_getCmd+0x1da>
          PRINT_DBG("test connection [try number %d] ", p_atp_ctxt->step)
 800486c:	4d5e      	ldr	r5, [pc, #376]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 800486e:	464a      	mov	r2, r9
 8004870:	4962      	ldr	r1, [pc, #392]	; (80049fc <ATCustom_TYPE1SC_getCmd+0x2c4>)
 8004872:	4628      	mov	r0, r5
 8004874:	f021 f9fc 	bl	8025c70 <sprintf>
 8004878:	4628      	mov	r0, r5
 800487a:	f01a fc4a 	bl	801f112 <crs_strlen>
 800487e:	b283      	uxth	r3, r0
 8004880:	462a      	mov	r2, r5
 8004882:	2102      	movs	r1, #2
 8004884:	4608      	mov	r0, r1
 8004886:	f01a fc87 	bl	801f198 <traceIF_itmPrint>
 800488a:	4628      	mov	r0, r5
 800488c:	f01a fc41 	bl	801f112 <crs_strlen>
 8004890:	b283      	uxth	r3, r0
 8004892:	462a      	mov	r2, r5
 8004894:	2102      	movs	r1, #2
 8004896:	4608      	mov	r0, r1
 8004898:	f01a fca0 	bl	801f1dc <traceIF_uartPrint>
          atcm_program_AT_CMD_ANSWER_OPTIONAL(&TYPE1SC_ctxt, p_atp_ctxt,
 800489c:	2300      	movs	r3, #0
 800489e:	9300      	str	r3, [sp, #0]
 80048a0:	2204      	movs	r2, #4
 80048a2:	4641      	mov	r1, r8
 80048a4:	4852      	ldr	r0, [pc, #328]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 80048a6:	f008 f8e5 	bl	800ca74 <atcm_program_AT_CMD_ANSWER_OPTIONAL>
 80048aa:	e7a9      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if ((curSID == (at_msg_t) SID_CS_RESET) && (TYPE1SC_ctxt.SID_ctxt.reset_type != CS_RESET_HW))
 80048ac:	4b50      	ldr	r3, [pc, #320]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 80048ae:	f893 26c8 	ldrb.w	r2, [r3, #1736]	; 0x6c8
 80048b2:	2a01      	cmp	r2, #1
 80048b4:	d0c5      	beq.n	8004842 <ATCustom_TYPE1SC_getCmd+0x10a>
      PRINT_ERR("Reset type (%d) not supported", TYPE1SC_ctxt.SID_ctxt.reset_type)
 80048b6:	4c4c      	ldr	r4, [pc, #304]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 80048b8:	4951      	ldr	r1, [pc, #324]	; (8004a00 <ATCustom_TYPE1SC_getCmd+0x2c8>)
 80048ba:	4620      	mov	r0, r4
 80048bc:	f021 f9d8 	bl	8025c70 <sprintf>
 80048c0:	4620      	mov	r0, r4
 80048c2:	f01a fc26 	bl	801f112 <crs_strlen>
 80048c6:	b283      	uxth	r3, r0
 80048c8:	4622      	mov	r2, r4
 80048ca:	2110      	movs	r1, #16
 80048cc:	2002      	movs	r0, #2
 80048ce:	f01a fc63 	bl	801f198 <traceIF_itmPrint>
 80048d2:	4620      	mov	r0, r4
 80048d4:	f01a fc1d 	bl	801f112 <crs_strlen>
 80048d8:	b283      	uxth	r3, r0
 80048da:	4622      	mov	r2, r4
 80048dc:	2110      	movs	r1, #16
 80048de:	2002      	movs	r0, #2
 80048e0:	f01a fc7c 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 80048e4:	2401      	movs	r4, #1
 80048e6:	e78b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        reset_variables_TYPE1SC();
 80048e8:	f7ff fe0a 	bl	8004500 <reset_variables_TYPE1SC>
        TYPE1SC_ctxt.persist.modem_at_ready = AT_FALSE;
 80048ec:	4b40      	ldr	r3, [pc, #256]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 80048ee:	2200      	movs	r2, #0
 80048f0:	f883 250e 	strb.w	r2, [r3, #1294]	; 0x50e
        if (curSID == (at_msg_t) SID_CS_RESET)
 80048f4:	2f80      	cmp	r7, #128	; 0x80
 80048f6:	d008      	beq.n	800490a <ATCustom_TYPE1SC_getCmd+0x1d2>
        (void) SysCtrl_TYPE1SC_reinit_channel(p_at_ctxt->ipc_handle, SYSCTRL_HW_FLOW_CONTROL_NONE);
 80048f8:	2100      	movs	r1, #0
 80048fa:	6868      	ldr	r0, [r5, #4]
 80048fc:	f002 fad4 	bl	8006ea8 <SysCtrl_TYPE1SC_reinit_channel>
        atcm_program_SKIP_CMD(p_atp_ctxt);
 8004900:	4640      	mov	r0, r8
 8004902:	f008 f90d 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004906:	464c      	mov	r4, r9
 8004908:	e77a      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          type1sc_modem_reset(&TYPE1SC_ctxt);
 800490a:	4618      	mov	r0, r3
 800490c:	f7ff fe92 	bl	8004634 <type1sc_modem_reset>
 8004910:	e7f2      	b.n	80048f8 <ATCustom_TYPE1SC_getCmd+0x1c0>
          PRINT_INFO("modem synchro established, proceed to normal power sequence")
 8004912:	4f35      	ldr	r7, [pc, #212]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 8004914:	2246      	movs	r2, #70	; 0x46
 8004916:	493b      	ldr	r1, [pc, #236]	; (8004a04 <ATCustom_TYPE1SC_getCmd+0x2cc>)
 8004918:	4638      	mov	r0, r7
 800491a:	f021 faf9 	bl	8025f10 <memcpy>
 800491e:	4638      	mov	r0, r7
 8004920:	f01a fbf7 	bl	801f112 <crs_strlen>
 8004924:	b283      	uxth	r3, r0
 8004926:	463a      	mov	r2, r7
 8004928:	2101      	movs	r1, #1
 800492a:	2002      	movs	r0, #2
 800492c:	f01a fc34 	bl	801f198 <traceIF_itmPrint>
 8004930:	4638      	mov	r0, r7
 8004932:	f01a fbee 	bl	801f112 <crs_strlen>
 8004936:	b283      	uxth	r3, r0
 8004938:	463a      	mov	r2, r7
 800493a:	2101      	movs	r1, #1
 800493c:	2002      	movs	r0, #2
 800493e:	f01a fc4d 	bl	801f1dc <traceIF_uartPrint>
          p_atp_ctxt->step = common_start_sequence_step - 1U;
 8004942:	231e      	movs	r3, #30
 8004944:	74ab      	strb	r3, [r5, #18]
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004946:	4640      	mov	r0, r8
 8004948:	f008 f8ea 	bl	800cb20 <atcm_program_SKIP_CMD>
 800494c:	e758      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      else if (p_atp_ctxt->step == TYPE1SC_MODEM_SYNCHRO_AT_MAX_RETRIES)
 800494e:	f1b9 0f1e 	cmp.w	r9, #30
 8004952:	d059      	beq.n	8004a08 <ATCustom_TYPE1SC_getCmd+0x2d0>
      else if (p_atp_ctxt->step == (common_start_sequence_step))
 8004954:	f1b9 0f1f 	cmp.w	r9, #31
 8004958:	f000 8087 	beq.w	8004a6a <ATCustom_TYPE1SC_getCmd+0x332>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 1U))
 800495c:	f1b9 0f20 	cmp.w	r9, #32
 8004960:	f000 808e 	beq.w	8004a80 <ATCustom_TYPE1SC_getCmd+0x348>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 2U))
 8004964:	f1b9 0f21 	cmp.w	r9, #33	; 0x21
 8004968:	f000 8095 	beq.w	8004a96 <ATCustom_TYPE1SC_getCmd+0x35e>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 3U))
 800496c:	f1b9 0f22 	cmp.w	r9, #34	; 0x22
 8004970:	f000 809a 	beq.w	8004aa8 <ATCustom_TYPE1SC_getCmd+0x370>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 4U))
 8004974:	f1b9 0f23 	cmp.w	r9, #35	; 0x23
 8004978:	f000 80a2 	beq.w	8004ac0 <ATCustom_TYPE1SC_getCmd+0x388>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 5U))
 800497c:	f1b9 0f24 	cmp.w	r9, #36	; 0x24
 8004980:	f000 80a7 	beq.w	8004ad2 <ATCustom_TYPE1SC_getCmd+0x39a>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 6U))
 8004984:	f1b9 0f25 	cmp.w	r9, #37	; 0x25
 8004988:	f000 80b0 	beq.w	8004aec <ATCustom_TYPE1SC_getCmd+0x3b4>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 7U))
 800498c:	f1b9 0f26 	cmp.w	r9, #38	; 0x26
 8004990:	f000 80b9 	beq.w	8004b06 <ATCustom_TYPE1SC_getCmd+0x3ce>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 8U))
 8004994:	f1b9 0f27 	cmp.w	r9, #39	; 0x27
 8004998:	f000 80c2 	beq.w	8004b20 <ATCustom_TYPE1SC_getCmd+0x3e8>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 9U))
 800499c:	f1b9 0f28 	cmp.w	r9, #40	; 0x28
 80049a0:	f000 80cb 	beq.w	8004b3a <ATCustom_TYPE1SC_getCmd+0x402>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 10U))
 80049a4:	f1b9 0f29 	cmp.w	r9, #41	; 0x29
 80049a8:	f000 8125 	beq.w	8004bf6 <ATCustom_TYPE1SC_getCmd+0x4be>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 11U))
 80049ac:	f1b9 0f2a 	cmp.w	r9, #42	; 0x2a
 80049b0:	f000 8125 	beq.w	8004bfe <ATCustom_TYPE1SC_getCmd+0x4c6>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 12U))
 80049b4:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 80049b8:	f000 812a 	beq.w	8004c10 <ATCustom_TYPE1SC_getCmd+0x4d8>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 13U))
 80049bc:	f1b9 0f2c 	cmp.w	r9, #44	; 0x2c
 80049c0:	f000 8131 	beq.w	8004c26 <ATCustom_TYPE1SC_getCmd+0x4ee>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 14U))
 80049c4:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 80049c8:	f000 8135 	beq.w	8004c36 <ATCustom_TYPE1SC_getCmd+0x4fe>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 15U))
 80049cc:	f1b9 0f2e 	cmp.w	r9, #46	; 0x2e
 80049d0:	f000 813e 	beq.w	8004c50 <ATCustom_TYPE1SC_getCmd+0x518>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 16U))
 80049d4:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
 80049d8:	f000 8190 	beq.w	8004cfc <ATCustom_TYPE1SC_getCmd+0x5c4>
      else if (p_atp_ctxt->step >= (common_start_sequence_step + 17U))
 80049dc:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
 80049e0:	f67f af0e 	bls.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        retval = ATSTATUS_ERROR;
 80049e4:	2401      	movs	r4, #1
 80049e6:	e70b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 80049e8:	200048dc 	.word	0x200048dc
 80049ec:	0802b810 	.word	0x0802b810
 80049f0:	20001084 	.word	0x20001084
 80049f4:	200017b0 	.word	0x200017b0
 80049f8:	20001834 	.word	0x20001834
 80049fc:	0802b87c 	.word	0x0802b87c
 8004a00:	0802b84c 	.word	0x0802b84c
 8004a04:	0802b8a8 	.word	0x0802b8a8
        if (TYPE1SC_ctxt.persist.modem_at_ready == AT_FALSE)
 8004a08:	4bc5      	ldr	r3, [pc, #788]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004a0a:	f893 350e 	ldrb.w	r3, [r3, #1294]	; 0x50e
 8004a0e:	bb43      	cbnz	r3, 8004a62 <ATCustom_TYPE1SC_getCmd+0x32a>
          PRINT_ERR("Impossible to sync with modem")
 8004a10:	4cc4      	ldr	r4, [pc, #784]	; (8004d24 <ATCustom_TYPE1SC_getCmd+0x5ec>)
 8004a12:	4dc5      	ldr	r5, [pc, #788]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004a14:	f104 0c20 	add.w	ip, r4, #32
 8004a18:	4627      	mov	r7, r4
 8004a1a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004a1c:	6028      	str	r0, [r5, #0]
 8004a1e:	6069      	str	r1, [r5, #4]
 8004a20:	60aa      	str	r2, [r5, #8]
 8004a22:	60eb      	str	r3, [r5, #12]
 8004a24:	463c      	mov	r4, r7
 8004a26:	3510      	adds	r5, #16
 8004a28:	4567      	cmp	r7, ip
 8004a2a:	d1f5      	bne.n	8004a18 <ATCustom_TYPE1SC_getCmd+0x2e0>
 8004a2c:	cc07      	ldmia	r4!, {r0, r1, r2}
 8004a2e:	6028      	str	r0, [r5, #0]
 8004a30:	6069      	str	r1, [r5, #4]
 8004a32:	60aa      	str	r2, [r5, #8]
 8004a34:	8823      	ldrh	r3, [r4, #0]
 8004a36:	81ab      	strh	r3, [r5, #12]
 8004a38:	4cbb      	ldr	r4, [pc, #748]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004a3a:	4620      	mov	r0, r4
 8004a3c:	f01a fb69 	bl	801f112 <crs_strlen>
 8004a40:	b283      	uxth	r3, r0
 8004a42:	4622      	mov	r2, r4
 8004a44:	2110      	movs	r1, #16
 8004a46:	2002      	movs	r0, #2
 8004a48:	f01a fba6 	bl	801f198 <traceIF_itmPrint>
 8004a4c:	4620      	mov	r0, r4
 8004a4e:	f01a fb60 	bl	801f112 <crs_strlen>
 8004a52:	b283      	uxth	r3, r0
 8004a54:	4622      	mov	r2, r4
 8004a56:	2110      	movs	r1, #16
 8004a58:	2002      	movs	r0, #2
 8004a5a:	f01a fbbf 	bl	801f1dc <traceIF_uartPrint>
          retval = ATSTATUS_ERROR;
 8004a5e:	2401      	movs	r4, #1
 8004a60:	e6ce      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004a62:	4640      	mov	r0, r8
 8004a64:	f008 f85c 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004a68:	e6ca      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.CMD_ctxt.cfun_value = 0U;
 8004a6a:	48ad      	ldr	r0, [pc, #692]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004a6c:	2300      	movs	r3, #0
 8004a6e:	f880 373d 	strb.w	r3, [r0, #1853]	; 0x73d
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CFUN, INTERMEDIATE_CMD);
 8004a72:	9300      	str	r3, [sp, #0]
 8004a74:	2313      	movs	r3, #19
 8004a76:	2203      	movs	r2, #3
 8004a78:	4641      	mov	r1, r8
 8004a7a:	f007 ffe9 	bl	800ca50 <atcm_program_AT_CMD>
 8004a7e:	e6bf      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.CMD_ctxt.command_echo = AT_FALSE;
 8004a80:	48a7      	ldr	r0, [pc, #668]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004a82:	2300      	movs	r3, #0
 8004a84:	f880 372f 	strb.w	r3, [r0, #1839]	; 0x72f
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_ATE, INTERMEDIATE_CMD);
 8004a88:	9300      	str	r3, [sp, #0]
 8004a8a:	2328      	movs	r3, #40	; 0x28
 8004a8c:	2204      	movs	r2, #4
 8004a8e:	4641      	mov	r1, r8
 8004a90:	f007 ffde 	bl	800ca50 <atcm_program_AT_CMD>
 8004a94:	e6b4      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CMEE, INTERMEDIATE_CMD);
 8004a96:	2300      	movs	r3, #0
 8004a98:	9300      	str	r3, [sp, #0]
 8004a9a:	2311      	movs	r3, #17
 8004a9c:	2203      	movs	r2, #3
 8004a9e:	4641      	mov	r1, r8
 8004aa0:	489f      	ldr	r0, [pc, #636]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004aa2:	f007 ffd5 	bl	800ca50 <atcm_program_AT_CMD>
 8004aa6:	e6ab      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.CMD_ctxt.dce_full_resp_format = AT_TRUE;
 8004aa8:	489d      	ldr	r0, [pc, #628]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004aaa:	2301      	movs	r3, #1
 8004aac:	f880 3730 	strb.w	r3, [r0, #1840]	; 0x730
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_ATV, INTERMEDIATE_CMD);
 8004ab0:	2300      	movs	r3, #0
 8004ab2:	9300      	str	r3, [sp, #0]
 8004ab4:	232b      	movs	r3, #43	; 0x2b
 8004ab6:	2204      	movs	r2, #4
 8004ab8:	4641      	mov	r1, r8
 8004aba:	f007 ffc9 	bl	800ca50 <atcm_program_AT_CMD>
 8004abe:	e69f      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMR, INTERMEDIATE_CMD);
 8004ac0:	2300      	movs	r3, #0
 8004ac2:	9300      	str	r3, [sp, #0]
 8004ac4:	230d      	movs	r3, #13
 8004ac6:	2204      	movs	r2, #4
 8004ac8:	4641      	mov	r1, r8
 8004aca:	4895      	ldr	r0, [pc, #596]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004acc:	f007 ffc0 	bl	800ca50 <atcm_program_AT_CMD>
 8004ad0:	e696      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_BAND;
 8004ad2:	4b96      	ldr	r3, [pc, #600]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004ad4:	2202      	movs	r2, #2
 8004ad6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETCFG, INTERMEDIATE_CMD);
 8004ada:	2300      	movs	r3, #0
 8004adc:	9300      	str	r3, [sp, #0]
 8004ade:	233b      	movs	r3, #59	; 0x3b
 8004ae0:	2203      	movs	r2, #3
 8004ae2:	4641      	mov	r1, r8
 8004ae4:	488e      	ldr	r0, [pc, #568]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004ae6:	f007 ffb3 	bl	800ca50 <atcm_program_AT_CMD>
 8004aea:	e689      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_HIFC_MODE;
 8004aec:	4b8f      	ldr	r3, [pc, #572]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004aee:	2204      	movs	r2, #4
 8004af0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETACFG, INTERMEDIATE_CMD);
 8004af4:	2300      	movs	r3, #0
 8004af6:	9300      	str	r3, [sp, #0]
 8004af8:	233d      	movs	r3, #61	; 0x3d
 8004afa:	2203      	movs	r2, #3
 8004afc:	4641      	mov	r1, r8
 8004afe:	4888      	ldr	r0, [pc, #544]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b00:	f007 ffa6 	bl	800ca50 <atcm_program_AT_CMD>
 8004b04:	e67c      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_PMCONF_SLEEP_MODE;
 8004b06:	4b89      	ldr	r3, [pc, #548]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004b08:	2205      	movs	r2, #5
 8004b0a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETACFG, INTERMEDIATE_CMD);
 8004b0e:	2300      	movs	r3, #0
 8004b10:	9300      	str	r3, [sp, #0]
 8004b12:	233d      	movs	r3, #61	; 0x3d
 8004b14:	2203      	movs	r2, #3
 8004b16:	4641      	mov	r1, r8
 8004b18:	4881      	ldr	r0, [pc, #516]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b1a:	f007 ff99 	bl	800ca50 <atcm_program_AT_CMD>
 8004b1e:	e66f      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_PMCONF_MAX_ALLOWED;
 8004b20:	4b82      	ldr	r3, [pc, #520]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004b22:	2206      	movs	r2, #6
 8004b24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETACFG, INTERMEDIATE_CMD);
 8004b28:	2300      	movs	r3, #0
 8004b2a:	9300      	str	r3, [sp, #0]
 8004b2c:	233d      	movs	r3, #61	; 0x3d
 8004b2e:	2203      	movs	r2, #3
 8004b30:	4641      	mov	r1, r8
 8004b32:	487b      	ldr	r0, [pc, #492]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b34:	f007 ff8c 	bl	800ca50 <atcm_program_AT_CMD>
 8004b38:	e662      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        if (reprogram_bdelay == true)
 8004b3a:	4b7d      	ldr	r3, [pc, #500]	; (8004d30 <ATCustom_TYPE1SC_getCmd+0x5f8>)
 8004b3c:	781b      	ldrb	r3, [r3, #0]
 8004b3e:	b383      	cbz	r3, 8004ba2 <ATCustom_TYPE1SC_getCmd+0x46a>
          PRINT_INFO("Reprogram modem boot delay")
 8004b40:	4f7c      	ldr	r7, [pc, #496]	; (8004d34 <ATCustom_TYPE1SC_getCmd+0x5fc>)
 8004b42:	4d79      	ldr	r5, [pc, #484]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004b44:	f107 0e20 	add.w	lr, r7, #32
 8004b48:	46bc      	mov	ip, r7
 8004b4a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004b4e:	6028      	str	r0, [r5, #0]
 8004b50:	6069      	str	r1, [r5, #4]
 8004b52:	60aa      	str	r2, [r5, #8]
 8004b54:	60eb      	str	r3, [r5, #12]
 8004b56:	4667      	mov	r7, ip
 8004b58:	3510      	adds	r5, #16
 8004b5a:	45f4      	cmp	ip, lr
 8004b5c:	d1f4      	bne.n	8004b48 <ATCustom_TYPE1SC_getCmd+0x410>
 8004b5e:	f8dc 0000 	ldr.w	r0, [ip]
 8004b62:	6028      	str	r0, [r5, #0]
 8004b64:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8004b68:	712b      	strb	r3, [r5, #4]
 8004b6a:	4d6f      	ldr	r5, [pc, #444]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004b6c:	4628      	mov	r0, r5
 8004b6e:	f01a fad0 	bl	801f112 <crs_strlen>
 8004b72:	b283      	uxth	r3, r0
 8004b74:	462a      	mov	r2, r5
 8004b76:	2101      	movs	r1, #1
 8004b78:	2002      	movs	r0, #2
 8004b7a:	f01a fb0d 	bl	801f198 <traceIF_itmPrint>
 8004b7e:	4628      	mov	r0, r5
 8004b80:	f01a fac7 	bl	801f112 <crs_strlen>
 8004b84:	b283      	uxth	r3, r0
 8004b86:	462a      	mov	r2, r5
 8004b88:	2101      	movs	r1, #1
 8004b8a:	2002      	movs	r0, #2
 8004b8c:	f01a fb26 	bl	801f1dc <traceIF_uartPrint>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt,
 8004b90:	2300      	movs	r3, #0
 8004b92:	9300      	str	r3, [sp, #0]
 8004b94:	233e      	movs	r3, #62	; 0x3e
 8004b96:	2203      	movs	r2, #3
 8004b98:	4641      	mov	r1, r8
 8004b9a:	4861      	ldr	r0, [pc, #388]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b9c:	f007 ff58 	bl	800ca50 <atcm_program_AT_CMD>
 8004ba0:	e62e      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          PRINT_INFO("Do not reprogram modem boot delay")
 8004ba2:	4d65      	ldr	r5, [pc, #404]	; (8004d38 <ATCustom_TYPE1SC_getCmd+0x600>)
 8004ba4:	4f60      	ldr	r7, [pc, #384]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004ba6:	f105 0e20 	add.w	lr, r5, #32
 8004baa:	46ac      	mov	ip, r5
 8004bac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004bb0:	6038      	str	r0, [r7, #0]
 8004bb2:	6079      	str	r1, [r7, #4]
 8004bb4:	60ba      	str	r2, [r7, #8]
 8004bb6:	60fb      	str	r3, [r7, #12]
 8004bb8:	4665      	mov	r5, ip
 8004bba:	3710      	adds	r7, #16
 8004bbc:	45f4      	cmp	ip, lr
 8004bbe:	d1f4      	bne.n	8004baa <ATCustom_TYPE1SC_getCmd+0x472>
 8004bc0:	cd07      	ldmia	r5!, {r0, r1, r2}
 8004bc2:	6038      	str	r0, [r7, #0]
 8004bc4:	6079      	str	r1, [r7, #4]
 8004bc6:	60ba      	str	r2, [r7, #8]
 8004bc8:	4d57      	ldr	r5, [pc, #348]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004bca:	4628      	mov	r0, r5
 8004bcc:	f01a faa1 	bl	801f112 <crs_strlen>
 8004bd0:	b283      	uxth	r3, r0
 8004bd2:	462a      	mov	r2, r5
 8004bd4:	2101      	movs	r1, #1
 8004bd6:	2002      	movs	r0, #2
 8004bd8:	f01a fade 	bl	801f198 <traceIF_itmPrint>
 8004bdc:	4628      	mov	r0, r5
 8004bde:	f01a fa98 	bl	801f112 <crs_strlen>
 8004be2:	b283      	uxth	r3, r0
 8004be4:	462a      	mov	r2, r5
 8004be6:	2101      	movs	r1, #1
 8004be8:	2002      	movs	r0, #2
 8004bea:	f01a faf7 	bl	801f1dc <traceIF_uartPrint>
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004bee:	4640      	mov	r0, r8
 8004bf0:	f007 ff96 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004bf4:	e604      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_SKIP_CMD(p_atp_ctxt);
 8004bf6:	4640      	mov	r0, r8
 8004bf8:	f007 ff92 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004bfc:	e600      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_IFC, INTERMEDIATE_CMD);
 8004bfe:	2300      	movs	r3, #0
 8004c00:	9300      	str	r3, [sp, #0]
 8004c02:	2332      	movs	r3, #50	; 0x32
 8004c04:	2203      	movs	r2, #3
 8004c06:	4641      	mov	r1, r8
 8004c08:	4845      	ldr	r0, [pc, #276]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004c0a:	f007 ff21 	bl	800ca50 <atcm_program_AT_CMD>
 8004c0e:	e5f7      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        (void) SysCtrl_TYPE1SC_reinit_channel(p_at_ctxt->ipc_handle, SYSCTRL_HW_FLOW_CONTROL_RTS_CTS);
 8004c10:	2101      	movs	r1, #1
 8004c12:	6868      	ldr	r0, [r5, #4]
 8004c14:	f002 f948 	bl	8006ea8 <SysCtrl_TYPE1SC_reinit_channel>
        atcm_program_TEMPO(p_atp_ctxt, 3000U, INTERMEDIATE_CMD);
 8004c18:	2200      	movs	r2, #0
 8004c1a:	f640 31b8 	movw	r1, #3000	; 0xbb8
 8004c1e:	4640      	mov	r0, r8
 8004c20:	f007 ff46 	bl	800cab0 <atcm_program_TEMPO>
 8004c24:	e5ec      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD_ANSWER_OPTIONAL(&TYPE1SC_ctxt, p_atp_ctxt,
 8004c26:	2300      	movs	r3, #0
 8004c28:	9300      	str	r3, [sp, #0]
 8004c2a:	2204      	movs	r2, #4
 8004c2c:	4641      	mov	r1, r8
 8004c2e:	483c      	ldr	r0, [pc, #240]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004c30:	f007 ff20 	bl	800ca74 <atcm_program_AT_CMD_ANSWER_OPTIONAL>
 8004c34:	e5e4      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.setcfg_function = SETGETCFG_BOOT_EVENT_TRUE;
 8004c36:	4b3d      	ldr	r3, [pc, #244]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004c38:	2207      	movs	r2, #7
 8004c3a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SETACFG, INTERMEDIATE_CMD);
 8004c3e:	2300      	movs	r3, #0
 8004c40:	9300      	str	r3, [sp, #0]
 8004c42:	233c      	movs	r3, #60	; 0x3c
 8004c44:	2203      	movs	r2, #3
 8004c46:	4641      	mov	r1, r8
 8004c48:	4835      	ldr	r0, [pc, #212]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004c4a:	f007 ff01 	bl	800ca50 <atcm_program_AT_CMD>
 8004c4e:	e5d7      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        if (type1sc_shared.modem_bootev_received == true)
 8004c50:	4b36      	ldr	r3, [pc, #216]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004c52:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8004c56:	b1db      	cbz	r3, 8004c90 <ATCustom_TYPE1SC_getCmd+0x558>
          PRINT_INFO("***** BOOTEV already received, continue init sequence *****")
 8004c58:	4d33      	ldr	r5, [pc, #204]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004c5a:	2246      	movs	r2, #70	; 0x46
 8004c5c:	4937      	ldr	r1, [pc, #220]	; (8004d3c <ATCustom_TYPE1SC_getCmd+0x604>)
 8004c5e:	4628      	mov	r0, r5
 8004c60:	f021 f956 	bl	8025f10 <memcpy>
 8004c64:	4628      	mov	r0, r5
 8004c66:	f01a fa54 	bl	801f112 <crs_strlen>
 8004c6a:	b283      	uxth	r3, r0
 8004c6c:	462a      	mov	r2, r5
 8004c6e:	2101      	movs	r1, #1
 8004c70:	2002      	movs	r0, #2
 8004c72:	f01a fa91 	bl	801f198 <traceIF_itmPrint>
 8004c76:	4628      	mov	r0, r5
 8004c78:	f01a fa4b 	bl	801f112 <crs_strlen>
 8004c7c:	b283      	uxth	r3, r0
 8004c7e:	462a      	mov	r2, r5
 8004c80:	2101      	movs	r1, #1
 8004c82:	2002      	movs	r0, #2
 8004c84:	f01a faaa 	bl	801f1dc <traceIF_uartPrint>
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004c88:	4640      	mov	r0, r8
 8004c8a:	f007 ff49 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004c8e:	e5b7      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          type1sc_shared.modem_waiting_for_bootev = true;
 8004c90:	4b26      	ldr	r3, [pc, #152]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004c92:	2201      	movs	r2, #1
 8004c94:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
          PRINT_INFO("***** wait for optional BOOTEV *****")
 8004c98:	4d29      	ldr	r5, [pc, #164]	; (8004d40 <ATCustom_TYPE1SC_getCmd+0x608>)
 8004c9a:	4f23      	ldr	r7, [pc, #140]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004c9c:	f105 0e20 	add.w	lr, r5, #32
 8004ca0:	46ac      	mov	ip, r5
 8004ca2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004ca6:	6038      	str	r0, [r7, #0]
 8004ca8:	6079      	str	r1, [r7, #4]
 8004caa:	60ba      	str	r2, [r7, #8]
 8004cac:	60fb      	str	r3, [r7, #12]
 8004cae:	4665      	mov	r5, ip
 8004cb0:	3710      	adds	r7, #16
 8004cb2:	45f4      	cmp	ip, lr
 8004cb4:	d1f4      	bne.n	8004ca0 <ATCustom_TYPE1SC_getCmd+0x568>
 8004cb6:	4663      	mov	r3, ip
 8004cb8:	cb07      	ldmia	r3!, {r0, r1, r2}
 8004cba:	6038      	str	r0, [r7, #0]
 8004cbc:	6079      	str	r1, [r7, #4]
 8004cbe:	60ba      	str	r2, [r7, #8]
 8004cc0:	881a      	ldrh	r2, [r3, #0]
 8004cc2:	789b      	ldrb	r3, [r3, #2]
 8004cc4:	81ba      	strh	r2, [r7, #12]
 8004cc6:	73bb      	strb	r3, [r7, #14]
 8004cc8:	4d17      	ldr	r5, [pc, #92]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004cca:	4628      	mov	r0, r5
 8004ccc:	f01a fa21 	bl	801f112 <crs_strlen>
 8004cd0:	b283      	uxth	r3, r0
 8004cd2:	462a      	mov	r2, r5
 8004cd4:	2101      	movs	r1, #1
 8004cd6:	2002      	movs	r0, #2
 8004cd8:	f01a fa5e 	bl	801f198 <traceIF_itmPrint>
 8004cdc:	4628      	mov	r0, r5
 8004cde:	f01a fa18 	bl	801f112 <crs_strlen>
 8004ce2:	b283      	uxth	r3, r0
 8004ce4:	462a      	mov	r2, r5
 8004ce6:	2101      	movs	r1, #1
 8004ce8:	2002      	movs	r0, #2
 8004cea:	f01a fa77 	bl	801f1dc <traceIF_uartPrint>
          atcm_program_TEMPO(p_atp_ctxt, TYPE1SC_BOOTEV_TIMEOUT, INTERMEDIATE_CMD);
 8004cee:	2200      	movs	r2, #0
 8004cf0:	f241 3188 	movw	r1, #5000	; 0x1388
 8004cf4:	4640      	mov	r0, r8
 8004cf6:	f007 fedb 	bl	800cab0 <atcm_program_TEMPO>
 8004cfa:	e581      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT, FINAL_CMD);
 8004cfc:	2301      	movs	r3, #1
 8004cfe:	9300      	str	r3, [sp, #0]
 8004d00:	2300      	movs	r3, #0
 8004d02:	2204      	movs	r2, #4
 8004d04:	4641      	mov	r1, r8
 8004d06:	4806      	ldr	r0, [pc, #24]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004d08:	f007 fea2 	bl	800ca50 <atcm_program_AT_CMD>
 8004d0c:	e578      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004d0e:	7cac      	ldrb	r4, [r5, #18]
 8004d10:	b10c      	cbz	r4, 8004d16 <ATCustom_TYPE1SC_getCmd+0x5de>
      retval = ATSTATUS_ERROR;
 8004d12:	2401      	movs	r4, #1
 8004d14:	e574      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8004d16:	4640      	mov	r0, r8
 8004d18:	f007 fef6 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8004d1c:	e570      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8004d1e:	bf00      	nop
 8004d20:	20001084 	.word	0x20001084
 8004d24:	0802b8f0 	.word	0x0802b8f0
 8004d28:	200048dc 	.word	0x200048dc
 8004d2c:	20001838 	.word	0x20001838
 8004d30:	20001834 	.word	0x20001834
 8004d34:	0802b920 	.word	0x0802b920
 8004d38:	0802b948 	.word	0x0802b948
 8004d3c:	0802b974 	.word	0x0802b974
 8004d40:	0802b9bc 	.word	0x0802b9bc
    if (p_atp_ctxt->step == 0U)
 8004d44:	7cad      	ldrb	r5, [r5, #18]
 8004d46:	b12d      	cbz	r5, 8004d54 <ATCustom_TYPE1SC_getCmd+0x61c>
    else if (p_atp_ctxt->step == 1U)
 8004d48:	2d01      	cmp	r5, #1
 8004d4a:	d00d      	beq.n	8004d68 <ATCustom_TYPE1SC_getCmd+0x630>
    else if (p_atp_ctxt->step == 2U)
 8004d4c:	2d02      	cmp	r5, #2
 8004d4e:	d01d      	beq.n	8004d8c <ATCustom_TYPE1SC_getCmd+0x654>
      retval = ATSTATUS_ERROR;
 8004d50:	2401      	movs	r4, #1
 8004d52:	e555      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CFUN, INTERMEDIATE_CMD);
 8004d54:	2300      	movs	r3, #0
 8004d56:	9300      	str	r3, [sp, #0]
 8004d58:	2313      	movs	r3, #19
 8004d5a:	2203      	movs	r2, #3
 8004d5c:	4641      	mov	r1, r8
 8004d5e:	48b0      	ldr	r0, [pc, #704]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d60:	f007 fe76 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004d64:	462c      	mov	r4, r5
 8004d66:	e54b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if (TYPE1SC_ctxt.SID_ctxt.modem_init.init == CS_CMI_MINI)
 8004d68:	4bad      	ldr	r3, [pc, #692]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d6a:	f893 55b1 	ldrb.w	r5, [r3, #1457]	; 0x5b1
 8004d6e:	b925      	cbnz	r5, 8004d7a <ATCustom_TYPE1SC_getCmd+0x642>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8004d70:	4640      	mov	r0, r8
 8004d72:	f007 fec9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004d76:	462c      	mov	r4, r5
 8004d78:	e542      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CPIN, INTERMEDIATE_CMD);
 8004d7a:	2300      	movs	r3, #0
 8004d7c:	9300      	str	r3, [sp, #0]
 8004d7e:	2312      	movs	r3, #18
 8004d80:	2202      	movs	r2, #2
 8004d82:	4641      	mov	r1, r8
 8004d84:	48a6      	ldr	r0, [pc, #664]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d86:	f007 fe63 	bl	800ca50 <atcm_program_AT_CMD>
 8004d8a:	e539      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if (TYPE1SC_ctxt.persist.sim_pin_code_ready == AT_FALSE)
 8004d8c:	4ba4      	ldr	r3, [pc, #656]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d8e:	f893 3510 	ldrb.w	r3, [r3, #1296]	; 0x510
 8004d92:	2b00      	cmp	r3, #0
 8004d94:	d159      	bne.n	8004e4a <ATCustom_TYPE1SC_getCmd+0x712>
        if (strlen((const CRC_CHAR_t *)&TYPE1SC_ctxt.SID_ctxt.modem_init.pincode.pincode) != 0U)
 8004d96:	4ba2      	ldr	r3, [pc, #648]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d98:	f893 35b3 	ldrb.w	r3, [r3, #1459]	; 0x5b3
 8004d9c:	b383      	cbz	r3, 8004e00 <ATCustom_TYPE1SC_getCmd+0x6c8>
          PRINT_INFO("CPIN required, we send user value to modem")
 8004d9e:	4fa1      	ldr	r7, [pc, #644]	; (8005024 <ATCustom_TYPE1SC_getCmd+0x8ec>)
 8004da0:	4da1      	ldr	r5, [pc, #644]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004da2:	f107 0e30 	add.w	lr, r7, #48	; 0x30
 8004da6:	46bc      	mov	ip, r7
 8004da8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004dac:	6028      	str	r0, [r5, #0]
 8004dae:	6069      	str	r1, [r5, #4]
 8004db0:	60aa      	str	r2, [r5, #8]
 8004db2:	60eb      	str	r3, [r5, #12]
 8004db4:	4667      	mov	r7, ip
 8004db6:	3510      	adds	r5, #16
 8004db8:	45f4      	cmp	ip, lr
 8004dba:	d1f4      	bne.n	8004da6 <ATCustom_TYPE1SC_getCmd+0x66e>
 8004dbc:	f8dc 0000 	ldr.w	r0, [ip]
 8004dc0:	6028      	str	r0, [r5, #0]
 8004dc2:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8004dc6:	712b      	strb	r3, [r5, #4]
 8004dc8:	4d97      	ldr	r5, [pc, #604]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004dca:	4628      	mov	r0, r5
 8004dcc:	f01a f9a1 	bl	801f112 <crs_strlen>
 8004dd0:	b283      	uxth	r3, r0
 8004dd2:	462a      	mov	r2, r5
 8004dd4:	2101      	movs	r1, #1
 8004dd6:	2002      	movs	r0, #2
 8004dd8:	f01a f9de 	bl	801f198 <traceIF_itmPrint>
 8004ddc:	4628      	mov	r0, r5
 8004dde:	f01a f998 	bl	801f112 <crs_strlen>
 8004de2:	b283      	uxth	r3, r0
 8004de4:	462a      	mov	r2, r5
 8004de6:	2101      	movs	r1, #1
 8004de8:	2002      	movs	r0, #2
 8004dea:	f01a f9f7 	bl	801f1dc <traceIF_uartPrint>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CPIN, FINAL_CMD);
 8004dee:	2301      	movs	r3, #1
 8004df0:	9300      	str	r3, [sp, #0]
 8004df2:	2312      	movs	r3, #18
 8004df4:	2203      	movs	r2, #3
 8004df6:	4641      	mov	r1, r8
 8004df8:	4889      	ldr	r0, [pc, #548]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004dfa:	f007 fe29 	bl	800ca50 <atcm_program_AT_CMD>
 8004dfe:	e4ff      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          PRINT_INFO("CPIN required but not provided by user")
 8004e00:	4d8a      	ldr	r5, [pc, #552]	; (800502c <ATCustom_TYPE1SC_getCmd+0x8f4>)
 8004e02:	4c89      	ldr	r4, [pc, #548]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004e04:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8004e08:	462f      	mov	r7, r5
 8004e0a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004e0c:	6020      	str	r0, [r4, #0]
 8004e0e:	6061      	str	r1, [r4, #4]
 8004e10:	60a2      	str	r2, [r4, #8]
 8004e12:	60e3      	str	r3, [r4, #12]
 8004e14:	463d      	mov	r5, r7
 8004e16:	3410      	adds	r4, #16
 8004e18:	4567      	cmp	r7, ip
 8004e1a:	d1f5      	bne.n	8004e08 <ATCustom_TYPE1SC_getCmd+0x6d0>
 8004e1c:	783b      	ldrb	r3, [r7, #0]
 8004e1e:	7023      	strb	r3, [r4, #0]
 8004e20:	4c81      	ldr	r4, [pc, #516]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004e22:	4620      	mov	r0, r4
 8004e24:	f01a f975 	bl	801f112 <crs_strlen>
 8004e28:	b283      	uxth	r3, r0
 8004e2a:	4622      	mov	r2, r4
 8004e2c:	2101      	movs	r1, #1
 8004e2e:	2002      	movs	r0, #2
 8004e30:	f01a f9b2 	bl	801f198 <traceIF_itmPrint>
 8004e34:	4620      	mov	r0, r4
 8004e36:	f01a f96c 	bl	801f112 <crs_strlen>
 8004e3a:	b283      	uxth	r3, r0
 8004e3c:	4622      	mov	r2, r4
 8004e3e:	2101      	movs	r1, #1
 8004e40:	2002      	movs	r0, #2
 8004e42:	f01a f9cb 	bl	801f1dc <traceIF_uartPrint>
          retval = ATSTATUS_ERROR;
 8004e46:	2401      	movs	r4, #1
 8004e48:	e4da      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        PRINT_INFO("CPIN not required")
 8004e4a:	4d77      	ldr	r5, [pc, #476]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004e4c:	4f78      	ldr	r7, [pc, #480]	; (8005030 <ATCustom_TYPE1SC_getCmd+0x8f8>)
 8004e4e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004e50:	6028      	str	r0, [r5, #0]
 8004e52:	6069      	str	r1, [r5, #4]
 8004e54:	60aa      	str	r2, [r5, #8]
 8004e56:	60eb      	str	r3, [r5, #12]
 8004e58:	cf07      	ldmia	r7!, {r0, r1, r2}
 8004e5a:	6128      	str	r0, [r5, #16]
 8004e5c:	6169      	str	r1, [r5, #20]
 8004e5e:	61aa      	str	r2, [r5, #24]
 8004e60:	4628      	mov	r0, r5
 8004e62:	f01a f956 	bl	801f112 <crs_strlen>
 8004e66:	b283      	uxth	r3, r0
 8004e68:	462a      	mov	r2, r5
 8004e6a:	2101      	movs	r1, #1
 8004e6c:	2002      	movs	r0, #2
 8004e6e:	f01a f993 	bl	801f198 <traceIF_itmPrint>
 8004e72:	4628      	mov	r0, r5
 8004e74:	f01a f94d 	bl	801f112 <crs_strlen>
 8004e78:	b283      	uxth	r3, r0
 8004e7a:	462a      	mov	r2, r5
 8004e7c:	2101      	movs	r1, #1
 8004e7e:	2002      	movs	r0, #2
 8004e80:	f01a f9ac 	bl	801f1dc <traceIF_uartPrint>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8004e84:	4640      	mov	r0, r8
 8004e86:	f007 fe3f 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8004e8a:	e4b9      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004e8c:	7cac      	ldrb	r4, [r5, #18]
 8004e8e:	2c00      	cmp	r4, #0
 8004e90:	f040 843b 	bne.w	800570a <ATCustom_TYPE1SC_getCmd+0xfd2>
      switch (TYPE1SC_ctxt.SID_ctxt.device_info->field_requested)
 8004e94:	4b62      	ldr	r3, [pc, #392]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004e96:	f8d3 35c4 	ldr.w	r3, [r3, #1476]	; 0x5c4
 8004e9a:	881b      	ldrh	r3, [r3, #0]
 8004e9c:	2b20      	cmp	r3, #32
 8004e9e:	d829      	bhi.n	8004ef4 <ATCustom_TYPE1SC_getCmd+0x7bc>
 8004ea0:	b21a      	sxth	r2, r3
 8004ea2:	2a00      	cmp	r2, #0
 8004ea4:	f000 8434 	beq.w	8005710 <ATCustom_TYPE1SC_getCmd+0xfd8>
 8004ea8:	3b01      	subs	r3, #1
 8004eaa:	2b1f      	cmp	r3, #31
 8004eac:	f200 8433 	bhi.w	8005716 <ATCustom_TYPE1SC_getCmd+0xfde>
 8004eb0:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004eb4:	002f0056 	.word	0x002f0056
 8004eb8:	00380431 	.word	0x00380431
 8004ebc:	04310431 	.word	0x04310431
 8004ec0:	00410431 	.word	0x00410431
 8004ec4:	04310431 	.word	0x04310431
 8004ec8:	04310431 	.word	0x04310431
 8004ecc:	04310431 	.word	0x04310431
 8004ed0:	004a0431 	.word	0x004a0431
 8004ed4:	04310431 	.word	0x04310431
 8004ed8:	04310431 	.word	0x04310431
 8004edc:	04310431 	.word	0x04310431
 8004ee0:	04310431 	.word	0x04310431
 8004ee4:	04310431 	.word	0x04310431
 8004ee8:	04310431 	.word	0x04310431
 8004eec:	04310431 	.word	0x04310431
 8004ef0:	00610431 	.word	0x00610431
 8004ef4:	2b40      	cmp	r3, #64	; 0x40
 8004ef6:	d047      	beq.n	8004f88 <ATCustom_TYPE1SC_getCmd+0x850>
 8004ef8:	2b80      	cmp	r3, #128	; 0x80
 8004efa:	d108      	bne.n	8004f0e <ATCustom_TYPE1SC_getCmd+0x7d6>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CCID, FINAL_CMD);
 8004efc:	2301      	movs	r3, #1
 8004efe:	9300      	str	r3, [sp, #0]
 8004f00:	2337      	movs	r3, #55	; 0x37
 8004f02:	2204      	movs	r2, #4
 8004f04:	4641      	mov	r1, r8
 8004f06:	4846      	ldr	r0, [pc, #280]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f08:	f007 fda2 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f0c:	e478      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      switch (TYPE1SC_ctxt.SID_ctxt.device_info->field_requested)
 8004f0e:	2401      	movs	r4, #1
 8004f10:	e476      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMI, FINAL_CMD);
 8004f12:	2301      	movs	r3, #1
 8004f14:	9300      	str	r3, [sp, #0]
 8004f16:	230b      	movs	r3, #11
 8004f18:	2204      	movs	r2, #4
 8004f1a:	4641      	mov	r1, r8
 8004f1c:	4840      	ldr	r0, [pc, #256]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f1e:	f007 fd97 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f22:	e46d      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMM, FINAL_CMD);
 8004f24:	2301      	movs	r3, #1
 8004f26:	9300      	str	r3, [sp, #0]
 8004f28:	230c      	movs	r3, #12
 8004f2a:	2204      	movs	r2, #4
 8004f2c:	4641      	mov	r1, r8
 8004f2e:	483c      	ldr	r0, [pc, #240]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f30:	f007 fd8e 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f34:	e464      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMR, FINAL_CMD);
 8004f36:	2301      	movs	r3, #1
 8004f38:	9300      	str	r3, [sp, #0]
 8004f3a:	230d      	movs	r3, #13
 8004f3c:	2204      	movs	r2, #4
 8004f3e:	4641      	mov	r1, r8
 8004f40:	4837      	ldr	r0, [pc, #220]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f42:	f007 fd85 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f46:	e45b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          TYPE1SC_ctxt.CMD_ctxt.cgsn_write_cmd_param = CGSN_SN;
 8004f48:	4835      	ldr	r0, [pc, #212]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f4a:	2300      	movs	r3, #0
 8004f4c:	f880 372c 	strb.w	r3, [r0, #1836]	; 0x72c
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGSN, FINAL_CMD);
 8004f50:	2301      	movs	r3, #1
 8004f52:	9300      	str	r3, [sp, #0]
 8004f54:	230e      	movs	r3, #14
 8004f56:	2204      	movs	r2, #4
 8004f58:	4641      	mov	r1, r8
 8004f5a:	f007 fd79 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f5e:	e44f      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          TYPE1SC_ctxt.CMD_ctxt.cgsn_write_cmd_param = CGSN_IMEI;
 8004f60:	482f      	ldr	r0, [pc, #188]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f62:	2301      	movs	r3, #1
 8004f64:	f880 372c 	strb.w	r3, [r0, #1836]	; 0x72c
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGSN, FINAL_CMD);
 8004f68:	9300      	str	r3, [sp, #0]
 8004f6a:	230e      	movs	r3, #14
 8004f6c:	2203      	movs	r2, #3
 8004f6e:	4641      	mov	r1, r8
 8004f70:	f007 fd6e 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f74:	e444      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CIMI, FINAL_CMD);
 8004f76:	2301      	movs	r3, #1
 8004f78:	9300      	str	r3, [sp, #0]
 8004f7a:	230f      	movs	r3, #15
 8004f7c:	2204      	movs	r2, #4
 8004f7e:	4641      	mov	r1, r8
 8004f80:	4827      	ldr	r0, [pc, #156]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f82:	f007 fd65 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f86:	e43b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CNUM, FINAL_CMD);
 8004f88:	2301      	movs	r3, #1
 8004f8a:	9300      	str	r3, [sp, #0]
 8004f8c:	2315      	movs	r3, #21
 8004f8e:	2204      	movs	r2, #4
 8004f90:	4641      	mov	r1, r8
 8004f92:	4823      	ldr	r0, [pc, #140]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f94:	f007 fd5c 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f98:	e432      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004f9a:	7cac      	ldrb	r4, [r5, #18]
 8004f9c:	b10c      	cbz	r4, 8004fa2 <ATCustom_TYPE1SC_getCmd+0x86a>
      retval = ATSTATUS_ERROR;
 8004f9e:	2401      	movs	r4, #1
 8004fa0:	e42e      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CSQ, FINAL_CMD);
 8004fa2:	2301      	movs	r3, #1
 8004fa4:	9300      	str	r3, [sp, #0]
 8004fa6:	231c      	movs	r3, #28
 8004fa8:	2204      	movs	r2, #4
 8004faa:	4641      	mov	r1, r8
 8004fac:	481c      	ldr	r0, [pc, #112]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004fae:	f007 fd4f 	bl	800ca50 <atcm_program_AT_CMD>
 8004fb2:	e425      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004fb4:	7cac      	ldrb	r4, [r5, #18]
 8004fb6:	b10c      	cbz	r4, 8004fbc <ATCustom_TYPE1SC_getCmd+0x884>
      retval = ATSTATUS_ERROR;
 8004fb8:	2401      	movs	r4, #1
 8004fba:	e421      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CGATT, FINAL_CMD);
 8004fbc:	2301      	movs	r3, #1
 8004fbe:	9300      	str	r3, [sp, #0]
 8004fc0:	2316      	movs	r3, #22
 8004fc2:	2202      	movs	r2, #2
 8004fc4:	4641      	mov	r1, r8
 8004fc6:	4816      	ldr	r0, [pc, #88]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004fc8:	f007 fd42 	bl	800ca50 <atcm_program_AT_CMD>
 8004fcc:	e418      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004fce:	7cad      	ldrb	r5, [r5, #18]
 8004fd0:	b12d      	cbz	r5, 8004fde <ATCustom_TYPE1SC_getCmd+0x8a6>
    else if (p_atp_ctxt->step == 1U)
 8004fd2:	2d01      	cmp	r5, #1
 8004fd4:	d00d      	beq.n	8004ff2 <ATCustom_TYPE1SC_getCmd+0x8ba>
    else if (p_atp_ctxt->step == 2U)
 8004fd6:	2d02      	cmp	r5, #2
 8004fd8:	d031      	beq.n	800503e <ATCustom_TYPE1SC_getCmd+0x906>
      retval = ATSTATUS_ERROR;
 8004fda:	2401      	movs	r4, #1
 8004fdc:	e410      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_COPS, INTERMEDIATE_CMD);
 8004fde:	2300      	movs	r3, #0
 8004fe0:	9300      	str	r3, [sp, #0]
 8004fe2:	2314      	movs	r3, #20
 8004fe4:	2202      	movs	r2, #2
 8004fe6:	4641      	mov	r1, r8
 8004fe8:	480d      	ldr	r0, [pc, #52]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004fea:	f007 fd31 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004fee:	462c      	mov	r4, r5
 8004ff0:	e406      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if ((TYPE1SC_ctxt.SID_ctxt.read_operator_infos.mode != operatorSelect->mode) ||
 8004ff2:	4b0b      	ldr	r3, [pc, #44]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004ff4:	f8b3 2610 	ldrh.w	r2, [r3, #1552]	; 0x610
 8004ff8:	f8b3 35c8 	ldrh.w	r3, [r3, #1480]	; 0x5c8
 8004ffc:	429a      	cmp	r2, r3
 8004ffe:	d104      	bne.n	800500a <ATCustom_TYPE1SC_getCmd+0x8d2>
          (operatorSelect->AcT_present == CELLULAR_TRUE))
 8005000:	4b07      	ldr	r3, [pc, #28]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8005002:	f893 360c 	ldrb.w	r3, [r3, #1548]	; 0x60c
      if ((TYPE1SC_ctxt.SID_ctxt.read_operator_infos.mode != operatorSelect->mode) ||
 8005006:	2b01      	cmp	r3, #1
 8005008:	d114      	bne.n	8005034 <ATCustom_TYPE1SC_getCmd+0x8fc>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_COPS, INTERMEDIATE_CMD);
 800500a:	2300      	movs	r3, #0
 800500c:	9300      	str	r3, [sp, #0]
 800500e:	2314      	movs	r3, #20
 8005010:	2203      	movs	r2, #3
 8005012:	4641      	mov	r1, r8
 8005014:	4802      	ldr	r0, [pc, #8]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8005016:	f007 fd1b 	bl	800ca50 <atcm_program_AT_CMD>
 800501a:	f7ff bbf1 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 800501e:	bf00      	nop
 8005020:	20001084 	.word	0x20001084
 8005024:	0802b9ec 	.word	0x0802b9ec
 8005028:	200048dc 	.word	0x200048dc
 800502c:	0802ba24 	.word	0x0802ba24
 8005030:	0802ba58 	.word	0x0802ba58
        atcm_program_SKIP_CMD(p_atp_ctxt);
 8005034:	4640      	mov	r0, r8
 8005036:	f007 fd73 	bl	800cb20 <atcm_program_SKIP_CMD>
 800503a:	f7ff bbe1 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CEREG, FINAL_CMD);
 800503e:	2301      	movs	r3, #1
 8005040:	9300      	str	r3, [sp, #0]
 8005042:	2319      	movs	r3, #25
 8005044:	2202      	movs	r2, #2
 8005046:	4641      	mov	r1, r8
 8005048:	48bc      	ldr	r0, [pc, #752]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800504a:	f007 fd01 	bl	800ca50 <atcm_program_AT_CMD>
 800504e:	f7ff bbd7 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005052:	7cad      	ldrb	r5, [r5, #18]
 8005054:	b135      	cbz	r5, 8005064 <ATCustom_TYPE1SC_getCmd+0x92c>
    else if (p_atp_ctxt->step == 1U)
 8005056:	2d01      	cmp	r5, #1
 8005058:	d00f      	beq.n	800507a <ATCustom_TYPE1SC_getCmd+0x942>
    else if (p_atp_ctxt->step == 2U)
 800505a:	2d02      	cmp	r5, #2
 800505c:	d017      	beq.n	800508e <ATCustom_TYPE1SC_getCmd+0x956>
      retval = ATSTATUS_ERROR;
 800505e:	2401      	movs	r4, #1
 8005060:	f7ff bbce 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CEREG, INTERMEDIATE_CMD);
 8005064:	2300      	movs	r3, #0
 8005066:	9300      	str	r3, [sp, #0]
 8005068:	2319      	movs	r3, #25
 800506a:	2202      	movs	r2, #2
 800506c:	4641      	mov	r1, r8
 800506e:	48b3      	ldr	r0, [pc, #716]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005070:	f007 fcee 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005074:	462c      	mov	r4, r5
 8005076:	f7ff bbc3 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CREG, INTERMEDIATE_CMD);
 800507a:	2300      	movs	r3, #0
 800507c:	9300      	str	r3, [sp, #0]
 800507e:	2317      	movs	r3, #23
 8005080:	2202      	movs	r2, #2
 8005082:	4641      	mov	r1, r8
 8005084:	48ad      	ldr	r0, [pc, #692]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005086:	f007 fce3 	bl	800ca50 <atcm_program_AT_CMD>
 800508a:	f7ff bbb9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_COPS, FINAL_CMD);
 800508e:	2301      	movs	r3, #1
 8005090:	9300      	str	r3, [sp, #0]
 8005092:	2314      	movs	r3, #20
 8005094:	2202      	movs	r2, #2
 8005096:	4641      	mov	r1, r8
 8005098:	48a8      	ldr	r0, [pc, #672]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800509a:	f007 fcd9 	bl	800ca50 <atcm_program_AT_CMD>
 800509e:	f7ff bbaf 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80050a2:	7cac      	ldrb	r4, [r5, #18]
 80050a4:	2c00      	cmp	r4, #0
 80050a6:	f040 8339 	bne.w	800571c <ATCustom_TYPE1SC_getCmd+0xfe4>
      CS_UrcEvent_t urcEvent = TYPE1SC_ctxt.SID_ctxt.urcEvent;
 80050aa:	4ba4      	ldr	r3, [pc, #656]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80050ac:	f893 2664 	ldrb.w	r2, [r3, #1636]	; 0x664
      if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO) ||
 80050b0:	1e53      	subs	r3, r2, #1
 80050b2:	b2db      	uxtb	r3, r3
 80050b4:	2b01      	cmp	r3, #1
 80050b6:	d90c      	bls.n	80050d2 <ATCustom_TYPE1SC_getCmd+0x99a>
 80050b8:	2a05      	cmp	r2, #5
 80050ba:	d00a      	beq.n	80050d2 <ATCustom_TYPE1SC_getCmd+0x99a>
          (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 80050bc:	2a06      	cmp	r2, #6
 80050be:	d008      	beq.n	80050d2 <ATCustom_TYPE1SC_getCmd+0x99a>
      else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 80050c0:	1ed3      	subs	r3, r2, #3
 80050c2:	b2db      	uxtb	r3, r3
 80050c4:	2b01      	cmp	r3, #1
 80050c6:	d90a      	bls.n	80050de <ATCustom_TYPE1SC_getCmd+0x9a6>
      else if (urcEvent == CS_URCEVENT_SIGNAL_QUALITY)
 80050c8:	2a07      	cmp	r2, #7
 80050ca:	d10d      	bne.n	80050e8 <ATCustom_TYPE1SC_getCmd+0x9b0>
        retval = ATSTATUS_ERROR;
 80050cc:	2401      	movs	r4, #1
 80050ce:	f7ff bb97 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        (void) atcm_subscribe_net_event(&TYPE1SC_ctxt, p_atp_ctxt);
 80050d2:	4641      	mov	r1, r8
 80050d4:	4899      	ldr	r0, [pc, #612]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80050d6:	f007 ff93 	bl	800d000 <atcm_subscribe_net_event>
 80050da:	f7ff bb91 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80050de:	4640      	mov	r0, r8
 80050e0:	f007 fd12 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80050e4:	f7ff bb8c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80050e8:	4640      	mov	r0, r8
 80050ea:	f007 fd0d 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80050ee:	f7ff bb87 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80050f2:	7cac      	ldrb	r4, [r5, #18]
 80050f4:	2c00      	cmp	r4, #0
 80050f6:	f040 8314 	bne.w	8005722 <ATCustom_TYPE1SC_getCmd+0xfea>
      CS_UrcEvent_t urcEvent = TYPE1SC_ctxt.SID_ctxt.urcEvent;
 80050fa:	4b90      	ldr	r3, [pc, #576]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80050fc:	f893 2664 	ldrb.w	r2, [r3, #1636]	; 0x664
      if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO) ||
 8005100:	1e53      	subs	r3, r2, #1
 8005102:	b2db      	uxtb	r3, r3
 8005104:	2b01      	cmp	r3, #1
 8005106:	d90c      	bls.n	8005122 <ATCustom_TYPE1SC_getCmd+0x9ea>
 8005108:	2a05      	cmp	r2, #5
 800510a:	d00a      	beq.n	8005122 <ATCustom_TYPE1SC_getCmd+0x9ea>
          (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 800510c:	2a06      	cmp	r2, #6
 800510e:	d008      	beq.n	8005122 <ATCustom_TYPE1SC_getCmd+0x9ea>
      else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 8005110:	1ed3      	subs	r3, r2, #3
 8005112:	b2db      	uxtb	r3, r3
 8005114:	2b01      	cmp	r3, #1
 8005116:	d90a      	bls.n	800512e <ATCustom_TYPE1SC_getCmd+0x9f6>
      else if (urcEvent == CS_URCEVENT_SIGNAL_QUALITY)
 8005118:	2a07      	cmp	r2, #7
 800511a:	d10d      	bne.n	8005138 <ATCustom_TYPE1SC_getCmd+0xa00>
        retval = ATSTATUS_ERROR;
 800511c:	2401      	movs	r4, #1
 800511e:	f7ff bb6f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        (void) atcm_unsubscribe_net_event(&TYPE1SC_ctxt, p_atp_ctxt);
 8005122:	4641      	mov	r1, r8
 8005124:	4885      	ldr	r0, [pc, #532]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005126:	f007 ffdb 	bl	800d0e0 <atcm_unsubscribe_net_event>
 800512a:	f7ff bb69 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800512e:	4640      	mov	r0, r8
 8005130:	f007 fcea 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005134:	f7ff bb64 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005138:	4640      	mov	r0, r8
 800513a:	f007 fce5 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800513e:	f7ff bb5f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005142:	7cac      	ldrb	r4, [r5, #18]
 8005144:	2c00      	cmp	r4, #0
 8005146:	f040 82ef 	bne.w	8005728 <ATCustom_TYPE1SC_getCmd+0xff0>
      if (TYPE1SC_ctxt.persist.urc_subscript_pdn_event == CELLULAR_FALSE)
 800514a:	4b7c      	ldr	r3, [pc, #496]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800514c:	7cdd      	ldrb	r5, [r3, #19]
 800514e:	b95d      	cbnz	r5, 8005168 <ATCustom_TYPE1SC_getCmd+0xa30>
        TYPE1SC_ctxt.persist.urc_subscript_pdn_event = CELLULAR_TRUE;
 8005150:	4618      	mov	r0, r3
 8005152:	2301      	movs	r3, #1
 8005154:	74c3      	strb	r3, [r0, #19]
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGEREP, FINAL_CMD);
 8005156:	9300      	str	r3, [sp, #0]
 8005158:	231a      	movs	r3, #26
 800515a:	2203      	movs	r2, #3
 800515c:	4641      	mov	r1, r8
 800515e:	f007 fc77 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005162:	462c      	mov	r4, r5
 8005164:	f7ff bb4c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005168:	4640      	mov	r0, r8
 800516a:	f007 fccd 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800516e:	f7ff bb47 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005172:	7cac      	ldrb	r4, [r5, #18]
 8005174:	2c00      	cmp	r4, #0
 8005176:	f040 82da 	bne.w	800572e <ATCustom_TYPE1SC_getCmd+0xff6>
      if (TYPE1SC_ctxt.persist.urc_subscript_pdn_event == CELLULAR_TRUE)
 800517a:	4b70      	ldr	r3, [pc, #448]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800517c:	7cdb      	ldrb	r3, [r3, #19]
 800517e:	2b01      	cmp	r3, #1
 8005180:	d004      	beq.n	800518c <ATCustom_TYPE1SC_getCmd+0xa54>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005182:	4640      	mov	r0, r8
 8005184:	f007 fcc0 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005188:	f7ff bb3a 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.persist.urc_subscript_pdn_event = CELLULAR_FALSE;
 800518c:	486b      	ldr	r0, [pc, #428]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800518e:	2300      	movs	r3, #0
 8005190:	74c3      	strb	r3, [r0, #19]
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGEREP, FINAL_CMD);
 8005192:	2301      	movs	r3, #1
 8005194:	9300      	str	r3, [sp, #0]
 8005196:	231a      	movs	r3, #26
 8005198:	2203      	movs	r2, #3
 800519a:	4641      	mov	r1, r8
 800519c:	f007 fc58 	bl	800ca50 <atcm_program_AT_CMD>
 80051a0:	f7ff bb2e 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80051a4:	7cac      	ldrb	r4, [r5, #18]
 80051a6:	b114      	cbz	r4, 80051ae <ATCustom_TYPE1SC_getCmd+0xa76>
      retval = ATSTATUS_ERROR;
 80051a8:	2401      	movs	r4, #1
 80051aa:	f7ff bb29 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.cgatt_write_cmd_param = CGATT_ATTACHED;
 80051ae:	4863      	ldr	r0, [pc, #396]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80051b0:	2301      	movs	r3, #1
 80051b2:	f880 372d 	strb.w	r3, [r0, #1837]	; 0x72d
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGATT, FINAL_CMD);
 80051b6:	9300      	str	r3, [sp, #0]
 80051b8:	2316      	movs	r3, #22
 80051ba:	2203      	movs	r2, #3
 80051bc:	4641      	mov	r1, r8
 80051be:	f007 fc47 	bl	800ca50 <atcm_program_AT_CMD>
 80051c2:	f7ff bb1d 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80051c6:	7cac      	ldrb	r4, [r5, #18]
 80051c8:	b114      	cbz	r4, 80051d0 <ATCustom_TYPE1SC_getCmd+0xa98>
      retval = ATSTATUS_ERROR;
 80051ca:	2401      	movs	r4, #1
 80051cc:	f7ff bb18 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.cgatt_write_cmd_param = CGATT_DETACHED;
 80051d0:	485a      	ldr	r0, [pc, #360]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80051d2:	2300      	movs	r3, #0
 80051d4:	f880 372d 	strb.w	r3, [r0, #1837]	; 0x72d
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGATT, FINAL_CMD);
 80051d8:	2301      	movs	r3, #1
 80051da:	9300      	str	r3, [sp, #0]
 80051dc:	2316      	movs	r3, #22
 80051de:	2203      	movs	r2, #3
 80051e0:	4641      	mov	r1, r8
 80051e2:	f007 fc35 	bl	800ca50 <atcm_program_AT_CMD>
 80051e6:	f7ff bb0b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80051ea:	7cac      	ldrb	r4, [r5, #18]
 80051ec:	b114      	cbz	r4, 80051f4 <ATCustom_TYPE1SC_getCmd+0xabc>
      retval = ATSTATUS_ERROR;
 80051ee:	2401      	movs	r4, #1
 80051f0:	f7ff bb06 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.pdn_state = PDN_STATE_ACTIVATE;
 80051f4:	4851      	ldr	r0, [pc, #324]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80051f6:	2301      	movs	r3, #1
 80051f8:	f880 3731 	strb.w	r3, [r0, #1841]	; 0x731
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PDNACT, FINAL_CMD);
 80051fc:	9300      	str	r3, [sp, #0]
 80051fe:	2341      	movs	r3, #65	; 0x41
 8005200:	2203      	movs	r2, #3
 8005202:	4641      	mov	r1, r8
 8005204:	f007 fc24 	bl	800ca50 <atcm_program_AT_CMD>
 8005208:	f7ff bafa 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800520c:	7cac      	ldrb	r4, [r5, #18]
 800520e:	b114      	cbz	r4, 8005216 <ATCustom_TYPE1SC_getCmd+0xade>
      retval = ATSTATUS_ERROR;
 8005210:	2401      	movs	r4, #1
 8005212:	f7ff baf5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.pdn_state = PDN_STATE_DEACTIVATE;
 8005216:	4849      	ldr	r0, [pc, #292]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005218:	2300      	movs	r3, #0
 800521a:	f880 3731 	strb.w	r3, [r0, #1841]	; 0x731
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PDNACT, FINAL_CMD);
 800521e:	2301      	movs	r3, #1
 8005220:	9300      	str	r3, [sp, #0]
 8005222:	2341      	movs	r3, #65	; 0x41
 8005224:	2203      	movs	r2, #3
 8005226:	4641      	mov	r1, r8
 8005228:	f007 fc12 	bl	800ca50 <atcm_program_AT_CMD>
 800522c:	f7ff bae8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005230:	7cad      	ldrb	r5, [r5, #18]
 8005232:	b135      	cbz	r5, 8005242 <ATCustom_TYPE1SC_getCmd+0xb0a>
    else if (p_atp_ctxt->step == 1U)
 8005234:	2d01      	cmp	r5, #1
 8005236:	d00f      	beq.n	8005258 <ATCustom_TYPE1SC_getCmd+0xb20>
    else if (p_atp_ctxt->step == 2U)
 8005238:	2d02      	cmp	r5, #2
 800523a:	d015      	beq.n	8005268 <ATCustom_TYPE1SC_getCmd+0xb30>
      retval = ATSTATUS_ERROR;
 800523c:	2401      	movs	r4, #1
 800523e:	f7ff badf 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PDNSET, INTERMEDIATE_CMD);
 8005242:	2300      	movs	r3, #0
 8005244:	9300      	str	r3, [sp, #0]
 8005246:	2336      	movs	r3, #54	; 0x36
 8005248:	2203      	movs	r2, #3
 800524a:	4641      	mov	r1, r8
 800524c:	483b      	ldr	r0, [pc, #236]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800524e:	f007 fbff 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005252:	462c      	mov	r4, r5
 8005254:	f7ff bad4 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_TEMPO(p_atp_ctxt, 2000U, INTERMEDIATE_CMD);
 8005258:	2200      	movs	r2, #0
 800525a:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 800525e:	4640      	mov	r0, r8
 8005260:	f007 fc26 	bl	800cab0 <atcm_program_TEMPO>
 8005264:	f7ff bacc 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_PDNSET, FINAL_CMD);
 8005268:	2301      	movs	r3, #1
 800526a:	9300      	str	r3, [sp, #0]
 800526c:	2336      	movs	r3, #54	; 0x36
 800526e:	2202      	movs	r2, #2
 8005270:	4641      	mov	r1, r8
 8005272:	4832      	ldr	r0, [pc, #200]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005274:	f007 fbec 	bl	800ca50 <atcm_program_AT_CMD>
 8005278:	f7ff bac2 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800527c:	4640      	mov	r0, r8
 800527e:	f007 fc43 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005282:	f7ff babd 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005286:	7cac      	ldrb	r4, [r5, #18]
 8005288:	b114      	cbz	r4, 8005290 <ATCustom_TYPE1SC_getCmd+0xb58>
      retval = ATSTATUS_ERROR;
 800528a:	2401      	movs	r4, #1
 800528c:	f7ff bab8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGPADDR, FINAL_CMD);
 8005290:	2301      	movs	r3, #1
 8005292:	9300      	str	r3, [sp, #0]
 8005294:	2321      	movs	r3, #33	; 0x21
 8005296:	2203      	movs	r2, #3
 8005298:	4641      	mov	r1, r8
 800529a:	4828      	ldr	r0, [pc, #160]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800529c:	f007 fbd8 	bl	800ca50 <atcm_program_AT_CMD>
 80052a0:	f7ff baae 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80052a4:	7cad      	ldrb	r5, [r5, #18]
 80052a6:	b135      	cbz	r5, 80052b6 <ATCustom_TYPE1SC_getCmd+0xb7e>
    else if (p_atp_ctxt->step == 1U)
 80052a8:	2d01      	cmp	r5, #1
 80052aa:	d012      	beq.n	80052d2 <ATCustom_TYPE1SC_getCmd+0xb9a>
    else if (p_atp_ctxt->step == 2U)
 80052ac:	2d02      	cmp	r5, #2
 80052ae:	d039      	beq.n	8005324 <ATCustom_TYPE1SC_getCmd+0xbec>
      retval = ATSTATUS_ERROR;
 80052b0:	2401      	movs	r4, #1
 80052b2:	f7ff baa5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      type1sc_shared.SocketCmd_Allocated_SocketID = AT_FALSE;
 80052b6:	2300      	movs	r3, #0
 80052b8:	4a21      	ldr	r2, [pc, #132]	; (8005340 <ATCustom_TYPE1SC_getCmd+0xc08>)
 80052ba:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_ALLOCATE,
 80052be:	9300      	str	r3, [sp, #0]
 80052c0:	2342      	movs	r3, #66	; 0x42
 80052c2:	2203      	movs	r2, #3
 80052c4:	4641      	mov	r1, r8
 80052c6:	481d      	ldr	r0, [pc, #116]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80052c8:	f007 fbc2 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 80052cc:	462c      	mov	r4, r5
 80052ce:	f7ff ba97 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if (type1sc_shared.SocketCmd_Allocated_SocketID == AT_TRUE)
 80052d2:	4b1b      	ldr	r3, [pc, #108]	; (8005340 <ATCustom_TYPE1SC_getCmd+0xc08>)
 80052d4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80052d8:	b14b      	cbz	r3, 80052ee <ATCustom_TYPE1SC_getCmd+0xbb6>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_ACTIVATE,
 80052da:	2300      	movs	r3, #0
 80052dc:	9300      	str	r3, [sp, #0]
 80052de:	2343      	movs	r3, #67	; 0x43
 80052e0:	2203      	movs	r2, #3
 80052e2:	4641      	mov	r1, r8
 80052e4:	4815      	ldr	r0, [pc, #84]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80052e6:	f007 fbb3 	bl	800ca50 <atcm_program_AT_CMD>
 80052ea:	f7ff ba89 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        PRINT_ERR("No valid socket_id affected by the modem has been reecived")
 80052ee:	4c15      	ldr	r4, [pc, #84]	; (8005344 <ATCustom_TYPE1SC_getCmd+0xc0c>)
 80052f0:	224b      	movs	r2, #75	; 0x4b
 80052f2:	4915      	ldr	r1, [pc, #84]	; (8005348 <ATCustom_TYPE1SC_getCmd+0xc10>)
 80052f4:	4620      	mov	r0, r4
 80052f6:	f020 fe0b 	bl	8025f10 <memcpy>
 80052fa:	4620      	mov	r0, r4
 80052fc:	f019 ff09 	bl	801f112 <crs_strlen>
 8005300:	b283      	uxth	r3, r0
 8005302:	4622      	mov	r2, r4
 8005304:	2110      	movs	r1, #16
 8005306:	2002      	movs	r0, #2
 8005308:	f019 ff46 	bl	801f198 <traceIF_itmPrint>
 800530c:	4620      	mov	r0, r4
 800530e:	f019 ff00 	bl	801f112 <crs_strlen>
 8005312:	b283      	uxth	r3, r0
 8005314:	4622      	mov	r2, r4
 8005316:	2110      	movs	r1, #16
 8005318:	2002      	movs	r0, #2
 800531a:	f019 ff5f 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800531e:	462c      	mov	r4, r5
 8005320:	f7ff ba6e 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      (void) atcm_socket_set_connected(&TYPE1SC_ctxt, TYPE1SC_ctxt.socket_ctxt.socket_info->socket_handle);
 8005324:	4805      	ldr	r0, [pc, #20]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005326:	f8d0 3740 	ldr.w	r3, [r0, #1856]	; 0x740
 800532a:	6819      	ldr	r1, [r3, #0]
 800532c:	f00f f900 	bl	8014530 <atcm_socket_set_connected>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005330:	4640      	mov	r0, r8
 8005332:	f007 fbe9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005336:	f7ff ba63 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 800533a:	bf00      	nop
 800533c:	20001084 	.word	0x20001084
 8005340:	20001838 	.word	0x20001838
 8005344:	200048dc 	.word	0x200048dc
 8005348:	0802ba74 	.word	0x0802ba74
    if (p_atp_ctxt->step == 0U)
 800534c:	7cac      	ldrb	r4, [r5, #18]
 800534e:	2c00      	cmp	r4, #0
 8005350:	f040 81f0 	bne.w	8005734 <ATCustom_TYPE1SC_getCmd+0xffc>
      if (TYPE1SC_ctxt.SID_ctxt.socketSendData_struct.buffer_size > MODEM_MAX_SOCKET_TX_DATA_SIZE)
 8005354:	4bbb      	ldr	r3, [pc, #748]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005356:	f8d3 267c 	ldr.w	r2, [r3, #1660]	; 0x67c
 800535a:	f240 23c6 	movw	r3, #710	; 0x2c6
 800535e:	429a      	cmp	r2, r3
 8005360:	d91c      	bls.n	800539c <ATCustom_TYPE1SC_getCmd+0xc64>
        PRINT_ERR("Data size to send %ld exceed maximum size %ld",
 8005362:	4cb9      	ldr	r4, [pc, #740]	; (8005648 <ATCustom_TYPE1SC_getCmd+0xf10>)
 8005364:	49b9      	ldr	r1, [pc, #740]	; (800564c <ATCustom_TYPE1SC_getCmd+0xf14>)
 8005366:	4620      	mov	r0, r4
 8005368:	f020 fc82 	bl	8025c70 <sprintf>
 800536c:	4620      	mov	r0, r4
 800536e:	f019 fed0 	bl	801f112 <crs_strlen>
 8005372:	b283      	uxth	r3, r0
 8005374:	4622      	mov	r2, r4
 8005376:	2110      	movs	r1, #16
 8005378:	2002      	movs	r0, #2
 800537a:	f019 ff0d 	bl	801f198 <traceIF_itmPrint>
 800537e:	4620      	mov	r0, r4
 8005380:	f019 fec7 	bl	801f112 <crs_strlen>
 8005384:	b283      	uxth	r3, r0
 8005386:	4622      	mov	r2, r4
 8005388:	2110      	movs	r1, #16
 800538a:	2002      	movs	r0, #2
 800538c:	f019 ff26 	bl	801f1dc <traceIF_uartPrint>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005390:	4640      	mov	r0, r8
 8005392:	f007 fbb9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
        retval = ATSTATUS_ERROR;
 8005396:	2401      	movs	r4, #1
 8005398:	f7ff ba32 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETDATA_SEND, FINAL_CMD);
 800539c:	2301      	movs	r3, #1
 800539e:	9300      	str	r3, [sp, #0]
 80053a0:	234b      	movs	r3, #75	; 0x4b
 80053a2:	2203      	movs	r2, #3
 80053a4:	4641      	mov	r1, r8
 80053a6:	48a7      	ldr	r0, [pc, #668]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053a8:	f007 fb52 	bl	800ca50 <atcm_program_AT_CMD>
 80053ac:	f7ff ba28 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80053b0:	7cac      	ldrb	r4, [r5, #18]
 80053b2:	b114      	cbz	r4, 80053ba <ATCustom_TYPE1SC_getCmd+0xc82>
      retval = ATSTATUS_ERROR;
 80053b4:	2401      	movs	r4, #1
 80053b6:	f7ff ba23 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETDATA_RECEIVE, FINAL_CMD);
 80053ba:	2301      	movs	r3, #1
 80053bc:	9300      	str	r3, [sp, #0]
 80053be:	234c      	movs	r3, #76	; 0x4c
 80053c0:	2203      	movs	r2, #3
 80053c2:	4641      	mov	r1, r8
 80053c4:	489f      	ldr	r0, [pc, #636]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053c6:	f007 fb43 	bl	800ca50 <atcm_program_AT_CMD>
 80053ca:	f7ff ba19 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80053ce:	7cad      	ldrb	r5, [r5, #18]
 80053d0:	b125      	cbz	r5, 80053dc <ATCustom_TYPE1SC_getCmd+0xca4>
    else if (p_atp_ctxt->step == 1U)
 80053d2:	2d01      	cmp	r5, #1
 80053d4:	d00d      	beq.n	80053f2 <ATCustom_TYPE1SC_getCmd+0xcba>
      retval = ATSTATUS_ERROR;
 80053d6:	2401      	movs	r4, #1
 80053d8:	f7ff ba12 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_DEACTIVATE,
 80053dc:	2300      	movs	r3, #0
 80053de:	9300      	str	r3, [sp, #0]
 80053e0:	2345      	movs	r3, #69	; 0x45
 80053e2:	2203      	movs	r2, #3
 80053e4:	4641      	mov	r1, r8
 80053e6:	4897      	ldr	r0, [pc, #604]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053e8:	f007 fb32 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 80053ec:	462c      	mov	r4, r5
 80053ee:	f7ff ba07 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_DELETE, FINAL_CMD);
 80053f2:	2301      	movs	r3, #1
 80053f4:	9300      	str	r3, [sp, #0]
 80053f6:	2347      	movs	r3, #71	; 0x47
 80053f8:	2203      	movs	r2, #3
 80053fa:	4641      	mov	r1, r8
 80053fc:	4891      	ldr	r0, [pc, #580]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053fe:	f007 fb27 	bl	800ca50 <atcm_program_AT_CMD>
 8005402:	f7ff b9fd 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005406:	7cac      	ldrb	r4, [r5, #18]
 8005408:	b114      	cbz	r4, 8005410 <ATCustom_TYPE1SC_getCmd+0xcd8>
      retval = ATSTATUS_ERROR;
 800540a:	2401      	movs	r4, #1
 800540c:	f7ff b9f8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_INFO, FINAL_CMD);
 8005410:	2301      	movs	r3, #1
 8005412:	9300      	str	r3, [sp, #0]
 8005414:	2344      	movs	r3, #68	; 0x44
 8005416:	2203      	movs	r2, #3
 8005418:	4641      	mov	r1, r8
 800541a:	488a      	ldr	r0, [pc, #552]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 800541c:	f007 fb18 	bl	800ca50 <atcm_program_AT_CMD>
 8005420:	f7ff b9ee 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005424:	7cad      	ldrb	r5, [r5, #18]
 8005426:	b135      	cbz	r5, 8005436 <ATCustom_TYPE1SC_getCmd+0xcfe>
    else if (p_atp_ctxt->step == 1U)
 8005428:	2d01      	cmp	r5, #1
 800542a:	d00d      	beq.n	8005448 <ATCustom_TYPE1SC_getCmd+0xd10>
    else if (p_atp_ctxt->step == 2U)
 800542c:	2d02      	cmp	r5, #2
 800542e:	d017      	beq.n	8005460 <ATCustom_TYPE1SC_getCmd+0xd28>
      retval = ATSTATUS_ERROR;
 8005430:	2401      	movs	r4, #1
 8005432:	f7ff b9e5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_TEMPO(p_atp_ctxt, 1000U, INTERMEDIATE_CMD);
 8005436:	2200      	movs	r2, #0
 8005438:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800543c:	4640      	mov	r0, r8
 800543e:	f007 fb37 	bl	800cab0 <atcm_program_TEMPO>
  at_status_t retval = ATSTATUS_OK;
 8005442:	462c      	mov	r4, r5
 8005444:	f7ff b9dc 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_RAW_CMD, (CMD_ID_t) CMD_AT_ESC_CMD, INTERMEDIATE_CMD);
 8005448:	2300      	movs	r3, #0
 800544a:	9300      	str	r3, [sp, #0]
 800544c:	2333      	movs	r3, #51	; 0x33
 800544e:	2206      	movs	r2, #6
 8005450:	4641      	mov	r1, r8
 8005452:	487c      	ldr	r0, [pc, #496]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005454:	f007 fafc 	bl	800ca50 <atcm_program_AT_CMD>
      reinitSyntaxAutomaton_TYPE1SC();
 8005458:	f7ff f84c 	bl	80044f4 <reinitSyntaxAutomaton_TYPE1SC>
 800545c:	f7ff b9d0 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_TEMPO(p_atp_ctxt, 2000U, FINAL_CMD);
 8005460:	2201      	movs	r2, #1
 8005462:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8005466:	4640      	mov	r0, r8
 8005468:	f007 fb22 	bl	800cab0 <atcm_program_TEMPO>
 800546c:	f7ff b9c8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005470:	7cac      	ldrb	r4, [r5, #18]
 8005472:	b114      	cbz	r4, 800547a <ATCustom_TYPE1SC_getCmd+0xd42>
      retval = ATSTATUS_ERROR;
 8005474:	2401      	movs	r4, #1
 8005476:	f7ff b9c3 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_ATO, FINAL_CMD);
 800547a:	2301      	movs	r3, #1
 800547c:	9300      	str	r3, [sp, #0]
 800547e:	232a      	movs	r3, #42	; 0x2a
 8005480:	2204      	movs	r2, #4
 8005482:	4641      	mov	r1, r8
 8005484:	486f      	ldr	r0, [pc, #444]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005486:	f007 fae3 	bl	800ca50 <atcm_program_AT_CMD>
 800548a:	f7ff b9b9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800548e:	7cad      	ldrb	r5, [r5, #18]
 8005490:	b145      	cbz	r5, 80054a4 <ATCustom_TYPE1SC_getCmd+0xd6c>
    else if (p_atp_ctxt->step == 1U)
 8005492:	3d01      	subs	r5, #1
 8005494:	2d04      	cmp	r5, #4
 8005496:	f200 8150 	bhi.w	800573a <ATCustom_TYPE1SC_getCmd+0x1002>
 800549a:	e8df f005 	tbb	[pc, r5]
 800549e:	1c12      	.short	0x1c12
 80054a0:	3026      	.short	0x3026
 80054a2:	3a          	.byte	0x3a
 80054a3:	00          	.byte	0x00
      if (init_type1sc_low_power() == AT_FALSE)
 80054a4:	f7ff f83a 	bl	800451c <init_type1sc_low_power>
 80054a8:	b928      	cbnz	r0, 80054b6 <ATCustom_TYPE1SC_getCmd+0xd7e>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80054aa:	4640      	mov	r0, r8
 80054ac:	f007 fb2c 	bl	800cb08 <atcm_program_NO_MORE_CMD>
  at_status_t retval = ATSTATUS_OK;
 80054b0:	462c      	mov	r4, r5
 80054b2:	f7ff b9a5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_SKIP_CMD(p_atp_ctxt);
 80054b6:	4640      	mov	r0, r8
 80054b8:	f007 fb32 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 80054bc:	462c      	mov	r4, r5
 80054be:	f7ff b99f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CEDRXS, INTERMEDIATE_CMD);
 80054c2:	2300      	movs	r3, #0
 80054c4:	9300      	str	r3, [sp, #0]
 80054c6:	2323      	movs	r3, #35	; 0x23
 80054c8:	2202      	movs	r2, #2
 80054ca:	4641      	mov	r1, r8
 80054cc:	485d      	ldr	r0, [pc, #372]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80054ce:	f007 fabf 	bl	800ca50 <atcm_program_AT_CMD>
 80054d2:	f7ff b995 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CPSMS, INTERMEDIATE_CMD);
 80054d6:	2300      	movs	r3, #0
 80054d8:	9300      	str	r3, [sp, #0]
 80054da:	2322      	movs	r3, #34	; 0x22
 80054dc:	2202      	movs	r2, #2
 80054de:	4641      	mov	r1, r8
 80054e0:	4858      	ldr	r0, [pc, #352]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80054e2:	f007 fab5 	bl	800ca50 <atcm_program_AT_CMD>
 80054e6:	f7ff b98b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEDRXS, INTERMEDIATE_CMD);
 80054ea:	2300      	movs	r3, #0
 80054ec:	9300      	str	r3, [sp, #0]
 80054ee:	2323      	movs	r3, #35	; 0x23
 80054f0:	2203      	movs	r2, #3
 80054f2:	4641      	mov	r1, r8
 80054f4:	4853      	ldr	r0, [pc, #332]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80054f6:	f007 faab 	bl	800ca50 <atcm_program_AT_CMD>
 80054fa:	f7ff b981 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CPSMS, INTERMEDIATE_CMD);
 80054fe:	2300      	movs	r3, #0
 8005500:	9300      	str	r3, [sp, #0]
 8005502:	2322      	movs	r3, #34	; 0x22
 8005504:	2203      	movs	r2, #3
 8005506:	4641      	mov	r1, r8
 8005508:	484e      	ldr	r0, [pc, #312]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 800550a:	f007 faa1 	bl	800ca50 <atcm_program_AT_CMD>
 800550e:	f7ff b977 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005512:	4640      	mov	r0, r8
 8005514:	f007 faf8 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005518:	f7ff b972 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800551c:	7cad      	ldrb	r5, [r5, #18]
 800551e:	b145      	cbz	r5, 8005532 <ATCustom_TYPE1SC_getCmd+0xdfa>
    else if (p_atp_ctxt->step == 1U)
 8005520:	2d01      	cmp	r5, #1
 8005522:	d011      	beq.n	8005548 <ATCustom_TYPE1SC_getCmd+0xe10>
    else if (p_atp_ctxt->step == 2U)
 8005524:	2d02      	cmp	r5, #2
 8005526:	d019      	beq.n	800555c <ATCustom_TYPE1SC_getCmd+0xe24>
    else if (p_atp_ctxt->step == 3U)
 8005528:	2d03      	cmp	r5, #3
 800552a:	d021      	beq.n	8005570 <ATCustom_TYPE1SC_getCmd+0xe38>
      retval = ATSTATUS_ERROR;
 800552c:	2401      	movs	r4, #1
 800552e:	f7ff b967 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEDRXS, INTERMEDIATE_CMD);
 8005532:	2300      	movs	r3, #0
 8005534:	9300      	str	r3, [sp, #0]
 8005536:	2323      	movs	r3, #35	; 0x23
 8005538:	2203      	movs	r2, #3
 800553a:	4641      	mov	r1, r8
 800553c:	4841      	ldr	r0, [pc, #260]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 800553e:	f007 fa87 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005542:	462c      	mov	r4, r5
 8005544:	f7ff b95c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CPSMS, INTERMEDIATE_CMD);
 8005548:	2300      	movs	r3, #0
 800554a:	9300      	str	r3, [sp, #0]
 800554c:	2322      	movs	r3, #34	; 0x22
 800554e:	2203      	movs	r2, #3
 8005550:	4641      	mov	r1, r8
 8005552:	483c      	ldr	r0, [pc, #240]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005554:	f007 fa7c 	bl	800ca50 <atcm_program_AT_CMD>
 8005558:	f7ff b952 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt,
 800555c:	2300      	movs	r3, #0
 800555e:	9300      	str	r3, [sp, #0]
 8005560:	2325      	movs	r3, #37	; 0x25
 8005562:	2204      	movs	r2, #4
 8005564:	4641      	mov	r1, r8
 8005566:	4837      	ldr	r0, [pc, #220]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005568:	f007 fa72 	bl	800ca50 <atcm_program_AT_CMD>
 800556c:	f7ff b948 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005570:	4640      	mov	r0, r8
 8005572:	f007 fac9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005576:	f7ff b943 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800557a:	7caf      	ldrb	r7, [r5, #18]
 800557c:	b127      	cbz	r7, 8005588 <ATCustom_TYPE1SC_getCmd+0xe50>
    else if (p_atp_ctxt->step == 1U)
 800557e:	2f01      	cmp	r7, #1
 8005580:	d00e      	beq.n	80055a0 <ATCustom_TYPE1SC_getCmd+0xe68>
      retval = ATSTATUS_ERROR;
 8005582:	2401      	movs	r4, #1
 8005584:	f7ff b93c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      low_power_state_requested();
 8005588:	f7fe ffea 	bl	8004560 <low_power_state_requested>
      (void) SysCtrl_TYPE1SC_request_suspend_channel(p_at_ctxt->ipc_handle, DEVTYPE_MODEM_CELLULAR);
 800558c:	2100      	movs	r1, #0
 800558e:	6868      	ldr	r0, [r5, #4]
 8005590:	f001 f8e8 	bl	8006764 <SysCtrl_TYPE1SC_request_suspend_channel>
      atcm_program_SKIP_CMD(p_atp_ctxt);
 8005594:	4640      	mov	r0, r8
 8005596:	f007 fac3 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 800559a:	463c      	mov	r4, r7
 800559c:	f7ff b930 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80055a0:	4640      	mov	r0, r8
 80055a2:	f007 fab1 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80055a6:	f7ff b92b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80055aa:	7cac      	ldrb	r4, [r5, #18]
 80055ac:	b114      	cbz	r4, 80055b4 <ATCustom_TYPE1SC_getCmd+0xe7c>
      retval = ATSTATUS_ERROR;
 80055ae:	2401      	movs	r4, #1
 80055b0:	f7ff b926 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      (void) SysCtrl_TYPE1SC_complete_suspend_channel(p_at_ctxt->ipc_handle, DEVTYPE_MODEM_CELLULAR);
 80055b4:	2100      	movs	r1, #0
 80055b6:	6868      	ldr	r0, [r5, #4]
 80055b8:	f001 f924 	bl	8006804 <SysCtrl_TYPE1SC_complete_suspend_channel>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80055bc:	4640      	mov	r0, r8
 80055be:	f007 faa3 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80055c2:	f7ff b91d 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80055c6:	7cac      	ldrb	r4, [r5, #18]
 80055c8:	b114      	cbz	r4, 80055d0 <ATCustom_TYPE1SC_getCmd+0xe98>
      retval = ATSTATUS_ERROR;
 80055ca:	2401      	movs	r4, #1
 80055cc:	f7ff b918 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      low_power_state_cancel();
 80055d0:	f7fe ffd8 	bl	8004584 <low_power_state_cancel>
      (void) SysCtrl_TYPE1SC_resume_channel(p_at_ctxt->ipc_handle,
 80055d4:	2200      	movs	r2, #0
 80055d6:	4611      	mov	r1, r2
 80055d8:	6868      	ldr	r0, [r5, #4]
 80055da:	f001 fb97 	bl	8006d0c <SysCtrl_TYPE1SC_resume_channel>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80055de:	4640      	mov	r0, r8
 80055e0:	f007 fa92 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80055e4:	f7ff b90c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80055e8:	7cac      	ldrb	r4, [r5, #18]
 80055ea:	2c00      	cmp	r4, #0
 80055ec:	f040 80a8 	bne.w	8005740 <ATCustom_TYPE1SC_getCmd+0x1008>
      uint8_t modem_originated = (TYPE1SC_ctxt.SID_ctxt.wakeup_origin == MODEM_WAKEUP) ? 1U : 0U;
 80055f0:	4b14      	ldr	r3, [pc, #80]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80055f2:	f893 3729 	ldrb.w	r3, [r3, #1833]	; 0x729
 80055f6:	2b02      	cmp	r3, #2
 80055f8:	d009      	beq.n	800560e <ATCustom_TYPE1SC_getCmd+0xed6>
 80055fa:	4622      	mov	r2, r4
      (void) SysCtrl_TYPE1SC_resume_channel(p_at_ctxt->ipc_handle,
 80055fc:	2100      	movs	r1, #0
 80055fe:	6868      	ldr	r0, [r5, #4]
 8005600:	f001 fb84 	bl	8006d0c <SysCtrl_TYPE1SC_resume_channel>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005604:	4640      	mov	r0, r8
 8005606:	f007 fa7f 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800560a:	f7ff b8f9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      uint8_t modem_originated = (TYPE1SC_ctxt.SID_ctxt.wakeup_origin == MODEM_WAKEUP) ? 1U : 0U;
 800560e:	2201      	movs	r2, #1
 8005610:	e7f4      	b.n	80055fc <ATCustom_TYPE1SC_getCmd+0xec4>
    if (p_atp_ctxt->step == 0U)
 8005612:	7cac      	ldrb	r4, [r5, #18]
 8005614:	b114      	cbz	r4, 800561c <ATCustom_TYPE1SC_getCmd+0xee4>
      retval = ATSTATUS_ERROR;
 8005616:	2401      	movs	r4, #1
 8005618:	f7ff b8f2 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_DNSRSLV, FINAL_CMD);
 800561c:	2301      	movs	r3, #1
 800561e:	9300      	str	r3, [sp, #0]
 8005620:	233f      	movs	r3, #63	; 0x3f
 8005622:	2203      	movs	r2, #3
 8005624:	4641      	mov	r1, r8
 8005626:	4807      	ldr	r0, [pc, #28]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005628:	f007 fa12 	bl	800ca50 <atcm_program_AT_CMD>
 800562c:	f7ff b8e8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005630:	4640      	mov	r0, r8
 8005632:	f007 fa69 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005636:	f7ff b8e3 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800563a:	7cac      	ldrb	r4, [r5, #18]
 800563c:	b144      	cbz	r4, 8005650 <ATCustom_TYPE1SC_getCmd+0xf18>
      retval = ATSTATUS_ERROR;
 800563e:	2401      	movs	r4, #1
 8005640:	f7ff b8de 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8005644:	20001084 	.word	0x20001084
 8005648:	200048dc 	.word	0x200048dc
 800564c:	0802bac0 	.word	0x0802bac0
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PINGCMD, FINAL_CMD);
 8005650:	2301      	movs	r3, #1
 8005652:	9300      	str	r3, [sp, #0]
 8005654:	2340      	movs	r3, #64	; 0x40
 8005656:	2203      	movs	r2, #3
 8005658:	4641      	mov	r1, r8
 800565a:	483b      	ldr	r0, [pc, #236]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 800565c:	f007 f9f8 	bl	800ca50 <atcm_program_AT_CMD>
 8005660:	f7ff b8ce 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005664:	7cac      	ldrb	r4, [r5, #18]
 8005666:	b114      	cbz	r4, 800566e <ATCustom_TYPE1SC_getCmd+0xf36>
      retval = ATSTATUS_ERROR;
 8005668:	2401      	movs	r4, #1
 800566a:	f7ff b8c9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_RAW_CMD, (CMD_ID_t) CMD_AT_DIRECT_CMD, FINAL_CMD);
 800566e:	4d36      	ldr	r5, [pc, #216]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 8005670:	2301      	movs	r3, #1
 8005672:	9300      	str	r3, [sp, #0]
 8005674:	2334      	movs	r3, #52	; 0x34
 8005676:	2206      	movs	r2, #6
 8005678:	4641      	mov	r1, r8
 800567a:	4628      	mov	r0, r5
 800567c:	f007 f9e8 	bl	800ca50 <atcm_program_AT_CMD>
      atcm_program_CMD_TIMEOUT(&TYPE1SC_ctxt, p_atp_ctxt, TYPE1SC_ctxt.SID_ctxt.direct_cmd_tx->cmd_timeout);
 8005680:	f8d5 3714 	ldr.w	r3, [r5, #1812]	; 0x714
 8005684:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8005686:	4641      	mov	r1, r8
 8005688:	4628      	mov	r0, r5
 800568a:	f007 fa05 	bl	800ca98 <atcm_program_CMD_TIMEOUT>
 800568e:	f7ff b8b7 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005692:	7cac      	ldrb	r4, [r5, #18]
 8005694:	b114      	cbz	r4, 800569c <ATCustom_TYPE1SC_getCmd+0xf64>
      retval = ATSTATUS_ERROR;
 8005696:	2401      	movs	r4, #1
 8005698:	f7ff b8b2 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      type1sc_shared.setcfg_function = SETGETCFG_SIM_POLICY;
 800569c:	2301      	movs	r3, #1
 800569e:	4a2b      	ldr	r2, [pc, #172]	; (800574c <ATCustom_TYPE1SC_getCmd+0x1014>)
 80056a0:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SETCFG, FINAL_CMD);
 80056a4:	9300      	str	r3, [sp, #0]
 80056a6:	233a      	movs	r3, #58	; 0x3a
 80056a8:	2203      	movs	r2, #3
 80056aa:	4641      	mov	r1, r8
 80056ac:	4826      	ldr	r0, [pc, #152]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 80056ae:	f007 f9cf 	bl	800ca50 <atcm_program_AT_CMD>
 80056b2:	f7ff b8a5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80056b6:	7cac      	ldrb	r4, [r5, #18]
 80056b8:	b114      	cbz	r4, 80056c0 <ATCustom_TYPE1SC_getCmd+0xf88>
      retval = ATSTATUS_ERROR;
 80056ba:	2401      	movs	r4, #1
 80056bc:	f7ff b8a0 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CSIM, FINAL_CMD);
 80056c0:	2301      	movs	r3, #1
 80056c2:	9300      	str	r3, [sp, #0]
 80056c4:	2326      	movs	r3, #38	; 0x26
 80056c6:	2203      	movs	r2, #3
 80056c8:	4641      	mov	r1, r8
 80056ca:	481f      	ldr	r0, [pc, #124]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 80056cc:	f007 f9c0 	bl	800ca50 <atcm_program_AT_CMD>
 80056d0:	f7ff b896 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    PRINT_ERR("Error, invalid command ID %d", curSID)
 80056d4:	4c1e      	ldr	r4, [pc, #120]	; (8005750 <ATCustom_TYPE1SC_getCmd+0x1018>)
 80056d6:	463a      	mov	r2, r7
 80056d8:	491e      	ldr	r1, [pc, #120]	; (8005754 <ATCustom_TYPE1SC_getCmd+0x101c>)
 80056da:	4620      	mov	r0, r4
 80056dc:	f020 fac8 	bl	8025c70 <sprintf>
 80056e0:	4620      	mov	r0, r4
 80056e2:	f019 fd16 	bl	801f112 <crs_strlen>
 80056e6:	b283      	uxth	r3, r0
 80056e8:	4622      	mov	r2, r4
 80056ea:	2110      	movs	r1, #16
 80056ec:	2002      	movs	r0, #2
 80056ee:	f019 fd53 	bl	801f198 <traceIF_itmPrint>
 80056f2:	4620      	mov	r0, r4
 80056f4:	f019 fd0d 	bl	801f112 <crs_strlen>
 80056f8:	b283      	uxth	r3, r0
 80056fa:	4622      	mov	r2, r4
 80056fc:	2110      	movs	r1, #16
 80056fe:	2002      	movs	r0, #2
 8005700:	f019 fd6c 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 8005704:	2401      	movs	r4, #1
 8005706:	f7ff b87b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 800570a:	2401      	movs	r4, #1
 800570c:	f7ff b878 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      switch (TYPE1SC_ctxt.SID_ctxt.device_info->field_requested)
 8005710:	2401      	movs	r4, #1
 8005712:	f7ff b875 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8005716:	2401      	movs	r4, #1
 8005718:	f7ff b872 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 800571c:	2401      	movs	r4, #1
 800571e:	f7ff b86f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005722:	2401      	movs	r4, #1
 8005724:	f7ff b86c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005728:	2401      	movs	r4, #1
 800572a:	f7ff b869 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 800572e:	2401      	movs	r4, #1
 8005730:	f7ff b866 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005734:	2401      	movs	r4, #1
 8005736:	f7ff b863 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800573a:	2401      	movs	r4, #1
 800573c:	f7ff b860 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005740:	2401      	movs	r4, #1
 8005742:	f7ff b85d 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8005746:	bf00      	nop
 8005748:	20001084 	.word	0x20001084
 800574c:	20001838 	.word	0x20001838
 8005750:	200048dc 	.word	0x200048dc
 8005754:	0802bb00 	.word	0x0802bb00

08005758 <ATCustom_TYPE1SC_extractElement>:
{
 8005758:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800575c:	4680      	mov	r8, r0
 800575e:	460f      	mov	r7, r1
 8005760:	4614      	mov	r4, r2
  PRINT_API("enter ATCustom_TYPE1SC_extractElement()")
 8005762:	4e54      	ldr	r6, [pc, #336]	; (80058b4 <ATCustom_TYPE1SC_extractElement+0x15c>)
 8005764:	4d54      	ldr	r5, [pc, #336]	; (80058b8 <ATCustom_TYPE1SC_extractElement+0x160>)
 8005766:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 800576a:	46b4      	mov	ip, r6
 800576c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005770:	6028      	str	r0, [r5, #0]
 8005772:	6069      	str	r1, [r5, #4]
 8005774:	60aa      	str	r2, [r5, #8]
 8005776:	60eb      	str	r3, [r5, #12]
 8005778:	4666      	mov	r6, ip
 800577a:	3510      	adds	r5, #16
 800577c:	45f4      	cmp	ip, lr
 800577e:	d1f4      	bne.n	800576a <ATCustom_TYPE1SC_extractElement+0x12>
 8005780:	f8dc 0000 	ldr.w	r0, [ip]
 8005784:	6028      	str	r0, [r5, #0]
 8005786:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800578a:	80ab      	strh	r3, [r5, #4]
 800578c:	4d4a      	ldr	r5, [pc, #296]	; (80058b8 <ATCustom_TYPE1SC_extractElement+0x160>)
 800578e:	4628      	mov	r0, r5
 8005790:	f019 fcbf 	bl	801f112 <crs_strlen>
 8005794:	b283      	uxth	r3, r0
 8005796:	462a      	mov	r2, r5
 8005798:	2104      	movs	r1, #4
 800579a:	2002      	movs	r0, #2
 800579c:	f019 fcfc 	bl	801f198 <traceIF_itmPrint>
 80057a0:	4628      	mov	r0, r5
 80057a2:	f019 fcb6 	bl	801f112 <crs_strlen>
 80057a6:	b283      	uxth	r3, r0
 80057a8:	462a      	mov	r2, r5
 80057aa:	2104      	movs	r1, #4
 80057ac:	2002      	movs	r0, #2
 80057ae:	f019 fd15 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("input message: size=%d ", p_msg_in->size)
 80057b2:	f8b7 27d0 	ldrh.w	r2, [r7, #2000]	; 0x7d0
 80057b6:	4941      	ldr	r1, [pc, #260]	; (80058bc <ATCustom_TYPE1SC_extractElement+0x164>)
 80057b8:	4628      	mov	r0, r5
 80057ba:	f020 fa59 	bl	8025c70 <sprintf>
 80057be:	4628      	mov	r0, r5
 80057c0:	f019 fca7 	bl	801f112 <crs_strlen>
 80057c4:	b283      	uxth	r3, r0
 80057c6:	462a      	mov	r2, r5
 80057c8:	2102      	movs	r1, #2
 80057ca:	4608      	mov	r0, r1
 80057cc:	f019 fce4 	bl	801f198 <traceIF_itmPrint>
 80057d0:	4628      	mov	r0, r5
 80057d2:	f019 fc9e 	bl	801f112 <crs_strlen>
 80057d6:	b283      	uxth	r3, r0
 80057d8:	462a      	mov	r2, r5
 80057da:	2102      	movs	r1, #2
 80057dc:	4608      	mov	r0, r1
 80057de:	f019 fcfd 	bl	801f1dc <traceIF_uartPrint>
  if (*p_parseIndex == 0U)
 80057e2:	8823      	ldrh	r3, [r4, #0]
 80057e4:	b923      	cbnz	r3, 80057f0 <ATCustom_TYPE1SC_extractElement+0x98>
    if ((p_msg_in->buffer[0] == (AT_CHAR_t)('\r')) && (p_msg_in->buffer[1] == (AT_CHAR_t)('\n')))
 80057e6:	883a      	ldrh	r2, [r7, #0]
 80057e8:	f640 230d 	movw	r3, #2573	; 0xa0d
 80057ec:	429a      	cmp	r2, r3
 80057ee:	d00b      	beq.n	8005808 <ATCustom_TYPE1SC_extractElement+0xb0>
  element_infos->str_start_idx = *p_parseIndex;
 80057f0:	8823      	ldrh	r3, [r4, #0]
 80057f2:	8163      	strh	r3, [r4, #10]
  element_infos->str_end_idx = *p_parseIndex;
 80057f4:	81a3      	strh	r3, [r4, #12]
  element_infos->str_size = 0U;
 80057f6:	2200      	movs	r2, #0
 80057f8:	81e2      	strh	r2, [r4, #14]
  if (*p_parseIndex >= p_msg_in->size)
 80057fa:	f8b7 27d0 	ldrh.w	r2, [r7, #2000]	; 0x7d0
 80057fe:	4293      	cmp	r3, r2
 8005800:	d32a      	bcc.n	8005858 <ATCustom_TYPE1SC_extractElement+0x100>
    retval_msg_end_detected = ATENDMSG_YES;
 8005802:	2000      	movs	r0, #0
}
 8005804:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      PRINT_DBG("cmd init sequence <CR><LF> found - break")
 8005808:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 80058c0 <ATCustom_TYPE1SC_extractElement+0x168>
 800580c:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 8005810:	4666      	mov	r6, ip
 8005812:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005814:	6028      	str	r0, [r5, #0]
 8005816:	6069      	str	r1, [r5, #4]
 8005818:	60aa      	str	r2, [r5, #8]
 800581a:	60eb      	str	r3, [r5, #12]
 800581c:	46b4      	mov	ip, r6
 800581e:	3510      	adds	r5, #16
 8005820:	4576      	cmp	r6, lr
 8005822:	d1f5      	bne.n	8005810 <ATCustom_TYPE1SC_extractElement+0xb8>
 8005824:	8832      	ldrh	r2, [r6, #0]
 8005826:	78b3      	ldrb	r3, [r6, #2]
 8005828:	802a      	strh	r2, [r5, #0]
 800582a:	70ab      	strb	r3, [r5, #2]
 800582c:	4d22      	ldr	r5, [pc, #136]	; (80058b8 <ATCustom_TYPE1SC_extractElement+0x160>)
 800582e:	4628      	mov	r0, r5
 8005830:	f019 fc6f 	bl	801f112 <crs_strlen>
 8005834:	b283      	uxth	r3, r0
 8005836:	462a      	mov	r2, r5
 8005838:	2102      	movs	r1, #2
 800583a:	4608      	mov	r0, r1
 800583c:	f019 fcac 	bl	801f198 <traceIF_itmPrint>
 8005840:	4628      	mov	r0, r5
 8005842:	f019 fc66 	bl	801f112 <crs_strlen>
 8005846:	b283      	uxth	r3, r0
 8005848:	462a      	mov	r2, r5
 800584a:	2102      	movs	r1, #2
 800584c:	4608      	mov	r0, r1
 800584e:	f019 fcc5 	bl	801f1dc <traceIF_uartPrint>
      *p_parseIndex = 2U;
 8005852:	2302      	movs	r3, #2
 8005854:	8023      	strh	r3, [r4, #0]
 8005856:	e7cb      	b.n	80057f0 <ATCustom_TYPE1SC_extractElement+0x98>
  exit_loop = false;
 8005858:	2100      	movs	r1, #0
  at_endmsg_t retval_msg_end_detected = ATENDMSG_NO;
 800585a:	2001      	movs	r0, #1
    switch (p_msg_in->buffer[*p_parseIndex])
 800585c:	8823      	ldrh	r3, [r4, #0]
 800585e:	5cfa      	ldrb	r2, [r7, r3]
 8005860:	2a3a      	cmp	r2, #58	; 0x3a
 8005862:	d021      	beq.n	80058a8 <ATCustom_TYPE1SC_extractElement+0x150>
 8005864:	d813      	bhi.n	800588e <ATCustom_TYPE1SC_extractElement+0x136>
 8005866:	2a0d      	cmp	r2, #13
 8005868:	d020      	beq.n	80058ac <ATCustom_TYPE1SC_extractElement+0x154>
 800586a:	2a2c      	cmp	r2, #44	; 0x2c
 800586c:	d117      	bne.n	800589e <ATCustom_TYPE1SC_extractElement+0x146>
 800586e:	2101      	movs	r1, #1
    (*p_parseIndex)++;
 8005870:	3301      	adds	r3, #1
 8005872:	b29b      	uxth	r3, r3
 8005874:	8023      	strh	r3, [r4, #0]
    if (*p_parseIndex >= p_msg_in->size)
 8005876:	f8b7 27d0 	ldrh.w	r2, [r7, #2000]	; 0x7d0
 800587a:	4293      	cmp	r3, r2
 800587c:	d301      	bcc.n	8005882 <ATCustom_TYPE1SC_extractElement+0x12a>
      exit_loop = true;
 800587e:	2101      	movs	r1, #1
      retval_msg_end_detected = ATENDMSG_YES;
 8005880:	2000      	movs	r0, #0
  } while (exit_loop == false);
 8005882:	2900      	cmp	r1, #0
 8005884:	d0ea      	beq.n	800585c <ATCustom_TYPE1SC_extractElement+0x104>
  element_infos->param_rank = (element_infos->param_rank + 1U);
 8005886:	8923      	ldrh	r3, [r4, #8]
 8005888:	3301      	adds	r3, #1
 800588a:	8123      	strh	r3, [r4, #8]
 800588c:	e7ba      	b.n	8005804 <ATCustom_TYPE1SC_extractElement+0xac>
    switch (p_msg_in->buffer[*p_parseIndex])
 800588e:	2a3d      	cmp	r2, #61	; 0x3d
 8005890:	d105      	bne.n	800589e <ATCustom_TYPE1SC_extractElement+0x146>
        if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t)CMD_AT_IFC)
 8005892:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8005896:	2a32      	cmp	r2, #50	; 0x32
 8005898:	d1ea      	bne.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
          exit_loop = true;
 800589a:	2101      	movs	r1, #1
 800589c:	e7e8      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
        element_infos->str_end_idx = *p_parseIndex;
 800589e:	81a3      	strh	r3, [r4, #12]
        element_infos->str_size++;
 80058a0:	89e2      	ldrh	r2, [r4, #14]
 80058a2:	3201      	adds	r2, #1
 80058a4:	81e2      	strh	r2, [r4, #14]
        break;
 80058a6:	e7e3      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
    switch (p_msg_in->buffer[*p_parseIndex])
 80058a8:	2101      	movs	r1, #1
 80058aa:	e7e1      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
        exit_loop = true;
 80058ac:	2101      	movs	r1, #1
        retval_msg_end_detected = ATENDMSG_YES;
 80058ae:	2000      	movs	r0, #0
 80058b0:	e7de      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
 80058b2:	bf00      	nop
 80058b4:	0802bb30 	.word	0x0802bb30
 80058b8:	200048dc 	.word	0x200048dc
 80058bc:	0802bb68 	.word	0x0802bb68
 80058c0:	0802bb8c 	.word	0x0802bb8c

080058c4 <ATCustom_TYPE1SC_analyzeCmd>:
{
 80058c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80058c8:	4607      	mov	r7, r0
 80058ca:	4688      	mov	r8, r1
 80058cc:	4616      	mov	r6, r2
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
 80058ce:	f100 0910 	add.w	r9, r0, #16
  PRINT_API("enter ATCustom_TYPE1SC_analyzeCmd()")
 80058d2:	4d9a      	ldr	r5, [pc, #616]	; (8005b3c <ATCustom_TYPE1SC_analyzeCmd+0x278>)
 80058d4:	4c9a      	ldr	r4, [pc, #616]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 80058d6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80058da:	46ac      	mov	ip, r5
 80058dc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80058e0:	6020      	str	r0, [r4, #0]
 80058e2:	6061      	str	r1, [r4, #4]
 80058e4:	60a2      	str	r2, [r4, #8]
 80058e6:	60e3      	str	r3, [r4, #12]
 80058e8:	4665      	mov	r5, ip
 80058ea:	3410      	adds	r4, #16
 80058ec:	45f4      	cmp	ip, lr
 80058ee:	d1f4      	bne.n	80058da <ATCustom_TYPE1SC_analyzeCmd+0x16>
 80058f0:	f8bc 3000 	ldrh.w	r3, [ip]
 80058f4:	8023      	strh	r3, [r4, #0]
 80058f6:	4c92      	ldr	r4, [pc, #584]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 80058f8:	4620      	mov	r0, r4
 80058fa:	f019 fc0a 	bl	801f112 <crs_strlen>
 80058fe:	b283      	uxth	r3, r0
 8005900:	4622      	mov	r2, r4
 8005902:	2104      	movs	r1, #4
 8005904:	2002      	movs	r0, #2
 8005906:	f019 fc47 	bl	801f198 <traceIF_itmPrint>
 800590a:	4620      	mov	r0, r4
 800590c:	f019 fc01 	bl	801f112 <crs_strlen>
 8005910:	b283      	uxth	r3, r0
 8005912:	4622      	mov	r2, r4
 8005914:	2104      	movs	r1, #4
 8005916:	2002      	movs	r0, #2
 8005918:	f019 fc60 	bl	801f1dc <traceIF_uartPrint>
  if (ATSTATUS_OK != atcm_searchCmdInLUT(&TYPE1SC_ctxt, p_atp_ctxt, p_msg_in, element_infos))
 800591c:	4633      	mov	r3, r6
 800591e:	4642      	mov	r2, r8
 8005920:	4649      	mov	r1, r9
 8005922:	4888      	ldr	r0, [pc, #544]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 8005924:	f007 fd58 	bl	800d3d8 <atcm_searchCmdInLUT>
 8005928:	2800      	cmp	r0, #0
 800592a:	d157      	bne.n	80059dc <ATCustom_TYPE1SC_analyzeCmd+0x118>
    switch (element_infos->cmd_id_received)
 800592c:	6873      	ldr	r3, [r6, #4]
 800592e:	2b4e      	cmp	r3, #78	; 0x4e
 8005930:	f200 8092 	bhi.w	8005a58 <ATCustom_TYPE1SC_analyzeCmd+0x194>
 8005934:	2b4e      	cmp	r3, #78	; 0x4e
 8005936:	f200 8093 	bhi.w	8005a60 <ATCustom_TYPE1SC_analyzeCmd+0x19c>
 800593a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800593e:	01aa      	.short	0x01aa
 8005940:	010b009b 	.word	0x010b009b
 8005944:	008b008b 	.word	0x008b008b
 8005948:	008b01ac 	.word	0x008b01ac
 800594c:	008b008b 	.word	0x008b008b
 8005950:	01b301b3 	.word	0x01b301b3
 8005954:	00910091 	.word	0x00910091
 8005958:	00910091 	.word	0x00910091
 800595c:	00910091 	.word	0x00910091
 8005960:	01e10091 	.word	0x01e10091
 8005964:	009101e1 	.word	0x009101e1
 8005968:	00910091 	.word	0x00910091
 800596c:	01e10133 	.word	0x01e10133
 8005970:	00910133 	.word	0x00910133
 8005974:	0091013a 	.word	0x0091013a
 8005978:	00910091 	.word	0x00910091
 800597c:	00910091 	.word	0x00910091
 8005980:	00910091 	.word	0x00910091
 8005984:	00910091 	.word	0x00910091
 8005988:	00910091 	.word	0x00910091
 800598c:	00910091 	.word	0x00910091
 8005990:	00910091 	.word	0x00910091
 8005994:	00910091 	.word	0x00910091
 8005998:	00910091 	.word	0x00910091
 800599c:	00910091 	.word	0x00910091
 80059a0:	00910091 	.word	0x00910091
 80059a4:	00910091 	.word	0x00910091
 80059a8:	00910091 	.word	0x00910091
 80059ac:	00910091 	.word	0x00910091
 80059b0:	00910091 	.word	0x00910091
 80059b4:	00910091 	.word	0x00910091
 80059b8:	00910091 	.word	0x00910091
 80059bc:	0140013e 	.word	0x0140013e
 80059c0:	00910091 	.word	0x00910091
 80059c4:	00910091 	.word	0x00910091
 80059c8:	00910091 	.word	0x00910091
 80059cc:	00910091 	.word	0x00910091
 80059d0:	00910091 	.word	0x00910091
 80059d4:	013c013c 	.word	0x013c013c
 80059d8:	014201e1 	.word	0x014201e1
    retval = atcm_check_text_line_cmd(&TYPE1SC_ctxt, p_at_ctxt, p_msg_in, element_infos);
 80059dc:	4633      	mov	r3, r6
 80059de:	4642      	mov	r2, r8
 80059e0:	4639      	mov	r1, r7
 80059e2:	4858      	ldr	r0, [pc, #352]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 80059e4:	f007 fd5e 	bl	800d4a4 <atcm_check_text_line_cmd>
    if (retval == ATACTION_RSP_NO_ACTION)
 80059e8:	2800      	cmp	r0, #0
 80059ea:	f040 818c 	bne.w	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
      switch (p_atp_ctxt->current_atcmd.id)
 80059ee:	69fb      	ldr	r3, [r7, #28]
 80059f0:	2b3d      	cmp	r3, #61	; 0x3d
 80059f2:	d028      	beq.n	8005a46 <ATCustom_TYPE1SC_analyzeCmd+0x182>
          PRINT_DBG("receive an un-expected line... is it a text line ?")
 80059f4:	4d54      	ldr	r5, [pc, #336]	; (8005b48 <ATCustom_TYPE1SC_analyzeCmd+0x284>)
 80059f6:	4c52      	ldr	r4, [pc, #328]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 80059f8:	f105 0730 	add.w	r7, r5, #48	; 0x30
 80059fc:	462e      	mov	r6, r5
 80059fe:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005a00:	6020      	str	r0, [r4, #0]
 8005a02:	6061      	str	r1, [r4, #4]
 8005a04:	60a2      	str	r2, [r4, #8]
 8005a06:	60e3      	str	r3, [r4, #12]
 8005a08:	4635      	mov	r5, r6
 8005a0a:	3410      	adds	r4, #16
 8005a0c:	42be      	cmp	r6, r7
 8005a0e:	d1f5      	bne.n	80059fc <ATCustom_TYPE1SC_analyzeCmd+0x138>
 8005a10:	cd07      	ldmia	r5!, {r0, r1, r2}
 8005a12:	6020      	str	r0, [r4, #0]
 8005a14:	6061      	str	r1, [r4, #4]
 8005a16:	60a2      	str	r2, [r4, #8]
 8005a18:	782b      	ldrb	r3, [r5, #0]
 8005a1a:	7323      	strb	r3, [r4, #12]
 8005a1c:	4c48      	ldr	r4, [pc, #288]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005a1e:	4620      	mov	r0, r4
 8005a20:	f019 fb77 	bl	801f112 <crs_strlen>
 8005a24:	b283      	uxth	r3, r0
 8005a26:	4622      	mov	r2, r4
 8005a28:	2102      	movs	r1, #2
 8005a2a:	4608      	mov	r0, r1
 8005a2c:	f019 fbb4 	bl	801f198 <traceIF_itmPrint>
 8005a30:	4620      	mov	r0, r4
 8005a32:	f019 fb6e 	bl	801f112 <crs_strlen>
 8005a36:	b283      	uxth	r3, r0
 8005a38:	4622      	mov	r2, r4
 8005a3a:	2102      	movs	r1, #2
 8005a3c:	4608      	mov	r0, r1
 8005a3e:	f019 fbcd 	bl	801f1dc <traceIF_uartPrint>
          retval = ATACTION_RSP_IGNORED;
 8005a42:	2010      	movs	r0, #16
          break;
 8005a44:	e15f      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          retval = fCmdpAnalyze_GETCFG_TYPE1SC(p_at_ctxt, &TYPE1SC_ctxt, p_msg_in, element_infos);
 8005a46:	4633      	mov	r3, r6
 8005a48:	4642      	mov	r2, r8
 8005a4a:	493e      	ldr	r1, [pc, #248]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 8005a4c:	4638      	mov	r0, r7
 8005a4e:	f7fd f8c7 	bl	8002be0 <fCmdpAnalyze_GETCFG_TYPE1SC>
          break;
 8005a52:	e158      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
    switch (element_infos->cmd_id_received)
 8005a54:	2004      	movs	r0, #4
 8005a56:	e156      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
 8005a58:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005a5c:	f000 8152 	beq.w	8005d04 <ATCustom_TYPE1SC_analyzeCmd+0x440>
        if (element_infos->cmd_id_received == p_atp_ctxt->current_atcmd.id)
 8005a60:	69fa      	ldr	r2, [r7, #28]
 8005a62:	4293      	cmp	r3, r2
 8005a64:	f000 8153 	beq.w	8005d0e <ATCustom_TYPE1SC_analyzeCmd+0x44a>
        else if (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD)
 8005a68:	8b3b      	ldrh	r3, [r7, #24]
 8005a6a:	2b06      	cmp	r3, #6
 8005a6c:	f040 8121 	bne.w	8005cb2 <ATCustom_TYPE1SC_analyzeCmd+0x3ee>
          retval = ATACTION_RSP_IGNORED;
 8005a70:	2010      	movs	r0, #16
 8005a72:	e148      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_DATA_SUSPEND)
 8005a74:	8a3b      	ldrh	r3, [r7, #16]
 8005a76:	2b7e      	cmp	r3, #126	; 0x7e
 8005a78:	d006      	beq.n	8005a88 <ATCustom_TYPE1SC_analyzeCmd+0x1c4>
        if ((p_atp_ctxt->current_SID == (at_msg_t) SID_CS_POWER_ON) ||
 8005a7a:	8a3b      	ldrh	r3, [r7, #16]
 8005a7c:	2b65      	cmp	r3, #101	; 0x65
 8005a7e:	d02a      	beq.n	8005ad6 <ATCustom_TYPE1SC_analyzeCmd+0x212>
 8005a80:	2b80      	cmp	r3, #128	; 0x80
 8005a82:	d028      	beq.n	8005ad6 <ATCustom_TYPE1SC_analyzeCmd+0x212>
        retval = ATACTION_RSP_FRC_END;
 8005a84:	2001      	movs	r0, #1
 8005a86:	e13e      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          PRINT_INFO("MODEM SWITCHES TO COMMAND MODE")
 8005a88:	4d30      	ldr	r5, [pc, #192]	; (8005b4c <ATCustom_TYPE1SC_analyzeCmd+0x288>)
 8005a8a:	4c2d      	ldr	r4, [pc, #180]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005a8c:	f105 0c20 	add.w	ip, r5, #32
 8005a90:	462e      	mov	r6, r5
 8005a92:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005a94:	6020      	str	r0, [r4, #0]
 8005a96:	6061      	str	r1, [r4, #4]
 8005a98:	60a2      	str	r2, [r4, #8]
 8005a9a:	60e3      	str	r3, [r4, #12]
 8005a9c:	4635      	mov	r5, r6
 8005a9e:	3410      	adds	r4, #16
 8005aa0:	4566      	cmp	r6, ip
 8005aa2:	d1f5      	bne.n	8005a90 <ATCustom_TYPE1SC_analyzeCmd+0x1cc>
 8005aa4:	cd03      	ldmia	r5!, {r0, r1}
 8005aa6:	6020      	str	r0, [r4, #0]
 8005aa8:	6061      	str	r1, [r4, #4]
 8005aaa:	782b      	ldrb	r3, [r5, #0]
 8005aac:	7223      	strb	r3, [r4, #8]
 8005aae:	4c24      	ldr	r4, [pc, #144]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005ab0:	4620      	mov	r0, r4
 8005ab2:	f019 fb2e 	bl	801f112 <crs_strlen>
 8005ab6:	b283      	uxth	r3, r0
 8005ab8:	4622      	mov	r2, r4
 8005aba:	2101      	movs	r1, #1
 8005abc:	2002      	movs	r0, #2
 8005abe:	f019 fb6b 	bl	801f198 <traceIF_itmPrint>
 8005ac2:	4620      	mov	r0, r4
 8005ac4:	f019 fb25 	bl	801f112 <crs_strlen>
 8005ac8:	b283      	uxth	r3, r0
 8005aca:	4622      	mov	r2, r4
 8005acc:	2101      	movs	r1, #1
 8005ace:	2002      	movs	r0, #2
 8005ad0:	f019 fb84 	bl	801f1dc <traceIF_uartPrint>
 8005ad4:	e7d1      	b.n	8005a7a <ATCustom_TYPE1SC_analyzeCmd+0x1b6>
          if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT)
 8005ad6:	69fb      	ldr	r3, [r7, #28]
 8005ad8:	b91b      	cbnz	r3, 8005ae2 <ATCustom_TYPE1SC_analyzeCmd+0x21e>
            TYPE1SC_ctxt.persist.modem_at_ready = AT_TRUE;
 8005ada:	4b1a      	ldr	r3, [pc, #104]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 8005adc:	2201      	movs	r2, #1
 8005ade:	f883 250e 	strb.w	r2, [r3, #1294]	; 0x50e
          if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_ATE)
 8005ae2:	69fb      	ldr	r3, [r7, #28]
 8005ae4:	2b28      	cmp	r3, #40	; 0x28
 8005ae6:	d001      	beq.n	8005aec <ATCustom_TYPE1SC_analyzeCmd+0x228>
        retval = ATACTION_RSP_FRC_END;
 8005ae8:	2001      	movs	r0, #1
 8005aea:	e10c      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
            PRINT_DBG("Echo successfully disabled")
 8005aec:	4e18      	ldr	r6, [pc, #96]	; (8005b50 <ATCustom_TYPE1SC_analyzeCmd+0x28c>)
 8005aee:	4d14      	ldr	r5, [pc, #80]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005af0:	f106 0720 	add.w	r7, r6, #32
 8005af4:	4634      	mov	r4, r6
 8005af6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005af8:	6028      	str	r0, [r5, #0]
 8005afa:	6069      	str	r1, [r5, #4]
 8005afc:	60aa      	str	r2, [r5, #8]
 8005afe:	60eb      	str	r3, [r5, #12]
 8005b00:	4626      	mov	r6, r4
 8005b02:	3510      	adds	r5, #16
 8005b04:	42bc      	cmp	r4, r7
 8005b06:	d1f5      	bne.n	8005af4 <ATCustom_TYPE1SC_analyzeCmd+0x230>
 8005b08:	6820      	ldr	r0, [r4, #0]
 8005b0a:	6028      	str	r0, [r5, #0]
 8005b0c:	7923      	ldrb	r3, [r4, #4]
 8005b0e:	712b      	strb	r3, [r5, #4]
 8005b10:	4c0b      	ldr	r4, [pc, #44]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005b12:	4620      	mov	r0, r4
 8005b14:	f019 fafd 	bl	801f112 <crs_strlen>
 8005b18:	b283      	uxth	r3, r0
 8005b1a:	4622      	mov	r2, r4
 8005b1c:	2102      	movs	r1, #2
 8005b1e:	4608      	mov	r0, r1
 8005b20:	f019 fb3a 	bl	801f198 <traceIF_itmPrint>
 8005b24:	4620      	mov	r0, r4
 8005b26:	f019 faf4 	bl	801f112 <crs_strlen>
 8005b2a:	b283      	uxth	r3, r0
 8005b2c:	4622      	mov	r2, r4
 8005b2e:	2102      	movs	r1, #2
 8005b30:	4608      	mov	r0, r1
 8005b32:	f019 fb53 	bl	801f1dc <traceIF_uartPrint>
        retval = ATACTION_RSP_FRC_END;
 8005b36:	2001      	movs	r0, #1
 8005b38:	e0e5      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
 8005b3a:	bf00      	nop
 8005b3c:	0802bbc0 	.word	0x0802bbc0
 8005b40:	200048dc 	.word	0x200048dc
 8005b44:	20001084 	.word	0x20001084
 8005b48:	0802bbf4 	.word	0x0802bbf4
 8005b4c:	0802bc34 	.word	0x0802bc34
 8005b50:	0802bc60 	.word	0x0802bc60
        PRINT_INFO("MODEM SWITCHES TO DATA MODE")
 8005b54:	4e6f      	ldr	r6, [pc, #444]	; (8005d14 <ATCustom_TYPE1SC_analyzeCmd+0x450>)
 8005b56:	4c70      	ldr	r4, [pc, #448]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005b58:	f106 0720 	add.w	r7, r6, #32
 8005b5c:	4635      	mov	r5, r6
 8005b5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005b60:	6020      	str	r0, [r4, #0]
 8005b62:	6061      	str	r1, [r4, #4]
 8005b64:	60a2      	str	r2, [r4, #8]
 8005b66:	60e3      	str	r3, [r4, #12]
 8005b68:	462e      	mov	r6, r5
 8005b6a:	3410      	adds	r4, #16
 8005b6c:	42bd      	cmp	r5, r7
 8005b6e:	d1f5      	bne.n	8005b5c <ATCustom_TYPE1SC_analyzeCmd+0x298>
 8005b70:	6828      	ldr	r0, [r5, #0]
 8005b72:	6020      	str	r0, [r4, #0]
 8005b74:	88ab      	ldrh	r3, [r5, #4]
 8005b76:	80a3      	strh	r3, [r4, #4]
 8005b78:	4c67      	ldr	r4, [pc, #412]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005b7a:	4620      	mov	r0, r4
 8005b7c:	f019 fac9 	bl	801f112 <crs_strlen>
 8005b80:	b283      	uxth	r3, r0
 8005b82:	4622      	mov	r2, r4
 8005b84:	2101      	movs	r1, #1
 8005b86:	2002      	movs	r0, #2
 8005b88:	f019 fb06 	bl	801f198 <traceIF_itmPrint>
 8005b8c:	4620      	mov	r0, r4
 8005b8e:	f019 fac0 	bl	801f112 <crs_strlen>
 8005b92:	b283      	uxth	r3, r0
 8005b94:	4622      	mov	r2, r4
 8005b96:	2101      	movs	r1, #1
 8005b98:	2002      	movs	r0, #2
 8005b9a:	f019 fb1f 	bl	801f1dc <traceIF_uartPrint>
        retval = (at_action_rsp_t)(ATACTION_RSP_FLAG_DATA_MODE | ATACTION_RSP_FRC_END);
 8005b9e:	f248 0001 	movw	r0, #32769	; 0x8001
        break;
 8005ba2:	e0b0      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        if (element_infos->cmd_id_received == p_atp_ctxt->current_atcmd.id)
 8005ba4:	69fa      	ldr	r2, [r7, #28]
 8005ba6:	4293      	cmp	r3, r2
 8005ba8:	d001      	beq.n	8005bae <ATCustom_TYPE1SC_analyzeCmd+0x2ea>
          retval = ATACTION_RSP_URC_FORWARDED;
 8005baa:	2040      	movs	r0, #64	; 0x40
 8005bac:	e0ab      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          retval = ATACTION_RSP_INTERMEDIATE;
 8005bae:	2008      	movs	r0, #8
 8005bb0:	e0a9      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_URC_FORWARDED;
 8005bb2:	2040      	movs	r0, #64	; 0x40
        break;
 8005bb4:	e0a7      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_INTERMEDIATE;
 8005bb6:	2008      	movs	r0, #8
        break;
 8005bb8:	e0a5      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_INTERMEDIATE;
 8005bba:	2008      	movs	r0, #8
        break;
 8005bbc:	e0a3      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_INTERMEDIATE;
 8005bbe:	2008      	movs	r0, #8
        break;
 8005bc0:	e0a1      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        if ((p_atp_ctxt->current_SID == (at_msg_t) SID_CS_POWER_ON) ||
 8005bc2:	8a3b      	ldrh	r3, [r7, #16]
 8005bc4:	2b65      	cmp	r3, #101	; 0x65
 8005bc6:	d001      	beq.n	8005bcc <ATCustom_TYPE1SC_analyzeCmd+0x308>
 8005bc8:	2b80      	cmp	r3, #128	; 0x80
 8005bca:	d15a      	bne.n	8005c82 <ATCustom_TYPE1SC_analyzeCmd+0x3be>
          type1sc_shared.modem_bootev_received = true;
 8005bcc:	4b53      	ldr	r3, [pc, #332]	; (8005d1c <ATCustom_TYPE1SC_analyzeCmd+0x458>)
 8005bce:	2201      	movs	r2, #1
 8005bd0:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
          if (type1sc_shared.modem_waiting_for_bootev == true)
 8005bd4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8005bd8:	b363      	cbz	r3, 8005c34 <ATCustom_TYPE1SC_analyzeCmd+0x370>
            type1sc_shared.modem_waiting_for_bootev = false;
 8005bda:	4b50      	ldr	r3, [pc, #320]	; (8005d1c <ATCustom_TYPE1SC_analyzeCmd+0x458>)
 8005bdc:	2200      	movs	r2, #0
 8005bde:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
            PRINT_INFO("continue INIT modem sequence")
 8005be2:	4e4f      	ldr	r6, [pc, #316]	; (8005d20 <ATCustom_TYPE1SC_analyzeCmd+0x45c>)
 8005be4:	4c4c      	ldr	r4, [pc, #304]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005be6:	f106 0720 	add.w	r7, r6, #32
 8005bea:	4635      	mov	r5, r6
 8005bec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005bee:	6020      	str	r0, [r4, #0]
 8005bf0:	6061      	str	r1, [r4, #4]
 8005bf2:	60a2      	str	r2, [r4, #8]
 8005bf4:	60e3      	str	r3, [r4, #12]
 8005bf6:	462e      	mov	r6, r5
 8005bf8:	3410      	adds	r4, #16
 8005bfa:	42bd      	cmp	r5, r7
 8005bfc:	d1f5      	bne.n	8005bea <ATCustom_TYPE1SC_analyzeCmd+0x326>
 8005bfe:	6828      	ldr	r0, [r5, #0]
 8005c00:	6020      	str	r0, [r4, #0]
 8005c02:	88aa      	ldrh	r2, [r5, #4]
 8005c04:	79ab      	ldrb	r3, [r5, #6]
 8005c06:	80a2      	strh	r2, [r4, #4]
 8005c08:	71a3      	strb	r3, [r4, #6]
 8005c0a:	4c43      	ldr	r4, [pc, #268]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005c0c:	4620      	mov	r0, r4
 8005c0e:	f019 fa80 	bl	801f112 <crs_strlen>
 8005c12:	b283      	uxth	r3, r0
 8005c14:	4622      	mov	r2, r4
 8005c16:	2101      	movs	r1, #1
 8005c18:	2002      	movs	r0, #2
 8005c1a:	f019 fabd 	bl	801f198 <traceIF_itmPrint>
 8005c1e:	4620      	mov	r0, r4
 8005c20:	f019 fa77 	bl	801f112 <crs_strlen>
 8005c24:	b283      	uxth	r3, r0
 8005c26:	4622      	mov	r2, r4
 8005c28:	2101      	movs	r1, #1
 8005c2a:	2002      	movs	r0, #2
 8005c2c:	f019 fad6 	bl	801f1dc <traceIF_uartPrint>
            retval = ATACTION_RSP_FRC_END;
 8005c30:	2001      	movs	r0, #1
 8005c32:	e068      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
            PRINT_DBG("memorize BOOTEV received")
 8005c34:	4e3b      	ldr	r6, [pc, #236]	; (8005d24 <ATCustom_TYPE1SC_analyzeCmd+0x460>)
 8005c36:	4d38      	ldr	r5, [pc, #224]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005c38:	f106 0720 	add.w	r7, r6, #32
 8005c3c:	4634      	mov	r4, r6
 8005c3e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005c40:	6028      	str	r0, [r5, #0]
 8005c42:	6069      	str	r1, [r5, #4]
 8005c44:	60aa      	str	r2, [r5, #8]
 8005c46:	60eb      	str	r3, [r5, #12]
 8005c48:	4626      	mov	r6, r4
 8005c4a:	3510      	adds	r5, #16
 8005c4c:	42bc      	cmp	r4, r7
 8005c4e:	d1f5      	bne.n	8005c3c <ATCustom_TYPE1SC_analyzeCmd+0x378>
 8005c50:	8822      	ldrh	r2, [r4, #0]
 8005c52:	78a3      	ldrb	r3, [r4, #2]
 8005c54:	802a      	strh	r2, [r5, #0]
 8005c56:	70ab      	strb	r3, [r5, #2]
 8005c58:	4c2f      	ldr	r4, [pc, #188]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005c5a:	4620      	mov	r0, r4
 8005c5c:	f019 fa59 	bl	801f112 <crs_strlen>
 8005c60:	b283      	uxth	r3, r0
 8005c62:	4622      	mov	r2, r4
 8005c64:	2102      	movs	r1, #2
 8005c66:	4608      	mov	r0, r1
 8005c68:	f019 fa96 	bl	801f198 <traceIF_itmPrint>
 8005c6c:	4620      	mov	r0, r4
 8005c6e:	f019 fa50 	bl	801f112 <crs_strlen>
 8005c72:	b283      	uxth	r3, r0
 8005c74:	4622      	mov	r2, r4
 8005c76:	2102      	movs	r1, #2
 8005c78:	4608      	mov	r0, r1
 8005c7a:	f019 faaf 	bl	801f1dc <traceIF_uartPrint>
            retval = ATACTION_RSP_URC_IGNORED;
 8005c7e:	2020      	movs	r0, #32
 8005c80:	e041      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          if (atcm_modem_event_received(&TYPE1SC_ctxt, CS_MDMEVENT_BOOT) == AT_TRUE)
 8005c82:	2101      	movs	r1, #1
 8005c84:	4828      	ldr	r0, [pc, #160]	; (8005d28 <ATCustom_TYPE1SC_analyzeCmd+0x464>)
 8005c86:	f007 faa7 	bl	800d1d8 <atcm_modem_event_received>
 8005c8a:	2800      	cmp	r0, #0
 8005c8c:	d03d      	beq.n	8005d0a <ATCustom_TYPE1SC_analyzeCmd+0x446>
            retval = ATACTION_RSP_URC_FORWARDED;
 8005c8e:	2040      	movs	r0, #64	; 0x40
 8005c90:	e039      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_IGNORED;
 8005c92:	2010      	movs	r0, #16
        break;
 8005c94:	e037      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = fRspAnalyze_Error_TYPE1SC(p_at_ctxt, &TYPE1SC_ctxt, p_msg_in, element_infos);
 8005c96:	4633      	mov	r3, r6
 8005c98:	4642      	mov	r2, r8
 8005c9a:	4923      	ldr	r1, [pc, #140]	; (8005d28 <ATCustom_TYPE1SC_analyzeCmd+0x464>)
 8005c9c:	4638      	mov	r0, r7
 8005c9e:	f7fc fdd7 	bl	8002850 <fRspAnalyze_Error_TYPE1SC>
        break;
 8005ca2:	e030      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = fRspAnalyze_Error_TYPE1SC(p_at_ctxt, &TYPE1SC_ctxt, p_msg_in, element_infos);
 8005ca4:	4633      	mov	r3, r6
 8005ca6:	4642      	mov	r2, r8
 8005ca8:	491f      	ldr	r1, [pc, #124]	; (8005d28 <ATCustom_TYPE1SC_analyzeCmd+0x464>)
 8005caa:	4638      	mov	r0, r7
 8005cac:	f7fc fdd0 	bl	8002850 <fRspAnalyze_Error_TYPE1SC>
        break;
 8005cb0:	e029      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          PRINT_INFO("UNEXPECTED MESSAGE RECEIVED")
 8005cb2:	4e1e      	ldr	r6, [pc, #120]	; (8005d2c <ATCustom_TYPE1SC_analyzeCmd+0x468>)
 8005cb4:	4c18      	ldr	r4, [pc, #96]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005cb6:	f106 0720 	add.w	r7, r6, #32
 8005cba:	4635      	mov	r5, r6
 8005cbc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005cbe:	6020      	str	r0, [r4, #0]
 8005cc0:	6061      	str	r1, [r4, #4]
 8005cc2:	60a2      	str	r2, [r4, #8]
 8005cc4:	60e3      	str	r3, [r4, #12]
 8005cc6:	462e      	mov	r6, r5
 8005cc8:	3410      	adds	r4, #16
 8005cca:	42bd      	cmp	r5, r7
 8005ccc:	d1f5      	bne.n	8005cba <ATCustom_TYPE1SC_analyzeCmd+0x3f6>
 8005cce:	6828      	ldr	r0, [r5, #0]
 8005cd0:	6020      	str	r0, [r4, #0]
 8005cd2:	88ab      	ldrh	r3, [r5, #4]
 8005cd4:	80a3      	strh	r3, [r4, #4]
 8005cd6:	4c10      	ldr	r4, [pc, #64]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005cd8:	4620      	mov	r0, r4
 8005cda:	f019 fa1a 	bl	801f112 <crs_strlen>
 8005cde:	b283      	uxth	r3, r0
 8005ce0:	4622      	mov	r2, r4
 8005ce2:	2101      	movs	r1, #1
 8005ce4:	2002      	movs	r0, #2
 8005ce6:	f019 fa57 	bl	801f198 <traceIF_itmPrint>
 8005cea:	4620      	mov	r0, r4
 8005cec:	f019 fa11 	bl	801f112 <crs_strlen>
 8005cf0:	b283      	uxth	r3, r0
 8005cf2:	4622      	mov	r2, r4
 8005cf4:	2101      	movs	r1, #1
 8005cf6:	2002      	movs	r0, #2
 8005cf8:	f019 fa70 	bl	801f1dc <traceIF_uartPrint>
          retval = ATACTION_RSP_IGNORED;
 8005cfc:	2010      	movs	r0, #16
 8005cfe:	e002      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_URC_IGNORED;
 8005d00:	2020      	movs	r0, #32
 8005d02:	e000      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
    switch (element_infos->cmd_id_received)
 8005d04:	2004      	movs	r0, #4
}
 8005d06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            retval = ATACTION_RSP_URC_IGNORED;
 8005d0a:	2020      	movs	r0, #32
 8005d0c:	e7fb      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          retval = ATACTION_RSP_INTERMEDIATE;
 8005d0e:	2008      	movs	r0, #8
 8005d10:	e7f9      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
 8005d12:	bf00      	nop
 8005d14:	0802bc88 	.word	0x0802bc88
 8005d18:	200048dc 	.word	0x200048dc
 8005d1c:	20001838 	.word	0x20001838
 8005d20:	0802bcb0 	.word	0x0802bcb0
 8005d24:	0802bcd8 	.word	0x0802bcd8
 8005d28:	20001084 	.word	0x20001084
 8005d2c:	0802bcfc 	.word	0x0802bcfc

08005d30 <ATCustom_TYPE1SC_analyzeParam>:
{
 8005d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005d34:	4607      	mov	r7, r0
 8005d36:	4688      	mov	r8, r1
 8005d38:	4616      	mov	r6, r2
  PRINT_API("enter ATCustom_TYPE1SC_analyzeParam()")
 8005d3a:	4d19      	ldr	r5, [pc, #100]	; (8005da0 <ATCustom_TYPE1SC_analyzeParam+0x70>)
 8005d3c:	4c19      	ldr	r4, [pc, #100]	; (8005da4 <ATCustom_TYPE1SC_analyzeParam+0x74>)
 8005d3e:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8005d42:	46ac      	mov	ip, r5
 8005d44:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005d48:	6020      	str	r0, [r4, #0]
 8005d4a:	6061      	str	r1, [r4, #4]
 8005d4c:	60a2      	str	r2, [r4, #8]
 8005d4e:	60e3      	str	r3, [r4, #12]
 8005d50:	4665      	mov	r5, ip
 8005d52:	3410      	adds	r4, #16
 8005d54:	45f4      	cmp	ip, lr
 8005d56:	d1f4      	bne.n	8005d42 <ATCustom_TYPE1SC_analyzeParam+0x12>
 8005d58:	f8dc 0000 	ldr.w	r0, [ip]
 8005d5c:	6020      	str	r0, [r4, #0]
 8005d5e:	4c11      	ldr	r4, [pc, #68]	; (8005da4 <ATCustom_TYPE1SC_analyzeParam+0x74>)
 8005d60:	4620      	mov	r0, r4
 8005d62:	f019 f9d6 	bl	801f112 <crs_strlen>
 8005d66:	b283      	uxth	r3, r0
 8005d68:	4622      	mov	r2, r4
 8005d6a:	2104      	movs	r1, #4
 8005d6c:	2002      	movs	r0, #2
 8005d6e:	f019 fa13 	bl	801f198 <traceIF_itmPrint>
 8005d72:	4620      	mov	r0, r4
 8005d74:	f019 f9cd 	bl	801f112 <crs_strlen>
 8005d78:	b283      	uxth	r3, r0
 8005d7a:	4622      	mov	r2, r4
 8005d7c:	2104      	movs	r1, #4
 8005d7e:	2002      	movs	r0, #2
 8005d80:	f019 fa2c 	bl	801f1dc <traceIF_uartPrint>
  retval = (atcm_get_CmdAnalyzeFunc(&TYPE1SC_ctxt, element_infos->cmd_id_received))(p_at_ctxt,
 8005d84:	4c08      	ldr	r4, [pc, #32]	; (8005da8 <ATCustom_TYPE1SC_analyzeParam+0x78>)
 8005d86:	6871      	ldr	r1, [r6, #4]
 8005d88:	4620      	mov	r0, r4
 8005d8a:	f006 fe1f 	bl	800c9cc <atcm_get_CmdAnalyzeFunc>
 8005d8e:	4605      	mov	r5, r0
 8005d90:	4633      	mov	r3, r6
 8005d92:	4642      	mov	r2, r8
 8005d94:	4621      	mov	r1, r4
 8005d96:	4638      	mov	r0, r7
 8005d98:	47a8      	blx	r5
}
 8005d9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005d9e:	bf00      	nop
 8005da0:	0802bd24 	.word	0x0802bd24
 8005da4:	200048dc 	.word	0x200048dc
 8005da8:	20001084 	.word	0x20001084

08005dac <ATCustom_TYPE1SC_terminateCmd>:
{
 8005dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005dae:	4606      	mov	r6, r0
 8005db0:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_terminateCmd()")
 8005db2:	4d42      	ldr	r5, [pc, #264]	; (8005ebc <ATCustom_TYPE1SC_terminateCmd+0x110>)
 8005db4:	4c42      	ldr	r4, [pc, #264]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005db6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8005dba:	46ac      	mov	ip, r5
 8005dbc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005dc0:	6020      	str	r0, [r4, #0]
 8005dc2:	6061      	str	r1, [r4, #4]
 8005dc4:	60a2      	str	r2, [r4, #8]
 8005dc6:	60e3      	str	r3, [r4, #12]
 8005dc8:	4665      	mov	r5, ip
 8005dca:	3410      	adds	r4, #16
 8005dcc:	45f4      	cmp	ip, lr
 8005dce:	d1f4      	bne.n	8005dba <ATCustom_TYPE1SC_terminateCmd+0xe>
 8005dd0:	f8dc 0000 	ldr.w	r0, [ip]
 8005dd4:	6020      	str	r0, [r4, #0]
 8005dd6:	4c3a      	ldr	r4, [pc, #232]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005dd8:	4620      	mov	r0, r4
 8005dda:	f019 f99a 	bl	801f112 <crs_strlen>
 8005dde:	b283      	uxth	r3, r0
 8005de0:	4622      	mov	r2, r4
 8005de2:	2104      	movs	r1, #4
 8005de4:	2002      	movs	r0, #2
 8005de6:	f019 f9d7 	bl	801f198 <traceIF_itmPrint>
 8005dea:	4620      	mov	r0, r4
 8005dec:	f019 f991 	bl	801f112 <crs_strlen>
 8005df0:	b283      	uxth	r3, r0
 8005df2:	4622      	mov	r2, r4
 8005df4:	2104      	movs	r1, #4
 8005df6:	2002      	movs	r0, #2
 8005df8:	f019 f9f0 	bl	801f1dc <traceIF_uartPrint>
  if (TYPE1SC_ctxt.socket_ctxt.socket_send_state != SocketSendState_No_Activity)
 8005dfc:	4b31      	ldr	r3, [pc, #196]	; (8005ec4 <ATCustom_TYPE1SC_terminateCmd+0x118>)
 8005dfe:	f893 37ac 	ldrb.w	r3, [r3, #1964]	; 0x7ac
 8005e02:	b133      	cbz	r3, 8005e12 <ATCustom_TYPE1SC_terminateCmd+0x66>
    if (p_atp_ctxt->current_SID != (at_msg_t) SID_CS_SEND_DATA)
 8005e04:	8833      	ldrh	r3, [r6, #0]
 8005e06:	2b7a      	cmp	r3, #122	; 0x7a
 8005e08:	d003      	beq.n	8005e12 <ATCustom_TYPE1SC_terminateCmd+0x66>
      TYPE1SC_ctxt.socket_ctxt.socket_send_state = SocketSendState_No_Activity;
 8005e0a:	4b2e      	ldr	r3, [pc, #184]	; (8005ec4 <ATCustom_TYPE1SC_terminateCmd+0x118>)
 8005e0c:	2200      	movs	r2, #0
 8005e0e:	f883 27ac 	strb.w	r2, [r3, #1964]	; 0x7ac
  if ((p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_ATD) ||
 8005e12:	68f3      	ldr	r3, [r6, #12]
 8005e14:	2b27      	cmp	r3, #39	; 0x27
 8005e16:	d005      	beq.n	8005e24 <ATCustom_TYPE1SC_terminateCmd+0x78>
 8005e18:	2b2a      	cmp	r3, #42	; 0x2a
 8005e1a:	d003      	beq.n	8005e24 <ATCustom_TYPE1SC_terminateCmd+0x78>
      (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_ATO) ||
 8005e1c:	2b1f      	cmp	r3, #31
 8005e1e:	d001      	beq.n	8005e24 <ATCustom_TYPE1SC_terminateCmd+0x78>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8005e20:	2010      	movs	r0, #16
 8005e22:	e026      	b.n	8005e72 <ATCustom_TYPE1SC_terminateCmd+0xc6>
    if (element_infos->cmd_id_received == (CMD_ID_t) CMD_AT_CONNECT)
 8005e24:	687b      	ldr	r3, [r7, #4]
 8005e26:	2b02      	cmp	r3, #2
 8005e28:	d024      	beq.n	8005e74 <ATCustom_TYPE1SC_terminateCmd+0xc8>
      PRINT_ERR("expected CONNECT not received !!!")
 8005e2a:	4e27      	ldr	r6, [pc, #156]	; (8005ec8 <ATCustom_TYPE1SC_terminateCmd+0x11c>)
 8005e2c:	4d24      	ldr	r5, [pc, #144]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005e2e:	f106 0730 	add.w	r7, r6, #48	; 0x30
 8005e32:	4634      	mov	r4, r6
 8005e34:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005e36:	6028      	str	r0, [r5, #0]
 8005e38:	6069      	str	r1, [r5, #4]
 8005e3a:	60aa      	str	r2, [r5, #8]
 8005e3c:	60eb      	str	r3, [r5, #12]
 8005e3e:	4626      	mov	r6, r4
 8005e40:	3510      	adds	r5, #16
 8005e42:	42bc      	cmp	r4, r7
 8005e44:	d1f5      	bne.n	8005e32 <ATCustom_TYPE1SC_terminateCmd+0x86>
 8005e46:	8823      	ldrh	r3, [r4, #0]
 8005e48:	802b      	strh	r3, [r5, #0]
 8005e4a:	4c1d      	ldr	r4, [pc, #116]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005e4c:	4620      	mov	r0, r4
 8005e4e:	f019 f960 	bl	801f112 <crs_strlen>
 8005e52:	b283      	uxth	r3, r0
 8005e54:	4622      	mov	r2, r4
 8005e56:	2110      	movs	r1, #16
 8005e58:	2002      	movs	r0, #2
 8005e5a:	f019 f99d 	bl	801f198 <traceIF_itmPrint>
 8005e5e:	4620      	mov	r0, r4
 8005e60:	f019 f957 	bl	801f112 <crs_strlen>
 8005e64:	b283      	uxth	r3, r0
 8005e66:	4622      	mov	r2, r4
 8005e68:	2110      	movs	r1, #16
 8005e6a:	2002      	movs	r0, #2
 8005e6c:	f019 f9b6 	bl	801f1dc <traceIF_uartPrint>
      retval = ATACTION_RSP_ERROR;
 8005e70:	2004      	movs	r0, #4
}
 8005e72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      p_atp_ctxt->is_final_cmd = 1U;
 8005e74:	2301      	movs	r3, #1
 8005e76:	7133      	strb	r3, [r6, #4]
      PRINT_DBG("CONNECT received")
 8005e78:	4c11      	ldr	r4, [pc, #68]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005e7a:	4d14      	ldr	r5, [pc, #80]	; (8005ecc <ATCustom_TYPE1SC_terminateCmd+0x120>)
 8005e7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005e7e:	6020      	str	r0, [r4, #0]
 8005e80:	6061      	str	r1, [r4, #4]
 8005e82:	60a2      	str	r2, [r4, #8]
 8005e84:	60e3      	str	r3, [r4, #12]
 8005e86:	cd03      	ldmia	r5!, {r0, r1}
 8005e88:	6120      	str	r0, [r4, #16]
 8005e8a:	6161      	str	r1, [r4, #20]
 8005e8c:	882a      	ldrh	r2, [r5, #0]
 8005e8e:	78ab      	ldrb	r3, [r5, #2]
 8005e90:	8322      	strh	r2, [r4, #24]
 8005e92:	76a3      	strb	r3, [r4, #26]
 8005e94:	4620      	mov	r0, r4
 8005e96:	f019 f93c 	bl	801f112 <crs_strlen>
 8005e9a:	b283      	uxth	r3, r0
 8005e9c:	4622      	mov	r2, r4
 8005e9e:	2102      	movs	r1, #2
 8005ea0:	4608      	mov	r0, r1
 8005ea2:	f019 f979 	bl	801f198 <traceIF_itmPrint>
 8005ea6:	4620      	mov	r0, r4
 8005ea8:	f019 f933 	bl	801f112 <crs_strlen>
 8005eac:	b283      	uxth	r3, r0
 8005eae:	4622      	mov	r2, r4
 8005eb0:	2102      	movs	r1, #2
 8005eb2:	4608      	mov	r0, r1
 8005eb4:	f019 f992 	bl	801f1dc <traceIF_uartPrint>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8005eb8:	2010      	movs	r0, #16
 8005eba:	e7da      	b.n	8005e72 <ATCustom_TYPE1SC_terminateCmd+0xc6>
 8005ebc:	0802bd58 	.word	0x0802bd58
 8005ec0:	200048dc 	.word	0x200048dc
 8005ec4:	20001084 	.word	0x20001084
 8005ec8:	0802bda8 	.word	0x0802bda8
 8005ecc:	0802bd8c 	.word	0x0802bd8c

08005ed0 <ATCustom_TYPE1SC_get_rsp>:
{
 8005ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ed2:	4606      	mov	r6, r0
 8005ed4:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_get_rsp()")
 8005ed6:	4c43      	ldr	r4, [pc, #268]	; (8005fe4 <ATCustom_TYPE1SC_get_rsp+0x114>)
 8005ed8:	4d43      	ldr	r5, [pc, #268]	; (8005fe8 <ATCustom_TYPE1SC_get_rsp+0x118>)
 8005eda:	f104 0e20 	add.w	lr, r4, #32
 8005ede:	46a4      	mov	ip, r4
 8005ee0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005ee4:	6028      	str	r0, [r5, #0]
 8005ee6:	6069      	str	r1, [r5, #4]
 8005ee8:	60aa      	str	r2, [r5, #8]
 8005eea:	60eb      	str	r3, [r5, #12]
 8005eec:	4664      	mov	r4, ip
 8005eee:	3510      	adds	r5, #16
 8005ef0:	45f4      	cmp	ip, lr
 8005ef2:	d1f4      	bne.n	8005ede <ATCustom_TYPE1SC_get_rsp+0xe>
 8005ef4:	4663      	mov	r3, ip
 8005ef6:	cb07      	ldmia	r3!, {r0, r1, r2}
 8005ef8:	6028      	str	r0, [r5, #0]
 8005efa:	6069      	str	r1, [r5, #4]
 8005efc:	60aa      	str	r2, [r5, #8]
 8005efe:	881a      	ldrh	r2, [r3, #0]
 8005f00:	789b      	ldrb	r3, [r3, #2]
 8005f02:	81aa      	strh	r2, [r5, #12]
 8005f04:	73ab      	strb	r3, [r5, #14]
 8005f06:	4c38      	ldr	r4, [pc, #224]	; (8005fe8 <ATCustom_TYPE1SC_get_rsp+0x118>)
 8005f08:	4620      	mov	r0, r4
 8005f0a:	f019 f902 	bl	801f112 <crs_strlen>
 8005f0e:	b283      	uxth	r3, r0
 8005f10:	4622      	mov	r2, r4
 8005f12:	2104      	movs	r1, #4
 8005f14:	2002      	movs	r0, #2
 8005f16:	f019 f93f 	bl	801f198 <traceIF_itmPrint>
 8005f1a:	4620      	mov	r0, r4
 8005f1c:	f019 f8f9 	bl	801f112 <crs_strlen>
 8005f20:	b283      	uxth	r3, r0
 8005f22:	4622      	mov	r2, r4
 8005f24:	2104      	movs	r1, #4
 8005f26:	2002      	movs	r0, #2
 8005f28:	f019 f958 	bl	801f1dc <traceIF_uartPrint>
  retval = atcm_modem_get_rsp(&TYPE1SC_ctxt, p_atp_ctxt, p_rsp_buf);
 8005f2c:	463a      	mov	r2, r7
 8005f2e:	4631      	mov	r1, r6
 8005f30:	482e      	ldr	r0, [pc, #184]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005f32:	f006 fe83 	bl	800cc3c <atcm_modem_get_rsp>
 8005f36:	4604      	mov	r4, r0
  switch (p_atp_ctxt->current_SID)
 8005f38:	8833      	ldrh	r3, [r6, #0]
 8005f3a:	2b83      	cmp	r3, #131	; 0x83
 8005f3c:	d00d      	beq.n	8005f5a <ATCustom_TYPE1SC_get_rsp+0x8a>
 8005f3e:	2b84      	cmp	r3, #132	; 0x84
 8005f40:	d019      	beq.n	8005f76 <ATCustom_TYPE1SC_get_rsp+0xa6>
 8005f42:	2b66      	cmp	r3, #102	; 0x66
 8005f44:	d013      	beq.n	8005f6e <ATCustom_TYPE1SC_get_rsp+0x9e>
  atcm_reset_SID_context(&TYPE1SC_ctxt.SID_ctxt);
 8005f46:	4d29      	ldr	r5, [pc, #164]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005f48:	f505 60b6 	add.w	r0, r5, #1456	; 0x5b0
 8005f4c:	f007 f94e 	bl	800d1ec <atcm_reset_SID_context>
  atcm_reset_SOCKET_context(&TYPE1SC_ctxt);
 8005f50:	4628      	mov	r0, r5
 8005f52:	f007 f9ff 	bl	800d354 <atcm_reset_SOCKET_context>
}
 8005f56:	4620      	mov	r0, r4
 8005f58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (DATAPACK_writeStruct(p_rsp_buf,
 8005f5a:	4b25      	ldr	r3, [pc, #148]	; (8005ff0 <ATCustom_TYPE1SC_get_rsp+0x120>)
 8005f5c:	2240      	movs	r2, #64	; 0x40
 8005f5e:	2127      	movs	r1, #39	; 0x27
 8005f60:	4638      	mov	r0, r7
 8005f62:	f006 f8a7 	bl	800c0b4 <DATAPACK_writeStruct>
 8005f66:	2800      	cmp	r0, #0
 8005f68:	d0ed      	beq.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
        retval = ATSTATUS_OK;
 8005f6a:	2400      	movs	r4, #0
 8005f6c:	e7eb      	b.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
      type1sc_modem_reset(&TYPE1SC_ctxt);
 8005f6e:	481f      	ldr	r0, [pc, #124]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005f70:	f7fe fb60 	bl	8004634 <type1sc_modem_reset>
      break;
 8005f74:	e7e7      	b.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
      PRINT_INFO("Ping final report")
 8005f76:	4d1c      	ldr	r5, [pc, #112]	; (8005fe8 <ATCustom_TYPE1SC_get_rsp+0x118>)
 8005f78:	4e1e      	ldr	r6, [pc, #120]	; (8005ff4 <ATCustom_TYPE1SC_get_rsp+0x124>)
 8005f7a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005f7c:	6028      	str	r0, [r5, #0]
 8005f7e:	6069      	str	r1, [r5, #4]
 8005f80:	60aa      	str	r2, [r5, #8]
 8005f82:	60eb      	str	r3, [r5, #12]
 8005f84:	ce07      	ldmia	r6!, {r0, r1, r2}
 8005f86:	6128      	str	r0, [r5, #16]
 8005f88:	6169      	str	r1, [r5, #20]
 8005f8a:	61aa      	str	r2, [r5, #24]
 8005f8c:	4628      	mov	r0, r5
 8005f8e:	f019 f8c0 	bl	801f112 <crs_strlen>
 8005f92:	b283      	uxth	r3, r0
 8005f94:	462a      	mov	r2, r5
 8005f96:	2101      	movs	r1, #1
 8005f98:	2002      	movs	r0, #2
 8005f9a:	f019 f8fd 	bl	801f198 <traceIF_itmPrint>
 8005f9e:	4628      	mov	r0, r5
 8005fa0:	f019 f8b7 	bl	801f112 <crs_strlen>
 8005fa4:	b283      	uxth	r3, r0
 8005fa6:	462a      	mov	r2, r5
 8005fa8:	2101      	movs	r1, #1
 8005faa:	2002      	movs	r0, #2
 8005fac:	f019 f916 	bl	801f1dc <traceIF_uartPrint>
      clear_ping_resp_struct(&TYPE1SC_ctxt);
 8005fb0:	4d0e      	ldr	r5, [pc, #56]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005fb2:	4628      	mov	r0, r5
 8005fb4:	f7fe f992 	bl	80042dc <clear_ping_resp_struct>
      TYPE1SC_ctxt.persist.ping_resp_urc.ping_status = CELLULAR_OK;
 8005fb8:	2300      	movs	r3, #0
 8005fba:	f885 355d 	strb.w	r3, [r5, #1373]	; 0x55d
      TYPE1SC_ctxt.persist.ping_resp_urc.is_final_report = CELLULAR_TRUE;
 8005fbe:	2301      	movs	r3, #1
 8005fc0:	f885 355e 	strb.w	r3, [r5, #1374]	; 0x55e
      TYPE1SC_ctxt.persist.ping_resp_urc.index = TYPE1SC_ctxt.persist.ping_infos.ping_params.pingnum + 1U;
 8005fc4:	f895 3558 	ldrb.w	r3, [r5, #1368]	; 0x558
 8005fc8:	3301      	adds	r3, #1
 8005fca:	f885 355c 	strb.w	r3, [r5, #1372]	; 0x55c
      if (DATAPACK_writeStruct(p_rsp_buf,
 8005fce:	f205 535c 	addw	r3, r5, #1372	; 0x55c
 8005fd2:	2250      	movs	r2, #80	; 0x50
 8005fd4:	2110      	movs	r1, #16
 8005fd6:	4638      	mov	r0, r7
 8005fd8:	f006 f86c 	bl	800c0b4 <DATAPACK_writeStruct>
 8005fdc:	2800      	cmp	r0, #0
 8005fde:	d0b2      	beq.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
        retval = ATSTATUS_OK;
 8005fe0:	2400      	movs	r4, #0
 8005fe2:	e7b0      	b.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
 8005fe4:	0802bddc 	.word	0x0802bddc
 8005fe8:	200048dc 	.word	0x200048dc
 8005fec:	20001084 	.word	0x20001084
 8005ff0:	20001838 	.word	0x20001838
 8005ff4:	0802be0c 	.word	0x0802be0c

08005ff8 <ATCustom_TYPE1SC_get_urc>:
{
 8005ff8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ffa:	4606      	mov	r6, r0
 8005ffc:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_get_urc()")
 8005ffe:	4c18      	ldr	r4, [pc, #96]	; (8006060 <ATCustom_TYPE1SC_get_urc+0x68>)
 8006000:	4d18      	ldr	r5, [pc, #96]	; (8006064 <ATCustom_TYPE1SC_get_urc+0x6c>)
 8006002:	f104 0e20 	add.w	lr, r4, #32
 8006006:	46a4      	mov	ip, r4
 8006008:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800600c:	6028      	str	r0, [r5, #0]
 800600e:	6069      	str	r1, [r5, #4]
 8006010:	60aa      	str	r2, [r5, #8]
 8006012:	60eb      	str	r3, [r5, #12]
 8006014:	4664      	mov	r4, ip
 8006016:	3510      	adds	r5, #16
 8006018:	45f4      	cmp	ip, lr
 800601a:	d1f4      	bne.n	8006006 <ATCustom_TYPE1SC_get_urc+0xe>
 800601c:	4663      	mov	r3, ip
 800601e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8006020:	6028      	str	r0, [r5, #0]
 8006022:	6069      	str	r1, [r5, #4]
 8006024:	60aa      	str	r2, [r5, #8]
 8006026:	881a      	ldrh	r2, [r3, #0]
 8006028:	789b      	ldrb	r3, [r3, #2]
 800602a:	81aa      	strh	r2, [r5, #12]
 800602c:	73ab      	strb	r3, [r5, #14]
 800602e:	4c0d      	ldr	r4, [pc, #52]	; (8006064 <ATCustom_TYPE1SC_get_urc+0x6c>)
 8006030:	4620      	mov	r0, r4
 8006032:	f019 f86e 	bl	801f112 <crs_strlen>
 8006036:	b283      	uxth	r3, r0
 8006038:	4622      	mov	r2, r4
 800603a:	2104      	movs	r1, #4
 800603c:	2002      	movs	r0, #2
 800603e:	f019 f8ab 	bl	801f198 <traceIF_itmPrint>
 8006042:	4620      	mov	r0, r4
 8006044:	f019 f865 	bl	801f112 <crs_strlen>
 8006048:	b283      	uxth	r3, r0
 800604a:	4622      	mov	r2, r4
 800604c:	2104      	movs	r1, #4
 800604e:	2002      	movs	r0, #2
 8006050:	f019 f8c4 	bl	801f1dc <traceIF_uartPrint>
  retval = atcm_modem_get_urc(&TYPE1SC_ctxt, p_atp_ctxt, p_rsp_buf);
 8006054:	463a      	mov	r2, r7
 8006056:	4631      	mov	r1, r6
 8006058:	4803      	ldr	r0, [pc, #12]	; (8006068 <ATCustom_TYPE1SC_get_urc+0x70>)
 800605a:	f007 fd73 	bl	800db44 <atcm_modem_get_urc>
}
 800605e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006060:	0802be28 	.word	0x0802be28
 8006064:	200048dc 	.word	0x200048dc
 8006068:	20001084 	.word	0x20001084

0800606c <ATCustom_TYPE1SC_get_error>:
{
 800606c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800606e:	4606      	mov	r6, r0
 8006070:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_get_error()")
 8006072:	4d15      	ldr	r5, [pc, #84]	; (80060c8 <ATCustom_TYPE1SC_get_error+0x5c>)
 8006074:	4c15      	ldr	r4, [pc, #84]	; (80060cc <ATCustom_TYPE1SC_get_error+0x60>)
 8006076:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 800607a:	46ac      	mov	ip, r5
 800607c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006080:	6020      	str	r0, [r4, #0]
 8006082:	6061      	str	r1, [r4, #4]
 8006084:	60a2      	str	r2, [r4, #8]
 8006086:	60e3      	str	r3, [r4, #12]
 8006088:	4665      	mov	r5, ip
 800608a:	3410      	adds	r4, #16
 800608c:	45f4      	cmp	ip, lr
 800608e:	d1f4      	bne.n	800607a <ATCustom_TYPE1SC_get_error+0xe>
 8006090:	f89c 3000 	ldrb.w	r3, [ip]
 8006094:	7023      	strb	r3, [r4, #0]
 8006096:	4c0d      	ldr	r4, [pc, #52]	; (80060cc <ATCustom_TYPE1SC_get_error+0x60>)
 8006098:	4620      	mov	r0, r4
 800609a:	f019 f83a 	bl	801f112 <crs_strlen>
 800609e:	b283      	uxth	r3, r0
 80060a0:	4622      	mov	r2, r4
 80060a2:	2104      	movs	r1, #4
 80060a4:	2002      	movs	r0, #2
 80060a6:	f019 f877 	bl	801f198 <traceIF_itmPrint>
 80060aa:	4620      	mov	r0, r4
 80060ac:	f019 f831 	bl	801f112 <crs_strlen>
 80060b0:	b283      	uxth	r3, r0
 80060b2:	4622      	mov	r2, r4
 80060b4:	2104      	movs	r1, #4
 80060b6:	2002      	movs	r0, #2
 80060b8:	f019 f890 	bl	801f1dc <traceIF_uartPrint>
  retval = atcm_modem_get_error(&TYPE1SC_ctxt, p_atp_ctxt, p_rsp_buf);
 80060bc:	463a      	mov	r2, r7
 80060be:	4631      	mov	r1, r6
 80060c0:	4803      	ldr	r0, [pc, #12]	; (80060d0 <ATCustom_TYPE1SC_get_error+0x64>)
 80060c2:	f006 ff63 	bl	800cf8c <atcm_modem_get_error>
}
 80060c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80060c8:	0802be58 	.word	0x0802be58
 80060cc:	200048dc 	.word	0x200048dc
 80060d0:	20001084 	.word	0x20001084

080060d4 <ATCustom_TYPE1SC_hw_event>:
  if (hwEvent == HWEVT_MODEM_RING)
 80060d4:	2901      	cmp	r1, #1
 80060d6:	d001      	beq.n	80060dc <ATCustom_TYPE1SC_hw_event+0x8>
  at_status_t retval = ATSTATUS_ERROR;
 80060d8:	2001      	movs	r0, #1
}
 80060da:	4770      	bx	lr
{
 80060dc:	b510      	push	{r4, lr}
 80060de:	4604      	mov	r4, r0
    if (is_waiting_modem_low_power_ack() == true)
 80060e0:	f7fe fa5a 	bl	8004598 <is_waiting_modem_low_power_ack>
 80060e4:	b920      	cbnz	r0, 80060f0 <ATCustom_TYPE1SC_hw_event+0x1c>
    else if (is_modem_in_low_power_state() == true)
 80060e6:	f7fe fa5d 	bl	80045a4 <is_modem_in_low_power_state>
 80060ea:	b978      	cbnz	r0, 800610c <ATCustom_TYPE1SC_hw_event+0x38>
  at_status_t retval = ATSTATUS_ERROR;
 80060ec:	2001      	movs	r0, #1
}
 80060ee:	bd10      	pop	{r4, pc}
      if (atcm_modem_event_received(&TYPE1SC_ctxt, CS_MDMEVENT_LP_ENTER) == AT_TRUE)
 80060f0:	2110      	movs	r1, #16
 80060f2:	480c      	ldr	r0, [pc, #48]	; (8006124 <ATCustom_TYPE1SC_hw_event+0x50>)
 80060f4:	f007 f870 	bl	800d1d8 <atcm_modem_event_received>
 80060f8:	b908      	cbnz	r0, 80060fe <ATCustom_TYPE1SC_hw_event+0x2a>
  at_status_t retval = ATSTATUS_ERROR;
 80060fa:	2001      	movs	r0, #1
 80060fc:	e7f7      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
        low_power_state_enter();
 80060fe:	f7fe fa37 	bl	8004570 <low_power_state_enter>
        AT_internalEvent(deviceType);
 8006102:	4620      	mov	r0, r4
 8006104:	f005 feb2 	bl	800be6c <AT_internalEvent>
        retval = ATSTATUS_OK;
 8006108:	2000      	movs	r0, #0
 800610a:	e7f0      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
      if (atcm_modem_event_received(&TYPE1SC_ctxt, CS_MDMEVENT_WAKEUP_REQ) == AT_TRUE)
 800610c:	2140      	movs	r1, #64	; 0x40
 800610e:	4805      	ldr	r0, [pc, #20]	; (8006124 <ATCustom_TYPE1SC_hw_event+0x50>)
 8006110:	f007 f862 	bl	800d1d8 <atcm_modem_event_received>
 8006114:	b908      	cbnz	r0, 800611a <ATCustom_TYPE1SC_hw_event+0x46>
  at_status_t retval = ATSTATUS_ERROR;
 8006116:	2001      	movs	r0, #1
 8006118:	e7e9      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
        AT_internalEvent(deviceType);
 800611a:	4620      	mov	r0, r4
 800611c:	f005 fea6 	bl	800be6c <AT_internalEvent>
        retval = ATSTATUS_OK;
 8006120:	2000      	movs	r0, #0
 8006122:	e7e4      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
 8006124:	20001084 	.word	0x20001084

08006128 <TYPE1SC_setup>:
  return (retval);
}

/* Private function Definition -----------------------------------------------*/
static sysctrl_status_t TYPE1SC_setup(void)
{
 8006128:	b5f0      	push	{r4, r5, r6, r7, lr}
 800612a:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO config
   * Initial pins state
   */
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_RESET);
 800612c:	4f20      	ldr	r7, [pc, #128]	; (80061b0 <TYPE1SC_setup+0x88>)
 800612e:	2200      	movs	r2, #0
 8006130:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006134:	4638      	mov	r0, r7
 8006136:	f001 fcb6 	bl	8007aa6 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 800613a:	4c1e      	ldr	r4, [pc, #120]	; (80061b4 <TYPE1SC_setup+0x8c>)
 800613c:	2200      	movs	r2, #0
 800613e:	2180      	movs	r1, #128	; 0x80
 8006140:	4620      	mov	r0, r4
 8006142:	f001 fcb0 	bl	8007aa6 <HAL_GPIO_WritePin>

  /* Init GPIOs - common parameters */
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006146:	2601      	movs	r6, #1
 8006148:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800614a:	2500      	movs	r5, #0
 800614c:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800614e:	9504      	str	r5, [sp, #16]

  /* Init GPIOs - RESET pin */
  GPIO_InitStruct.Pin = MODEM_RST_PIN;
 8006150:	2340      	movs	r3, #64	; 0x40
 8006152:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_RST_GPIO_PORT, &GPIO_InitStruct);
 8006154:	a901      	add	r1, sp, #4
 8006156:	4620      	mov	r0, r4
 8006158:	f001 fb46 	bl	80077e8 <HAL_GPIO_Init>

  /* Init GPIOs - DTR pin */
  GPIO_InitStruct.Pin = MODEM_DTR_PIN;
 800615c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006160:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_DTR_GPIO_PORT, &GPIO_InitStruct);
 8006162:	a901      	add	r1, sp, #4
 8006164:	4638      	mov	r0, r7
 8006166:	f001 fb3f 	bl	80077e8 <HAL_GPIO_Init>

  /* Init GPIOs - PWR_EN pin */
  GPIO_InitStruct.Pin = MODEM_PWR_EN_PIN;
 800616a:	2380      	movs	r3, #128	; 0x80
 800616c:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_PWR_EN_GPIO_PORT, &GPIO_InitStruct);
 800616e:	a901      	add	r1, sp, #4
 8006170:	4620      	mov	r0, r4
 8006172:	f001 fb39 	bl	80077e8 <HAL_GPIO_Init>
  /* NOTE: do not activate RING interrupt at this point, it's too early and can result
   *       in a crash in NVIC handler
   */

  /* Print current modem UART setup */
  PRINT_FORCE("TYPE1SC UART config: BaudRate=%d / HW flow ctrl=%d", MODEM_UART_BAUDRATE,
 8006176:	4c10      	ldr	r4, [pc, #64]	; (80061b8 <TYPE1SC_setup+0x90>)
 8006178:	4633      	mov	r3, r6
 800617a:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800617e:	490f      	ldr	r1, [pc, #60]	; (80061bc <TYPE1SC_setup+0x94>)
 8006180:	4620      	mov	r0, r4
 8006182:	f01f fd75 	bl	8025c70 <sprintf>
 8006186:	4620      	mov	r0, r4
 8006188:	f018 ffc3 	bl	801f112 <crs_strlen>
 800618c:	b283      	uxth	r3, r0
 800618e:	4622      	mov	r2, r4
 8006190:	4631      	mov	r1, r6
 8006192:	2002      	movs	r0, #2
 8006194:	f019 f800 	bl	801f198 <traceIF_itmPrint>
 8006198:	4620      	mov	r0, r4
 800619a:	f018 ffba 	bl	801f112 <crs_strlen>
 800619e:	b282      	uxth	r2, r0
 80061a0:	4621      	mov	r1, r4
 80061a2:	2002      	movs	r0, #2
 80061a4:	f019 f832 	bl	801f20c <traceIF_uartPrintForce>
              ((MODEM_UART_HWFLOWCTRL == UART_HWCONTROL_NONE) ? 0 : 1))

  return (retval);
}
 80061a8:	4628      	mov	r0, r5
 80061aa:	b007      	add	sp, #28
 80061ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80061ae:	bf00      	nop
 80061b0:	48000800 	.word	0x48000800
 80061b4:	48000400 	.word	0x48000400
 80061b8:	200048dc 	.word	0x200048dc
 80061bc:	0802cc3c 	.word	0x0802cc3c

080061c0 <TYPE1SC_LP_disable_modem_uart>:

static void TYPE1SC_LP_disable_modem_uart(void)
{
 80061c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80061c4:	b086      	sub	sp, #24
  /* Note:
  *  Not needed for TYPE1SC_LP_enable_modem_uart because it is
  *  already done in HAL_UART_Init() which call MSP_Init
  */
  PRINT_DBG("enter TYPE1SC_LP_disable_modem_uart")
 80061c6:	4d4c      	ldr	r5, [pc, #304]	; (80062f8 <TYPE1SC_LP_disable_modem_uart+0x138>)
 80061c8:	4c4c      	ldr	r4, [pc, #304]	; (80062fc <TYPE1SC_LP_disable_modem_uart+0x13c>)
 80061ca:	f105 0630 	add.w	r6, r5, #48	; 0x30
 80061ce:	46ac      	mov	ip, r5
 80061d0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80061d4:	6020      	str	r0, [r4, #0]
 80061d6:	6061      	str	r1, [r4, #4]
 80061d8:	60a2      	str	r2, [r4, #8]
 80061da:	60e3      	str	r3, [r4, #12]
 80061dc:	4665      	mov	r5, ip
 80061de:	3410      	adds	r4, #16
 80061e0:	45b4      	cmp	ip, r6
 80061e2:	d1f4      	bne.n	80061ce <TYPE1SC_LP_disable_modem_uart+0xe>
 80061e4:	f8dc 0000 	ldr.w	r0, [ip]
 80061e8:	6020      	str	r0, [r4, #0]
 80061ea:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80061ee:	80a3      	strh	r3, [r4, #4]
 80061f0:	4c42      	ldr	r4, [pc, #264]	; (80062fc <TYPE1SC_LP_disable_modem_uart+0x13c>)
 80061f2:	4620      	mov	r0, r4
 80061f4:	f018 ff8d 	bl	801f112 <crs_strlen>
 80061f8:	b283      	uxth	r3, r0
 80061fa:	4622      	mov	r2, r4
 80061fc:	2102      	movs	r1, #2
 80061fe:	4608      	mov	r0, r1
 8006200:	f018 ffca 	bl	801f198 <traceIF_itmPrint>
 8006204:	4620      	mov	r0, r4
 8006206:	f018 ff84 	bl	801f112 <crs_strlen>
 800620a:	b283      	uxth	r3, r0
 800620c:	4622      	mov	r2, r4
 800620e:	2102      	movs	r1, #2
 8006210:	4608      	mov	r0, r1
 8006212:	f018 ffe3 	bl	801f1dc <traceIF_uartPrint>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006216:	2400      	movs	r4, #0
 8006218:	9401      	str	r4, [sp, #4]
 800621a:	9402      	str	r4, [sp, #8]
 800621c:	9403      	str	r4, [sp, #12]
 800621e:	9404      	str	r4, [sp, #16]
 8006220:	9405      	str	r4, [sp, #20]

  /* Configure CTS and RTS pins
   *   Do this even if HwFlowControl is not activated because
   *   pins are reserved in the current project
   */
  GPIO_InitStruct.Pin = MODEM_CTS_PIN;
 8006222:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006226:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8006228:	2502      	movs	r5, #2
 800622a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(MODEM_CTS_GPIO_PORT, &GPIO_InitStruct);
 800622c:	a901      	add	r1, sp, #4
 800622e:	4834      	ldr	r0, [pc, #208]	; (8006300 <TYPE1SC_LP_disable_modem_uart+0x140>)
 8006230:	f001 fada 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_RTS_PIN;
 8006234:	f04f 0804 	mov.w	r8, #4
 8006238:	f8cd 8004 	str.w	r8, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800623c:	2601      	movs	r6, #1
 800623e:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006240:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_RTS_GPIO_PORT, &GPIO_InitStruct);
 8006242:	4f30      	ldr	r7, [pc, #192]	; (8006304 <TYPE1SC_LP_disable_modem_uart+0x144>)
 8006244:	eb0d 0108 	add.w	r1, sp, r8
 8006248:	4638      	mov	r0, r7
 800624a:	f001 facd 	bl	80077e8 <HAL_GPIO_Init>

#if (DEBUG_LOW_POWER == 1)
  PRINT_INFO(">>> set RTS pin to LOW)")
#endif /* (DEBUG_LOW_POWER == 1) */
  HAL_GPIO_WritePin(MODEM_RTS_GPIO_PORT, MODEM_RTS_PIN, GPIO_PIN_RESET);
 800624e:	4622      	mov	r2, r4
 8006250:	4641      	mov	r1, r8
 8006252:	4638      	mov	r0, r7
 8006254:	f001 fc27 	bl	8007aa6 <HAL_GPIO_WritePin>

  /* Re-configure HOST_RX pin to monitor it */
  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 8006258:	2320      	movs	r3, #32
 800625a:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800625c:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800625e:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 8006260:	4d29      	ldr	r5, [pc, #164]	; (8006308 <TYPE1SC_LP_disable_modem_uart+0x148>)
 8006262:	eb0d 0108 	add.w	r1, sp, r8
 8006266:	4628      	mov	r0, r5
 8006268:	f001 fabe 	bl	80077e8 <HAL_GPIO_Init>

  /* Re-configure HOST_TX pin to allow to trigger Low Power */
  GPIO_InitStruct.Pin = MODEM_TX_PIN;
 800626c:	2710      	movs	r7, #16
 800626e:	9701      	str	r7, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006270:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006272:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8006274:	9604      	str	r6, [sp, #16]
  HAL_GPIO_Init(MODEM_TX_GPIO_PORT, &GPIO_InitStruct);
 8006276:	eb0d 0108 	add.w	r1, sp, r8
 800627a:	4628      	mov	r0, r5
 800627c:	f001 fab4 	bl	80077e8 <HAL_GPIO_Init>

#if (DEBUG_LOW_POWER == 1)
  PRINT_INFO(">>> Request modem to enter Low Power (set HOST-TX pin to LOW)")
#endif /* (DEBUG_LOW_POWER == 1) */
  HAL_GPIO_WritePin(MODEM_TX_GPIO_PORT, MODEM_TX_PIN, GPIO_PIN_RESET);
 8006280:	4622      	mov	r2, r4
 8006282:	4639      	mov	r1, r7
 8006284:	4628      	mov	r0, r5
 8006286:	f001 fc0e 	bl	8007aa6 <HAL_GPIO_WritePin>
  PRINT_INFO(">>> Waiting for HOST-RX pin set to LOW by modem")
#endif /* (DEBUG_LOW_POWER == 1) */
  uint32_t count = 0U;
  uint32_t count_delay = 10U;
  uint32_t count_max = 500U;
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_SET) &&
 800628a:	2120      	movs	r1, #32
 800628c:	481e      	ldr	r0, [pc, #120]	; (8006308 <TYPE1SC_LP_disable_modem_uart+0x148>)
 800628e:	f001 fc03 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006292:	2801      	cmp	r0, #1
 8006294:	d107      	bne.n	80062a6 <TYPE1SC_LP_disable_modem_uart+0xe6>
 8006296:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 800629a:	d204      	bcs.n	80062a6 <TYPE1SC_LP_disable_modem_uart+0xe6>
         (count < count_max))
  {
    SysCtrl_delay(count_delay);
 800629c:	200a      	movs	r0, #10
 800629e:	f00e fefd 	bl	801509c <SysCtrl_delay>
    count++;
 80062a2:	3401      	adds	r4, #1
 80062a4:	e7f1      	b.n	800628a <TYPE1SC_LP_disable_modem_uart+0xca>
    PRINT_INFO(">>> HOST-RX LOW after %ld ms", count * count_delay)
  }
#endif /* (DEBUG_LOW_POWER == 1) */

  /* Set modem UART GPIO pins to ANALOG to optimize power consumption */
  GPIO_InitStruct.Pin = MODEM_TX_PIN;
 80062a6:	2310      	movs	r3, #16
 80062a8:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062aa:	2503      	movs	r5, #3
 80062ac:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062ae:	2400      	movs	r4, #0
 80062b0:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_TX_GPIO_PORT, &GPIO_InitStruct);
 80062b2:	4e15      	ldr	r6, [pc, #84]	; (8006308 <TYPE1SC_LP_disable_modem_uart+0x148>)
 80062b4:	a901      	add	r1, sp, #4
 80062b6:	4630      	mov	r0, r6
 80062b8:	f001 fa96 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 80062bc:	2320      	movs	r3, #32
 80062be:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062c0:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062c2:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 80062c4:	a901      	add	r1, sp, #4
 80062c6:	4630      	mov	r0, r6
 80062c8:	f001 fa8e 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_CTS_PIN;
 80062cc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80062d0:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062d2:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062d4:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_CTS_GPIO_PORT, &GPIO_InitStruct);
 80062d6:	a901      	add	r1, sp, #4
 80062d8:	4809      	ldr	r0, [pc, #36]	; (8006300 <TYPE1SC_LP_disable_modem_uart+0x140>)
 80062da:	f001 fa85 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_RTS_PIN;
 80062de:	2304      	movs	r3, #4
 80062e0:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062e2:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062e4:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_RTS_GPIO_PORT, &GPIO_InitStruct);
 80062e6:	eb0d 0103 	add.w	r1, sp, r3
 80062ea:	4806      	ldr	r0, [pc, #24]	; (8006304 <TYPE1SC_LP_disable_modem_uart+0x144>)
 80062ec:	f001 fa7c 	bl	80077e8 <HAL_GPIO_Init>
}
 80062f0:	b006      	add	sp, #24
 80062f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80062f6:	bf00      	nop
 80062f8:	0802cc74 	.word	0x0802cc74
 80062fc:	200048dc 	.word	0x200048dc
 8006300:	48000400 	.word	0x48000400
 8006304:	48000c00 	.word	0x48000c00
 8006308:	48000800 	.word	0x48000800

0800630c <disable_RING>:
{
 800630c:	b500      	push	{lr}
 800630e:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006310:	2300      	movs	r3, #0
 8006312:	9301      	str	r3, [sp, #4]
 8006314:	9302      	str	r3, [sp, #8]
 8006316:	9303      	str	r3, [sp, #12]
 8006318:	9304      	str	r3, [sp, #16]
 800631a:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 800631c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006320:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006322:	2303      	movs	r3, #3
 8006324:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 8006326:	a901      	add	r1, sp, #4
 8006328:	4804      	ldr	r0, [pc, #16]	; (800633c <disable_RING+0x30>)
 800632a:	f001 fa5d 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_DisableIRQ(MODEM_RING_IRQN);
 800632e:	2028      	movs	r0, #40	; 0x28
 8006330:	f001 f9fc 	bl	800772c <HAL_NVIC_DisableIRQ>
}
 8006334:	b007      	add	sp, #28
 8006336:	f85d fb04 	ldr.w	pc, [sp], #4
 800633a:	bf00      	nop
 800633c:	48000400 	.word	0x48000400

08006340 <enable_RING_wait_for_falling>:
{
 8006340:	b500      	push	{lr}
 8006342:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006344:	2300      	movs	r3, #0
 8006346:	9301      	str	r3, [sp, #4]
 8006348:	9302      	str	r3, [sp, #8]
 800634a:	9303      	str	r3, [sp, #12]
 800634c:	9304      	str	r3, [sp, #16]
 800634e:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 8006350:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006354:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8006356:	4b06      	ldr	r3, [pc, #24]	; (8006370 <enable_RING_wait_for_falling+0x30>)
 8006358:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 800635a:	a901      	add	r1, sp, #4
 800635c:	4805      	ldr	r0, [pc, #20]	; (8006374 <enable_RING_wait_for_falling+0x34>)
 800635e:	f001 fa43 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_EnableIRQ(MODEM_RING_IRQN);
 8006362:	2028      	movs	r0, #40	; 0x28
 8006364:	f001 f9d4 	bl	8007710 <HAL_NVIC_EnableIRQ>
}
 8006368:	b007      	add	sp, #28
 800636a:	f85d fb04 	ldr.w	pc, [sp], #4
 800636e:	bf00      	nop
 8006370:	10210000 	.word	0x10210000
 8006374:	48000400 	.word	0x48000400

08006378 <enable_RING_wait_for_rising>:
{
 8006378:	b500      	push	{lr}
 800637a:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800637c:	2300      	movs	r3, #0
 800637e:	9301      	str	r3, [sp, #4]
 8006380:	9302      	str	r3, [sp, #8]
 8006382:	9303      	str	r3, [sp, #12]
 8006384:	9304      	str	r3, [sp, #16]
 8006386:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 8006388:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800638c:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 800638e:	4b06      	ldr	r3, [pc, #24]	; (80063a8 <enable_RING_wait_for_rising+0x30>)
 8006390:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 8006392:	a901      	add	r1, sp, #4
 8006394:	4805      	ldr	r0, [pc, #20]	; (80063ac <enable_RING_wait_for_rising+0x34>)
 8006396:	f001 fa27 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_EnableIRQ(MODEM_RING_IRQN);
 800639a:	2028      	movs	r0, #40	; 0x28
 800639c:	f001 f9b8 	bl	8007710 <HAL_NVIC_EnableIRQ>
}
 80063a0:	b007      	add	sp, #28
 80063a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80063a6:	bf00      	nop
 80063a8:	10110000 	.word	0x10110000
 80063ac:	48000400 	.word	0x48000400

080063b0 <SysCtrl_TYPE1SC_getDeviceDescriptor>:
  if (p_devices_list == NULL)
 80063b0:	b189      	cbz	r1, 80063d6 <SysCtrl_TYPE1SC_getDeviceDescriptor+0x26>
{
 80063b2:	b510      	push	{r4, lr}
 80063b4:	4604      	mov	r4, r0
 80063b6:	460b      	mov	r3, r1
    if (type == DEVTYPE_MODEM_CELLULAR)
 80063b8:	b108      	cbz	r0, 80063be <SysCtrl_TYPE1SC_getDeviceDescriptor+0xe>
      retval = SCSTATUS_ERROR;
 80063ba:	2001      	movs	r0, #1
}
 80063bc:	bd10      	pop	{r4, pc}
      p_devices_list->type          = DEVTYPE_MODEM_CELLULAR;
 80063be:	2000      	movs	r0, #0
 80063c0:	7008      	strb	r0, [r1, #0]
      p_devices_list->ipc_device    = USER_DEFINED_IPC_DEVICE_MODEM;
 80063c2:	7048      	strb	r0, [r1, #1]
      p_devices_list->ipc_interface = IPC_INTERFACE_UART;
 80063c4:	2101      	movs	r1, #1
 80063c6:	7099      	strb	r1, [r3, #2]
      (void) IPC_init(p_devices_list->ipc_device, p_devices_list->ipc_interface, &MODEM_UART_HANDLE);
 80063c8:	4a04      	ldr	r2, [pc, #16]	; (80063dc <SysCtrl_TYPE1SC_getDeviceDescriptor+0x2c>)
 80063ca:	f017 ff77 	bl	801e2bc <IPC_init>
    (void) TYPE1SC_setup();
 80063ce:	f7ff feab 	bl	8006128 <TYPE1SC_setup>
      retval = SCSTATUS_OK;
 80063d2:	4620      	mov	r0, r4
 80063d4:	e7f2      	b.n	80063bc <SysCtrl_TYPE1SC_getDeviceDescriptor+0xc>
    retval = SCSTATUS_ERROR;
 80063d6:	2001      	movs	r0, #1
}
 80063d8:	4770      	bx	lr
 80063da:	bf00      	nop
 80063dc:	20000d04 	.word	0x20000d04

080063e0 <SysCtrl_TYPE1SC_close_channel>:
{
 80063e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  PRINT_DBG("SysCtrl_TYPE1SC_close_channel")
 80063e2:	4e4b      	ldr	r6, [pc, #300]	; (8006510 <SysCtrl_TYPE1SC_close_channel+0x130>)
 80063e4:	4d4b      	ldr	r5, [pc, #300]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 80063e6:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80063ea:	4634      	mov	r4, r6
 80063ec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80063ee:	6028      	str	r0, [r5, #0]
 80063f0:	6069      	str	r1, [r5, #4]
 80063f2:	60aa      	str	r2, [r5, #8]
 80063f4:	60eb      	str	r3, [r5, #12]
 80063f6:	4626      	mov	r6, r4
 80063f8:	3510      	adds	r5, #16
 80063fa:	4564      	cmp	r4, ip
 80063fc:	d1f5      	bne.n	80063ea <SysCtrl_TYPE1SC_close_channel+0xa>
 80063fe:	4c45      	ldr	r4, [pc, #276]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 8006400:	4620      	mov	r0, r4
 8006402:	f018 fe86 	bl	801f112 <crs_strlen>
 8006406:	b283      	uxth	r3, r0
 8006408:	4622      	mov	r2, r4
 800640a:	2102      	movs	r1, #2
 800640c:	4608      	mov	r0, r1
 800640e:	f018 fec3 	bl	801f198 <traceIF_itmPrint>
 8006412:	4620      	mov	r0, r4
 8006414:	f018 fe7d 	bl	801f112 <crs_strlen>
 8006418:	b283      	uxth	r3, r0
 800641a:	4622      	mov	r2, r4
 800641c:	2102      	movs	r1, #2
 800641e:	4608      	mov	r0, r1
 8006420:	f018 fedc 	bl	801f1dc <traceIF_uartPrint>
  HAL_NVIC_DisableIRQ(MODEM_UART_IRQN);
 8006424:	2027      	movs	r0, #39	; 0x27
 8006426:	f001 f981 	bl	800772c <HAL_NVIC_DisableIRQ>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_RESET);
 800642a:	2200      	movs	r2, #0
 800642c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006430:	4839      	ldr	r0, [pc, #228]	; (8006518 <SysCtrl_TYPE1SC_close_channel+0x138>)
 8006432:	f001 fb38 	bl	8007aa6 <HAL_GPIO_WritePin>
  uint32_t count = 0U;
 8006436:	2400      	movs	r4, #0
  while ((HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN) == GPIO_PIN_SET) &&
 8006438:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800643c:	4837      	ldr	r0, [pc, #220]	; (800651c <SysCtrl_TYPE1SC_close_channel+0x13c>)
 800643e:	f001 fb2b 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006442:	2801      	cmp	r0, #1
 8006444:	d107      	bne.n	8006456 <SysCtrl_TYPE1SC_close_channel+0x76>
 8006446:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 800644a:	d204      	bcs.n	8006456 <SysCtrl_TYPE1SC_close_channel+0x76>
    SysCtrl_delay(count_delay);
 800644c:	200a      	movs	r0, #10
 800644e:	f00e fe25 	bl	801509c <SysCtrl_delay>
    count++;
 8006452:	3401      	adds	r4, #1
 8006454:	e7f0      	b.n	8006438 <SysCtrl_TYPE1SC_close_channel+0x58>
  if (HAL_UART_DeInit(&MODEM_UART_HANDLE) != HAL_OK)
 8006456:	4832      	ldr	r0, [pc, #200]	; (8006520 <SysCtrl_TYPE1SC_close_channel+0x140>)
 8006458:	f003 fdc6 	bl	8009fe8 <HAL_UART_DeInit>
 800645c:	4607      	mov	r7, r0
 800645e:	b348      	cbz	r0, 80064b4 <SysCtrl_TYPE1SC_close_channel+0xd4>
    PRINT_ERR("HAL_UART_DeInit error")
 8006460:	4d30      	ldr	r5, [pc, #192]	; (8006524 <SysCtrl_TYPE1SC_close_channel+0x144>)
 8006462:	4c2c      	ldr	r4, [pc, #176]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 8006464:	f105 0720 	add.w	r7, r5, #32
 8006468:	462e      	mov	r6, r5
 800646a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800646c:	6020      	str	r0, [r4, #0]
 800646e:	6061      	str	r1, [r4, #4]
 8006470:	60a2      	str	r2, [r4, #8]
 8006472:	60e3      	str	r3, [r4, #12]
 8006474:	4635      	mov	r5, r6
 8006476:	3410      	adds	r4, #16
 8006478:	42be      	cmp	r6, r7
 800647a:	d1f5      	bne.n	8006468 <SysCtrl_TYPE1SC_close_channel+0x88>
 800647c:	cd07      	ldmia	r5!, {r0, r1, r2}
 800647e:	6020      	str	r0, [r4, #0]
 8006480:	6061      	str	r1, [r4, #4]
 8006482:	60a2      	str	r2, [r4, #8]
 8006484:	882b      	ldrh	r3, [r5, #0]
 8006486:	81a3      	strh	r3, [r4, #12]
 8006488:	4c22      	ldr	r4, [pc, #136]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 800648a:	4620      	mov	r0, r4
 800648c:	f018 fe41 	bl	801f112 <crs_strlen>
 8006490:	b283      	uxth	r3, r0
 8006492:	4622      	mov	r2, r4
 8006494:	2110      	movs	r1, #16
 8006496:	2002      	movs	r0, #2
 8006498:	f018 fe7e 	bl	801f198 <traceIF_itmPrint>
 800649c:	4620      	mov	r0, r4
 800649e:	f018 fe38 	bl	801f112 <crs_strlen>
 80064a2:	b283      	uxth	r3, r0
 80064a4:	4622      	mov	r2, r4
 80064a6:	2110      	movs	r1, #16
 80064a8:	2002      	movs	r0, #2
 80064aa:	f018 fe97 	bl	801f1dc <traceIF_uartPrint>
    retval = SCSTATUS_ERROR;
 80064ae:	2701      	movs	r7, #1
}
 80064b0:	4638      	mov	r0, r7
 80064b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TYPE1SC_LP_disable_modem_uart();
 80064b4:	f7ff fe84 	bl	80061c0 <TYPE1SC_LP_disable_modem_uart>
    SysCtrl_delay(150U);
 80064b8:	2096      	movs	r0, #150	; 0x96
 80064ba:	f00e fdef 	bl	801509c <SysCtrl_delay>
    PRINT_INFO("modem channel closed")
 80064be:	4e1a      	ldr	r6, [pc, #104]	; (8006528 <SysCtrl_TYPE1SC_close_channel+0x148>)
 80064c0:	4c14      	ldr	r4, [pc, #80]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 80064c2:	f106 0c20 	add.w	ip, r6, #32
 80064c6:	4635      	mov	r5, r6
 80064c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80064ca:	6020      	str	r0, [r4, #0]
 80064cc:	6061      	str	r1, [r4, #4]
 80064ce:	60a2      	str	r2, [r4, #8]
 80064d0:	60e3      	str	r3, [r4, #12]
 80064d2:	462e      	mov	r6, r5
 80064d4:	3410      	adds	r4, #16
 80064d6:	4565      	cmp	r5, ip
 80064d8:	d1f5      	bne.n	80064c6 <SysCtrl_TYPE1SC_close_channel+0xe6>
 80064da:	6828      	ldr	r0, [r5, #0]
 80064dc:	6020      	str	r0, [r4, #0]
 80064de:	88aa      	ldrh	r2, [r5, #4]
 80064e0:	79ab      	ldrb	r3, [r5, #6]
 80064e2:	80a2      	strh	r2, [r4, #4]
 80064e4:	71a3      	strb	r3, [r4, #6]
 80064e6:	4c0b      	ldr	r4, [pc, #44]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 80064e8:	4620      	mov	r0, r4
 80064ea:	f018 fe12 	bl	801f112 <crs_strlen>
 80064ee:	b283      	uxth	r3, r0
 80064f0:	4622      	mov	r2, r4
 80064f2:	2101      	movs	r1, #1
 80064f4:	2002      	movs	r0, #2
 80064f6:	f018 fe4f 	bl	801f198 <traceIF_itmPrint>
 80064fa:	4620      	mov	r0, r4
 80064fc:	f018 fe09 	bl	801f112 <crs_strlen>
 8006500:	b283      	uxth	r3, r0
 8006502:	4622      	mov	r2, r4
 8006504:	2101      	movs	r1, #1
 8006506:	2002      	movs	r0, #2
 8006508:	f018 fe68 	bl	801f1dc <traceIF_uartPrint>
 800650c:	e7d0      	b.n	80064b0 <SysCtrl_TYPE1SC_close_channel+0xd0>
 800650e:	bf00      	nop
 8006510:	0802ccac 	.word	0x0802ccac
 8006514:	200048dc 	.word	0x200048dc
 8006518:	48000800 	.word	0x48000800
 800651c:	48000400 	.word	0x48000400
 8006520:	20000d04 	.word	0x20000d04
 8006524:	0802ccdc 	.word	0x0802ccdc
 8006528:	0802cd0c 	.word	0x0802cd0c

0800652c <SysCtrl_TYPE1SC_power_on>:
{
 800652c:	b538      	push	{r3, r4, r5, lr}
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 800652e:	2200      	movs	r2, #0
 8006530:	2180      	movs	r1, #128	; 0x80
 8006532:	4831      	ldr	r0, [pc, #196]	; (80065f8 <SysCtrl_TYPE1SC_power_on+0xcc>)
 8006534:	f001 fab7 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 8006538:	2096      	movs	r0, #150	; 0x96
 800653a:	f00e fdaf 	bl	801509c <SysCtrl_delay>
  PRINT_INFO("MODEM POWER ON")
 800653e:	4d2f      	ldr	r5, [pc, #188]	; (80065fc <SysCtrl_TYPE1SC_power_on+0xd0>)
 8006540:	4c2f      	ldr	r4, [pc, #188]	; (8006600 <SysCtrl_TYPE1SC_power_on+0xd4>)
 8006542:	f105 0e20 	add.w	lr, r5, #32
 8006546:	46ac      	mov	ip, r5
 8006548:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800654c:	6020      	str	r0, [r4, #0]
 800654e:	6061      	str	r1, [r4, #4]
 8006550:	60a2      	str	r2, [r4, #8]
 8006552:	60e3      	str	r3, [r4, #12]
 8006554:	4665      	mov	r5, ip
 8006556:	3410      	adds	r4, #16
 8006558:	45f4      	cmp	ip, lr
 800655a:	d1f4      	bne.n	8006546 <SysCtrl_TYPE1SC_power_on+0x1a>
 800655c:	f89c 3000 	ldrb.w	r3, [ip]
 8006560:	7023      	strb	r3, [r4, #0]
 8006562:	4c27      	ldr	r4, [pc, #156]	; (8006600 <SysCtrl_TYPE1SC_power_on+0xd4>)
 8006564:	4620      	mov	r0, r4
 8006566:	f018 fdd4 	bl	801f112 <crs_strlen>
 800656a:	b283      	uxth	r3, r0
 800656c:	4622      	mov	r2, r4
 800656e:	2101      	movs	r1, #1
 8006570:	2002      	movs	r0, #2
 8006572:	f018 fe11 	bl	801f198 <traceIF_itmPrint>
 8006576:	4620      	mov	r0, r4
 8006578:	f018 fdcb 	bl	801f112 <crs_strlen>
 800657c:	b283      	uxth	r3, r0
 800657e:	4622      	mov	r2, r4
 8006580:	2101      	movs	r1, #1
 8006582:	2002      	movs	r0, #2
 8006584:	f018 fe2a 	bl	801f1dc <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_SET);
 8006588:	2201      	movs	r2, #1
 800658a:	2180      	movs	r1, #128	; 0x80
 800658c:	481a      	ldr	r0, [pc, #104]	; (80065f8 <SysCtrl_TYPE1SC_power_on+0xcc>)
 800658e:	f001 fa8a 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 8006592:	2096      	movs	r0, #150	; 0x96
 8006594:	f00e fd82 	bl	801509c <SysCtrl_delay>
  enable_RING_wait_for_falling();
 8006598:	f7ff fed2 	bl	8006340 <enable_RING_wait_for_falling>
  PRINT_DBG("MODEM POWER ON done")
 800659c:	4d19      	ldr	r5, [pc, #100]	; (8006604 <SysCtrl_TYPE1SC_power_on+0xd8>)
 800659e:	46a4      	mov	ip, r4
 80065a0:	f105 0e20 	add.w	lr, r5, #32
 80065a4:	462c      	mov	r4, r5
 80065a6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80065a8:	f8cc 0000 	str.w	r0, [ip]
 80065ac:	f8cc 1004 	str.w	r1, [ip, #4]
 80065b0:	f8cc 2008 	str.w	r2, [ip, #8]
 80065b4:	f8cc 300c 	str.w	r3, [ip, #12]
 80065b8:	4625      	mov	r5, r4
 80065ba:	f10c 0c10 	add.w	ip, ip, #16
 80065be:	4574      	cmp	r4, lr
 80065c0:	d1f0      	bne.n	80065a4 <SysCtrl_TYPE1SC_power_on+0x78>
 80065c2:	6820      	ldr	r0, [r4, #0]
 80065c4:	f8cc 0000 	str.w	r0, [ip]
 80065c8:	88a3      	ldrh	r3, [r4, #4]
 80065ca:	f8ac 3004 	strh.w	r3, [ip, #4]
 80065ce:	4c0c      	ldr	r4, [pc, #48]	; (8006600 <SysCtrl_TYPE1SC_power_on+0xd4>)
 80065d0:	4620      	mov	r0, r4
 80065d2:	f018 fd9e 	bl	801f112 <crs_strlen>
 80065d6:	b283      	uxth	r3, r0
 80065d8:	4622      	mov	r2, r4
 80065da:	2102      	movs	r1, #2
 80065dc:	4608      	mov	r0, r1
 80065de:	f018 fddb 	bl	801f198 <traceIF_itmPrint>
 80065e2:	4620      	mov	r0, r4
 80065e4:	f018 fd95 	bl	801f112 <crs_strlen>
 80065e8:	b283      	uxth	r3, r0
 80065ea:	4622      	mov	r2, r4
 80065ec:	2102      	movs	r1, #2
 80065ee:	4608      	mov	r0, r1
 80065f0:	f018 fdf4 	bl	801f1dc <traceIF_uartPrint>
}
 80065f4:	2000      	movs	r0, #0
 80065f6:	bd38      	pop	{r3, r4, r5, pc}
 80065f8:	48000400 	.word	0x48000400
 80065fc:	0802cd34 	.word	0x0802cd34
 8006600:	200048dc 	.word	0x200048dc
 8006604:	0802cd58 	.word	0x0802cd58

08006608 <SysCtrl_TYPE1SC_power_off>:
{
 8006608:	b538      	push	{r3, r4, r5, lr}
  PRINT_INFO("MODEM POWER OFF")
 800660a:	4d30      	ldr	r5, [pc, #192]	; (80066cc <SysCtrl_TYPE1SC_power_off+0xc4>)
 800660c:	4c30      	ldr	r4, [pc, #192]	; (80066d0 <SysCtrl_TYPE1SC_power_off+0xc8>)
 800660e:	f105 0e20 	add.w	lr, r5, #32
 8006612:	46ac      	mov	ip, r5
 8006614:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006618:	6020      	str	r0, [r4, #0]
 800661a:	6061      	str	r1, [r4, #4]
 800661c:	60a2      	str	r2, [r4, #8]
 800661e:	60e3      	str	r3, [r4, #12]
 8006620:	4665      	mov	r5, ip
 8006622:	3410      	adds	r4, #16
 8006624:	45f4      	cmp	ip, lr
 8006626:	d1f4      	bne.n	8006612 <SysCtrl_TYPE1SC_power_off+0xa>
 8006628:	f8bc 3000 	ldrh.w	r3, [ip]
 800662c:	8023      	strh	r3, [r4, #0]
 800662e:	4c28      	ldr	r4, [pc, #160]	; (80066d0 <SysCtrl_TYPE1SC_power_off+0xc8>)
 8006630:	4620      	mov	r0, r4
 8006632:	f018 fd6e 	bl	801f112 <crs_strlen>
 8006636:	b283      	uxth	r3, r0
 8006638:	4622      	mov	r2, r4
 800663a:	2101      	movs	r1, #1
 800663c:	2002      	movs	r0, #2
 800663e:	f018 fdab 	bl	801f198 <traceIF_itmPrint>
 8006642:	4620      	mov	r0, r4
 8006644:	f018 fd65 	bl	801f112 <crs_strlen>
 8006648:	b283      	uxth	r3, r0
 800664a:	4622      	mov	r2, r4
 800664c:	2101      	movs	r1, #1
 800664e:	2002      	movs	r0, #2
 8006650:	f018 fdc4 	bl	801f1dc <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 8006654:	2200      	movs	r2, #0
 8006656:	2180      	movs	r1, #128	; 0x80
 8006658:	481e      	ldr	r0, [pc, #120]	; (80066d4 <SysCtrl_TYPE1SC_power_off+0xcc>)
 800665a:	f001 fa24 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 800665e:	2096      	movs	r0, #150	; 0x96
 8006660:	f00e fd1c 	bl	801509c <SysCtrl_delay>
  disable_RING();
 8006664:	f7ff fe52 	bl	800630c <disable_RING>
  PRINT_DBG("MODEM POWER OFF done")
 8006668:	4d1b      	ldr	r5, [pc, #108]	; (80066d8 <SysCtrl_TYPE1SC_power_off+0xd0>)
 800666a:	46a4      	mov	ip, r4
 800666c:	f105 0e20 	add.w	lr, r5, #32
 8006670:	462c      	mov	r4, r5
 8006672:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006674:	f8cc 0000 	str.w	r0, [ip]
 8006678:	f8cc 1004 	str.w	r1, [ip, #4]
 800667c:	f8cc 2008 	str.w	r2, [ip, #8]
 8006680:	f8cc 300c 	str.w	r3, [ip, #12]
 8006684:	4625      	mov	r5, r4
 8006686:	f10c 0c10 	add.w	ip, ip, #16
 800668a:	4574      	cmp	r4, lr
 800668c:	d1f0      	bne.n	8006670 <SysCtrl_TYPE1SC_power_off+0x68>
 800668e:	6820      	ldr	r0, [r4, #0]
 8006690:	f8cc 0000 	str.w	r0, [ip]
 8006694:	88a2      	ldrh	r2, [r4, #4]
 8006696:	79a3      	ldrb	r3, [r4, #6]
 8006698:	f8ac 2004 	strh.w	r2, [ip, #4]
 800669c:	f88c 3006 	strb.w	r3, [ip, #6]
 80066a0:	4c0b      	ldr	r4, [pc, #44]	; (80066d0 <SysCtrl_TYPE1SC_power_off+0xc8>)
 80066a2:	4620      	mov	r0, r4
 80066a4:	f018 fd35 	bl	801f112 <crs_strlen>
 80066a8:	b283      	uxth	r3, r0
 80066aa:	4622      	mov	r2, r4
 80066ac:	2102      	movs	r1, #2
 80066ae:	4608      	mov	r0, r1
 80066b0:	f018 fd72 	bl	801f198 <traceIF_itmPrint>
 80066b4:	4620      	mov	r0, r4
 80066b6:	f018 fd2c 	bl	801f112 <crs_strlen>
 80066ba:	b283      	uxth	r3, r0
 80066bc:	4622      	mov	r2, r4
 80066be:	2102      	movs	r1, #2
 80066c0:	4608      	mov	r0, r1
 80066c2:	f018 fd8b 	bl	801f1dc <traceIF_uartPrint>
}
 80066c6:	2000      	movs	r0, #0
 80066c8:	bd38      	pop	{r3, r4, r5, pc}
 80066ca:	bf00      	nop
 80066cc:	0802cd80 	.word	0x0802cd80
 80066d0:	200048dc 	.word	0x200048dc
 80066d4:	48000400 	.word	0x48000400
 80066d8:	0802cda4 	.word	0x0802cda4

080066dc <SysCtrl_TYPE1SC_reset>:
{
 80066dc:	b538      	push	{r3, r4, r5, lr}
  PRINT_INFO("!!! Modem hardware reset triggered !!!")
 80066de:	4c1d      	ldr	r4, [pc, #116]	; (8006754 <SysCtrl_TYPE1SC_reset+0x78>)
 80066e0:	4d1d      	ldr	r5, [pc, #116]	; (8006758 <SysCtrl_TYPE1SC_reset+0x7c>)
 80066e2:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 80066e6:	46a4      	mov	ip, r4
 80066e8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80066ec:	6028      	str	r0, [r5, #0]
 80066ee:	6069      	str	r1, [r5, #4]
 80066f0:	60aa      	str	r2, [r5, #8]
 80066f2:	60eb      	str	r3, [r5, #12]
 80066f4:	4664      	mov	r4, ip
 80066f6:	3510      	adds	r5, #16
 80066f8:	45f4      	cmp	ip, lr
 80066fa:	d1f4      	bne.n	80066e6 <SysCtrl_TYPE1SC_reset+0xa>
 80066fc:	cc03      	ldmia	r4!, {r0, r1}
 80066fe:	6028      	str	r0, [r5, #0]
 8006700:	6069      	str	r1, [r5, #4]
 8006702:	7823      	ldrb	r3, [r4, #0]
 8006704:	722b      	strb	r3, [r5, #8]
 8006706:	4c14      	ldr	r4, [pc, #80]	; (8006758 <SysCtrl_TYPE1SC_reset+0x7c>)
 8006708:	4620      	mov	r0, r4
 800670a:	f018 fd02 	bl	801f112 <crs_strlen>
 800670e:	b283      	uxth	r3, r0
 8006710:	4622      	mov	r2, r4
 8006712:	2101      	movs	r1, #1
 8006714:	2002      	movs	r0, #2
 8006716:	f018 fd3f 	bl	801f198 <traceIF_itmPrint>
 800671a:	4620      	mov	r0, r4
 800671c:	f018 fcf9 	bl	801f112 <crs_strlen>
 8006720:	b283      	uxth	r3, r0
 8006722:	4622      	mov	r2, r4
 8006724:	2101      	movs	r1, #1
 8006726:	2002      	movs	r0, #2
 8006728:	f018 fd58 	bl	801f1dc <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 800672c:	4c0b      	ldr	r4, [pc, #44]	; (800675c <SysCtrl_TYPE1SC_reset+0x80>)
 800672e:	2200      	movs	r2, #0
 8006730:	2180      	movs	r1, #128	; 0x80
 8006732:	4620      	mov	r0, r4
 8006734:	f001 f9b7 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 8006738:	2096      	movs	r0, #150	; 0x96
 800673a:	f00e fcaf 	bl	801509c <SysCtrl_delay>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_SET);
 800673e:	2201      	movs	r2, #1
 8006740:	2180      	movs	r1, #128	; 0x80
 8006742:	4620      	mov	r0, r4
 8006744:	f001 f9af 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(TYPE1SC_BOOT_TIME);
 8006748:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800674c:	f00e fca6 	bl	801509c <SysCtrl_delay>
}
 8006750:	2000      	movs	r0, #0
 8006752:	bd38      	pop	{r3, r4, r5, pc}
 8006754:	0802cdcc 	.word	0x0802cdcc
 8006758:	200048dc 	.word	0x200048dc
 800675c:	48000400 	.word	0x48000400

08006760 <SysCtrl_TYPE1SC_sim_select>:
}
 8006760:	2000      	movs	r0, #0
 8006762:	4770      	bx	lr

08006764 <SysCtrl_TYPE1SC_request_suspend_channel>:
{
 8006764:	b538      	push	{r3, r4, r5, lr}
  PRINT_DBG("enter modem channel suspend request")
 8006766:	4d23      	ldr	r5, [pc, #140]	; (80067f4 <SysCtrl_TYPE1SC_request_suspend_channel+0x90>)
 8006768:	4c23      	ldr	r4, [pc, #140]	; (80067f8 <SysCtrl_TYPE1SC_request_suspend_channel+0x94>)
 800676a:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 800676e:	46ac      	mov	ip, r5
 8006770:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006774:	6020      	str	r0, [r4, #0]
 8006776:	6061      	str	r1, [r4, #4]
 8006778:	60a2      	str	r2, [r4, #8]
 800677a:	60e3      	str	r3, [r4, #12]
 800677c:	4665      	mov	r5, ip
 800677e:	3410      	adds	r4, #16
 8006780:	45f4      	cmp	ip, lr
 8006782:	d1f4      	bne.n	800676e <SysCtrl_TYPE1SC_request_suspend_channel+0xa>
 8006784:	f8dc 0000 	ldr.w	r0, [ip]
 8006788:	6020      	str	r0, [r4, #0]
 800678a:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800678e:	80a3      	strh	r3, [r4, #4]
 8006790:	4c19      	ldr	r4, [pc, #100]	; (80067f8 <SysCtrl_TYPE1SC_request_suspend_channel+0x94>)
 8006792:	4620      	mov	r0, r4
 8006794:	f018 fcbd 	bl	801f112 <crs_strlen>
 8006798:	b283      	uxth	r3, r0
 800679a:	4622      	mov	r2, r4
 800679c:	2102      	movs	r1, #2
 800679e:	4608      	mov	r0, r1
 80067a0:	f018 fcfa 	bl	801f198 <traceIF_itmPrint>
 80067a4:	4620      	mov	r0, r4
 80067a6:	f018 fcb4 	bl	801f112 <crs_strlen>
 80067aa:	b283      	uxth	r3, r0
 80067ac:	4622      	mov	r2, r4
 80067ae:	2102      	movs	r1, #2
 80067b0:	4608      	mov	r0, r1
 80067b2:	f018 fd13 	bl	801f1dc <traceIF_uartPrint>
  PRINT_INFO(">>> Request modem to enter Low Power: Set HOST_TO_MODEM (=DTR) to LOW")
 80067b6:	2258      	movs	r2, #88	; 0x58
 80067b8:	4910      	ldr	r1, [pc, #64]	; (80067fc <SysCtrl_TYPE1SC_request_suspend_channel+0x98>)
 80067ba:	4620      	mov	r0, r4
 80067bc:	f01f fba8 	bl	8025f10 <memcpy>
 80067c0:	4620      	mov	r0, r4
 80067c2:	f018 fca6 	bl	801f112 <crs_strlen>
 80067c6:	b283      	uxth	r3, r0
 80067c8:	4622      	mov	r2, r4
 80067ca:	2101      	movs	r1, #1
 80067cc:	2002      	movs	r0, #2
 80067ce:	f018 fce3 	bl	801f198 <traceIF_itmPrint>
 80067d2:	4620      	mov	r0, r4
 80067d4:	f018 fc9d 	bl	801f112 <crs_strlen>
 80067d8:	b283      	uxth	r3, r0
 80067da:	4622      	mov	r2, r4
 80067dc:	2101      	movs	r1, #1
 80067de:	2002      	movs	r0, #2
 80067e0:	f018 fcfc 	bl	801f1dc <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_RESET);
 80067e4:	2200      	movs	r2, #0
 80067e6:	f44f 7180 	mov.w	r1, #256	; 0x100
 80067ea:	4805      	ldr	r0, [pc, #20]	; (8006800 <SysCtrl_TYPE1SC_request_suspend_channel+0x9c>)
 80067ec:	f001 f95b 	bl	8007aa6 <HAL_GPIO_WritePin>
}
 80067f0:	2000      	movs	r0, #0
 80067f2:	bd38      	pop	{r3, r4, r5, pc}
 80067f4:	0802ce08 	.word	0x0802ce08
 80067f8:	200048dc 	.word	0x200048dc
 80067fc:	0802ce40 	.word	0x0802ce40
 8006800:	48000800 	.word	0x48000800

08006804 <SysCtrl_TYPE1SC_complete_suspend_channel>:
{
 8006804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  PRINT_DBG("enter modem channel suspend complete")
 8006806:	4d45      	ldr	r5, [pc, #276]	; (800691c <SysCtrl_TYPE1SC_complete_suspend_channel+0x118>)
 8006808:	4c45      	ldr	r4, [pc, #276]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 800680a:	f105 0630 	add.w	r6, r5, #48	; 0x30
 800680e:	46ac      	mov	ip, r5
 8006810:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006814:	6020      	str	r0, [r4, #0]
 8006816:	6061      	str	r1, [r4, #4]
 8006818:	60a2      	str	r2, [r4, #8]
 800681a:	60e3      	str	r3, [r4, #12]
 800681c:	4665      	mov	r5, ip
 800681e:	3410      	adds	r4, #16
 8006820:	45b4      	cmp	ip, r6
 8006822:	d1f4      	bne.n	800680e <SysCtrl_TYPE1SC_complete_suspend_channel+0xa>
 8006824:	f8dc 0000 	ldr.w	r0, [ip]
 8006828:	6020      	str	r0, [r4, #0]
 800682a:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800682e:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8006832:	80a2      	strh	r2, [r4, #4]
 8006834:	71a3      	strb	r3, [r4, #6]
 8006836:	4c3a      	ldr	r4, [pc, #232]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 8006838:	4620      	mov	r0, r4
 800683a:	f018 fc6a 	bl	801f112 <crs_strlen>
 800683e:	b283      	uxth	r3, r0
 8006840:	4622      	mov	r2, r4
 8006842:	2102      	movs	r1, #2
 8006844:	4608      	mov	r0, r1
 8006846:	f018 fca7 	bl	801f198 <traceIF_itmPrint>
 800684a:	4620      	mov	r0, r4
 800684c:	f018 fc61 	bl	801f112 <crs_strlen>
 8006850:	b283      	uxth	r3, r0
 8006852:	4622      	mov	r2, r4
 8006854:	2102      	movs	r1, #2
 8006856:	4608      	mov	r0, r1
 8006858:	f018 fcc0 	bl	801f1dc <traceIF_uartPrint>
  HAL_NVIC_DisableIRQ(MODEM_UART_IRQN);
 800685c:	2027      	movs	r0, #39	; 0x27
 800685e:	f000 ff65 	bl	800772c <HAL_NVIC_DisableIRQ>
  if (HAL_UART_DeInit(&MODEM_UART_HANDLE) != HAL_OK)
 8006862:	4830      	ldr	r0, [pc, #192]	; (8006924 <SysCtrl_TYPE1SC_complete_suspend_channel+0x120>)
 8006864:	f003 fbc0 	bl	8009fe8 <HAL_UART_DeInit>
 8006868:	4607      	mov	r7, r0
 800686a:	b370      	cbz	r0, 80068ca <SysCtrl_TYPE1SC_complete_suspend_channel+0xc6>
    PRINT_ERR("HAL_UART_DeInit error")
 800686c:	4c2e      	ldr	r4, [pc, #184]	; (8006928 <SysCtrl_TYPE1SC_complete_suspend_channel+0x124>)
 800686e:	4d2c      	ldr	r5, [pc, #176]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 8006870:	f104 0620 	add.w	r6, r4, #32
 8006874:	46a4      	mov	ip, r4
 8006876:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800687a:	6028      	str	r0, [r5, #0]
 800687c:	6069      	str	r1, [r5, #4]
 800687e:	60aa      	str	r2, [r5, #8]
 8006880:	60eb      	str	r3, [r5, #12]
 8006882:	4664      	mov	r4, ip
 8006884:	3510      	adds	r5, #16
 8006886:	45b4      	cmp	ip, r6
 8006888:	d1f4      	bne.n	8006874 <SysCtrl_TYPE1SC_complete_suspend_channel+0x70>
 800688a:	cc07      	ldmia	r4!, {r0, r1, r2}
 800688c:	6028      	str	r0, [r5, #0]
 800688e:	6069      	str	r1, [r5, #4]
 8006890:	60aa      	str	r2, [r5, #8]
 8006892:	8823      	ldrh	r3, [r4, #0]
 8006894:	81ab      	strh	r3, [r5, #12]
 8006896:	4c22      	ldr	r4, [pc, #136]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 8006898:	4620      	mov	r0, r4
 800689a:	f018 fc3a 	bl	801f112 <crs_strlen>
 800689e:	b283      	uxth	r3, r0
 80068a0:	4622      	mov	r2, r4
 80068a2:	2110      	movs	r1, #16
 80068a4:	2002      	movs	r0, #2
 80068a6:	f018 fc77 	bl	801f198 <traceIF_itmPrint>
 80068aa:	4620      	mov	r0, r4
 80068ac:	f018 fc31 	bl	801f112 <crs_strlen>
 80068b0:	b283      	uxth	r3, r0
 80068b2:	4622      	mov	r2, r4
 80068b4:	2110      	movs	r1, #16
 80068b6:	2002      	movs	r0, #2
 80068b8:	f018 fc90 	bl	801f1dc <traceIF_uartPrint>
    retval = SCSTATUS_ERROR;
 80068bc:	2701      	movs	r7, #1
  TYPE1SC_LP_disable_modem_uart();
 80068be:	f7ff fc7f 	bl	80061c0 <TYPE1SC_LP_disable_modem_uart>
  enable_RING_wait_for_rising();
 80068c2:	f7ff fd59 	bl	8006378 <enable_RING_wait_for_rising>
}
 80068c6:	4638      	mov	r0, r7
 80068c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_DBG("modem channel closed")
 80068ca:	4e18      	ldr	r6, [pc, #96]	; (800692c <SysCtrl_TYPE1SC_complete_suspend_channel+0x128>)
 80068cc:	4c14      	ldr	r4, [pc, #80]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 80068ce:	f106 0c20 	add.w	ip, r6, #32
 80068d2:	4635      	mov	r5, r6
 80068d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80068d6:	6020      	str	r0, [r4, #0]
 80068d8:	6061      	str	r1, [r4, #4]
 80068da:	60a2      	str	r2, [r4, #8]
 80068dc:	60e3      	str	r3, [r4, #12]
 80068de:	462e      	mov	r6, r5
 80068e0:	3410      	adds	r4, #16
 80068e2:	4565      	cmp	r5, ip
 80068e4:	d1f5      	bne.n	80068d2 <SysCtrl_TYPE1SC_complete_suspend_channel+0xce>
 80068e6:	6828      	ldr	r0, [r5, #0]
 80068e8:	6020      	str	r0, [r4, #0]
 80068ea:	88aa      	ldrh	r2, [r5, #4]
 80068ec:	79ab      	ldrb	r3, [r5, #6]
 80068ee:	80a2      	strh	r2, [r4, #4]
 80068f0:	71a3      	strb	r3, [r4, #6]
 80068f2:	4c0b      	ldr	r4, [pc, #44]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 80068f4:	4620      	mov	r0, r4
 80068f6:	f018 fc0c 	bl	801f112 <crs_strlen>
 80068fa:	b283      	uxth	r3, r0
 80068fc:	4622      	mov	r2, r4
 80068fe:	2102      	movs	r1, #2
 8006900:	4608      	mov	r0, r1
 8006902:	f018 fc49 	bl	801f198 <traceIF_itmPrint>
 8006906:	4620      	mov	r0, r4
 8006908:	f018 fc03 	bl	801f112 <crs_strlen>
 800690c:	b283      	uxth	r3, r0
 800690e:	4622      	mov	r2, r4
 8006910:	2102      	movs	r1, #2
 8006912:	4608      	mov	r0, r1
 8006914:	f018 fc62 	bl	801f1dc <traceIF_uartPrint>
 8006918:	e7d1      	b.n	80068be <SysCtrl_TYPE1SC_complete_suspend_channel+0xba>
 800691a:	bf00      	nop
 800691c:	0802ce98 	.word	0x0802ce98
 8006920:	200048dc 	.word	0x200048dc
 8006924:	20000d04 	.word	0x20000d04
 8006928:	0802ccdc 	.word	0x0802ccdc
 800692c:	0802cd0c 	.word	0x0802cd0c

08006930 <enable_UART>:

  return (retval);
}

sysctrl_status_t enable_UART(IPC_Handle_t *ipc_handle, SysCtrl_TYPE1SC_HwFlowCtrl_t hwFC_status)
{
 8006930:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006934:	b086      	sub	sp, #24
 8006936:	4607      	mov	r7, r0
 8006938:	460e      	mov	r6, r1
  sysctrl_status_t retval = SCSTATUS_OK;
  PRINT_DBG("enter enable_UART")
 800693a:	4d87      	ldr	r5, [pc, #540]	; (8006b58 <enable_UART+0x228>)
 800693c:	4c87      	ldr	r4, [pc, #540]	; (8006b5c <enable_UART+0x22c>)
 800693e:	f105 0e20 	add.w	lr, r5, #32
 8006942:	46ac      	mov	ip, r5
 8006944:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006948:	6020      	str	r0, [r4, #0]
 800694a:	6061      	str	r1, [r4, #4]
 800694c:	60a2      	str	r2, [r4, #8]
 800694e:	60e3      	str	r3, [r4, #12]
 8006950:	4665      	mov	r5, ip
 8006952:	3410      	adds	r4, #16
 8006954:	45f4      	cmp	ip, lr
 8006956:	d1f4      	bne.n	8006942 <enable_UART+0x12>
 8006958:	f8dc 0000 	ldr.w	r0, [ip]
 800695c:	6020      	str	r0, [r4, #0]
 800695e:	4c7f      	ldr	r4, [pc, #508]	; (8006b5c <enable_UART+0x22c>)
 8006960:	4620      	mov	r0, r4
 8006962:	f018 fbd6 	bl	801f112 <crs_strlen>
 8006966:	b283      	uxth	r3, r0
 8006968:	4622      	mov	r2, r4
 800696a:	2102      	movs	r1, #2
 800696c:	4608      	mov	r0, r1
 800696e:	f018 fc13 	bl	801f198 <traceIF_itmPrint>
 8006972:	4620      	mov	r0, r4
 8006974:	f018 fbcd 	bl	801f112 <crs_strlen>
 8006978:	b283      	uxth	r3, r0
 800697a:	4622      	mov	r2, r4
 800697c:	2102      	movs	r1, #2
 800697e:	4608      	mov	r0, r1
 8006980:	f018 fc2c 	bl	801f1dc <traceIF_uartPrint>

  /* UART deinitialization */
  if (HAL_UART_DeInit(&MODEM_UART_HANDLE) != HAL_OK)
 8006984:	4876      	ldr	r0, [pc, #472]	; (8006b60 <enable_UART+0x230>)
 8006986:	f003 fb2f 	bl	8009fe8 <HAL_UART_DeInit>
 800698a:	b368      	cbz	r0, 80069e8 <enable_UART+0xb8>
  {
    PRINT_ERR("HAL_UART_DeInit error")
 800698c:	4c75      	ldr	r4, [pc, #468]	; (8006b64 <enable_UART+0x234>)
 800698e:	4d73      	ldr	r5, [pc, #460]	; (8006b5c <enable_UART+0x22c>)
 8006990:	f104 0620 	add.w	r6, r4, #32
 8006994:	46a4      	mov	ip, r4
 8006996:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800699a:	6028      	str	r0, [r5, #0]
 800699c:	6069      	str	r1, [r5, #4]
 800699e:	60aa      	str	r2, [r5, #8]
 80069a0:	60eb      	str	r3, [r5, #12]
 80069a2:	4664      	mov	r4, ip
 80069a4:	3510      	adds	r5, #16
 80069a6:	45b4      	cmp	ip, r6
 80069a8:	d1f4      	bne.n	8006994 <enable_UART+0x64>
 80069aa:	cc07      	ldmia	r4!, {r0, r1, r2}
 80069ac:	6028      	str	r0, [r5, #0]
 80069ae:	6069      	str	r1, [r5, #4]
 80069b0:	60aa      	str	r2, [r5, #8]
 80069b2:	8823      	ldrh	r3, [r4, #0]
 80069b4:	81ab      	strh	r3, [r5, #12]
 80069b6:	4c69      	ldr	r4, [pc, #420]	; (8006b5c <enable_UART+0x22c>)
 80069b8:	4620      	mov	r0, r4
 80069ba:	f018 fbaa 	bl	801f112 <crs_strlen>
 80069be:	b283      	uxth	r3, r0
 80069c0:	4622      	mov	r2, r4
 80069c2:	2110      	movs	r1, #16
 80069c4:	2002      	movs	r0, #2
 80069c6:	f018 fbe7 	bl	801f198 <traceIF_itmPrint>
 80069ca:	4620      	mov	r0, r4
 80069cc:	f018 fba1 	bl	801f112 <crs_strlen>
 80069d0:	b283      	uxth	r3, r0
 80069d2:	4622      	mov	r2, r4
 80069d4:	2110      	movs	r1, #16
 80069d6:	2002      	movs	r0, #2
 80069d8:	f018 fc00 	bl	801f1dc <traceIF_uartPrint>
    retval = SCSTATUS_ERROR;
 80069dc:	f04f 0801 	mov.w	r8, #1
      retval = SCSTATUS_ERROR;
    }
  }

  return (retval);
}
 80069e0:	4640      	mov	r0, r8
 80069e2:	b006      	add	sp, #24
 80069e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SysCtrl_delay(50U);
 80069e8:	2032      	movs	r0, #50	; 0x32
 80069ea:	f00e fb57 	bl	801509c <SysCtrl_delay>
    MODEM_UART_HANDLE.Instance = MODEM_UART_INSTANCE;
 80069ee:	4b5c      	ldr	r3, [pc, #368]	; (8006b60 <enable_UART+0x230>)
 80069f0:	4a5d      	ldr	r2, [pc, #372]	; (8006b68 <enable_UART+0x238>)
 80069f2:	601a      	str	r2, [r3, #0]
    MODEM_UART_HANDLE.Init.BaudRate = MODEM_UART_BAUDRATE;
 80069f4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80069f8:	605a      	str	r2, [r3, #4]
    MODEM_UART_HANDLE.Init.WordLength = MODEM_UART_WORDLENGTH;
 80069fa:	2200      	movs	r2, #0
 80069fc:	609a      	str	r2, [r3, #8]
    MODEM_UART_HANDLE.Init.StopBits = MODEM_UART_STOPBITS;
 80069fe:	60da      	str	r2, [r3, #12]
    MODEM_UART_HANDLE.Init.Parity = MODEM_UART_PARITY;
 8006a00:	611a      	str	r2, [r3, #16]
    MODEM_UART_HANDLE.Init.Mode = MODEM_UART_MODE;
 8006a02:	220c      	movs	r2, #12
 8006a04:	615a      	str	r2, [r3, #20]
    if (hwFC_status == SYSCTRL_HW_FLOW_CONTROL_NONE)
 8006a06:	2e00      	cmp	r6, #0
 8006a08:	d155      	bne.n	8006ab6 <enable_UART+0x186>
      MODEM_UART_HANDLE.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006a0a:	2200      	movs	r2, #0
 8006a0c:	619a      	str	r2, [r3, #24]
    PRINT_INFO("UART config: setting HW Flow Control to %d",
 8006a0e:	4c54      	ldr	r4, [pc, #336]	; (8006b60 <enable_UART+0x230>)
 8006a10:	69a2      	ldr	r2, [r4, #24]
 8006a12:	4d52      	ldr	r5, [pc, #328]	; (8006b5c <enable_UART+0x22c>)
 8006a14:	3a00      	subs	r2, #0
 8006a16:	bf18      	it	ne
 8006a18:	2201      	movne	r2, #1
 8006a1a:	4954      	ldr	r1, [pc, #336]	; (8006b6c <enable_UART+0x23c>)
 8006a1c:	4628      	mov	r0, r5
 8006a1e:	f01f f927 	bl	8025c70 <sprintf>
 8006a22:	4628      	mov	r0, r5
 8006a24:	f018 fb75 	bl	801f112 <crs_strlen>
 8006a28:	b283      	uxth	r3, r0
 8006a2a:	462a      	mov	r2, r5
 8006a2c:	2101      	movs	r1, #1
 8006a2e:	2002      	movs	r0, #2
 8006a30:	f018 fbb2 	bl	801f198 <traceIF_itmPrint>
 8006a34:	4628      	mov	r0, r5
 8006a36:	f018 fb6c 	bl	801f112 <crs_strlen>
 8006a3a:	b283      	uxth	r3, r0
 8006a3c:	462a      	mov	r2, r5
 8006a3e:	2101      	movs	r1, #1
 8006a40:	2002      	movs	r0, #2
 8006a42:	f018 fbcb 	bl	801f1dc <traceIF_uartPrint>
    MODEM_UART_HANDLE.Init.OverSampling = UART_OVERSAMPLING_16;
 8006a46:	2300      	movs	r3, #0
 8006a48:	61e3      	str	r3, [r4, #28]
    MODEM_UART_HANDLE.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8006a4a:	6223      	str	r3, [r4, #32]
    MODEM_UART_HANDLE.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8006a4c:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_UART_Init(&MODEM_UART_HANDLE) == HAL_OK)
 8006a4e:	4620      	mov	r0, r4
 8006a50:	f003 ffcb 	bl	800a9ea <HAL_UART_Init>
 8006a54:	4680      	mov	r8, r0
 8006a56:	2800      	cmp	r0, #0
 8006a58:	d152      	bne.n	8006b00 <enable_UART+0x1d0>
      if (MODEM_UART_HANDLE.Init.HwFlowCtl == UART_HWCONTROL_NONE)
 8006a5a:	69a3      	ldr	r3, [r4, #24]
 8006a5c:	2b00      	cmp	r3, #0
 8006a5e:	d036      	beq.n	8006ace <enable_UART+0x19e>
      if (ipc_handle != NULL)
 8006a60:	b32f      	cbz	r7, 8006aae <enable_UART+0x17e>
        PRINT_DBG("call IPC_reset")
 8006a62:	4e43      	ldr	r6, [pc, #268]	; (8006b70 <enable_UART+0x240>)
 8006a64:	4d3d      	ldr	r5, [pc, #244]	; (8006b5c <enable_UART+0x22c>)
 8006a66:	f106 0c20 	add.w	ip, r6, #32
 8006a6a:	4634      	mov	r4, r6
 8006a6c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006a6e:	6028      	str	r0, [r5, #0]
 8006a70:	6069      	str	r1, [r5, #4]
 8006a72:	60aa      	str	r2, [r5, #8]
 8006a74:	60eb      	str	r3, [r5, #12]
 8006a76:	4626      	mov	r6, r4
 8006a78:	3510      	adds	r5, #16
 8006a7a:	4564      	cmp	r4, ip
 8006a7c:	d1f5      	bne.n	8006a6a <enable_UART+0x13a>
 8006a7e:	7823      	ldrb	r3, [r4, #0]
 8006a80:	702b      	strb	r3, [r5, #0]
 8006a82:	4c36      	ldr	r4, [pc, #216]	; (8006b5c <enable_UART+0x22c>)
 8006a84:	4620      	mov	r0, r4
 8006a86:	f018 fb44 	bl	801f112 <crs_strlen>
 8006a8a:	b283      	uxth	r3, r0
 8006a8c:	4622      	mov	r2, r4
 8006a8e:	2102      	movs	r1, #2
 8006a90:	4608      	mov	r0, r1
 8006a92:	f018 fb81 	bl	801f198 <traceIF_itmPrint>
 8006a96:	4620      	mov	r0, r4
 8006a98:	f018 fb3b 	bl	801f112 <crs_strlen>
 8006a9c:	b283      	uxth	r3, r0
 8006a9e:	4622      	mov	r2, r4
 8006aa0:	2102      	movs	r1, #2
 8006aa2:	4608      	mov	r0, r1
 8006aa4:	f018 fb9a 	bl	801f1dc <traceIF_uartPrint>
        (void) IPC_reset(ipc_handle);
 8006aa8:	4638      	mov	r0, r7
 8006aaa:	f017 fc4a 	bl	801e342 <IPC_reset>
      HAL_NVIC_EnableIRQ(MODEM_UART_IRQN);
 8006aae:	2027      	movs	r0, #39	; 0x27
 8006ab0:	f000 fe2e 	bl	8007710 <HAL_NVIC_EnableIRQ>
 8006ab4:	e794      	b.n	80069e0 <enable_UART+0xb0>
    else if (hwFC_status == SYSCTRL_HW_FLOW_CONTROL_RTS_CTS)
 8006ab6:	2e01      	cmp	r6, #1
 8006ab8:	d004      	beq.n	8006ac4 <enable_UART+0x194>
      MODEM_UART_HANDLE.Init.HwFlowCtl = MODEM_UART_HWFLOWCTRL;
 8006aba:	4b29      	ldr	r3, [pc, #164]	; (8006b60 <enable_UART+0x230>)
 8006abc:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006ac0:	619a      	str	r2, [r3, #24]
 8006ac2:	e7a4      	b.n	8006a0e <enable_UART+0xde>
      MODEM_UART_HANDLE.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8006ac4:	4b26      	ldr	r3, [pc, #152]	; (8006b60 <enable_UART+0x230>)
 8006ac6:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006aca:	619a      	str	r2, [r3, #24]
 8006acc:	e79f      	b.n	8006a0e <enable_UART+0xde>
        GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006ace:	2400      	movs	r4, #0
 8006ad0:	9401      	str	r4, [sp, #4]
 8006ad2:	9402      	str	r4, [sp, #8]
 8006ad4:	9403      	str	r4, [sp, #12]
 8006ad6:	9404      	str	r4, [sp, #16]
 8006ad8:	9405      	str	r4, [sp, #20]
        GPIO_InitStruct.Pin = MODEM_CTS_PIN;
 8006ada:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006ade:	9301      	str	r3, [sp, #4]
        GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006ae0:	2503      	movs	r5, #3
 8006ae2:	9502      	str	r5, [sp, #8]
        HAL_GPIO_Init(MODEM_CTS_GPIO_PORT, &GPIO_InitStruct);
 8006ae4:	a901      	add	r1, sp, #4
 8006ae6:	4823      	ldr	r0, [pc, #140]	; (8006b74 <enable_UART+0x244>)
 8006ae8:	f000 fe7e 	bl	80077e8 <HAL_GPIO_Init>
        GPIO_InitStruct.Pin = MODEM_RTS_PIN;
 8006aec:	2304      	movs	r3, #4
 8006aee:	9301      	str	r3, [sp, #4]
        GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006af0:	9502      	str	r5, [sp, #8]
        GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006af2:	9403      	str	r4, [sp, #12]
        HAL_GPIO_Init(MODEM_RTS_GPIO_PORT, &GPIO_InitStruct);
 8006af4:	eb0d 0103 	add.w	r1, sp, r3
 8006af8:	481f      	ldr	r0, [pc, #124]	; (8006b78 <enable_UART+0x248>)
 8006afa:	f000 fe75 	bl	80077e8 <HAL_GPIO_Init>
 8006afe:	e7af      	b.n	8006a60 <enable_UART+0x130>
      PRINT_ERR("error in HAL_UART_Init")
 8006b00:	4d1e      	ldr	r5, [pc, #120]	; (8006b7c <enable_UART+0x24c>)
 8006b02:	4c16      	ldr	r4, [pc, #88]	; (8006b5c <enable_UART+0x22c>)
 8006b04:	f105 0720 	add.w	r7, r5, #32
 8006b08:	462e      	mov	r6, r5
 8006b0a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8006b0c:	6020      	str	r0, [r4, #0]
 8006b0e:	6061      	str	r1, [r4, #4]
 8006b10:	60a2      	str	r2, [r4, #8]
 8006b12:	60e3      	str	r3, [r4, #12]
 8006b14:	4635      	mov	r5, r6
 8006b16:	3410      	adds	r4, #16
 8006b18:	42be      	cmp	r6, r7
 8006b1a:	d1f5      	bne.n	8006b08 <enable_UART+0x1d8>
 8006b1c:	cd07      	ldmia	r5!, {r0, r1, r2}
 8006b1e:	6020      	str	r0, [r4, #0]
 8006b20:	6061      	str	r1, [r4, #4]
 8006b22:	60a2      	str	r2, [r4, #8]
 8006b24:	882a      	ldrh	r2, [r5, #0]
 8006b26:	78ab      	ldrb	r3, [r5, #2]
 8006b28:	81a2      	strh	r2, [r4, #12]
 8006b2a:	73a3      	strb	r3, [r4, #14]
 8006b2c:	4c0b      	ldr	r4, [pc, #44]	; (8006b5c <enable_UART+0x22c>)
 8006b2e:	4620      	mov	r0, r4
 8006b30:	f018 faef 	bl	801f112 <crs_strlen>
 8006b34:	b283      	uxth	r3, r0
 8006b36:	4622      	mov	r2, r4
 8006b38:	2110      	movs	r1, #16
 8006b3a:	2002      	movs	r0, #2
 8006b3c:	f018 fb2c 	bl	801f198 <traceIF_itmPrint>
 8006b40:	4620      	mov	r0, r4
 8006b42:	f018 fae6 	bl	801f112 <crs_strlen>
 8006b46:	b283      	uxth	r3, r0
 8006b48:	4622      	mov	r2, r4
 8006b4a:	2110      	movs	r1, #16
 8006b4c:	2002      	movs	r0, #2
 8006b4e:	f018 fb45 	bl	801f1dc <traceIF_uartPrint>
      retval = SCSTATUS_ERROR;
 8006b52:	f04f 0801 	mov.w	r8, #1
 8006b56:	e743      	b.n	80069e0 <enable_UART+0xb0>
 8006b58:	0802ced0 	.word	0x0802ced0
 8006b5c:	200048dc 	.word	0x200048dc
 8006b60:	20000d04 	.word	0x20000d04
 8006b64:	0802ccdc 	.word	0x0802ccdc
 8006b68:	40004800 	.word	0x40004800
 8006b6c:	0802cef4 	.word	0x0802cef4
 8006b70:	0802cf34 	.word	0x0802cf34
 8006b74:	48000400 	.word	0x48000400
 8006b78:	48000c00 	.word	0x48000c00
 8006b7c:	0802cf58 	.word	0x0802cf58

08006b80 <SysCtrl_TYPE1SC_open_channel>:
{
 8006b80:	b530      	push	{r4, r5, lr}
 8006b82:	b087      	sub	sp, #28
  PRINT_DBG("enter SysCtrl_TYPE1SC_open_channel")
 8006b84:	4d27      	ldr	r5, [pc, #156]	; (8006c24 <SysCtrl_TYPE1SC_open_channel+0xa4>)
 8006b86:	4c28      	ldr	r4, [pc, #160]	; (8006c28 <SysCtrl_TYPE1SC_open_channel+0xa8>)
 8006b88:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8006b8c:	46ac      	mov	ip, r5
 8006b8e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006b92:	6020      	str	r0, [r4, #0]
 8006b94:	6061      	str	r1, [r4, #4]
 8006b96:	60a2      	str	r2, [r4, #8]
 8006b98:	60e3      	str	r3, [r4, #12]
 8006b9a:	4665      	mov	r5, ip
 8006b9c:	3410      	adds	r4, #16
 8006b9e:	45f4      	cmp	ip, lr
 8006ba0:	d1f4      	bne.n	8006b8c <SysCtrl_TYPE1SC_open_channel+0xc>
 8006ba2:	f8dc 0000 	ldr.w	r0, [ip]
 8006ba6:	6020      	str	r0, [r4, #0]
 8006ba8:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8006bac:	7123      	strb	r3, [r4, #4]
 8006bae:	4c1e      	ldr	r4, [pc, #120]	; (8006c28 <SysCtrl_TYPE1SC_open_channel+0xa8>)
 8006bb0:	4620      	mov	r0, r4
 8006bb2:	f018 faae 	bl	801f112 <crs_strlen>
 8006bb6:	b283      	uxth	r3, r0
 8006bb8:	4622      	mov	r2, r4
 8006bba:	2102      	movs	r1, #2
 8006bbc:	4608      	mov	r0, r1
 8006bbe:	f018 faeb 	bl	801f198 <traceIF_itmPrint>
 8006bc2:	4620      	mov	r0, r4
 8006bc4:	f018 faa5 	bl	801f112 <crs_strlen>
 8006bc8:	b283      	uxth	r3, r0
 8006bca:	4622      	mov	r2, r4
 8006bcc:	2102      	movs	r1, #2
 8006bce:	4608      	mov	r0, r1
 8006bd0:	f018 fb04 	bl	801f1dc <traceIF_uartPrint>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006bd4:	2400      	movs	r4, #0
 8006bd6:	9401      	str	r4, [sp, #4]
 8006bd8:	9402      	str	r4, [sp, #8]
 8006bda:	9403      	str	r4, [sp, #12]
 8006bdc:	9404      	str	r4, [sp, #16]
 8006bde:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 8006be0:	2320      	movs	r3, #32
 8006be2:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8006be4:	2302      	movs	r3, #2
 8006be6:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 8006be8:	4d10      	ldr	r5, [pc, #64]	; (8006c2c <SysCtrl_TYPE1SC_open_channel+0xac>)
 8006bea:	a901      	add	r1, sp, #4
 8006bec:	4628      	mov	r0, r5
 8006bee:	f000 fdfb 	bl	80077e8 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_SET);
 8006bf2:	2201      	movs	r2, #1
 8006bf4:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006bf8:	4628      	mov	r0, r5
 8006bfa:	f000 ff54 	bl	8007aa6 <HAL_GPIO_WritePin>
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006bfe:	2120      	movs	r1, #32
 8006c00:	480a      	ldr	r0, [pc, #40]	; (8006c2c <SysCtrl_TYPE1SC_open_channel+0xac>)
 8006c02:	f000 ff49 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006c06:	b938      	cbnz	r0, 8006c18 <SysCtrl_TYPE1SC_open_channel+0x98>
 8006c08:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 8006c0c:	d204      	bcs.n	8006c18 <SysCtrl_TYPE1SC_open_channel+0x98>
    SysCtrl_delay(count_delay);
 8006c0e:	200a      	movs	r0, #10
 8006c10:	f00e fa44 	bl	801509c <SysCtrl_delay>
    count++;
 8006c14:	3401      	adds	r4, #1
 8006c16:	e7f2      	b.n	8006bfe <SysCtrl_TYPE1SC_open_channel+0x7e>
  retval = enable_UART(NULL, SYSCTRL_HW_FLOW_CONTROL_USER_SETTING);
 8006c18:	2102      	movs	r1, #2
 8006c1a:	2000      	movs	r0, #0
 8006c1c:	f7ff fe88 	bl	8006930 <enable_UART>
}
 8006c20:	b007      	add	sp, #28
 8006c22:	bd30      	pop	{r4, r5, pc}
 8006c24:	0802cf88 	.word	0x0802cf88
 8006c28:	200048dc 	.word	0x200048dc
 8006c2c:	48000800 	.word	0x48000800

08006c30 <HIFC_A_modem_resume>:
{
 8006c30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006c34:	b086      	sub	sp, #24
 8006c36:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006c38:	2400      	movs	r4, #0
 8006c3a:	9401      	str	r4, [sp, #4]
 8006c3c:	9402      	str	r4, [sp, #8]
 8006c3e:	9403      	str	r4, [sp, #12]
 8006c40:	9404      	str	r4, [sp, #16]
 8006c42:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_TX_PIN;
 8006c44:	2710      	movs	r7, #16
 8006c46:	9701      	str	r7, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006c48:	f04f 0801 	mov.w	r8, #1
 8006c4c:	f8cd 8008 	str.w	r8, [sp, #8]
  HAL_GPIO_Init(MODEM_TX_GPIO_PORT, &GPIO_InitStruct);
 8006c50:	4e14      	ldr	r6, [pc, #80]	; (8006ca4 <HIFC_A_modem_resume+0x74>)
 8006c52:	a901      	add	r1, sp, #4
 8006c54:	4630      	mov	r0, r6
 8006c56:	f000 fdc7 	bl	80077e8 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(MODEM_TX_GPIO_PORT, MODEM_TX_PIN, GPIO_PIN_SET);
 8006c5a:	4642      	mov	r2, r8
 8006c5c:	4639      	mov	r1, r7
 8006c5e:	4630      	mov	r0, r6
 8006c60:	f000 ff21 	bl	8007aa6 <HAL_GPIO_WritePin>
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006c64:	2120      	movs	r1, #32
 8006c66:	480f      	ldr	r0, [pc, #60]	; (8006ca4 <HIFC_A_modem_resume+0x74>)
 8006c68:	f000 ff16 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006c6c:	b938      	cbnz	r0, 8006c7e <HIFC_A_modem_resume+0x4e>
 8006c6e:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 8006c72:	d204      	bcs.n	8006c7e <HIFC_A_modem_resume+0x4e>
    SysCtrl_delay(count_delay);
 8006c74:	200a      	movs	r0, #10
 8006c76:	f00e fa11 	bl	801509c <SysCtrl_delay>
    count++;
 8006c7a:	3401      	adds	r4, #1
 8006c7c:	e7f2      	b.n	8006c64 <HIFC_A_modem_resume+0x34>
  retval = enable_UART(ipc_handle, SYSCTRL_HW_FLOW_CONTROL_USER_SETTING);
 8006c7e:	2102      	movs	r1, #2
 8006c80:	4628      	mov	r0, r5
 8006c82:	f7ff fe55 	bl	8006930 <enable_UART>
 8006c86:	4604      	mov	r4, r0
  SysCtrl_delay(1000U);
 8006c88:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006c8c:	f00e fa06 	bl	801509c <SysCtrl_delay>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_SET);
 8006c90:	2201      	movs	r2, #1
 8006c92:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006c96:	4803      	ldr	r0, [pc, #12]	; (8006ca4 <HIFC_A_modem_resume+0x74>)
 8006c98:	f000 ff05 	bl	8007aa6 <HAL_GPIO_WritePin>
}
 8006c9c:	4620      	mov	r0, r4
 8006c9e:	b006      	add	sp, #24
 8006ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006ca4:	48000800 	.word	0x48000800

08006ca8 <HIFC_A_host_resume>:
{
 8006ca8:	b538      	push	{r3, r4, r5, lr}
 8006caa:	4605      	mov	r5, r0
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_SET);
 8006cac:	2201      	movs	r2, #1
 8006cae:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006cb2:	4814      	ldr	r0, [pc, #80]	; (8006d04 <HIFC_A_host_resume+0x5c>)
 8006cb4:	f000 fef7 	bl	8007aa6 <HAL_GPIO_WritePin>
  uint32_t count = 0U;
 8006cb8:	2400      	movs	r4, #0
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006cba:	e003      	b.n	8006cc4 <HIFC_A_host_resume+0x1c>
    SysCtrl_delay(count_delay);
 8006cbc:	200a      	movs	r0, #10
 8006cbe:	f00e f9ed 	bl	801509c <SysCtrl_delay>
    count++;
 8006cc2:	3401      	adds	r4, #1
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006cc4:	2120      	movs	r1, #32
 8006cc6:	480f      	ldr	r0, [pc, #60]	; (8006d04 <HIFC_A_host_resume+0x5c>)
 8006cc8:	f000 fee6 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006ccc:	b910      	cbnz	r0, 8006cd4 <HIFC_A_host_resume+0x2c>
 8006cce:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
 8006cd2:	d3f3      	bcc.n	8006cbc <HIFC_A_host_resume+0x14>
  retval = enable_UART(ipc_handle, SYSCTRL_HW_FLOW_CONTROL_USER_SETTING);
 8006cd4:	2102      	movs	r1, #2
 8006cd6:	4628      	mov	r0, r5
 8006cd8:	f7ff fe2a 	bl	8006930 <enable_UART>
 8006cdc:	4605      	mov	r5, r0
  count = 0U;
 8006cde:	2400      	movs	r4, #0
  while ((HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN) == GPIO_PIN_RESET) &&
 8006ce0:	e003      	b.n	8006cea <HIFC_A_host_resume+0x42>
    SysCtrl_delay(count_delay);
 8006ce2:	200a      	movs	r0, #10
 8006ce4:	f00e f9da 	bl	801509c <SysCtrl_delay>
    count++;
 8006ce8:	3401      	adds	r4, #1
  while ((HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN) == GPIO_PIN_RESET) &&
 8006cea:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8006cee:	4806      	ldr	r0, [pc, #24]	; (8006d08 <HIFC_A_host_resume+0x60>)
 8006cf0:	f000 fed2 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006cf4:	b918      	cbnz	r0, 8006cfe <HIFC_A_host_resume+0x56>
 8006cf6:	f240 53db 	movw	r3, #1499	; 0x5db
 8006cfa:	429c      	cmp	r4, r3
 8006cfc:	d9f1      	bls.n	8006ce2 <HIFC_A_host_resume+0x3a>
}
 8006cfe:	4628      	mov	r0, r5
 8006d00:	bd38      	pop	{r3, r4, r5, pc}
 8006d02:	bf00      	nop
 8006d04:	48000800 	.word	0x48000800
 8006d08:	48000400 	.word	0x48000400

08006d0c <SysCtrl_TYPE1SC_resume_channel>:
{
 8006d0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006d0e:	b087      	sub	sp, #28
 8006d10:	4606      	mov	r6, r0
 8006d12:	4617      	mov	r7, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006d14:	2300      	movs	r3, #0
 8006d16:	9301      	str	r3, [sp, #4]
 8006d18:	9302      	str	r3, [sp, #8]
 8006d1a:	9303      	str	r3, [sp, #12]
 8006d1c:	9304      	str	r3, [sp, #16]
 8006d1e:	9305      	str	r3, [sp, #20]
  PRINT_DBG("enter SysCtrl_TYPE1SC_resume_channel")
 8006d20:	4d5a      	ldr	r5, [pc, #360]	; (8006e8c <SysCtrl_TYPE1SC_resume_channel+0x180>)
 8006d22:	4c5b      	ldr	r4, [pc, #364]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006d24:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8006d28:	46ac      	mov	ip, r5
 8006d2a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006d2e:	6020      	str	r0, [r4, #0]
 8006d30:	6061      	str	r1, [r4, #4]
 8006d32:	60a2      	str	r2, [r4, #8]
 8006d34:	60e3      	str	r3, [r4, #12]
 8006d36:	4665      	mov	r5, ip
 8006d38:	3410      	adds	r4, #16
 8006d3a:	45f4      	cmp	ip, lr
 8006d3c:	d1f4      	bne.n	8006d28 <SysCtrl_TYPE1SC_resume_channel+0x1c>
 8006d3e:	f8dc 0000 	ldr.w	r0, [ip]
 8006d42:	6020      	str	r0, [r4, #0]
 8006d44:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8006d48:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8006d4c:	80a2      	strh	r2, [r4, #4]
 8006d4e:	71a3      	strb	r3, [r4, #6]
 8006d50:	4c4f      	ldr	r4, [pc, #316]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006d52:	4620      	mov	r0, r4
 8006d54:	f018 f9dd 	bl	801f112 <crs_strlen>
 8006d58:	b283      	uxth	r3, r0
 8006d5a:	4622      	mov	r2, r4
 8006d5c:	2102      	movs	r1, #2
 8006d5e:	4608      	mov	r0, r1
 8006d60:	f018 fa1a 	bl	801f198 <traceIF_itmPrint>
 8006d64:	4620      	mov	r0, r4
 8006d66:	f018 f9d4 	bl	801f112 <crs_strlen>
 8006d6a:	b283      	uxth	r3, r0
 8006d6c:	4622      	mov	r2, r4
 8006d6e:	2102      	movs	r1, #2
 8006d70:	4608      	mov	r0, r1
 8006d72:	f018 fa33 	bl	801f1dc <traceIF_uartPrint>
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8006d76:	2300      	movs	r3, #0
 8006d78:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8006d7a:	2302      	movs	r3, #2
 8006d7c:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 8006d7e:	2320      	movs	r3, #32
 8006d80:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 8006d82:	a901      	add	r1, sp, #4
 8006d84:	4843      	ldr	r0, [pc, #268]	; (8006e94 <SysCtrl_TYPE1SC_resume_channel+0x188>)
 8006d86:	f000 fd2f 	bl	80077e8 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 8006d8a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006d8e:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 8006d90:	a901      	add	r1, sp, #4
 8006d92:	4841      	ldr	r0, [pc, #260]	; (8006e98 <SysCtrl_TYPE1SC_resume_channel+0x18c>)
 8006d94:	f000 fd28 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_DisableIRQ(MODEM_RING_IRQN);
 8006d98:	2028      	movs	r0, #40	; 0x28
 8006d9a:	f000 fcc7 	bl	800772c <HAL_NVIC_DisableIRQ>
  if (modem_originated == 1U)
 8006d9e:	2f01      	cmp	r7, #1
 8006da0:	d051      	beq.n	8006e46 <SysCtrl_TYPE1SC_resume_channel+0x13a>
    PRINT_FORCE("<< HOST RESUME USECASE >> ")
 8006da2:	4c3b      	ldr	r4, [pc, #236]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006da4:	4d3d      	ldr	r5, [pc, #244]	; (8006e9c <SysCtrl_TYPE1SC_resume_channel+0x190>)
 8006da6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006da8:	6020      	str	r0, [r4, #0]
 8006daa:	6061      	str	r1, [r4, #4]
 8006dac:	60a2      	str	r2, [r4, #8]
 8006dae:	60e3      	str	r3, [r4, #12]
 8006db0:	cd07      	ldmia	r5!, {r0, r1, r2}
 8006db2:	6120      	str	r0, [r4, #16]
 8006db4:	6161      	str	r1, [r4, #20]
 8006db6:	61a2      	str	r2, [r4, #24]
 8006db8:	782b      	ldrb	r3, [r5, #0]
 8006dba:	7723      	strb	r3, [r4, #28]
 8006dbc:	4620      	mov	r0, r4
 8006dbe:	f018 f9a8 	bl	801f112 <crs_strlen>
 8006dc2:	b283      	uxth	r3, r0
 8006dc4:	4622      	mov	r2, r4
 8006dc6:	2101      	movs	r1, #1
 8006dc8:	2002      	movs	r0, #2
 8006dca:	f018 f9e5 	bl	801f198 <traceIF_itmPrint>
 8006dce:	4620      	mov	r0, r4
 8006dd0:	f018 f99f 	bl	801f112 <crs_strlen>
 8006dd4:	b282      	uxth	r2, r0
 8006dd6:	4621      	mov	r1, r4
 8006dd8:	2002      	movs	r0, #2
 8006dda:	f018 fa17 	bl	801f20c <traceIF_uartPrintForce>
    retval = HIFC_A_host_resume(ipc_handle);
 8006dde:	4630      	mov	r0, r6
 8006de0:	f7ff ff62 	bl	8006ca8 <HIFC_A_host_resume>
 8006de4:	4606      	mov	r6, r0
  enable_RING_wait_for_falling();
 8006de6:	f7ff faab 	bl	8006340 <enable_RING_wait_for_falling>
  SysCtrl_delay(100U);
 8006dea:	2064      	movs	r0, #100	; 0x64
 8006dec:	f00e f956 	bl	801509c <SysCtrl_delay>
  PRINT_DBG("resume channel OK ")
 8006df0:	4d2b      	ldr	r5, [pc, #172]	; (8006ea0 <SysCtrl_TYPE1SC_resume_channel+0x194>)
 8006df2:	4c27      	ldr	r4, [pc, #156]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006df4:	f105 0720 	add.w	r7, r5, #32
 8006df8:	46ac      	mov	ip, r5
 8006dfa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006dfe:	6020      	str	r0, [r4, #0]
 8006e00:	6061      	str	r1, [r4, #4]
 8006e02:	60a2      	str	r2, [r4, #8]
 8006e04:	60e3      	str	r3, [r4, #12]
 8006e06:	4665      	mov	r5, ip
 8006e08:	3410      	adds	r4, #16
 8006e0a:	45bc      	cmp	ip, r7
 8006e0c:	d1f4      	bne.n	8006df8 <SysCtrl_TYPE1SC_resume_channel+0xec>
 8006e0e:	f8dc 0000 	ldr.w	r0, [ip]
 8006e12:	6020      	str	r0, [r4, #0]
 8006e14:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8006e18:	7123      	strb	r3, [r4, #4]
 8006e1a:	4c1d      	ldr	r4, [pc, #116]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006e1c:	4620      	mov	r0, r4
 8006e1e:	f018 f978 	bl	801f112 <crs_strlen>
 8006e22:	b283      	uxth	r3, r0
 8006e24:	4622      	mov	r2, r4
 8006e26:	2102      	movs	r1, #2
 8006e28:	4608      	mov	r0, r1
 8006e2a:	f018 f9b5 	bl	801f198 <traceIF_itmPrint>
 8006e2e:	4620      	mov	r0, r4
 8006e30:	f018 f96f 	bl	801f112 <crs_strlen>
 8006e34:	b283      	uxth	r3, r0
 8006e36:	4622      	mov	r2, r4
 8006e38:	2102      	movs	r1, #2
 8006e3a:	4608      	mov	r0, r1
 8006e3c:	f018 f9ce 	bl	801f1dc <traceIF_uartPrint>
}
 8006e40:	4630      	mov	r0, r6
 8006e42:	b007      	add	sp, #28
 8006e44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINT_FORCE("<< MODEM RESUME USECASE >> ")
 8006e46:	4d17      	ldr	r5, [pc, #92]	; (8006ea4 <SysCtrl_TYPE1SC_resume_channel+0x198>)
 8006e48:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006e4a:	6020      	str	r0, [r4, #0]
 8006e4c:	6061      	str	r1, [r4, #4]
 8006e4e:	60a2      	str	r2, [r4, #8]
 8006e50:	60e3      	str	r3, [r4, #12]
 8006e52:	cd07      	ldmia	r5!, {r0, r1, r2}
 8006e54:	6120      	str	r0, [r4, #16]
 8006e56:	6161      	str	r1, [r4, #20]
 8006e58:	61a2      	str	r2, [r4, #24]
 8006e5a:	882b      	ldrh	r3, [r5, #0]
 8006e5c:	83a3      	strh	r3, [r4, #28]
 8006e5e:	4620      	mov	r0, r4
 8006e60:	f018 f957 	bl	801f112 <crs_strlen>
 8006e64:	b283      	uxth	r3, r0
 8006e66:	4622      	mov	r2, r4
 8006e68:	2101      	movs	r1, #1
 8006e6a:	2002      	movs	r0, #2
 8006e6c:	f018 f994 	bl	801f198 <traceIF_itmPrint>
 8006e70:	4620      	mov	r0, r4
 8006e72:	f018 f94e 	bl	801f112 <crs_strlen>
 8006e76:	b282      	uxth	r2, r0
 8006e78:	4621      	mov	r1, r4
 8006e7a:	2002      	movs	r0, #2
 8006e7c:	f018 f9c6 	bl	801f20c <traceIF_uartPrintForce>
    retval = HIFC_A_modem_resume(ipc_handle);
 8006e80:	4630      	mov	r0, r6
 8006e82:	f7ff fed5 	bl	8006c30 <HIFC_A_modem_resume>
 8006e86:	4606      	mov	r6, r0
 8006e88:	e7ad      	b.n	8006de6 <SysCtrl_TYPE1SC_resume_channel+0xda>
 8006e8a:	bf00      	nop
 8006e8c:	0802cfc0 	.word	0x0802cfc0
 8006e90:	200048dc 	.word	0x200048dc
 8006e94:	48000800 	.word	0x48000800
 8006e98:	48000400 	.word	0x48000400
 8006e9c:	0802d018 	.word	0x0802d018
 8006ea0:	0802d038 	.word	0x0802d038
 8006ea4:	0802cff8 	.word	0x0802cff8

08006ea8 <SysCtrl_TYPE1SC_reinit_channel>:
{
 8006ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006eaa:	4606      	mov	r6, r0
 8006eac:	460f      	mov	r7, r1
  PRINT_DBG("enter SysCtrl_TYPE1SC_reinit_channel")
 8006eae:	4d18      	ldr	r5, [pc, #96]	; (8006f10 <SysCtrl_TYPE1SC_reinit_channel+0x68>)
 8006eb0:	4c18      	ldr	r4, [pc, #96]	; (8006f14 <SysCtrl_TYPE1SC_reinit_channel+0x6c>)
 8006eb2:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8006eb6:	46ac      	mov	ip, r5
 8006eb8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006ebc:	6020      	str	r0, [r4, #0]
 8006ebe:	6061      	str	r1, [r4, #4]
 8006ec0:	60a2      	str	r2, [r4, #8]
 8006ec2:	60e3      	str	r3, [r4, #12]
 8006ec4:	4665      	mov	r5, ip
 8006ec6:	3410      	adds	r4, #16
 8006ec8:	45f4      	cmp	ip, lr
 8006eca:	d1f4      	bne.n	8006eb6 <SysCtrl_TYPE1SC_reinit_channel+0xe>
 8006ecc:	f8dc 0000 	ldr.w	r0, [ip]
 8006ed0:	6020      	str	r0, [r4, #0]
 8006ed2:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8006ed6:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8006eda:	80a2      	strh	r2, [r4, #4]
 8006edc:	71a3      	strb	r3, [r4, #6]
 8006ede:	4c0d      	ldr	r4, [pc, #52]	; (8006f14 <SysCtrl_TYPE1SC_reinit_channel+0x6c>)
 8006ee0:	4620      	mov	r0, r4
 8006ee2:	f018 f916 	bl	801f112 <crs_strlen>
 8006ee6:	b283      	uxth	r3, r0
 8006ee8:	4622      	mov	r2, r4
 8006eea:	2102      	movs	r1, #2
 8006eec:	4608      	mov	r0, r1
 8006eee:	f018 f953 	bl	801f198 <traceIF_itmPrint>
 8006ef2:	4620      	mov	r0, r4
 8006ef4:	f018 f90d 	bl	801f112 <crs_strlen>
 8006ef8:	b283      	uxth	r3, r0
 8006efa:	4622      	mov	r2, r4
 8006efc:	2102      	movs	r1, #2
 8006efe:	4608      	mov	r0, r1
 8006f00:	f018 f96c 	bl	801f1dc <traceIF_uartPrint>
  retval = enable_UART(ipc_handle, hwFC_status);
 8006f04:	4639      	mov	r1, r7
 8006f06:	4630      	mov	r0, r6
 8006f08:	f7ff fd12 	bl	8006930 <enable_UART>
}
 8006f0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006f0e:	bf00      	nop
 8006f10:	0802d060 	.word	0x0802d060
 8006f14:	200048dc 	.word	0x200048dc

08006f18 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006f18:	490f      	ldr	r1, [pc, #60]	; (8006f58 <SystemInit+0x40>)
 8006f1a:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8006f1e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8006f22:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8006f26:	4b0d      	ldr	r3, [pc, #52]	; (8006f5c <SystemInit+0x44>)
 8006f28:	681a      	ldr	r2, [r3, #0]
 8006f2a:	f042 0201 	orr.w	r2, r2, #1
 8006f2e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8006f30:	2000      	movs	r0, #0
 8006f32:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8006f34:	681a      	ldr	r2, [r3, #0]
 8006f36:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8006f3a:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8006f3e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8006f40:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8006f44:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8006f46:	681a      	ldr	r2, [r3, #0]
 8006f48:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8006f4c:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8006f4e:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006f50:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8006f54:	608b      	str	r3, [r1, #8]
#endif
}
 8006f56:	4770      	bx	lr
 8006f58:	e000ed00 	.word	0xe000ed00
 8006f5c:	40021000 	.word	0x40021000

08006f60 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8006f60:	b510      	push	{r4, lr}
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8006f62:	2003      	movs	r0, #3
 8006f64:	f000 fb8a 	bl	800767c <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8006f68:	2000      	movs	r0, #0
 8006f6a:	f7fa fbbd 	bl	80016e8 <HAL_InitTick>
 8006f6e:	b110      	cbz	r0, 8006f76 <HAL_Init+0x16>
  {
    status = HAL_ERROR;
 8006f70:	2401      	movs	r4, #1
    HAL_MspInit();
  }

  /* Return function status */
  return status;
}
 8006f72:	4620      	mov	r0, r4
 8006f74:	bd10      	pop	{r4, pc}
 8006f76:	4604      	mov	r4, r0
    HAL_MspInit();
 8006f78:	f7fa fb6e 	bl	8001658 <HAL_MspInit>
 8006f7c:	e7f9      	b.n	8006f72 <HAL_Init+0x12>
	...

08006f80 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8006f80:	4b03      	ldr	r3, [pc, #12]	; (8006f90 <HAL_IncTick+0x10>)
 8006f82:	781b      	ldrb	r3, [r3, #0]
 8006f84:	4a03      	ldr	r2, [pc, #12]	; (8006f94 <HAL_IncTick+0x14>)
 8006f86:	6811      	ldr	r1, [r2, #0]
 8006f88:	440b      	add	r3, r1
 8006f8a:	6013      	str	r3, [r2, #0]
}
 8006f8c:	4770      	bx	lr
 8006f8e:	bf00      	nop
 8006f90:	20000038 	.word	0x20000038
 8006f94:	20001880 	.word	0x20001880

08006f98 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8006f98:	4b01      	ldr	r3, [pc, #4]	; (8006fa0 <HAL_GetTick+0x8>)
 8006f9a:	6818      	ldr	r0, [r3, #0]
}
 8006f9c:	4770      	bx	lr
 8006f9e:	bf00      	nop
 8006fa0:	20001880 	.word	0x20001880

08006fa4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8006fa4:	b538      	push	{r3, r4, r5, lr}
 8006fa6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8006fa8:	f7ff fff6 	bl	8006f98 <HAL_GetTick>
 8006fac:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8006fae:	f1b4 3fff 	cmp.w	r4, #4294967295
 8006fb2:	d002      	beq.n	8006fba <HAL_Delay+0x16>
  {
    wait += (uint32_t)uwTickFreq;
 8006fb4:	4b04      	ldr	r3, [pc, #16]	; (8006fc8 <HAL_Delay+0x24>)
 8006fb6:	781b      	ldrb	r3, [r3, #0]
 8006fb8:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8006fba:	f7ff ffed 	bl	8006f98 <HAL_GetTick>
 8006fbe:	1b40      	subs	r0, r0, r5
 8006fc0:	42a0      	cmp	r0, r4
 8006fc2:	d3fa      	bcc.n	8006fba <HAL_Delay+0x16>
  {
  }
}
 8006fc4:	bd38      	pop	{r3, r4, r5, pc}
 8006fc6:	bf00      	nop
 8006fc8:	20000038 	.word	0x20000038

08006fcc <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8006fcc:	b530      	push	{r4, r5, lr}
 8006fce:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8006fd0:	2300      	movs	r3, #0
 8006fd2:	9301      	str	r3, [sp, #4]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8006fd4:	2800      	cmp	r0, #0
 8006fd6:	f000 80da 	beq.w	800718e <HAL_ADC_Init+0x1c2>
 8006fda:	4604      	mov	r4, r0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8006fdc:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8006fde:	b303      	cbz	r3, 8007022 <HAL_ADC_Init+0x56>
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8006fe0:	6823      	ldr	r3, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8006fe2:	689a      	ldr	r2, [r3, #8]
 8006fe4:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
 8006fe8:	d005      	beq.n	8006ff6 <HAL_ADC_Init+0x2a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8006fea:	689a      	ldr	r2, [r3, #8]
 8006fec:	f022 4220 	bic.w	r2, r2, #2684354560	; 0xa0000000
 8006ff0:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8006ff4:	609a      	str	r2, [r3, #8]
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8006ff6:	6822      	ldr	r2, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8006ff8:	6893      	ldr	r3, [r2, #8]
 8006ffa:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8006ffe:	d11d      	bne.n	800703c <HAL_ADC_Init+0x70>
  MODIFY_REG(ADCx->CR,
 8007000:	6893      	ldr	r3, [r2, #8]
 8007002:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8007006:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800700a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800700e:	6093      	str	r3, [r2, #8]
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8007010:	4b60      	ldr	r3, [pc, #384]	; (8007194 <HAL_ADC_Init+0x1c8>)
 8007012:	681b      	ldr	r3, [r3, #0]
 8007014:	099b      	lsrs	r3, r3, #6
 8007016:	4a60      	ldr	r2, [pc, #384]	; (8007198 <HAL_ADC_Init+0x1cc>)
 8007018:	fba2 2303 	umull	r2, r3, r2, r3
 800701c:	099b      	lsrs	r3, r3, #6
 800701e:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8007020:	e009      	b.n	8007036 <HAL_ADC_Init+0x6a>
    HAL_ADC_MspInit(hadc);
 8007022:	f7f9 ffc5 	bl	8000fb0 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8007026:	2300      	movs	r3, #0
 8007028:	65e3      	str	r3, [r4, #92]	; 0x5c
    hadc->Lock = HAL_UNLOCKED;
 800702a:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
 800702e:	e7d7      	b.n	8006fe0 <HAL_ADC_Init+0x14>
    {
      wait_loop_index--;
 8007030:	9b01      	ldr	r3, [sp, #4]
 8007032:	3b01      	subs	r3, #1
 8007034:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8007036:	9b01      	ldr	r3, [sp, #4]
 8007038:	2b00      	cmp	r3, #0
 800703a:	d1f9      	bne.n	8007030 <HAL_ADC_Init+0x64>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800703c:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 800703e:	6893      	ldr	r3, [r2, #8]
 8007040:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8007044:	d17a      	bne.n	800713c <HAL_ADC_Init+0x170>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007046:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007048:	f043 0310 	orr.w	r3, r3, #16
 800704c:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800704e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007050:	f043 0301 	orr.w	r3, r3, #1
 8007054:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 8007056:	2001      	movs	r0, #1
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8007058:	6893      	ldr	r3, [r2, #8]
 800705a:	f013 0304 	ands.w	r3, r3, #4
 800705e:	d000      	beq.n	8007062 <HAL_ADC_Init+0x96>
 8007060:	2301      	movs	r3, #1
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8007062:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8007064:	f011 0f10 	tst.w	r1, #16
 8007068:	f040 808a 	bne.w	8007180 <HAL_ADC_Init+0x1b4>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 800706c:	2b00      	cmp	r3, #0
 800706e:	f040 8087 	bne.w	8007180 <HAL_ADC_Init+0x1b4>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8007072:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007074:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8007078:	f043 0302 	orr.w	r3, r3, #2
 800707c:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800707e:	6893      	ldr	r3, [r2, #8]
 8007080:	f013 0f01 	tst.w	r3, #1
 8007084:	d10b      	bne.n	800709e <HAL_ADC_Init+0xd2>
 8007086:	4b45      	ldr	r3, [pc, #276]	; (800719c <HAL_ADC_Init+0x1d0>)
 8007088:	689b      	ldr	r3, [r3, #8]
 800708a:	f013 0f01 	tst.w	r3, #1
 800708e:	d106      	bne.n	800709e <HAL_ADC_Init+0xd2>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8007090:	6863      	ldr	r3, [r4, #4]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8007092:	4943      	ldr	r1, [pc, #268]	; (80071a0 <HAL_ADC_Init+0x1d4>)
 8007094:	688a      	ldr	r2, [r1, #8]
 8007096:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 800709a:	4313      	orrs	r3, r2
 800709c:	608b      	str	r3, [r1, #8]
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800709e:	7e62      	ldrb	r2, [r4, #25]
                hadc->Init.Overrun                                                     |
 80070a0:	6b63      	ldr	r3, [r4, #52]	; 0x34
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80070a2:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
                hadc->Init.DataAlign                                                   |
 80070a6:	68e2      	ldr	r2, [r4, #12]
                hadc->Init.Overrun                                                     |
 80070a8:	4313      	orrs	r3, r2
                hadc->Init.Resolution                                                  |
 80070aa:	68a2      	ldr	r2, [r4, #8]
                hadc->Init.DataAlign                                                   |
 80070ac:	4313      	orrs	r3, r2
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 80070ae:	f894 2020 	ldrb.w	r2, [r4, #32]
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80070b2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80070b6:	2a01      	cmp	r2, #1
 80070b8:	d042      	beq.n	8007140 <HAL_ADC_Init+0x174>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80070ba:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80070bc:	b122      	cbz	r2, 80070c8 <HAL_ADC_Init+0xfc>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80070be:	f402 7270 	and.w	r2, r2, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 80070c2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80070c4:	430a      	orrs	r2, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80070c6:	4313      	orrs	r3, r2
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 80070c8:	6821      	ldr	r1, [r4, #0]
 80070ca:	68cd      	ldr	r5, [r1, #12]
 80070cc:	4a35      	ldr	r2, [pc, #212]	; (80071a4 <HAL_ADC_Init+0x1d8>)
 80070ce:	402a      	ands	r2, r5
 80070d0:	431a      	orrs	r2, r3
 80070d2:	60ca      	str	r2, [r1, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80070d4:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80070d6:	688b      	ldr	r3, [r1, #8]
 80070d8:	f013 0304 	ands.w	r3, r3, #4
 80070dc:	d000      	beq.n	80070e0 <HAL_ADC_Init+0x114>
 80070de:	2301      	movs	r3, #1
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80070e0:	688a      	ldr	r2, [r1, #8]
 80070e2:	f012 0208 	ands.w	r2, r2, #8
 80070e6:	d000      	beq.n	80070ea <HAL_ADC_Init+0x11e>
 80070e8:	2201      	movs	r2, #1
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 80070ea:	b9c3      	cbnz	r3, 800711e <HAL_ADC_Init+0x152>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 80070ec:	b9ba      	cbnz	r2, 800711e <HAL_ADC_Init+0x152>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80070ee:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80070f0:	7e22      	ldrb	r2, [r4, #24]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80070f2:	ea43 3382 	orr.w	r3, r3, r2, lsl #14
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80070f6:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80070fa:	ea43 0242 	orr.w	r2, r3, r2, lsl #1

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80070fe:	68cb      	ldr	r3, [r1, #12]
 8007100:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007104:	f023 0306 	bic.w	r3, r3, #6
 8007108:	4313      	orrs	r3, r2
 800710a:	60cb      	str	r3, [r1, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 800710c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8007110:	2b01      	cmp	r3, #1
 8007112:	d01a      	beq.n	800714a <HAL_ADC_Init+0x17e>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8007114:	6822      	ldr	r2, [r4, #0]
 8007116:	6913      	ldr	r3, [r2, #16]
 8007118:	f023 0301 	bic.w	r3, r3, #1
 800711c:	6113      	str	r3, [r2, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800711e:	6923      	ldr	r3, [r4, #16]
 8007120:	2b01      	cmp	r3, #1
 8007122:	d024      	beq.n	800716e <HAL_ADC_Init+0x1a2>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8007124:	6822      	ldr	r2, [r4, #0]
 8007126:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8007128:	f023 030f 	bic.w	r3, r3, #15
 800712c:	6313      	str	r3, [r2, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800712e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007130:	f023 0303 	bic.w	r3, r3, #3
 8007134:	f043 0301 	orr.w	r3, r3, #1
 8007138:	65a3      	str	r3, [r4, #88]	; 0x58
 800713a:	e026      	b.n	800718a <HAL_ADC_Init+0x1be>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800713c:	2000      	movs	r0, #0
 800713e:	e78b      	b.n	8007058 <HAL_ADC_Init+0x8c>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8007140:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8007142:	3a01      	subs	r2, #1
 8007144:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 8007148:	e7b7      	b.n	80070ba <HAL_ADC_Init+0xee>
        MODIFY_REG(hadc->Instance->CFGR2,
 800714a:	6821      	ldr	r1, [r4, #0]
 800714c:	690b      	ldr	r3, [r1, #16]
 800714e:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8007152:	f023 0304 	bic.w	r3, r3, #4
 8007156:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8007158:	6c25      	ldr	r5, [r4, #64]	; 0x40
 800715a:	432a      	orrs	r2, r5
 800715c:	6c65      	ldr	r5, [r4, #68]	; 0x44
 800715e:	432a      	orrs	r2, r5
 8007160:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8007162:	432a      	orrs	r2, r5
 8007164:	4313      	orrs	r3, r2
 8007166:	f043 0301 	orr.w	r3, r3, #1
 800716a:	610b      	str	r3, [r1, #16]
 800716c:	e7d7      	b.n	800711e <HAL_ADC_Init+0x152>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800716e:	6821      	ldr	r1, [r4, #0]
 8007170:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8007172:	f023 030f 	bic.w	r3, r3, #15
 8007176:	69e2      	ldr	r2, [r4, #28]
 8007178:	3a01      	subs	r2, #1
 800717a:	4313      	orrs	r3, r2
 800717c:	630b      	str	r3, [r1, #48]	; 0x30
 800717e:	e7d6      	b.n	800712e <HAL_ADC_Init+0x162>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007180:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007182:	f043 0310 	orr.w	r3, r3, #16
 8007186:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8007188:	2001      	movs	r0, #1
  }

  /* Return function status */
  return tmp_hal_status;
}
 800718a:	b003      	add	sp, #12
 800718c:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 800718e:	2001      	movs	r0, #1
 8007190:	e7fb      	b.n	800718a <HAL_ADC_Init+0x1be>
 8007192:	bf00      	nop
 8007194:	20000034 	.word	0x20000034
 8007198:	053e2d63 	.word	0x053e2d63
 800719c:	50040000 	.word	0x50040000
 80071a0:	50040300 	.word	0x50040300
 80071a4:	fff0c007 	.word	0xfff0c007

080071a8 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 80071a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80071aa:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 80071ac:	2200      	movs	r2, #0
 80071ae:	9201      	str	r2, [sp, #4]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80071b0:	f890 2054 	ldrb.w	r2, [r0, #84]	; 0x54
 80071b4:	2a01      	cmp	r2, #1
 80071b6:	f000 8256 	beq.w	8007666 <HAL_ADC_ConfigChannel+0x4be>
 80071ba:	4603      	mov	r3, r0
 80071bc:	2201      	movs	r2, #1
 80071be:	f880 2054 	strb.w	r2, [r0, #84]	; 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80071c2:	6802      	ldr	r2, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80071c4:	6892      	ldr	r2, [r2, #8]
 80071c6:	f012 0f04 	tst.w	r2, #4
 80071ca:	d009      	beq.n	80071e0 <HAL_ADC_ConfigChannel+0x38>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80071cc:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80071ce:	f042 0220 	orr.w	r2, r2, #32
 80071d2:	6582      	str	r2, [r0, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 80071d4:	2001      	movs	r0, #1
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80071d6:	2200      	movs	r2, #0
 80071d8:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
}
 80071dc:	b003      	add	sp, #12
 80071de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (sConfig->Rank <= 5U)
 80071e0:	684a      	ldr	r2, [r1, #4]
 80071e2:	2a05      	cmp	r2, #5
 80071e4:	d809      	bhi.n	80071fa <HAL_ADC_ConfigChannel+0x52>
      switch (sConfig->Rank)
 80071e6:	3a02      	subs	r2, #2
 80071e8:	2a03      	cmp	r2, #3
 80071ea:	f200 809d 	bhi.w	8007328 <HAL_ADC_ConfigChannel+0x180>
 80071ee:	e8df f002 	tbb	[pc, r2]
 80071f2:	9102      	.short	0x9102
 80071f4:	9794      	.short	0x9794
          sConfig->Rank = ADC_REGULAR_RANK_2;
 80071f6:	220c      	movs	r2, #12
 80071f8:	604a      	str	r2, [r1, #4]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 80071fa:	681d      	ldr	r5, [r3, #0]
 80071fc:	684c      	ldr	r4, [r1, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80071fe:	3530      	adds	r5, #48	; 0x30
 8007200:	0a22      	lsrs	r2, r4, #8
 8007202:	0092      	lsls	r2, r2, #2
 8007204:	f002 020c 	and.w	r2, r2, #12
  MODIFY_REG(*preg,
 8007208:	58a8      	ldr	r0, [r5, r2]
 800720a:	f004 0e1f 	and.w	lr, r4, #31
 800720e:	241f      	movs	r4, #31
 8007210:	fa04 f40e 	lsl.w	r4, r4, lr
 8007214:	ea20 0004 	bic.w	r0, r0, r4
 8007218:	680c      	ldr	r4, [r1, #0]
 800721a:	f3c4 6c84 	ubfx	ip, r4, #26, #5
 800721e:	fa0c fc0e 	lsl.w	ip, ip, lr
 8007222:	ea40 000c 	orr.w	r0, r0, ip
 8007226:	50a8      	str	r0, [r5, r2]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8007228:	681c      	ldr	r4, [r3, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800722a:	68a2      	ldr	r2, [r4, #8]
 800722c:	f012 0204 	ands.w	r2, r2, #4
 8007230:	d000      	beq.n	8007234 <HAL_ADC_ConfigChannel+0x8c>
 8007232:	2201      	movs	r2, #1
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8007234:	68a0      	ldr	r0, [r4, #8]
 8007236:	f010 0008 	ands.w	r0, r0, #8
 800723a:	d000      	beq.n	800723e <HAL_ADC_ConfigChannel+0x96>
 800723c:	2001      	movs	r0, #1
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800723e:	2a00      	cmp	r2, #0
 8007240:	d134      	bne.n	80072ac <HAL_ADC_ConfigChannel+0x104>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8007242:	2800      	cmp	r0, #0
 8007244:	d132      	bne.n	80072ac <HAL_ADC_ConfigChannel+0x104>
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8007246:	6888      	ldr	r0, [r1, #8]
 8007248:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
 800724c:	d06f      	beq.n	800732e <HAL_ADC_ConfigChannel+0x186>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800724e:	680e      	ldr	r6, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8007250:	3414      	adds	r4, #20
 8007252:	0e72      	lsrs	r2, r6, #25
 8007254:	0092      	lsls	r2, r2, #2
 8007256:	f002 0204 	and.w	r2, r2, #4
  MODIFY_REG(*preg,
 800725a:	58a5      	ldr	r5, [r4, r2]
 800725c:	f3c6 5c04 	ubfx	ip, r6, #20, #5
 8007260:	2607      	movs	r6, #7
 8007262:	fa06 f60c 	lsl.w	r6, r6, ip
 8007266:	ea25 0506 	bic.w	r5, r5, r6
 800726a:	fa00 f00c 	lsl.w	r0, r0, ip
 800726e:	4328      	orrs	r0, r5
 8007270:	50a0      	str	r0, [r4, r2]
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 8007272:	6818      	ldr	r0, [r3, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8007274:	6942      	ldr	r2, [r0, #20]
 8007276:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800727a:	6142      	str	r2, [r0, #20]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800727c:	694c      	ldr	r4, [r1, #20]
 800727e:	6818      	ldr	r0, [r3, #0]
 8007280:	68c2      	ldr	r2, [r0, #12]
 8007282:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 8007286:	0052      	lsls	r2, r2, #1
 8007288:	4094      	lsls	r4, r2
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800728a:	690d      	ldr	r5, [r1, #16]
 800728c:	2d04      	cmp	r5, #4
 800728e:	d063      	beq.n	8007358 <HAL_ADC_ConfigChannel+0x1b0>
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8007290:	680e      	ldr	r6, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8007292:	3060      	adds	r0, #96	; 0x60
  MODIFY_REG(*preg,
 8007294:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
 8007298:	4aac      	ldr	r2, [pc, #688]	; (800754c <HAL_ADC_ConfigChannel+0x3a4>)
 800729a:	403a      	ands	r2, r7
 800729c:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 80072a0:	4334      	orrs	r4, r6
 80072a2:	4322      	orrs	r2, r4
 80072a4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80072a8:	f840 2025 	str.w	r2, [r0, r5, lsl #2]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80072ac:	6818      	ldr	r0, [r3, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80072ae:	6882      	ldr	r2, [r0, #8]
 80072b0:	f012 0f01 	tst.w	r2, #1
 80072b4:	d117      	bne.n	80072e6 <HAL_ADC_ConfigChannel+0x13e>
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 80072b6:	680a      	ldr	r2, [r1, #0]
 80072b8:	68cd      	ldr	r5, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 80072ba:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 80072be:	f3c2 0c12 	ubfx	ip, r2, #0, #19
 80072c2:	ea24 040c 	bic.w	r4, r4, ip
 80072c6:	f005 0c18 	and.w	ip, r5, #24
 80072ca:	4da1      	ldr	r5, [pc, #644]	; (8007550 <HAL_ADC_ConfigChannel+0x3a8>)
 80072cc:	fa25 f50c 	lsr.w	r5, r5, ip
 80072d0:	402a      	ands	r2, r5
 80072d2:	f3c2 0212 	ubfx	r2, r2, #0, #19
 80072d6:	4322      	orrs	r2, r4
 80072d8:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 80072dc:	68c8      	ldr	r0, [r1, #12]
 80072de:	4a9d      	ldr	r2, [pc, #628]	; (8007554 <HAL_ADC_ConfigChannel+0x3ac>)
 80072e0:	4290      	cmp	r0, r2
 80072e2:	f000 80a1 	beq.w	8007428 <HAL_ADC_ConfigChannel+0x280>
    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80072e6:	680a      	ldr	r2, [r1, #0]
 80072e8:	499b      	ldr	r1, [pc, #620]	; (8007558 <HAL_ADC_ConfigChannel+0x3b0>)
 80072ea:	420a      	tst	r2, r1
 80072ec:	f000 81b7 	beq.w	800765e <HAL_ADC_ConfigChannel+0x4b6>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80072f0:	499a      	ldr	r1, [pc, #616]	; (800755c <HAL_ADC_ConfigChannel+0x3b4>)
 80072f2:	6889      	ldr	r1, [r1, #8]
 80072f4:	f001 74e0 	and.w	r4, r1, #29360128	; 0x1c00000
      if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80072f8:	4899      	ldr	r0, [pc, #612]	; (8007560 <HAL_ADC_ConfigChannel+0x3b8>)
 80072fa:	4282      	cmp	r2, r0
 80072fc:	f000 8162 	beq.w	80075c4 <HAL_ADC_ConfigChannel+0x41c>
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8007300:	4898      	ldr	r0, [pc, #608]	; (8007564 <HAL_ADC_ConfigChannel+0x3bc>)
 8007302:	4282      	cmp	r2, r0
 8007304:	f000 8184 	beq.w	8007610 <HAL_ADC_ConfigChannel+0x468>
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
 8007308:	4897      	ldr	r0, [pc, #604]	; (8007568 <HAL_ADC_ConfigChannel+0x3c0>)
 800730a:	4282      	cmp	r2, r0
 800730c:	f000 8194 	beq.w	8007638 <HAL_ADC_ConfigChannel+0x490>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007310:	2000      	movs	r0, #0
 8007312:	e760      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          sConfig->Rank = ADC_REGULAR_RANK_3;
 8007314:	2212      	movs	r2, #18
 8007316:	604a      	str	r2, [r1, #4]
          break;
 8007318:	e76f      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
          sConfig->Rank = ADC_REGULAR_RANK_4;
 800731a:	2218      	movs	r2, #24
 800731c:	604a      	str	r2, [r1, #4]
          break;
 800731e:	e76c      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
          sConfig->Rank = ADC_REGULAR_RANK_5;
 8007320:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007324:	604a      	str	r2, [r1, #4]
          break;
 8007326:	e768      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
          sConfig->Rank = ADC_REGULAR_RANK_1;
 8007328:	2206      	movs	r2, #6
 800732a:	604a      	str	r2, [r1, #4]
          break;
 800732c:	e765      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 800732e:	6808      	ldr	r0, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8007330:	3414      	adds	r4, #20
 8007332:	0e42      	lsrs	r2, r0, #25
 8007334:	0092      	lsls	r2, r2, #2
 8007336:	f002 0204 	and.w	r2, r2, #4
  MODIFY_REG(*preg,
 800733a:	58a5      	ldr	r5, [r4, r2]
 800733c:	f3c0 5004 	ubfx	r0, r0, #20, #5
 8007340:	2607      	movs	r6, #7
 8007342:	fa06 f000 	lsl.w	r0, r6, r0
 8007346:	ea25 0000 	bic.w	r0, r5, r0
 800734a:	50a0      	str	r0, [r4, r2]
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 800734c:	6818      	ldr	r0, [r3, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 800734e:	6942      	ldr	r2, [r0, #20]
 8007350:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8007354:	6142      	str	r2, [r0, #20]
}
 8007356:	e791      	b.n	800727c <HAL_ADC_ConfigChannel+0xd4>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8007358:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800735a:	6e04      	ldr	r4, [r0, #96]	; 0x60
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800735c:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8007360:	680a      	ldr	r2, [r1, #0]
 8007362:	f3c2 0512 	ubfx	r5, r2, #0, #19
 8007366:	bb85      	cbnz	r5, 80073ca <HAL_ADC_ConfigChannel+0x222>
 8007368:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800736c:	4294      	cmp	r4, r2
 800736e:	d034      	beq.n	80073da <HAL_ADC_ConfigChannel+0x232>
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8007370:	681c      	ldr	r4, [r3, #0]
 8007372:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8007374:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8007376:	f3c0 6084 	ubfx	r0, r0, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800737a:	680a      	ldr	r2, [r1, #0]
 800737c:	f3c2 0512 	ubfx	r5, r2, #0, #19
 8007380:	bb85      	cbnz	r5, 80073e4 <HAL_ADC_ConfigChannel+0x23c>
 8007382:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8007386:	4290      	cmp	r0, r2
 8007388:	d034      	beq.n	80073f4 <HAL_ADC_ConfigChannel+0x24c>
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800738a:	681c      	ldr	r4, [r3, #0]
 800738c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 800738e:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8007390:	f3c0 6084 	ubfx	r0, r0, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8007394:	680a      	ldr	r2, [r1, #0]
 8007396:	f3c2 0512 	ubfx	r5, r2, #0, #19
 800739a:	bb85      	cbnz	r5, 80073fe <HAL_ADC_ConfigChannel+0x256>
 800739c:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80073a0:	4290      	cmp	r0, r2
 80073a2:	d034      	beq.n	800740e <HAL_ADC_ConfigChannel+0x266>
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80073a4:	681c      	ldr	r4, [r3, #0]
 80073a6:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80073a8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80073aa:	f3c0 6084 	ubfx	r0, r0, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80073ae:	680a      	ldr	r2, [r1, #0]
 80073b0:	f3c2 0512 	ubfx	r5, r2, #0, #19
 80073b4:	bb85      	cbnz	r5, 8007418 <HAL_ADC_ConfigChannel+0x270>
 80073b6:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80073ba:	4290      	cmp	r0, r2
 80073bc:	f47f af76 	bne.w	80072ac <HAL_ADC_ConfigChannel+0x104>
  MODIFY_REG(*preg,
 80073c0:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80073c2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80073c6:	66e2      	str	r2, [r4, #108]	; 0x6c
}
 80073c8:	e770      	b.n	80072ac <HAL_ADC_ConfigChannel+0x104>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80073ca:	fa92 f2a2 	rbit	r2, r2
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 80073ce:	b112      	cbz	r2, 80073d6 <HAL_ADC_ConfigChannel+0x22e>
  {
    return 32U;
  }
  return __builtin_clz(value);
 80073d0:	fab2 f282 	clz	r2, r2
 80073d4:	e7ca      	b.n	800736c <HAL_ADC_ConfigChannel+0x1c4>
    return 32U;
 80073d6:	2220      	movs	r2, #32
 80073d8:	e7c8      	b.n	800736c <HAL_ADC_ConfigChannel+0x1c4>
  MODIFY_REG(*preg,
 80073da:	6e02      	ldr	r2, [r0, #96]	; 0x60
 80073dc:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80073e0:	6602      	str	r2, [r0, #96]	; 0x60
}
 80073e2:	e7c5      	b.n	8007370 <HAL_ADC_ConfigChannel+0x1c8>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80073e4:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 80073e8:	b112      	cbz	r2, 80073f0 <HAL_ADC_ConfigChannel+0x248>
  return __builtin_clz(value);
 80073ea:	fab2 f282 	clz	r2, r2
 80073ee:	e7ca      	b.n	8007386 <HAL_ADC_ConfigChannel+0x1de>
    return 32U;
 80073f0:	2220      	movs	r2, #32
 80073f2:	e7c8      	b.n	8007386 <HAL_ADC_ConfigChannel+0x1de>
  MODIFY_REG(*preg,
 80073f4:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80073f6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80073fa:	6662      	str	r2, [r4, #100]	; 0x64
}
 80073fc:	e7c5      	b.n	800738a <HAL_ADC_ConfigChannel+0x1e2>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80073fe:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 8007402:	b112      	cbz	r2, 800740a <HAL_ADC_ConfigChannel+0x262>
  return __builtin_clz(value);
 8007404:	fab2 f282 	clz	r2, r2
 8007408:	e7ca      	b.n	80073a0 <HAL_ADC_ConfigChannel+0x1f8>
    return 32U;
 800740a:	2220      	movs	r2, #32
 800740c:	e7c8      	b.n	80073a0 <HAL_ADC_ConfigChannel+0x1f8>
  MODIFY_REG(*preg,
 800740e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8007410:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8007414:	66a2      	str	r2, [r4, #104]	; 0x68
}
 8007416:	e7c5      	b.n	80073a4 <HAL_ADC_ConfigChannel+0x1fc>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007418:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 800741c:	b112      	cbz	r2, 8007424 <HAL_ADC_ConfigChannel+0x27c>
  return __builtin_clz(value);
 800741e:	fab2 f282 	clz	r2, r2
 8007422:	e7ca      	b.n	80073ba <HAL_ADC_ConfigChannel+0x212>
    return 32U;
 8007424:	2220      	movs	r2, #32
 8007426:	e7c8      	b.n	80073ba <HAL_ADC_ConfigChannel+0x212>
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007428:	681c      	ldr	r4, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800742a:	680a      	ldr	r2, [r1, #0]
 800742c:	f3c2 0512 	ubfx	r5, r2, #0, #19
 8007430:	2d00      	cmp	r5, #0
 8007432:	d138      	bne.n	80074a6 <HAL_ADC_ConfigChannel+0x2fe>
 8007434:	0e90      	lsrs	r0, r2, #26
 8007436:	3001      	adds	r0, #1
 8007438:	f000 001f 	and.w	r0, r0, #31
 800743c:	2809      	cmp	r0, #9
 800743e:	bf8c      	ite	hi
 8007440:	2000      	movhi	r0, #0
 8007442:	2001      	movls	r0, #1
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007444:	2800      	cmp	r0, #0
 8007446:	d066      	beq.n	8007516 <HAL_ADC_ConfigChannel+0x36e>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8007448:	2d00      	cmp	r5, #0
 800744a:	d13b      	bne.n	80074c4 <HAL_ADC_ConfigChannel+0x31c>
 800744c:	0e90      	lsrs	r0, r2, #26
 800744e:	3001      	adds	r0, #1
 8007450:	0680      	lsls	r0, r0, #26
 8007452:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 8007456:	2d00      	cmp	r5, #0
 8007458:	d140      	bne.n	80074dc <HAL_ADC_ConfigChannel+0x334>
 800745a:	0e97      	lsrs	r7, r2, #26
 800745c:	3701      	adds	r7, #1
 800745e:	f007 071f 	and.w	r7, r7, #31
 8007462:	2601      	movs	r6, #1
 8007464:	40be      	lsls	r6, r7
 8007466:	4330      	orrs	r0, r6
 8007468:	2d00      	cmp	r5, #0
 800746a:	d146      	bne.n	80074fa <HAL_ADC_ConfigChannel+0x352>
 800746c:	0e92      	lsrs	r2, r2, #26
 800746e:	3201      	adds	r2, #1
 8007470:	f002 021f 	and.w	r2, r2, #31
 8007474:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8007478:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800747a:	4310      	orrs	r0, r2
 800747c:	688d      	ldr	r5, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800747e:	f104 0e14 	add.w	lr, r4, #20
 8007482:	0e42      	lsrs	r2, r0, #25
 8007484:	0092      	lsls	r2, r2, #2
 8007486:	f002 0204 	and.w	r2, r2, #4
  MODIFY_REG(*preg,
 800748a:	f85e 4002 	ldr.w	r4, [lr, r2]
 800748e:	f3c0 5004 	ubfx	r0, r0, #20, #5
 8007492:	2607      	movs	r6, #7
 8007494:	4086      	lsls	r6, r0
 8007496:	ea24 0c06 	bic.w	ip, r4, r6
 800749a:	4085      	lsls	r5, r0
 800749c:	ea4c 0505 	orr.w	r5, ip, r5
 80074a0:	f84e 5002 	str.w	r5, [lr, r2]
}
 80074a4:	e71f      	b.n	80072e6 <HAL_ADC_ConfigChannel+0x13e>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074a6:	fa92 f0a2 	rbit	r0, r2
  if (value == 0U)
 80074aa:	b148      	cbz	r0, 80074c0 <HAL_ADC_ConfigChannel+0x318>
  return __builtin_clz(value);
 80074ac:	fab0 f080 	clz	r0, r0
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80074b0:	3001      	adds	r0, #1
 80074b2:	f000 001f 	and.w	r0, r0, #31
 80074b6:	2809      	cmp	r0, #9
 80074b8:	bf8c      	ite	hi
 80074ba:	2000      	movhi	r0, #0
 80074bc:	2001      	movls	r0, #1
 80074be:	e7c1      	b.n	8007444 <HAL_ADC_ConfigChannel+0x29c>
    return 32U;
 80074c0:	2020      	movs	r0, #32
 80074c2:	e7f5      	b.n	80074b0 <HAL_ADC_ConfigChannel+0x308>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074c4:	fa92 f0a2 	rbit	r0, r2
  if (value == 0U)
 80074c8:	b130      	cbz	r0, 80074d8 <HAL_ADC_ConfigChannel+0x330>
  return __builtin_clz(value);
 80074ca:	fab0 f080 	clz	r0, r0
 80074ce:	3001      	adds	r0, #1
 80074d0:	0680      	lsls	r0, r0, #26
 80074d2:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 80074d6:	e7be      	b.n	8007456 <HAL_ADC_ConfigChannel+0x2ae>
    return 32U;
 80074d8:	2020      	movs	r0, #32
 80074da:	e7f8      	b.n	80074ce <HAL_ADC_ConfigChannel+0x326>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074dc:	fa92 f6a2 	rbit	r6, r2
  if (value == 0U)
 80074e0:	b14e      	cbz	r6, 80074f6 <HAL_ADC_ConfigChannel+0x34e>
  return __builtin_clz(value);
 80074e2:	fab6 f686 	clz	r6, r6
 80074e6:	3601      	adds	r6, #1
 80074e8:	f006 061f 	and.w	r6, r6, #31
 80074ec:	f04f 0c01 	mov.w	ip, #1
 80074f0:	fa0c f606 	lsl.w	r6, ip, r6
 80074f4:	e7b7      	b.n	8007466 <HAL_ADC_ConfigChannel+0x2be>
    return 32U;
 80074f6:	2620      	movs	r6, #32
 80074f8:	e7f5      	b.n	80074e6 <HAL_ADC_ConfigChannel+0x33e>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074fa:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 80074fe:	b142      	cbz	r2, 8007512 <HAL_ADC_ConfigChannel+0x36a>
  return __builtin_clz(value);
 8007500:	fab2 f282 	clz	r2, r2
 8007504:	3201      	adds	r2, #1
 8007506:	f002 021f 	and.w	r2, r2, #31
 800750a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800750e:	0512      	lsls	r2, r2, #20
 8007510:	e7b3      	b.n	800747a <HAL_ADC_ConfigChannel+0x2d2>
    return 32U;
 8007512:	2220      	movs	r2, #32
 8007514:	e7f6      	b.n	8007504 <HAL_ADC_ConfigChannel+0x35c>
 8007516:	bb4d      	cbnz	r5, 800756c <HAL_ADC_ConfigChannel+0x3c4>
 8007518:	0e90      	lsrs	r0, r2, #26
 800751a:	3001      	adds	r0, #1
 800751c:	0680      	lsls	r0, r0, #26
 800751e:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 8007522:	bb7d      	cbnz	r5, 8007584 <HAL_ADC_ConfigChannel+0x3dc>
 8007524:	0e97      	lsrs	r7, r2, #26
 8007526:	3701      	adds	r7, #1
 8007528:	f007 071f 	and.w	r7, r7, #31
 800752c:	2601      	movs	r6, #1
 800752e:	40be      	lsls	r6, r7
 8007530:	4330      	orrs	r0, r6
 8007532:	bbb5      	cbnz	r5, 80075a2 <HAL_ADC_ConfigChannel+0x3fa>
 8007534:	0e92      	lsrs	r2, r2, #26
 8007536:	3201      	adds	r2, #1
 8007538:	f002 021f 	and.w	r2, r2, #31
 800753c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8007540:	3a1e      	subs	r2, #30
 8007542:	0512      	lsls	r2, r2, #20
 8007544:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007548:	4310      	orrs	r0, r2
 800754a:	e797      	b.n	800747c <HAL_ADC_ConfigChannel+0x2d4>
 800754c:	03fff000 	.word	0x03fff000
 8007550:	0007ffff 	.word	0x0007ffff
 8007554:	407f0000 	.word	0x407f0000
 8007558:	80080000 	.word	0x80080000
 800755c:	50040300 	.word	0x50040300
 8007560:	c7520000 	.word	0xc7520000
 8007564:	cb840000 	.word	0xcb840000
 8007568:	80000001 	.word	0x80000001
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800756c:	fa92 f0a2 	rbit	r0, r2
  if (value == 0U)
 8007570:	b130      	cbz	r0, 8007580 <HAL_ADC_ConfigChannel+0x3d8>
  return __builtin_clz(value);
 8007572:	fab0 f080 	clz	r0, r0
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8007576:	3001      	adds	r0, #1
 8007578:	0680      	lsls	r0, r0, #26
 800757a:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 800757e:	e7d0      	b.n	8007522 <HAL_ADC_ConfigChannel+0x37a>
    return 32U;
 8007580:	2020      	movs	r0, #32
 8007582:	e7f8      	b.n	8007576 <HAL_ADC_ConfigChannel+0x3ce>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007584:	fa92 f6a2 	rbit	r6, r2
  if (value == 0U)
 8007588:	b14e      	cbz	r6, 800759e <HAL_ADC_ConfigChannel+0x3f6>
  return __builtin_clz(value);
 800758a:	fab6 f686 	clz	r6, r6
 800758e:	3601      	adds	r6, #1
 8007590:	f006 061f 	and.w	r6, r6, #31
 8007594:	f04f 0c01 	mov.w	ip, #1
 8007598:	fa0c f606 	lsl.w	r6, ip, r6
 800759c:	e7c8      	b.n	8007530 <HAL_ADC_ConfigChannel+0x388>
    return 32U;
 800759e:	2620      	movs	r6, #32
 80075a0:	e7f5      	b.n	800758e <HAL_ADC_ConfigChannel+0x3e6>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80075a2:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 80075a6:	b15a      	cbz	r2, 80075c0 <HAL_ADC_ConfigChannel+0x418>
  return __builtin_clz(value);
 80075a8:	fab2 f282 	clz	r2, r2
 80075ac:	3201      	adds	r2, #1
 80075ae:	f002 021f 	and.w	r2, r2, #31
 80075b2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80075b6:	3a1e      	subs	r2, #30
 80075b8:	0512      	lsls	r2, r2, #20
 80075ba:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80075be:	e7c3      	b.n	8007548 <HAL_ADC_ConfigChannel+0x3a0>
    return 32U;
 80075c0:	2220      	movs	r2, #32
 80075c2:	e7f3      	b.n	80075ac <HAL_ADC_ConfigChannel+0x404>
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80075c4:	f411 0f00 	tst.w	r1, #8388608	; 0x800000
 80075c8:	f47f ae9a 	bne.w	8007300 <HAL_ADC_ConfigChannel+0x158>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80075cc:	6819      	ldr	r1, [r3, #0]
 80075ce:	4a27      	ldr	r2, [pc, #156]	; (800766c <HAL_ADC_ConfigChannel+0x4c4>)
 80075d0:	4291      	cmp	r1, r2
 80075d2:	d001      	beq.n	80075d8 <HAL_ADC_ConfigChannel+0x430>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80075d4:	2000      	movs	r0, #0
 80075d6:	e5fe      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80075d8:	f444 0200 	orr.w	r2, r4, #8388608	; 0x800000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80075dc:	4824      	ldr	r0, [pc, #144]	; (8007670 <HAL_ADC_ConfigChannel+0x4c8>)
 80075de:	6881      	ldr	r1, [r0, #8]
 80075e0:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 80075e4:	430a      	orrs	r2, r1
 80075e6:	6082      	str	r2, [r0, #8]
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80075e8:	4a22      	ldr	r2, [pc, #136]	; (8007674 <HAL_ADC_ConfigChannel+0x4cc>)
 80075ea:	6812      	ldr	r2, [r2, #0]
 80075ec:	0992      	lsrs	r2, r2, #6
 80075ee:	4922      	ldr	r1, [pc, #136]	; (8007678 <HAL_ADC_ConfigChannel+0x4d0>)
 80075f0:	fba1 1202 	umull	r1, r2, r1, r2
 80075f4:	0992      	lsrs	r2, r2, #6
 80075f6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80075fa:	0092      	lsls	r2, r2, #2
 80075fc:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 80075fe:	e002      	b.n	8007606 <HAL_ADC_ConfigChannel+0x45e>
            wait_loop_index--;
 8007600:	9a01      	ldr	r2, [sp, #4]
 8007602:	3a01      	subs	r2, #1
 8007604:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 8007606:	9a01      	ldr	r2, [sp, #4]
 8007608:	2a00      	cmp	r2, #0
 800760a:	d1f9      	bne.n	8007600 <HAL_ADC_ConfigChannel+0x458>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800760c:	2000      	movs	r0, #0
 800760e:	e5e2      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8007610:	f011 7f80 	tst.w	r1, #16777216	; 0x1000000
 8007614:	f47f ae78 	bne.w	8007308 <HAL_ADC_ConfigChannel+0x160>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8007618:	6819      	ldr	r1, [r3, #0]
 800761a:	4a14      	ldr	r2, [pc, #80]	; (800766c <HAL_ADC_ConfigChannel+0x4c4>)
 800761c:	4291      	cmp	r1, r2
 800761e:	d001      	beq.n	8007624 <HAL_ADC_ConfigChannel+0x47c>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007620:	2000      	movs	r0, #0
 8007622:	e5d8      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8007624:	f044 7280 	orr.w	r2, r4, #16777216	; 0x1000000
 8007628:	4811      	ldr	r0, [pc, #68]	; (8007670 <HAL_ADC_ConfigChannel+0x4c8>)
 800762a:	6881      	ldr	r1, [r0, #8]
 800762c:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8007630:	430a      	orrs	r2, r1
 8007632:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007634:	2000      	movs	r0, #0
}
 8007636:	e5ce      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8007638:	f411 0f80 	tst.w	r1, #4194304	; 0x400000
 800763c:	d111      	bne.n	8007662 <HAL_ADC_ConfigChannel+0x4ba>
        if (ADC_VREFINT_INSTANCE(hadc))
 800763e:	6819      	ldr	r1, [r3, #0]
 8007640:	4a0a      	ldr	r2, [pc, #40]	; (800766c <HAL_ADC_ConfigChannel+0x4c4>)
 8007642:	4291      	cmp	r1, r2
 8007644:	d001      	beq.n	800764a <HAL_ADC_ConfigChannel+0x4a2>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007646:	2000      	movs	r0, #0
 8007648:	e5c5      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 800764a:	f444 0280 	orr.w	r2, r4, #4194304	; 0x400000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800764e:	4808      	ldr	r0, [pc, #32]	; (8007670 <HAL_ADC_ConfigChannel+0x4c8>)
 8007650:	6881      	ldr	r1, [r0, #8]
 8007652:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8007656:	430a      	orrs	r2, r1
 8007658:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800765a:	2000      	movs	r0, #0
}
 800765c:	e5bb      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
 800765e:	2000      	movs	r0, #0
 8007660:	e5b9      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
 8007662:	2000      	movs	r0, #0
 8007664:	e5b7      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
  __HAL_LOCK(hadc);
 8007666:	2002      	movs	r0, #2
 8007668:	e5b8      	b.n	80071dc <HAL_ADC_ConfigChannel+0x34>
 800766a:	bf00      	nop
 800766c:	50040000 	.word	0x50040000
 8007670:	50040300 	.word	0x50040300
 8007674:	20000034 	.word	0x20000034
 8007678:	053e2d63 	.word	0x053e2d63

0800767c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800767c:	4a07      	ldr	r2, [pc, #28]	; (800769c <HAL_NVIC_SetPriorityGrouping+0x20>)
 800767e:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8007680:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8007684:	041b      	lsls	r3, r3, #16
 8007686:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8007688:	0200      	lsls	r0, r0, #8
 800768a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800768e:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8007690:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8007694:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8007698:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800769a:	4770      	bx	lr
 800769c:	e000ed00 	.word	0xe000ed00

080076a0 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80076a0:	b500      	push	{lr}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80076a2:	4b19      	ldr	r3, [pc, #100]	; (8007708 <HAL_NVIC_SetPriority+0x68>)
 80076a4:	68db      	ldr	r3, [r3, #12]
 80076a6:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80076aa:	f1c3 0c07 	rsb	ip, r3, #7
 80076ae:	f1bc 0f04 	cmp.w	ip, #4
 80076b2:	bf28      	it	cs
 80076b4:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80076b8:	f103 0e04 	add.w	lr, r3, #4
 80076bc:	f1be 0f06 	cmp.w	lr, #6
 80076c0:	d918      	bls.n	80076f4 <HAL_NVIC_SetPriority+0x54>
 80076c2:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80076c4:	f04f 3eff 	mov.w	lr, #4294967295
 80076c8:	fa0e fc0c 	lsl.w	ip, lr, ip
 80076cc:	ea21 010c 	bic.w	r1, r1, ip
 80076d0:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80076d2:	fa0e fe03 	lsl.w	lr, lr, r3
 80076d6:	ea22 020e 	bic.w	r2, r2, lr
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80076da:	430a      	orrs	r2, r1
  if ((int32_t)(IRQn) >= 0)
 80076dc:	2800      	cmp	r0, #0
 80076de:	db0b      	blt.n	80076f8 <HAL_NVIC_SetPriority+0x58>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80076e0:	0112      	lsls	r2, r2, #4
 80076e2:	b2d2      	uxtb	r2, r2
 80076e4:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80076e8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80076ec:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80076f0:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80076f4:	2300      	movs	r3, #0
 80076f6:	e7e5      	b.n	80076c4 <HAL_NVIC_SetPriority+0x24>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80076f8:	f000 000f 	and.w	r0, r0, #15
 80076fc:	0112      	lsls	r2, r2, #4
 80076fe:	b2d2      	uxtb	r2, r2
 8007700:	4b02      	ldr	r3, [pc, #8]	; (800770c <HAL_NVIC_SetPriority+0x6c>)
 8007702:	541a      	strb	r2, [r3, r0]
 8007704:	e7f4      	b.n	80076f0 <HAL_NVIC_SetPriority+0x50>
 8007706:	bf00      	nop
 8007708:	e000ed00 	.word	0xe000ed00
 800770c:	e000ed14 	.word	0xe000ed14

08007710 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8007710:	2800      	cmp	r0, #0
 8007712:	db07      	blt.n	8007724 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8007714:	f000 021f 	and.w	r2, r0, #31
 8007718:	0940      	lsrs	r0, r0, #5
 800771a:	2301      	movs	r3, #1
 800771c:	4093      	lsls	r3, r2
 800771e:	4a02      	ldr	r2, [pc, #8]	; (8007728 <HAL_NVIC_EnableIRQ+0x18>)
 8007720:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8007724:	4770      	bx	lr
 8007726:	bf00      	nop
 8007728:	e000e100 	.word	0xe000e100

0800772c <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800772c:	2800      	cmp	r0, #0
 800772e:	db0c      	blt.n	800774a <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8007730:	f000 021f 	and.w	r2, r0, #31
 8007734:	0940      	lsrs	r0, r0, #5
 8007736:	2301      	movs	r3, #1
 8007738:	4093      	lsls	r3, r2
 800773a:	3020      	adds	r0, #32
 800773c:	4a03      	ldr	r2, [pc, #12]	; (800774c <HAL_NVIC_DisableIRQ+0x20>)
 800773e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8007742:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007746:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800774a:	4770      	bx	lr
 800774c:	e000e100 	.word	0xe000e100

08007750 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8007750:	3801      	subs	r0, #1
 8007752:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8007756:	d20b      	bcs.n	8007770 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8007758:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800775c:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800775e:	4a05      	ldr	r2, [pc, #20]	; (8007774 <HAL_SYSTICK_Config+0x24>)
 8007760:	21f0      	movs	r1, #240	; 0xf0
 8007762:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8007766:	2000      	movs	r0, #0
 8007768:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800776a:	2207      	movs	r2, #7
 800776c:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800776e:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8007770:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8007772:	4770      	bx	lr
 8007774:	e000ed00 	.word	0xe000ed00

08007778 <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8007778:	2804      	cmp	r0, #4
 800777a:	d006      	beq.n	800778a <HAL_SYSTICK_CLKSourceConfig+0x12>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800777c:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8007780:	6913      	ldr	r3, [r2, #16]
 8007782:	f023 0304 	bic.w	r3, r3, #4
 8007786:	6113      	str	r3, [r2, #16]
  }
}
 8007788:	4770      	bx	lr
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800778a:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 800778e:	6913      	ldr	r3, [r2, #16]
 8007790:	f043 0304 	orr.w	r3, r3, #4
 8007794:	6113      	str	r3, [r2, #16]
 8007796:	4770      	bx	lr

08007798 <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8007798:	b508      	push	{r3, lr}
  HAL_StatusTypeDef status = HAL_OK;

  if(HAL_DMA_STATE_BUSY != hdma->State)
 800779a:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 800779e:	b2db      	uxtb	r3, r3
 80077a0:	2b02      	cmp	r3, #2
 80077a2:	d003      	beq.n	80077ac <HAL_DMA_Abort_IT+0x14>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80077a4:	2304      	movs	r3, #4
 80077a6:	63c3      	str	r3, [r0, #60]	; 0x3c

    status = HAL_ERROR;
 80077a8:	2001      	movs	r0, #1
    {
      hdma->XferAbortCallback(hdma);
    }
  }
  return status;
}
 80077aa:	bd08      	pop	{r3, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80077ac:	6802      	ldr	r2, [r0, #0]
 80077ae:	6813      	ldr	r3, [r2, #0]
 80077b0:	f023 030e 	bic.w	r3, r3, #14
 80077b4:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 80077b6:	6802      	ldr	r2, [r0, #0]
 80077b8:	6813      	ldr	r3, [r2, #0]
 80077ba:	f023 0301 	bic.w	r3, r3, #1
 80077be:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80077c0:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80077c2:	f003 031c 	and.w	r3, r3, #28
 80077c6:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80077c8:	2201      	movs	r2, #1
 80077ca:	fa02 f303 	lsl.w	r3, r2, r3
 80077ce:	604b      	str	r3, [r1, #4]
    hdma->State = HAL_DMA_STATE_READY;
 80077d0:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 80077d4:	2300      	movs	r3, #0
 80077d6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if(hdma->XferAbortCallback != NULL)
 80077da:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80077dc:	b113      	cbz	r3, 80077e4 <HAL_DMA_Abort_IT+0x4c>
      hdma->XferAbortCallback(hdma);
 80077de:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 80077e0:	2000      	movs	r0, #0
 80077e2:	e7e2      	b.n	80077aa <HAL_DMA_Abort_IT+0x12>
 80077e4:	2000      	movs	r0, #0
 80077e6:	e7e0      	b.n	80077aa <HAL_DMA_Abort_IT+0x12>

080077e8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80077e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80077ea:	b083      	sub	sp, #12
  uint32_t position = 0x00u;
 80077ec:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80077ee:	e036      	b.n	800785e <HAL_GPIO_Init+0x76>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80077f0:	2404      	movs	r4, #4
 80077f2:	e000      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 80077f4:	2400      	movs	r4, #0
 80077f6:	40b4      	lsls	r4, r6
 80077f8:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 80077fa:	3502      	adds	r5, #2
 80077fc:	4e5f      	ldr	r6, [pc, #380]	; (800797c <HAL_GPIO_Init+0x194>)
 80077fe:	f846 4025 	str.w	r4, [r6, r5, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8007802:	4c5f      	ldr	r4, [pc, #380]	; (8007980 <HAL_GPIO_Init+0x198>)
 8007804:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 8007806:	43d4      	mvns	r4, r2
 8007808:	ea25 0602 	bic.w	r6, r5, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800780c:	684f      	ldr	r7, [r1, #4]
 800780e:	f417 3f80 	tst.w	r7, #65536	; 0x10000
 8007812:	d001      	beq.n	8007818 <HAL_GPIO_Init+0x30>
        {
          temp |= iocurrent;
 8007814:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->IMR1 = temp;
 8007818:	4d59      	ldr	r5, [pc, #356]	; (8007980 <HAL_GPIO_Init+0x198>)
 800781a:	602e      	str	r6, [r5, #0]

        temp = EXTI->EMR1;
 800781c:	686d      	ldr	r5, [r5, #4]
        temp &= ~(iocurrent);
 800781e:	ea04 0605 	and.w	r6, r4, r5
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007822:	684f      	ldr	r7, [r1, #4]
 8007824:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8007828:	d001      	beq.n	800782e <HAL_GPIO_Init+0x46>
        {
          temp |= iocurrent;
 800782a:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->EMR1 = temp;
 800782e:	4d54      	ldr	r5, [pc, #336]	; (8007980 <HAL_GPIO_Init+0x198>)
 8007830:	606e      	str	r6, [r5, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8007832:	68ad      	ldr	r5, [r5, #8]
        temp &= ~(iocurrent);
 8007834:	ea04 0605 	and.w	r6, r4, r5
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007838:	684f      	ldr	r7, [r1, #4]
 800783a:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
 800783e:	d001      	beq.n	8007844 <HAL_GPIO_Init+0x5c>
        {
          temp |= iocurrent;
 8007840:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->RTSR1 = temp;
 8007844:	4d4e      	ldr	r5, [pc, #312]	; (8007980 <HAL_GPIO_Init+0x198>)
 8007846:	60ae      	str	r6, [r5, #8]

        temp = EXTI->FTSR1;
 8007848:	68ed      	ldr	r5, [r5, #12]
        temp &= ~(iocurrent);
 800784a:	402c      	ands	r4, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800784c:	684e      	ldr	r6, [r1, #4]
 800784e:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
 8007852:	d001      	beq.n	8007858 <HAL_GPIO_Init+0x70>
        {
          temp |= iocurrent;
 8007854:	ea42 0405 	orr.w	r4, r2, r5
        }
        EXTI->FTSR1 = temp;
 8007858:	4a49      	ldr	r2, [pc, #292]	; (8007980 <HAL_GPIO_Init+0x198>)
 800785a:	60d4      	str	r4, [r2, #12]
      }
    }

    position++;
 800785c:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800785e:	680a      	ldr	r2, [r1, #0]
 8007860:	fa32 f403 	lsrs.w	r4, r2, r3
 8007864:	f000 8087 	beq.w	8007976 <HAL_GPIO_Init+0x18e>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8007868:	f04f 0c01 	mov.w	ip, #1
 800786c:	fa0c fc03 	lsl.w	ip, ip, r3
    if (iocurrent != 0x00u)
 8007870:	ea1c 0202 	ands.w	r2, ip, r2
 8007874:	d0f2      	beq.n	800785c <HAL_GPIO_Init+0x74>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007876:	684c      	ldr	r4, [r1, #4]
 8007878:	1e65      	subs	r5, r4, #1
 800787a:	2d01      	cmp	r5, #1
 800787c:	d903      	bls.n	8007886 <HAL_GPIO_Init+0x9e>
 800787e:	2c11      	cmp	r4, #17
 8007880:	d001      	beq.n	8007886 <HAL_GPIO_Init+0x9e>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8007882:	2c12      	cmp	r4, #18
 8007884:	d112      	bne.n	80078ac <HAL_GPIO_Init+0xc4>
        temp = GPIOx->OSPEEDR;
 8007886:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8007888:	005e      	lsls	r6, r3, #1
 800788a:	2403      	movs	r4, #3
 800788c:	40b4      	lsls	r4, r6
 800788e:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2u));
 8007892:	68cc      	ldr	r4, [r1, #12]
 8007894:	40b4      	lsls	r4, r6
 8007896:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 8007898:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 800789a:	6845      	ldr	r5, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800789c:	ea25 050c 	bic.w	r5, r5, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 80078a0:	684c      	ldr	r4, [r1, #4]
 80078a2:	f3c4 1400 	ubfx	r4, r4, #4, #1
 80078a6:	409c      	lsls	r4, r3
 80078a8:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 80078aa:	6044      	str	r4, [r0, #4]
      temp = GPIOx->PUPDR;
 80078ac:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 80078ae:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 80078b2:	2403      	movs	r4, #3
 80078b4:	fa04 f40e 	lsl.w	r4, r4, lr
 80078b8:	ea6f 0c04 	mvn.w	ip, r4
 80078bc:	ea25 0504 	bic.w	r5, r5, r4
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80078c0:	688c      	ldr	r4, [r1, #8]
 80078c2:	fa04 f40e 	lsl.w	r4, r4, lr
 80078c6:	432c      	orrs	r4, r5
      GPIOx->PUPDR = temp;
 80078c8:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80078ca:	684c      	ldr	r4, [r1, #4]
 80078cc:	2c02      	cmp	r4, #2
 80078ce:	d001      	beq.n	80078d4 <HAL_GPIO_Init+0xec>
 80078d0:	2c12      	cmp	r4, #18
 80078d2:	d10f      	bne.n	80078f4 <HAL_GPIO_Init+0x10c>
        temp = GPIOx->AFR[position >> 3u];
 80078d4:	08dd      	lsrs	r5, r3, #3
 80078d6:	3508      	adds	r5, #8
 80078d8:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80078dc:	f003 0607 	and.w	r6, r3, #7
 80078e0:	00b6      	lsls	r6, r6, #2
 80078e2:	240f      	movs	r4, #15
 80078e4:	40b4      	lsls	r4, r6
 80078e6:	ea27 0704 	bic.w	r7, r7, r4
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80078ea:	690c      	ldr	r4, [r1, #16]
 80078ec:	40b4      	lsls	r4, r6
 80078ee:	433c      	orrs	r4, r7
        GPIOx->AFR[position >> 3u] = temp;
 80078f0:	f840 4025 	str.w	r4, [r0, r5, lsl #2]
      temp = GPIOx->MODER;
 80078f4:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80078f6:	ea0c 0c04 	and.w	ip, ip, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80078fa:	684c      	ldr	r4, [r1, #4]
 80078fc:	f004 0403 	and.w	r4, r4, #3
 8007900:	fa04 f40e 	lsl.w	r4, r4, lr
 8007904:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->MODER = temp;
 8007908:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800790a:	684c      	ldr	r4, [r1, #4]
 800790c:	f014 5f80 	tst.w	r4, #268435456	; 0x10000000
 8007910:	d0a4      	beq.n	800785c <HAL_GPIO_Init+0x74>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007912:	4c1c      	ldr	r4, [pc, #112]	; (8007984 <HAL_GPIO_Init+0x19c>)
 8007914:	6e25      	ldr	r5, [r4, #96]	; 0x60
 8007916:	f045 0501 	orr.w	r5, r5, #1
 800791a:	6625      	str	r5, [r4, #96]	; 0x60
 800791c:	6e24      	ldr	r4, [r4, #96]	; 0x60
 800791e:	f004 0401 	and.w	r4, r4, #1
 8007922:	9401      	str	r4, [sp, #4]
 8007924:	9c01      	ldr	r4, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2u];
 8007926:	089d      	lsrs	r5, r3, #2
 8007928:	1cae      	adds	r6, r5, #2
 800792a:	4c14      	ldr	r4, [pc, #80]	; (800797c <HAL_GPIO_Init+0x194>)
 800792c:	f854 7026 	ldr.w	r7, [r4, r6, lsl #2]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8007930:	f003 0603 	and.w	r6, r3, #3
 8007934:	00b6      	lsls	r6, r6, #2
 8007936:	240f      	movs	r4, #15
 8007938:	40b4      	lsls	r4, r6
 800793a:	ea27 0704 	bic.w	r7, r7, r4
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800793e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
 8007942:	f43f af57 	beq.w	80077f4 <HAL_GPIO_Init+0xc>
 8007946:	4c10      	ldr	r4, [pc, #64]	; (8007988 <HAL_GPIO_Init+0x1a0>)
 8007948:	42a0      	cmp	r0, r4
 800794a:	d00e      	beq.n	800796a <HAL_GPIO_Init+0x182>
 800794c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8007950:	42a0      	cmp	r0, r4
 8007952:	d00c      	beq.n	800796e <HAL_GPIO_Init+0x186>
 8007954:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8007958:	42a0      	cmp	r0, r4
 800795a:	d00a      	beq.n	8007972 <HAL_GPIO_Init+0x18a>
 800795c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8007960:	42a0      	cmp	r0, r4
 8007962:	f43f af45 	beq.w	80077f0 <HAL_GPIO_Init+0x8>
 8007966:	2407      	movs	r4, #7
 8007968:	e745      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 800796a:	2401      	movs	r4, #1
 800796c:	e743      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 800796e:	2402      	movs	r4, #2
 8007970:	e741      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 8007972:	2403      	movs	r4, #3
 8007974:	e73f      	b.n	80077f6 <HAL_GPIO_Init+0xe>
  }
}
 8007976:	b003      	add	sp, #12
 8007978:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800797a:	bf00      	nop
 800797c:	40010000 	.word	0x40010000
 8007980:	40010400 	.word	0x40010400
 8007984:	40021000 	.word	0x40021000
 8007988:	48000400 	.word	0x48000400

0800798c <HAL_GPIO_DeInit>:
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00u;
 800798c:	2300      	movs	r3, #0
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
 800798e:	fa31 f203 	lsrs.w	r2, r1, r3
 8007992:	d07a      	beq.n	8007a8a <HAL_GPIO_DeInit+0xfe>
{
 8007994:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007996:	e02e      	b.n	80079f6 <HAL_GPIO_DeInit+0x6a>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2u];
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8007998:	2504      	movs	r5, #4
 800799a:	e000      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 800799c:	2500      	movs	r5, #0
 800799e:	fa05 f50c 	lsl.w	r5, r5, ip
 80079a2:	42a5      	cmp	r5, r4
 80079a4:	d055      	beq.n	8007a52 <HAL_GPIO_DeInit+0xc6>
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 80079a6:	6804      	ldr	r4, [r0, #0]
 80079a8:	005d      	lsls	r5, r3, #1
 80079aa:	f04f 0c03 	mov.w	ip, #3
 80079ae:	fa0c fc05 	lsl.w	ip, ip, r5
 80079b2:	ea44 040c 	orr.w	r4, r4, ip
 80079b6:	6004      	str	r4, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 80079b8:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 80079bc:	f10e 0e08 	add.w	lr, lr, #8
 80079c0:	f850 402e 	ldr.w	r4, [r0, lr, lsl #2]
 80079c4:	f003 0607 	and.w	r6, r3, #7
 80079c8:	00b6      	lsls	r6, r6, #2
 80079ca:	250f      	movs	r5, #15
 80079cc:	40b5      	lsls	r5, r6
 80079ce:	ea24 0405 	bic.w	r4, r4, r5
 80079d2:	f840 402e 	str.w	r4, [r0, lr, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 80079d6:	6884      	ldr	r4, [r0, #8]
 80079d8:	ea24 040c 	bic.w	r4, r4, ip
 80079dc:	6084      	str	r4, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80079de:	6844      	ldr	r4, [r0, #4]
 80079e0:	ea24 0202 	bic.w	r2, r4, r2
 80079e4:	6042      	str	r2, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 80079e6:	68c2      	ldr	r2, [r0, #12]
 80079e8:	ea22 020c 	bic.w	r2, r2, ip
 80079ec:	60c2      	str	r2, [r0, #12]
      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_ASC0<< position);
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
    }

    position++;
 80079ee:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00u)
 80079f0:	fa31 f203 	lsrs.w	r2, r1, r3
 80079f4:	d048      	beq.n	8007a88 <HAL_GPIO_DeInit+0xfc>
    iocurrent = (GPIO_Pin) & (1uL << position);
 80079f6:	2201      	movs	r2, #1
 80079f8:	409a      	lsls	r2, r3
    if (iocurrent != 0x00u)
 80079fa:	ea12 0701 	ands.w	r7, r2, r1
 80079fe:	d0f6      	beq.n	80079ee <HAL_GPIO_DeInit+0x62>
      tmp = SYSCFG->EXTICR[position >> 2u];
 8007a00:	ea4f 0e93 	mov.w	lr, r3, lsr #2
 8007a04:	f10e 0502 	add.w	r5, lr, #2
 8007a08:	4c20      	ldr	r4, [pc, #128]	; (8007a8c <HAL_GPIO_DeInit+0x100>)
 8007a0a:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8007a0e:	f003 0c03 	and.w	ip, r3, #3
 8007a12:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8007a16:	250f      	movs	r5, #15
 8007a18:	fa05 f60c 	lsl.w	r6, r5, ip
 8007a1c:	4034      	ands	r4, r6
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8007a1e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
 8007a22:	d0bb      	beq.n	800799c <HAL_GPIO_DeInit+0x10>
 8007a24:	4d1a      	ldr	r5, [pc, #104]	; (8007a90 <HAL_GPIO_DeInit+0x104>)
 8007a26:	42a8      	cmp	r0, r5
 8007a28:	d00d      	beq.n	8007a46 <HAL_GPIO_DeInit+0xba>
 8007a2a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007a2e:	42a8      	cmp	r0, r5
 8007a30:	d00b      	beq.n	8007a4a <HAL_GPIO_DeInit+0xbe>
 8007a32:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007a36:	42a8      	cmp	r0, r5
 8007a38:	d009      	beq.n	8007a4e <HAL_GPIO_DeInit+0xc2>
 8007a3a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007a3e:	42a8      	cmp	r0, r5
 8007a40:	d0aa      	beq.n	8007998 <HAL_GPIO_DeInit+0xc>
 8007a42:	2507      	movs	r5, #7
 8007a44:	e7ab      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 8007a46:	2501      	movs	r5, #1
 8007a48:	e7a9      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 8007a4a:	2502      	movs	r5, #2
 8007a4c:	e7a7      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 8007a4e:	2503      	movs	r5, #3
 8007a50:	e7a5      	b.n	800799e <HAL_GPIO_DeInit+0x12>
        EXTI->IMR1 &= ~(iocurrent);
 8007a52:	4c10      	ldr	r4, [pc, #64]	; (8007a94 <HAL_GPIO_DeInit+0x108>)
 8007a54:	6825      	ldr	r5, [r4, #0]
 8007a56:	ea25 0507 	bic.w	r5, r5, r7
 8007a5a:	6025      	str	r5, [r4, #0]
        EXTI->EMR1 &= ~(iocurrent);
 8007a5c:	6865      	ldr	r5, [r4, #4]
 8007a5e:	ea25 0507 	bic.w	r5, r5, r7
 8007a62:	6065      	str	r5, [r4, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 8007a64:	68a5      	ldr	r5, [r4, #8]
 8007a66:	ea25 0507 	bic.w	r5, r5, r7
 8007a6a:	60a5      	str	r5, [r4, #8]
        EXTI->FTSR1 &= ~(iocurrent);
 8007a6c:	68e5      	ldr	r5, [r4, #12]
 8007a6e:	ea25 0507 	bic.w	r5, r5, r7
 8007a72:	60e5      	str	r5, [r4, #12]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8007a74:	4f05      	ldr	r7, [pc, #20]	; (8007a8c <HAL_GPIO_DeInit+0x100>)
 8007a76:	f10e 0402 	add.w	r4, lr, #2
 8007a7a:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 8007a7e:	ea25 0506 	bic.w	r5, r5, r6
 8007a82:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
 8007a86:	e78e      	b.n	80079a6 <HAL_GPIO_DeInit+0x1a>
  }
}
 8007a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007a8a:	4770      	bx	lr
 8007a8c:	40010000 	.word	0x40010000
 8007a90:	48000400 	.word	0x48000400
 8007a94:	40010400 	.word	0x40010400

08007a98 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 8007a98:	6903      	ldr	r3, [r0, #16]
 8007a9a:	4219      	tst	r1, r3
 8007a9c:	d001      	beq.n	8007aa2 <HAL_GPIO_ReadPin+0xa>
  {
    bitstatus = GPIO_PIN_SET;
 8007a9e:	2001      	movs	r0, #1
 8007aa0:	4770      	bx	lr
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8007aa2:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8007aa4:	4770      	bx	lr

08007aa6 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8007aa6:	b10a      	cbz	r2, 8007aac <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8007aa8:	6181      	str	r1, [r0, #24]
 8007aaa:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8007aac:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8007aae:	4770      	bx	lr

08007ab0 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8007ab0:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8007ab2:	4b05      	ldr	r3, [pc, #20]	; (8007ac8 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 8007ab4:	695b      	ldr	r3, [r3, #20]
 8007ab6:	4203      	tst	r3, r0
 8007ab8:	d100      	bne.n	8007abc <HAL_GPIO_EXTI_IRQHandler+0xc>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}
 8007aba:	bd08      	pop	{r3, pc}
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8007abc:	4b02      	ldr	r3, [pc, #8]	; (8007ac8 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 8007abe:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8007ac0:	f016 fbae 	bl	801e220 <HAL_GPIO_EXTI_Callback>
}
 8007ac4:	e7f9      	b.n	8007aba <HAL_GPIO_EXTI_IRQHandler+0xa>
 8007ac6:	bf00      	nop
 8007ac8:	40010400 	.word	0x40010400

08007acc <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007acc:	6803      	ldr	r3, [r0, #0]
 8007ace:	699a      	ldr	r2, [r3, #24]
 8007ad0:	f012 0f02 	tst.w	r2, #2
 8007ad4:	d001      	beq.n	8007ada <I2C_Flush_TXDR+0xe>
  {
    hi2c->Instance->TXDR = 0x00U;
 8007ad6:	2200      	movs	r2, #0
 8007ad8:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007ada:	6803      	ldr	r3, [r0, #0]
 8007adc:	699a      	ldr	r2, [r3, #24]
 8007ade:	f012 0f01 	tst.w	r2, #1
 8007ae2:	d103      	bne.n	8007aec <I2C_Flush_TXDR+0x20>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007ae4:	699a      	ldr	r2, [r3, #24]
 8007ae6:	f042 0201 	orr.w	r2, r2, #1
 8007aea:	619a      	str	r2, [r3, #24]
  }
}
 8007aec:	4770      	bx	lr

08007aee <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 8007aee:	b430      	push	{r4, r5}
 8007af0:	9d02      	ldr	r5, [sp, #8]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 8007af2:	6804      	ldr	r4, [r0, #0]
 8007af4:	6860      	ldr	r0, [r4, #4]
 8007af6:	ea4f 5c55 	mov.w	ip, r5, lsr #21
 8007afa:	f40c 6c80 	and.w	ip, ip, #1024	; 0x400
 8007afe:	f04c 7c7f 	orr.w	ip, ip, #66846720	; 0x3fc0000
 8007b02:	f44c 3c58 	orr.w	ip, ip, #221184	; 0x36000
 8007b06:	f44c 7c7f 	orr.w	ip, ip, #1020	; 0x3fc
 8007b0a:	f04c 0c03 	orr.w	ip, ip, #3
 8007b0e:	ea20 000c 	bic.w	r0, r0, ip
 8007b12:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8007b16:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8007b1a:	4319      	orrs	r1, r3
 8007b1c:	4329      	orrs	r1, r5
 8007b1e:	4308      	orrs	r0, r1
 8007b20:	6060      	str	r0, [r4, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 8007b22:	bc30      	pop	{r4, r5}
 8007b24:	4770      	bx	lr

08007b26 <I2C_IsAcknowledgeFailed>:
{
 8007b26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007b28:	4605      	mov	r5, r0
 8007b2a:	460e      	mov	r6, r1
 8007b2c:	4617      	mov	r7, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007b2e:	6803      	ldr	r3, [r0, #0]
 8007b30:	699b      	ldr	r3, [r3, #24]
 8007b32:	f013 0f10 	tst.w	r3, #16
 8007b36:	d101      	bne.n	8007b3c <I2C_IsAcknowledgeFailed+0x16>
  return HAL_OK;
 8007b38:	2000      	movs	r0, #0
}
 8007b3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007b3c:	682b      	ldr	r3, [r5, #0]
 8007b3e:	699c      	ldr	r4, [r3, #24]
 8007b40:	f014 0f20 	tst.w	r4, #32
 8007b44:	d117      	bne.n	8007b76 <I2C_IsAcknowledgeFailed+0x50>
      if (Timeout != HAL_MAX_DELAY)
 8007b46:	f1b6 3fff 	cmp.w	r6, #4294967295
 8007b4a:	d0f7      	beq.n	8007b3c <I2C_IsAcknowledgeFailed+0x16>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007b4c:	f7ff fa24 	bl	8006f98 <HAL_GetTick>
 8007b50:	1bc0      	subs	r0, r0, r7
 8007b52:	42b0      	cmp	r0, r6
 8007b54:	d801      	bhi.n	8007b5a <I2C_IsAcknowledgeFailed+0x34>
 8007b56:	2e00      	cmp	r6, #0
 8007b58:	d1f0      	bne.n	8007b3c <I2C_IsAcknowledgeFailed+0x16>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007b5a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8007b5c:	f043 0320 	orr.w	r3, r3, #32
 8007b60:	646b      	str	r3, [r5, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8007b62:	2320      	movs	r3, #32
 8007b64:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b68:	2300      	movs	r3, #0
 8007b6a:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
          __HAL_UNLOCK(hi2c);
 8007b6e:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
          return HAL_ERROR;
 8007b72:	2001      	movs	r0, #1
 8007b74:	e7e1      	b.n	8007b3a <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007b76:	2210      	movs	r2, #16
 8007b78:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007b7a:	682b      	ldr	r3, [r5, #0]
 8007b7c:	2420      	movs	r4, #32
 8007b7e:	61dc      	str	r4, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8007b80:	4628      	mov	r0, r5
 8007b82:	f7ff ffa3 	bl	8007acc <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8007b86:	682a      	ldr	r2, [r5, #0]
 8007b88:	6853      	ldr	r3, [r2, #4]
 8007b8a:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8007b8e:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 8007b92:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8007b96:	f023 0301 	bic.w	r3, r3, #1
 8007b9a:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007b9c:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8007b9e:	f043 0304 	orr.w	r3, r3, #4
 8007ba2:	646b      	str	r3, [r5, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8007ba4:	f885 4041 	strb.w	r4, [r5, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ba8:	2300      	movs	r3, #0
 8007baa:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8007bae:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    return HAL_ERROR;
 8007bb2:	2001      	movs	r0, #1
 8007bb4:	e7c1      	b.n	8007b3a <I2C_IsAcknowledgeFailed+0x14>

08007bb6 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8007bb6:	b570      	push	{r4, r5, r6, lr}
 8007bb8:	4604      	mov	r4, r0
 8007bba:	460d      	mov	r5, r1
 8007bbc:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007bbe:	6823      	ldr	r3, [r4, #0]
 8007bc0:	699b      	ldr	r3, [r3, #24]
 8007bc2:	f013 0f02 	tst.w	r3, #2
 8007bc6:	d11d      	bne.n	8007c04 <I2C_WaitOnTXISFlagUntilTimeout+0x4e>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007bc8:	4632      	mov	r2, r6
 8007bca:	4629      	mov	r1, r5
 8007bcc:	4620      	mov	r0, r4
 8007bce:	f7ff ffaa 	bl	8007b26 <I2C_IsAcknowledgeFailed>
 8007bd2:	b9c8      	cbnz	r0, 8007c08 <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
 8007bd4:	f1b5 3fff 	cmp.w	r5, #4294967295
 8007bd8:	d0f1      	beq.n	8007bbe <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007bda:	f7ff f9dd 	bl	8006f98 <HAL_GetTick>
 8007bde:	1b80      	subs	r0, r0, r6
 8007be0:	42a8      	cmp	r0, r5
 8007be2:	d801      	bhi.n	8007be8 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 8007be4:	2d00      	cmp	r5, #0
 8007be6:	d1ea      	bne.n	8007bbe <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007be8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007bea:	f043 0320 	orr.w	r3, r3, #32
 8007bee:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8007bf0:	2320      	movs	r3, #32
 8007bf2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bf6:	2300      	movs	r3, #0
 8007bf8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8007bfc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
 8007c00:	2001      	movs	r0, #1
 8007c02:	e000      	b.n	8007c06 <I2C_WaitOnTXISFlagUntilTimeout+0x50>
  return HAL_OK;
 8007c04:	2000      	movs	r0, #0
}
 8007c06:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8007c08:	2001      	movs	r0, #1
 8007c0a:	e7fc      	b.n	8007c06 <I2C_WaitOnTXISFlagUntilTimeout+0x50>

08007c0c <I2C_WaitOnFlagUntilTimeout>:
{
 8007c0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007c10:	4606      	mov	r6, r0
 8007c12:	4688      	mov	r8, r1
 8007c14:	4617      	mov	r7, r2
 8007c16:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007c18:	6834      	ldr	r4, [r6, #0]
 8007c1a:	69a4      	ldr	r4, [r4, #24]
 8007c1c:	ea38 0404 	bics.w	r4, r8, r4
 8007c20:	bf0c      	ite	eq
 8007c22:	2401      	moveq	r4, #1
 8007c24:	2400      	movne	r4, #0
 8007c26:	42bc      	cmp	r4, r7
 8007c28:	d118      	bne.n	8007c5c <I2C_WaitOnFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
 8007c2a:	f1b5 3fff 	cmp.w	r5, #4294967295
 8007c2e:	d0f3      	beq.n	8007c18 <I2C_WaitOnFlagUntilTimeout+0xc>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007c30:	f7ff f9b2 	bl	8006f98 <HAL_GetTick>
 8007c34:	9b06      	ldr	r3, [sp, #24]
 8007c36:	1ac0      	subs	r0, r0, r3
 8007c38:	42a8      	cmp	r0, r5
 8007c3a:	d801      	bhi.n	8007c40 <I2C_WaitOnFlagUntilTimeout+0x34>
 8007c3c:	2d00      	cmp	r5, #0
 8007c3e:	d1eb      	bne.n	8007c18 <I2C_WaitOnFlagUntilTimeout+0xc>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007c40:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8007c42:	f043 0320 	orr.w	r3, r3, #32
 8007c46:	6473      	str	r3, [r6, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8007c48:	2320      	movs	r3, #32
 8007c4a:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c4e:	2300      	movs	r3, #0
 8007c50:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8007c54:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
        return HAL_ERROR;
 8007c58:	2001      	movs	r0, #1
 8007c5a:	e000      	b.n	8007c5e <I2C_WaitOnFlagUntilTimeout+0x52>
  return HAL_OK;
 8007c5c:	2000      	movs	r0, #0
}
 8007c5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08007c64 <I2C_RequestMemoryWrite>:
{
 8007c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007c68:	b082      	sub	sp, #8
 8007c6a:	4604      	mov	r4, r0
 8007c6c:	4690      	mov	r8, r2
 8007c6e:	461d      	mov	r5, r3
 8007c70:	9e08      	ldr	r6, [sp, #32]
 8007c72:	9f09      	ldr	r7, [sp, #36]	; 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007c74:	4b19      	ldr	r3, [pc, #100]	; (8007cdc <I2C_RequestMemoryWrite+0x78>)
 8007c76:	9300      	str	r3, [sp, #0]
 8007c78:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007c7c:	b2ea      	uxtb	r2, r5
 8007c7e:	f7ff ff36 	bl	8007aee <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c82:	463a      	mov	r2, r7
 8007c84:	4631      	mov	r1, r6
 8007c86:	4620      	mov	r0, r4
 8007c88:	f7ff ff95 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007c8c:	b9f8      	cbnz	r0, 8007cce <I2C_RequestMemoryWrite+0x6a>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007c8e:	2d01      	cmp	r5, #1
 8007c90:	d10e      	bne.n	8007cb0 <I2C_RequestMemoryWrite+0x4c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007c92:	6823      	ldr	r3, [r4, #0]
 8007c94:	fa5f f288 	uxtb.w	r2, r8
 8007c98:	629a      	str	r2, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8007c9a:	9700      	str	r7, [sp, #0]
 8007c9c:	4633      	mov	r3, r6
 8007c9e:	2200      	movs	r2, #0
 8007ca0:	2180      	movs	r1, #128	; 0x80
 8007ca2:	4620      	mov	r0, r4
 8007ca4:	f7ff ffb2 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007ca8:	b9a8      	cbnz	r0, 8007cd6 <I2C_RequestMemoryWrite+0x72>
}
 8007caa:	b002      	add	sp, #8
 8007cac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007cb0:	6823      	ldr	r3, [r4, #0]
 8007cb2:	ea4f 2218 	mov.w	r2, r8, lsr #8
 8007cb6:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007cb8:	463a      	mov	r2, r7
 8007cba:	4631      	mov	r1, r6
 8007cbc:	4620      	mov	r0, r4
 8007cbe:	f7ff ff7a 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007cc2:	b930      	cbnz	r0, 8007cd2 <I2C_RequestMemoryWrite+0x6e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007cc4:	6823      	ldr	r3, [r4, #0]
 8007cc6:	fa5f f288 	uxtb.w	r2, r8
 8007cca:	629a      	str	r2, [r3, #40]	; 0x28
 8007ccc:	e7e5      	b.n	8007c9a <I2C_RequestMemoryWrite+0x36>
    return HAL_ERROR;
 8007cce:	2001      	movs	r0, #1
 8007cd0:	e7eb      	b.n	8007caa <I2C_RequestMemoryWrite+0x46>
      return HAL_ERROR;
 8007cd2:	2001      	movs	r0, #1
 8007cd4:	e7e9      	b.n	8007caa <I2C_RequestMemoryWrite+0x46>
    return HAL_ERROR;
 8007cd6:	2001      	movs	r0, #1
 8007cd8:	e7e7      	b.n	8007caa <I2C_RequestMemoryWrite+0x46>
 8007cda:	bf00      	nop
 8007cdc:	80002000 	.word	0x80002000

08007ce0 <I2C_RequestMemoryRead>:
{
 8007ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007ce4:	b082      	sub	sp, #8
 8007ce6:	4604      	mov	r4, r0
 8007ce8:	4690      	mov	r8, r2
 8007cea:	461d      	mov	r5, r3
 8007cec:	9e08      	ldr	r6, [sp, #32]
 8007cee:	9f09      	ldr	r7, [sp, #36]	; 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007cf0:	4b18      	ldr	r3, [pc, #96]	; (8007d54 <I2C_RequestMemoryRead+0x74>)
 8007cf2:	9300      	str	r3, [sp, #0]
 8007cf4:	2300      	movs	r3, #0
 8007cf6:	b2ea      	uxtb	r2, r5
 8007cf8:	f7ff fef9 	bl	8007aee <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007cfc:	463a      	mov	r2, r7
 8007cfe:	4631      	mov	r1, r6
 8007d00:	4620      	mov	r0, r4
 8007d02:	f7ff ff58 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d06:	b9f8      	cbnz	r0, 8007d48 <I2C_RequestMemoryRead+0x68>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007d08:	2d01      	cmp	r5, #1
 8007d0a:	d10e      	bne.n	8007d2a <I2C_RequestMemoryRead+0x4a>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d0c:	6823      	ldr	r3, [r4, #0]
 8007d0e:	fa5f f288 	uxtb.w	r2, r8
 8007d12:	629a      	str	r2, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8007d14:	9700      	str	r7, [sp, #0]
 8007d16:	4633      	mov	r3, r6
 8007d18:	2200      	movs	r2, #0
 8007d1a:	2140      	movs	r1, #64	; 0x40
 8007d1c:	4620      	mov	r0, r4
 8007d1e:	f7ff ff75 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007d22:	b9a8      	cbnz	r0, 8007d50 <I2C_RequestMemoryRead+0x70>
}
 8007d24:	b002      	add	sp, #8
 8007d26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007d2a:	6823      	ldr	r3, [r4, #0]
 8007d2c:	ea4f 2218 	mov.w	r2, r8, lsr #8
 8007d30:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d32:	463a      	mov	r2, r7
 8007d34:	4631      	mov	r1, r6
 8007d36:	4620      	mov	r0, r4
 8007d38:	f7ff ff3d 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d3c:	b930      	cbnz	r0, 8007d4c <I2C_RequestMemoryRead+0x6c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d3e:	6823      	ldr	r3, [r4, #0]
 8007d40:	fa5f f288 	uxtb.w	r2, r8
 8007d44:	629a      	str	r2, [r3, #40]	; 0x28
 8007d46:	e7e5      	b.n	8007d14 <I2C_RequestMemoryRead+0x34>
    return HAL_ERROR;
 8007d48:	2001      	movs	r0, #1
 8007d4a:	e7eb      	b.n	8007d24 <I2C_RequestMemoryRead+0x44>
      return HAL_ERROR;
 8007d4c:	2001      	movs	r0, #1
 8007d4e:	e7e9      	b.n	8007d24 <I2C_RequestMemoryRead+0x44>
    return HAL_ERROR;
 8007d50:	2001      	movs	r0, #1
 8007d52:	e7e7      	b.n	8007d24 <I2C_RequestMemoryRead+0x44>
 8007d54:	80002000 	.word	0x80002000

08007d58 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007d58:	b570      	push	{r4, r5, r6, lr}
 8007d5a:	4605      	mov	r5, r0
 8007d5c:	460c      	mov	r4, r1
 8007d5e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007d60:	682b      	ldr	r3, [r5, #0]
 8007d62:	699b      	ldr	r3, [r3, #24]
 8007d64:	f013 0f20 	tst.w	r3, #32
 8007d68:	d11a      	bne.n	8007da0 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d6a:	4632      	mov	r2, r6
 8007d6c:	4621      	mov	r1, r4
 8007d6e:	4628      	mov	r0, r5
 8007d70:	f7ff fed9 	bl	8007b26 <I2C_IsAcknowledgeFailed>
 8007d74:	b9b0      	cbnz	r0, 8007da4 <I2C_WaitOnSTOPFlagUntilTimeout+0x4c>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007d76:	f7ff f90f 	bl	8006f98 <HAL_GetTick>
 8007d7a:	1b80      	subs	r0, r0, r6
 8007d7c:	42a0      	cmp	r0, r4
 8007d7e:	d801      	bhi.n	8007d84 <I2C_WaitOnSTOPFlagUntilTimeout+0x2c>
 8007d80:	2c00      	cmp	r4, #0
 8007d82:	d1ed      	bne.n	8007d60 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007d84:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8007d86:	f043 0320 	orr.w	r3, r3, #32
 8007d8a:	646b      	str	r3, [r5, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8007d8c:	2320      	movs	r3, #32
 8007d8e:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8007d92:	2300      	movs	r3, #0
 8007d94:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 8007d98:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      return HAL_ERROR;
 8007d9c:	2001      	movs	r0, #1
}
 8007d9e:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8007da0:	2000      	movs	r0, #0
 8007da2:	e7fc      	b.n	8007d9e <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
      return HAL_ERROR;
 8007da4:	2001      	movs	r0, #1
 8007da6:	e7fa      	b.n	8007d9e <I2C_WaitOnSTOPFlagUntilTimeout+0x46>

08007da8 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8007da8:	2800      	cmp	r0, #0
 8007daa:	d059      	beq.n	8007e60 <HAL_I2C_Init+0xb8>
{
 8007dac:	b510      	push	{r4, lr}
 8007dae:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8007db0:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8007db4:	2b00      	cmp	r3, #0
 8007db6:	d043      	beq.n	8007e40 <HAL_I2C_Init+0x98>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007db8:	2324      	movs	r3, #36	; 0x24
 8007dba:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8007dbe:	6822      	ldr	r2, [r4, #0]
 8007dc0:	6813      	ldr	r3, [r2, #0]
 8007dc2:	f023 0301 	bic.w	r3, r3, #1
 8007dc6:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8007dc8:	6863      	ldr	r3, [r4, #4]
 8007dca:	6822      	ldr	r2, [r4, #0]
 8007dcc:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8007dd0:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007dd2:	6822      	ldr	r2, [r4, #0]
 8007dd4:	6893      	ldr	r3, [r2, #8]
 8007dd6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007dda:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007ddc:	68e3      	ldr	r3, [r4, #12]
 8007dde:	2b01      	cmp	r3, #1
 8007de0:	d033      	beq.n	8007e4a <HAL_I2C_Init+0xa2>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8007de2:	68a3      	ldr	r3, [r4, #8]
 8007de4:	6822      	ldr	r2, [r4, #0]
 8007de6:	f443 4304 	orr.w	r3, r3, #33792	; 0x8400
 8007dea:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8007dec:	68e3      	ldr	r3, [r4, #12]
 8007dee:	2b02      	cmp	r3, #2
 8007df0:	d031      	beq.n	8007e56 <HAL_I2C_Init+0xae>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8007df2:	6822      	ldr	r2, [r4, #0]
 8007df4:	6853      	ldr	r3, [r2, #4]
 8007df6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8007dfa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007dfe:	6053      	str	r3, [r2, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007e00:	6822      	ldr	r2, [r4, #0]
 8007e02:	68d3      	ldr	r3, [r2, #12]
 8007e04:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007e08:	60d3      	str	r3, [r2, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8007e0a:	6923      	ldr	r3, [r4, #16]
 8007e0c:	6962      	ldr	r2, [r4, #20]
 8007e0e:	4313      	orrs	r3, r2
 8007e10:	69a1      	ldr	r1, [r4, #24]
 8007e12:	6822      	ldr	r2, [r4, #0]
 8007e14:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007e18:	60d3      	str	r3, [r2, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8007e1a:	69e3      	ldr	r3, [r4, #28]
 8007e1c:	6a21      	ldr	r1, [r4, #32]
 8007e1e:	6822      	ldr	r2, [r4, #0]
 8007e20:	430b      	orrs	r3, r1
 8007e22:	6013      	str	r3, [r2, #0]
  __HAL_I2C_ENABLE(hi2c);
 8007e24:	6822      	ldr	r2, [r4, #0]
 8007e26:	6813      	ldr	r3, [r2, #0]
 8007e28:	f043 0301 	orr.w	r3, r3, #1
 8007e2c:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e2e:	2000      	movs	r0, #0
 8007e30:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007e32:	2320      	movs	r3, #32
 8007e34:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8007e38:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007e3a:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 8007e3e:	bd10      	pop	{r4, pc}
    hi2c->Lock = HAL_UNLOCKED;
 8007e40:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8007e44:	f7f9 f9a4 	bl	8001190 <HAL_I2C_MspInit>
 8007e48:	e7b6      	b.n	8007db8 <HAL_I2C_Init+0x10>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8007e4a:	68a3      	ldr	r3, [r4, #8]
 8007e4c:	6822      	ldr	r2, [r4, #0]
 8007e4e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007e52:	6093      	str	r3, [r2, #8]
 8007e54:	e7ca      	b.n	8007dec <HAL_I2C_Init+0x44>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007e56:	6823      	ldr	r3, [r4, #0]
 8007e58:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8007e5c:	605a      	str	r2, [r3, #4]
 8007e5e:	e7c8      	b.n	8007df2 <HAL_I2C_Init+0x4a>
    return HAL_ERROR;
 8007e60:	2001      	movs	r0, #1
}
 8007e62:	4770      	bx	lr

08007e64 <HAL_I2C_DeInit>:
  if (hi2c == NULL)
 8007e64:	b1a8      	cbz	r0, 8007e92 <HAL_I2C_DeInit+0x2e>
{
 8007e66:	b510      	push	{r4, lr}
 8007e68:	4604      	mov	r4, r0
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007e6a:	2324      	movs	r3, #36	; 0x24
 8007e6c:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8007e70:	6802      	ldr	r2, [r0, #0]
 8007e72:	6813      	ldr	r3, [r2, #0]
 8007e74:	f023 0301 	bic.w	r3, r3, #1
 8007e78:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8007e7a:	f7f9 f9b9 	bl	80011f0 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e7e:	2000      	movs	r0, #0
 8007e80:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
 8007e82:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8007e86:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007e88:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  __HAL_UNLOCK(hi2c);
 8007e8c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8007e90:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8007e92:	2001      	movs	r0, #1
}
 8007e94:	4770      	bx	lr

08007e96 <HAL_I2C_Mem_Write>:
{
 8007e96:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e9a:	b083      	sub	sp, #12
 8007e9c:	460e      	mov	r6, r1
 8007e9e:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 8007ea2:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 8007ea4:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
 8007ea8:	b2c9      	uxtb	r1, r1
 8007eaa:	2920      	cmp	r1, #32
 8007eac:	f040 80bb 	bne.w	8008026 <HAL_I2C_Mem_Write+0x190>
 8007eb0:	4604      	mov	r4, r0
 8007eb2:	4690      	mov	r8, r2
 8007eb4:	4699      	mov	r9, r3
    if ((pData == NULL) || (Size == 0U))
 8007eb6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007eb8:	b1cb      	cbz	r3, 8007eee <HAL_I2C_Mem_Write+0x58>
 8007eba:	f1ba 0f00 	cmp.w	sl, #0
 8007ebe:	d016      	beq.n	8007eee <HAL_I2C_Mem_Write+0x58>
    __HAL_LOCK(hi2c);
 8007ec0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8007ec4:	2b01      	cmp	r3, #1
 8007ec6:	f000 80b2 	beq.w	800802e <HAL_I2C_Mem_Write+0x198>
 8007eca:	f04f 0b01 	mov.w	fp, #1
 8007ece:	f880 b040 	strb.w	fp, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8007ed2:	f7ff f861 	bl	8006f98 <HAL_GetTick>
 8007ed6:	4607      	mov	r7, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007ed8:	9000      	str	r0, [sp, #0]
 8007eda:	2319      	movs	r3, #25
 8007edc:	465a      	mov	r2, fp
 8007ede:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007ee2:	4620      	mov	r0, r4
 8007ee4:	f7ff fe92 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007ee8:	b130      	cbz	r0, 8007ef8 <HAL_I2C_Mem_Write+0x62>
      return HAL_ERROR;
 8007eea:	2001      	movs	r0, #1
 8007eec:	e09c      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8007eee:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007ef2:	6463      	str	r3, [r4, #68]	; 0x44
      return  HAL_ERROR;
 8007ef4:	2001      	movs	r0, #1
 8007ef6:	e097      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007ef8:	2321      	movs	r3, #33	; 0x21
 8007efa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007efe:	2340      	movs	r3, #64	; 0x40
 8007f00:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007f04:	2300      	movs	r3, #0
 8007f06:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007f08:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007f0a:	6262      	str	r2, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007f0c:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8007f10:	6363      	str	r3, [r4, #52]	; 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007f12:	9701      	str	r7, [sp, #4]
 8007f14:	9500      	str	r5, [sp, #0]
 8007f16:	464b      	mov	r3, r9
 8007f18:	4642      	mov	r2, r8
 8007f1a:	4631      	mov	r1, r6
 8007f1c:	4620      	mov	r0, r4
 8007f1e:	f7ff fea1 	bl	8007c64 <I2C_RequestMemoryWrite>
 8007f22:	b970      	cbnz	r0, 8007f42 <HAL_I2C_Mem_Write+0xac>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007f24:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f26:	b29b      	uxth	r3, r3
 8007f28:	2bff      	cmp	r3, #255	; 0xff
 8007f2a:	d90f      	bls.n	8007f4c <HAL_I2C_Mem_Write+0xb6>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f2c:	22ff      	movs	r2, #255	; 0xff
 8007f2e:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f30:	2300      	movs	r3, #0
 8007f32:	9300      	str	r3, [sp, #0]
 8007f34:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007f38:	4631      	mov	r1, r6
 8007f3a:	4620      	mov	r0, r4
 8007f3c:	f7ff fdd7 	bl	8007aee <I2C_TransferConfig>
 8007f40:	e021      	b.n	8007f86 <HAL_I2C_Mem_Write+0xf0>
      __HAL_UNLOCK(hi2c);
 8007f42:	2300      	movs	r3, #0
 8007f44:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8007f48:	4658      	mov	r0, fp
 8007f4a:	e06d      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
      hi2c->XferSize = hi2c->XferCount;
 8007f4c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007f4e:	b292      	uxth	r2, r2
 8007f50:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f52:	2300      	movs	r3, #0
 8007f54:	9300      	str	r3, [sp, #0]
 8007f56:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007f5a:	b2d2      	uxtb	r2, r2
 8007f5c:	4631      	mov	r1, r6
 8007f5e:	4620      	mov	r0, r4
 8007f60:	f7ff fdc5 	bl	8007aee <I2C_TransferConfig>
 8007f64:	e00f      	b.n	8007f86 <HAL_I2C_Mem_Write+0xf0>
          hi2c->XferSize = hi2c->XferCount;
 8007f66:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007f68:	b292      	uxth	r2, r2
 8007f6a:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f6c:	2300      	movs	r3, #0
 8007f6e:	9300      	str	r3, [sp, #0]
 8007f70:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007f74:	b2d2      	uxtb	r2, r2
 8007f76:	4631      	mov	r1, r6
 8007f78:	4620      	mov	r0, r4
 8007f7a:	f7ff fdb8 	bl	8007aee <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
 8007f7e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f80:	b29b      	uxth	r3, r3
 8007f82:	2b00      	cmp	r3, #0
 8007f84:	d033      	beq.n	8007fee <HAL_I2C_Mem_Write+0x158>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007f86:	463a      	mov	r2, r7
 8007f88:	4629      	mov	r1, r5
 8007f8a:	4620      	mov	r0, r4
 8007f8c:	f7ff fe13 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007f90:	2800      	cmp	r0, #0
 8007f92:	d14e      	bne.n	8008032 <HAL_I2C_Mem_Write+0x19c>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8007f94:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8007f96:	6823      	ldr	r3, [r4, #0]
 8007f98:	7812      	ldrb	r2, [r2, #0]
 8007f9a:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->pBuffPtr++;
 8007f9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f9e:	3301      	adds	r3, #1
 8007fa0:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8007fa2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fa4:	b29b      	uxth	r3, r3
 8007fa6:	3b01      	subs	r3, #1
 8007fa8:	b29b      	uxth	r3, r3
 8007faa:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007fac:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8007fae:	3b01      	subs	r3, #1
 8007fb0:	b29b      	uxth	r3, r3
 8007fb2:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8007fb4:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007fb6:	b292      	uxth	r2, r2
 8007fb8:	2a00      	cmp	r2, #0
 8007fba:	d0e0      	beq.n	8007f7e <HAL_I2C_Mem_Write+0xe8>
 8007fbc:	2b00      	cmp	r3, #0
 8007fbe:	d1de      	bne.n	8007f7e <HAL_I2C_Mem_Write+0xe8>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007fc0:	9700      	str	r7, [sp, #0]
 8007fc2:	462b      	mov	r3, r5
 8007fc4:	2200      	movs	r2, #0
 8007fc6:	2180      	movs	r1, #128	; 0x80
 8007fc8:	4620      	mov	r0, r4
 8007fca:	f7ff fe1f 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007fce:	bb90      	cbnz	r0, 8008036 <HAL_I2C_Mem_Write+0x1a0>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007fd0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fd2:	b29b      	uxth	r3, r3
 8007fd4:	2bff      	cmp	r3, #255	; 0xff
 8007fd6:	d9c6      	bls.n	8007f66 <HAL_I2C_Mem_Write+0xd0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007fd8:	22ff      	movs	r2, #255	; 0xff
 8007fda:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007fdc:	2300      	movs	r3, #0
 8007fde:	9300      	str	r3, [sp, #0]
 8007fe0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007fe4:	4631      	mov	r1, r6
 8007fe6:	4620      	mov	r0, r4
 8007fe8:	f7ff fd81 	bl	8007aee <I2C_TransferConfig>
 8007fec:	e7c7      	b.n	8007f7e <HAL_I2C_Mem_Write+0xe8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007fee:	463a      	mov	r2, r7
 8007ff0:	4629      	mov	r1, r5
 8007ff2:	4620      	mov	r0, r4
 8007ff4:	f7ff feb0 	bl	8007d58 <I2C_WaitOnSTOPFlagUntilTimeout>
 8007ff8:	b9f8      	cbnz	r0, 800803a <HAL_I2C_Mem_Write+0x1a4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007ffa:	6823      	ldr	r3, [r4, #0]
 8007ffc:	2220      	movs	r2, #32
 8007ffe:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8008000:	6821      	ldr	r1, [r4, #0]
 8008002:	684b      	ldr	r3, [r1, #4]
 8008004:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8008008:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 800800c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8008010:	f023 0301 	bic.w	r3, r3, #1
 8008014:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8008016:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800801a:	2300      	movs	r3, #0
 800801c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8008020:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_OK;
 8008024:	e000      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
    return HAL_BUSY;
 8008026:	2002      	movs	r0, #2
}
 8008028:	b003      	add	sp, #12
 800802a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 800802e:	2002      	movs	r0, #2
 8008030:	e7fa      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
        return HAL_ERROR;
 8008032:	2001      	movs	r0, #1
 8008034:	e7f8      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
          return HAL_ERROR;
 8008036:	2001      	movs	r0, #1
 8008038:	e7f6      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
      return HAL_ERROR;
 800803a:	2001      	movs	r0, #1
 800803c:	e7f4      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
	...

08008040 <HAL_I2C_Mem_Read>:
{
 8008040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008044:	b083      	sub	sp, #12
 8008046:	460e      	mov	r6, r1
 8008048:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 800804c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 800804e:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
 8008052:	b2c9      	uxtb	r1, r1
 8008054:	2920      	cmp	r1, #32
 8008056:	f040 80bc 	bne.w	80081d2 <HAL_I2C_Mem_Read+0x192>
 800805a:	4604      	mov	r4, r0
 800805c:	4690      	mov	r8, r2
 800805e:	4699      	mov	r9, r3
    if ((pData == NULL) || (Size == 0U))
 8008060:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008062:	b1cb      	cbz	r3, 8008098 <HAL_I2C_Mem_Read+0x58>
 8008064:	f1ba 0f00 	cmp.w	sl, #0
 8008068:	d016      	beq.n	8008098 <HAL_I2C_Mem_Read+0x58>
    __HAL_LOCK(hi2c);
 800806a:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800806e:	2b01      	cmp	r3, #1
 8008070:	f000 80b3 	beq.w	80081da <HAL_I2C_Mem_Read+0x19a>
 8008074:	f04f 0b01 	mov.w	fp, #1
 8008078:	f880 b040 	strb.w	fp, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 800807c:	f7fe ff8c 	bl	8006f98 <HAL_GetTick>
 8008080:	4607      	mov	r7, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8008082:	9000      	str	r0, [sp, #0]
 8008084:	2319      	movs	r3, #25
 8008086:	465a      	mov	r2, fp
 8008088:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800808c:	4620      	mov	r0, r4
 800808e:	f7ff fdbd 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8008092:	b130      	cbz	r0, 80080a2 <HAL_I2C_Mem_Read+0x62>
      return HAL_ERROR;
 8008094:	2001      	movs	r0, #1
 8008096:	e09d      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8008098:	f44f 7300 	mov.w	r3, #512	; 0x200
 800809c:	6463      	str	r3, [r4, #68]	; 0x44
      return  HAL_ERROR;
 800809e:	2001      	movs	r0, #1
 80080a0:	e098      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80080a2:	2322      	movs	r3, #34	; 0x22
 80080a4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80080a8:	2340      	movs	r3, #64	; 0x40
 80080aa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80080ae:	2300      	movs	r3, #0
 80080b0:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 80080b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80080b4:	6262      	str	r2, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 80080b6:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 80080ba:	6363      	str	r3, [r4, #52]	; 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80080bc:	9701      	str	r7, [sp, #4]
 80080be:	9500      	str	r5, [sp, #0]
 80080c0:	464b      	mov	r3, r9
 80080c2:	4642      	mov	r2, r8
 80080c4:	4631      	mov	r1, r6
 80080c6:	4620      	mov	r0, r4
 80080c8:	f7ff fe0a 	bl	8007ce0 <I2C_RequestMemoryRead>
 80080cc:	b970      	cbnz	r0, 80080ec <HAL_I2C_Mem_Read+0xac>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80080ce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80080d0:	b29b      	uxth	r3, r3
 80080d2:	2bff      	cmp	r3, #255	; 0xff
 80080d4:	d90f      	bls.n	80080f6 <HAL_I2C_Mem_Read+0xb6>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80080d6:	22ff      	movs	r2, #255	; 0xff
 80080d8:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80080da:	4b44      	ldr	r3, [pc, #272]	; (80081ec <HAL_I2C_Mem_Read+0x1ac>)
 80080dc:	9300      	str	r3, [sp, #0]
 80080de:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80080e2:	4631      	mov	r1, r6
 80080e4:	4620      	mov	r0, r4
 80080e6:	f7ff fd02 	bl	8007aee <I2C_TransferConfig>
 80080ea:	e021      	b.n	8008130 <HAL_I2C_Mem_Read+0xf0>
      __HAL_UNLOCK(hi2c);
 80080ec:	2300      	movs	r3, #0
 80080ee:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 80080f2:	4658      	mov	r0, fp
 80080f4:	e06e      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
      hi2c->XferSize = hi2c->XferCount;
 80080f6:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80080f8:	b292      	uxth	r2, r2
 80080fa:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80080fc:	4b3b      	ldr	r3, [pc, #236]	; (80081ec <HAL_I2C_Mem_Read+0x1ac>)
 80080fe:	9300      	str	r3, [sp, #0]
 8008100:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008104:	b2d2      	uxtb	r2, r2
 8008106:	4631      	mov	r1, r6
 8008108:	4620      	mov	r0, r4
 800810a:	f7ff fcf0 	bl	8007aee <I2C_TransferConfig>
 800810e:	e00f      	b.n	8008130 <HAL_I2C_Mem_Read+0xf0>
          hi2c->XferSize = hi2c->XferCount;
 8008110:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8008112:	b292      	uxth	r2, r2
 8008114:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008116:	2300      	movs	r3, #0
 8008118:	9300      	str	r3, [sp, #0]
 800811a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800811e:	b2d2      	uxtb	r2, r2
 8008120:	4631      	mov	r1, r6
 8008122:	4620      	mov	r0, r4
 8008124:	f7ff fce3 	bl	8007aee <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
 8008128:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800812a:	b29b      	uxth	r3, r3
 800812c:	2b00      	cmp	r3, #0
 800812e:	d034      	beq.n	800819a <HAL_I2C_Mem_Read+0x15a>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8008130:	9700      	str	r7, [sp, #0]
 8008132:	462b      	mov	r3, r5
 8008134:	2200      	movs	r2, #0
 8008136:	2104      	movs	r1, #4
 8008138:	4620      	mov	r0, r4
 800813a:	f7ff fd67 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 800813e:	2800      	cmp	r0, #0
 8008140:	d14d      	bne.n	80081de <HAL_I2C_Mem_Read+0x19e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8008142:	6823      	ldr	r3, [r4, #0]
 8008144:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008146:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008148:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 800814a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800814c:	3301      	adds	r3, #1
 800814e:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8008150:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8008152:	3a01      	subs	r2, #1
 8008154:	b292      	uxth	r2, r2
 8008156:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8008158:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800815a:	b29b      	uxth	r3, r3
 800815c:	3b01      	subs	r3, #1
 800815e:	b29b      	uxth	r3, r3
 8008160:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8008162:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008164:	b29b      	uxth	r3, r3
 8008166:	2b00      	cmp	r3, #0
 8008168:	d0de      	beq.n	8008128 <HAL_I2C_Mem_Read+0xe8>
 800816a:	2a00      	cmp	r2, #0
 800816c:	d1dc      	bne.n	8008128 <HAL_I2C_Mem_Read+0xe8>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800816e:	9700      	str	r7, [sp, #0]
 8008170:	462b      	mov	r3, r5
 8008172:	2180      	movs	r1, #128	; 0x80
 8008174:	4620      	mov	r0, r4
 8008176:	f7ff fd49 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 800817a:	bb90      	cbnz	r0, 80081e2 <HAL_I2C_Mem_Read+0x1a2>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800817c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800817e:	b29b      	uxth	r3, r3
 8008180:	2bff      	cmp	r3, #255	; 0xff
 8008182:	d9c5      	bls.n	8008110 <HAL_I2C_Mem_Read+0xd0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8008184:	22ff      	movs	r2, #255	; 0xff
 8008186:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008188:	2300      	movs	r3, #0
 800818a:	9300      	str	r3, [sp, #0]
 800818c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8008190:	4631      	mov	r1, r6
 8008192:	4620      	mov	r0, r4
 8008194:	f7ff fcab 	bl	8007aee <I2C_TransferConfig>
 8008198:	e7c6      	b.n	8008128 <HAL_I2C_Mem_Read+0xe8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800819a:	463a      	mov	r2, r7
 800819c:	4629      	mov	r1, r5
 800819e:	4620      	mov	r0, r4
 80081a0:	f7ff fdda 	bl	8007d58 <I2C_WaitOnSTOPFlagUntilTimeout>
 80081a4:	b9f8      	cbnz	r0, 80081e6 <HAL_I2C_Mem_Read+0x1a6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80081a6:	6823      	ldr	r3, [r4, #0]
 80081a8:	2220      	movs	r2, #32
 80081aa:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
 80081ac:	6821      	ldr	r1, [r4, #0]
 80081ae:	684b      	ldr	r3, [r1, #4]
 80081b0:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 80081b4:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 80081b8:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 80081bc:	f023 0301 	bic.w	r3, r3, #1
 80081c0:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80081c2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80081c6:	2300      	movs	r3, #0
 80081c8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 80081cc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_OK;
 80081d0:	e000      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
    return HAL_BUSY;
 80081d2:	2002      	movs	r0, #2
}
 80081d4:	b003      	add	sp, #12
 80081d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 80081da:	2002      	movs	r0, #2
 80081dc:	e7fa      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
        return HAL_ERROR;
 80081de:	2001      	movs	r0, #1
 80081e0:	e7f8      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
          return HAL_ERROR;
 80081e2:	2001      	movs	r0, #1
 80081e4:	e7f6      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
      return HAL_ERROR;
 80081e6:	2001      	movs	r0, #1
 80081e8:	e7f4      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
 80081ea:	bf00      	nop
 80081ec:	80002400 	.word	0x80002400

080081f0 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 80081f0:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80081f2:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 80081f6:	b2d2      	uxtb	r2, r2
 80081f8:	2a20      	cmp	r2, #32
 80081fa:	d123      	bne.n	8008244 <HAL_I2CEx_ConfigAnalogFilter+0x54>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80081fc:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8008200:	2a01      	cmp	r2, #1
 8008202:	d021      	beq.n	8008248 <HAL_I2CEx_ConfigAnalogFilter+0x58>
 8008204:	2201      	movs	r2, #1
 8008206:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800820a:	2224      	movs	r2, #36	; 0x24
 800820c:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8008210:	6800      	ldr	r0, [r0, #0]
 8008212:	6802      	ldr	r2, [r0, #0]
 8008214:	f022 0201 	bic.w	r2, r2, #1
 8008218:	6002      	str	r2, [r0, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800821a:	6818      	ldr	r0, [r3, #0]
 800821c:	6802      	ldr	r2, [r0, #0]
 800821e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8008222:	6002      	str	r2, [r0, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8008224:	6818      	ldr	r0, [r3, #0]
 8008226:	6802      	ldr	r2, [r0, #0]
 8008228:	4311      	orrs	r1, r2
 800822a:	6001      	str	r1, [r0, #0]

    __HAL_I2C_ENABLE(hi2c);
 800822c:	6819      	ldr	r1, [r3, #0]
 800822e:	680a      	ldr	r2, [r1, #0]
 8008230:	f042 0201 	orr.w	r2, r2, #1
 8008234:	600a      	str	r2, [r1, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8008236:	2220      	movs	r2, #32
 8008238:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800823c:	2000      	movs	r0, #0
 800823e:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40

    return HAL_OK;
 8008242:	4770      	bx	lr
  }
  else
  {
    return HAL_BUSY;
 8008244:	2002      	movs	r0, #2
 8008246:	4770      	bx	lr
    __HAL_LOCK(hi2c);
 8008248:	2002      	movs	r0, #2
  }
}
 800824a:	4770      	bx	lr

0800824c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800824c:	4603      	mov	r3, r0

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800824e:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8008252:	b2d2      	uxtb	r2, r2
 8008254:	2a20      	cmp	r2, #32
 8008256:	d121      	bne.n	800829c <HAL_I2CEx_ConfigDigitalFilter+0x50>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8008258:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 800825c:	2a01      	cmp	r2, #1
 800825e:	d01f      	beq.n	80082a0 <HAL_I2CEx_ConfigDigitalFilter+0x54>
 8008260:	2201      	movs	r2, #1
 8008262:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 8008266:	2224      	movs	r2, #36	; 0x24
 8008268:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800826c:	6800      	ldr	r0, [r0, #0]
 800826e:	6802      	ldr	r2, [r0, #0]
 8008270:	f022 0201 	bic.w	r2, r2, #1
 8008274:	6002      	str	r2, [r0, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8008276:	6818      	ldr	r0, [r3, #0]
 8008278:	6802      	ldr	r2, [r0, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 800827a:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800827e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8008282:	6002      	str	r2, [r0, #0]

    __HAL_I2C_ENABLE(hi2c);
 8008284:	6819      	ldr	r1, [r3, #0]
 8008286:	680a      	ldr	r2, [r1, #0]
 8008288:	f042 0201 	orr.w	r2, r2, #1
 800828c:	600a      	str	r2, [r1, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800828e:	2220      	movs	r2, #32
 8008290:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8008294:	2000      	movs	r0, #0
 8008296:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40

    return HAL_OK;
 800829a:	4770      	bx	lr
  }
  else
  {
    return HAL_BUSY;
 800829c:	2002      	movs	r0, #2
 800829e:	4770      	bx	lr
    __HAL_LOCK(hi2c);
 80082a0:	2002      	movs	r0, #2
  }
}
 80082a2:	4770      	bx	lr

080082a4 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80082a4:	b570      	push	{r4, r5, r6, lr}
 80082a6:	b086      	sub	sp, #24
  USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80082a8:	2800      	cmp	r0, #0
 80082aa:	f000 808c 	beq.w	80083c6 <HAL_PCD_Init+0x122>
 80082ae:	4604      	mov	r4, r0

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80082b0:	f890 32a9 	ldrb.w	r3, [r0, #681]	; 0x2a9
 80082b4:	b1eb      	cbz	r3, 80082f2 <HAL_PCD_Init+0x4e>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80082b6:	2303      	movs	r3, #3
 80082b8:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
    hpcd->Init.dma_enable = 0U;
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80082bc:	6820      	ldr	r0, [r4, #0]
 80082be:	f002 fbcd 	bl	800aa5c <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80082c2:	4625      	mov	r5, r4
 80082c4:	f855 6b10 	ldr.w	r6, [r5], #16
 80082c8:	46ec      	mov	ip, sp
 80082ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80082cc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80082d0:	682b      	ldr	r3, [r5, #0]
 80082d2:	f8cc 3000 	str.w	r3, [ip]
 80082d6:	1d23      	adds	r3, r4, #4
 80082d8:	cb0e      	ldmia	r3, {r1, r2, r3}
 80082da:	4630      	mov	r0, r6
 80082dc:	f002 fbb7 	bl	800aa4e <USB_CoreInit>
 80082e0:	4605      	mov	r5, r0
 80082e2:	b158      	cbz	r0, 80082fc <HAL_PCD_Init+0x58>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80082e4:	2302      	movs	r3, #2
 80082e6:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
    return HAL_ERROR;
 80082ea:	2501      	movs	r5, #1
  }
  
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 80082ec:	4628      	mov	r0, r5
 80082ee:	b006      	add	sp, #24
 80082f0:	bd70      	pop	{r4, r5, r6, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80082f2:	f880 32a8 	strb.w	r3, [r0, #680]	; 0x2a8
    HAL_PCD_MspInit(hpcd);
 80082f6:	f7f9 fcdb 	bl	8001cb0 <HAL_PCD_MspInit>
 80082fa:	e7dc      	b.n	80082b6 <HAL_PCD_Init+0x12>
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80082fc:	2100      	movs	r1, #0
 80082fe:	6820      	ldr	r0, [r4, #0]
 8008300:	f002 fbb6 	bl	800aa70 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8008304:	462b      	mov	r3, r5
 8008306:	e01a      	b.n	800833e <HAL_PCD_Init+0x9a>
    hpcd->IN_ep[i].is_in = 1U;
 8008308:	1c5a      	adds	r2, r3, #1
 800830a:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800830e:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8008312:	2001      	movs	r0, #1
 8008314:	7048      	strb	r0, [r1, #1]
    hpcd->IN_ep[i].num = i;
 8008316:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800831a:	f804 3031 	strb.w	r3, [r4, r1, lsl #3]
    hpcd->IN_ep[i].tx_fifo_num = i;
 800831e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8008322:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8008326:	86cb      	strh	r3, [r1, #54]	; 0x36
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8008328:	eb02 0c82 	add.w	ip, r2, r2, lsl #2
 800832c:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
 8008330:	2000      	movs	r0, #0
 8008332:	f88c 0003 	strb.w	r0, [ip, #3]
    hpcd->IN_ep[i].maxpacket = 0U;
 8008336:	6388      	str	r0, [r1, #56]	; 0x38
    hpcd->IN_ep[i].xfer_buff = 0U;
 8008338:	63c8      	str	r0, [r1, #60]	; 0x3c
    hpcd->IN_ep[i].xfer_len = 0U;
 800833a:	6408      	str	r0, [r1, #64]	; 0x40
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800833c:	b2d3      	uxtb	r3, r2
 800833e:	6861      	ldr	r1, [r4, #4]
 8008340:	428b      	cmp	r3, r1
 8008342:	d3e1      	bcc.n	8008308 <HAL_PCD_Init+0x64>
 8008344:	e016      	b.n	8008374 <HAL_PCD_Init+0xd0>
    hpcd->OUT_ep[i].is_in = 0U;
 8008346:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 800834a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 800834e:	2200      	movs	r2, #0
 8008350:	f883 2169 	strb.w	r2, [r3, #361]	; 0x169
    hpcd->OUT_ep[i].num = i;
 8008354:	f883 5168 	strb.w	r5, [r3, #360]	; 0x168
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8008358:	f883 216b 	strb.w	r2, [r3, #363]	; 0x16b
    hpcd->OUT_ep[i].maxpacket = 0U;
 800835c:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8008360:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
    hpcd->OUT_ep[i].xfer_len = 0U;
 8008364:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 8008368:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 800836c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8008370:	3501      	adds	r5, #1
 8008372:	b2ed      	uxtb	r5, r5
 8008374:	42a9      	cmp	r1, r5
 8008376:	d8e6      	bhi.n	8008346 <HAL_PCD_Init+0xa2>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8008378:	4625      	mov	r5, r4
 800837a:	f855 6b10 	ldr.w	r6, [r5], #16
 800837e:	46ec      	mov	ip, sp
 8008380:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008382:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8008386:	682b      	ldr	r3, [r5, #0]
 8008388:	f8cc 3000 	str.w	r3, [ip]
 800838c:	1d23      	adds	r3, r4, #4
 800838e:	cb0e      	ldmia	r3, {r1, r2, r3}
 8008390:	4630      	mov	r0, r6
 8008392:	f002 fb6f 	bl	800aa74 <USB_DevInit>
 8008396:	4605      	mov	r5, r0
 8008398:	b960      	cbnz	r0, 80083b4 <HAL_PCD_Init+0x110>
  hpcd->USB_Address = 0U;
 800839a:	2300      	movs	r3, #0
 800839c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  hpcd->State = HAL_PCD_STATE_READY;
 80083a0:	2301      	movs	r3, #1
 80083a2:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
  if (hpcd->Init.lpm_enable == 1U)
 80083a6:	69e3      	ldr	r3, [r4, #28]
 80083a8:	2b01      	cmp	r3, #1
 80083aa:	d008      	beq.n	80083be <HAL_PCD_Init+0x11a>
  (void)USB_DevDisconnect(hpcd->Instance);
 80083ac:	6820      	ldr	r0, [r4, #0]
 80083ae:	f002 fb72 	bl	800aa96 <USB_DevDisconnect>
  return HAL_OK;
 80083b2:	e79b      	b.n	80082ec <HAL_PCD_Init+0x48>
    hpcd->State = HAL_PCD_STATE_ERROR;
 80083b4:	2302      	movs	r3, #2
 80083b6:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
    return HAL_ERROR;
 80083ba:	2501      	movs	r5, #1
 80083bc:	e796      	b.n	80082ec <HAL_PCD_Init+0x48>
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 80083be:	4620      	mov	r0, r4
 80083c0:	f000 f803 	bl	80083ca <HAL_PCDEx_ActivateLPM>
 80083c4:	e7f2      	b.n	80083ac <HAL_PCD_Init+0x108>
    return HAL_ERROR;
 80083c6:	2501      	movs	r5, #1
 80083c8:	e790      	b.n	80082ec <HAL_PCD_Init+0x48>

080083ca <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 80083ca:	4603      	mov	r3, r0

  USB_TypeDef *USBx = hpcd->Instance;
 80083cc:	6802      	ldr	r2, [r0, #0]
  hpcd->lpm_active = 1U;
 80083ce:	2101      	movs	r1, #1
 80083d0:	f8c0 12e8 	str.w	r1, [r0, #744]	; 0x2e8
  hpcd->LPM_State = LPM_L0;
 80083d4:	2000      	movs	r0, #0
 80083d6:	f883 02e0 	strb.w	r0, [r3, #736]	; 0x2e0

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 80083da:	f8b2 3054 	ldrh.w	r3, [r2, #84]	; 0x54
 80083de:	b29b      	uxth	r3, r3
 80083e0:	430b      	orrs	r3, r1
 80083e2:	f8a2 3054 	strh.w	r3, [r2, #84]	; 0x54
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 80083e6:	f8b2 3054 	ldrh.w	r3, [r2, #84]	; 0x54
 80083ea:	b29b      	uxth	r3, r3
 80083ec:	f043 0302 	orr.w	r3, r3, #2
 80083f0:	f8a2 3054 	strh.w	r3, [r2, #84]	; 0x54

  return HAL_OK;
}
 80083f4:	4770      	bx	lr
	...

080083f8 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80083f8:	4a02      	ldr	r2, [pc, #8]	; (8008404 <HAL_PWR_EnableBkUpAccess+0xc>)
 80083fa:	6813      	ldr	r3, [r2, #0]
 80083fc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008400:	6013      	str	r3, [r2, #0]
}
 8008402:	4770      	bx	lr
 8008404:	40007000 	.word	0x40007000

08008408 <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8008408:	4b02      	ldr	r3, [pc, #8]	; (8008414 <HAL_PWREx_GetVoltageRange+0xc>)
 800840a:	6818      	ldr	r0, [r3, #0]
#endif
}
 800840c:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8008410:	4770      	bx	lr
 8008412:	bf00      	nop
 8008414:	40007000 	.word	0x40007000

08008418 <HAL_PWREx_ControlVoltageScaling>:
  }

#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8008418:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800841c:	d00f      	beq.n	800843e <HAL_PWREx_ControlVoltageScaling+0x26>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 800841e:	4b1f      	ldr	r3, [pc, #124]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008420:	681b      	ldr	r3, [r3, #0]
 8008422:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8008426:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800842a:	d034      	beq.n	8008496 <HAL_PWREx_ControlVoltageScaling+0x7e>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 800842c:	4a1b      	ldr	r2, [pc, #108]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 800842e:	6813      	ldr	r3, [r2, #0]
 8008430:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8008434:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008438:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 800843a:	2000      	movs	r0, #0
 800843c:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 800843e:	4b17      	ldr	r3, [pc, #92]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008440:	681b      	ldr	r3, [r3, #0]
 8008442:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8008446:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800844a:	d020      	beq.n	800848e <HAL_PWREx_ControlVoltageScaling+0x76>
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800844c:	4a13      	ldr	r2, [pc, #76]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 800844e:	6813      	ldr	r3, [r2, #0]
 8008450:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8008454:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008458:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800845a:	4b11      	ldr	r3, [pc, #68]	; (80084a0 <HAL_PWREx_ControlVoltageScaling+0x88>)
 800845c:	681b      	ldr	r3, [r3, #0]
 800845e:	2232      	movs	r2, #50	; 0x32
 8008460:	fb02 f303 	mul.w	r3, r2, r3
 8008464:	4a0f      	ldr	r2, [pc, #60]	; (80084a4 <HAL_PWREx_ControlVoltageScaling+0x8c>)
 8008466:	fba2 2303 	umull	r2, r3, r2, r3
 800846a:	0c9b      	lsrs	r3, r3, #18
 800846c:	3301      	adds	r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800846e:	e000      	b.n	8008472 <HAL_PWREx_ControlVoltageScaling+0x5a>
        wait_loop_index--;
 8008470:	3b01      	subs	r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8008472:	4a0a      	ldr	r2, [pc, #40]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008474:	6952      	ldr	r2, [r2, #20]
 8008476:	f412 6f80 	tst.w	r2, #1024	; 0x400
 800847a:	d001      	beq.n	8008480 <HAL_PWREx_ControlVoltageScaling+0x68>
 800847c:	2b00      	cmp	r3, #0
 800847e:	d1f7      	bne.n	8008470 <HAL_PWREx_ControlVoltageScaling+0x58>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8008480:	4b06      	ldr	r3, [pc, #24]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008482:	695b      	ldr	r3, [r3, #20]
 8008484:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008488:	d103      	bne.n	8008492 <HAL_PWREx_ControlVoltageScaling+0x7a>
  return HAL_OK;
 800848a:	2000      	movs	r0, #0
 800848c:	4770      	bx	lr
 800848e:	2000      	movs	r0, #0
 8008490:	4770      	bx	lr
        return HAL_TIMEOUT;
 8008492:	2003      	movs	r0, #3
 8008494:	4770      	bx	lr
  return HAL_OK;
 8008496:	2000      	movs	r0, #0
}
 8008498:	4770      	bx	lr
 800849a:	bf00      	nop
 800849c:	40007000 	.word	0x40007000
 80084a0:	20000034 	.word	0x20000034
 80084a4:	431bde83 	.word	0x431bde83

080084a8 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 80084a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80084ac:	4605      	mov	r5, r0
 80084ae:	460f      	mov	r7, r1
 80084b0:	4616      	mov	r6, r2
 80084b2:	4699      	mov	r9, r3
 80084b4:	f8dd 8020 	ldr.w	r8, [sp, #32]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80084b8:	682c      	ldr	r4, [r5, #0]
 80084ba:	68a4      	ldr	r4, [r4, #8]
 80084bc:	423c      	tst	r4, r7
 80084be:	bf14      	ite	ne
 80084c0:	f04f 0c01 	movne.w	ip, #1
 80084c4:	f04f 0c00 	moveq.w	ip, #0
 80084c8:	45b4      	cmp	ip, r6
 80084ca:	d014      	beq.n	80084f6 <QSPI_WaitFlagStateUntilTimeout+0x4e>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80084cc:	f1b8 3fff 	cmp.w	r8, #4294967295
 80084d0:	d0f2      	beq.n	80084b8 <QSPI_WaitFlagStateUntilTimeout+0x10>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80084d2:	f7fe fd61 	bl	8006f98 <HAL_GetTick>
 80084d6:	eba0 0009 	sub.w	r0, r0, r9
 80084da:	4540      	cmp	r0, r8
 80084dc:	d802      	bhi.n	80084e4 <QSPI_WaitFlagStateUntilTimeout+0x3c>
 80084de:	f1b8 0f00 	cmp.w	r8, #0
 80084e2:	d1e9      	bne.n	80084b8 <QSPI_WaitFlagStateUntilTimeout+0x10>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80084e4:	2304      	movs	r3, #4
 80084e6:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80084ea:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80084ec:	f043 0301 	orr.w	r3, r3, #1
 80084f0:	646b      	str	r3, [r5, #68]	; 0x44

        return HAL_ERROR;
 80084f2:	2001      	movs	r0, #1
 80084f4:	e000      	b.n	80084f8 <QSPI_WaitFlagStateUntilTimeout+0x50>
      }
    }
  }
  return HAL_OK;
 80084f6:	2000      	movs	r0, #0
}
 80084f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080084fc <HAL_QSPI_SetTimeout>:
  hqspi->Timeout = Timeout;
 80084fc:	6481      	str	r1, [r0, #72]	; 0x48
}
 80084fe:	4770      	bx	lr

08008500 <HAL_QSPI_Init>:
{
 8008500:	b570      	push	{r4, r5, r6, lr}
 8008502:	b082      	sub	sp, #8
 8008504:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8008506:	f7fe fd47 	bl	8006f98 <HAL_GetTick>
  if(hqspi == NULL)
 800850a:	2c00      	cmp	r4, #0
 800850c:	d04c      	beq.n	80085a8 <HAL_QSPI_Init+0xa8>
 800850e:	4606      	mov	r6, r0
  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8008510:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008514:	2b00      	cmp	r3, #0
 8008516:	d03c      	beq.n	8008592 <HAL_QSPI_Init+0x92>
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8008518:	6825      	ldr	r5, [r4, #0]
 800851a:	682a      	ldr	r2, [r5, #0]
 800851c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 8008520:	68a1      	ldr	r1, [r4, #8]
 8008522:	3901      	subs	r1, #1
 8008524:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8008528:	602a      	str	r2, [r5, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 800852a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800852c:	9300      	str	r3, [sp, #0]
 800852e:	4633      	mov	r3, r6
 8008530:	2200      	movs	r2, #0
 8008532:	2120      	movs	r1, #32
 8008534:	4620      	mov	r0, r4
 8008536:	f7ff ffb7 	bl	80084a8 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
 800853a:	bb28      	cbnz	r0, 8008588 <HAL_QSPI_Init+0x88>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 800853c:	6821      	ldr	r1, [r4, #0]
 800853e:	680b      	ldr	r3, [r1, #0]
 8008540:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8008544:	f023 03d0 	bic.w	r3, r3, #208	; 0xd0
 8008548:	6865      	ldr	r5, [r4, #4]
 800854a:	68e2      	ldr	r2, [r4, #12]
 800854c:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
 8008550:	69e5      	ldr	r5, [r4, #28]
 8008552:	432a      	orrs	r2, r5
 8008554:	6a25      	ldr	r5, [r4, #32]
 8008556:	432a      	orrs	r2, r5
 8008558:	4313      	orrs	r3, r2
 800855a:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 800855c:	6821      	ldr	r1, [r4, #0]
 800855e:	684a      	ldr	r2, [r1, #4]
 8008560:	4b12      	ldr	r3, [pc, #72]	; (80085ac <HAL_QSPI_Init+0xac>)
 8008562:	4013      	ands	r3, r2
 8008564:	6925      	ldr	r5, [r4, #16]
 8008566:	6962      	ldr	r2, [r4, #20]
 8008568:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 800856c:	69a5      	ldr	r5, [r4, #24]
 800856e:	432a      	orrs	r2, r5
 8008570:	4313      	orrs	r3, r2
 8008572:	604b      	str	r3, [r1, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8008574:	6822      	ldr	r2, [r4, #0]
 8008576:	6813      	ldr	r3, [r2, #0]
 8008578:	f043 0301 	orr.w	r3, r3, #1
 800857c:	6013      	str	r3, [r2, #0]
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 800857e:	2300      	movs	r3, #0
 8008580:	6463      	str	r3, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 8008582:	2301      	movs	r3, #1
 8008584:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 8008588:	2300      	movs	r3, #0
 800858a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 800858e:	b002      	add	sp, #8
 8008590:	bd70      	pop	{r4, r5, r6, pc}
    hqspi->Lock = HAL_UNLOCKED;
 8008592:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_QSPI_MspInit(hqspi);
 8008596:	4620      	mov	r0, r4
 8008598:	f7f8 ff20 	bl	80013dc <HAL_QSPI_MspInit>
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
 800859c:	f241 3188 	movw	r1, #5000	; 0x1388
 80085a0:	4620      	mov	r0, r4
 80085a2:	f7ff ffab 	bl	80084fc <HAL_QSPI_SetTimeout>
 80085a6:	e7b7      	b.n	8008518 <HAL_QSPI_Init+0x18>
    return HAL_ERROR;
 80085a8:	2001      	movs	r0, #1
 80085aa:	e7f0      	b.n	800858e <HAL_QSPI_Init+0x8e>
 80085ac:	ffe0f8fe 	.word	0xffe0f8fe

080085b0 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80085b0:	b530      	push	{r4, r5, lr}
 80085b2:	b083      	sub	sp, #12
 80085b4:	4604      	mov	r4, r0
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80085b6:	4b20      	ldr	r3, [pc, #128]	; (8008638 <RCC_SetFlashLatencyFromMSIRange+0x88>)
 80085b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80085ba:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80085be:	d00b      	beq.n	80085d8 <RCC_SetFlashLatencyFromMSIRange+0x28>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80085c0:	f7ff ff22 	bl	8008408 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80085c4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80085c8:	d017      	beq.n	80085fa <RCC_SetFlashLatencyFromMSIRange+0x4a>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 80085ca:	2c80      	cmp	r4, #128	; 0x80
 80085cc:	d81f      	bhi.n	800860e <RCC_SetFlashLatencyFromMSIRange+0x5e>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 80085ce:	d02d      	beq.n	800862c <RCC_SetFlashLatencyFromMSIRange+0x7c>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7)
 80085d0:	2c70      	cmp	r4, #112	; 0x70
 80085d2:	d02d      	beq.n	8008630 <RCC_SetFlashLatencyFromMSIRange+0x80>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80085d4:	2100      	movs	r1, #0
 80085d6:	e01b      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
    __HAL_RCC_PWR_CLK_ENABLE();
 80085d8:	4d17      	ldr	r5, [pc, #92]	; (8008638 <RCC_SetFlashLatencyFromMSIRange+0x88>)
 80085da:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80085dc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80085e0:	65ab      	str	r3, [r5, #88]	; 0x58
 80085e2:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80085e4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80085e8:	9301      	str	r3, [sp, #4]
 80085ea:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80085ec:	f7ff ff0c 	bl	8008408 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80085f0:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80085f2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80085f6:	65ab      	str	r3, [r5, #88]	; 0x58
 80085f8:	e7e4      	b.n	80085c4 <RCC_SetFlashLatencyFromMSIRange+0x14>
    if(msirange > RCC_MSIRANGE_8)
 80085fa:	2c80      	cmp	r4, #128	; 0x80
 80085fc:	d903      	bls.n	8008606 <RCC_SetFlashLatencyFromMSIRange+0x56>
      if(msirange > RCC_MSIRANGE_10)
 80085fe:	2ca0      	cmp	r4, #160	; 0xa0
 8008600:	d903      	bls.n	800860a <RCC_SetFlashLatencyFromMSIRange+0x5a>
        latency = FLASH_LATENCY_2; /* 2WS */
 8008602:	2102      	movs	r1, #2
 8008604:	e004      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8008606:	2100      	movs	r1, #0
 8008608:	e002      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
        latency = FLASH_LATENCY_1; /* 1WS */
 800860a:	2101      	movs	r1, #1
 800860c:	e000      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
      latency = FLASH_LATENCY_3; /* 3WS */
 800860e:	2103      	movs	r1, #3
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8008610:	4a0a      	ldr	r2, [pc, #40]	; (800863c <RCC_SetFlashLatencyFromMSIRange+0x8c>)
 8008612:	6813      	ldr	r3, [r2, #0]
 8008614:	f023 0307 	bic.w	r3, r3, #7
 8008618:	430b      	orrs	r3, r1
 800861a:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 800861c:	6813      	ldr	r3, [r2, #0]
 800861e:	f003 0307 	and.w	r3, r3, #7
 8008622:	428b      	cmp	r3, r1
 8008624:	d106      	bne.n	8008634 <RCC_SetFlashLatencyFromMSIRange+0x84>
  {
    return HAL_ERROR;
  }

  return HAL_OK;
 8008626:	2000      	movs	r0, #0
}
 8008628:	b003      	add	sp, #12
 800862a:	bd30      	pop	{r4, r5, pc}
        latency = FLASH_LATENCY_2; /* 2WS */
 800862c:	2102      	movs	r1, #2
 800862e:	e7ef      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
        latency = FLASH_LATENCY_1; /* 1WS */
 8008630:	2101      	movs	r1, #1
 8008632:	e7ed      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
    return HAL_ERROR;
 8008634:	2001      	movs	r0, #1
 8008636:	e7f7      	b.n	8008628 <RCC_SetFlashLatencyFromMSIRange+0x78>
 8008638:	40021000 	.word	0x40021000
 800863c:	40022000 	.word	0x40022000

08008640 <HAL_RCC_MCOConfig>:
{
 8008640:	b570      	push	{r4, r5, r6, lr}
 8008642:	b086      	sub	sp, #24
 8008644:	460d      	mov	r5, r1
 8008646:	4616      	mov	r6, r2
  __MCO1_CLK_ENABLE();
 8008648:	4c0f      	ldr	r4, [pc, #60]	; (8008688 <HAL_RCC_MCOConfig+0x48>)
 800864a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800864c:	f043 0301 	orr.w	r3, r3, #1
 8008650:	64e3      	str	r3, [r4, #76]	; 0x4c
 8008652:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8008654:	f003 0301 	and.w	r3, r3, #1
 8008658:	9300      	str	r3, [sp, #0]
 800865a:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Pin = MCO1_PIN;
 800865c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008660:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008662:	2302      	movs	r3, #2
 8008664:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008666:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008668:	2300      	movs	r3, #0
 800866a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 800866c:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 800866e:	a901      	add	r1, sp, #4
 8008670:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8008674:	f7ff f8b8 	bl	80077e8 <HAL_GPIO_Init>
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv ));
 8008678:	68a3      	ldr	r3, [r4, #8]
 800867a:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 800867e:	4335      	orrs	r5, r6
 8008680:	432b      	orrs	r3, r5
 8008682:	60a3      	str	r3, [r4, #8]
}
 8008684:	b006      	add	sp, #24
 8008686:	bd70      	pop	{r4, r5, r6, pc}
 8008688:	40021000 	.word	0x40021000

0800868c <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800868c:	4a28      	ldr	r2, [pc, #160]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 800868e:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8008690:	68d2      	ldr	r2, [r2, #12]
 8008692:	f002 0203 	and.w	r2, r2, #3
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8008696:	f013 030c 	ands.w	r3, r3, #12
 800869a:	d00a      	beq.n	80086b2 <HAL_RCC_GetSysClockFreq+0x26>
 800869c:	2b0c      	cmp	r3, #12
 800869e:	d006      	beq.n	80086ae <HAL_RCC_GetSysClockFreq+0x22>
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 80086a0:	2b04      	cmp	r3, #4
 80086a2:	d01f      	beq.n	80086e4 <HAL_RCC_GetSysClockFreq+0x58>
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 80086a4:	2b08      	cmp	r3, #8
 80086a6:	d020      	beq.n	80086ea <HAL_RCC_GetSysClockFreq+0x5e>
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086a8:	2000      	movs	r0, #0
 80086aa:	4602      	mov	r2, r0
 80086ac:	e010      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 80086ae:	2a01      	cmp	r2, #1
 80086b0:	d1f6      	bne.n	80086a0 <HAL_RCC_GetSysClockFreq+0x14>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80086b2:	4a1f      	ldr	r2, [pc, #124]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086b4:	6812      	ldr	r2, [r2, #0]
 80086b6:	f012 0f08 	tst.w	r2, #8
 80086ba:	d10c      	bne.n	80086d6 <HAL_RCC_GetSysClockFreq+0x4a>
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80086bc:	4a1c      	ldr	r2, [pc, #112]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086be:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80086c2:	f3c2 2203 	ubfx	r2, r2, #8, #4
    msirange = MSIRangeTable[msirange];
 80086c6:	491b      	ldr	r1, [pc, #108]	; (8008734 <HAL_RCC_GetSysClockFreq+0xa8>)
 80086c8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 80086cc:	b143      	cbz	r3, 80086e0 <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086ce:	2000      	movs	r0, #0
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 80086d0:	2b0c      	cmp	r3, #12
 80086d2:	d00d      	beq.n	80086f0 <HAL_RCC_GetSysClockFreq+0x64>
}
 80086d4:	4770      	bx	lr
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80086d6:	4a16      	ldr	r2, [pc, #88]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086d8:	6812      	ldr	r2, [r2, #0]
 80086da:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80086de:	e7f2      	b.n	80086c6 <HAL_RCC_GetSysClockFreq+0x3a>
      sysclockfreq = msirange;
 80086e0:	4610      	mov	r0, r2
 80086e2:	e7f5      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
    sysclockfreq = HSI_VALUE;
 80086e4:	4814      	ldr	r0, [pc, #80]	; (8008738 <HAL_RCC_GetSysClockFreq+0xac>)
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086e6:	2200      	movs	r2, #0
 80086e8:	e7f2      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
    sysclockfreq = HSE_VALUE;
 80086ea:	4814      	ldr	r0, [pc, #80]	; (800873c <HAL_RCC_GetSysClockFreq+0xb0>)
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086ec:	2200      	movs	r2, #0
 80086ee:	e7ef      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80086f0:	4b0f      	ldr	r3, [pc, #60]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086f2:	68db      	ldr	r3, [r3, #12]
 80086f4:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 80086f8:	2b02      	cmp	r3, #2
 80086fa:	d016      	beq.n	800872a <HAL_RCC_GetSysClockFreq+0x9e>
 80086fc:	2b03      	cmp	r3, #3
 80086fe:	d100      	bne.n	8008702 <HAL_RCC_GetSysClockFreq+0x76>
      pllvco = HSE_VALUE;
 8008700:	4a0e      	ldr	r2, [pc, #56]	; (800873c <HAL_RCC_GetSysClockFreq+0xb0>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8008702:	490b      	ldr	r1, [pc, #44]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 8008704:	68cb      	ldr	r3, [r1, #12]
 8008706:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800870a:	3301      	adds	r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 800870c:	68c8      	ldr	r0, [r1, #12]
 800870e:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8008712:	fb02 f000 	mul.w	r0, r2, r0
 8008716:	fbb0 f0f3 	udiv	r0, r0, r3
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800871a:	68cb      	ldr	r3, [r1, #12]
 800871c:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8008720:	3301      	adds	r3, #1
 8008722:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 8008724:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 8008728:	e7d4      	b.n	80086d4 <HAL_RCC_GetSysClockFreq+0x48>
    switch (pllsource)
 800872a:	4a03      	ldr	r2, [pc, #12]	; (8008738 <HAL_RCC_GetSysClockFreq+0xac>)
 800872c:	e7e9      	b.n	8008702 <HAL_RCC_GetSysClockFreq+0x76>
 800872e:	bf00      	nop
 8008730:	40021000 	.word	0x40021000
 8008734:	0802d0b0 	.word	0x0802d0b0
 8008738:	00f42400 	.word	0x00f42400
 800873c:	007a1200 	.word	0x007a1200

08008740 <HAL_RCC_OscConfig>:
  if(RCC_OscInitStruct == NULL)
 8008740:	2800      	cmp	r0, #0
 8008742:	f000 8327 	beq.w	8008d94 <HAL_RCC_OscConfig+0x654>
{
 8008746:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008748:	b083      	sub	sp, #12
 800874a:	4604      	mov	r4, r0
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800874c:	4b96      	ldr	r3, [pc, #600]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800874e:	689d      	ldr	r5, [r3, #8]
 8008750:	f005 050c 	and.w	r5, r5, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8008754:	68de      	ldr	r6, [r3, #12]
 8008756:	f006 0603 	and.w	r6, r6, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800875a:	6803      	ldr	r3, [r0, #0]
 800875c:	f013 0f10 	tst.w	r3, #16
 8008760:	d05a      	beq.n	8008818 <HAL_RCC_OscConfig+0xd8>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8008762:	b1e5      	cbz	r5, 800879e <HAL_RCC_OscConfig+0x5e>
 8008764:	2d0c      	cmp	r5, #12
 8008766:	d018      	beq.n	800879a <HAL_RCC_OscConfig+0x5a>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8008768:	69a3      	ldr	r3, [r4, #24]
 800876a:	2b00      	cmp	r3, #0
 800876c:	f000 80bb 	beq.w	80088e6 <HAL_RCC_OscConfig+0x1a6>
        __HAL_RCC_MSI_ENABLE();
 8008770:	4a8d      	ldr	r2, [pc, #564]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008772:	6813      	ldr	r3, [r2, #0]
 8008774:	f043 0301 	orr.w	r3, r3, #1
 8008778:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800877a:	f7fe fc0d 	bl	8006f98 <HAL_GetTick>
 800877e:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008780:	4b89      	ldr	r3, [pc, #548]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008782:	681b      	ldr	r3, [r3, #0]
 8008784:	f013 0f02 	tst.w	r3, #2
 8008788:	f040 809a 	bne.w	80088c0 <HAL_RCC_OscConfig+0x180>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800878c:	f7fe fc04 	bl	8006f98 <HAL_GetTick>
 8008790:	1bc0      	subs	r0, r0, r7
 8008792:	2802      	cmp	r0, #2
 8008794:	d9f4      	bls.n	8008780 <HAL_RCC_OscConfig+0x40>
            return HAL_TIMEOUT;
 8008796:	2003      	movs	r0, #3
 8008798:	e307      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 800879a:	2e01      	cmp	r6, #1
 800879c:	d1e4      	bne.n	8008768 <HAL_RCC_OscConfig+0x28>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800879e:	4b82      	ldr	r3, [pc, #520]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087a0:	681b      	ldr	r3, [r3, #0]
 80087a2:	f013 0f02 	tst.w	r3, #2
 80087a6:	d003      	beq.n	80087b0 <HAL_RCC_OscConfig+0x70>
 80087a8:	69a3      	ldr	r3, [r4, #24]
 80087aa:	2b00      	cmp	r3, #0
 80087ac:	f000 82f4 	beq.w	8008d98 <HAL_RCC_OscConfig+0x658>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80087b0:	6a20      	ldr	r0, [r4, #32]
 80087b2:	4b7d      	ldr	r3, [pc, #500]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087b4:	681b      	ldr	r3, [r3, #0]
 80087b6:	f013 0f08 	tst.w	r3, #8
 80087ba:	d05b      	beq.n	8008874 <HAL_RCC_OscConfig+0x134>
 80087bc:	4b7a      	ldr	r3, [pc, #488]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087be:	681b      	ldr	r3, [r3, #0]
 80087c0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80087c4:	4298      	cmp	r0, r3
 80087c6:	d85c      	bhi.n	8008882 <HAL_RCC_OscConfig+0x142>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80087c8:	4b77      	ldr	r3, [pc, #476]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087ca:	681a      	ldr	r2, [r3, #0]
 80087cc:	f042 0208 	orr.w	r2, r2, #8
 80087d0:	601a      	str	r2, [r3, #0]
 80087d2:	681a      	ldr	r2, [r3, #0]
 80087d4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80087d8:	6a21      	ldr	r1, [r4, #32]
 80087da:	430a      	orrs	r2, r1
 80087dc:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80087de:	685a      	ldr	r2, [r3, #4]
 80087e0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80087e4:	69e1      	ldr	r1, [r4, #28]
 80087e6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80087ea:	605a      	str	r2, [r3, #4]
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 80087ec:	2d00      	cmp	r5, #0
 80087ee:	d060      	beq.n	80088b2 <HAL_RCC_OscConfig+0x172>
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80087f0:	f7ff ff4c 	bl	800868c <HAL_RCC_GetSysClockFreq>
 80087f4:	4b6c      	ldr	r3, [pc, #432]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087f6:	689b      	ldr	r3, [r3, #8]
 80087f8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80087fc:	4a6b      	ldr	r2, [pc, #428]	; (80089ac <HAL_RCC_OscConfig+0x26c>)
 80087fe:	5cd3      	ldrb	r3, [r2, r3]
 8008800:	f003 031f 	and.w	r3, r3, #31
 8008804:	40d8      	lsrs	r0, r3
 8008806:	4b6a      	ldr	r3, [pc, #424]	; (80089b0 <HAL_RCC_OscConfig+0x270>)
 8008808:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 800880a:	4b6a      	ldr	r3, [pc, #424]	; (80089b4 <HAL_RCC_OscConfig+0x274>)
 800880c:	6818      	ldr	r0, [r3, #0]
 800880e:	f7f8 ff6b 	bl	80016e8 <HAL_InitTick>
        if(status != HAL_OK)
 8008812:	2800      	cmp	r0, #0
 8008814:	f040 82c9 	bne.w	8008daa <HAL_RCC_OscConfig+0x66a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8008818:	6823      	ldr	r3, [r4, #0]
 800881a:	f013 0f01 	tst.w	r3, #1
 800881e:	f000 8081 	beq.w	8008924 <HAL_RCC_OscConfig+0x1e4>
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 8008822:	2d08      	cmp	r5, #8
 8008824:	d075      	beq.n	8008912 <HAL_RCC_OscConfig+0x1d2>
 8008826:	2d0c      	cmp	r5, #12
 8008828:	d071      	beq.n	800890e <HAL_RCC_OscConfig+0x1ce>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800882a:	6863      	ldr	r3, [r4, #4]
 800882c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008830:	f000 8097 	beq.w	8008962 <HAL_RCC_OscConfig+0x222>
 8008834:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8008838:	f000 8099 	beq.w	800896e <HAL_RCC_OscConfig+0x22e>
 800883c:	4b5a      	ldr	r3, [pc, #360]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800883e:	681a      	ldr	r2, [r3, #0]
 8008840:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008844:	601a      	str	r2, [r3, #0]
 8008846:	681a      	ldr	r2, [r3, #0]
 8008848:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800884c:	601a      	str	r2, [r3, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800884e:	6863      	ldr	r3, [r4, #4]
 8008850:	2b00      	cmp	r3, #0
 8008852:	f000 8099 	beq.w	8008988 <HAL_RCC_OscConfig+0x248>
        tickstart = HAL_GetTick();
 8008856:	f7fe fb9f 	bl	8006f98 <HAL_GetTick>
 800885a:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800885c:	4b52      	ldr	r3, [pc, #328]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800885e:	681b      	ldr	r3, [r3, #0]
 8008860:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8008864:	d15e      	bne.n	8008924 <HAL_RCC_OscConfig+0x1e4>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8008866:	f7fe fb97 	bl	8006f98 <HAL_GetTick>
 800886a:	1bc0      	subs	r0, r0, r7
 800886c:	2864      	cmp	r0, #100	; 0x64
 800886e:	d9f5      	bls.n	800885c <HAL_RCC_OscConfig+0x11c>
            return HAL_TIMEOUT;
 8008870:	2003      	movs	r0, #3
 8008872:	e29a      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8008874:	4b4c      	ldr	r3, [pc, #304]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008876:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800887a:	091b      	lsrs	r3, r3, #4
 800887c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008880:	e7a0      	b.n	80087c4 <HAL_RCC_OscConfig+0x84>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8008882:	f7ff fe95 	bl	80085b0 <RCC_SetFlashLatencyFromMSIRange>
 8008886:	2800      	cmp	r0, #0
 8008888:	f040 8288 	bne.w	8008d9c <HAL_RCC_OscConfig+0x65c>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800888c:	4b46      	ldr	r3, [pc, #280]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800888e:	681a      	ldr	r2, [r3, #0]
 8008890:	f042 0208 	orr.w	r2, r2, #8
 8008894:	601a      	str	r2, [r3, #0]
 8008896:	681a      	ldr	r2, [r3, #0]
 8008898:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800889c:	6a21      	ldr	r1, [r4, #32]
 800889e:	430a      	orrs	r2, r1
 80088a0:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80088a2:	685a      	ldr	r2, [r3, #4]
 80088a4:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80088a8:	69e1      	ldr	r1, [r4, #28]
 80088aa:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80088ae:	605a      	str	r2, [r3, #4]
 80088b0:	e79e      	b.n	80087f0 <HAL_RCC_OscConfig+0xb0>
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80088b2:	6a20      	ldr	r0, [r4, #32]
 80088b4:	f7ff fe7c 	bl	80085b0 <RCC_SetFlashLatencyFromMSIRange>
 80088b8:	2800      	cmp	r0, #0
 80088ba:	d099      	beq.n	80087f0 <HAL_RCC_OscConfig+0xb0>
              return HAL_ERROR;
 80088bc:	2001      	movs	r0, #1
 80088be:	e274      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80088c0:	4b39      	ldr	r3, [pc, #228]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80088c2:	681a      	ldr	r2, [r3, #0]
 80088c4:	f042 0208 	orr.w	r2, r2, #8
 80088c8:	601a      	str	r2, [r3, #0]
 80088ca:	681a      	ldr	r2, [r3, #0]
 80088cc:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80088d0:	6a21      	ldr	r1, [r4, #32]
 80088d2:	430a      	orrs	r2, r1
 80088d4:	601a      	str	r2, [r3, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80088d6:	685a      	ldr	r2, [r3, #4]
 80088d8:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80088dc:	69e1      	ldr	r1, [r4, #28]
 80088de:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80088e2:	605a      	str	r2, [r3, #4]
 80088e4:	e798      	b.n	8008818 <HAL_RCC_OscConfig+0xd8>
        __HAL_RCC_MSI_DISABLE();
 80088e6:	4a30      	ldr	r2, [pc, #192]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80088e8:	6813      	ldr	r3, [r2, #0]
 80088ea:	f023 0301 	bic.w	r3, r3, #1
 80088ee:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80088f0:	f7fe fb52 	bl	8006f98 <HAL_GetTick>
 80088f4:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80088f6:	4b2c      	ldr	r3, [pc, #176]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80088f8:	681b      	ldr	r3, [r3, #0]
 80088fa:	f013 0f02 	tst.w	r3, #2
 80088fe:	d08b      	beq.n	8008818 <HAL_RCC_OscConfig+0xd8>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8008900:	f7fe fb4a 	bl	8006f98 <HAL_GetTick>
 8008904:	1bc0      	subs	r0, r0, r7
 8008906:	2802      	cmp	r0, #2
 8008908:	d9f5      	bls.n	80088f6 <HAL_RCC_OscConfig+0x1b6>
            return HAL_TIMEOUT;
 800890a:	2003      	movs	r0, #3
 800890c:	e24d      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 800890e:	2e03      	cmp	r6, #3
 8008910:	d18b      	bne.n	800882a <HAL_RCC_OscConfig+0xea>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8008912:	4b25      	ldr	r3, [pc, #148]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008914:	681b      	ldr	r3, [r3, #0]
 8008916:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800891a:	d003      	beq.n	8008924 <HAL_RCC_OscConfig+0x1e4>
 800891c:	6863      	ldr	r3, [r4, #4]
 800891e:	2b00      	cmp	r3, #0
 8008920:	f000 823e 	beq.w	8008da0 <HAL_RCC_OscConfig+0x660>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8008924:	6823      	ldr	r3, [r4, #0]
 8008926:	f013 0f02 	tst.w	r3, #2
 800892a:	d058      	beq.n	80089de <HAL_RCC_OscConfig+0x29e>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 800892c:	2d04      	cmp	r5, #4
 800892e:	d045      	beq.n	80089bc <HAL_RCC_OscConfig+0x27c>
 8008930:	2d0c      	cmp	r5, #12
 8008932:	d041      	beq.n	80089b8 <HAL_RCC_OscConfig+0x278>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8008934:	68e3      	ldr	r3, [r4, #12]
 8008936:	2b00      	cmp	r3, #0
 8008938:	d077      	beq.n	8008a2a <HAL_RCC_OscConfig+0x2ea>
        __HAL_RCC_HSI_ENABLE();
 800893a:	4a1b      	ldr	r2, [pc, #108]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800893c:	6813      	ldr	r3, [r2, #0]
 800893e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008942:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8008944:	f7fe fb28 	bl	8006f98 <HAL_GetTick>
 8008948:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800894a:	4b17      	ldr	r3, [pc, #92]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800894c:	681b      	ldr	r3, [r3, #0]
 800894e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008952:	d161      	bne.n	8008a18 <HAL_RCC_OscConfig+0x2d8>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8008954:	f7fe fb20 	bl	8006f98 <HAL_GetTick>
 8008958:	1b80      	subs	r0, r0, r6
 800895a:	2802      	cmp	r0, #2
 800895c:	d9f5      	bls.n	800894a <HAL_RCC_OscConfig+0x20a>
            return HAL_TIMEOUT;
 800895e:	2003      	movs	r0, #3
 8008960:	e223      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8008962:	4a11      	ldr	r2, [pc, #68]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008964:	6813      	ldr	r3, [r2, #0]
 8008966:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800896a:	6013      	str	r3, [r2, #0]
 800896c:	e76f      	b.n	800884e <HAL_RCC_OscConfig+0x10e>
 800896e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8008972:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8008976:	681a      	ldr	r2, [r3, #0]
 8008978:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800897c:	601a      	str	r2, [r3, #0]
 800897e:	681a      	ldr	r2, [r3, #0]
 8008980:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8008984:	601a      	str	r2, [r3, #0]
 8008986:	e762      	b.n	800884e <HAL_RCC_OscConfig+0x10e>
        tickstart = HAL_GetTick();
 8008988:	f7fe fb06 	bl	8006f98 <HAL_GetTick>
 800898c:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800898e:	4b06      	ldr	r3, [pc, #24]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008990:	681b      	ldr	r3, [r3, #0]
 8008992:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8008996:	d0c5      	beq.n	8008924 <HAL_RCC_OscConfig+0x1e4>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8008998:	f7fe fafe 	bl	8006f98 <HAL_GetTick>
 800899c:	1bc0      	subs	r0, r0, r7
 800899e:	2864      	cmp	r0, #100	; 0x64
 80089a0:	d9f5      	bls.n	800898e <HAL_RCC_OscConfig+0x24e>
            return HAL_TIMEOUT;
 80089a2:	2003      	movs	r0, #3
 80089a4:	e201      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 80089a6:	bf00      	nop
 80089a8:	40021000 	.word	0x40021000
 80089ac:	0802d098 	.word	0x0802d098
 80089b0:	20000034 	.word	0x20000034
 80089b4:	2000003c 	.word	0x2000003c
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80089b8:	2e02      	cmp	r6, #2
 80089ba:	d1bb      	bne.n	8008934 <HAL_RCC_OscConfig+0x1f4>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80089bc:	4bac      	ldr	r3, [pc, #688]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 80089be:	681b      	ldr	r3, [r3, #0]
 80089c0:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80089c4:	d003      	beq.n	80089ce <HAL_RCC_OscConfig+0x28e>
 80089c6:	68e3      	ldr	r3, [r4, #12]
 80089c8:	2b00      	cmp	r3, #0
 80089ca:	f000 81eb 	beq.w	8008da4 <HAL_RCC_OscConfig+0x664>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80089ce:	4aa8      	ldr	r2, [pc, #672]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 80089d0:	6853      	ldr	r3, [r2, #4]
 80089d2:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80089d6:	6921      	ldr	r1, [r4, #16]
 80089d8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 80089dc:	6053      	str	r3, [r2, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80089de:	6823      	ldr	r3, [r4, #0]
 80089e0:	f013 0f08 	tst.w	r3, #8
 80089e4:	d04c      	beq.n	8008a80 <HAL_RCC_OscConfig+0x340>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80089e6:	6963      	ldr	r3, [r4, #20]
 80089e8:	b39b      	cbz	r3, 8008a52 <HAL_RCC_OscConfig+0x312>
      __HAL_RCC_LSI_ENABLE();
 80089ea:	4aa1      	ldr	r2, [pc, #644]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 80089ec:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 80089f0:	f043 0301 	orr.w	r3, r3, #1
 80089f4:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      tickstart = HAL_GetTick();
 80089f8:	f7fe face 	bl	8006f98 <HAL_GetTick>
 80089fc:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80089fe:	4b9c      	ldr	r3, [pc, #624]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a00:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8008a04:	f013 0f02 	tst.w	r3, #2
 8008a08:	d13a      	bne.n	8008a80 <HAL_RCC_OscConfig+0x340>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8008a0a:	f7fe fac5 	bl	8006f98 <HAL_GetTick>
 8008a0e:	1b80      	subs	r0, r0, r6
 8008a10:	2802      	cmp	r0, #2
 8008a12:	d9f4      	bls.n	80089fe <HAL_RCC_OscConfig+0x2be>
          return HAL_TIMEOUT;
 8008a14:	2003      	movs	r0, #3
 8008a16:	e1c8      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008a18:	4a95      	ldr	r2, [pc, #596]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a1a:	6853      	ldr	r3, [r2, #4]
 8008a1c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008a20:	6921      	ldr	r1, [r4, #16]
 8008a22:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8008a26:	6053      	str	r3, [r2, #4]
 8008a28:	e7d9      	b.n	80089de <HAL_RCC_OscConfig+0x29e>
        __HAL_RCC_HSI_DISABLE();
 8008a2a:	4a91      	ldr	r2, [pc, #580]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a2c:	6813      	ldr	r3, [r2, #0]
 8008a2e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008a32:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8008a34:	f7fe fab0 	bl	8006f98 <HAL_GetTick>
 8008a38:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8008a3a:	4b8d      	ldr	r3, [pc, #564]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a3c:	681b      	ldr	r3, [r3, #0]
 8008a3e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008a42:	d0cc      	beq.n	80089de <HAL_RCC_OscConfig+0x29e>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8008a44:	f7fe faa8 	bl	8006f98 <HAL_GetTick>
 8008a48:	1b80      	subs	r0, r0, r6
 8008a4a:	2802      	cmp	r0, #2
 8008a4c:	d9f5      	bls.n	8008a3a <HAL_RCC_OscConfig+0x2fa>
            return HAL_TIMEOUT;
 8008a4e:	2003      	movs	r0, #3
 8008a50:	e1ab      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      __HAL_RCC_LSI_DISABLE();
 8008a52:	4a87      	ldr	r2, [pc, #540]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a54:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8008a58:	f023 0301 	bic.w	r3, r3, #1
 8008a5c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      tickstart = HAL_GetTick();
 8008a60:	f7fe fa9a 	bl	8006f98 <HAL_GetTick>
 8008a64:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8008a66:	4b82      	ldr	r3, [pc, #520]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a68:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8008a6c:	f013 0f02 	tst.w	r3, #2
 8008a70:	d006      	beq.n	8008a80 <HAL_RCC_OscConfig+0x340>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8008a72:	f7fe fa91 	bl	8006f98 <HAL_GetTick>
 8008a76:	1b80      	subs	r0, r0, r6
 8008a78:	2802      	cmp	r0, #2
 8008a7a:	d9f4      	bls.n	8008a66 <HAL_RCC_OscConfig+0x326>
          return HAL_TIMEOUT;
 8008a7c:	2003      	movs	r0, #3
 8008a7e:	e194      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008a80:	6823      	ldr	r3, [r4, #0]
 8008a82:	f013 0f04 	tst.w	r3, #4
 8008a86:	d07a      	beq.n	8008b7e <HAL_RCC_OscConfig+0x43e>
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8008a88:	4b79      	ldr	r3, [pc, #484]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a8a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008a8c:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8008a90:	d136      	bne.n	8008b00 <HAL_RCC_OscConfig+0x3c0>
      __HAL_RCC_PWR_CLK_ENABLE();
 8008a92:	4b77      	ldr	r3, [pc, #476]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a94:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8008a96:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8008a9a:	659a      	str	r2, [r3, #88]	; 0x58
 8008a9c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008a9e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008aa2:	9301      	str	r3, [sp, #4]
 8008aa4:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8008aa6:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8008aa8:	4b72      	ldr	r3, [pc, #456]	; (8008c74 <HAL_RCC_OscConfig+0x534>)
 8008aaa:	681b      	ldr	r3, [r3, #0]
 8008aac:	f413 7f80 	tst.w	r3, #256	; 0x100
 8008ab0:	d028      	beq.n	8008b04 <HAL_RCC_OscConfig+0x3c4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8008ab2:	68a3      	ldr	r3, [r4, #8]
 8008ab4:	2b01      	cmp	r3, #1
 8008ab6:	d039      	beq.n	8008b2c <HAL_RCC_OscConfig+0x3ec>
 8008ab8:	2b05      	cmp	r3, #5
 8008aba:	d03f      	beq.n	8008b3c <HAL_RCC_OscConfig+0x3fc>
 8008abc:	4b6c      	ldr	r3, [pc, #432]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008abe:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008ac2:	f022 0201 	bic.w	r2, r2, #1
 8008ac6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8008aca:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008ace:	f022 0204 	bic.w	r2, r2, #4
 8008ad2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8008ad6:	68a3      	ldr	r3, [r4, #8]
 8008ad8:	2b00      	cmp	r3, #0
 8008ada:	d03d      	beq.n	8008b58 <HAL_RCC_OscConfig+0x418>
      tickstart = HAL_GetTick();
 8008adc:	f7fe fa5c 	bl	8006f98 <HAL_GetTick>
 8008ae0:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8008ae2:	4b63      	ldr	r3, [pc, #396]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008ae4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008ae8:	f013 0f02 	tst.w	r3, #2
 8008aec:	d146      	bne.n	8008b7c <HAL_RCC_OscConfig+0x43c>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008aee:	f7fe fa53 	bl	8006f98 <HAL_GetTick>
 8008af2:	1bc0      	subs	r0, r0, r7
 8008af4:	f241 3388 	movw	r3, #5000	; 0x1388
 8008af8:	4298      	cmp	r0, r3
 8008afa:	d9f2      	bls.n	8008ae2 <HAL_RCC_OscConfig+0x3a2>
          return HAL_TIMEOUT;
 8008afc:	2003      	movs	r0, #3
 8008afe:	e154      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    FlagStatus       pwrclkchanged = RESET;
 8008b00:	2600      	movs	r6, #0
 8008b02:	e7d1      	b.n	8008aa8 <HAL_RCC_OscConfig+0x368>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8008b04:	4a5b      	ldr	r2, [pc, #364]	; (8008c74 <HAL_RCC_OscConfig+0x534>)
 8008b06:	6813      	ldr	r3, [r2, #0]
 8008b08:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008b0c:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8008b0e:	f7fe fa43 	bl	8006f98 <HAL_GetTick>
 8008b12:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8008b14:	4b57      	ldr	r3, [pc, #348]	; (8008c74 <HAL_RCC_OscConfig+0x534>)
 8008b16:	681b      	ldr	r3, [r3, #0]
 8008b18:	f413 7f80 	tst.w	r3, #256	; 0x100
 8008b1c:	d1c9      	bne.n	8008ab2 <HAL_RCC_OscConfig+0x372>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8008b1e:	f7fe fa3b 	bl	8006f98 <HAL_GetTick>
 8008b22:	1bc0      	subs	r0, r0, r7
 8008b24:	2802      	cmp	r0, #2
 8008b26:	d9f5      	bls.n	8008b14 <HAL_RCC_OscConfig+0x3d4>
          return HAL_TIMEOUT;
 8008b28:	2003      	movs	r0, #3
 8008b2a:	e13e      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8008b2c:	4a50      	ldr	r2, [pc, #320]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b2e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8008b32:	f043 0301 	orr.w	r3, r3, #1
 8008b36:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8008b3a:	e7cc      	b.n	8008ad6 <HAL_RCC_OscConfig+0x396>
 8008b3c:	4b4c      	ldr	r3, [pc, #304]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b3e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008b42:	f042 0204 	orr.w	r2, r2, #4
 8008b46:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8008b4a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008b4e:	f042 0201 	orr.w	r2, r2, #1
 8008b52:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8008b56:	e7be      	b.n	8008ad6 <HAL_RCC_OscConfig+0x396>
      tickstart = HAL_GetTick();
 8008b58:	f7fe fa1e 	bl	8006f98 <HAL_GetTick>
 8008b5c:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8008b5e:	4b44      	ldr	r3, [pc, #272]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b60:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008b64:	f013 0f02 	tst.w	r3, #2
 8008b68:	d008      	beq.n	8008b7c <HAL_RCC_OscConfig+0x43c>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008b6a:	f7fe fa15 	bl	8006f98 <HAL_GetTick>
 8008b6e:	1bc0      	subs	r0, r0, r7
 8008b70:	f241 3388 	movw	r3, #5000	; 0x1388
 8008b74:	4298      	cmp	r0, r3
 8008b76:	d9f2      	bls.n	8008b5e <HAL_RCC_OscConfig+0x41e>
          return HAL_TIMEOUT;
 8008b78:	2003      	movs	r0, #3
 8008b7a:	e116      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    if(pwrclkchanged == SET)
 8008b7c:	b9e6      	cbnz	r6, 8008bb8 <HAL_RCC_OscConfig+0x478>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8008b7e:	6823      	ldr	r3, [r4, #0]
 8008b80:	f013 0f20 	tst.w	r3, #32
 8008b84:	d035      	beq.n	8008bf2 <HAL_RCC_OscConfig+0x4b2>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8008b86:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008b88:	b1e3      	cbz	r3, 8008bc4 <HAL_RCC_OscConfig+0x484>
      __HAL_RCC_HSI48_ENABLE();
 8008b8a:	4a39      	ldr	r2, [pc, #228]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b8c:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8008b90:	f043 0301 	orr.w	r3, r3, #1
 8008b94:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
      tickstart = HAL_GetTick();
 8008b98:	f7fe f9fe 	bl	8006f98 <HAL_GetTick>
 8008b9c:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8008b9e:	4b34      	ldr	r3, [pc, #208]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008ba0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8008ba4:	f013 0f02 	tst.w	r3, #2
 8008ba8:	d123      	bne.n	8008bf2 <HAL_RCC_OscConfig+0x4b2>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8008baa:	f7fe f9f5 	bl	8006f98 <HAL_GetTick>
 8008bae:	1b80      	subs	r0, r0, r6
 8008bb0:	2802      	cmp	r0, #2
 8008bb2:	d9f4      	bls.n	8008b9e <HAL_RCC_OscConfig+0x45e>
          return HAL_TIMEOUT;
 8008bb4:	2003      	movs	r0, #3
 8008bb6:	e0f8      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      __HAL_RCC_PWR_CLK_DISABLE();
 8008bb8:	4a2d      	ldr	r2, [pc, #180]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008bba:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8008bbc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008bc0:	6593      	str	r3, [r2, #88]	; 0x58
 8008bc2:	e7dc      	b.n	8008b7e <HAL_RCC_OscConfig+0x43e>
      __HAL_RCC_HSI48_DISABLE();
 8008bc4:	4a2a      	ldr	r2, [pc, #168]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008bc6:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8008bca:	f023 0301 	bic.w	r3, r3, #1
 8008bce:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
      tickstart = HAL_GetTick();
 8008bd2:	f7fe f9e1 	bl	8006f98 <HAL_GetTick>
 8008bd6:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8008bd8:	4b25      	ldr	r3, [pc, #148]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008bda:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8008bde:	f013 0f02 	tst.w	r3, #2
 8008be2:	d006      	beq.n	8008bf2 <HAL_RCC_OscConfig+0x4b2>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8008be4:	f7fe f9d8 	bl	8006f98 <HAL_GetTick>
 8008be8:	1b80      	subs	r0, r0, r6
 8008bea:	2802      	cmp	r0, #2
 8008bec:	d9f4      	bls.n	8008bd8 <HAL_RCC_OscConfig+0x498>
          return HAL_TIMEOUT;
 8008bee:	2003      	movs	r0, #3
 8008bf0:	e0db      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8008bf2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008bf4:	2b00      	cmp	r3, #0
 8008bf6:	f000 80d7 	beq.w	8008da8 <HAL_RCC_OscConfig+0x668>
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8008bfa:	2b02      	cmp	r3, #2
 8008bfc:	d027      	beq.n	8008c4e <HAL_RCC_OscConfig+0x50e>
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8008bfe:	2d0c      	cmp	r5, #12
 8008c00:	f000 80d7 	beq.w	8008db2 <HAL_RCC_OscConfig+0x672>
        __HAL_RCC_PLL_DISABLE();
 8008c04:	4b1a      	ldr	r3, [pc, #104]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c06:	681a      	ldr	r2, [r3, #0]
 8008c08:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8008c0c:	601a      	str	r2, [r3, #0]
        if(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8008c0e:	681b      	ldr	r3, [r3, #0]
 8008c10:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8008c14:	d104      	bne.n	8008c20 <HAL_RCC_OscConfig+0x4e0>
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8008c16:	4a16      	ldr	r2, [pc, #88]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c18:	68d3      	ldr	r3, [r2, #12]
 8008c1a:	f023 0303 	bic.w	r3, r3, #3
 8008c1e:	60d3      	str	r3, [r2, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 8008c20:	4a13      	ldr	r2, [pc, #76]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c22:	68d3      	ldr	r3, [r2, #12]
 8008c24:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8008c28:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008c2c:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 8008c2e:	f7fe f9b3 	bl	8006f98 <HAL_GetTick>
 8008c32:	4604      	mov	r4, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008c34:	4b0e      	ldr	r3, [pc, #56]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c36:	681b      	ldr	r3, [r3, #0]
 8008c38:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008c3c:	f000 80a8 	beq.w	8008d90 <HAL_RCC_OscConfig+0x650>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008c40:	f7fe f9aa 	bl	8006f98 <HAL_GetTick>
 8008c44:	1b00      	subs	r0, r0, r4
 8008c46:	2802      	cmp	r0, #2
 8008c48:	d9f4      	bls.n	8008c34 <HAL_RCC_OscConfig+0x4f4>
            return HAL_TIMEOUT;
 8008c4a:	2003      	movs	r0, #3
 8008c4c:	e0ad      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      pll_config = RCC->PLLCFGR;
 8008c4e:	4b08      	ldr	r3, [pc, #32]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c50:	68db      	ldr	r3, [r3, #12]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8008c52:	f003 0103 	and.w	r1, r3, #3
 8008c56:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8008c58:	4291      	cmp	r1, r2
 8008c5a:	d00d      	beq.n	8008c78 <HAL_RCC_OscConfig+0x538>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8008c5c:	2d0c      	cmp	r5, #12
 8008c5e:	f000 80a6 	beq.w	8008dae <HAL_RCC_OscConfig+0x66e>
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 8008c62:	4b03      	ldr	r3, [pc, #12]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c64:	681b      	ldr	r3, [r3, #0]
 8008c66:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 8008c6a:	d02f      	beq.n	8008ccc <HAL_RCC_OscConfig+0x58c>
            return HAL_ERROR;
 8008c6c:	2001      	movs	r0, #1
 8008c6e:	e09c      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 8008c70:	40021000 	.word	0x40021000
 8008c74:	40007000 	.word	0x40007000
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8008c78:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8008c7c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8008c7e:	3901      	subs	r1, #1
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8008c80:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8008c84:	d1ea      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8008c86:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 8008c8a:	6b61      	ldr	r1, [r4, #52]	; 0x34
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8008c8c:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8008c90:	d1e4      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8008c92:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
 8008c96:	6ba1      	ldr	r1, [r4, #56]	; 0x38
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8008c98:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8008c9c:	d1de      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8008c9e:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 8008ca2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8008ca4:	0852      	lsrs	r2, r2, #1
 8008ca6:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8008ca8:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8008cac:	d1d6      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8008cae:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8008cb2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008cb4:	0852      	lsrs	r2, r2, #1
 8008cb6:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8008cb8:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 8008cbc:	d1ce      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008cbe:	4b3e      	ldr	r3, [pc, #248]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cc0:	681b      	ldr	r3, [r3, #0]
 8008cc2:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008cc6:	d049      	beq.n	8008d5c <HAL_RCC_OscConfig+0x61c>
  return HAL_OK;
 8008cc8:	2000      	movs	r0, #0
 8008cca:	e06e      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
            __HAL_RCC_PLL_DISABLE();
 8008ccc:	4a3a      	ldr	r2, [pc, #232]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cce:	6813      	ldr	r3, [r2, #0]
 8008cd0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008cd4:	6013      	str	r3, [r2, #0]
            tickstart = HAL_GetTick();
 8008cd6:	f7fe f95f 	bl	8006f98 <HAL_GetTick>
 8008cda:	4605      	mov	r5, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008cdc:	4b36      	ldr	r3, [pc, #216]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cde:	681b      	ldr	r3, [r3, #0]
 8008ce0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008ce4:	d006      	beq.n	8008cf4 <HAL_RCC_OscConfig+0x5b4>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008ce6:	f7fe f957 	bl	8006f98 <HAL_GetTick>
 8008cea:	1b40      	subs	r0, r0, r5
 8008cec:	2802      	cmp	r0, #2
 8008cee:	d9f5      	bls.n	8008cdc <HAL_RCC_OscConfig+0x59c>
                return HAL_TIMEOUT;
 8008cf0:	2003      	movs	r0, #3
 8008cf2:	e05a      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8008cf4:	4a30      	ldr	r2, [pc, #192]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cf6:	68d3      	ldr	r3, [r2, #12]
 8008cf8:	4930      	ldr	r1, [pc, #192]	; (8008dbc <HAL_RCC_OscConfig+0x67c>)
 8008cfa:	4019      	ands	r1, r3
 8008cfc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008cfe:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8008d00:	3801      	subs	r0, #1
 8008d02:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8008d06:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8008d08:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008d0c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8008d0e:	0840      	lsrs	r0, r0, #1
 8008d10:	3801      	subs	r0, #1
 8008d12:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 8008d16:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8008d18:	0840      	lsrs	r0, r0, #1
 8008d1a:	3801      	subs	r0, #1
 8008d1c:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
 8008d20:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8008d22:	ea43 63c0 	orr.w	r3, r3, r0, lsl #27
 8008d26:	4319      	orrs	r1, r3
 8008d28:	60d1      	str	r1, [r2, #12]
            __HAL_RCC_PLL_ENABLE();
 8008d2a:	6813      	ldr	r3, [r2, #0]
 8008d2c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008d30:	6013      	str	r3, [r2, #0]
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008d32:	68d3      	ldr	r3, [r2, #12]
 8008d34:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008d38:	60d3      	str	r3, [r2, #12]
            tickstart = HAL_GetTick();
 8008d3a:	f7fe f92d 	bl	8006f98 <HAL_GetTick>
 8008d3e:	4604      	mov	r4, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008d40:	4b1d      	ldr	r3, [pc, #116]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008d42:	681b      	ldr	r3, [r3, #0]
 8008d44:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008d48:	d106      	bne.n	8008d58 <HAL_RCC_OscConfig+0x618>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008d4a:	f7fe f925 	bl	8006f98 <HAL_GetTick>
 8008d4e:	1b00      	subs	r0, r0, r4
 8008d50:	2802      	cmp	r0, #2
 8008d52:	d9f5      	bls.n	8008d40 <HAL_RCC_OscConfig+0x600>
                return HAL_TIMEOUT;
 8008d54:	2003      	movs	r0, #3
 8008d56:	e028      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  return HAL_OK;
 8008d58:	2000      	movs	r0, #0
 8008d5a:	e026      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
          __HAL_RCC_PLL_ENABLE();
 8008d5c:	4b16      	ldr	r3, [pc, #88]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008d5e:	681a      	ldr	r2, [r3, #0]
 8008d60:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008d64:	601a      	str	r2, [r3, #0]
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008d66:	68da      	ldr	r2, [r3, #12]
 8008d68:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008d6c:	60da      	str	r2, [r3, #12]
          tickstart = HAL_GetTick();
 8008d6e:	f7fe f913 	bl	8006f98 <HAL_GetTick>
 8008d72:	4604      	mov	r4, r0
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008d74:	4b10      	ldr	r3, [pc, #64]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008d76:	681b      	ldr	r3, [r3, #0]
 8008d78:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008d7c:	d106      	bne.n	8008d8c <HAL_RCC_OscConfig+0x64c>
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008d7e:	f7fe f90b 	bl	8006f98 <HAL_GetTick>
 8008d82:	1b03      	subs	r3, r0, r4
 8008d84:	2b02      	cmp	r3, #2
 8008d86:	d9f5      	bls.n	8008d74 <HAL_RCC_OscConfig+0x634>
              return HAL_TIMEOUT;
 8008d88:	2003      	movs	r0, #3
 8008d8a:	e00e      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  return HAL_OK;
 8008d8c:	2000      	movs	r0, #0
 8008d8e:	e00c      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 8008d90:	2000      	movs	r0, #0
 8008d92:	e00a      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    return HAL_ERROR;
 8008d94:	2001      	movs	r0, #1
}
 8008d96:	4770      	bx	lr
        return HAL_ERROR;
 8008d98:	2001      	movs	r0, #1
 8008d9a:	e006      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
            return HAL_ERROR;
 8008d9c:	2001      	movs	r0, #1
 8008d9e:	e004      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        return HAL_ERROR;
 8008da0:	2001      	movs	r0, #1
 8008da2:	e002      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        return HAL_ERROR;
 8008da4:	2001      	movs	r0, #1
 8008da6:	e000      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  return HAL_OK;
 8008da8:	2000      	movs	r0, #0
}
 8008daa:	b003      	add	sp, #12
 8008dac:	bdf0      	pop	{r4, r5, r6, r7, pc}
          return HAL_ERROR;
 8008dae:	2001      	movs	r0, #1
 8008db0:	e7fb      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        return HAL_ERROR;
 8008db2:	2001      	movs	r0, #1
 8008db4:	e7f9      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 8008db6:	bf00      	nop
 8008db8:	40021000 	.word	0x40021000
 8008dbc:	019d808c 	.word	0x019d808c

08008dc0 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8008dc0:	2800      	cmp	r0, #0
 8008dc2:	f000 8098 	beq.w	8008ef6 <HAL_RCC_ClockConfig+0x136>
{
 8008dc6:	b570      	push	{r4, r5, r6, lr}
 8008dc8:	460c      	mov	r4, r1
 8008dca:	4605      	mov	r5, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8008dcc:	4b4e      	ldr	r3, [pc, #312]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008dce:	681b      	ldr	r3, [r3, #0]
 8008dd0:	f003 0307 	and.w	r3, r3, #7
 8008dd4:	428b      	cmp	r3, r1
 8008dd6:	d20b      	bcs.n	8008df0 <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008dd8:	4a4b      	ldr	r2, [pc, #300]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008dda:	6813      	ldr	r3, [r2, #0]
 8008ddc:	f023 0307 	bic.w	r3, r3, #7
 8008de0:	430b      	orrs	r3, r1
 8008de2:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008de4:	6813      	ldr	r3, [r2, #0]
 8008de6:	f003 0307 	and.w	r3, r3, #7
 8008dea:	428b      	cmp	r3, r1
 8008dec:	f040 8085 	bne.w	8008efa <HAL_RCC_ClockConfig+0x13a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008df0:	682b      	ldr	r3, [r5, #0]
 8008df2:	f013 0f01 	tst.w	r3, #1
 8008df6:	d039      	beq.n	8008e6c <HAL_RCC_ClockConfig+0xac>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008df8:	686b      	ldr	r3, [r5, #4]
 8008dfa:	2b03      	cmp	r3, #3
 8008dfc:	d009      	beq.n	8008e12 <HAL_RCC_ClockConfig+0x52>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008dfe:	2b02      	cmp	r3, #2
 8008e00:	d026      	beq.n	8008e50 <HAL_RCC_ClockConfig+0x90>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8008e02:	bb63      	cbnz	r3, 8008e5e <HAL_RCC_ClockConfig+0x9e>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008e04:	4a41      	ldr	r2, [pc, #260]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e06:	6812      	ldr	r2, [r2, #0]
 8008e08:	f012 0f02 	tst.w	r2, #2
 8008e0c:	d106      	bne.n	8008e1c <HAL_RCC_ClockConfig+0x5c>
          return HAL_ERROR;
 8008e0e:	2001      	movs	r0, #1
 8008e10:	e070      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008e12:	4a3e      	ldr	r2, [pc, #248]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e14:	6812      	ldr	r2, [r2, #0]
 8008e16:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8008e1a:	d070      	beq.n	8008efe <HAL_RCC_ClockConfig+0x13e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8008e1c:	493b      	ldr	r1, [pc, #236]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e1e:	688a      	ldr	r2, [r1, #8]
 8008e20:	f022 0203 	bic.w	r2, r2, #3
 8008e24:	4313      	orrs	r3, r2
 8008e26:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8008e28:	f7fe f8b6 	bl	8006f98 <HAL_GetTick>
 8008e2c:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8008e2e:	4b37      	ldr	r3, [pc, #220]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e30:	689b      	ldr	r3, [r3, #8]
 8008e32:	f003 030c 	and.w	r3, r3, #12
 8008e36:	686a      	ldr	r2, [r5, #4]
 8008e38:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8008e3c:	d016      	beq.n	8008e6c <HAL_RCC_ClockConfig+0xac>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008e3e:	f7fe f8ab 	bl	8006f98 <HAL_GetTick>
 8008e42:	1b80      	subs	r0, r0, r6
 8008e44:	f241 3388 	movw	r3, #5000	; 0x1388
 8008e48:	4298      	cmp	r0, r3
 8008e4a:	d9f0      	bls.n	8008e2e <HAL_RCC_ClockConfig+0x6e>
        return HAL_TIMEOUT;
 8008e4c:	2003      	movs	r0, #3
 8008e4e:	e051      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8008e50:	4a2e      	ldr	r2, [pc, #184]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e52:	6812      	ldr	r2, [r2, #0]
 8008e54:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8008e58:	d1e0      	bne.n	8008e1c <HAL_RCC_ClockConfig+0x5c>
          return HAL_ERROR;
 8008e5a:	2001      	movs	r0, #1
 8008e5c:	e04a      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8008e5e:	4a2b      	ldr	r2, [pc, #172]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e60:	6812      	ldr	r2, [r2, #0]
 8008e62:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8008e66:	d1d9      	bne.n	8008e1c <HAL_RCC_ClockConfig+0x5c>
          return HAL_ERROR;
 8008e68:	2001      	movs	r0, #1
 8008e6a:	e043      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008e6c:	682b      	ldr	r3, [r5, #0]
 8008e6e:	f013 0f02 	tst.w	r3, #2
 8008e72:	d006      	beq.n	8008e82 <HAL_RCC_ClockConfig+0xc2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008e74:	4a25      	ldr	r2, [pc, #148]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e76:	6893      	ldr	r3, [r2, #8]
 8008e78:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008e7c:	68a9      	ldr	r1, [r5, #8]
 8008e7e:	430b      	orrs	r3, r1
 8008e80:	6093      	str	r3, [r2, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8008e82:	4b21      	ldr	r3, [pc, #132]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008e84:	681b      	ldr	r3, [r3, #0]
 8008e86:	f003 0307 	and.w	r3, r3, #7
 8008e8a:	42a3      	cmp	r3, r4
 8008e8c:	d90a      	bls.n	8008ea4 <HAL_RCC_ClockConfig+0xe4>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008e8e:	4a1e      	ldr	r2, [pc, #120]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008e90:	6813      	ldr	r3, [r2, #0]
 8008e92:	f023 0307 	bic.w	r3, r3, #7
 8008e96:	4323      	orrs	r3, r4
 8008e98:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008e9a:	6813      	ldr	r3, [r2, #0]
 8008e9c:	f003 0307 	and.w	r3, r3, #7
 8008ea0:	42a3      	cmp	r3, r4
 8008ea2:	d12e      	bne.n	8008f02 <HAL_RCC_ClockConfig+0x142>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008ea4:	682b      	ldr	r3, [r5, #0]
 8008ea6:	f013 0f04 	tst.w	r3, #4
 8008eaa:	d006      	beq.n	8008eba <HAL_RCC_ClockConfig+0xfa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8008eac:	4a17      	ldr	r2, [pc, #92]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008eae:	6893      	ldr	r3, [r2, #8]
 8008eb0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8008eb4:	68e9      	ldr	r1, [r5, #12]
 8008eb6:	430b      	orrs	r3, r1
 8008eb8:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008eba:	682b      	ldr	r3, [r5, #0]
 8008ebc:	f013 0f08 	tst.w	r3, #8
 8008ec0:	d007      	beq.n	8008ed2 <HAL_RCC_ClockConfig+0x112>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8008ec2:	4a12      	ldr	r2, [pc, #72]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008ec4:	6893      	ldr	r3, [r2, #8]
 8008ec6:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8008eca:	6929      	ldr	r1, [r5, #16]
 8008ecc:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8008ed0:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8008ed2:	f7ff fbdb 	bl	800868c <HAL_RCC_GetSysClockFreq>
 8008ed6:	4b0d      	ldr	r3, [pc, #52]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008ed8:	689b      	ldr	r3, [r3, #8]
 8008eda:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8008ede:	4a0c      	ldr	r2, [pc, #48]	; (8008f10 <HAL_RCC_ClockConfig+0x150>)
 8008ee0:	5cd3      	ldrb	r3, [r2, r3]
 8008ee2:	f003 031f 	and.w	r3, r3, #31
 8008ee6:	40d8      	lsrs	r0, r3
 8008ee8:	4b0a      	ldr	r3, [pc, #40]	; (8008f14 <HAL_RCC_ClockConfig+0x154>)
 8008eea:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick(uwTickPrio);
 8008eec:	4b0a      	ldr	r3, [pc, #40]	; (8008f18 <HAL_RCC_ClockConfig+0x158>)
 8008eee:	6818      	ldr	r0, [r3, #0]
 8008ef0:	f7f8 fbfa 	bl	80016e8 <HAL_InitTick>
}
 8008ef4:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8008ef6:	2001      	movs	r0, #1
}
 8008ef8:	4770      	bx	lr
      return HAL_ERROR;
 8008efa:	2001      	movs	r0, #1
 8008efc:	e7fa      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
        return HAL_ERROR;
 8008efe:	2001      	movs	r0, #1
 8008f00:	e7f8      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
      return HAL_ERROR;
 8008f02:	2001      	movs	r0, #1
 8008f04:	e7f6      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
 8008f06:	bf00      	nop
 8008f08:	40022000 	.word	0x40022000
 8008f0c:	40021000 	.word	0x40021000
 8008f10:	0802d098 	.word	0x0802d098
 8008f14:	20000034 	.word	0x20000034
 8008f18:	2000003c 	.word	0x2000003c

08008f1c <HAL_RCC_GetHCLKFreq>:
}
 8008f1c:	4b01      	ldr	r3, [pc, #4]	; (8008f24 <HAL_RCC_GetHCLKFreq+0x8>)
 8008f1e:	6818      	ldr	r0, [r3, #0]
 8008f20:	4770      	bx	lr
 8008f22:	bf00      	nop
 8008f24:	20000034 	.word	0x20000034

08008f28 <HAL_RCC_GetPCLK1Freq>:
{
 8008f28:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8008f2a:	f7ff fff7 	bl	8008f1c <HAL_RCC_GetHCLKFreq>
 8008f2e:	4b05      	ldr	r3, [pc, #20]	; (8008f44 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8008f30:	689b      	ldr	r3, [r3, #8]
 8008f32:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8008f36:	4a04      	ldr	r2, [pc, #16]	; (8008f48 <HAL_RCC_GetPCLK1Freq+0x20>)
 8008f38:	5cd3      	ldrb	r3, [r2, r3]
 8008f3a:	f003 031f 	and.w	r3, r3, #31
}
 8008f3e:	40d8      	lsrs	r0, r3
 8008f40:	bd08      	pop	{r3, pc}
 8008f42:	bf00      	nop
 8008f44:	40021000 	.word	0x40021000
 8008f48:	0802d0a8 	.word	0x0802d0a8

08008f4c <HAL_RCC_GetPCLK2Freq>:
{
 8008f4c:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8008f4e:	f7ff ffe5 	bl	8008f1c <HAL_RCC_GetHCLKFreq>
 8008f52:	4b05      	ldr	r3, [pc, #20]	; (8008f68 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8008f54:	689b      	ldr	r3, [r3, #8]
 8008f56:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8008f5a:	4a04      	ldr	r2, [pc, #16]	; (8008f6c <HAL_RCC_GetPCLK2Freq+0x20>)
 8008f5c:	5cd3      	ldrb	r3, [r2, r3]
 8008f5e:	f003 031f 	and.w	r3, r3, #31
}
 8008f62:	40d8      	lsrs	r0, r3
 8008f64:	bd08      	pop	{r3, pc}
 8008f66:	bf00      	nop
 8008f68:	40021000 	.word	0x40021000
 8008f6c:	0802d0a8 	.word	0x0802d0a8

08008f70 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8008f70:	230f      	movs	r3, #15
 8008f72:	6003      	str	r3, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8008f74:	4b0b      	ldr	r3, [pc, #44]	; (8008fa4 <HAL_RCC_GetClockConfig+0x34>)
 8008f76:	689a      	ldr	r2, [r3, #8]
 8008f78:	f002 0203 	and.w	r2, r2, #3
 8008f7c:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
 8008f7e:	689a      	ldr	r2, [r3, #8]
 8008f80:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008f84:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
 8008f86:	689a      	ldr	r2, [r3, #8]
 8008f88:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8008f8c:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8008f8e:	689b      	ldr	r3, [r3, #8]
 8008f90:	08db      	lsrs	r3, r3, #3
 8008f92:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008f96:	6103      	str	r3, [r0, #16]
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8008f98:	4b03      	ldr	r3, [pc, #12]	; (8008fa8 <HAL_RCC_GetClockConfig+0x38>)
 8008f9a:	681b      	ldr	r3, [r3, #0]
 8008f9c:	f003 0307 	and.w	r3, r3, #7
 8008fa0:	600b      	str	r3, [r1, #0]
}
 8008fa2:	4770      	bx	lr
 8008fa4:	40021000 	.word	0x40021000
 8008fa8:	40022000 	.word	0x40022000

08008fac <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8008fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008fae:	4604      	mov	r4, r0
 8008fb0:	460f      	mov	r7, r1
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8008fb2:	4b58      	ldr	r3, [pc, #352]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8008fb4:	68db      	ldr	r3, [r3, #12]
 8008fb6:	f013 0f03 	tst.w	r3, #3
 8008fba:	d018      	beq.n	8008fee <RCCEx_PLLSAI1_Config+0x42>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8008fbc:	4b55      	ldr	r3, [pc, #340]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8008fbe:	68db      	ldr	r3, [r3, #12]
 8008fc0:	f003 0303 	and.w	r3, r3, #3
 8008fc4:	6802      	ldr	r2, [r0, #0]
 8008fc6:	4293      	cmp	r3, r2
 8008fc8:	d002      	beq.n	8008fd0 <RCCEx_PLLSAI1_Config+0x24>
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
#endif
      )
    {
      status = HAL_ERROR;
 8008fca:	2501      	movs	r5, #1
      }
    }
  }

  return status;
}
 8008fcc:	4628      	mov	r0, r5
 8008fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ||
 8008fd0:	2a00      	cmp	r2, #0
 8008fd2:	f000 809d 	beq.w	8009110 <RCCEx_PLLSAI1_Config+0x164>
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 8008fd6:	4b4f      	ldr	r3, [pc, #316]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8008fd8:	68db      	ldr	r3, [r3, #12]
 8008fda:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8008fde:	3301      	adds	r3, #1
 8008fe0:	6842      	ldr	r2, [r0, #4]
       ||
 8008fe2:	4293      	cmp	r3, r2
 8008fe4:	d001      	beq.n	8008fea <RCCEx_PLLSAI1_Config+0x3e>
      status = HAL_ERROR;
 8008fe6:	2501      	movs	r5, #1
 8008fe8:	e7f0      	b.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
  HAL_StatusTypeDef status = HAL_OK;
 8008fea:	2500      	movs	r5, #0
 8008fec:	e009      	b.n	8009002 <RCCEx_PLLSAI1_Config+0x56>
    switch(PllSai1->PLLSAI1Source)
 8008fee:	6803      	ldr	r3, [r0, #0]
 8008ff0:	2b02      	cmp	r3, #2
 8008ff2:	d056      	beq.n	80090a2 <RCCEx_PLLSAI1_Config+0xf6>
 8008ff4:	2b03      	cmp	r3, #3
 8008ff6:	d05b      	beq.n	80090b0 <RCCEx_PLLSAI1_Config+0x104>
 8008ff8:	2b01      	cmp	r3, #1
 8008ffa:	d041      	beq.n	8009080 <RCCEx_PLLSAI1_Config+0xd4>
 8008ffc:	2501      	movs	r5, #1
  if(status == HAL_OK)
 8008ffe:	2d00      	cmp	r5, #0
 8009000:	d1e4      	bne.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
    __HAL_RCC_PLLSAI1_DISABLE();
 8009002:	4a44      	ldr	r2, [pc, #272]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009004:	6813      	ldr	r3, [r2, #0]
 8009006:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800900a:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800900c:	f7fd ffc4 	bl	8006f98 <HAL_GetTick>
 8009010:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009012:	4b40      	ldr	r3, [pc, #256]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009014:	681b      	ldr	r3, [r3, #0]
 8009016:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 800901a:	d005      	beq.n	8009028 <RCCEx_PLLSAI1_Config+0x7c>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800901c:	f7fd ffbc 	bl	8006f98 <HAL_GetTick>
 8009020:	1b83      	subs	r3, r0, r6
 8009022:	2b02      	cmp	r3, #2
 8009024:	d9f5      	bls.n	8009012 <RCCEx_PLLSAI1_Config+0x66>
        status = HAL_TIMEOUT;
 8009026:	2503      	movs	r5, #3
    if(status == HAL_OK)
 8009028:	2d00      	cmp	r5, #0
 800902a:	d1cf      	bne.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
      if(Divider == DIVIDER_P_UPDATE)
 800902c:	2f00      	cmp	r7, #0
 800902e:	d14d      	bne.n	80090cc <RCCEx_PLLSAI1_Config+0x120>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8009030:	4938      	ldr	r1, [pc, #224]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009032:	690b      	ldr	r3, [r1, #16]
 8009034:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8009038:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800903c:	68a0      	ldr	r0, [r4, #8]
 800903e:	68e2      	ldr	r2, [r4, #12]
 8009040:	06d2      	lsls	r2, r2, #27
 8009042:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8009046:	4313      	orrs	r3, r2
 8009048:	610b      	str	r3, [r1, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 800904a:	4a32      	ldr	r2, [pc, #200]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 800904c:	6813      	ldr	r3, [r2, #0]
 800904e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8009052:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8009054:	f7fd ffa0 	bl	8006f98 <HAL_GetTick>
 8009058:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 800905a:	4b2e      	ldr	r3, [pc, #184]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 800905c:	681b      	ldr	r3, [r3, #0]
 800905e:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8009062:	d105      	bne.n	8009070 <RCCEx_PLLSAI1_Config+0xc4>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009064:	f7fd ff98 	bl	8006f98 <HAL_GetTick>
 8009068:	1b83      	subs	r3, r0, r6
 800906a:	2b02      	cmp	r3, #2
 800906c:	d9f5      	bls.n	800905a <RCCEx_PLLSAI1_Config+0xae>
          status = HAL_TIMEOUT;
 800906e:	2503      	movs	r5, #3
      if(status == HAL_OK)
 8009070:	2d00      	cmp	r5, #0
 8009072:	d1ab      	bne.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8009074:	4a27      	ldr	r2, [pc, #156]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009076:	6913      	ldr	r3, [r2, #16]
 8009078:	69a1      	ldr	r1, [r4, #24]
 800907a:	430b      	orrs	r3, r1
 800907c:	6113      	str	r3, [r2, #16]
 800907e:	e7a5      	b.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8009080:	4a24      	ldr	r2, [pc, #144]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009082:	6812      	ldr	r2, [r2, #0]
 8009084:	f012 0f02 	tst.w	r2, #2
 8009088:	d01e      	beq.n	80090c8 <RCCEx_PLLSAI1_Config+0x11c>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 800908a:	4822      	ldr	r0, [pc, #136]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 800908c:	68c2      	ldr	r2, [r0, #12]
 800908e:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8009092:	6861      	ldr	r1, [r4, #4]
 8009094:	3901      	subs	r1, #1
 8009096:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800909a:	4313      	orrs	r3, r2
 800909c:	60c3      	str	r3, [r0, #12]
 800909e:	2500      	movs	r5, #0
 80090a0:	e7ad      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80090a2:	4a1c      	ldr	r2, [pc, #112]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090a4:	6812      	ldr	r2, [r2, #0]
 80090a6:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80090aa:	d1ee      	bne.n	800908a <RCCEx_PLLSAI1_Config+0xde>
        status = HAL_ERROR;
 80090ac:	2501      	movs	r5, #1
 80090ae:	e7a6      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 80090b0:	4a18      	ldr	r2, [pc, #96]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090b2:	6812      	ldr	r2, [r2, #0]
 80090b4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80090b8:	d1e7      	bne.n	800908a <RCCEx_PLLSAI1_Config+0xde>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80090ba:	4a16      	ldr	r2, [pc, #88]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090bc:	6812      	ldr	r2, [r2, #0]
 80090be:	f412 2f80 	tst.w	r2, #262144	; 0x40000
 80090c2:	d1e2      	bne.n	800908a <RCCEx_PLLSAI1_Config+0xde>
          status = HAL_ERROR;
 80090c4:	2501      	movs	r5, #1
 80090c6:	e79a      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
        status = HAL_ERROR;
 80090c8:	2501      	movs	r5, #1
 80090ca:	e798      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
      else if(Divider == DIVIDER_Q_UPDATE)
 80090cc:	2f01      	cmp	r7, #1
 80090ce:	d00f      	beq.n	80090f0 <RCCEx_PLLSAI1_Config+0x144>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80090d0:	4810      	ldr	r0, [pc, #64]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090d2:	6902      	ldr	r2, [r0, #16]
 80090d4:	f022 62c0 	bic.w	r2, r2, #100663296	; 0x6000000
 80090d8:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80090dc:	68a1      	ldr	r1, [r4, #8]
 80090de:	6963      	ldr	r3, [r4, #20]
 80090e0:	085b      	lsrs	r3, r3, #1
 80090e2:	3b01      	subs	r3, #1
 80090e4:	065b      	lsls	r3, r3, #25
 80090e6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80090ea:	431a      	orrs	r2, r3
 80090ec:	6102      	str	r2, [r0, #16]
 80090ee:	e7ac      	b.n	800904a <RCCEx_PLLSAI1_Config+0x9e>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80090f0:	4808      	ldr	r0, [pc, #32]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090f2:	6902      	ldr	r2, [r0, #16]
 80090f4:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80090f8:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80090fc:	68a1      	ldr	r1, [r4, #8]
 80090fe:	6923      	ldr	r3, [r4, #16]
 8009100:	085b      	lsrs	r3, r3, #1
 8009102:	3b01      	subs	r3, #1
 8009104:	055b      	lsls	r3, r3, #21
 8009106:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800910a:	431a      	orrs	r2, r3
 800910c:	6102      	str	r2, [r0, #16]
 800910e:	e79c      	b.n	800904a <RCCEx_PLLSAI1_Config+0x9e>
      status = HAL_ERROR;
 8009110:	2501      	movs	r5, #1
 8009112:	e75b      	b.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
 8009114:	40021000 	.word	0x40021000

08009118 <HAL_RCCEx_PeriphCLKConfig>:
{
 8009118:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800911c:	b082      	sub	sp, #8
 800911e:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8009120:	6803      	ldr	r3, [r0, #0]
 8009122:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009126:	d025      	beq.n	8009174 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    switch(PeriphClkInit->Sai1ClockSelection)
 8009128:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800912a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800912e:	d006      	beq.n	800913e <HAL_RCCEx_PeriphCLKConfig+0x26>
 8009130:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8009134:	d012      	beq.n	800915c <HAL_RCCEx_PeriphCLKConfig+0x44>
 8009136:	b14b      	cbz	r3, 800914c <HAL_RCCEx_PeriphCLKConfig+0x34>
 8009138:	2601      	movs	r6, #1
 800913a:	4637      	mov	r7, r6
 800913c:	e01c      	b.n	8009178 <HAL_RCCEx_PeriphCLKConfig+0x60>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
 800913e:	4a44      	ldr	r2, [pc, #272]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009140:	68d3      	ldr	r3, [r2, #12]
 8009142:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009146:	60d3      	str	r3, [r2, #12]
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8009148:	2700      	movs	r7, #0
 800914a:	e008      	b.n	800915e <HAL_RCCEx_PeriphCLKConfig+0x46>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 800914c:	2100      	movs	r1, #0
 800914e:	3004      	adds	r0, #4
 8009150:	f7ff ff2c 	bl	8008fac <RCCEx_PLLSAI1_Config>
    if(ret == HAL_OK)
 8009154:	4607      	mov	r7, r0
 8009156:	b110      	cbz	r0, 800915e <HAL_RCCEx_PeriphCLKConfig+0x46>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8009158:	4606      	mov	r6, r0
 800915a:	e00d      	b.n	8009178 <HAL_RCCEx_PeriphCLKConfig+0x60>
    switch(PeriphClkInit->Sai1ClockSelection)
 800915c:	2700      	movs	r7, #0
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800915e:	4a3c      	ldr	r2, [pc, #240]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009160:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009164:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8009168:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800916a:	430b      	orrs	r3, r1
 800916c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8009170:	2600      	movs	r6, #0
 8009172:	e001      	b.n	8009178 <HAL_RCCEx_PeriphCLKConfig+0x60>
 8009174:	2600      	movs	r6, #0
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8009176:	4637      	mov	r7, r6
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8009178:	6823      	ldr	r3, [r4, #0]
 800917a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800917e:	d070      	beq.n	8009262 <HAL_RCCEx_PeriphCLKConfig+0x14a>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8009180:	4b33      	ldr	r3, [pc, #204]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009182:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009184:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8009188:	d14c      	bne.n	8009224 <HAL_RCCEx_PeriphCLKConfig+0x10c>
      __HAL_RCC_PWR_CLK_ENABLE();
 800918a:	4b31      	ldr	r3, [pc, #196]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 800918c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800918e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8009192:	659a      	str	r2, [r3, #88]	; 0x58
 8009194:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009196:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800919a:	9301      	str	r3, [sp, #4]
 800919c:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800919e:	f04f 0801 	mov.w	r8, #1
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80091a2:	4a2c      	ldr	r2, [pc, #176]	; (8009254 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 80091a4:	6813      	ldr	r3, [r2, #0]
 80091a6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80091aa:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 80091ac:	f7fd fef4 	bl	8006f98 <HAL_GetTick>
 80091b0:	4605      	mov	r5, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 80091b2:	4b28      	ldr	r3, [pc, #160]	; (8009254 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 80091b4:	681b      	ldr	r3, [r3, #0]
 80091b6:	f413 7f80 	tst.w	r3, #256	; 0x100
 80091ba:	d105      	bne.n	80091c8 <HAL_RCCEx_PeriphCLKConfig+0xb0>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80091bc:	f7fd feec 	bl	8006f98 <HAL_GetTick>
 80091c0:	1b40      	subs	r0, r0, r5
 80091c2:	2802      	cmp	r0, #2
 80091c4:	d9f5      	bls.n	80091b2 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        ret = HAL_TIMEOUT;
 80091c6:	2703      	movs	r7, #3
    if(ret == HAL_OK)
 80091c8:	2f00      	cmp	r7, #0
 80091ca:	d145      	bne.n	8009258 <HAL_RCCEx_PeriphCLKConfig+0x140>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80091cc:	4b20      	ldr	r3, [pc, #128]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 80091ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80091d2:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80091d6:	d015      	beq.n	8009204 <HAL_RCCEx_PeriphCLKConfig+0xec>
 80091d8:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80091da:	429a      	cmp	r2, r3
 80091dc:	d012      	beq.n	8009204 <HAL_RCCEx_PeriphCLKConfig+0xec>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80091de:	4a1c      	ldr	r2, [pc, #112]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 80091e0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80091e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 80091e8:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 80091ec:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 80091f0:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 80091f4:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 80091f8:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 80091fc:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8009200:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8009204:	f013 0f01 	tst.w	r3, #1
 8009208:	d10f      	bne.n	800922a <HAL_RCCEx_PeriphCLKConfig+0x112>
      if(ret == HAL_OK)
 800920a:	2f00      	cmp	r7, #0
 800920c:	f040 8116 	bne.w	800943c <HAL_RCCEx_PeriphCLKConfig+0x324>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8009210:	4a0f      	ldr	r2, [pc, #60]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009212:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8009216:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800921a:	6e61      	ldr	r1, [r4, #100]	; 0x64
 800921c:	430b      	orrs	r3, r1
 800921e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8009222:	e01a      	b.n	800925a <HAL_RCCEx_PeriphCLKConfig+0x142>
    FlagStatus       pwrclkchanged = RESET;
 8009224:	f04f 0800 	mov.w	r8, #0
 8009228:	e7bb      	b.n	80091a2 <HAL_RCCEx_PeriphCLKConfig+0x8a>
        tickstart = HAL_GetTick();
 800922a:	f7fd feb5 	bl	8006f98 <HAL_GetTick>
 800922e:	4605      	mov	r5, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8009230:	4b07      	ldr	r3, [pc, #28]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009232:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8009236:	f013 0f02 	tst.w	r3, #2
 800923a:	d1e6      	bne.n	800920a <HAL_RCCEx_PeriphCLKConfig+0xf2>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800923c:	f7fd feac 	bl	8006f98 <HAL_GetTick>
 8009240:	1b40      	subs	r0, r0, r5
 8009242:	f241 3388 	movw	r3, #5000	; 0x1388
 8009246:	4298      	cmp	r0, r3
 8009248:	d9f2      	bls.n	8009230 <HAL_RCCEx_PeriphCLKConfig+0x118>
            ret = HAL_TIMEOUT;
 800924a:	2703      	movs	r7, #3
 800924c:	e7dd      	b.n	800920a <HAL_RCCEx_PeriphCLKConfig+0xf2>
 800924e:	bf00      	nop
 8009250:	40021000 	.word	0x40021000
 8009254:	40007000 	.word	0x40007000
      status = ret;
 8009258:	463e      	mov	r6, r7
    if(pwrclkchanged == SET)
 800925a:	f1b8 0f00 	cmp.w	r8, #0
 800925e:	f040 80ef 	bne.w	8009440 <HAL_RCCEx_PeriphCLKConfig+0x328>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8009262:	6823      	ldr	r3, [r4, #0]
 8009264:	f013 0f01 	tst.w	r3, #1
 8009268:	d008      	beq.n	800927c <HAL_RCCEx_PeriphCLKConfig+0x164>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800926a:	4a90      	ldr	r2, [pc, #576]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 800926c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009270:	f023 0303 	bic.w	r3, r3, #3
 8009274:	6a21      	ldr	r1, [r4, #32]
 8009276:	430b      	orrs	r3, r1
 8009278:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800927c:	6823      	ldr	r3, [r4, #0]
 800927e:	f013 0f02 	tst.w	r3, #2
 8009282:	d008      	beq.n	8009296 <HAL_RCCEx_PeriphCLKConfig+0x17e>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8009284:	4a89      	ldr	r2, [pc, #548]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009286:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800928a:	f023 030c 	bic.w	r3, r3, #12
 800928e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8009290:	430b      	orrs	r3, r1
 8009292:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8009296:	6823      	ldr	r3, [r4, #0]
 8009298:	f013 0f04 	tst.w	r3, #4
 800929c:	d008      	beq.n	80092b0 <HAL_RCCEx_PeriphCLKConfig+0x198>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800929e:	4a83      	ldr	r2, [pc, #524]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092a0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092a4:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80092a8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80092aa:	430b      	orrs	r3, r1
 80092ac:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80092b0:	6823      	ldr	r3, [r4, #0]
 80092b2:	f013 0f08 	tst.w	r3, #8
 80092b6:	d008      	beq.n	80092ca <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80092b8:	4a7c      	ldr	r2, [pc, #496]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092ba:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092be:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80092c2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80092c4:	430b      	orrs	r3, r1
 80092c6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80092ca:	6823      	ldr	r3, [r4, #0]
 80092cc:	f013 0f20 	tst.w	r3, #32
 80092d0:	d008      	beq.n	80092e4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80092d2:	4a76      	ldr	r2, [pc, #472]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092d4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092d8:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80092dc:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80092de:	430b      	orrs	r3, r1
 80092e0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80092e4:	6823      	ldr	r3, [r4, #0]
 80092e6:	f413 7f00 	tst.w	r3, #512	; 0x200
 80092ea:	d008      	beq.n	80092fe <HAL_RCCEx_PeriphCLKConfig+0x1e6>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80092ec:	4a6f      	ldr	r2, [pc, #444]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092ee:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092f2:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 80092f6:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80092f8:	430b      	orrs	r3, r1
 80092fa:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80092fe:	6823      	ldr	r3, [r4, #0]
 8009300:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009304:	d008      	beq.n	8009318 <HAL_RCCEx_PeriphCLKConfig+0x200>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8009306:	4a69      	ldr	r2, [pc, #420]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009308:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800930c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8009310:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8009312:	430b      	orrs	r3, r1
 8009314:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8009318:	6823      	ldr	r3, [r4, #0]
 800931a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800931e:	d008      	beq.n	8009332 <HAL_RCCEx_PeriphCLKConfig+0x21a>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8009320:	4a62      	ldr	r2, [pc, #392]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009322:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009326:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800932a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800932c:	430b      	orrs	r3, r1
 800932e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8009332:	6823      	ldr	r3, [r4, #0]
 8009334:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009338:	d008      	beq.n	800934c <HAL_RCCEx_PeriphCLKConfig+0x234>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800933a:	4a5c      	ldr	r2, [pc, #368]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 800933c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009340:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8009344:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8009346:	430b      	orrs	r3, r1
 8009348:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800934c:	6823      	ldr	r3, [r4, #0]
 800934e:	f413 7f80 	tst.w	r3, #256	; 0x100
 8009352:	d008      	beq.n	8009366 <HAL_RCCEx_PeriphCLKConfig+0x24e>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8009354:	4a55      	ldr	r2, [pc, #340]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009356:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800935a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 800935e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8009360:	430b      	orrs	r3, r1
 8009362:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8009366:	6823      	ldr	r3, [r4, #0]
 8009368:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800936c:	d008      	beq.n	8009380 <HAL_RCCEx_PeriphCLKConfig+0x268>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800936e:	4a4f      	ldr	r2, [pc, #316]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009370:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8009374:	f023 0303 	bic.w	r3, r3, #3
 8009378:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800937a:	430b      	orrs	r3, r1
 800937c:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8009380:	6823      	ldr	r3, [r4, #0]
 8009382:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 8009386:	d00f      	beq.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8009388:	4a48      	ldr	r2, [pc, #288]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 800938a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800938e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8009392:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8009394:	430b      	orrs	r3, r1
 8009396:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800939a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800939c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80093a0:	d054      	beq.n	800944c <HAL_RCCEx_PeriphCLKConfig+0x334>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 80093a2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80093a6:	d056      	beq.n	8009456 <HAL_RCCEx_PeriphCLKConfig+0x33e>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80093a8:	6823      	ldr	r3, [r4, #0]
 80093aa:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 80093ae:	d00f      	beq.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80093b0:	4a3e      	ldr	r2, [pc, #248]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80093b2:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80093b6:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80093ba:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80093bc:	430b      	orrs	r3, r1
 80093be:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80093c2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80093c4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80093c8:	d04d      	beq.n	8009466 <HAL_RCCEx_PeriphCLKConfig+0x34e>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80093ca:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80093ce:	d04f      	beq.n	8009470 <HAL_RCCEx_PeriphCLKConfig+0x358>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80093d0:	6823      	ldr	r3, [r4, #0]
 80093d2:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80093d6:	d00f      	beq.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80093d8:	4a34      	ldr	r2, [pc, #208]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80093da:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80093de:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80093e2:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80093e4:	430b      	orrs	r3, r1
 80093e6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80093ea:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80093ec:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80093f0:	d046      	beq.n	8009480 <HAL_RCCEx_PeriphCLKConfig+0x368>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 80093f2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80093f6:	d048      	beq.n	800948a <HAL_RCCEx_PeriphCLKConfig+0x372>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80093f8:	6823      	ldr	r3, [r4, #0]
 80093fa:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80093fe:	d00c      	beq.n	800941a <HAL_RCCEx_PeriphCLKConfig+0x302>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8009400:	4a2a      	ldr	r2, [pc, #168]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009402:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009406:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800940a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800940c:	430b      	orrs	r3, r1
 800940e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8009412:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8009414:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8009418:	d03f      	beq.n	800949a <HAL_RCCEx_PeriphCLKConfig+0x382>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800941a:	6823      	ldr	r3, [r4, #0]
 800941c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8009420:	d008      	beq.n	8009434 <HAL_RCCEx_PeriphCLKConfig+0x31c>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8009422:	4a22      	ldr	r2, [pc, #136]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009424:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009428:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800942c:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800942e:	430b      	orrs	r3, r1
 8009430:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
 8009434:	4630      	mov	r0, r6
 8009436:	b002      	add	sp, #8
 8009438:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = ret;
 800943c:	463e      	mov	r6, r7
 800943e:	e70c      	b.n	800925a <HAL_RCCEx_PeriphCLKConfig+0x142>
      __HAL_RCC_PWR_CLK_DISABLE();
 8009440:	4a1a      	ldr	r2, [pc, #104]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009442:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009444:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009448:	6593      	str	r3, [r2, #88]	; 0x58
 800944a:	e70a      	b.n	8009262 <HAL_RCCEx_PeriphCLKConfig+0x14a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800944c:	68d3      	ldr	r3, [r2, #12]
 800944e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009452:	60d3      	str	r3, [r2, #12]
 8009454:	e7a8      	b.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8009456:	2101      	movs	r1, #1
 8009458:	1d20      	adds	r0, r4, #4
 800945a:	f7ff fda7 	bl	8008fac <RCCEx_PLLSAI1_Config>
        if(ret != HAL_OK)
 800945e:	2800      	cmp	r0, #0
 8009460:	d0a2      	beq.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
          status = ret;
 8009462:	4606      	mov	r6, r0
 8009464:	e7a0      	b.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8009466:	68d3      	ldr	r3, [r2, #12]
 8009468:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800946c:	60d3      	str	r3, [r2, #12]
 800946e:	e7af      	b.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8009470:	2101      	movs	r1, #1
 8009472:	1d20      	adds	r0, r4, #4
 8009474:	f7ff fd9a 	bl	8008fac <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8009478:	2800      	cmp	r0, #0
 800947a:	d0a9      	beq.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
        status = ret;
 800947c:	4606      	mov	r6, r0
 800947e:	e7a7      	b.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8009480:	68d3      	ldr	r3, [r2, #12]
 8009482:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009486:	60d3      	str	r3, [r2, #12]
 8009488:	e7b6      	b.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800948a:	2101      	movs	r1, #1
 800948c:	1d20      	adds	r0, r4, #4
 800948e:	f7ff fd8d 	bl	8008fac <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8009492:	2800      	cmp	r0, #0
 8009494:	d0b0      	beq.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
        status = ret;
 8009496:	4606      	mov	r6, r0
 8009498:	e7ae      	b.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 800949a:	2102      	movs	r1, #2
 800949c:	1d20      	adds	r0, r4, #4
 800949e:	f7ff fd85 	bl	8008fac <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 80094a2:	2800      	cmp	r0, #0
 80094a4:	d0b9      	beq.n	800941a <HAL_RCCEx_PeriphCLKConfig+0x302>
        status = ret;
 80094a6:	4606      	mov	r6, r0
 80094a8:	e7b7      	b.n	800941a <HAL_RCCEx_PeriphCLKConfig+0x302>
 80094aa:	bf00      	nop
 80094ac:	40021000 	.word	0x40021000

080094b0 <HAL_RCCEx_EnableMSIPLLMode>:
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 80094b0:	4a02      	ldr	r2, [pc, #8]	; (80094bc <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 80094b2:	6813      	ldr	r3, [r2, #0]
 80094b4:	f043 0304 	orr.w	r3, r3, #4
 80094b8:	6013      	str	r3, [r2, #0]
}
 80094ba:	4770      	bx	lr
 80094bc:	40021000 	.word	0x40021000

080094c0 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 80094c0:	b378      	cbz	r0, 8009522 <HAL_RNG_Init+0x62>
{
 80094c2:	b538      	push	{r3, r4, r5, lr}
 80094c4:	4604      	mov	r4, r0

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 80094c6:	7943      	ldrb	r3, [r0, #5]
 80094c8:	b17b      	cbz	r3, 80094ea <HAL_RNG_Init+0x2a>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 80094ca:	2302      	movs	r3, #2
 80094cc:	7163      	strb	r3, [r4, #5]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
#endif /* defined(RNG_CR_CED) */
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 80094ce:	6822      	ldr	r2, [r4, #0]
 80094d0:	6813      	ldr	r3, [r2, #0]
 80094d2:	f043 0304 	orr.w	r3, r3, #4
 80094d6:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 80094d8:	6823      	ldr	r3, [r4, #0]
 80094da:	685b      	ldr	r3, [r3, #4]
 80094dc:	f013 0f40 	tst.w	r3, #64	; 0x40
 80094e0:	d007      	beq.n	80094f2 <HAL_RNG_Init+0x32>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 80094e2:	2304      	movs	r3, #4
 80094e4:	7163      	strb	r3, [r4, #5]
    return HAL_ERROR;
 80094e6:	2001      	movs	r0, #1
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 80094e8:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
 80094ea:	7103      	strb	r3, [r0, #4]
    HAL_RNG_MspInit(hrng);
 80094ec:	f7f7 ffc0 	bl	8001470 <HAL_RNG_MspInit>
 80094f0:	e7eb      	b.n	80094ca <HAL_RNG_Init+0xa>
  tickstart = HAL_GetTick();
 80094f2:	f7fd fd51 	bl	8006f98 <HAL_GetTick>
 80094f6:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 80094f8:	6823      	ldr	r3, [r4, #0]
 80094fa:	685b      	ldr	r3, [r3, #4]
 80094fc:	f013 0f04 	tst.w	r3, #4
 8009500:	d00a      	beq.n	8009518 <HAL_RNG_Init+0x58>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8009502:	f7fd fd49 	bl	8006f98 <HAL_GetTick>
 8009506:	1b40      	subs	r0, r0, r5
 8009508:	2802      	cmp	r0, #2
 800950a:	d9f5      	bls.n	80094f8 <HAL_RNG_Init+0x38>
      hrng->State = HAL_RNG_STATE_ERROR;
 800950c:	2304      	movs	r3, #4
 800950e:	7163      	strb	r3, [r4, #5]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8009510:	2302      	movs	r3, #2
 8009512:	60a3      	str	r3, [r4, #8]
      return HAL_ERROR;
 8009514:	2001      	movs	r0, #1
 8009516:	e7e7      	b.n	80094e8 <HAL_RNG_Init+0x28>
  hrng->State = HAL_RNG_STATE_READY;
 8009518:	2301      	movs	r3, #1
 800951a:	7163      	strb	r3, [r4, #5]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 800951c:	2000      	movs	r0, #0
 800951e:	60a0      	str	r0, [r4, #8]
  return HAL_OK;
 8009520:	e7e2      	b.n	80094e8 <HAL_RNG_Init+0x28>
    return HAL_ERROR;
 8009522:	2001      	movs	r0, #1
}
 8009524:	4770      	bx	lr

08009526 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 8009526:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 8009528:	7903      	ldrb	r3, [r0, #4]
 800952a:	2b01      	cmp	r3, #1
 800952c:	d02b      	beq.n	8009586 <HAL_RNG_GenerateRandomNumber+0x60>
 800952e:	4604      	mov	r4, r0
 8009530:	460e      	mov	r6, r1
 8009532:	2301      	movs	r3, #1
 8009534:	7103      	strb	r3, [r0, #4]

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 8009536:	7945      	ldrb	r5, [r0, #5]
 8009538:	b2ed      	uxtb	r5, r5
 800953a:	429d      	cmp	r5, r3
 800953c:	d006      	beq.n	800954c <HAL_RNG_GenerateRandomNumber+0x26>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800953e:	2304      	movs	r3, #4
 8009540:	6083      	str	r3, [r0, #8]
    status = HAL_ERROR;
 8009542:	2501      	movs	r5, #1
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8009544:	2300      	movs	r3, #0
 8009546:	7123      	strb	r3, [r4, #4]

  return status;
}
 8009548:	4628      	mov	r0, r5
 800954a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
 800954c:	2302      	movs	r3, #2
 800954e:	7143      	strb	r3, [r0, #5]
    tickstart = HAL_GetTick();
 8009550:	f7fd fd22 	bl	8006f98 <HAL_GetTick>
 8009554:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8009556:	6823      	ldr	r3, [r4, #0]
 8009558:	685a      	ldr	r2, [r3, #4]
 800955a:	f012 0f01 	tst.w	r2, #1
 800955e:	d10b      	bne.n	8009578 <HAL_RNG_GenerateRandomNumber+0x52>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8009560:	f7fd fd1a 	bl	8006f98 <HAL_GetTick>
 8009564:	1bc0      	subs	r0, r0, r7
 8009566:	2802      	cmp	r0, #2
 8009568:	d9f5      	bls.n	8009556 <HAL_RNG_GenerateRandomNumber+0x30>
        hrng->State = HAL_RNG_STATE_READY;
 800956a:	2301      	movs	r3, #1
 800956c:	7163      	strb	r3, [r4, #5]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800956e:	2302      	movs	r3, #2
 8009570:	60a3      	str	r3, [r4, #8]
        __HAL_UNLOCK(hrng);
 8009572:	2300      	movs	r3, #0
 8009574:	7123      	strb	r3, [r4, #4]
        return HAL_ERROR;
 8009576:	e7e7      	b.n	8009548 <HAL_RNG_GenerateRandomNumber+0x22>
    hrng->RandomNumber = hrng->Instance->DR;
 8009578:	689b      	ldr	r3, [r3, #8]
 800957a:	60e3      	str	r3, [r4, #12]
    *random32bit = hrng->RandomNumber;
 800957c:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
 800957e:	2301      	movs	r3, #1
 8009580:	7163      	strb	r3, [r4, #5]
  HAL_StatusTypeDef status = HAL_OK;
 8009582:	2500      	movs	r5, #0
 8009584:	e7de      	b.n	8009544 <HAL_RNG_GenerateRandomNumber+0x1e>
  __HAL_LOCK(hrng);
 8009586:	2502      	movs	r5, #2
 8009588:	e7de      	b.n	8009548 <HAL_RNG_GenerateRandomNumber+0x22>

0800958a <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 800958a:	b538      	push	{r3, r4, r5, lr}
 800958c:	4604      	mov	r4, r0

  /* Clear RSF flag */
#if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
  hrtc->Instance->ICSR &= (uint32_t)RTC_RSF_MASK;
#else
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 800958e:	6802      	ldr	r2, [r0, #0]
 8009590:	68d3      	ldr	r3, [r2, #12]
 8009592:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8009596:	60d3      	str	r3, [r2, #12]
#endif

  tickstart = HAL_GetTick();
 8009598:	f7fd fcfe 	bl	8006f98 <HAL_GetTick>
 800959c:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
#if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
  while ((hrtc->Instance->ICSR & RTC_ICSR_RSF) == 0U)
#else
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800959e:	6823      	ldr	r3, [r4, #0]
 80095a0:	68db      	ldr	r3, [r3, #12]
 80095a2:	f013 0f20 	tst.w	r3, #32
 80095a6:	d107      	bne.n	80095b8 <HAL_RTC_WaitForSynchro+0x2e>
#endif
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80095a8:	f7fd fcf6 	bl	8006f98 <HAL_GetTick>
 80095ac:	1b40      	subs	r0, r0, r5
 80095ae:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80095b2:	d9f4      	bls.n	800959e <HAL_RTC_WaitForSynchro+0x14>
    {
      return HAL_TIMEOUT;
 80095b4:	2003      	movs	r0, #3
 80095b6:	e000      	b.n	80095ba <HAL_RTC_WaitForSynchro+0x30>
    }
  }

  return HAL_OK;
 80095b8:	2000      	movs	r0, #0
}
 80095ba:	bd38      	pop	{r3, r4, r5, pc}

080095bc <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 80095bc:	b570      	push	{r4, r5, r6, lr}
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
      }
    }
  }
#else /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 80095be:	6803      	ldr	r3, [r0, #0]
 80095c0:	68da      	ldr	r2, [r3, #12]
 80095c2:	f012 0f40 	tst.w	r2, #64	; 0x40
 80095c6:	d002      	beq.n	80095ce <RTC_EnterInitMode+0x12>
  HAL_StatusTypeDef status = HAL_OK;
 80095c8:	2500      	movs	r5, #0
    }
  }
#endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */

  return status;
}
 80095ca:	4628      	mov	r0, r5
 80095cc:	bd70      	pop	{r4, r5, r6, pc}
 80095ce:	4604      	mov	r4, r0
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80095d0:	f04f 32ff 	mov.w	r2, #4294967295
 80095d4:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 80095d6:	f7fd fcdf 	bl	8006f98 <HAL_GetTick>
 80095da:	4606      	mov	r6, r0
  HAL_StatusTypeDef status = HAL_OK;
 80095dc:	2500      	movs	r5, #0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80095de:	6823      	ldr	r3, [r4, #0]
 80095e0:	68db      	ldr	r3, [r3, #12]
 80095e2:	f013 0f40 	tst.w	r3, #64	; 0x40
 80095e6:	d1f0      	bne.n	80095ca <RTC_EnterInitMode+0xe>
 80095e8:	2d03      	cmp	r5, #3
 80095ea:	d0ee      	beq.n	80095ca <RTC_EnterInitMode+0xe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 80095ec:	f7fd fcd4 	bl	8006f98 <HAL_GetTick>
 80095f0:	1b83      	subs	r3, r0, r6
 80095f2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80095f6:	d9f2      	bls.n	80095de <RTC_EnterInitMode+0x22>
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80095f8:	2503      	movs	r5, #3
 80095fa:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21
 80095fe:	e7ee      	b.n	80095de <RTC_EnterInitMode+0x22>

08009600 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8009600:	b510      	push	{r4, lr}
 8009602:	4604      	mov	r4, r0
  /* Exit Initialization mode */
#if defined(STM32L412xx) || defined(STM32L422xx) || defined(STM32L4P5xx) || defined(STM32L4Q5xx)
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
#else
  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ISR, RTC_ISR_INIT);
 8009604:	4b10      	ldr	r3, [pc, #64]	; (8009648 <RTC_ExitInitMode+0x48>)
 8009606:	68da      	ldr	r2, [r3, #12]
 8009608:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800960c:	60da      	str	r2, [r3, #12]
#endif

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 800960e:	689b      	ldr	r3, [r3, #8]
 8009610:	f013 0f20 	tst.w	r3, #32
 8009614:	d106      	bne.n	8009624 <RTC_ExitInitMode+0x24>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8009616:	f7ff ffb8 	bl	800958a <HAL_RTC_WaitForSynchro>
 800961a:	b198      	cbz	r0, 8009644 <RTC_ExitInitMode+0x44>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800961c:	2003      	movs	r0, #3
 800961e:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      status = HAL_TIMEOUT;
 8009622:	e00f      	b.n	8009644 <RTC_ExitInitMode+0x44>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8009624:	4a08      	ldr	r2, [pc, #32]	; (8009648 <RTC_ExitInitMode+0x48>)
 8009626:	6893      	ldr	r3, [r2, #8]
 8009628:	f023 0320 	bic.w	r3, r3, #32
 800962c:	6093      	str	r3, [r2, #8]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800962e:	f7ff ffac 	bl	800958a <HAL_RTC_WaitForSynchro>
 8009632:	b110      	cbz	r0, 800963a <RTC_ExitInitMode+0x3a>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8009634:	2003      	movs	r0, #3
 8009636:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      status = HAL_TIMEOUT;
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 800963a:	4a03      	ldr	r2, [pc, #12]	; (8009648 <RTC_ExitInitMode+0x48>)
 800963c:	6893      	ldr	r3, [r2, #8]
 800963e:	f043 0320 	orr.w	r3, r3, #32
 8009642:	6093      	str	r3, [r2, #8]
  }

  return status;
}
 8009644:	bd10      	pop	{r4, pc}
 8009646:	bf00      	nop
 8009648:	40002800 	.word	0x40002800

0800964c <HAL_RTC_Init>:
  if (hrtc != NULL)
 800964c:	2800      	cmp	r0, #0
 800964e:	d048      	beq.n	80096e2 <HAL_RTC_Init+0x96>
{
 8009650:	b538      	push	{r3, r4, r5, lr}
 8009652:	4604      	mov	r4, r0
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8009654:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8009658:	b16b      	cbz	r3, 8009676 <HAL_RTC_Init+0x2a>
    hrtc->State = HAL_RTC_STATE_BUSY;
 800965a:	2302      	movs	r3, #2
 800965c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009660:	6823      	ldr	r3, [r4, #0]
 8009662:	22ca      	movs	r2, #202	; 0xca
 8009664:	625a      	str	r2, [r3, #36]	; 0x24
 8009666:	6823      	ldr	r3, [r4, #0]
 8009668:	2253      	movs	r2, #83	; 0x53
 800966a:	625a      	str	r2, [r3, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 800966c:	4620      	mov	r0, r4
 800966e:	f7ff ffa5 	bl	80095bc <RTC_EnterInitMode>
    if (status == HAL_OK)
 8009672:	b128      	cbz	r0, 8009680 <HAL_RTC_Init+0x34>
}
 8009674:	bd38      	pop	{r3, r4, r5, pc}
      hrtc->Lock = HAL_UNLOCKED;
 8009676:	f880 3020 	strb.w	r3, [r0, #32]
      HAL_RTC_MspInit(hrtc);
 800967a:	f7f7 ff2b 	bl	80014d4 <HAL_RTC_MspInit>
 800967e:	e7ec      	b.n	800965a <HAL_RTC_Init+0xe>
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 8009680:	6822      	ldr	r2, [r4, #0]
 8009682:	6893      	ldr	r3, [r2, #8]
 8009684:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8009688:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800968c:	6093      	str	r3, [r2, #8]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 800968e:	6821      	ldr	r1, [r4, #0]
 8009690:	688a      	ldr	r2, [r1, #8]
 8009692:	6863      	ldr	r3, [r4, #4]
 8009694:	6920      	ldr	r0, [r4, #16]
 8009696:	4303      	orrs	r3, r0
 8009698:	69a0      	ldr	r0, [r4, #24]
 800969a:	4303      	orrs	r3, r0
 800969c:	4313      	orrs	r3, r2
 800969e:	608b      	str	r3, [r1, #8]
      hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
 80096a0:	6823      	ldr	r3, [r4, #0]
 80096a2:	68e2      	ldr	r2, [r4, #12]
 80096a4:	611a      	str	r2, [r3, #16]
      hrtc->Instance->PRER |= (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 80096a6:	6822      	ldr	r2, [r4, #0]
 80096a8:	6913      	ldr	r3, [r2, #16]
 80096aa:	68a1      	ldr	r1, [r4, #8]
 80096ac:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80096b0:	6113      	str	r3, [r2, #16]
      status = RTC_ExitInitMode(hrtc);
 80096b2:	4620      	mov	r0, r4
 80096b4:	f7ff ffa4 	bl	8009600 <RTC_ExitInitMode>
      if (status == HAL_OK)
 80096b8:	2800      	cmp	r0, #0
 80096ba:	d1db      	bne.n	8009674 <HAL_RTC_Init+0x28>
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 80096bc:	6822      	ldr	r2, [r4, #0]
 80096be:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80096c0:	f023 0303 	bic.w	r3, r3, #3
 80096c4:	64d3      	str	r3, [r2, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80096c6:	6821      	ldr	r1, [r4, #0]
 80096c8:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 80096ca:	69e2      	ldr	r2, [r4, #28]
 80096cc:	6965      	ldr	r5, [r4, #20]
 80096ce:	432a      	orrs	r2, r5
 80096d0:	4313      	orrs	r3, r2
 80096d2:	64cb      	str	r3, [r1, #76]	; 0x4c
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80096d4:	6823      	ldr	r3, [r4, #0]
 80096d6:	22ff      	movs	r2, #255	; 0xff
 80096d8:	625a      	str	r2, [r3, #36]	; 0x24
          hrtc->State = HAL_RTC_STATE_READY;
 80096da:	2301      	movs	r3, #1
 80096dc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 80096e0:	e7c8      	b.n	8009674 <HAL_RTC_Init+0x28>
  HAL_StatusTypeDef status = HAL_ERROR;
 80096e2:	2001      	movs	r0, #1
}
 80096e4:	4770      	bx	lr

080096e6 <HAL_SPI_Init>:
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80096e6:	2800      	cmp	r0, #0
 80096e8:	d06a      	beq.n	80097c0 <HAL_SPI_Init+0xda>
{
 80096ea:	b510      	push	{r4, lr}
 80096ec:	4604      	mov	r4, r0
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80096ee:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80096f0:	b933      	cbnz	r3, 8009700 <HAL_SPI_Init+0x1a>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80096f2:	6843      	ldr	r3, [r0, #4]
 80096f4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80096f8:	d005      	beq.n	8009706 <HAL_SPI_Init+0x20>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80096fa:	2300      	movs	r3, #0
 80096fc:	61c3      	str	r3, [r0, #28]
 80096fe:	e002      	b.n	8009706 <HAL_SPI_Init+0x20>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8009700:	2300      	movs	r3, #0
 8009702:	6103      	str	r3, [r0, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8009704:	6143      	str	r3, [r0, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009706:	2300      	movs	r3, #0
 8009708:	62a3      	str	r3, [r4, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800970a:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 800970e:	2b00      	cmp	r3, #0
 8009710:	d04d      	beq.n	80097ae <HAL_SPI_Init+0xc8>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8009712:	2302      	movs	r3, #2
 8009714:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8009718:	6822      	ldr	r2, [r4, #0]
 800971a:	6813      	ldr	r3, [r2, #0]
 800971c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009720:	6013      	str	r3, [r2, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009722:	68e3      	ldr	r3, [r4, #12]
 8009724:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009728:	d947      	bls.n	80097ba <HAL_SPI_Init+0xd4>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800972a:	2200      	movs	r2, #0
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800972c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8009730:	d004      	beq.n	800973c <HAL_SPI_Init+0x56>
 8009732:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009736:	d001      	beq.n	800973c <HAL_SPI_Init+0x56>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009738:	2300      	movs	r3, #0
 800973a:	62a3      	str	r3, [r4, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800973c:	6863      	ldr	r3, [r4, #4]
 800973e:	f403 7382 	and.w	r3, r3, #260	; 0x104
 8009742:	68a1      	ldr	r1, [r4, #8]
 8009744:	f401 4104 	and.w	r1, r1, #33792	; 0x8400
 8009748:	430b      	orrs	r3, r1
 800974a:	6921      	ldr	r1, [r4, #16]
 800974c:	f001 0102 	and.w	r1, r1, #2
 8009750:	430b      	orrs	r3, r1
 8009752:	6961      	ldr	r1, [r4, #20]
 8009754:	f001 0101 	and.w	r1, r1, #1
 8009758:	430b      	orrs	r3, r1
 800975a:	69a1      	ldr	r1, [r4, #24]
 800975c:	f401 7100 	and.w	r1, r1, #512	; 0x200
 8009760:	430b      	orrs	r3, r1
 8009762:	69e1      	ldr	r1, [r4, #28]
 8009764:	f001 0138 	and.w	r1, r1, #56	; 0x38
 8009768:	430b      	orrs	r3, r1
 800976a:	6a21      	ldr	r1, [r4, #32]
 800976c:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8009770:	430b      	orrs	r3, r1
 8009772:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8009774:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
 8009778:	6820      	ldr	r0, [r4, #0]
 800977a:	430b      	orrs	r3, r1
 800977c:	6003      	str	r3, [r0, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800977e:	8b63      	ldrh	r3, [r4, #26]
 8009780:	f003 0304 	and.w	r3, r3, #4
 8009784:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8009786:	f001 0110 	and.w	r1, r1, #16
 800978a:	430b      	orrs	r3, r1
 800978c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800978e:	f001 0108 	and.w	r1, r1, #8
 8009792:	430b      	orrs	r3, r1
 8009794:	68e1      	ldr	r1, [r4, #12]
 8009796:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
 800979a:	430b      	orrs	r3, r1
 800979c:	6821      	ldr	r1, [r4, #0]
 800979e:	431a      	orrs	r2, r3
 80097a0:	604a      	str	r2, [r1, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80097a2:	2000      	movs	r0, #0
 80097a4:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80097a6:	2301      	movs	r3, #1
 80097a8:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  return HAL_OK;
}
 80097ac:	bd10      	pop	{r4, pc}
    hspi->Lock = HAL_UNLOCKED;
 80097ae:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 80097b2:	4620      	mov	r0, r4
 80097b4:	f7f7 feec 	bl	8001590 <HAL_SPI_MspInit>
 80097b8:	e7ab      	b.n	8009712 <HAL_SPI_Init+0x2c>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80097ba:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80097be:	e7b5      	b.n	800972c <HAL_SPI_Init+0x46>
    return HAL_ERROR;
 80097c0:	2001      	movs	r0, #1
}
 80097c2:	4770      	bx	lr

080097c4 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80097c4:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80097c6:	6a03      	ldr	r3, [r0, #32]
 80097c8:	f023 0301 	bic.w	r3, r3, #1
 80097cc:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80097ce:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80097d0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80097d2:	6983      	ldr	r3, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80097d4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80097d8:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80097dc:	680d      	ldr	r5, [r1, #0]
 80097de:	431d      	orrs	r5, r3

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 80097e0:	f022 0202 	bic.w	r2, r2, #2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80097e4:	688b      	ldr	r3, [r1, #8]
 80097e6:	4313      	orrs	r3, r2

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80097e8:	4a14      	ldr	r2, [pc, #80]	; (800983c <TIM_OC1_SetConfig+0x78>)
 80097ea:	4290      	cmp	r0, r2
 80097ec:	d007      	beq.n	80097fe <TIM_OC1_SetConfig+0x3a>
 80097ee:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 80097f2:	4290      	cmp	r0, r2
 80097f4:	d003      	beq.n	80097fe <TIM_OC1_SetConfig+0x3a>
 80097f6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80097fa:	4290      	cmp	r0, r2
 80097fc:	d105      	bne.n	800980a <TIM_OC1_SetConfig+0x46>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80097fe:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8009802:	68ca      	ldr	r2, [r1, #12]
 8009804:	431a      	orrs	r2, r3
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8009806:	f022 0304 	bic.w	r3, r2, #4
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800980a:	4a0c      	ldr	r2, [pc, #48]	; (800983c <TIM_OC1_SetConfig+0x78>)
 800980c:	4290      	cmp	r0, r2
 800980e:	d007      	beq.n	8009820 <TIM_OC1_SetConfig+0x5c>
 8009810:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 8009814:	4290      	cmp	r0, r2
 8009816:	d003      	beq.n	8009820 <TIM_OC1_SetConfig+0x5c>
 8009818:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800981c:	4290      	cmp	r0, r2
 800981e:	d105      	bne.n	800982c <TIM_OC1_SetConfig+0x68>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8009820:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8009824:	694a      	ldr	r2, [r1, #20]
 8009826:	4322      	orrs	r2, r4
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8009828:	698c      	ldr	r4, [r1, #24]
 800982a:	4314      	orrs	r4, r2
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800982c:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800982e:	6185      	str	r5, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8009830:	684a      	ldr	r2, [r1, #4]
 8009832:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009834:	6203      	str	r3, [r0, #32]
}
 8009836:	bc30      	pop	{r4, r5}
 8009838:	4770      	bx	lr
 800983a:	bf00      	nop
 800983c:	40012c00 	.word	0x40012c00

08009840 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8009840:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8009842:	6a03      	ldr	r3, [r0, #32]
 8009844:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8009848:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800984a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800984c:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800984e:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8009850:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009854:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8009858:	680d      	ldr	r5, [r1, #0]
 800985a:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800985c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8009860:	688a      	ldr	r2, [r1, #8]
 8009862:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8009866:	4a12      	ldr	r2, [pc, #72]	; (80098b0 <TIM_OC3_SetConfig+0x70>)
 8009868:	4290      	cmp	r0, r2
 800986a:	d019      	beq.n	80098a0 <TIM_OC3_SetConfig+0x60>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800986c:	4a10      	ldr	r2, [pc, #64]	; (80098b0 <TIM_OC3_SetConfig+0x70>)
 800986e:	4290      	cmp	r0, r2
 8009870:	d007      	beq.n	8009882 <TIM_OC3_SetConfig+0x42>
 8009872:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 8009876:	4290      	cmp	r0, r2
 8009878:	d003      	beq.n	8009882 <TIM_OC3_SetConfig+0x42>
 800987a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800987e:	4290      	cmp	r0, r2
 8009880:	d107      	bne.n	8009892 <TIM_OC3_SetConfig+0x52>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8009882:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8009886:	694a      	ldr	r2, [r1, #20]
 8009888:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800988c:	698a      	ldr	r2, [r1, #24]
 800988e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009892:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8009894:	61c5      	str	r5, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8009896:	684a      	ldr	r2, [r1, #4]
 8009898:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800989a:	6203      	str	r3, [r0, #32]
}
 800989c:	bc30      	pop	{r4, r5}
 800989e:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC3NP;
 80098a0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80098a4:	68ca      	ldr	r2, [r1, #12]
 80098a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 80098aa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80098ae:	e7dd      	b.n	800986c <TIM_OC3_SetConfig+0x2c>
 80098b0:	40012c00 	.word	0x40012c00

080098b4 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80098b4:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80098b6:	6a03      	ldr	r3, [r0, #32]
 80098b8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80098bc:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80098be:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80098c0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80098c2:	69c3      	ldr	r3, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80098c4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80098c8:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80098cc:	680d      	ldr	r5, [r1, #0]
 80098ce:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 80098d2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80098d6:	688d      	ldr	r5, [r1, #8]
 80098d8:	ea42 3205 	orr.w	r2, r2, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80098dc:	4d0b      	ldr	r5, [pc, #44]	; (800990c <TIM_OC4_SetConfig+0x58>)
 80098de:	42a8      	cmp	r0, r5
 80098e0:	d007      	beq.n	80098f2 <TIM_OC4_SetConfig+0x3e>
 80098e2:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 80098e6:	42a8      	cmp	r0, r5
 80098e8:	d003      	beq.n	80098f2 <TIM_OC4_SetConfig+0x3e>
 80098ea:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80098ee:	42a8      	cmp	r0, r5
 80098f0:	d104      	bne.n	80098fc <TIM_OC4_SetConfig+0x48>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 80098f2:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 80098f6:	694d      	ldr	r5, [r1, #20]
 80098f8:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80098fc:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80098fe:	61c3      	str	r3, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8009900:	684b      	ldr	r3, [r1, #4]
 8009902:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009904:	6202      	str	r2, [r0, #32]
}
 8009906:	bc30      	pop	{r4, r5}
 8009908:	4770      	bx	lr
 800990a:	bf00      	nop
 800990c:	40012c00 	.word	0x40012c00

08009910 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8009910:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8009912:	6a03      	ldr	r3, [r0, #32]
 8009914:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8009918:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800991a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800991c:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800991e:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8009920:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009924:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8009928:	680d      	ldr	r5, [r1, #0]
 800992a:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800992c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8009930:	688d      	ldr	r5, [r1, #8]
 8009932:	ea43 4305 	orr.w	r3, r3, r5, lsl #16

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8009936:	4d0b      	ldr	r5, [pc, #44]	; (8009964 <TIM_OC5_SetConfig+0x54>)
 8009938:	42a8      	cmp	r0, r5
 800993a:	d007      	beq.n	800994c <TIM_OC5_SetConfig+0x3c>
 800993c:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8009940:	42a8      	cmp	r0, r5
 8009942:	d003      	beq.n	800994c <TIM_OC5_SetConfig+0x3c>
 8009944:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8009948:	42a8      	cmp	r0, r5
 800994a:	d104      	bne.n	8009956 <TIM_OC5_SetConfig+0x46>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800994c:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8009950:	694d      	ldr	r5, [r1, #20]
 8009952:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009956:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8009958:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800995a:	684a      	ldr	r2, [r1, #4]
 800995c:	6582      	str	r2, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800995e:	6203      	str	r3, [r0, #32]
}
 8009960:	bc30      	pop	{r4, r5}
 8009962:	4770      	bx	lr
 8009964:	40012c00 	.word	0x40012c00

08009968 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8009968:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800996a:	6a03      	ldr	r3, [r0, #32]
 800996c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8009970:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8009972:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8009974:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8009976:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8009978:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800997c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8009980:	680d      	ldr	r5, [r1, #0]
 8009982:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8009986:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800998a:	688d      	ldr	r5, [r1, #8]
 800998c:	ea42 5205 	orr.w	r2, r2, r5, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8009990:	4d0b      	ldr	r5, [pc, #44]	; (80099c0 <TIM_OC6_SetConfig+0x58>)
 8009992:	42a8      	cmp	r0, r5
 8009994:	d007      	beq.n	80099a6 <TIM_OC6_SetConfig+0x3e>
 8009996:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 800999a:	42a8      	cmp	r0, r5
 800999c:	d003      	beq.n	80099a6 <TIM_OC6_SetConfig+0x3e>
 800999e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80099a2:	42a8      	cmp	r0, r5
 80099a4:	d104      	bne.n	80099b0 <TIM_OC6_SetConfig+0x48>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 80099a6:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80099aa:	694d      	ldr	r5, [r1, #20]
 80099ac:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80099b0:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 80099b2:	6543      	str	r3, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 80099b4:	684b      	ldr	r3, [r1, #4]
 80099b6:	65c3      	str	r3, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80099b8:	6202      	str	r2, [r0, #32]
}
 80099ba:	bc30      	pop	{r4, r5}
 80099bc:	4770      	bx	lr
 80099be:	bf00      	nop
 80099c0:	40012c00 	.word	0x40012c00

080099c4 <HAL_TIM_Base_MspInit>:
}
 80099c4:	4770      	bx	lr
	...

080099c8 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 80099c8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80099cc:	b2db      	uxtb	r3, r3
 80099ce:	2b01      	cmp	r3, #1
 80099d0:	d12a      	bne.n	8009a28 <HAL_TIM_Base_Start_IT+0x60>
  htim->State = HAL_TIM_STATE_BUSY;
 80099d2:	2302      	movs	r3, #2
 80099d4:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80099d8:	6802      	ldr	r2, [r0, #0]
 80099da:	68d3      	ldr	r3, [r2, #12]
 80099dc:	f043 0301 	orr.w	r3, r3, #1
 80099e0:	60d3      	str	r3, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80099e2:	6803      	ldr	r3, [r0, #0]
 80099e4:	4a13      	ldr	r2, [pc, #76]	; (8009a34 <HAL_TIM_Base_Start_IT+0x6c>)
 80099e6:	4293      	cmp	r3, r2
 80099e8:	d010      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
 80099ea:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80099ee:	d00d      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
 80099f0:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80099f4:	4293      	cmp	r3, r2
 80099f6:	d009      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
 80099f8:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 80099fc:	4293      	cmp	r3, r2
 80099fe:	d005      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
    __HAL_TIM_ENABLE(htim);
 8009a00:	681a      	ldr	r2, [r3, #0]
 8009a02:	f042 0201 	orr.w	r2, r2, #1
 8009a06:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8009a08:	2000      	movs	r0, #0
 8009a0a:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8009a0c:	6899      	ldr	r1, [r3, #8]
 8009a0e:	4a0a      	ldr	r2, [pc, #40]	; (8009a38 <HAL_TIM_Base_Start_IT+0x70>)
 8009a10:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8009a12:	2a06      	cmp	r2, #6
 8009a14:	d00a      	beq.n	8009a2c <HAL_TIM_Base_Start_IT+0x64>
 8009a16:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8009a1a:	d009      	beq.n	8009a30 <HAL_TIM_Base_Start_IT+0x68>
      __HAL_TIM_ENABLE(htim);
 8009a1c:	681a      	ldr	r2, [r3, #0]
 8009a1e:	f042 0201 	orr.w	r2, r2, #1
 8009a22:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8009a24:	2000      	movs	r0, #0
 8009a26:	4770      	bx	lr
    return HAL_ERROR;
 8009a28:	2001      	movs	r0, #1
 8009a2a:	4770      	bx	lr
  return HAL_OK;
 8009a2c:	2000      	movs	r0, #0
 8009a2e:	4770      	bx	lr
 8009a30:	2000      	movs	r0, #0
}
 8009a32:	4770      	bx	lr
 8009a34:	40012c00 	.word	0x40012c00
 8009a38:	00010007 	.word	0x00010007

08009a3c <HAL_TIM_OC_DelayElapsedCallback>:
}
 8009a3c:	4770      	bx	lr

08009a3e <HAL_TIM_IC_CaptureCallback>:
}
 8009a3e:	4770      	bx	lr

08009a40 <HAL_TIM_PWM_PulseFinishedCallback>:
}
 8009a40:	4770      	bx	lr

08009a42 <HAL_TIM_TriggerCallback>:
}
 8009a42:	4770      	bx	lr

08009a44 <HAL_TIM_IRQHandler>:
{
 8009a44:	b510      	push	{r4, lr}
 8009a46:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8009a48:	6803      	ldr	r3, [r0, #0]
 8009a4a:	691a      	ldr	r2, [r3, #16]
 8009a4c:	f012 0f02 	tst.w	r2, #2
 8009a50:	d011      	beq.n	8009a76 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8009a52:	68da      	ldr	r2, [r3, #12]
 8009a54:	f012 0f02 	tst.w	r2, #2
 8009a58:	d00d      	beq.n	8009a76 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8009a5a:	f06f 0202 	mvn.w	r2, #2
 8009a5e:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009a60:	2301      	movs	r3, #1
 8009a62:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8009a64:	6803      	ldr	r3, [r0, #0]
 8009a66:	699b      	ldr	r3, [r3, #24]
 8009a68:	f013 0f03 	tst.w	r3, #3
 8009a6c:	d079      	beq.n	8009b62 <HAL_TIM_IRQHandler+0x11e>
          HAL_TIM_IC_CaptureCallback(htim);
 8009a6e:	f7ff ffe6 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009a72:	2300      	movs	r3, #0
 8009a74:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8009a76:	6823      	ldr	r3, [r4, #0]
 8009a78:	691a      	ldr	r2, [r3, #16]
 8009a7a:	f012 0f04 	tst.w	r2, #4
 8009a7e:	d012      	beq.n	8009aa6 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8009a80:	68da      	ldr	r2, [r3, #12]
 8009a82:	f012 0f04 	tst.w	r2, #4
 8009a86:	d00e      	beq.n	8009aa6 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8009a88:	f06f 0204 	mvn.w	r2, #4
 8009a8c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8009a8e:	2302      	movs	r3, #2
 8009a90:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8009a92:	6823      	ldr	r3, [r4, #0]
 8009a94:	699b      	ldr	r3, [r3, #24]
 8009a96:	f413 7f40 	tst.w	r3, #768	; 0x300
 8009a9a:	d068      	beq.n	8009b6e <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8009a9c:	4620      	mov	r0, r4
 8009a9e:	f7ff ffce 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009aa2:	2300      	movs	r3, #0
 8009aa4:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8009aa6:	6823      	ldr	r3, [r4, #0]
 8009aa8:	691a      	ldr	r2, [r3, #16]
 8009aaa:	f012 0f08 	tst.w	r2, #8
 8009aae:	d012      	beq.n	8009ad6 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8009ab0:	68da      	ldr	r2, [r3, #12]
 8009ab2:	f012 0f08 	tst.w	r2, #8
 8009ab6:	d00e      	beq.n	8009ad6 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8009ab8:	f06f 0208 	mvn.w	r2, #8
 8009abc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8009abe:	2304      	movs	r3, #4
 8009ac0:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8009ac2:	6823      	ldr	r3, [r4, #0]
 8009ac4:	69db      	ldr	r3, [r3, #28]
 8009ac6:	f013 0f03 	tst.w	r3, #3
 8009aca:	d057      	beq.n	8009b7c <HAL_TIM_IRQHandler+0x138>
        HAL_TIM_IC_CaptureCallback(htim);
 8009acc:	4620      	mov	r0, r4
 8009ace:	f7ff ffb6 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009ad2:	2300      	movs	r3, #0
 8009ad4:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8009ad6:	6823      	ldr	r3, [r4, #0]
 8009ad8:	691a      	ldr	r2, [r3, #16]
 8009ada:	f012 0f10 	tst.w	r2, #16
 8009ade:	d012      	beq.n	8009b06 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8009ae0:	68da      	ldr	r2, [r3, #12]
 8009ae2:	f012 0f10 	tst.w	r2, #16
 8009ae6:	d00e      	beq.n	8009b06 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8009ae8:	f06f 0210 	mvn.w	r2, #16
 8009aec:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8009aee:	2308      	movs	r3, #8
 8009af0:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8009af2:	6823      	ldr	r3, [r4, #0]
 8009af4:	69db      	ldr	r3, [r3, #28]
 8009af6:	f413 7f40 	tst.w	r3, #768	; 0x300
 8009afa:	d046      	beq.n	8009b8a <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8009afc:	4620      	mov	r0, r4
 8009afe:	f7ff ff9e 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009b02:	2300      	movs	r3, #0
 8009b04:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8009b06:	6823      	ldr	r3, [r4, #0]
 8009b08:	691a      	ldr	r2, [r3, #16]
 8009b0a:	f012 0f01 	tst.w	r2, #1
 8009b0e:	d003      	beq.n	8009b18 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8009b10:	68da      	ldr	r2, [r3, #12]
 8009b12:	f012 0f01 	tst.w	r2, #1
 8009b16:	d13f      	bne.n	8009b98 <HAL_TIM_IRQHandler+0x154>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8009b18:	6823      	ldr	r3, [r4, #0]
 8009b1a:	691a      	ldr	r2, [r3, #16]
 8009b1c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b20:	d003      	beq.n	8009b2a <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8009b22:	68da      	ldr	r2, [r3, #12]
 8009b24:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b28:	d13d      	bne.n	8009ba6 <HAL_TIM_IRQHandler+0x162>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8009b2a:	6823      	ldr	r3, [r4, #0]
 8009b2c:	691a      	ldr	r2, [r3, #16]
 8009b2e:	f412 7f80 	tst.w	r2, #256	; 0x100
 8009b32:	d003      	beq.n	8009b3c <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8009b34:	68da      	ldr	r2, [r3, #12]
 8009b36:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b3a:	d13b      	bne.n	8009bb4 <HAL_TIM_IRQHandler+0x170>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8009b3c:	6823      	ldr	r3, [r4, #0]
 8009b3e:	691a      	ldr	r2, [r3, #16]
 8009b40:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009b44:	d003      	beq.n	8009b4e <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8009b46:	68da      	ldr	r2, [r3, #12]
 8009b48:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009b4c:	d139      	bne.n	8009bc2 <HAL_TIM_IRQHandler+0x17e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8009b4e:	6823      	ldr	r3, [r4, #0]
 8009b50:	691a      	ldr	r2, [r3, #16]
 8009b52:	f012 0f20 	tst.w	r2, #32
 8009b56:	d003      	beq.n	8009b60 <HAL_TIM_IRQHandler+0x11c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8009b58:	68da      	ldr	r2, [r3, #12]
 8009b5a:	f012 0f20 	tst.w	r2, #32
 8009b5e:	d137      	bne.n	8009bd0 <HAL_TIM_IRQHandler+0x18c>
}
 8009b60:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b62:	f7ff ff6b 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b66:	4620      	mov	r0, r4
 8009b68:	f7ff ff6a 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b6c:	e781      	b.n	8009a72 <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b6e:	4620      	mov	r0, r4
 8009b70:	f7ff ff64 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b74:	4620      	mov	r0, r4
 8009b76:	f7ff ff63 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b7a:	e792      	b.n	8009aa2 <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b7c:	4620      	mov	r0, r4
 8009b7e:	f7ff ff5d 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b82:	4620      	mov	r0, r4
 8009b84:	f7ff ff5c 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b88:	e7a3      	b.n	8009ad2 <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b8a:	4620      	mov	r0, r4
 8009b8c:	f7ff ff56 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b90:	4620      	mov	r0, r4
 8009b92:	f7ff ff55 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b96:	e7b4      	b.n	8009b02 <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8009b98:	f06f 0201 	mvn.w	r2, #1
 8009b9c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8009b9e:	4620      	mov	r0, r4
 8009ba0:	f7f7 fb3e 	bl	8001220 <HAL_TIM_PeriodElapsedCallback>
 8009ba4:	e7b8      	b.n	8009b18 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8009ba6:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8009baa:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8009bac:	4620      	mov	r0, r4
 8009bae:	f000 f9c4 	bl	8009f3a <HAL_TIMEx_BreakCallback>
 8009bb2:	e7ba      	b.n	8009b2a <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8009bb4:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009bb8:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8009bba:	4620      	mov	r0, r4
 8009bbc:	f000 f9be 	bl	8009f3c <HAL_TIMEx_Break2Callback>
 8009bc0:	e7bc      	b.n	8009b3c <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8009bc2:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009bc6:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8009bc8:	4620      	mov	r0, r4
 8009bca:	f7ff ff3a 	bl	8009a42 <HAL_TIM_TriggerCallback>
 8009bce:	e7be      	b.n	8009b4e <HAL_TIM_IRQHandler+0x10a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8009bd0:	f06f 0220 	mvn.w	r2, #32
 8009bd4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8009bd6:	4620      	mov	r0, r4
 8009bd8:	f000 f9ae 	bl	8009f38 <HAL_TIMEx_CommutCallback>
}
 8009bdc:	e7c0      	b.n	8009b60 <HAL_TIM_IRQHandler+0x11c>
	...

08009be0 <TIM_Base_SetConfig>:
  tmpcr1 = TIMx->CR1;
 8009be0:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8009be2:	4a1e      	ldr	r2, [pc, #120]	; (8009c5c <TIM_Base_SetConfig+0x7c>)
 8009be4:	4290      	cmp	r0, r2
 8009be6:	d006      	beq.n	8009bf6 <TIM_Base_SetConfig+0x16>
 8009be8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8009bec:	d003      	beq.n	8009bf6 <TIM_Base_SetConfig+0x16>
 8009bee:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8009bf2:	4290      	cmp	r0, r2
 8009bf4:	d103      	bne.n	8009bfe <TIM_Base_SetConfig+0x1e>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8009bf6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8009bfa:	684a      	ldr	r2, [r1, #4]
 8009bfc:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8009bfe:	4a17      	ldr	r2, [pc, #92]	; (8009c5c <TIM_Base_SetConfig+0x7c>)
 8009c00:	4290      	cmp	r0, r2
 8009c02:	d00e      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c04:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8009c08:	d00b      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c0a:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8009c0e:	4290      	cmp	r0, r2
 8009c10:	d007      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c12:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 8009c16:	4290      	cmp	r0, r2
 8009c18:	d003      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c1a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8009c1e:	4290      	cmp	r0, r2
 8009c20:	d103      	bne.n	8009c2a <TIM_Base_SetConfig+0x4a>
    tmpcr1 &= ~TIM_CR1_CKD;
 8009c22:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009c26:	68ca      	ldr	r2, [r1, #12]
 8009c28:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009c2a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009c2e:	694a      	ldr	r2, [r1, #20]
 8009c30:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8009c32:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009c34:	688b      	ldr	r3, [r1, #8]
 8009c36:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8009c38:	680b      	ldr	r3, [r1, #0]
 8009c3a:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8009c3c:	4b07      	ldr	r3, [pc, #28]	; (8009c5c <TIM_Base_SetConfig+0x7c>)
 8009c3e:	4298      	cmp	r0, r3
 8009c40:	d007      	beq.n	8009c52 <TIM_Base_SetConfig+0x72>
 8009c42:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
 8009c46:	4298      	cmp	r0, r3
 8009c48:	d003      	beq.n	8009c52 <TIM_Base_SetConfig+0x72>
 8009c4a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009c4e:	4298      	cmp	r0, r3
 8009c50:	d101      	bne.n	8009c56 <TIM_Base_SetConfig+0x76>
    TIMx->RCR = Structure->RepetitionCounter;
 8009c52:	690b      	ldr	r3, [r1, #16]
 8009c54:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8009c56:	2301      	movs	r3, #1
 8009c58:	6143      	str	r3, [r0, #20]
}
 8009c5a:	4770      	bx	lr
 8009c5c:	40012c00 	.word	0x40012c00

08009c60 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8009c60:	b360      	cbz	r0, 8009cbc <HAL_TIM_Base_Init+0x5c>
{
 8009c62:	b510      	push	{r4, lr}
 8009c64:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8009c66:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009c6a:	b313      	cbz	r3, 8009cb2 <HAL_TIM_Base_Init+0x52>
  htim->State = HAL_TIM_STATE_BUSY;
 8009c6c:	2302      	movs	r3, #2
 8009c6e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8009c72:	4621      	mov	r1, r4
 8009c74:	f851 0b04 	ldr.w	r0, [r1], #4
 8009c78:	f7ff ffb2 	bl	8009be0 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8009c7c:	2301      	movs	r3, #1
 8009c7e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009c82:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8009c86:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8009c8a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8009c8e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8009c92:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8009c96:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009c9a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8009c9e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8009ca2:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 8009ca6:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 8009caa:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8009cae:	2000      	movs	r0, #0
}
 8009cb0:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8009cb2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8009cb6:	f7ff fe85 	bl	80099c4 <HAL_TIM_Base_MspInit>
 8009cba:	e7d7      	b.n	8009c6c <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8009cbc:	2001      	movs	r0, #1
}
 8009cbe:	4770      	bx	lr

08009cc0 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8009cc0:	b360      	cbz	r0, 8009d1c <HAL_TIM_PWM_Init+0x5c>
{
 8009cc2:	b510      	push	{r4, lr}
 8009cc4:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8009cc6:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009cca:	b313      	cbz	r3, 8009d12 <HAL_TIM_PWM_Init+0x52>
  htim->State = HAL_TIM_STATE_BUSY;
 8009ccc:	2302      	movs	r3, #2
 8009cce:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8009cd2:	4621      	mov	r1, r4
 8009cd4:	f851 0b04 	ldr.w	r0, [r1], #4
 8009cd8:	f7ff ff82 	bl	8009be0 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8009cdc:	2301      	movs	r3, #1
 8009cde:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009ce2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8009ce6:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8009cea:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8009cee:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8009cf2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8009cf6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009cfa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8009cfe:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8009d02:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 8009d06:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 8009d0a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8009d0e:	2000      	movs	r0, #0
}
 8009d10:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8009d12:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8009d16:	f7f7 fdbb 	bl	8001890 <HAL_TIM_PWM_MspInit>
 8009d1a:	e7d7      	b.n	8009ccc <HAL_TIM_PWM_Init+0xc>
    return HAL_ERROR;
 8009d1c:	2001      	movs	r0, #1
}
 8009d1e:	4770      	bx	lr

08009d20 <TIM_OC2_SetConfig>:
{
 8009d20:	b430      	push	{r4, r5}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8009d22:	6a03      	ldr	r3, [r0, #32]
 8009d24:	f023 0310 	bic.w	r3, r3, #16
 8009d28:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8009d2a:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8009d2c:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8009d2e:	6982      	ldr	r2, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8009d30:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009d34:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8009d38:	680d      	ldr	r5, [r1, #0]
 8009d3a:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer &= ~TIM_CCER_CC2P;
 8009d3e:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8009d42:	688d      	ldr	r5, [r1, #8]
 8009d44:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8009d48:	4d12      	ldr	r5, [pc, #72]	; (8009d94 <TIM_OC2_SetConfig+0x74>)
 8009d4a:	42a8      	cmp	r0, r5
 8009d4c:	d019      	beq.n	8009d82 <TIM_OC2_SetConfig+0x62>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8009d4e:	4d11      	ldr	r5, [pc, #68]	; (8009d94 <TIM_OC2_SetConfig+0x74>)
 8009d50:	42a8      	cmp	r0, r5
 8009d52:	d007      	beq.n	8009d64 <TIM_OC2_SetConfig+0x44>
 8009d54:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8009d58:	42a8      	cmp	r0, r5
 8009d5a:	d003      	beq.n	8009d64 <TIM_OC2_SetConfig+0x44>
 8009d5c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8009d60:	42a8      	cmp	r0, r5
 8009d62:	d107      	bne.n	8009d74 <TIM_OC2_SetConfig+0x54>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8009d64:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8009d68:	694d      	ldr	r5, [r1, #20]
 8009d6a:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8009d6e:	698d      	ldr	r5, [r1, #24]
 8009d70:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
  TIMx->CR2 = tmpcr2;
 8009d74:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8009d76:	6182      	str	r2, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8009d78:	684a      	ldr	r2, [r1, #4]
 8009d7a:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8009d7c:	6203      	str	r3, [r0, #32]
}
 8009d7e:	bc30      	pop	{r4, r5}
 8009d80:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC2NP;
 8009d82:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8009d86:	68cd      	ldr	r5, [r1, #12]
 8009d88:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8009d8c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009d90:	e7dd      	b.n	8009d4e <TIM_OC2_SetConfig+0x2e>
 8009d92:	bf00      	nop
 8009d94:	40012c00 	.word	0x40012c00

08009d98 <HAL_TIM_PWM_ConfigChannel>:
{
 8009d98:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 8009d9a:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009d9e:	2b01      	cmp	r3, #1
 8009da0:	f000 808c 	beq.w	8009ebc <HAL_TIM_PWM_ConfigChannel+0x124>
 8009da4:	4604      	mov	r4, r0
 8009da6:	460d      	mov	r5, r1
 8009da8:	2301      	movs	r3, #1
 8009daa:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 8009dae:	2a14      	cmp	r2, #20
 8009db0:	d81e      	bhi.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
 8009db2:	e8df f002 	tbb	[pc, r2]
 8009db6:	1d0b      	.short	0x1d0b
 8009db8:	1d211d1d 	.word	0x1d211d1d
 8009dbc:	1d351d1d 	.word	0x1d351d1d
 8009dc0:	1d481d1d 	.word	0x1d481d1d
 8009dc4:	1d5c1d1d 	.word	0x1d5c1d1d
 8009dc8:	1d1d      	.short	0x1d1d
 8009dca:	6f          	.byte	0x6f
 8009dcb:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8009dcc:	6800      	ldr	r0, [r0, #0]
 8009dce:	f7ff fcf9 	bl	80097c4 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8009dd2:	6822      	ldr	r2, [r4, #0]
 8009dd4:	6993      	ldr	r3, [r2, #24]
 8009dd6:	f043 0308 	orr.w	r3, r3, #8
 8009dda:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8009ddc:	6822      	ldr	r2, [r4, #0]
 8009dde:	6993      	ldr	r3, [r2, #24]
 8009de0:	f023 0304 	bic.w	r3, r3, #4
 8009de4:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8009de6:	6822      	ldr	r2, [r4, #0]
 8009de8:	6993      	ldr	r3, [r2, #24]
 8009dea:	6929      	ldr	r1, [r5, #16]
 8009dec:	430b      	orrs	r3, r1
 8009dee:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
 8009df0:	2000      	movs	r0, #0
 8009df2:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8009df6:	bd38      	pop	{r3, r4, r5, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8009df8:	6800      	ldr	r0, [r0, #0]
 8009dfa:	f7ff ff91 	bl	8009d20 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8009dfe:	6822      	ldr	r2, [r4, #0]
 8009e00:	6993      	ldr	r3, [r2, #24]
 8009e02:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009e06:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8009e08:	6822      	ldr	r2, [r4, #0]
 8009e0a:	6993      	ldr	r3, [r2, #24]
 8009e0c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009e10:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8009e12:	6822      	ldr	r2, [r4, #0]
 8009e14:	6993      	ldr	r3, [r2, #24]
 8009e16:	6929      	ldr	r1, [r5, #16]
 8009e18:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009e1c:	6193      	str	r3, [r2, #24]
      break;
 8009e1e:	e7e7      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8009e20:	6800      	ldr	r0, [r0, #0]
 8009e22:	f7ff fd0d 	bl	8009840 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8009e26:	6822      	ldr	r2, [r4, #0]
 8009e28:	69d3      	ldr	r3, [r2, #28]
 8009e2a:	f043 0308 	orr.w	r3, r3, #8
 8009e2e:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8009e30:	6822      	ldr	r2, [r4, #0]
 8009e32:	69d3      	ldr	r3, [r2, #28]
 8009e34:	f023 0304 	bic.w	r3, r3, #4
 8009e38:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8009e3a:	6822      	ldr	r2, [r4, #0]
 8009e3c:	69d3      	ldr	r3, [r2, #28]
 8009e3e:	6929      	ldr	r1, [r5, #16]
 8009e40:	430b      	orrs	r3, r1
 8009e42:	61d3      	str	r3, [r2, #28]
      break;
 8009e44:	e7d4      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8009e46:	6800      	ldr	r0, [r0, #0]
 8009e48:	f7ff fd34 	bl	80098b4 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8009e4c:	6822      	ldr	r2, [r4, #0]
 8009e4e:	69d3      	ldr	r3, [r2, #28]
 8009e50:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009e54:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8009e56:	6822      	ldr	r2, [r4, #0]
 8009e58:	69d3      	ldr	r3, [r2, #28]
 8009e5a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009e5e:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8009e60:	6822      	ldr	r2, [r4, #0]
 8009e62:	69d3      	ldr	r3, [r2, #28]
 8009e64:	6929      	ldr	r1, [r5, #16]
 8009e66:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009e6a:	61d3      	str	r3, [r2, #28]
      break;
 8009e6c:	e7c0      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8009e6e:	6800      	ldr	r0, [r0, #0]
 8009e70:	f7ff fd4e 	bl	8009910 <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8009e74:	6822      	ldr	r2, [r4, #0]
 8009e76:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e78:	f043 0308 	orr.w	r3, r3, #8
 8009e7c:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8009e7e:	6822      	ldr	r2, [r4, #0]
 8009e80:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e82:	f023 0304 	bic.w	r3, r3, #4
 8009e86:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8009e88:	6822      	ldr	r2, [r4, #0]
 8009e8a:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e8c:	6929      	ldr	r1, [r5, #16]
 8009e8e:	430b      	orrs	r3, r1
 8009e90:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 8009e92:	e7ad      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8009e94:	6800      	ldr	r0, [r0, #0]
 8009e96:	f7ff fd67 	bl	8009968 <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8009e9a:	6822      	ldr	r2, [r4, #0]
 8009e9c:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e9e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009ea2:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8009ea4:	6822      	ldr	r2, [r4, #0]
 8009ea6:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009ea8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009eac:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8009eae:	6822      	ldr	r2, [r4, #0]
 8009eb0:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009eb2:	6929      	ldr	r1, [r5, #16]
 8009eb4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009eb8:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 8009eba:	e799      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
  __HAL_LOCK(htim);
 8009ebc:	2002      	movs	r0, #2
 8009ebe:	e79a      	b.n	8009df6 <HAL_TIM_PWM_ConfigChannel+0x5e>

08009ec0 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8009ec0:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 8009ec4:	2a01      	cmp	r2, #1
 8009ec6:	d033      	beq.n	8009f30 <HAL_TIMEx_MasterConfigSynchronization+0x70>
{
 8009ec8:	b430      	push	{r4, r5}
 8009eca:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
 8009ecc:	2201      	movs	r2, #1
 8009ece:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8009ed2:	2202      	movs	r2, #2
 8009ed4:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8009ed8:	6800      	ldr	r0, [r0, #0]
 8009eda:	6842      	ldr	r2, [r0, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8009edc:	6884      	ldr	r4, [r0, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8009ede:	4d15      	ldr	r5, [pc, #84]	; (8009f34 <HAL_TIMEx_MasterConfigSynchronization+0x74>)
 8009ee0:	42a8      	cmp	r0, r5
 8009ee2:	d020      	beq.n	8009f26 <HAL_TIMEx_MasterConfigSynchronization+0x66>
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8009ee4:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009ee8:	680d      	ldr	r5, [r1, #0]
 8009eea:	432a      	orrs	r2, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8009eec:	6042      	str	r2, [r0, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8009eee:	681a      	ldr	r2, [r3, #0]
 8009ef0:	4810      	ldr	r0, [pc, #64]	; (8009f34 <HAL_TIMEx_MasterConfigSynchronization+0x74>)
 8009ef2:	4282      	cmp	r2, r0
 8009ef4:	d00a      	beq.n	8009f0c <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8009ef6:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8009efa:	d007      	beq.n	8009f0c <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8009efc:	f5a0 3094 	sub.w	r0, r0, #75776	; 0x12800
 8009f00:	4282      	cmp	r2, r0
 8009f02:	d003      	beq.n	8009f0c <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8009f04:	f500 309e 	add.w	r0, r0, #80896	; 0x13c00
 8009f08:	4282      	cmp	r2, r0
 8009f0a:	d104      	bne.n	8009f16 <HAL_TIMEx_MasterConfigSynchronization+0x56>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 8009f0c:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8009f10:	6889      	ldr	r1, [r1, #8]
 8009f12:	4321      	orrs	r1, r4

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8009f14:	6091      	str	r1, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8009f16:	2201      	movs	r2, #1
 8009f18:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8009f1c:	2000      	movs	r0, #0
 8009f1e:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c

  return HAL_OK;
}
 8009f22:	bc30      	pop	{r4, r5}
 8009f24:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_MMS2;
 8009f26:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8009f2a:	684d      	ldr	r5, [r1, #4]
 8009f2c:	432a      	orrs	r2, r5
 8009f2e:	e7d9      	b.n	8009ee4 <HAL_TIMEx_MasterConfigSynchronization+0x24>
  __HAL_LOCK(htim);
 8009f30:	2002      	movs	r0, #2
}
 8009f32:	4770      	bx	lr
 8009f34:	40012c00 	.word	0x40012c00

08009f38 <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8009f38:	4770      	bx	lr

08009f3a <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8009f3a:	4770      	bx	lr

08009f3c <HAL_TIMEx_Break2Callback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8009f3c:	4770      	bx	lr

08009f3e <UART_EndRxTransfer>:
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
#if defined(USART_CR1_FIFOEN)
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
#else
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8009f3e:	6802      	ldr	r2, [r0, #0]
 8009f40:	6813      	ldr	r3, [r2, #0]
 8009f42:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8009f46:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009f48:	6802      	ldr	r2, [r0, #0]
 8009f4a:	6893      	ldr	r3, [r2, #8]
 8009f4c:	f023 0301 	bic.w	r3, r3, #1
 8009f50:	6093      	str	r3, [r2, #8]
#endif /* USART_CR1_FIFOEN */

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8009f52:	2320      	movs	r3, #32
 8009f54:	6783      	str	r3, [r0, #120]	; 0x78

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8009f56:	2300      	movs	r3, #0
 8009f58:	6603      	str	r3, [r0, #96]	; 0x60
}
 8009f5a:	4770      	bx	lr

08009f5c <UART_TxISR_8BIT>:
  * @retval None
  */
static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
{
  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8009f5c:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8009f5e:	2b21      	cmp	r3, #33	; 0x21
 8009f60:	d000      	beq.n	8009f64 <UART_TxISR_8BIT+0x8>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
      huart->pTxBuffPtr++;
      huart->TxXferCount--;
    }
  }
}
 8009f62:	4770      	bx	lr
    if (huart->TxXferCount == 0U)
 8009f64:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009f68:	b29b      	uxth	r3, r3
 8009f6a:	b953      	cbnz	r3, 8009f82 <UART_TxISR_8BIT+0x26>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8009f6c:	6802      	ldr	r2, [r0, #0]
 8009f6e:	6813      	ldr	r3, [r2, #0]
 8009f70:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009f74:	6013      	str	r3, [r2, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8009f76:	6802      	ldr	r2, [r0, #0]
 8009f78:	6813      	ldr	r3, [r2, #0]
 8009f7a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009f7e:	6013      	str	r3, [r2, #0]
 8009f80:	4770      	bx	lr
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 8009f82:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8009f84:	6803      	ldr	r3, [r0, #0]
 8009f86:	7812      	ldrb	r2, [r2, #0]
 8009f88:	851a      	strh	r2, [r3, #40]	; 0x28
      huart->pTxBuffPtr++;
 8009f8a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8009f8c:	3301      	adds	r3, #1
 8009f8e:	64c3      	str	r3, [r0, #76]	; 0x4c
      huart->TxXferCount--;
 8009f90:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009f94:	b29b      	uxth	r3, r3
 8009f96:	3b01      	subs	r3, #1
 8009f98:	b29b      	uxth	r3, r3
 8009f9a:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
}
 8009f9e:	e7e0      	b.n	8009f62 <UART_TxISR_8BIT+0x6>

08009fa0 <UART_TxISR_16BIT>:
static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8009fa0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8009fa2:	2b21      	cmp	r3, #33	; 0x21
 8009fa4:	d000      	beq.n	8009fa8 <UART_TxISR_16BIT+0x8>
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
      huart->pTxBuffPtr += 2U;
      huart->TxXferCount--;
    }
  }
}
 8009fa6:	4770      	bx	lr
    if (huart->TxXferCount == 0U)
 8009fa8:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009fac:	b29b      	uxth	r3, r3
 8009fae:	b953      	cbnz	r3, 8009fc6 <UART_TxISR_16BIT+0x26>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8009fb0:	6802      	ldr	r2, [r0, #0]
 8009fb2:	6813      	ldr	r3, [r2, #0]
 8009fb4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009fb8:	6013      	str	r3, [r2, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8009fba:	6802      	ldr	r2, [r0, #0]
 8009fbc:	6813      	ldr	r3, [r2, #0]
 8009fbe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009fc2:	6013      	str	r3, [r2, #0]
 8009fc4:	4770      	bx	lr
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8009fc6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 8009fc8:	881b      	ldrh	r3, [r3, #0]
 8009fca:	6802      	ldr	r2, [r0, #0]
 8009fcc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009fd0:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->pTxBuffPtr += 2U;
 8009fd2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8009fd4:	3302      	adds	r3, #2
 8009fd6:	64c3      	str	r3, [r0, #76]	; 0x4c
      huart->TxXferCount--;
 8009fd8:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009fdc:	b29b      	uxth	r3, r3
 8009fde:	3b01      	subs	r3, #1
 8009fe0:	b29b      	uxth	r3, r3
 8009fe2:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
}
 8009fe6:	e7de      	b.n	8009fa6 <UART_TxISR_16BIT+0x6>

08009fe8 <HAL_UART_DeInit>:
  if (huart == NULL)
 8009fe8:	b1c0      	cbz	r0, 800a01c <HAL_UART_DeInit+0x34>
{
 8009fea:	b538      	push	{r3, r4, r5, lr}
 8009fec:	4605      	mov	r5, r0
  huart->gState = HAL_UART_STATE_BUSY;
 8009fee:	2324      	movs	r3, #36	; 0x24
 8009ff0:	6743      	str	r3, [r0, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 8009ff2:	6802      	ldr	r2, [r0, #0]
 8009ff4:	6813      	ldr	r3, [r2, #0]
 8009ff6:	f023 0301 	bic.w	r3, r3, #1
 8009ffa:	6013      	str	r3, [r2, #0]
  huart->Instance->CR1 = 0x0U;
 8009ffc:	6803      	ldr	r3, [r0, #0]
 8009ffe:	2400      	movs	r4, #0
 800a000:	601c      	str	r4, [r3, #0]
  huart->Instance->CR2 = 0x0U;
 800a002:	6803      	ldr	r3, [r0, #0]
 800a004:	605c      	str	r4, [r3, #4]
  huart->Instance->CR3 = 0x0U;
 800a006:	6803      	ldr	r3, [r0, #0]
 800a008:	609c      	str	r4, [r3, #8]
  HAL_UART_MspDeInit(huart);
 800a00a:	f7f7 fde9 	bl	8001be0 <HAL_UART_MspDeInit>
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a00e:	67ec      	str	r4, [r5, #124]	; 0x7c
  huart->gState = HAL_UART_STATE_RESET;
 800a010:	676c      	str	r4, [r5, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_RESET;
 800a012:	67ac      	str	r4, [r5, #120]	; 0x78
  __HAL_UNLOCK(huart);
 800a014:	f885 4070 	strb.w	r4, [r5, #112]	; 0x70
  return HAL_OK;
 800a018:	4620      	mov	r0, r4
}
 800a01a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800a01c:	2001      	movs	r0, #1
}
 800a01e:	4770      	bx	lr

0800a020 <HAL_UART_Transmit_IT>:
  if (huart->gState == HAL_UART_STATE_READY)
 800a020:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a022:	2b20      	cmp	r3, #32
 800a024:	d128      	bne.n	800a078 <HAL_UART_Transmit_IT+0x58>
    if ((pData == NULL) || (Size == 0U))
 800a026:	b349      	cbz	r1, 800a07c <HAL_UART_Transmit_IT+0x5c>
 800a028:	b352      	cbz	r2, 800a080 <HAL_UART_Transmit_IT+0x60>
    __HAL_LOCK(huart);
 800a02a:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 800a02e:	2b01      	cmp	r3, #1
 800a030:	d028      	beq.n	800a084 <HAL_UART_Transmit_IT+0x64>
 800a032:	2301      	movs	r3, #1
 800a034:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->pTxBuffPtr  = pData;
 800a038:	64c1      	str	r1, [r0, #76]	; 0x4c
    huart->TxXferSize  = Size;
 800a03a:	f8a0 2050 	strh.w	r2, [r0, #80]	; 0x50
    huart->TxXferCount = Size;
 800a03e:	f8a0 2052 	strh.w	r2, [r0, #82]	; 0x52
    huart->TxISR       = NULL;
 800a042:	2300      	movs	r3, #0
 800a044:	6643      	str	r3, [r0, #100]	; 0x64
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a046:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800a048:	2321      	movs	r3, #33	; 0x21
 800a04a:	6743      	str	r3, [r0, #116]	; 0x74
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a04c:	6883      	ldr	r3, [r0, #8]
 800a04e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a052:	d00b      	beq.n	800a06c <HAL_UART_Transmit_IT+0x4c>
      huart->TxISR = UART_TxISR_8BIT;
 800a054:	4b0c      	ldr	r3, [pc, #48]	; (800a088 <HAL_UART_Transmit_IT+0x68>)
 800a056:	6643      	str	r3, [r0, #100]	; 0x64
    __HAL_UNLOCK(huart);
 800a058:	2300      	movs	r3, #0
 800a05a:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800a05e:	6801      	ldr	r1, [r0, #0]
 800a060:	680a      	ldr	r2, [r1, #0]
 800a062:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a066:	600a      	str	r2, [r1, #0]
    return HAL_OK;
 800a068:	4618      	mov	r0, r3
 800a06a:	4770      	bx	lr
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a06c:	6903      	ldr	r3, [r0, #16]
 800a06e:	2b00      	cmp	r3, #0
 800a070:	d1f0      	bne.n	800a054 <HAL_UART_Transmit_IT+0x34>
      huart->TxISR = UART_TxISR_16BIT;
 800a072:	4b06      	ldr	r3, [pc, #24]	; (800a08c <HAL_UART_Transmit_IT+0x6c>)
 800a074:	6643      	str	r3, [r0, #100]	; 0x64
 800a076:	e7ef      	b.n	800a058 <HAL_UART_Transmit_IT+0x38>
    return HAL_BUSY;
 800a078:	2002      	movs	r0, #2
 800a07a:	4770      	bx	lr
      return HAL_ERROR;
 800a07c:	2001      	movs	r0, #1
 800a07e:	4770      	bx	lr
 800a080:	2001      	movs	r0, #1
 800a082:	4770      	bx	lr
    __HAL_LOCK(huart);
 800a084:	2002      	movs	r0, #2
}
 800a086:	4770      	bx	lr
 800a088:	08009f5d 	.word	0x08009f5d
 800a08c:	08009fa1 	.word	0x08009fa1

0800a090 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 800a090:	6f83      	ldr	r3, [r0, #120]	; 0x78
 800a092:	2b20      	cmp	r3, #32
 800a094:	d15a      	bne.n	800a14c <HAL_UART_Receive_IT+0xbc>
    if ((pData == NULL) || (Size == 0U))
 800a096:	2900      	cmp	r1, #0
 800a098:	d05a      	beq.n	800a150 <HAL_UART_Receive_IT+0xc0>
 800a09a:	2a00      	cmp	r2, #0
 800a09c:	d05a      	beq.n	800a154 <HAL_UART_Receive_IT+0xc4>
    __HAL_LOCK(huart);
 800a09e:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 800a0a2:	2b01      	cmp	r3, #1
 800a0a4:	d058      	beq.n	800a158 <HAL_UART_Receive_IT+0xc8>
 800a0a6:	2301      	movs	r3, #1
 800a0a8:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->pRxBuffPtr  = pData;
 800a0ac:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxXferSize  = Size;
 800a0ae:	f8a0 2058 	strh.w	r2, [r0, #88]	; 0x58
    huart->RxXferCount = Size;
 800a0b2:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    huart->RxISR       = NULL;
 800a0b6:	2300      	movs	r3, #0
 800a0b8:	6603      	str	r3, [r0, #96]	; 0x60
    UART_MASK_COMPUTATION(huart);
 800a0ba:	6883      	ldr	r3, [r0, #8]
 800a0bc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a0c0:	d006      	beq.n	800a0d0 <HAL_UART_Receive_IT+0x40>
 800a0c2:	b9a3      	cbnz	r3, 800a0ee <HAL_UART_Receive_IT+0x5e>
 800a0c4:	6903      	ldr	r3, [r0, #16]
 800a0c6:	b973      	cbnz	r3, 800a0e6 <HAL_UART_Receive_IT+0x56>
 800a0c8:	23ff      	movs	r3, #255	; 0xff
 800a0ca:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0ce:	e014      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0d0:	6903      	ldr	r3, [r0, #16]
 800a0d2:	b923      	cbnz	r3, 800a0de <HAL_UART_Receive_IT+0x4e>
 800a0d4:	f240 13ff 	movw	r3, #511	; 0x1ff
 800a0d8:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0dc:	e00d      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0de:	23ff      	movs	r3, #255	; 0xff
 800a0e0:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0e4:	e009      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0e6:	237f      	movs	r3, #127	; 0x7f
 800a0e8:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0ec:	e005      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0ee:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800a0f2:	d01b      	beq.n	800a12c <HAL_UART_Receive_IT+0x9c>
 800a0f4:	2300      	movs	r3, #0
 800a0f6:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a0fa:	2300      	movs	r3, #0
 800a0fc:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800a0fe:	2322      	movs	r3, #34	; 0x22
 800a100:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a102:	6802      	ldr	r2, [r0, #0]
 800a104:	6893      	ldr	r3, [r2, #8]
 800a106:	f043 0301 	orr.w	r3, r3, #1
 800a10a:	6093      	str	r3, [r2, #8]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a10c:	6883      	ldr	r3, [r0, #8]
 800a10e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a112:	d015      	beq.n	800a140 <HAL_UART_Receive_IT+0xb0>
      huart->RxISR = UART_RxISR_8BIT;
 800a114:	4b11      	ldr	r3, [pc, #68]	; (800a15c <HAL_UART_Receive_IT+0xcc>)
 800a116:	6603      	str	r3, [r0, #96]	; 0x60
    __HAL_UNLOCK(huart);
 800a118:	2300      	movs	r3, #0
 800a11a:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 800a11e:	6801      	ldr	r1, [r0, #0]
 800a120:	680a      	ldr	r2, [r1, #0]
 800a122:	f442 7290 	orr.w	r2, r2, #288	; 0x120
 800a126:	600a      	str	r2, [r1, #0]
    return HAL_OK;
 800a128:	4618      	mov	r0, r3
 800a12a:	4770      	bx	lr
    UART_MASK_COMPUTATION(huart);
 800a12c:	6903      	ldr	r3, [r0, #16]
 800a12e:	b91b      	cbnz	r3, 800a138 <HAL_UART_Receive_IT+0xa8>
 800a130:	237f      	movs	r3, #127	; 0x7f
 800a132:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a136:	e7e0      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a138:	233f      	movs	r3, #63	; 0x3f
 800a13a:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a13e:	e7dc      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a140:	6903      	ldr	r3, [r0, #16]
 800a142:	2b00      	cmp	r3, #0
 800a144:	d1e6      	bne.n	800a114 <HAL_UART_Receive_IT+0x84>
      huart->RxISR = UART_RxISR_16BIT;
 800a146:	4b06      	ldr	r3, [pc, #24]	; (800a160 <HAL_UART_Receive_IT+0xd0>)
 800a148:	6603      	str	r3, [r0, #96]	; 0x60
 800a14a:	e7e5      	b.n	800a118 <HAL_UART_Receive_IT+0x88>
    return HAL_BUSY;
 800a14c:	2002      	movs	r0, #2
 800a14e:	4770      	bx	lr
      return HAL_ERROR;
 800a150:	2001      	movs	r0, #1
 800a152:	4770      	bx	lr
 800a154:	2001      	movs	r0, #1
 800a156:	4770      	bx	lr
    __HAL_LOCK(huart);
 800a158:	2002      	movs	r0, #2
}
 800a15a:	4770      	bx	lr
 800a15c:	0800a17f 	.word	0x0800a17f
 800a160:	0800a1e5 	.word	0x0800a1e5

0800a164 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 800a164:	b508      	push	{r3, lr}
  /* Disable the UART Transmit Complete Interrupt */
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800a166:	6801      	ldr	r1, [r0, #0]
 800a168:	680a      	ldr	r2, [r1, #0]
 800a16a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a16e:	600a      	str	r2, [r1, #0]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800a170:	2220      	movs	r2, #32
 800a172:	6742      	str	r2, [r0, #116]	; 0x74

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800a174:	2200      	movs	r2, #0
 800a176:	6642      	str	r2, [r0, #100]	; 0x64
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800a178:	f014 f87a 	bl	801e270 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800a17c:	bd08      	pop	{r3, pc}

0800a17e <UART_RxISR_8BIT>:
  * @brief RX interrrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 800a17e:	b508      	push	{r3, lr}
  uint16_t uhMask = huart->Mask;
 800a180:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800a184:	6f82      	ldr	r2, [r0, #120]	; 0x78
 800a186:	2a22      	cmp	r2, #34	; 0x22
 800a188:	d006      	beq.n	800a198 <UART_RxISR_8BIT+0x1a>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800a18a:	6802      	ldr	r2, [r0, #0]
 800a18c:	8b13      	ldrh	r3, [r2, #24]
 800a18e:	b29b      	uxth	r3, r3
 800a190:	f043 0308 	orr.w	r3, r3, #8
 800a194:	8313      	strh	r3, [r2, #24]
  }
}
 800a196:	bd08      	pop	{r3, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800a198:	6802      	ldr	r2, [r0, #0]
 800a19a:	8c91      	ldrh	r1, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 800a19c:	b2db      	uxtb	r3, r3
 800a19e:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800a1a0:	400b      	ands	r3, r1
 800a1a2:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
 800a1a4:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800a1a6:	3301      	adds	r3, #1
 800a1a8:	6543      	str	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800a1aa:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a1ae:	b29b      	uxth	r3, r3
 800a1b0:	3b01      	subs	r3, #1
 800a1b2:	b29b      	uxth	r3, r3
 800a1b4:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 800a1b8:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a1bc:	b29b      	uxth	r3, r3
 800a1be:	2b00      	cmp	r3, #0
 800a1c0:	d1e9      	bne.n	800a196 <UART_RxISR_8BIT+0x18>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a1c2:	6802      	ldr	r2, [r0, #0]
 800a1c4:	6813      	ldr	r3, [r2, #0]
 800a1c6:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800a1ca:	6013      	str	r3, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a1cc:	6802      	ldr	r2, [r0, #0]
 800a1ce:	6893      	ldr	r3, [r2, #8]
 800a1d0:	f023 0301 	bic.w	r3, r3, #1
 800a1d4:	6093      	str	r3, [r2, #8]
      huart->RxState = HAL_UART_STATE_READY;
 800a1d6:	2320      	movs	r3, #32
 800a1d8:	6783      	str	r3, [r0, #120]	; 0x78
      huart->RxISR = NULL;
 800a1da:	2300      	movs	r3, #0
 800a1dc:	6603      	str	r3, [r0, #96]	; 0x60
      HAL_UART_RxCpltCallback(huart);
 800a1de:	f014 f833 	bl	801e248 <HAL_UART_RxCpltCallback>
 800a1e2:	e7d8      	b.n	800a196 <UART_RxISR_8BIT+0x18>

0800a1e4 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 800a1e4:	b508      	push	{r3, lr}
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 800a1e6:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800a1ea:	6f82      	ldr	r2, [r0, #120]	; 0x78
 800a1ec:	2a22      	cmp	r2, #34	; 0x22
 800a1ee:	d006      	beq.n	800a1fe <UART_RxISR_16BIT+0x1a>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800a1f0:	6802      	ldr	r2, [r0, #0]
 800a1f2:	8b13      	ldrh	r3, [r2, #24]
 800a1f4:	b29b      	uxth	r3, r3
 800a1f6:	f043 0308 	orr.w	r3, r3, #8
 800a1fa:	8313      	strh	r3, [r2, #24]
  }
}
 800a1fc:	bd08      	pop	{r3, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800a1fe:	6802      	ldr	r2, [r0, #0]
 800a200:	8c91      	ldrh	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 800a202:	6d42      	ldr	r2, [r0, #84]	; 0x54
    *tmp = (uint16_t)(uhdata & uhMask);
 800a204:	400b      	ands	r3, r1
 800a206:	8013      	strh	r3, [r2, #0]
    huart->pRxBuffPtr += 2U;
 800a208:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800a20a:	3302      	adds	r3, #2
 800a20c:	6543      	str	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800a20e:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a212:	b29b      	uxth	r3, r3
 800a214:	3b01      	subs	r3, #1
 800a216:	b29b      	uxth	r3, r3
 800a218:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 800a21c:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a220:	b29b      	uxth	r3, r3
 800a222:	2b00      	cmp	r3, #0
 800a224:	d1ea      	bne.n	800a1fc <UART_RxISR_16BIT+0x18>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a226:	6802      	ldr	r2, [r0, #0]
 800a228:	6813      	ldr	r3, [r2, #0]
 800a22a:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800a22e:	6013      	str	r3, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a230:	6802      	ldr	r2, [r0, #0]
 800a232:	6893      	ldr	r3, [r2, #8]
 800a234:	f023 0301 	bic.w	r3, r3, #1
 800a238:	6093      	str	r3, [r2, #8]
      huart->RxState = HAL_UART_STATE_READY;
 800a23a:	2320      	movs	r3, #32
 800a23c:	6783      	str	r3, [r0, #120]	; 0x78
      huart->RxISR = NULL;
 800a23e:	2300      	movs	r3, #0
 800a240:	6603      	str	r3, [r0, #96]	; 0x60
      HAL_UART_RxCpltCallback(huart);
 800a242:	f014 f801 	bl	801e248 <HAL_UART_RxCpltCallback>
 800a246:	e7d9      	b.n	800a1fc <UART_RxISR_16BIT+0x18>

0800a248 <HAL_UART_IRQHandler>:
{
 800a248:	b570      	push	{r4, r5, r6, lr}
 800a24a:	4604      	mov	r4, r0
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800a24c:	6801      	ldr	r1, [r0, #0]
 800a24e:	69cb      	ldr	r3, [r1, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800a250:	6808      	ldr	r0, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800a252:	688d      	ldr	r5, [r1, #8]
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 800a254:	f640 020f 	movw	r2, #2063	; 0x80f
  if (errorflags == 0U)
 800a258:	401a      	ands	r2, r3
 800a25a:	d105      	bne.n	800a268 <HAL_UART_IRQHandler+0x20>
    if (((isrflags & USART_ISR_RXNE) != 0U)
 800a25c:	f013 0f20 	tst.w	r3, #32
 800a260:	d002      	beq.n	800a268 <HAL_UART_IRQHandler+0x20>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800a262:	f010 0f20 	tst.w	r0, #32
 800a266:	d11c      	bne.n	800a2a2 <HAL_UART_IRQHandler+0x5a>
  if ((errorflags != 0U)
 800a268:	b12a      	cbz	r2, 800a276 <HAL_UART_IRQHandler+0x2e>
      && (((cr3its & USART_CR3_EIE) != 0U)
 800a26a:	f015 0201 	ands.w	r2, r5, #1
 800a26e:	d11e      	bne.n	800a2ae <HAL_UART_IRQHandler+0x66>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 800a270:	4e54      	ldr	r6, [pc, #336]	; (800a3c4 <HAL_UART_IRQHandler+0x17c>)
 800a272:	4230      	tst	r0, r6
 800a274:	d11b      	bne.n	800a2ae <HAL_UART_IRQHandler+0x66>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 800a276:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800a27a:	d003      	beq.n	800a284 <HAL_UART_IRQHandler+0x3c>
 800a27c:	f415 0f80 	tst.w	r5, #4194304	; 0x400000
 800a280:	f040 808e 	bne.w	800a3a0 <HAL_UART_IRQHandler+0x158>
  if (((isrflags & USART_ISR_TXE) != 0U)
 800a284:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a288:	d003      	beq.n	800a292 <HAL_UART_IRQHandler+0x4a>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 800a28a:	f010 0f80 	tst.w	r0, #128	; 0x80
 800a28e:	f040 808e 	bne.w	800a3ae <HAL_UART_IRQHandler+0x166>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800a292:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a296:	d003      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
 800a298:	f010 0f40 	tst.w	r0, #64	; 0x40
 800a29c:	f040 808e 	bne.w	800a3bc <HAL_UART_IRQHandler+0x174>
}
 800a2a0:	bd70      	pop	{r4, r5, r6, pc}
      if (huart->RxISR != NULL)
 800a2a2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a2a4:	2b00      	cmp	r3, #0
 800a2a6:	d0fb      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
        huart->RxISR(huart);
 800a2a8:	4620      	mov	r0, r4
 800a2aa:	4798      	blx	r3
      return;
 800a2ac:	e7f8      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800a2ae:	f013 0f01 	tst.w	r3, #1
 800a2b2:	d007      	beq.n	800a2c4 <HAL_UART_IRQHandler+0x7c>
 800a2b4:	f410 7f80 	tst.w	r0, #256	; 0x100
 800a2b8:	d004      	beq.n	800a2c4 <HAL_UART_IRQHandler+0x7c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800a2ba:	2501      	movs	r5, #1
 800a2bc:	620d      	str	r5, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800a2be:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800a2c0:	4329      	orrs	r1, r5
 800a2c2:	67e1      	str	r1, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800a2c4:	f013 0f02 	tst.w	r3, #2
 800a2c8:	d007      	beq.n	800a2da <HAL_UART_IRQHandler+0x92>
 800a2ca:	b132      	cbz	r2, 800a2da <HAL_UART_IRQHandler+0x92>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800a2cc:	6821      	ldr	r1, [r4, #0]
 800a2ce:	2502      	movs	r5, #2
 800a2d0:	620d      	str	r5, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800a2d2:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800a2d4:	f041 0104 	orr.w	r1, r1, #4
 800a2d8:	67e1      	str	r1, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800a2da:	f013 0f04 	tst.w	r3, #4
 800a2de:	d007      	beq.n	800a2f0 <HAL_UART_IRQHandler+0xa8>
 800a2e0:	b132      	cbz	r2, 800a2f0 <HAL_UART_IRQHandler+0xa8>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800a2e2:	6821      	ldr	r1, [r4, #0]
 800a2e4:	2504      	movs	r5, #4
 800a2e6:	620d      	str	r5, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 800a2e8:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800a2ea:	f041 0102 	orr.w	r1, r1, #2
 800a2ee:	67e1      	str	r1, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_ORE) != 0U)
 800a2f0:	f013 0f08 	tst.w	r3, #8
 800a2f4:	d009      	beq.n	800a30a <HAL_UART_IRQHandler+0xc2>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800a2f6:	f010 0f20 	tst.w	r0, #32
 800a2fa:	d100      	bne.n	800a2fe <HAL_UART_IRQHandler+0xb6>
 800a2fc:	b12a      	cbz	r2, 800a30a <HAL_UART_IRQHandler+0xc2>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800a2fe:	6822      	ldr	r2, [r4, #0]
 800a300:	2108      	movs	r1, #8
 800a302:	6211      	str	r1, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800a304:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a306:	430a      	orrs	r2, r1
 800a308:	67e2      	str	r2, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 800a30a:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800a30e:	d00a      	beq.n	800a326 <HAL_UART_IRQHandler+0xde>
 800a310:	f010 6f80 	tst.w	r0, #67108864	; 0x4000000
 800a314:	d007      	beq.n	800a326 <HAL_UART_IRQHandler+0xde>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800a316:	6822      	ldr	r2, [r4, #0]
 800a318:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800a31c:	6211      	str	r1, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 800a31e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a320:	f042 0220 	orr.w	r2, r2, #32
 800a324:	67e2      	str	r2, [r4, #124]	; 0x7c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800a326:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a328:	2a00      	cmp	r2, #0
 800a32a:	d0b9      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800a32c:	f013 0f20 	tst.w	r3, #32
 800a330:	d006      	beq.n	800a340 <HAL_UART_IRQHandler+0xf8>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800a332:	f010 0f20 	tst.w	r0, #32
 800a336:	d003      	beq.n	800a340 <HAL_UART_IRQHandler+0xf8>
        if (huart->RxISR != NULL)
 800a338:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a33a:	b10b      	cbz	r3, 800a340 <HAL_UART_IRQHandler+0xf8>
          huart->RxISR(huart);
 800a33c:	4620      	mov	r0, r4
 800a33e:	4798      	blx	r3
      errorcode = huart->ErrorCode;
 800a340:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800a342:	6823      	ldr	r3, [r4, #0]
 800a344:	689b      	ldr	r3, [r3, #8]
 800a346:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a34a:	d102      	bne.n	800a352 <HAL_UART_IRQHandler+0x10a>
 800a34c:	f012 0f28 	tst.w	r2, #40	; 0x28
 800a350:	d020      	beq.n	800a394 <HAL_UART_IRQHandler+0x14c>
        UART_EndRxTransfer(huart);
 800a352:	4620      	mov	r0, r4
 800a354:	f7ff fdf3 	bl	8009f3e <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a358:	6823      	ldr	r3, [r4, #0]
 800a35a:	689a      	ldr	r2, [r3, #8]
 800a35c:	f012 0f40 	tst.w	r2, #64	; 0x40
 800a360:	d014      	beq.n	800a38c <HAL_UART_IRQHandler+0x144>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a362:	689a      	ldr	r2, [r3, #8]
 800a364:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a368:	609a      	str	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 800a36a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800a36c:	b153      	cbz	r3, 800a384 <HAL_UART_IRQHandler+0x13c>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800a36e:	4a16      	ldr	r2, [pc, #88]	; (800a3c8 <HAL_UART_IRQHandler+0x180>)
 800a370:	639a      	str	r2, [r3, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800a372:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800a374:	f7fd fa10 	bl	8007798 <HAL_DMA_Abort_IT>
 800a378:	2800      	cmp	r0, #0
 800a37a:	d091      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800a37c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800a37e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a380:	4798      	blx	r3
 800a382:	e78d      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
            HAL_UART_ErrorCallback(huart);
 800a384:	4620      	mov	r0, r4
 800a386:	f013 ff7f 	bl	801e288 <HAL_UART_ErrorCallback>
 800a38a:	e789      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
          HAL_UART_ErrorCallback(huart);
 800a38c:	4620      	mov	r0, r4
 800a38e:	f013 ff7b 	bl	801e288 <HAL_UART_ErrorCallback>
 800a392:	e785      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
        HAL_UART_ErrorCallback(huart);
 800a394:	4620      	mov	r0, r4
 800a396:	f013 ff77 	bl	801e288 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a39a:	2300      	movs	r3, #0
 800a39c:	67e3      	str	r3, [r4, #124]	; 0x7c
    return;
 800a39e:	e77f      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 800a3a0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800a3a4:	620b      	str	r3, [r1, #32]
    HAL_UARTEx_WakeupCallback(huart);
 800a3a6:	4620      	mov	r0, r4
 800a3a8:	f000 fb50 	bl	800aa4c <HAL_UARTEx_WakeupCallback>
    return;
 800a3ac:	e778      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    if (huart->TxISR != NULL)
 800a3ae:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a3b0:	2b00      	cmp	r3, #0
 800a3b2:	f43f af75 	beq.w	800a2a0 <HAL_UART_IRQHandler+0x58>
      huart->TxISR(huart);
 800a3b6:	4620      	mov	r0, r4
 800a3b8:	4798      	blx	r3
    return;
 800a3ba:	e771      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    UART_EndTransmit_IT(huart);
 800a3bc:	4620      	mov	r0, r4
 800a3be:	f7ff fed1 	bl	800a164 <UART_EndTransmit_IT>
    return;
 800a3c2:	e76d      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
 800a3c4:	04000120 	.word	0x04000120
 800a3c8:	0800a3cd 	.word	0x0800a3cd

0800a3cc <UART_DMAAbortOnError>:
{
 800a3cc:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a3ce:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 800a3d0:	2300      	movs	r3, #0
 800a3d2:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
  huart->TxXferCount = 0U;
 800a3d6:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
 800a3da:	f013 ff55 	bl	801e288 <HAL_UART_ErrorCallback>
}
 800a3de:	bd08      	pop	{r3, pc}

0800a3e0 <HAL_UART_AbortTransmitCpltCallback>:
}
 800a3e0:	4770      	bx	lr
	...

0800a3e4 <HAL_UART_AbortTransmit_IT>:
{
 800a3e4:	b510      	push	{r4, lr}
 800a3e6:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800a3e8:	6802      	ldr	r2, [r0, #0]
 800a3ea:	6813      	ldr	r3, [r2, #0]
 800a3ec:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800a3f0:	6013      	str	r3, [r2, #0]
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800a3f2:	6803      	ldr	r3, [r0, #0]
 800a3f4:	689a      	ldr	r2, [r3, #8]
 800a3f6:	f012 0f80 	tst.w	r2, #128	; 0x80
 800a3fa:	d018      	beq.n	800a42e <HAL_UART_AbortTransmit_IT+0x4a>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800a3fc:	689a      	ldr	r2, [r3, #8]
 800a3fe:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a402:	609a      	str	r2, [r3, #8]
    if (huart->hdmatx != NULL)
 800a404:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800a406:	b14b      	cbz	r3, 800a41c <HAL_UART_AbortTransmit_IT+0x38>
      huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
 800a408:	4a0e      	ldr	r2, [pc, #56]	; (800a444 <HAL_UART_AbortTransmit_IT+0x60>)
 800a40a:	639a      	str	r2, [r3, #56]	; 0x38
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
 800a40c:	6e80      	ldr	r0, [r0, #104]	; 0x68
 800a40e:	f7fd f9c3 	bl	8007798 <HAL_DMA_Abort_IT>
 800a412:	b1a0      	cbz	r0, 800a43e <HAL_UART_AbortTransmit_IT+0x5a>
        huart->hdmatx->XferAbortCallback(huart->hdmatx);
 800a414:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800a416:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a418:	4798      	blx	r3
 800a41a:	e010      	b.n	800a43e <HAL_UART_AbortTransmit_IT+0x5a>
      huart->TxXferCount = 0U;
 800a41c:	2300      	movs	r3, #0
 800a41e:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
      huart->TxISR = NULL;
 800a422:	6643      	str	r3, [r0, #100]	; 0x64
      huart->gState = HAL_UART_STATE_READY;
 800a424:	2320      	movs	r3, #32
 800a426:	6743      	str	r3, [r0, #116]	; 0x74
      HAL_UART_AbortTransmitCpltCallback(huart);
 800a428:	f7ff ffda 	bl	800a3e0 <HAL_UART_AbortTransmitCpltCallback>
 800a42c:	e007      	b.n	800a43e <HAL_UART_AbortTransmit_IT+0x5a>
    huart->TxXferCount = 0U;
 800a42e:	2300      	movs	r3, #0
 800a430:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
    huart->TxISR = NULL;
 800a434:	6643      	str	r3, [r0, #100]	; 0x64
    huart->gState = HAL_UART_STATE_READY;
 800a436:	2320      	movs	r3, #32
 800a438:	6743      	str	r3, [r0, #116]	; 0x74
    HAL_UART_AbortTransmitCpltCallback(huart);
 800a43a:	f7ff ffd1 	bl	800a3e0 <HAL_UART_AbortTransmitCpltCallback>
}
 800a43e:	2000      	movs	r0, #0
 800a440:	bd10      	pop	{r4, pc}
 800a442:	bf00      	nop
 800a444:	0800a449 	.word	0x0800a449

0800a448 <UART_DMATxOnlyAbortCallback>:
{
 800a448:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a44a:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->TxXferCount = 0U;
 800a44c:	2300      	movs	r3, #0
 800a44e:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
  huart->gState = HAL_UART_STATE_READY;
 800a452:	2320      	movs	r3, #32
 800a454:	6743      	str	r3, [r0, #116]	; 0x74
  HAL_UART_AbortTransmitCpltCallback(huart);
 800a456:	f7ff ffc3 	bl	800a3e0 <HAL_UART_AbortTransmitCpltCallback>
}
 800a45a:	bd08      	pop	{r3, pc}

0800a45c <UART_SetConfig>:
{
 800a45c:	b510      	push	{r4, lr}
 800a45e:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 800a460:	6801      	ldr	r1, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a462:	6883      	ldr	r3, [r0, #8]
 800a464:	6902      	ldr	r2, [r0, #16]
 800a466:	4313      	orrs	r3, r2
 800a468:	6942      	ldr	r2, [r0, #20]
 800a46a:	4313      	orrs	r3, r2
 800a46c:	69c2      	ldr	r2, [r0, #28]
 800a46e:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800a470:	6808      	ldr	r0, [r1, #0]
 800a472:	4a8f      	ldr	r2, [pc, #572]	; (800a6b0 <UART_SetConfig+0x254>)
 800a474:	4002      	ands	r2, r0
 800a476:	431a      	orrs	r2, r3
 800a478:	600a      	str	r2, [r1, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800a47a:	6822      	ldr	r2, [r4, #0]
 800a47c:	6853      	ldr	r3, [r2, #4]
 800a47e:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800a482:	68e1      	ldr	r1, [r4, #12]
 800a484:	430b      	orrs	r3, r1
 800a486:	6053      	str	r3, [r2, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800a488:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800a48a:	6822      	ldr	r2, [r4, #0]
 800a48c:	4b89      	ldr	r3, [pc, #548]	; (800a6b4 <UART_SetConfig+0x258>)
 800a48e:	429a      	cmp	r2, r3
 800a490:	d001      	beq.n	800a496 <UART_SetConfig+0x3a>
    tmpreg |= huart->Init.OneBitSampling;
 800a492:	6a23      	ldr	r3, [r4, #32]
 800a494:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800a496:	6893      	ldr	r3, [r2, #8]
 800a498:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 800a49c:	430b      	orrs	r3, r1
 800a49e:	6093      	str	r3, [r2, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a4a0:	6823      	ldr	r3, [r4, #0]
 800a4a2:	4a85      	ldr	r2, [pc, #532]	; (800a6b8 <UART_SetConfig+0x25c>)
 800a4a4:	4293      	cmp	r3, r2
 800a4a6:	d023      	beq.n	800a4f0 <UART_SetConfig+0x94>
 800a4a8:	4a84      	ldr	r2, [pc, #528]	; (800a6bc <UART_SetConfig+0x260>)
 800a4aa:	4293      	cmp	r3, r2
 800a4ac:	d034      	beq.n	800a518 <UART_SetConfig+0xbc>
 800a4ae:	4a84      	ldr	r2, [pc, #528]	; (800a6c0 <UART_SetConfig+0x264>)
 800a4b0:	4293      	cmp	r3, r2
 800a4b2:	d04a      	beq.n	800a54a <UART_SetConfig+0xee>
 800a4b4:	4a83      	ldr	r2, [pc, #524]	; (800a6c4 <UART_SetConfig+0x268>)
 800a4b6:	4293      	cmp	r3, r2
 800a4b8:	d059      	beq.n	800a56e <UART_SetConfig+0x112>
 800a4ba:	4a7e      	ldr	r2, [pc, #504]	; (800a6b4 <UART_SetConfig+0x258>)
 800a4bc:	4293      	cmp	r3, r2
 800a4be:	d068      	beq.n	800a592 <UART_SetConfig+0x136>
 800a4c0:	2210      	movs	r2, #16
  if (UART_INSTANCE_LOWPOWER(huart))
 800a4c2:	497c      	ldr	r1, [pc, #496]	; (800a6b4 <UART_SetConfig+0x258>)
 800a4c4:	428b      	cmp	r3, r1
 800a4c6:	f000 8095 	beq.w	800a5f4 <UART_SetConfig+0x198>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a4ca:	69e0      	ldr	r0, [r4, #28]
 800a4cc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800a4d0:	f000 80c1 	beq.w	800a656 <UART_SetConfig+0x1fa>
    switch (clocksource)
 800a4d4:	2a08      	cmp	r2, #8
 800a4d6:	f200 812a 	bhi.w	800a72e <UART_SetConfig+0x2d2>
 800a4da:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a4de:	00f9      	.short	0x00f9
 800a4e0:	00e7010f 	.word	0x00e7010f
 800a4e4:	01120128 	.word	0x01120128
 800a4e8:	01280128 	.word	0x01280128
 800a4ec:	01150128 	.word	0x01150128
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a4f0:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
 800a4f4:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a4f8:	f002 0203 	and.w	r2, r2, #3
 800a4fc:	2a03      	cmp	r2, #3
 800a4fe:	d809      	bhi.n	800a514 <UART_SetConfig+0xb8>
 800a500:	e8df f002 	tbb	[pc, r2]
 800a504:	065c0402 	.word	0x065c0402
 800a508:	2201      	movs	r2, #1
 800a50a:	e7da      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a50c:	2204      	movs	r2, #4
 800a50e:	e7d8      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a510:	2208      	movs	r2, #8
 800a512:	e7d6      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a514:	2210      	movs	r2, #16
 800a516:	e7d4      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a518:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 800a51c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a520:	f002 020c 	and.w	r2, r2, #12
 800a524:	2a0c      	cmp	r2, #12
 800a526:	d80e      	bhi.n	800a546 <UART_SetConfig+0xea>
 800a528:	e8df f002 	tbb	[pc, r2]
 800a52c:	0d0d0d07 	.word	0x0d0d0d07
 800a530:	0d0d0d09 	.word	0x0d0d0d09
 800a534:	0d0d0d4a 	.word	0x0d0d0d4a
 800a538:	0b          	.byte	0x0b
 800a539:	00          	.byte	0x00
 800a53a:	2200      	movs	r2, #0
 800a53c:	e7c1      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a53e:	2204      	movs	r2, #4
 800a540:	e7bf      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a542:	2208      	movs	r2, #8
 800a544:	e7bd      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a546:	2210      	movs	r2, #16
 800a548:	e7bb      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a54a:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 800a54e:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a552:	f002 0230 	and.w	r2, r2, #48	; 0x30
 800a556:	2a20      	cmp	r2, #32
 800a558:	d034      	beq.n	800a5c4 <UART_SetConfig+0x168>
 800a55a:	d804      	bhi.n	800a566 <UART_SetConfig+0x10a>
 800a55c:	b3a2      	cbz	r2, 800a5c8 <UART_SetConfig+0x16c>
 800a55e:	2a10      	cmp	r2, #16
 800a560:	d134      	bne.n	800a5cc <UART_SetConfig+0x170>
 800a562:	2204      	movs	r2, #4
 800a564:	e7ad      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a566:	2a30      	cmp	r2, #48	; 0x30
 800a568:	d132      	bne.n	800a5d0 <UART_SetConfig+0x174>
 800a56a:	2208      	movs	r2, #8
 800a56c:	e7a9      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a56e:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 800a572:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a576:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 800a57a:	2a80      	cmp	r2, #128	; 0x80
 800a57c:	d02a      	beq.n	800a5d4 <UART_SetConfig+0x178>
 800a57e:	d804      	bhi.n	800a58a <UART_SetConfig+0x12e>
 800a580:	b352      	cbz	r2, 800a5d8 <UART_SetConfig+0x17c>
 800a582:	2a40      	cmp	r2, #64	; 0x40
 800a584:	d12a      	bne.n	800a5dc <UART_SetConfig+0x180>
 800a586:	2204      	movs	r2, #4
 800a588:	e79b      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a58a:	2ac0      	cmp	r2, #192	; 0xc0
 800a58c:	d128      	bne.n	800a5e0 <UART_SetConfig+0x184>
 800a58e:	2208      	movs	r2, #8
 800a590:	e797      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a592:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 800a596:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a59a:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 800a59e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800a5a2:	d01f      	beq.n	800a5e4 <UART_SetConfig+0x188>
 800a5a4:	d805      	bhi.n	800a5b2 <UART_SetConfig+0x156>
 800a5a6:	b1fa      	cbz	r2, 800a5e8 <UART_SetConfig+0x18c>
 800a5a8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800a5ac:	d11e      	bne.n	800a5ec <UART_SetConfig+0x190>
 800a5ae:	2204      	movs	r2, #4
 800a5b0:	e787      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5b2:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 800a5b6:	d11b      	bne.n	800a5f0 <UART_SetConfig+0x194>
 800a5b8:	2208      	movs	r2, #8
 800a5ba:	e782      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5bc:	2202      	movs	r2, #2
 800a5be:	e780      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5c0:	2202      	movs	r2, #2
 800a5c2:	e77e      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5c4:	2202      	movs	r2, #2
 800a5c6:	e77c      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5c8:	2200      	movs	r2, #0
 800a5ca:	e77a      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5cc:	2210      	movs	r2, #16
 800a5ce:	e778      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5d0:	2210      	movs	r2, #16
 800a5d2:	e776      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5d4:	2202      	movs	r2, #2
 800a5d6:	e774      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5d8:	2200      	movs	r2, #0
 800a5da:	e772      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5dc:	2210      	movs	r2, #16
 800a5de:	e770      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5e0:	2210      	movs	r2, #16
 800a5e2:	e76e      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5e4:	2202      	movs	r2, #2
 800a5e6:	e76c      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5e8:	2200      	movs	r2, #0
 800a5ea:	e76a      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5ec:	2210      	movs	r2, #16
 800a5ee:	e768      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5f0:	2210      	movs	r2, #16
 800a5f2:	e766      	b.n	800a4c2 <UART_SetConfig+0x66>
    switch (clocksource)
 800a5f4:	2a08      	cmp	r2, #8
 800a5f6:	f200 808a 	bhi.w	800a70e <UART_SetConfig+0x2b2>
 800a5fa:	e8df f002 	tbb	[pc, r2]
 800a5fe:	8808      	.short	0x8808
 800a600:	8827882a 	.word	0x8827882a
 800a604:	8888      	.short	0x8888
 800a606:	05          	.byte	0x05
 800a607:	00          	.byte	0x00
 800a608:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800a60c:	e003      	b.n	800a616 <UART_SetConfig+0x1ba>
        pclk = HAL_RCC_GetPCLK1Freq();
 800a60e:	f7fe fc8b 	bl	8008f28 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800a612:	2800      	cmp	r0, #0
 800a614:	d07d      	beq.n	800a712 <UART_SetConfig+0x2b6>
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 800a616:	6862      	ldr	r2, [r4, #4]
 800a618:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800a61c:	4283      	cmp	r3, r0
 800a61e:	d87a      	bhi.n	800a716 <UART_SetConfig+0x2ba>
 800a620:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 800a624:	d879      	bhi.n	800a71a <UART_SetConfig+0x2be>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate));
 800a626:	0e01      	lsrs	r1, r0, #24
 800a628:	0200      	lsls	r0, r0, #8
 800a62a:	0853      	lsrs	r3, r2, #1
 800a62c:	18c0      	adds	r0, r0, r3
 800a62e:	f04f 0300 	mov.w	r3, #0
 800a632:	f141 0100 	adc.w	r1, r1, #0
 800a636:	f7f6 facf 	bl	8000bd8 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800a63a:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
 800a63e:	4b22      	ldr	r3, [pc, #136]	; (800a6c8 <UART_SetConfig+0x26c>)
 800a640:	429a      	cmp	r2, r3
 800a642:	d86c      	bhi.n	800a71e <UART_SetConfig+0x2c2>
          huart->Instance->BRR = usartdiv;
 800a644:	6823      	ldr	r3, [r4, #0]
 800a646:	60d8      	str	r0, [r3, #12]
 800a648:	2000      	movs	r0, #0
 800a64a:	e053      	b.n	800a6f4 <UART_SetConfig+0x298>
        pclk = HAL_RCC_GetSysClockFreq();
 800a64c:	f7fe f81e 	bl	800868c <HAL_RCC_GetSysClockFreq>
        break;
 800a650:	e7df      	b.n	800a612 <UART_SetConfig+0x1b6>
        pclk = (uint32_t) HSI_VALUE;
 800a652:	481e      	ldr	r0, [pc, #120]	; (800a6cc <UART_SetConfig+0x270>)
 800a654:	e7df      	b.n	800a616 <UART_SetConfig+0x1ba>
    switch (clocksource)
 800a656:	2a08      	cmp	r2, #8
 800a658:	d863      	bhi.n	800a722 <UART_SetConfig+0x2c6>
 800a65a:	e8df f002 	tbb	[pc, r2]
 800a65e:	2107      	.short	0x2107
 800a660:	62246205 	.word	0x62246205
 800a664:	6262      	.short	0x6262
 800a666:	0b          	.byte	0x0b
 800a667:	00          	.byte	0x00
 800a668:	4818      	ldr	r0, [pc, #96]	; (800a6cc <UART_SetConfig+0x270>)
 800a66a:	e003      	b.n	800a674 <UART_SetConfig+0x218>
        pclk = HAL_RCC_GetPCLK1Freq();
 800a66c:	f7fe fc5c 	bl	8008f28 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800a670:	2800      	cmp	r0, #0
 800a672:	d058      	beq.n	800a726 <UART_SetConfig+0x2ca>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800a674:	6862      	ldr	r2, [r4, #4]
 800a676:	0853      	lsrs	r3, r2, #1
 800a678:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800a67c:	fbb3 f3f2 	udiv	r3, r3, r2
 800a680:	b29b      	uxth	r3, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800a682:	f1a3 0110 	sub.w	r1, r3, #16
 800a686:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800a68a:	4291      	cmp	r1, r2
 800a68c:	d84d      	bhi.n	800a72a <UART_SetConfig+0x2ce>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800a68e:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800a692:	f3c3 0342 	ubfx	r3, r3, #1, #3
 800a696:	4313      	orrs	r3, r2
        huart->Instance->BRR = brrtemp;
 800a698:	6822      	ldr	r2, [r4, #0]
 800a69a:	60d3      	str	r3, [r2, #12]
 800a69c:	2000      	movs	r0, #0
 800a69e:	e029      	b.n	800a6f4 <UART_SetConfig+0x298>
        pclk = HAL_RCC_GetPCLK2Freq();
 800a6a0:	f7fe fc54 	bl	8008f4c <HAL_RCC_GetPCLK2Freq>
        break;
 800a6a4:	e7e4      	b.n	800a670 <UART_SetConfig+0x214>
        pclk = HAL_RCC_GetSysClockFreq();
 800a6a6:	f7fd fff1 	bl	800868c <HAL_RCC_GetSysClockFreq>
        break;
 800a6aa:	e7e1      	b.n	800a670 <UART_SetConfig+0x214>
    switch (clocksource)
 800a6ac:	4807      	ldr	r0, [pc, #28]	; (800a6cc <UART_SetConfig+0x270>)
 800a6ae:	e012      	b.n	800a6d6 <UART_SetConfig+0x27a>
 800a6b0:	efff69f3 	.word	0xefff69f3
 800a6b4:	40008000 	.word	0x40008000
 800a6b8:	40013800 	.word	0x40013800
 800a6bc:	40004400 	.word	0x40004400
 800a6c0:	40004800 	.word	0x40004800
 800a6c4:	40004c00 	.word	0x40004c00
 800a6c8:	000ffcff 	.word	0x000ffcff
 800a6cc:	00f42400 	.word	0x00f42400
        pclk = HAL_RCC_GetPCLK1Freq();
 800a6d0:	f7fe fc2a 	bl	8008f28 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800a6d4:	b368      	cbz	r0, 800a732 <UART_SetConfig+0x2d6>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800a6d6:	6863      	ldr	r3, [r4, #4]
 800a6d8:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800a6dc:	fbb0 f0f3 	udiv	r0, r0, r3
 800a6e0:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800a6e2:	f1a0 0210 	sub.w	r2, r0, #16
 800a6e6:	f64f 73ef 	movw	r3, #65519	; 0xffef
 800a6ea:	429a      	cmp	r2, r3
 800a6ec:	d823      	bhi.n	800a736 <UART_SetConfig+0x2da>
        huart->Instance->BRR = usartdiv;
 800a6ee:	6823      	ldr	r3, [r4, #0]
 800a6f0:	60d8      	str	r0, [r3, #12]
 800a6f2:	2000      	movs	r0, #0
  huart->RxISR = NULL;
 800a6f4:	2300      	movs	r3, #0
 800a6f6:	6623      	str	r3, [r4, #96]	; 0x60
  huart->TxISR = NULL;
 800a6f8:	6663      	str	r3, [r4, #100]	; 0x64
}
 800a6fa:	bd10      	pop	{r4, pc}
        pclk = HAL_RCC_GetPCLK2Freq();
 800a6fc:	f7fe fc26 	bl	8008f4c <HAL_RCC_GetPCLK2Freq>
        break;
 800a700:	e7e8      	b.n	800a6d4 <UART_SetConfig+0x278>
        pclk = HAL_RCC_GetSysClockFreq();
 800a702:	f7fd ffc3 	bl	800868c <HAL_RCC_GetSysClockFreq>
        break;
 800a706:	e7e5      	b.n	800a6d4 <UART_SetConfig+0x278>
        pclk = (uint32_t) LSE_VALUE;
 800a708:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800a70c:	e7e3      	b.n	800a6d6 <UART_SetConfig+0x27a>
    switch (clocksource)
 800a70e:	2001      	movs	r0, #1
 800a710:	e7f0      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a712:	2000      	movs	r0, #0
 800a714:	e7ee      	b.n	800a6f4 <UART_SetConfig+0x298>
        ret = HAL_ERROR;
 800a716:	2001      	movs	r0, #1
 800a718:	e7ec      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a71a:	2001      	movs	r0, #1
 800a71c:	e7ea      	b.n	800a6f4 <UART_SetConfig+0x298>
          ret = HAL_ERROR;
 800a71e:	2001      	movs	r0, #1
 800a720:	e7e8      	b.n	800a6f4 <UART_SetConfig+0x298>
    switch (clocksource)
 800a722:	2001      	movs	r0, #1
 800a724:	e7e6      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a726:	2000      	movs	r0, #0
 800a728:	e7e4      	b.n	800a6f4 <UART_SetConfig+0x298>
        ret = HAL_ERROR;
 800a72a:	2001      	movs	r0, #1
 800a72c:	e7e2      	b.n	800a6f4 <UART_SetConfig+0x298>
    switch (clocksource)
 800a72e:	2001      	movs	r0, #1
 800a730:	e7e0      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a732:	2000      	movs	r0, #0
 800a734:	e7de      	b.n	800a6f4 <UART_SetConfig+0x298>
        ret = HAL_ERROR;
 800a736:	2001      	movs	r0, #1
 800a738:	e7dc      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a73a:	bf00      	nop

0800a73c <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800a73c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a73e:	f013 0f01 	tst.w	r3, #1
 800a742:	d006      	beq.n	800a752 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800a744:	6802      	ldr	r2, [r0, #0]
 800a746:	6853      	ldr	r3, [r2, #4]
 800a748:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800a74c:	6a81      	ldr	r1, [r0, #40]	; 0x28
 800a74e:	430b      	orrs	r3, r1
 800a750:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800a752:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a754:	f013 0f02 	tst.w	r3, #2
 800a758:	d006      	beq.n	800a768 <UART_AdvFeatureConfig+0x2c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800a75a:	6802      	ldr	r2, [r0, #0]
 800a75c:	6853      	ldr	r3, [r2, #4]
 800a75e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a762:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800a764:	430b      	orrs	r3, r1
 800a766:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800a768:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a76a:	f013 0f04 	tst.w	r3, #4
 800a76e:	d006      	beq.n	800a77e <UART_AdvFeatureConfig+0x42>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800a770:	6802      	ldr	r2, [r0, #0]
 800a772:	6853      	ldr	r3, [r2, #4]
 800a774:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800a778:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800a77a:	430b      	orrs	r3, r1
 800a77c:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800a77e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a780:	f013 0f08 	tst.w	r3, #8
 800a784:	d006      	beq.n	800a794 <UART_AdvFeatureConfig+0x58>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800a786:	6802      	ldr	r2, [r0, #0]
 800a788:	6853      	ldr	r3, [r2, #4]
 800a78a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800a78e:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800a790:	430b      	orrs	r3, r1
 800a792:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800a794:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a796:	f013 0f10 	tst.w	r3, #16
 800a79a:	d006      	beq.n	800a7aa <UART_AdvFeatureConfig+0x6e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800a79c:	6802      	ldr	r2, [r0, #0]
 800a79e:	6893      	ldr	r3, [r2, #8]
 800a7a0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800a7a4:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800a7a6:	430b      	orrs	r3, r1
 800a7a8:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800a7aa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a7ac:	f013 0f20 	tst.w	r3, #32
 800a7b0:	d006      	beq.n	800a7c0 <UART_AdvFeatureConfig+0x84>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800a7b2:	6802      	ldr	r2, [r0, #0]
 800a7b4:	6893      	ldr	r3, [r2, #8]
 800a7b6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800a7ba:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 800a7bc:	430b      	orrs	r3, r1
 800a7be:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800a7c0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a7c2:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a7c6:	d00a      	beq.n	800a7de <UART_AdvFeatureConfig+0xa2>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800a7c8:	6802      	ldr	r2, [r0, #0]
 800a7ca:	6853      	ldr	r3, [r2, #4]
 800a7cc:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800a7d0:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800a7d2:	430b      	orrs	r3, r1
 800a7d4:	6053      	str	r3, [r2, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800a7d6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a7d8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800a7dc:	d00b      	beq.n	800a7f6 <UART_AdvFeatureConfig+0xba>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800a7de:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a7e0:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a7e4:	d006      	beq.n	800a7f4 <UART_AdvFeatureConfig+0xb8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800a7e6:	6802      	ldr	r2, [r0, #0]
 800a7e8:	6853      	ldr	r3, [r2, #4]
 800a7ea:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800a7ee:	6c81      	ldr	r1, [r0, #72]	; 0x48
 800a7f0:	430b      	orrs	r3, r1
 800a7f2:	6053      	str	r3, [r2, #4]
}
 800a7f4:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800a7f6:	6802      	ldr	r2, [r0, #0]
 800a7f8:	6853      	ldr	r3, [r2, #4]
 800a7fa:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 800a7fe:	6c41      	ldr	r1, [r0, #68]	; 0x44
 800a800:	430b      	orrs	r3, r1
 800a802:	6053      	str	r3, [r2, #4]
 800a804:	e7eb      	b.n	800a7de <UART_AdvFeatureConfig+0xa2>

0800a806 <UART_WaitOnFlagUntilTimeout>:
{
 800a806:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a80a:	4605      	mov	r5, r0
 800a80c:	460f      	mov	r7, r1
 800a80e:	4616      	mov	r6, r2
 800a810:	4699      	mov	r9, r3
 800a812:	f8dd 8020 	ldr.w	r8, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800a816:	682b      	ldr	r3, [r5, #0]
 800a818:	69dc      	ldr	r4, [r3, #28]
 800a81a:	ea37 0404 	bics.w	r4, r7, r4
 800a81e:	bf0c      	ite	eq
 800a820:	2401      	moveq	r4, #1
 800a822:	2400      	movne	r4, #0
 800a824:	42b4      	cmp	r4, r6
 800a826:	d13c      	bne.n	800a8a2 <UART_WaitOnFlagUntilTimeout+0x9c>
    if (Timeout != HAL_MAX_DELAY)
 800a828:	f1b8 3fff 	cmp.w	r8, #4294967295
 800a82c:	d0f3      	beq.n	800a816 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a82e:	f7fc fbb3 	bl	8006f98 <HAL_GetTick>
 800a832:	eba0 0009 	sub.w	r0, r0, r9
 800a836:	4540      	cmp	r0, r8
 800a838:	d821      	bhi.n	800a87e <UART_WaitOnFlagUntilTimeout+0x78>
 800a83a:	f1b8 0f00 	cmp.w	r8, #0
 800a83e:	d01e      	beq.n	800a87e <UART_WaitOnFlagUntilTimeout+0x78>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800a840:	682b      	ldr	r3, [r5, #0]
 800a842:	681a      	ldr	r2, [r3, #0]
 800a844:	f012 0f04 	tst.w	r2, #4
 800a848:	d0e5      	beq.n	800a816 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800a84a:	69da      	ldr	r2, [r3, #28]
 800a84c:	f412 6f00 	tst.w	r2, #2048	; 0x800
 800a850:	d0e1      	beq.n	800a816 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800a852:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800a856:	621a      	str	r2, [r3, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800a858:	682a      	ldr	r2, [r5, #0]
 800a85a:	6813      	ldr	r3, [r2, #0]
 800a85c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800a860:	6013      	str	r3, [r2, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a862:	682a      	ldr	r2, [r5, #0]
 800a864:	6893      	ldr	r3, [r2, #8]
 800a866:	f023 0301 	bic.w	r3, r3, #1
 800a86a:	6093      	str	r3, [r2, #8]
          huart->gState = HAL_UART_STATE_READY;
 800a86c:	2320      	movs	r3, #32
 800a86e:	676b      	str	r3, [r5, #116]	; 0x74
          huart->RxState = HAL_UART_STATE_READY;
 800a870:	67ab      	str	r3, [r5, #120]	; 0x78
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800a872:	67eb      	str	r3, [r5, #124]	; 0x7c
          __HAL_UNLOCK(huart);
 800a874:	2300      	movs	r3, #0
 800a876:	f885 3070 	strb.w	r3, [r5, #112]	; 0x70
          return HAL_TIMEOUT;
 800a87a:	2003      	movs	r0, #3
 800a87c:	e012      	b.n	800a8a4 <UART_WaitOnFlagUntilTimeout+0x9e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800a87e:	682a      	ldr	r2, [r5, #0]
 800a880:	6813      	ldr	r3, [r2, #0]
 800a882:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800a886:	6013      	str	r3, [r2, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a888:	682a      	ldr	r2, [r5, #0]
 800a88a:	6893      	ldr	r3, [r2, #8]
 800a88c:	f023 0301 	bic.w	r3, r3, #1
 800a890:	6093      	str	r3, [r2, #8]
        huart->gState = HAL_UART_STATE_READY;
 800a892:	2320      	movs	r3, #32
 800a894:	676b      	str	r3, [r5, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 800a896:	67ab      	str	r3, [r5, #120]	; 0x78
        __HAL_UNLOCK(huart);
 800a898:	2300      	movs	r3, #0
 800a89a:	f885 3070 	strb.w	r3, [r5, #112]	; 0x70
        return HAL_TIMEOUT;
 800a89e:	2003      	movs	r0, #3
 800a8a0:	e000      	b.n	800a8a4 <UART_WaitOnFlagUntilTimeout+0x9e>
  return HAL_OK;
 800a8a2:	2000      	movs	r0, #0
}
 800a8a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800a8a8 <HAL_UART_Transmit>:
{
 800a8a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a8ac:	b082      	sub	sp, #8
 800a8ae:	461e      	mov	r6, r3
  if (huart->gState == HAL_UART_STATE_READY)
 800a8b0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a8b2:	2b20      	cmp	r3, #32
 800a8b4:	d155      	bne.n	800a962 <HAL_UART_Transmit+0xba>
 800a8b6:	4604      	mov	r4, r0
 800a8b8:	460d      	mov	r5, r1
 800a8ba:	4690      	mov	r8, r2
    if ((pData == NULL) || (Size == 0U))
 800a8bc:	2900      	cmp	r1, #0
 800a8be:	d054      	beq.n	800a96a <HAL_UART_Transmit+0xc2>
 800a8c0:	2a00      	cmp	r2, #0
 800a8c2:	d054      	beq.n	800a96e <HAL_UART_Transmit+0xc6>
    __HAL_LOCK(huart);
 800a8c4:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 800a8c8:	2b01      	cmp	r3, #1
 800a8ca:	d052      	beq.n	800a972 <HAL_UART_Transmit+0xca>
 800a8cc:	2301      	movs	r3, #1
 800a8ce:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a8d2:	2300      	movs	r3, #0
 800a8d4:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800a8d6:	2321      	movs	r3, #33	; 0x21
 800a8d8:	6743      	str	r3, [r0, #116]	; 0x74
    tickstart = HAL_GetTick();
 800a8da:	f7fc fb5d 	bl	8006f98 <HAL_GetTick>
 800a8de:	4607      	mov	r7, r0
    huart->TxXferSize  = Size;
 800a8e0:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50
    huart->TxXferCount = Size;
 800a8e4:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a8e8:	68a3      	ldr	r3, [r4, #8]
 800a8ea:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a8ee:	d005      	beq.n	800a8fc <HAL_UART_Transmit+0x54>
      pdata16bits = NULL;
 800a8f0:	f04f 0800 	mov.w	r8, #0
    __HAL_UNLOCK(huart);
 800a8f4:	2300      	movs	r3, #0
 800a8f6:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    while (huart->TxXferCount > 0U)
 800a8fa:	e014      	b.n	800a926 <HAL_UART_Transmit+0x7e>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a8fc:	6923      	ldr	r3, [r4, #16]
 800a8fe:	b113      	cbz	r3, 800a906 <HAL_UART_Transmit+0x5e>
      pdata16bits = NULL;
 800a900:	f04f 0800 	mov.w	r8, #0
 800a904:	e7f6      	b.n	800a8f4 <HAL_UART_Transmit+0x4c>
      pdata16bits = (uint16_t *) pData;
 800a906:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 800a908:	2500      	movs	r5, #0
 800a90a:	e7f3      	b.n	800a8f4 <HAL_UART_Transmit+0x4c>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800a90c:	f838 3b02 	ldrh.w	r3, [r8], #2
 800a910:	6822      	ldr	r2, [r4, #0]
 800a912:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a916:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 800a918:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
 800a91c:	b292      	uxth	r2, r2
 800a91e:	3a01      	subs	r2, #1
 800a920:	b292      	uxth	r2, r2
 800a922:	f8a4 2052 	strh.w	r2, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 800a926:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 800a92a:	b29b      	uxth	r3, r3
 800a92c:	b173      	cbz	r3, 800a94c <HAL_UART_Transmit+0xa4>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800a92e:	9600      	str	r6, [sp, #0]
 800a930:	463b      	mov	r3, r7
 800a932:	2200      	movs	r2, #0
 800a934:	2180      	movs	r1, #128	; 0x80
 800a936:	4620      	mov	r0, r4
 800a938:	f7ff ff65 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a93c:	b9d8      	cbnz	r0, 800a976 <HAL_UART_Transmit+0xce>
      if (pdata8bits == NULL)
 800a93e:	2d00      	cmp	r5, #0
 800a940:	d0e4      	beq.n	800a90c <HAL_UART_Transmit+0x64>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800a942:	6823      	ldr	r3, [r4, #0]
 800a944:	f815 2b01 	ldrb.w	r2, [r5], #1
 800a948:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800a94a:	e7e5      	b.n	800a918 <HAL_UART_Transmit+0x70>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800a94c:	9600      	str	r6, [sp, #0]
 800a94e:	463b      	mov	r3, r7
 800a950:	2200      	movs	r2, #0
 800a952:	2140      	movs	r1, #64	; 0x40
 800a954:	4620      	mov	r0, r4
 800a956:	f7ff ff56 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a95a:	b970      	cbnz	r0, 800a97a <HAL_UART_Transmit+0xd2>
    huart->gState = HAL_UART_STATE_READY;
 800a95c:	2320      	movs	r3, #32
 800a95e:	6763      	str	r3, [r4, #116]	; 0x74
    return HAL_OK;
 800a960:	e000      	b.n	800a964 <HAL_UART_Transmit+0xbc>
    return HAL_BUSY;
 800a962:	2002      	movs	r0, #2
}
 800a964:	b002      	add	sp, #8
 800a966:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 800a96a:	2001      	movs	r0, #1
 800a96c:	e7fa      	b.n	800a964 <HAL_UART_Transmit+0xbc>
 800a96e:	2001      	movs	r0, #1
 800a970:	e7f8      	b.n	800a964 <HAL_UART_Transmit+0xbc>
    __HAL_LOCK(huart);
 800a972:	2002      	movs	r0, #2
 800a974:	e7f6      	b.n	800a964 <HAL_UART_Transmit+0xbc>
        return HAL_TIMEOUT;
 800a976:	2003      	movs	r0, #3
 800a978:	e7f4      	b.n	800a964 <HAL_UART_Transmit+0xbc>
      return HAL_TIMEOUT;
 800a97a:	2003      	movs	r0, #3
 800a97c:	e7f2      	b.n	800a964 <HAL_UART_Transmit+0xbc>

0800a97e <UART_CheckIdleState>:
{
 800a97e:	b530      	push	{r4, r5, lr}
 800a980:	b083      	sub	sp, #12
 800a982:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a984:	2300      	movs	r3, #0
 800a986:	67c3      	str	r3, [r0, #124]	; 0x7c
  tickstart = HAL_GetTick();
 800a988:	f7fc fb06 	bl	8006f98 <HAL_GetTick>
 800a98c:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800a98e:	6822      	ldr	r2, [r4, #0]
 800a990:	6812      	ldr	r2, [r2, #0]
 800a992:	f012 0f08 	tst.w	r2, #8
 800a996:	d10c      	bne.n	800a9b2 <UART_CheckIdleState+0x34>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800a998:	6823      	ldr	r3, [r4, #0]
 800a99a:	681b      	ldr	r3, [r3, #0]
 800a99c:	f013 0f04 	tst.w	r3, #4
 800a9a0:	d115      	bne.n	800a9ce <UART_CheckIdleState+0x50>
  huart->gState = HAL_UART_STATE_READY;
 800a9a2:	2320      	movs	r3, #32
 800a9a4:	6763      	str	r3, [r4, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 800a9a6:	67a3      	str	r3, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 800a9a8:	2000      	movs	r0, #0
 800a9aa:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
}
 800a9ae:	b003      	add	sp, #12
 800a9b0:	bd30      	pop	{r4, r5, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800a9b2:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800a9b6:	9300      	str	r3, [sp, #0]
 800a9b8:	4603      	mov	r3, r0
 800a9ba:	2200      	movs	r2, #0
 800a9bc:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800a9c0:	4620      	mov	r0, r4
 800a9c2:	f7ff ff20 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a9c6:	2800      	cmp	r0, #0
 800a9c8:	d0e6      	beq.n	800a998 <UART_CheckIdleState+0x1a>
      return HAL_TIMEOUT;
 800a9ca:	2003      	movs	r0, #3
 800a9cc:	e7ef      	b.n	800a9ae <UART_CheckIdleState+0x30>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800a9ce:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800a9d2:	9300      	str	r3, [sp, #0]
 800a9d4:	462b      	mov	r3, r5
 800a9d6:	2200      	movs	r2, #0
 800a9d8:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800a9dc:	4620      	mov	r0, r4
 800a9de:	f7ff ff12 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a9e2:	2800      	cmp	r0, #0
 800a9e4:	d0dd      	beq.n	800a9a2 <UART_CheckIdleState+0x24>
      return HAL_TIMEOUT;
 800a9e6:	2003      	movs	r0, #3
 800a9e8:	e7e1      	b.n	800a9ae <UART_CheckIdleState+0x30>

0800a9ea <HAL_UART_Init>:
  if (huart == NULL)
 800a9ea:	b368      	cbz	r0, 800aa48 <HAL_UART_Init+0x5e>
{
 800a9ec:	b510      	push	{r4, lr}
 800a9ee:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 800a9f0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a9f2:	b303      	cbz	r3, 800aa36 <HAL_UART_Init+0x4c>
  huart->gState = HAL_UART_STATE_BUSY;
 800a9f4:	2324      	movs	r3, #36	; 0x24
 800a9f6:	6763      	str	r3, [r4, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 800a9f8:	6822      	ldr	r2, [r4, #0]
 800a9fa:	6813      	ldr	r3, [r2, #0]
 800a9fc:	f023 0301 	bic.w	r3, r3, #1
 800aa00:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800aa02:	4620      	mov	r0, r4
 800aa04:	f7ff fd2a 	bl	800a45c <UART_SetConfig>
 800aa08:	2801      	cmp	r0, #1
 800aa0a:	d013      	beq.n	800aa34 <HAL_UART_Init+0x4a>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800aa0c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800aa0e:	b9bb      	cbnz	r3, 800aa40 <HAL_UART_Init+0x56>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800aa10:	6822      	ldr	r2, [r4, #0]
 800aa12:	6853      	ldr	r3, [r2, #4]
 800aa14:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800aa18:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800aa1a:	6822      	ldr	r2, [r4, #0]
 800aa1c:	6893      	ldr	r3, [r2, #8]
 800aa1e:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 800aa22:	6093      	str	r3, [r2, #8]
  __HAL_UART_ENABLE(huart);
 800aa24:	6822      	ldr	r2, [r4, #0]
 800aa26:	6813      	ldr	r3, [r2, #0]
 800aa28:	f043 0301 	orr.w	r3, r3, #1
 800aa2c:	6013      	str	r3, [r2, #0]
  return (UART_CheckIdleState(huart));
 800aa2e:	4620      	mov	r0, r4
 800aa30:	f7ff ffa5 	bl	800a97e <UART_CheckIdleState>
}
 800aa34:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 800aa36:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 800aa3a:	f7f7 f833 	bl	8001aa4 <HAL_UART_MspInit>
 800aa3e:	e7d9      	b.n	800a9f4 <HAL_UART_Init+0xa>
    UART_AdvFeatureConfig(huart);
 800aa40:	4620      	mov	r0, r4
 800aa42:	f7ff fe7b 	bl	800a73c <UART_AdvFeatureConfig>
 800aa46:	e7e3      	b.n	800aa10 <HAL_UART_Init+0x26>
    return HAL_ERROR;
 800aa48:	2001      	movs	r0, #1
}
 800aa4a:	4770      	bx	lr

0800aa4c <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 800aa4c:	4770      	bx	lr

0800aa4e <USB_CoreInit>:
  * @param  cfg : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800aa4e:	b084      	sub	sp, #16
 800aa50:	a801      	add	r0, sp, #4
 800aa52:	e880 000e 	stmia.w	r0, {r1, r2, r3}
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 800aa56:	2000      	movs	r0, #0
 800aa58:	b004      	add	sp, #16
 800aa5a:	4770      	bx	lr

0800aa5c <USB_DisableGlobalInt>:
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 800aa5c:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
 800aa60:	f423 537e 	bic.w	r3, r3, #16256	; 0x3f80
 800aa64:	045b      	lsls	r3, r3, #17
 800aa66:	0c5b      	lsrs	r3, r3, #17
 800aa68:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40

  return HAL_OK;
}
 800aa6c:	2000      	movs	r0, #0
 800aa6e:	4770      	bx	lr

0800aa70 <USB_SetCurrentMode>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 800aa70:	2000      	movs	r0, #0
 800aa72:	4770      	bx	lr

0800aa74 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800aa74:	b084      	sub	sp, #16
 800aa76:	4684      	mov	ip, r0
 800aa78:	a801      	add	r0, sp, #4
 800aa7a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 800aa7e:	2301      	movs	r3, #1
 800aa80:	f8ac 3040 	strh.w	r3, [ip, #64]	; 0x40

  /*CNTR_FRES = 0*/
  USBx->CNTR = 0U;
 800aa84:	2000      	movs	r0, #0
 800aa86:	f8ac 0040 	strh.w	r0, [ip, #64]	; 0x40

  /*Clear pending interrupts*/
  USBx->ISTR = 0U;
 800aa8a:	f8ac 0044 	strh.w	r0, [ip, #68]	; 0x44

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 800aa8e:	f8ac 0050 	strh.w	r0, [ip, #80]	; 0x50

  return HAL_OK;
}
 800aa92:	b004      	add	sp, #16
 800aa94:	4770      	bx	lr

0800aa96 <USB_DevDisconnect>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect(USB_TypeDef *USBx)
{
  /* Disable DP Pull-Up bit to disconnect the Internal PU resistor on USB DP line */
  USBx->BCDR &= (uint16_t)(~(USB_BCDR_DPPU));
 800aa96:	f8b0 3058 	ldrh.w	r3, [r0, #88]	; 0x58
 800aa9a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800aa9e:	f8a0 3058 	strh.w	r3, [r0, #88]	; 0x58

  return HAL_OK;
}
 800aaa2:	2000      	movs	r0, #0
 800aaa4:	4770      	bx	lr
	...

0800aaa8 <find_deviceType_ATHandle>:

  return (retval);
}

static at_handle_t find_deviceType_ATHandle(sysctrl_device_type_t deviceType)
{
 800aaa8:	4602      	mov	r2, r0
  at_handle_t retval = AT_HANDLE_INVALID; /* default value */
  at_handle_t idx = 0;
 800aaaa:	2000      	movs	r0, #0

  /* find handle */
  while (idx < ATCORE_MAX_HANDLES)
 800aaac:	2800      	cmp	r0, #0
 800aaae:	dd02      	ble.n	800aab6 <find_deviceType_ATHandle+0xe>
  at_handle_t retval = AT_HANDLE_INVALID; /* default value */
 800aab0:	f04f 30ff 	mov.w	r0, #4294967295
    }
    idx++;
  }

  return (retval);
}
 800aab4:	4770      	bx	lr
    if (at_context[idx].device_type == deviceType)
 800aab6:	f240 639c 	movw	r3, #1692	; 0x69c
 800aaba:	fb00 f303 	mul.w	r3, r0, r3
 800aabe:	4903      	ldr	r1, [pc, #12]	; (800aacc <find_deviceType_ATHandle+0x24>)
 800aac0:	5ccb      	ldrb	r3, [r1, r3]
 800aac2:	4293      	cmp	r3, r2
 800aac4:	d0f6      	beq.n	800aab4 <find_deviceType_ATHandle+0xc>
    idx++;
 800aac6:	1c43      	adds	r3, r0, #1
 800aac8:	b218      	sxth	r0, r3
 800aaca:	e7ef      	b.n	800aaac <find_deviceType_ATHandle+0x4>
 800aacc:	2000188c 	.word	0x2000188c

0800aad0 <IRQ_DISABLE>:
  __ASM volatile ("cpsid i" : : : "memory");
 800aad0:	b672      	cpsid	i
}

static void IRQ_DISABLE(void)
{
  __disable_irq();
}
 800aad2:	4770      	bx	lr

0800aad4 <IRQ_ENABLE>:
  __ASM volatile ("cpsie i" : : : "memory");
 800aad4:	b662      	cpsie	i

static void IRQ_ENABLE(void)
{
  __enable_irq();
}
 800aad6:	4770      	bx	lr

0800aad8 <findMsgReceivedHandle>:

  return (retval);
}

static at_status_t findMsgReceivedHandle(at_handle_t *athandle)
{
 800aad8:	4603      	mov	r3, r0
  bool leave_loop = false;
  at_handle_t i = 0;

  do
  {
    if (MsgReceived[i] != 0U)
 800aada:	4a04      	ldr	r2, [pc, #16]	; (800aaec <findMsgReceivedHandle+0x14>)
 800aadc:	7812      	ldrb	r2, [r2, #0]
 800aade:	b112      	cbz	r2, 800aae6 <findMsgReceivedHandle+0xe>
    {
      *athandle = (at_handle_t) i;
 800aae0:	2000      	movs	r0, #0
 800aae2:	8018      	strh	r0, [r3, #0]
      retval = ATSTATUS_OK;
      leave_loop = true;
 800aae4:	4770      	bx	lr
 800aae6:	2001      	movs	r0, #1
    }
    i++;
  } while ((leave_loop == false) && (i < ATCORE_MAX_HANDLES));

  return (retval);
}
 800aae8:	4770      	bx	lr
 800aaea:	bf00      	nop
 800aaec:	20001888 	.word	0x20001888

0800aaf0 <allocate_ATHandle>:
{
 800aaf0:	b538      	push	{r3, r4, r5, lr}
 800aaf2:	4605      	mov	r5, r0
  at_handle_t idx = 0;
 800aaf4:	2400      	movs	r4, #0
  while ((idx < ATCORE_MAX_HANDLES) && (at_context[idx].device_type != DEVTYPE_INVALID))
 800aaf6:	2c00      	cmp	r4, #0
 800aaf8:	dc0a      	bgt.n	800ab10 <allocate_ATHandle+0x20>
 800aafa:	f240 639c 	movw	r3, #1692	; 0x69c
 800aafe:	fb04 f303 	mul.w	r3, r4, r3
 800ab02:	4a09      	ldr	r2, [pc, #36]	; (800ab28 <allocate_ATHandle+0x38>)
 800ab04:	5cd3      	ldrb	r3, [r2, r3]
 800ab06:	2b01      	cmp	r3, #1
 800ab08:	d002      	beq.n	800ab10 <allocate_ATHandle+0x20>
    idx++;
 800ab0a:	3401      	adds	r4, #1
 800ab0c:	b224      	sxth	r4, r4
 800ab0e:	e7f2      	b.n	800aaf6 <allocate_ATHandle+0x6>
  if (idx == ATCORE_MAX_HANDLES)
 800ab10:	2c01      	cmp	r4, #1
 800ab12:	d002      	beq.n	800ab1a <allocate_ATHandle+0x2a>
  at_status_t retval = ATSTATUS_OK;
 800ab14:	2000      	movs	r0, #0
  *athandle = (at_handle_t) idx;
 800ab16:	802c      	strh	r4, [r5, #0]
}
 800ab18:	bd38      	pop	{r3, r4, r5, pc}
    LOG_ERROR(6, ERROR_WARNING);
 800ab1a:	2202      	movs	r2, #2
 800ab1c:	2106      	movs	r1, #6
 800ab1e:	4610      	mov	r0, r2
 800ab20:	f013 fb14 	bl	801e14c <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800ab24:	2001      	movs	r0, #1
 800ab26:	e7f6      	b.n	800ab16 <allocate_ATHandle+0x26>
 800ab28:	2000188c 	.word	0x2000188c

0800ab2c <find_index>:
{
 800ab2c:	b508      	push	{r3, lr}
    if (&ipcHandleTab[idx] == ipcHandle)
 800ab2e:	4b05      	ldr	r3, [pc, #20]	; (800ab44 <find_index+0x18>)
 800ab30:	4283      	cmp	r3, r0
 800ab32:	d004      	beq.n	800ab3e <find_index+0x12>
    LOG_ERROR(5, ERROR_FATAL);
 800ab34:	2203      	movs	r2, #3
 800ab36:	2105      	movs	r1, #5
 800ab38:	2002      	movs	r0, #2
 800ab3a:	f013 fb07 	bl	801e14c <ERROR_Handler>
}
 800ab3e:	2000      	movs	r0, #0
 800ab40:	bd08      	pop	{r3, pc}
 800ab42:	bf00      	nop
 800ab44:	20002570 	.word	0x20002570

0800ab48 <waitOnMsgUntilTimeout>:
{
 800ab48:	b570      	push	{r4, r5, r6, lr}
 800ab4a:	4615      	mov	r5, r2
  TRACE_DBG("**** Waiting Sema (to=%lu) *****", Timeout)
 800ab4c:	4c2c      	ldr	r4, [pc, #176]	; (800ac00 <waitOnMsgUntilTimeout+0xb8>)
 800ab4e:	492d      	ldr	r1, [pc, #180]	; (800ac04 <waitOnMsgUntilTimeout+0xbc>)
 800ab50:	4620      	mov	r0, r4
 800ab52:	f01b f88d 	bl	8025c70 <sprintf>
 800ab56:	4620      	mov	r0, r4
 800ab58:	f014 fadb 	bl	801f112 <crs_strlen>
 800ab5c:	b283      	uxth	r3, r0
 800ab5e:	4622      	mov	r2, r4
 800ab60:	2102      	movs	r1, #2
 800ab62:	4608      	mov	r0, r1
 800ab64:	f014 fb18 	bl	801f198 <traceIF_itmPrint>
 800ab68:	4620      	mov	r0, r4
 800ab6a:	f014 fad2 	bl	801f112 <crs_strlen>
 800ab6e:	b283      	uxth	r3, r0
 800ab70:	4622      	mov	r2, r4
 800ab72:	2102      	movs	r1, #2
 800ab74:	4608      	mov	r0, r1
 800ab76:	f014 fb31 	bl	801f1dc <traceIF_uartPrint>
  if (rtosalSemaphoreAcquire(s_WaitAnswer_SemaphoreId, Timeout) != ((rtosalStatus)osOK))
 800ab7a:	4629      	mov	r1, r5
 800ab7c:	4b22      	ldr	r3, [pc, #136]	; (800ac08 <waitOnMsgUntilTimeout+0xc0>)
 800ab7e:	6818      	ldr	r0, [r3, #0]
 800ab80:	f014 f9cf 	bl	801ef22 <rtosalSemaphoreAcquire>
 800ab84:	bb18      	cbnz	r0, 800abce <waitOnMsgUntilTimeout+0x86>
  at_status_t retval = ATSTATUS_OK;
 800ab86:	2600      	movs	r6, #0
  TRACE_DBG("**** Sema Freed *****")
 800ab88:	4c1d      	ldr	r4, [pc, #116]	; (800ac00 <waitOnMsgUntilTimeout+0xb8>)
 800ab8a:	4d20      	ldr	r5, [pc, #128]	; (800ac0c <waitOnMsgUntilTimeout+0xc4>)
 800ab8c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ab8e:	6020      	str	r0, [r4, #0]
 800ab90:	6061      	str	r1, [r4, #4]
 800ab92:	60a2      	str	r2, [r4, #8]
 800ab94:	60e3      	str	r3, [r4, #12]
 800ab96:	cd07      	ldmia	r5!, {r0, r1, r2}
 800ab98:	6120      	str	r0, [r4, #16]
 800ab9a:	6161      	str	r1, [r4, #20]
 800ab9c:	61a2      	str	r2, [r4, #24]
 800ab9e:	882a      	ldrh	r2, [r5, #0]
 800aba0:	78ab      	ldrb	r3, [r5, #2]
 800aba2:	83a2      	strh	r2, [r4, #28]
 800aba4:	77a3      	strb	r3, [r4, #30]
 800aba6:	4620      	mov	r0, r4
 800aba8:	f014 fab3 	bl	801f112 <crs_strlen>
 800abac:	b283      	uxth	r3, r0
 800abae:	4622      	mov	r2, r4
 800abb0:	2102      	movs	r1, #2
 800abb2:	4608      	mov	r0, r1
 800abb4:	f014 faf0 	bl	801f198 <traceIF_itmPrint>
 800abb8:	4620      	mov	r0, r4
 800abba:	f014 faaa 	bl	801f112 <crs_strlen>
 800abbe:	b283      	uxth	r3, r0
 800abc0:	4622      	mov	r2, r4
 800abc2:	2102      	movs	r1, #2
 800abc4:	4608      	mov	r0, r1
 800abc6:	f014 fb09 	bl	801f1dc <traceIF_uartPrint>
}
 800abca:	4630      	mov	r0, r6
 800abcc:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_DBG("**** Sema Timeout (=%ld) !!! *****", Timeout)
 800abce:	462a      	mov	r2, r5
 800abd0:	490f      	ldr	r1, [pc, #60]	; (800ac10 <waitOnMsgUntilTimeout+0xc8>)
 800abd2:	4620      	mov	r0, r4
 800abd4:	f01b f84c 	bl	8025c70 <sprintf>
 800abd8:	4620      	mov	r0, r4
 800abda:	f014 fa9a 	bl	801f112 <crs_strlen>
 800abde:	b283      	uxth	r3, r0
 800abe0:	4622      	mov	r2, r4
 800abe2:	2102      	movs	r1, #2
 800abe4:	4608      	mov	r0, r1
 800abe6:	f014 fad7 	bl	801f198 <traceIF_itmPrint>
 800abea:	4620      	mov	r0, r4
 800abec:	f014 fa91 	bl	801f112 <crs_strlen>
 800abf0:	b283      	uxth	r3, r0
 800abf2:	4622      	mov	r2, r4
 800abf4:	2102      	movs	r1, #2
 800abf6:	4608      	mov	r0, r1
 800abf8:	f014 faf0 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_TIMEOUT;
 800abfc:	2602      	movs	r6, #2
 800abfe:	e7c3      	b.n	800ab88 <waitOnMsgUntilTimeout+0x40>
 800ac00:	200048dc 	.word	0x200048dc
 800ac04:	0802d0e0 	.word	0x0802d0e0
 800ac08:	20003544 	.word	0x20003544
 800ac0c:	0802d138 	.word	0x0802d138
 800ac10:	0802d10c 	.word	0x0802d10c

0800ac14 <waitFromIPC>:
{
 800ac14:	b570      	push	{r4, r5, r6, lr}
 800ac16:	4614      	mov	r4, r2
  retval = waitOnMsgUntilTimeout(athandle, tickstart, cmdTimeout);
 800ac18:	f7ff ff96 	bl	800ab48 <waitOnMsgUntilTimeout>
  if (retval != ATSTATUS_OK)
 800ac1c:	4605      	mov	r5, r0
 800ac1e:	b100      	cbz	r0, 800ac22 <waitFromIPC+0xe>
    if (cmdTimeout != 0U)
 800ac20:	b90c      	cbnz	r4, 800ac26 <waitFromIPC+0x12>
}
 800ac22:	4628      	mov	r0, r5
 800ac24:	bd70      	pop	{r4, r5, r6, pc}
      TRACE_INFO("TIMEOUT EVENT(%ld ms)", cmdTimeout)
 800ac26:	4e0c      	ldr	r6, [pc, #48]	; (800ac58 <waitFromIPC+0x44>)
 800ac28:	4622      	mov	r2, r4
 800ac2a:	490c      	ldr	r1, [pc, #48]	; (800ac5c <waitFromIPC+0x48>)
 800ac2c:	4630      	mov	r0, r6
 800ac2e:	f01b f81f 	bl	8025c70 <sprintf>
 800ac32:	4630      	mov	r0, r6
 800ac34:	f014 fa6d 	bl	801f112 <crs_strlen>
 800ac38:	b283      	uxth	r3, r0
 800ac3a:	4632      	mov	r2, r6
 800ac3c:	2101      	movs	r1, #1
 800ac3e:	2002      	movs	r0, #2
 800ac40:	f014 faaa 	bl	801f198 <traceIF_itmPrint>
 800ac44:	4630      	mov	r0, r6
 800ac46:	f014 fa64 	bl	801f112 <crs_strlen>
 800ac4a:	b283      	uxth	r3, r0
 800ac4c:	4632      	mov	r2, r6
 800ac4e:	2101      	movs	r1, #1
 800ac50:	2002      	movs	r0, #2
 800ac52:	f014 fac3 	bl	801f1dc <traceIF_uartPrint>
 800ac56:	e7e4      	b.n	800ac22 <waitFromIPC+0xe>
 800ac58:	200048dc 	.word	0x200048dc
 800ac5c:	0802d158 	.word	0x0802d158

0800ac60 <msgSentCallback>:
{
 800ac60:	b508      	push	{r3, lr}
  uint8_t index = find_index(ipcHandle);
 800ac62:	f7ff ff63 	bl	800ab2c <find_index>
  at_context[index].dataSent = AT_TRUE;
 800ac66:	4b06      	ldr	r3, [pc, #24]	; (800ac80 <msgSentCallback+0x20>)
 800ac68:	f240 629c 	movw	r2, #1692	; 0x69c
 800ac6c:	fb02 3000 	mla	r0, r2, r0, r3
 800ac70:	2301      	movs	r3, #1
 800ac72:	7303      	strb	r3, [r0, #12]
  (void) rtosalSemaphoreRelease(at_context[index].s_SendConfirm_SemaphoreId);
 800ac74:	f8d0 0698 	ldr.w	r0, [r0, #1688]	; 0x698
 800ac78:	f014 f957 	bl	801ef2a <rtosalSemaphoreRelease>
}
 800ac7c:	bd08      	pop	{r3, pc}
 800ac7e:	bf00      	nop
 800ac80:	2000188c 	.word	0x2000188c

0800ac84 <msgReceivedCallback>:
{
 800ac84:	b538      	push	{r3, r4, r5, lr}
  uint8_t index = find_index(ipcHandle);
 800ac86:	f7ff ff51 	bl	800ab2c <find_index>
  MsgReceived[index]++;
 800ac8a:	4a1b      	ldr	r2, [pc, #108]	; (800acf8 <msgReceivedCallback+0x74>)
 800ac8c:	5c13      	ldrb	r3, [r2, r0]
 800ac8e:	3301      	adds	r3, #1
 800ac90:	b2db      	uxtb	r3, r3
 800ac92:	5413      	strb	r3, [r2, r0]
  if (rtosalMessageQueuePut(q_msg_IPC_received_Id,
 800ac94:	2200      	movs	r2, #0
 800ac96:	2101      	movs	r1, #1
 800ac98:	4b18      	ldr	r3, [pc, #96]	; (800acfc <msgReceivedCallback+0x78>)
 800ac9a:	6818      	ldr	r0, [r3, #0]
 800ac9c:	f014 f967 	bl	801ef6e <rtosalMessageQueuePut>
 800aca0:	b900      	cbnz	r0, 800aca4 <msgReceivedCallback+0x20>
}
 800aca2:	bd38      	pop	{r3, r4, r5, pc}
    TRACE_ERR("q_msg_IPC_received_Id error for SIG_IPC_MSG")
 800aca4:	4d16      	ldr	r5, [pc, #88]	; (800ad00 <msgReceivedCallback+0x7c>)
 800aca6:	4c17      	ldr	r4, [pc, #92]	; (800ad04 <msgReceivedCallback+0x80>)
 800aca8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 800acac:	46ac      	mov	ip, r5
 800acae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800acb2:	6020      	str	r0, [r4, #0]
 800acb4:	6061      	str	r1, [r4, #4]
 800acb6:	60a2      	str	r2, [r4, #8]
 800acb8:	60e3      	str	r3, [r4, #12]
 800acba:	4665      	mov	r5, ip
 800acbc:	3410      	adds	r4, #16
 800acbe:	45f4      	cmp	ip, lr
 800acc0:	d1f4      	bne.n	800acac <msgReceivedCallback+0x28>
 800acc2:	cd03      	ldmia	r5!, {r0, r1}
 800acc4:	6020      	str	r0, [r4, #0]
 800acc6:	6061      	str	r1, [r4, #4]
 800acc8:	882a      	ldrh	r2, [r5, #0]
 800acca:	78ab      	ldrb	r3, [r5, #2]
 800accc:	8122      	strh	r2, [r4, #8]
 800acce:	72a3      	strb	r3, [r4, #10]
 800acd0:	4c0c      	ldr	r4, [pc, #48]	; (800ad04 <msgReceivedCallback+0x80>)
 800acd2:	4620      	mov	r0, r4
 800acd4:	f014 fa1d 	bl	801f112 <crs_strlen>
 800acd8:	b283      	uxth	r3, r0
 800acda:	4622      	mov	r2, r4
 800acdc:	2110      	movs	r1, #16
 800acde:	2002      	movs	r0, #2
 800ace0:	f014 fa5a 	bl	801f198 <traceIF_itmPrint>
 800ace4:	4620      	mov	r0, r4
 800ace6:	f014 fa14 	bl	801f112 <crs_strlen>
 800acea:	b283      	uxth	r3, r0
 800acec:	4622      	mov	r2, r4
 800acee:	2110      	movs	r1, #16
 800acf0:	2002      	movs	r0, #2
 800acf2:	f014 fa73 	bl	801f1dc <traceIF_uartPrint>
}
 800acf6:	e7d4      	b.n	800aca2 <msgReceivedCallback+0x1e>
 800acf8:	20001888 	.word	0x20001888
 800acfc:	2000353c 	.word	0x2000353c
 800ad00:	0802d178 	.word	0x0802d178
 800ad04:	200048dc 	.word	0x200048dc

0800ad08 <sendToIPC>:
{
 800ad08:	b570      	push	{r4, r5, r6, lr}
 800ad0a:	4605      	mov	r5, r0
  if (IPC_send(at_context[athandle].ipc_handle, cmdBuf, cmdSize) == IPC_ERROR)
 800ad0c:	4b21      	ldr	r3, [pc, #132]	; (800ad94 <sendToIPC+0x8c>)
 800ad0e:	f240 609c 	movw	r0, #1692	; 0x69c
 800ad12:	fb00 3305 	mla	r3, r0, r5, r3
 800ad16:	6858      	ldr	r0, [r3, #4]
 800ad18:	f013 fb2c 	bl	801e374 <IPC_send>
 800ad1c:	2801      	cmp	r0, #1
 800ad1e:	d00e      	beq.n	800ad3e <sendToIPC+0x36>
    (void) rtosalSemaphoreAcquire(at_context[athandle].s_SendConfirm_SemaphoreId, 5000U);
 800ad20:	4c1c      	ldr	r4, [pc, #112]	; (800ad94 <sendToIPC+0x8c>)
 800ad22:	f240 639c 	movw	r3, #1692	; 0x69c
 800ad26:	fb03 4405 	mla	r4, r3, r5, r4
 800ad2a:	f241 3188 	movw	r1, #5000	; 0x1388
 800ad2e:	f8d4 0698 	ldr.w	r0, [r4, #1688]	; 0x698
 800ad32:	f014 f8f6 	bl	801ef22 <rtosalSemaphoreAcquire>
    if (at_context[athandle].dataSent == AT_TRUE)
 800ad36:	7b23      	ldrb	r3, [r4, #12]
 800ad38:	b353      	cbz	r3, 800ad90 <sendToIPC+0x88>
      retval = ATSTATUS_OK;
 800ad3a:	2400      	movs	r4, #0
 800ad3c:	e026      	b.n	800ad8c <sendToIPC+0x84>
 800ad3e:	4604      	mov	r4, r0
    TRACE_ERR(" IPC send error")
 800ad40:	4d15      	ldr	r5, [pc, #84]	; (800ad98 <sendToIPC+0x90>)
 800ad42:	4e16      	ldr	r6, [pc, #88]	; (800ad9c <sendToIPC+0x94>)
 800ad44:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800ad46:	6028      	str	r0, [r5, #0]
 800ad48:	6069      	str	r1, [r5, #4]
 800ad4a:	60aa      	str	r2, [r5, #8]
 800ad4c:	60eb      	str	r3, [r5, #12]
 800ad4e:	ce07      	ldmia	r6!, {r0, r1, r2}
 800ad50:	6128      	str	r0, [r5, #16]
 800ad52:	6169      	str	r1, [r5, #20]
 800ad54:	61aa      	str	r2, [r5, #24]
 800ad56:	8832      	ldrh	r2, [r6, #0]
 800ad58:	78b3      	ldrb	r3, [r6, #2]
 800ad5a:	83aa      	strh	r2, [r5, #28]
 800ad5c:	77ab      	strb	r3, [r5, #30]
 800ad5e:	4628      	mov	r0, r5
 800ad60:	f014 f9d7 	bl	801f112 <crs_strlen>
 800ad64:	b283      	uxth	r3, r0
 800ad66:	462a      	mov	r2, r5
 800ad68:	2110      	movs	r1, #16
 800ad6a:	2002      	movs	r0, #2
 800ad6c:	f014 fa14 	bl	801f198 <traceIF_itmPrint>
 800ad70:	4628      	mov	r0, r5
 800ad72:	f014 f9ce 	bl	801f112 <crs_strlen>
 800ad76:	b283      	uxth	r3, r0
 800ad78:	462a      	mov	r2, r5
 800ad7a:	2110      	movs	r1, #16
 800ad7c:	2002      	movs	r0, #2
 800ad7e:	f014 fa2d 	bl	801f1dc <traceIF_uartPrint>
    LOG_ERROR(15, ERROR_WARNING);
 800ad82:	2202      	movs	r2, #2
 800ad84:	210f      	movs	r1, #15
 800ad86:	4610      	mov	r0, r2
 800ad88:	f013 f9e0 	bl	801e14c <ERROR_Handler>
}
 800ad8c:	4620      	mov	r0, r4
 800ad8e:	bd70      	pop	{r4, r5, r6, pc}
      retval = ATSTATUS_ERROR;
 800ad90:	2401      	movs	r4, #1
 800ad92:	e7fb      	b.n	800ad8c <sendToIPC+0x84>
 800ad94:	2000188c 	.word	0x2000188c
 800ad98:	200048dc 	.word	0x200048dc
 800ad9c:	0802d1b4 	.word	0x0802d1b4

0800ada0 <process_answer>:
{
 800ada0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ada4:	4604      	mov	r4, r0
 800ada6:	460f      	mov	r7, r1
 800ada8:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
 800adaa:	f7fc f8f5 	bl	8006f98 <HAL_GetTick>
 800adae:	4605      	mov	r5, r0
    waitIPCstatus = waitFromIPC(athandle, tickstart, at_cmd_timeout, &msgFromIPC[athandle]);
 800adb0:	4b61      	ldr	r3, [pc, #388]	; (800af38 <process_answer+0x198>)
 800adb2:	f240 72d2 	movw	r2, #2002	; 0x7d2
 800adb6:	fb02 3304 	mla	r3, r2, r4, r3
 800adba:	4632      	mov	r2, r6
 800adbc:	4629      	mov	r1, r5
 800adbe:	4620      	mov	r0, r4
 800adc0:	f7ff ff28 	bl	800ac14 <waitFromIPC>
    if (waitIPCstatus != ATSTATUS_OK)
 800adc4:	b9b8      	cbnz	r0, 800adf6 <process_answer+0x56>
      if ((at_context[athandle].action_flags & ATACTION_RSP_FRC_END) != 0U)
 800adc6:	4b5d      	ldr	r3, [pc, #372]	; (800af3c <process_answer+0x19c>)
 800adc8:	f240 629c 	movw	r2, #1692	; 0x69c
 800adcc:	fb02 3304 	mla	r3, r2, r4, r3
 800add0:	f8b3 3690 	ldrh.w	r3, [r3, #1680]	; 0x690
 800add4:	f013 0f01 	tst.w	r3, #1
 800add8:	d060      	beq.n	800ae9c <process_answer+0xfc>
        at_context[athandle].action_flags &= ~((at_action_rsp_t) ATACTION_RSP_FRC_END);
 800adda:	4a58      	ldr	r2, [pc, #352]	; (800af3c <process_answer+0x19c>)
 800addc:	f240 619c 	movw	r1, #1692	; 0x69c
 800ade0:	fb01 2204 	mla	r2, r1, r4, r2
 800ade4:	f023 0301 	bic.w	r3, r3, #1
 800ade8:	f8a2 3690 	strh.w	r3, [r2, #1680]	; 0x690
        action_rsp = ATACTION_RSP_FRC_END;
 800adec:	2001      	movs	r0, #1
  } while ((action_rsp == ATACTION_RSP_INTERMEDIATE) ||
 800adee:	2810      	cmp	r0, #16
 800adf0:	d0de      	beq.n	800adb0 <process_answer+0x10>
}
 800adf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      (void) IPC_abort(at_context[athandle].ipc_handle);
 800adf6:	4b51      	ldr	r3, [pc, #324]	; (800af3c <process_answer+0x19c>)
 800adf8:	f240 629c 	movw	r2, #1692	; 0x69c
 800adfc:	fb02 3304 	mla	r3, r2, r4, r3
 800ae00:	6858      	ldr	r0, [r3, #4]
 800ae02:	f013 faa5 	bl	801e350 <IPC_abort>
      if ((action_send & ATACTION_SEND_WAIT_MANDATORY_RSP) != 0U)
 800ae06:	f017 0f01 	tst.w	r7, #1
 800ae0a:	d104      	bne.n	800ae16 <process_answer+0x76>
        if ((action_send & ATACTION_SEND_FLAG_LAST_CMD) != 0U)
 800ae0c:	f417 4f00 	tst.w	r7, #32768	; 0x8000
 800ae10:	d042      	beq.n	800ae98 <process_answer+0xf8>
          action_rsp = ATACTION_RSP_FRC_END;
 800ae12:	2001      	movs	r0, #1
 800ae14:	e7eb      	b.n	800adee <process_answer+0x4e>
        TRACE_ERR("AT_sendcmd error: wait from ipc")
 800ae16:	f8df e128 	ldr.w	lr, [pc, #296]	; 800af40 <process_answer+0x1a0>
 800ae1a:	f8df c128 	ldr.w	ip, [pc, #296]	; 800af44 <process_answer+0x1a4>
 800ae1e:	f10e 0920 	add.w	r9, lr, #32
 800ae22:	46f0      	mov	r8, lr
 800ae24:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 800ae28:	f8cc 0000 	str.w	r0, [ip]
 800ae2c:	f8cc 1004 	str.w	r1, [ip, #4]
 800ae30:	f8cc 2008 	str.w	r2, [ip, #8]
 800ae34:	f8cc 300c 	str.w	r3, [ip, #12]
 800ae38:	46c6      	mov	lr, r8
 800ae3a:	f10c 0c10 	add.w	ip, ip, #16
 800ae3e:	45c8      	cmp	r8, r9
 800ae40:	d1ef      	bne.n	800ae22 <process_answer+0x82>
 800ae42:	e8be 0007 	ldmia.w	lr!, {r0, r1, r2}
 800ae46:	f8cc 0000 	str.w	r0, [ip]
 800ae4a:	f8cc 1004 	str.w	r1, [ip, #4]
 800ae4e:	f8cc 2008 	str.w	r2, [ip, #8]
 800ae52:	f8be 2000 	ldrh.w	r2, [lr]
 800ae56:	f89e 3002 	ldrb.w	r3, [lr, #2]
 800ae5a:	f8ac 200c 	strh.w	r2, [ip, #12]
 800ae5e:	f88c 300e 	strb.w	r3, [ip, #14]
 800ae62:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 800af44 <process_answer+0x1a4>
 800ae66:	4640      	mov	r0, r8
 800ae68:	f014 f953 	bl	801f112 <crs_strlen>
 800ae6c:	b283      	uxth	r3, r0
 800ae6e:	4642      	mov	r2, r8
 800ae70:	2110      	movs	r1, #16
 800ae72:	2002      	movs	r0, #2
 800ae74:	f014 f990 	bl	801f198 <traceIF_itmPrint>
 800ae78:	4640      	mov	r0, r8
 800ae7a:	f014 f94a 	bl	801f112 <crs_strlen>
 800ae7e:	b283      	uxth	r3, r0
 800ae80:	4642      	mov	r2, r8
 800ae82:	2110      	movs	r1, #16
 800ae84:	2002      	movs	r0, #2
 800ae86:	f014 f9a9 	bl	801f1dc <traceIF_uartPrint>
        LOG_ERROR(10, ERROR_WARNING);
 800ae8a:	2202      	movs	r2, #2
 800ae8c:	210a      	movs	r1, #10
 800ae8e:	4610      	mov	r0, r2
 800ae90:	f013 f95c 	bl	801e14c <ERROR_Handler>
        action_rsp = ATACTION_RSP_ERROR;
 800ae94:	2004      	movs	r0, #4
 800ae96:	e7aa      	b.n	800adee <process_answer+0x4e>
          action_rsp = ATACTION_RSP_FRC_CONTINUE;
 800ae98:	2002      	movs	r0, #2
 800ae9a:	e7a8      	b.n	800adee <process_answer+0x4e>
      else if ((at_context[athandle].action_flags & ATACTION_RSP_FRC_CONTINUE) != 0U)
 800ae9c:	f013 0f02 	tst.w	r3, #2
 800aea0:	d104      	bne.n	800aeac <process_answer+0x10c>
      else if ((at_context[athandle].action_flags & ATACTION_RSP_ERROR) != 0U)
 800aea2:	f013 0f04 	tst.w	r3, #4
 800aea6:	d10c      	bne.n	800aec2 <process_answer+0x122>
        action_rsp = ATACTION_RSP_IGNORED;
 800aea8:	2010      	movs	r0, #16
 800aeaa:	e7a0      	b.n	800adee <process_answer+0x4e>
        at_context[athandle].action_flags &= ~((at_action_rsp_t) ATACTION_RSP_FRC_CONTINUE);
 800aeac:	4a23      	ldr	r2, [pc, #140]	; (800af3c <process_answer+0x19c>)
 800aeae:	f240 619c 	movw	r1, #1692	; 0x69c
 800aeb2:	fb01 2204 	mla	r2, r1, r4, r2
 800aeb6:	f023 0302 	bic.w	r3, r3, #2
 800aeba:	f8a2 3690 	strh.w	r3, [r2, #1680]	; 0x690
        action_rsp = ATACTION_RSP_FRC_CONTINUE;
 800aebe:	2002      	movs	r0, #2
 800aec0:	e795      	b.n	800adee <process_answer+0x4e>
        at_context[athandle].action_flags &= ~((at_action_rsp_t) ATACTION_RSP_ERROR);
 800aec2:	4a1e      	ldr	r2, [pc, #120]	; (800af3c <process_answer+0x19c>)
 800aec4:	f240 619c 	movw	r1, #1692	; 0x69c
 800aec8:	fb01 2204 	mla	r2, r1, r4, r2
 800aecc:	f023 0304 	bic.w	r3, r3, #4
 800aed0:	f8a2 3690 	strh.w	r3, [r2, #1680]	; 0x690
        TRACE_ERR("AT_sendcmd error: parse from rsp")
 800aed4:	f8df 8070 	ldr.w	r8, [pc, #112]	; 800af48 <process_answer+0x1a8>
 800aed8:	f8df e068 	ldr.w	lr, [pc, #104]	; 800af44 <process_answer+0x1a4>
 800aedc:	f108 0930 	add.w	r9, r8, #48	; 0x30
 800aee0:	46c4      	mov	ip, r8
 800aee2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800aee6:	f8ce 0000 	str.w	r0, [lr]
 800aeea:	f8ce 1004 	str.w	r1, [lr, #4]
 800aeee:	f8ce 2008 	str.w	r2, [lr, #8]
 800aef2:	f8ce 300c 	str.w	r3, [lr, #12]
 800aef6:	46e0      	mov	r8, ip
 800aef8:	f10e 0e10 	add.w	lr, lr, #16
 800aefc:	45cc      	cmp	ip, r9
 800aefe:	d1ef      	bne.n	800aee0 <process_answer+0x140>
 800af00:	f8df 8040 	ldr.w	r8, [pc, #64]	; 800af44 <process_answer+0x1a4>
 800af04:	4640      	mov	r0, r8
 800af06:	f014 f904 	bl	801f112 <crs_strlen>
 800af0a:	b283      	uxth	r3, r0
 800af0c:	4642      	mov	r2, r8
 800af0e:	2110      	movs	r1, #16
 800af10:	2002      	movs	r0, #2
 800af12:	f014 f941 	bl	801f198 <traceIF_itmPrint>
 800af16:	4640      	mov	r0, r8
 800af18:	f014 f8fb 	bl	801f112 <crs_strlen>
 800af1c:	b283      	uxth	r3, r0
 800af1e:	4642      	mov	r2, r8
 800af20:	2110      	movs	r1, #16
 800af22:	2002      	movs	r0, #2
 800af24:	f014 f95a 	bl	801f1dc <traceIF_uartPrint>
        LOG_ERROR(11, ERROR_WARNING);
 800af28:	2202      	movs	r2, #2
 800af2a:	210b      	movs	r1, #11
 800af2c:	4610      	mov	r0, r2
 800af2e:	f013 f90d 	bl	801e14c <ERROR_Handler>
        action_rsp = ATACTION_RSP_ERROR;
 800af32:	2004      	movs	r0, #4
 800af34:	e75b      	b.n	800adee <process_answer+0x4e>
 800af36:	bf00      	nop
 800af38:	20002d68 	.word	0x20002d68
 800af3c:	2000188c 	.word	0x2000188c
 800af40:	0802d1d4 	.word	0x0802d1d4
 800af44:	200048dc 	.word	0x200048dc
 800af48:	0802d204 	.word	0x0802d204

0800af4c <process_AT_transaction>:
{
 800af4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800af50:	b085      	sub	sp, #20
 800af52:	4606      	mov	r6, r0
 800af54:	4688      	mov	r8, r1
  uint32_t at_cmd_timeout = 0U;
 800af56:	2400      	movs	r4, #0
 800af58:	9403      	str	r4, [sp, #12]
  (void) memset((void *) build_atcmd, 0, ATCMD_MAX_CMD_SIZE);
 800af5a:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 800af5e:	4621      	mov	r1, r4
 800af60:	489d      	ldr	r0, [pc, #628]	; (800b1d8 <process_AT_transaction+0x28c>)
 800af62:	f01a fef8 	bl	8025d56 <memset>
  at_action_rsp_t action_rsp = ATACTION_RSP_NO_ACTION;
 800af66:	4627      	mov	r7, r4
  at_status_t retval = ATSTATUS_OK;
 800af68:	46a1      	mov	r9, r4
 800af6a:	e035      	b.n	800afd8 <process_AT_transaction+0x8c>
      TRACE_DBG("AT_sendcmd error: get at command")
 800af6c:	4d9b      	ldr	r5, [pc, #620]	; (800b1dc <process_AT_transaction+0x290>)
 800af6e:	4c9c      	ldr	r4, [pc, #624]	; (800b1e0 <process_AT_transaction+0x294>)
 800af70:	f105 0e20 	add.w	lr, r5, #32
 800af74:	46ac      	mov	ip, r5
 800af76:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800af7a:	6020      	str	r0, [r4, #0]
 800af7c:	6061      	str	r1, [r4, #4]
 800af7e:	60a2      	str	r2, [r4, #8]
 800af80:	60e3      	str	r3, [r4, #12]
 800af82:	4665      	mov	r5, ip
 800af84:	3410      	adds	r4, #16
 800af86:	45f4      	cmp	ip, lr
 800af88:	d1f4      	bne.n	800af74 <process_AT_transaction+0x28>
 800af8a:	cd03      	ldmia	r5!, {r0, r1}
 800af8c:	6020      	str	r0, [r4, #0]
 800af8e:	6061      	str	r1, [r4, #4]
 800af90:	882b      	ldrh	r3, [r5, #0]
 800af92:	8123      	strh	r3, [r4, #8]
 800af94:	4c92      	ldr	r4, [pc, #584]	; (800b1e0 <process_AT_transaction+0x294>)
 800af96:	4620      	mov	r0, r4
 800af98:	f014 f8bb 	bl	801f112 <crs_strlen>
 800af9c:	b283      	uxth	r3, r0
 800af9e:	4622      	mov	r2, r4
 800afa0:	2102      	movs	r1, #2
 800afa2:	4608      	mov	r0, r1
 800afa4:	f014 f8f8 	bl	801f198 <traceIF_itmPrint>
 800afa8:	4620      	mov	r0, r4
 800afaa:	f014 f8b2 	bl	801f112 <crs_strlen>
 800afae:	b283      	uxth	r3, r0
 800afb0:	4622      	mov	r2, r4
 800afb2:	2102      	movs	r1, #2
 800afb4:	4608      	mov	r0, r1
 800afb6:	f014 f911 	bl	801f1dc <traceIF_uartPrint>
      LOG_ERROR(7, ERROR_WARNING);
 800afba:	2202      	movs	r2, #2
 800afbc:	2107      	movs	r1, #7
 800afbe:	4610      	mov	r0, r2
 800afc0:	f013 f8c4 	bl	801e14c <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800afc4:	2300      	movs	r3, #0
      retval = ATSTATUS_ERROR;
 800afc6:	f04f 0901 	mov.w	r9, #1
    if (retval == ATSTATUS_ERROR)
 800afca:	f1b9 0f01 	cmp.w	r9, #1
 800afce:	f000 80d5 	beq.w	800b17c <process_AT_transaction+0x230>
  } while (another_cmd_to_send == 1U);
 800afd2:	2b00      	cmp	r3, #0
 800afd4:	f000 80d2 	beq.w	800b17c <process_AT_transaction+0x230>
    (void) memset((void *)&build_atcmd[0], 0, sizeof(AT_CHAR_t) * ATCMD_MAX_CMD_SIZE);
 800afd8:	4c7f      	ldr	r4, [pc, #508]	; (800b1d8 <process_AT_transaction+0x28c>)
 800afda:	f44f 65c8 	mov.w	r5, #1600	; 0x640
 800afde:	462a      	mov	r2, r5
 800afe0:	2100      	movs	r1, #0
 800afe2:	4620      	mov	r0, r4
 800afe4:	f01a feb7 	bl	8025d56 <memset>
    build_atcmd_size = 0U;
 800afe8:	2300      	movs	r3, #0
 800afea:	f8ad 300a 	strh.w	r3, [sp, #10]
    action_send = ATParser_get_ATcmd(&at_context[athandle],
 800afee:	ab03      	add	r3, sp, #12
 800aff0:	9300      	str	r3, [sp, #0]
 800aff2:	f10d 030a 	add.w	r3, sp, #10
 800aff6:	462a      	mov	r2, r5
 800aff8:	4621      	mov	r1, r4
 800affa:	487a      	ldr	r0, [pc, #488]	; (800b1e4 <process_AT_transaction+0x298>)
 800affc:	f240 649c 	movw	r4, #1692	; 0x69c
 800b000:	fb04 0006 	mla	r0, r4, r6, r0
 800b004:	f009 fc9c 	bl	8014940 <ATParser_get_ATcmd>
 800b008:	4604      	mov	r4, r0
    if ((action_send & ATACTION_SEND_ERROR) != 0U)
 800b00a:	f010 0f04 	tst.w	r0, #4
 800b00e:	d1ad      	bne.n	800af6c <process_AT_transaction+0x20>
      if (build_atcmd_size > 0U)
 800b010:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 800b014:	b182      	cbz	r2, 800b038 <process_AT_transaction+0xec>
        if ((at_context[athandle].in_data_mode == AT_TRUE) && (msg_in_id != (at_msg_t) SID_CS_DATA_SUSPEND))
 800b016:	4b73      	ldr	r3, [pc, #460]	; (800b1e4 <process_AT_transaction+0x298>)
 800b018:	f240 619c 	movw	r1, #1692	; 0x69c
 800b01c:	fb01 3306 	mla	r3, r1, r6, r3
 800b020:	7a9b      	ldrb	r3, [r3, #10]
 800b022:	b113      	cbz	r3, 800b02a <process_AT_transaction+0xde>
 800b024:	f1b8 0f7e 	cmp.w	r8, #126	; 0x7e
 800b028:	d117      	bne.n	800b05a <process_AT_transaction+0x10e>
          retval = sendToIPC(athandle, (uint8_t *)&build_atcmd[0], build_atcmd_size);
 800b02a:	496b      	ldr	r1, [pc, #428]	; (800b1d8 <process_AT_transaction+0x28c>)
 800b02c:	4630      	mov	r0, r6
 800b02e:	f7ff fe6b 	bl	800ad08 <sendToIPC>
          if (retval != ATSTATUS_OK)
 800b032:	4681      	mov	r9, r0
 800b034:	2800      	cmp	r0, #0
 800b036:	d13d      	bne.n	800b0b4 <process_AT_transaction+0x168>
      if (retval != ATSTATUS_ERROR)
 800b038:	f1b9 0f01 	cmp.w	r9, #1
 800b03c:	f000 809c 	beq.w	800b178 <process_AT_transaction+0x22c>
        if (((action_send & ATACTION_SEND_WAIT_MANDATORY_RSP) != 0U) ||
 800b040:	f014 0f03 	tst.w	r4, #3
 800b044:	d069      	beq.n	800b11a <process_AT_transaction+0x1ce>
          action_rsp = process_answer(athandle, action_send, at_cmd_timeout);
 800b046:	9a03      	ldr	r2, [sp, #12]
 800b048:	4621      	mov	r1, r4
 800b04a:	4630      	mov	r0, r6
 800b04c:	f7ff fea8 	bl	800ada0 <process_answer>
 800b050:	4607      	mov	r7, r0
          if (action_rsp == ATACTION_RSP_FRC_CONTINUE)
 800b052:	2802      	cmp	r0, #2
 800b054:	d15f      	bne.n	800b116 <process_AT_transaction+0x1ca>
            another_cmd_to_send = 1U;
 800b056:	2301      	movs	r3, #1
 800b058:	e7b7      	b.n	800afca <process_AT_transaction+0x7e>
          TRACE_ERR("DATA ongoing, can not send a command")
 800b05a:	f8df c194 	ldr.w	ip, [pc, #404]	; 800b1f0 <process_AT_transaction+0x2a4>
 800b05e:	4d60      	ldr	r5, [pc, #384]	; (800b1e0 <process_AT_transaction+0x294>)
 800b060:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 800b064:	4664      	mov	r4, ip
 800b066:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b068:	6028      	str	r0, [r5, #0]
 800b06a:	6069      	str	r1, [r5, #4]
 800b06c:	60aa      	str	r2, [r5, #8]
 800b06e:	60eb      	str	r3, [r5, #12]
 800b070:	46a4      	mov	ip, r4
 800b072:	3510      	adds	r5, #16
 800b074:	4574      	cmp	r4, lr
 800b076:	d1f5      	bne.n	800b064 <process_AT_transaction+0x118>
 800b078:	6820      	ldr	r0, [r4, #0]
 800b07a:	6028      	str	r0, [r5, #0]
 800b07c:	4c58      	ldr	r4, [pc, #352]	; (800b1e0 <process_AT_transaction+0x294>)
 800b07e:	4620      	mov	r0, r4
 800b080:	f014 f847 	bl	801f112 <crs_strlen>
 800b084:	b283      	uxth	r3, r0
 800b086:	4622      	mov	r2, r4
 800b088:	2110      	movs	r1, #16
 800b08a:	2002      	movs	r0, #2
 800b08c:	f014 f884 	bl	801f198 <traceIF_itmPrint>
 800b090:	4620      	mov	r0, r4
 800b092:	f014 f83e 	bl	801f112 <crs_strlen>
 800b096:	b283      	uxth	r3, r0
 800b098:	4622      	mov	r2, r4
 800b09a:	2110      	movs	r1, #16
 800b09c:	2002      	movs	r0, #2
 800b09e:	f014 f89d 	bl	801f1dc <traceIF_uartPrint>
          LOG_ERROR(8, ERROR_WARNING);
 800b0a2:	2202      	movs	r2, #2
 800b0a4:	2108      	movs	r1, #8
 800b0a6:	4610      	mov	r0, r2
 800b0a8:	f013 f850 	bl	801e14c <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b0ac:	2300      	movs	r3, #0
          retval = ATSTATUS_ERROR;
 800b0ae:	f04f 0901 	mov.w	r9, #1
 800b0b2:	e78a      	b.n	800afca <process_AT_transaction+0x7e>
            TRACE_ERR("AT_sendcmd error: send to ipc")
 800b0b4:	4d4c      	ldr	r5, [pc, #304]	; (800b1e8 <process_AT_transaction+0x29c>)
 800b0b6:	4c4a      	ldr	r4, [pc, #296]	; (800b1e0 <process_AT_transaction+0x294>)
 800b0b8:	f105 0e20 	add.w	lr, r5, #32
 800b0bc:	46ac      	mov	ip, r5
 800b0be:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b0c2:	6020      	str	r0, [r4, #0]
 800b0c4:	6061      	str	r1, [r4, #4]
 800b0c6:	60a2      	str	r2, [r4, #8]
 800b0c8:	60e3      	str	r3, [r4, #12]
 800b0ca:	4665      	mov	r5, ip
 800b0cc:	3410      	adds	r4, #16
 800b0ce:	45f4      	cmp	ip, lr
 800b0d0:	d1f4      	bne.n	800b0bc <process_AT_transaction+0x170>
 800b0d2:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b0d4:	6020      	str	r0, [r4, #0]
 800b0d6:	6061      	str	r1, [r4, #4]
 800b0d8:	60a2      	str	r2, [r4, #8]
 800b0da:	782b      	ldrb	r3, [r5, #0]
 800b0dc:	7323      	strb	r3, [r4, #12]
 800b0de:	4c40      	ldr	r4, [pc, #256]	; (800b1e0 <process_AT_transaction+0x294>)
 800b0e0:	4620      	mov	r0, r4
 800b0e2:	f014 f816 	bl	801f112 <crs_strlen>
 800b0e6:	b283      	uxth	r3, r0
 800b0e8:	4622      	mov	r2, r4
 800b0ea:	2110      	movs	r1, #16
 800b0ec:	2002      	movs	r0, #2
 800b0ee:	f014 f853 	bl	801f198 <traceIF_itmPrint>
 800b0f2:	4620      	mov	r0, r4
 800b0f4:	f014 f80d 	bl	801f112 <crs_strlen>
 800b0f8:	b283      	uxth	r3, r0
 800b0fa:	4622      	mov	r2, r4
 800b0fc:	2110      	movs	r1, #16
 800b0fe:	2002      	movs	r0, #2
 800b100:	f014 f86c 	bl	801f1dc <traceIF_uartPrint>
            LOG_ERROR(9, ERROR_WARNING);
 800b104:	2202      	movs	r2, #2
 800b106:	2109      	movs	r1, #9
 800b108:	4610      	mov	r0, r2
 800b10a:	f013 f81f 	bl	801e14c <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b10e:	2300      	movs	r3, #0
            retval = ATSTATUS_ERROR;
 800b110:	f04f 0901 	mov.w	r9, #1
 800b114:	e759      	b.n	800afca <process_AT_transaction+0x7e>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b116:	2300      	movs	r3, #0
 800b118:	e757      	b.n	800afca <process_AT_transaction+0x7e>
          TRACE_ERR("Invalid action code")
 800b11a:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 800b1f4 <process_AT_transaction+0x2a8>
 800b11e:	4c30      	ldr	r4, [pc, #192]	; (800b1e0 <process_AT_transaction+0x294>)
 800b120:	f10c 0e20 	add.w	lr, ip, #32
 800b124:	4665      	mov	r5, ip
 800b126:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b128:	6020      	str	r0, [r4, #0]
 800b12a:	6061      	str	r1, [r4, #4]
 800b12c:	60a2      	str	r2, [r4, #8]
 800b12e:	60e3      	str	r3, [r4, #12]
 800b130:	46ac      	mov	ip, r5
 800b132:	3410      	adds	r4, #16
 800b134:	4575      	cmp	r5, lr
 800b136:	d1f5      	bne.n	800b124 <process_AT_transaction+0x1d8>
 800b138:	882a      	ldrh	r2, [r5, #0]
 800b13a:	78ab      	ldrb	r3, [r5, #2]
 800b13c:	8022      	strh	r2, [r4, #0]
 800b13e:	70a3      	strb	r3, [r4, #2]
 800b140:	4c27      	ldr	r4, [pc, #156]	; (800b1e0 <process_AT_transaction+0x294>)
 800b142:	4620      	mov	r0, r4
 800b144:	f013 ffe5 	bl	801f112 <crs_strlen>
 800b148:	b283      	uxth	r3, r0
 800b14a:	4622      	mov	r2, r4
 800b14c:	2110      	movs	r1, #16
 800b14e:	2002      	movs	r0, #2
 800b150:	f014 f822 	bl	801f198 <traceIF_itmPrint>
 800b154:	4620      	mov	r0, r4
 800b156:	f013 ffdc 	bl	801f112 <crs_strlen>
 800b15a:	b283      	uxth	r3, r0
 800b15c:	4622      	mov	r2, r4
 800b15e:	2110      	movs	r1, #16
 800b160:	2002      	movs	r0, #2
 800b162:	f014 f83b 	bl	801f1dc <traceIF_uartPrint>
          LOG_ERROR(13, ERROR_WARNING);
 800b166:	2202      	movs	r2, #2
 800b168:	210d      	movs	r1, #13
 800b16a:	4610      	mov	r0, r2
 800b16c:	f012 ffee 	bl	801e14c <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b170:	2300      	movs	r3, #0
          retval = ATSTATUS_ERROR;
 800b172:	f04f 0901 	mov.w	r9, #1
 800b176:	e728      	b.n	800afca <process_AT_transaction+0x7e>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b178:	2300      	movs	r3, #0
 800b17a:	e726      	b.n	800afca <process_AT_transaction+0x7e>
  at_context[athandle].action_flags = ATACTION_RSP_NO_ACTION;
 800b17c:	4b19      	ldr	r3, [pc, #100]	; (800b1e4 <process_AT_transaction+0x298>)
 800b17e:	f240 629c 	movw	r2, #1692	; 0x69c
 800b182:	fb02 3306 	mla	r3, r2, r6, r3
 800b186:	2200      	movs	r2, #0
 800b188:	f8a3 2690 	strh.w	r2, [r3, #1680]	; 0x690
  TRACE_DBG("action_rsp value = %d", action_rsp)
 800b18c:	4c14      	ldr	r4, [pc, #80]	; (800b1e0 <process_AT_transaction+0x294>)
 800b18e:	463a      	mov	r2, r7
 800b190:	4916      	ldr	r1, [pc, #88]	; (800b1ec <process_AT_transaction+0x2a0>)
 800b192:	4620      	mov	r0, r4
 800b194:	f01a fd6c 	bl	8025c70 <sprintf>
 800b198:	4620      	mov	r0, r4
 800b19a:	f013 ffba 	bl	801f112 <crs_strlen>
 800b19e:	b283      	uxth	r3, r0
 800b1a0:	4622      	mov	r2, r4
 800b1a2:	2102      	movs	r1, #2
 800b1a4:	4608      	mov	r0, r1
 800b1a6:	f013 fff7 	bl	801f198 <traceIF_itmPrint>
 800b1aa:	4620      	mov	r0, r4
 800b1ac:	f013 ffb1 	bl	801f112 <crs_strlen>
 800b1b0:	b283      	uxth	r3, r0
 800b1b2:	4622      	mov	r2, r4
 800b1b4:	2102      	movs	r1, #2
 800b1b6:	4608      	mov	r0, r1
 800b1b8:	f014 f810 	bl	801f1dc <traceIF_uartPrint>
  if (action_rsp == ATACTION_RSP_ERROR)
 800b1bc:	2f04      	cmp	r7, #4
 800b1be:	d003      	beq.n	800b1c8 <process_AT_transaction+0x27c>
}
 800b1c0:	4648      	mov	r0, r9
 800b1c2:	b005      	add	sp, #20
 800b1c4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    LOG_ERROR(14, ERROR_WARNING);
 800b1c8:	2202      	movs	r2, #2
 800b1ca:	210e      	movs	r1, #14
 800b1cc:	4610      	mov	r0, r2
 800b1ce:	f012 ffbd 	bl	801e14c <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800b1d2:	f04f 0901 	mov.w	r9, #1
 800b1d6:	e7f3      	b.n	800b1c0 <process_AT_transaction+0x274>
 800b1d8:	20001f2c 	.word	0x20001f2c
 800b1dc:	0802d234 	.word	0x0802d234
 800b1e0:	200048dc 	.word	0x200048dc
 800b1e4:	2000188c 	.word	0x2000188c
 800b1e8:	0802d294 	.word	0x0802d294
 800b1ec:	0802d2e8 	.word	0x0802d2e8
 800b1f0:	0802d260 	.word	0x0802d260
 800b1f4:	0802d2c4 	.word	0x0802d2c4

0800b1f8 <analyze_action_result>:
{
 800b1f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b1fc:	4605      	mov	r5, r0
 800b1fe:	460a      	mov	r2, r1
  at_bool_t data_mode = ((val & ATACTION_RSP_FLAG_DATA_MODE) != 0U) ? AT_TRUE : AT_FALSE;
 800b200:	0bcf      	lsrs	r7, r1, #15
  action = (at_action_rsp_t)(val & ~(at_action_rsp_t)ATACTION_RSP_FLAG_DATA_MODE);
 800b202:	f3c1 060e 	ubfx	r6, r1, #0, #15
  TRACE_DBG("RAW ACTION (analyze_action_result) = 0x%x", val)
 800b206:	4c65      	ldr	r4, [pc, #404]	; (800b39c <analyze_action_result+0x1a4>)
 800b208:	4965      	ldr	r1, [pc, #404]	; (800b3a0 <analyze_action_result+0x1a8>)
 800b20a:	4620      	mov	r0, r4
 800b20c:	f01a fd30 	bl	8025c70 <sprintf>
 800b210:	4620      	mov	r0, r4
 800b212:	f013 ff7e 	bl	801f112 <crs_strlen>
 800b216:	b283      	uxth	r3, r0
 800b218:	4622      	mov	r2, r4
 800b21a:	2102      	movs	r1, #2
 800b21c:	4608      	mov	r0, r1
 800b21e:	f013 ffbb 	bl	801f198 <traceIF_itmPrint>
 800b222:	4620      	mov	r0, r4
 800b224:	f013 ff75 	bl	801f112 <crs_strlen>
 800b228:	b283      	uxth	r3, r0
 800b22a:	4622      	mov	r2, r4
 800b22c:	2102      	movs	r1, #2
 800b22e:	4608      	mov	r0, r1
 800b230:	f013 ffd4 	bl	801f1dc <traceIF_uartPrint>
  TRACE_DBG("CLEANED ACTION=%d (data mode=%d)", action, data_mode)
 800b234:	463b      	mov	r3, r7
 800b236:	4632      	mov	r2, r6
 800b238:	495a      	ldr	r1, [pc, #360]	; (800b3a4 <analyze_action_result+0x1ac>)
 800b23a:	4620      	mov	r0, r4
 800b23c:	f01a fd18 	bl	8025c70 <sprintf>
 800b240:	4620      	mov	r0, r4
 800b242:	f013 ff66 	bl	801f112 <crs_strlen>
 800b246:	b283      	uxth	r3, r0
 800b248:	4622      	mov	r2, r4
 800b24a:	2102      	movs	r1, #2
 800b24c:	4608      	mov	r0, r1
 800b24e:	f013 ffa3 	bl	801f198 <traceIF_itmPrint>
 800b252:	4620      	mov	r0, r4
 800b254:	f013 ff5d 	bl	801f112 <crs_strlen>
 800b258:	b283      	uxth	r3, r0
 800b25a:	4622      	mov	r2, r4
 800b25c:	2102      	movs	r1, #2
 800b25e:	4608      	mov	r0, r1
 800b260:	f013 ffbc 	bl	801f1dc <traceIF_uartPrint>
  if (data_mode == AT_TRUE)
 800b264:	2f00      	cmp	r7, #0
 800b266:	d064      	beq.n	800b332 <analyze_action_result+0x13a>
    if (at_context[athandle].in_data_mode == AT_FALSE)
 800b268:	4b4f      	ldr	r3, [pc, #316]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b26a:	f240 629c 	movw	r2, #1692	; 0x69c
 800b26e:	fb02 3305 	mla	r3, r2, r5, r3
 800b272:	7a9b      	ldrb	r3, [r3, #10]
 800b274:	b113      	cbz	r3, 800b27c <analyze_action_result+0x84>
}
 800b276:	4630      	mov	r0, r6
 800b278:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      IPC_Handle_t *h_other_ipc = IPC_get_other_channel(at_context[athandle].ipc_handle);
 800b27c:	4b4a      	ldr	r3, [pc, #296]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b27e:	fb02 3305 	mla	r3, r2, r5, r3
 800b282:	6858      	ldr	r0, [r3, #4]
 800b284:	f013 f872 	bl	801e36c <IPC_get_other_channel>
      if (h_other_ipc != NULL)
 800b288:	b360      	cbz	r0, 800b2e4 <analyze_action_result+0xec>
        (void) IPC_select(h_other_ipc);
 800b28a:	f013 f868 	bl	801e35e <IPC_select>
        at_context[athandle].in_data_mode = AT_TRUE;
 800b28e:	4b46      	ldr	r3, [pc, #280]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b290:	f240 629c 	movw	r2, #1692	; 0x69c
 800b294:	fb02 3305 	mla	r3, r2, r5, r3
 800b298:	2201      	movs	r2, #1
 800b29a:	729a      	strb	r2, [r3, #10]
        TRACE_INFO("<<< DATA MODE SELECTED >>>")
 800b29c:	4f43      	ldr	r7, [pc, #268]	; (800b3ac <analyze_action_result+0x1b4>)
 800b29e:	4625      	mov	r5, r4
 800b2a0:	f107 0c20 	add.w	ip, r7, #32
 800b2a4:	463c      	mov	r4, r7
 800b2a6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b2a8:	6028      	str	r0, [r5, #0]
 800b2aa:	6069      	str	r1, [r5, #4]
 800b2ac:	60aa      	str	r2, [r5, #8]
 800b2ae:	60eb      	str	r3, [r5, #12]
 800b2b0:	4627      	mov	r7, r4
 800b2b2:	3510      	adds	r5, #16
 800b2b4:	4564      	cmp	r4, ip
 800b2b6:	d1f5      	bne.n	800b2a4 <analyze_action_result+0xac>
 800b2b8:	6820      	ldr	r0, [r4, #0]
 800b2ba:	6028      	str	r0, [r5, #0]
 800b2bc:	4c37      	ldr	r4, [pc, #220]	; (800b39c <analyze_action_result+0x1a4>)
 800b2be:	4620      	mov	r0, r4
 800b2c0:	f013 ff27 	bl	801f112 <crs_strlen>
 800b2c4:	b283      	uxth	r3, r0
 800b2c6:	4622      	mov	r2, r4
 800b2c8:	2101      	movs	r1, #1
 800b2ca:	2002      	movs	r0, #2
 800b2cc:	f013 ff64 	bl	801f198 <traceIF_itmPrint>
 800b2d0:	4620      	mov	r0, r4
 800b2d2:	f013 ff1e 	bl	801f112 <crs_strlen>
 800b2d6:	b283      	uxth	r3, r0
 800b2d8:	4622      	mov	r2, r4
 800b2da:	2101      	movs	r1, #1
 800b2dc:	2002      	movs	r0, #2
 800b2de:	f013 ff7d 	bl	801f1dc <traceIF_uartPrint>
 800b2e2:	e7c8      	b.n	800b276 <analyze_action_result+0x7e>
        TRACE_ERR("<<< ERROR WHEN SELECTING DATA MODE >>>")
 800b2e4:	4e32      	ldr	r6, [pc, #200]	; (800b3b0 <analyze_action_result+0x1b8>)
 800b2e6:	4c2d      	ldr	r4, [pc, #180]	; (800b39c <analyze_action_result+0x1a4>)
 800b2e8:	f106 0730 	add.w	r7, r6, #48	; 0x30
 800b2ec:	4635      	mov	r5, r6
 800b2ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b2f0:	6020      	str	r0, [r4, #0]
 800b2f2:	6061      	str	r1, [r4, #4]
 800b2f4:	60a2      	str	r2, [r4, #8]
 800b2f6:	60e3      	str	r3, [r4, #12]
 800b2f8:	462e      	mov	r6, r5
 800b2fa:	3410      	adds	r4, #16
 800b2fc:	42bd      	cmp	r5, r7
 800b2fe:	d1f5      	bne.n	800b2ec <analyze_action_result+0xf4>
 800b300:	6828      	ldr	r0, [r5, #0]
 800b302:	6020      	str	r0, [r4, #0]
 800b304:	88ab      	ldrh	r3, [r5, #4]
 800b306:	80a3      	strh	r3, [r4, #4]
 800b308:	4c24      	ldr	r4, [pc, #144]	; (800b39c <analyze_action_result+0x1a4>)
 800b30a:	4620      	mov	r0, r4
 800b30c:	f013 ff01 	bl	801f112 <crs_strlen>
 800b310:	b283      	uxth	r3, r0
 800b312:	4622      	mov	r2, r4
 800b314:	2110      	movs	r1, #16
 800b316:	2002      	movs	r0, #2
 800b318:	f013 ff3e 	bl	801f198 <traceIF_itmPrint>
 800b31c:	4620      	mov	r0, r4
 800b31e:	f013 fef8 	bl	801f112 <crs_strlen>
 800b322:	b283      	uxth	r3, r0
 800b324:	4622      	mov	r2, r4
 800b326:	2110      	movs	r1, #16
 800b328:	2002      	movs	r0, #2
 800b32a:	f013 ff57 	bl	801f1dc <traceIF_uartPrint>
        action = ATACTION_RSP_ERROR;
 800b32e:	2604      	movs	r6, #4
 800b330:	e7a1      	b.n	800b276 <analyze_action_result+0x7e>
    if (at_context[athandle].in_data_mode == AT_TRUE)
 800b332:	4b1d      	ldr	r3, [pc, #116]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b334:	f240 629c 	movw	r2, #1692	; 0x69c
 800b338:	fb02 3305 	mla	r3, r2, r5, r3
 800b33c:	7a9b      	ldrb	r3, [r3, #10]
 800b33e:	2b00      	cmp	r3, #0
 800b340:	d099      	beq.n	800b276 <analyze_action_result+0x7e>
      at_context[athandle].in_data_mode = AT_FALSE;
 800b342:	4b19      	ldr	r3, [pc, #100]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b344:	fb02 3305 	mla	r3, r2, r5, r3
 800b348:	2200      	movs	r2, #0
 800b34a:	729a      	strb	r2, [r3, #10]
      TRACE_INFO("<<< COMMAND MODE SELECTED >>>")
 800b34c:	4f19      	ldr	r7, [pc, #100]	; (800b3b4 <analyze_action_result+0x1bc>)
 800b34e:	4c13      	ldr	r4, [pc, #76]	; (800b39c <analyze_action_result+0x1a4>)
 800b350:	f107 0c20 	add.w	ip, r7, #32
 800b354:	463d      	mov	r5, r7
 800b356:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b358:	6020      	str	r0, [r4, #0]
 800b35a:	6061      	str	r1, [r4, #4]
 800b35c:	60a2      	str	r2, [r4, #8]
 800b35e:	60e3      	str	r3, [r4, #12]
 800b360:	462f      	mov	r7, r5
 800b362:	3410      	adds	r4, #16
 800b364:	4565      	cmp	r5, ip
 800b366:	d1f5      	bne.n	800b354 <analyze_action_result+0x15c>
 800b368:	6828      	ldr	r0, [r5, #0]
 800b36a:	6020      	str	r0, [r4, #0]
 800b36c:	88aa      	ldrh	r2, [r5, #4]
 800b36e:	79ab      	ldrb	r3, [r5, #6]
 800b370:	80a2      	strh	r2, [r4, #4]
 800b372:	71a3      	strb	r3, [r4, #6]
 800b374:	4c09      	ldr	r4, [pc, #36]	; (800b39c <analyze_action_result+0x1a4>)
 800b376:	4620      	mov	r0, r4
 800b378:	f013 fecb 	bl	801f112 <crs_strlen>
 800b37c:	b283      	uxth	r3, r0
 800b37e:	4622      	mov	r2, r4
 800b380:	2101      	movs	r1, #1
 800b382:	2002      	movs	r0, #2
 800b384:	f013 ff08 	bl	801f198 <traceIF_itmPrint>
 800b388:	4620      	mov	r0, r4
 800b38a:	f013 fec2 	bl	801f112 <crs_strlen>
 800b38e:	b283      	uxth	r3, r0
 800b390:	4622      	mov	r2, r4
 800b392:	2101      	movs	r1, #1
 800b394:	2002      	movs	r0, #2
 800b396:	f013 ff21 	bl	801f1dc <traceIF_uartPrint>
 800b39a:	e76c      	b.n	800b276 <analyze_action_result+0x7e>
 800b39c:	200048dc 	.word	0x200048dc
 800b3a0:	0802d308 	.word	0x0802d308
 800b3a4:	0802d33c 	.word	0x0802d33c
 800b3a8:	2000188c 	.word	0x2000188c
 800b3ac:	0802d368 	.word	0x0802d368
 800b3b0:	0802d38c 	.word	0x0802d38c
 800b3b4:	0802d3c4 	.word	0x0802d3c4

0800b3b8 <ATCoreTaskBody>:

static void ATCoreTaskBody(void *argument)
{
 800b3b8:	b570      	push	{r4, r5, r6, lr}
 800b3ba:	b082      	sub	sp, #8
  at_status_t retUrc;
  at_handle_t athandle;
  at_status_t ret;
  at_action_rsp_t action;
  rtosalStatus status;
  uint32_t msg = 0;
 800b3bc:	2300      	movs	r3, #0
 800b3be:	9300      	str	r3, [sp, #0]

  static at_buf_t urc_buf[ATCMD_MAX_BUF_SIZE]; /* buffer size not optimized yet */

  TRACE_DBG("<start ATCore TASK>")
 800b3c0:	4cbd      	ldr	r4, [pc, #756]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b3c2:	4dbe      	ldr	r5, [pc, #760]	; (800b6bc <ATCoreTaskBody+0x304>)
 800b3c4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b3c6:	6020      	str	r0, [r4, #0]
 800b3c8:	6061      	str	r1, [r4, #4]
 800b3ca:	60a2      	str	r2, [r4, #8]
 800b3cc:	60e3      	str	r3, [r4, #12]
 800b3ce:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b3d0:	6120      	str	r0, [r4, #16]
 800b3d2:	6161      	str	r1, [r4, #20]
 800b3d4:	61a2      	str	r2, [r4, #24]
 800b3d6:	782b      	ldrb	r3, [r5, #0]
 800b3d8:	7723      	strb	r3, [r4, #28]
 800b3da:	4620      	mov	r0, r4
 800b3dc:	f013 fe99 	bl	801f112 <crs_strlen>
 800b3e0:	b283      	uxth	r3, r0
 800b3e2:	4622      	mov	r2, r4
 800b3e4:	2102      	movs	r1, #2
 800b3e6:	4608      	mov	r0, r1
 800b3e8:	f013 fed6 	bl	801f198 <traceIF_itmPrint>
 800b3ec:	4620      	mov	r0, r4
 800b3ee:	f013 fe90 	bl	801f112 <crs_strlen>
 800b3f2:	b283      	uxth	r3, r0
 800b3f4:	4622      	mov	r2, r4
 800b3f6:	2102      	movs	r1, #2
 800b3f8:	4608      	mov	r0, r1
 800b3fa:	f013 feef 	bl	801f1dc <traceIF_uartPrint>
 800b3fe:	e1ef      	b.n	800b7e0 <ATCoreTaskBody+0x428>
      TRACE_DBG("<ATCore TASK> - received msg event= 0x%lx", msg)

      if (msg == (SIG_IPC_MSG))
      {
        /* a message has been received from IPC, retrieve its handle */
        ret = findMsgReceivedHandle(&athandle);
 800b400:	f10d 0006 	add.w	r0, sp, #6
 800b404:	f7ff fb68 	bl	800aad8 <findMsgReceivedHandle>
        if (ret != ATSTATUS_OK)
 800b408:	2800      	cmp	r0, #0
 800b40a:	f040 81e9 	bne.w	800b7e0 <ATCoreTaskBody+0x428>
          /* skip this loop iteration */
          continue;
        }

        /* retrieve message from IPC */
        if (IPC_receive(&ipcHandleTab[athandle], &msgFromIPC[athandle]) == IPC_ERROR)
 800b40e:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b412:	ebc3 2003 	rsb	r0, r3, r3, lsl #8
 800b416:	4aaa      	ldr	r2, [pc, #680]	; (800b6c0 <ATCoreTaskBody+0x308>)
 800b418:	f240 71d2 	movw	r1, #2002	; 0x7d2
 800b41c:	fb01 2103 	mla	r1, r1, r3, r2
 800b420:	4ba8      	ldr	r3, [pc, #672]	; (800b6c4 <ATCoreTaskBody+0x30c>)
 800b422:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800b426:	f012 ffaf 	bl	801e388 <IPC_receive>
 800b42a:	2801      	cmp	r0, #1
 800b42c:	d073      	beq.n	800b516 <ATCoreTaskBody+0x15e>
          /* skip this loop iteration */
          continue;
        }

        /* one message has been read */
        IRQ_DISABLE();
 800b42e:	f7ff fb4f 	bl	800aad0 <IRQ_DISABLE>
        MsgReceived[athandle]--;
 800b432:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b436:	49a4      	ldr	r1, [pc, #656]	; (800b6c8 <ATCoreTaskBody+0x310>)
 800b438:	5c8b      	ldrb	r3, [r1, r2]
 800b43a:	3b01      	subs	r3, #1
 800b43c:	b2db      	uxtb	r3, r3
 800b43e:	548b      	strb	r3, [r1, r2]
        IRQ_ENABLE();
 800b440:	f7ff fb48 	bl	800aad4 <IRQ_ENABLE>

        /* Parse the response */
        action = ATParser_parse_rsp(&at_context[athandle], &msgFromIPC[athandle]);
 800b444:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
 800b448:	4da0      	ldr	r5, [pc, #640]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b44a:	f240 669c 	movw	r6, #1692	; 0x69c
 800b44e:	4b9c      	ldr	r3, [pc, #624]	; (800b6c0 <ATCoreTaskBody+0x308>)
 800b450:	f240 71d2 	movw	r1, #2002	; 0x7d2
 800b454:	fb01 3100 	mla	r1, r1, r0, r3
 800b458:	fb06 5000 	mla	r0, r6, r0, r5
 800b45c:	f009 fb18 	bl	8014a90 <ATParser_parse_rsp>
 800b460:	4601      	mov	r1, r0

        /* analyze the response (check data mode flag) */
        action = analyze_action_result(athandle, action);
 800b462:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
 800b466:	f7ff fec7 	bl	800b1f8 <analyze_action_result>
 800b46a:	4604      	mov	r4, r0

        /* add this action to action flags */
        at_context[athandle].action_flags |= action;
 800b46c:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b470:	fb06 5503 	mla	r5, r6, r3, r5
 800b474:	f8b5 3690 	ldrh.w	r3, [r5, #1680]	; 0x690
 800b478:	4303      	orrs	r3, r0
 800b47a:	b29b      	uxth	r3, r3
 800b47c:	f8a5 3690 	strh.w	r3, [r5, #1680]	; 0x690
        TRACE_DBG("add action 0x%x (flags=0x%x)", action, at_context[athandle].action_flags)
 800b480:	4d8d      	ldr	r5, [pc, #564]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b482:	4602      	mov	r2, r0
 800b484:	4992      	ldr	r1, [pc, #584]	; (800b6d0 <ATCoreTaskBody+0x318>)
 800b486:	4628      	mov	r0, r5
 800b488:	f01a fbf2 	bl	8025c70 <sprintf>
 800b48c:	4628      	mov	r0, r5
 800b48e:	f013 fe40 	bl	801f112 <crs_strlen>
 800b492:	b283      	uxth	r3, r0
 800b494:	462a      	mov	r2, r5
 800b496:	2102      	movs	r1, #2
 800b498:	4608      	mov	r0, r1
 800b49a:	f013 fe7d 	bl	801f198 <traceIF_itmPrint>
 800b49e:	4628      	mov	r0, r5
 800b4a0:	f013 fe37 	bl	801f112 <crs_strlen>
 800b4a4:	b283      	uxth	r3, r0
 800b4a6:	462a      	mov	r2, r5
 800b4a8:	2102      	movs	r1, #2
 800b4aa:	4608      	mov	r0, r1
 800b4ac:	f013 fe96 	bl	801f1dc <traceIF_uartPrint>
        if (action == ATACTION_RSP_ERROR)
 800b4b0:	2c04      	cmp	r4, #4
 800b4b2:	f000 8087 	beq.w	800b5c4 <ATCoreTaskBody+0x20c>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
          continue;
        }

        /* check if this is an URC to forward */
        if (action == ATACTION_RSP_URC_FORWARDED)
 800b4b6:	2c40      	cmp	r4, #64	; 0x40
 800b4b8:	f000 80d4 	beq.w	800b664 <ATCoreTaskBody+0x2ac>
                (* register_URC_callback[athandle])(urc_buf);
              }
            } while (retUrc == ATSTATUS_OK_PENDING_URC);
          }
        }
        else if ((action == ATACTION_RSP_FRC_CONTINUE) ||
 800b4bc:	3c01      	subs	r4, #1
 800b4be:	b2a4      	uxth	r4, r4
 800b4c0:	2c01      	cmp	r4, #1
 800b4c2:	f200 818d 	bhi.w	800b7e0 <ATCoreTaskBody+0x428>
                 (action == ATACTION_RSP_FRC_END) ||
                 (action == ATACTION_RSP_ERROR))
        {
          TRACE_DBG("**** Sema released *****")
 800b4c6:	4e83      	ldr	r6, [pc, #524]	; (800b6d4 <ATCoreTaskBody+0x31c>)
 800b4c8:	4d7b      	ldr	r5, [pc, #492]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b4ca:	f106 0c20 	add.w	ip, r6, #32
 800b4ce:	4634      	mov	r4, r6
 800b4d0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b4d2:	6028      	str	r0, [r5, #0]
 800b4d4:	6069      	str	r1, [r5, #4]
 800b4d6:	60aa      	str	r2, [r5, #8]
 800b4d8:	60eb      	str	r3, [r5, #12]
 800b4da:	4626      	mov	r6, r4
 800b4dc:	3510      	adds	r5, #16
 800b4de:	4564      	cmp	r4, ip
 800b4e0:	d1f5      	bne.n	800b4ce <ATCoreTaskBody+0x116>
 800b4e2:	8823      	ldrh	r3, [r4, #0]
 800b4e4:	802b      	strh	r3, [r5, #0]
 800b4e6:	4c74      	ldr	r4, [pc, #464]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b4e8:	4620      	mov	r0, r4
 800b4ea:	f013 fe12 	bl	801f112 <crs_strlen>
 800b4ee:	b283      	uxth	r3, r0
 800b4f0:	4622      	mov	r2, r4
 800b4f2:	2102      	movs	r1, #2
 800b4f4:	4608      	mov	r0, r1
 800b4f6:	f013 fe4f 	bl	801f198 <traceIF_itmPrint>
 800b4fa:	4620      	mov	r0, r4
 800b4fc:	f013 fe09 	bl	801f112 <crs_strlen>
 800b500:	b283      	uxth	r3, r0
 800b502:	4622      	mov	r2, r4
 800b504:	2102      	movs	r1, #2
 800b506:	4608      	mov	r0, r1
 800b508:	f013 fe68 	bl	801f1dc <traceIF_uartPrint>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
 800b50c:	4b72      	ldr	r3, [pc, #456]	; (800b6d8 <ATCoreTaskBody+0x320>)
 800b50e:	6818      	ldr	r0, [r3, #0]
 800b510:	f013 fd0b 	bl	801ef2a <rtosalSemaphoreRelease>
 800b514:	e164      	b.n	800b7e0 <ATCoreTaskBody+0x428>
          TRACE_ERR("IPC receive error")
 800b516:	4e71      	ldr	r6, [pc, #452]	; (800b6dc <ATCoreTaskBody+0x324>)
 800b518:	4625      	mov	r5, r4
 800b51a:	f106 0c20 	add.w	ip, r6, #32
 800b51e:	4634      	mov	r4, r6
 800b520:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b522:	6028      	str	r0, [r5, #0]
 800b524:	6069      	str	r1, [r5, #4]
 800b526:	60aa      	str	r2, [r5, #8]
 800b528:	60eb      	str	r3, [r5, #12]
 800b52a:	4626      	mov	r6, r4
 800b52c:	3510      	adds	r5, #16
 800b52e:	4564      	cmp	r4, ip
 800b530:	d1f5      	bne.n	800b51e <ATCoreTaskBody+0x166>
 800b532:	7823      	ldrb	r3, [r4, #0]
 800b534:	702b      	strb	r3, [r5, #0]
 800b536:	4c60      	ldr	r4, [pc, #384]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b538:	4620      	mov	r0, r4
 800b53a:	f013 fdea 	bl	801f112 <crs_strlen>
 800b53e:	b283      	uxth	r3, r0
 800b540:	4622      	mov	r2, r4
 800b542:	2110      	movs	r1, #16
 800b544:	2002      	movs	r0, #2
 800b546:	f013 fe27 	bl	801f198 <traceIF_itmPrint>
 800b54a:	4620      	mov	r0, r4
 800b54c:	f013 fde1 	bl	801f112 <crs_strlen>
 800b550:	b283      	uxth	r3, r0
 800b552:	4622      	mov	r2, r4
 800b554:	2110      	movs	r1, #16
 800b556:	2002      	movs	r0, #2
 800b558:	f013 fe40 	bl	801f1dc <traceIF_uartPrint>
          ATParser_abort_request(&at_context[athandle]);
 800b55c:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b560:	4b5a      	ldr	r3, [pc, #360]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b562:	f240 609c 	movw	r0, #1692	; 0x69c
 800b566:	fb00 3002 	mla	r0, r0, r2, r3
 800b56a:	f009 fb74 	bl	8014c56 <ATParser_abort_request>
          TRACE_DBG("**** Sema Released on error 1 *****")
 800b56e:	4d5c      	ldr	r5, [pc, #368]	; (800b6e0 <ATCoreTaskBody+0x328>)
 800b570:	f105 0c20 	add.w	ip, r5, #32
 800b574:	462e      	mov	r6, r5
 800b576:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800b578:	6020      	str	r0, [r4, #0]
 800b57a:	6061      	str	r1, [r4, #4]
 800b57c:	60a2      	str	r2, [r4, #8]
 800b57e:	60e3      	str	r3, [r4, #12]
 800b580:	4635      	mov	r5, r6
 800b582:	3410      	adds	r4, #16
 800b584:	4566      	cmp	r6, ip
 800b586:	d1f5      	bne.n	800b574 <ATCoreTaskBody+0x1bc>
 800b588:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b58a:	6020      	str	r0, [r4, #0]
 800b58c:	6061      	str	r1, [r4, #4]
 800b58e:	60a2      	str	r2, [r4, #8]
 800b590:	782b      	ldrb	r3, [r5, #0]
 800b592:	7323      	strb	r3, [r4, #12]
 800b594:	4c48      	ldr	r4, [pc, #288]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b596:	4620      	mov	r0, r4
 800b598:	f013 fdbb 	bl	801f112 <crs_strlen>
 800b59c:	b283      	uxth	r3, r0
 800b59e:	4622      	mov	r2, r4
 800b5a0:	2102      	movs	r1, #2
 800b5a2:	4608      	mov	r0, r1
 800b5a4:	f013 fdf8 	bl	801f198 <traceIF_itmPrint>
 800b5a8:	4620      	mov	r0, r4
 800b5aa:	f013 fdb2 	bl	801f112 <crs_strlen>
 800b5ae:	b283      	uxth	r3, r0
 800b5b0:	4622      	mov	r2, r4
 800b5b2:	2102      	movs	r1, #2
 800b5b4:	4608      	mov	r0, r1
 800b5b6:	f013 fe11 	bl	801f1dc <traceIF_uartPrint>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
 800b5ba:	4b47      	ldr	r3, [pc, #284]	; (800b6d8 <ATCoreTaskBody+0x320>)
 800b5bc:	6818      	ldr	r0, [r3, #0]
 800b5be:	f013 fcb4 	bl	801ef2a <rtosalSemaphoreRelease>
          continue;
 800b5c2:	e10d      	b.n	800b7e0 <ATCoreTaskBody+0x428>
          TRACE_ERR("AT_sendcmd error")
 800b5c4:	462c      	mov	r4, r5
 800b5c6:	4d47      	ldr	r5, [pc, #284]	; (800b6e4 <ATCoreTaskBody+0x32c>)
 800b5c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b5ca:	6020      	str	r0, [r4, #0]
 800b5cc:	6061      	str	r1, [r4, #4]
 800b5ce:	60a2      	str	r2, [r4, #8]
 800b5d0:	60e3      	str	r3, [r4, #12]
 800b5d2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b5d4:	6120      	str	r0, [r4, #16]
 800b5d6:	6161      	str	r1, [r4, #20]
 800b5d8:	61a2      	str	r2, [r4, #24]
 800b5da:	61e3      	str	r3, [r4, #28]
 800b5dc:	4620      	mov	r0, r4
 800b5de:	f013 fd98 	bl	801f112 <crs_strlen>
 800b5e2:	b283      	uxth	r3, r0
 800b5e4:	4622      	mov	r2, r4
 800b5e6:	2110      	movs	r1, #16
 800b5e8:	2002      	movs	r0, #2
 800b5ea:	f013 fdd5 	bl	801f198 <traceIF_itmPrint>
 800b5ee:	4620      	mov	r0, r4
 800b5f0:	f013 fd8f 	bl	801f112 <crs_strlen>
 800b5f4:	b283      	uxth	r3, r0
 800b5f6:	4622      	mov	r2, r4
 800b5f8:	2110      	movs	r1, #16
 800b5fa:	2002      	movs	r0, #2
 800b5fc:	f013 fdee 	bl	801f1dc <traceIF_uartPrint>
          ATParser_abort_request(&at_context[athandle]);
 800b600:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b604:	4b31      	ldr	r3, [pc, #196]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b606:	fb06 3002 	mla	r0, r6, r2, r3
 800b60a:	f009 fb24 	bl	8014c56 <ATParser_abort_request>
          TRACE_DBG("**** Sema Released on error 2 *****")
 800b60e:	4d36      	ldr	r5, [pc, #216]	; (800b6e8 <ATCoreTaskBody+0x330>)
 800b610:	f105 0c20 	add.w	ip, r5, #32
 800b614:	462e      	mov	r6, r5
 800b616:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800b618:	6020      	str	r0, [r4, #0]
 800b61a:	6061      	str	r1, [r4, #4]
 800b61c:	60a2      	str	r2, [r4, #8]
 800b61e:	60e3      	str	r3, [r4, #12]
 800b620:	4635      	mov	r5, r6
 800b622:	3410      	adds	r4, #16
 800b624:	4566      	cmp	r6, ip
 800b626:	d1f5      	bne.n	800b614 <ATCoreTaskBody+0x25c>
 800b628:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b62a:	6020      	str	r0, [r4, #0]
 800b62c:	6061      	str	r1, [r4, #4]
 800b62e:	60a2      	str	r2, [r4, #8]
 800b630:	782b      	ldrb	r3, [r5, #0]
 800b632:	7323      	strb	r3, [r4, #12]
 800b634:	4c20      	ldr	r4, [pc, #128]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b636:	4620      	mov	r0, r4
 800b638:	f013 fd6b 	bl	801f112 <crs_strlen>
 800b63c:	b283      	uxth	r3, r0
 800b63e:	4622      	mov	r2, r4
 800b640:	2102      	movs	r1, #2
 800b642:	4608      	mov	r0, r1
 800b644:	f013 fda8 	bl	801f198 <traceIF_itmPrint>
 800b648:	4620      	mov	r0, r4
 800b64a:	f013 fd62 	bl	801f112 <crs_strlen>
 800b64e:	b283      	uxth	r3, r0
 800b650:	4622      	mov	r2, r4
 800b652:	2102      	movs	r1, #2
 800b654:	4608      	mov	r0, r1
 800b656:	f013 fdc1 	bl	801f1dc <traceIF_uartPrint>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
 800b65a:	4b1f      	ldr	r3, [pc, #124]	; (800b6d8 <ATCoreTaskBody+0x320>)
 800b65c:	6818      	ldr	r0, [r3, #0]
 800b65e:	f013 fc64 	bl	801ef2a <rtosalSemaphoreRelease>
          continue;
 800b662:	e0bd      	b.n	800b7e0 <ATCoreTaskBody+0x428>
          if (register_URC_callback[athandle] != NULL)
 800b664:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b668:	4b20      	ldr	r3, [pc, #128]	; (800b6ec <ATCoreTaskBody+0x334>)
 800b66a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b66e:	2b00      	cmp	r3, #0
 800b670:	f000 80b6 	beq.w	800b7e0 <ATCoreTaskBody+0x428>
 800b674:	e009      	b.n	800b68a <ATCoreTaskBody+0x2d2>
                (* register_URC_callback[athandle])(urc_buf);
 800b676:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b67a:	4b1c      	ldr	r3, [pc, #112]	; (800b6ec <ATCoreTaskBody+0x334>)
 800b67c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b680:	481b      	ldr	r0, [pc, #108]	; (800b6f0 <ATCoreTaskBody+0x338>)
 800b682:	4798      	blx	r3
            } while (retUrc == ATSTATUS_OK_PENDING_URC);
 800b684:	2c03      	cmp	r4, #3
 800b686:	f040 80ab 	bne.w	800b7e0 <ATCoreTaskBody+0x428>
              (void) memset((void *) urc_buf, 0, ATCMD_MAX_BUF_SIZE);
 800b68a:	4c19      	ldr	r4, [pc, #100]	; (800b6f0 <ATCoreTaskBody+0x338>)
 800b68c:	2280      	movs	r2, #128	; 0x80
 800b68e:	2100      	movs	r1, #0
 800b690:	4620      	mov	r0, r4
 800b692:	f01a fb60 	bl	8025d56 <memset>
              retUrc = ATParser_get_urc(&at_context[athandle], urc_buf);
 800b696:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b69a:	4621      	mov	r1, r4
 800b69c:	4b0b      	ldr	r3, [pc, #44]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b69e:	f240 609c 	movw	r0, #1692	; 0x69c
 800b6a2:	fb00 3002 	mla	r0, r0, r2, r3
 800b6a6:	f009 face 	bl	8014c46 <ATParser_get_urc>
              if ((retUrc == ATSTATUS_OK) || (retUrc == ATSTATUS_OK_PENDING_URC))
 800b6aa:	4604      	mov	r4, r0
 800b6ac:	2800      	cmp	r0, #0
 800b6ae:	d0e2      	beq.n	800b676 <ATCoreTaskBody+0x2be>
 800b6b0:	2803      	cmp	r0, #3
 800b6b2:	d1e7      	bne.n	800b684 <ATCoreTaskBody+0x2cc>
 800b6b4:	e7df      	b.n	800b676 <ATCoreTaskBody+0x2be>
 800b6b6:	bf00      	nop
 800b6b8:	200048dc 	.word	0x200048dc
 800b6bc:	0802d3ec 	.word	0x0802d3ec
 800b6c0:	20002d68 	.word	0x20002d68
 800b6c4:	20002570 	.word	0x20002570
 800b6c8:	20001888 	.word	0x20001888
 800b6cc:	2000188c 	.word	0x2000188c
 800b6d0:	0802d494 	.word	0x0802d494
 800b6d4:	0802d50c 	.word	0x0802d50c
 800b6d8:	20003544 	.word	0x20003544
 800b6dc:	0802d440 	.word	0x0802d440
 800b6e0:	0802d464 	.word	0x0802d464
 800b6e4:	0802d4bc 	.word	0x0802d4bc
 800b6e8:	0802d4dc 	.word	0x0802d4dc
 800b6ec:	20003540 	.word	0x20003540
 800b6f0:	20003548 	.word	0x20003548
      else if (msg == (SIG_INTERNAL_EVENT_MODEM))
      {
        /* An internal event has been received (ie not coming from IPC: could be an interrupt from modem,...)
         * Do not call IPC_receive in this case
         */
        TRACE_INFO("!!! an internal event has been received !!!")
 800b6f4:	4e52      	ldr	r6, [pc, #328]	; (800b840 <ATCoreTaskBody+0x488>)
 800b6f6:	4c53      	ldr	r4, [pc, #332]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b6f8:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 800b6fc:	4635      	mov	r5, r6
 800b6fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b700:	6020      	str	r0, [r4, #0]
 800b702:	6061      	str	r1, [r4, #4]
 800b704:	60a2      	str	r2, [r4, #8]
 800b706:	60e3      	str	r3, [r4, #12]
 800b708:	462e      	mov	r6, r5
 800b70a:	3410      	adds	r4, #16
 800b70c:	4565      	cmp	r5, ip
 800b70e:	d1f5      	bne.n	800b6fc <ATCoreTaskBody+0x344>
 800b710:	6828      	ldr	r0, [r5, #0]
 800b712:	6020      	str	r0, [r4, #0]
 800b714:	792b      	ldrb	r3, [r5, #4]
 800b716:	7123      	strb	r3, [r4, #4]
 800b718:	4c4a      	ldr	r4, [pc, #296]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b71a:	4620      	mov	r0, r4
 800b71c:	f013 fcf9 	bl	801f112 <crs_strlen>
 800b720:	b283      	uxth	r3, r0
 800b722:	4622      	mov	r2, r4
 800b724:	2101      	movs	r1, #1
 800b726:	2002      	movs	r0, #2
 800b728:	f013 fd36 	bl	801f198 <traceIF_itmPrint>
 800b72c:	4620      	mov	r0, r4
 800b72e:	f013 fcf0 	bl	801f112 <crs_strlen>
 800b732:	b283      	uxth	r3, r0
 800b734:	4622      	mov	r2, r4
 800b736:	2101      	movs	r1, #1
 800b738:	2002      	movs	r0, #2
 800b73a:	f013 fd4f 	bl	801f1dc <traceIF_uartPrint>
        athandle = find_deviceType_ATHandle(DEVTYPE_MODEM_CELLULAR);
 800b73e:	2000      	movs	r0, #0
 800b740:	f7ff f9b2 	bl	800aaa8 <find_deviceType_ATHandle>
 800b744:	f8ad 0006 	strh.w	r0, [sp, #6]
        if (athandle != AT_HANDLE_INVALID)
 800b748:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b74c:	d048      	beq.n	800b7e0 <ATCoreTaskBody+0x428>
        {
          if (register_URC_callback[athandle] != NULL)
 800b74e:	4b3e      	ldr	r3, [pc, #248]	; (800b848 <ATCoreTaskBody+0x490>)
 800b750:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800b754:	2b00      	cmp	r3, #0
 800b756:	d043      	beq.n	800b7e0 <ATCoreTaskBody+0x428>
 800b758:	e008      	b.n	800b76c <ATCoreTaskBody+0x3b4>
              (void) memset((void *) urc_buf, 0, ATCMD_MAX_BUF_SIZE);
              retUrc = ATParser_get_urc(&at_context[athandle], urc_buf);
              if ((retUrc == ATSTATUS_OK) || (retUrc == ATSTATUS_OK_PENDING_URC))
              {
                /* call the URC callback */
                (* register_URC_callback[athandle])(urc_buf);
 800b75a:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b75e:	4b3a      	ldr	r3, [pc, #232]	; (800b848 <ATCoreTaskBody+0x490>)
 800b760:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b764:	4839      	ldr	r0, [pc, #228]	; (800b84c <ATCoreTaskBody+0x494>)
 800b766:	4798      	blx	r3
              }
            } while (retUrc == ATSTATUS_OK_PENDING_URC);
 800b768:	2c03      	cmp	r4, #3
 800b76a:	d139      	bne.n	800b7e0 <ATCoreTaskBody+0x428>
              (void) memset((void *) urc_buf, 0, ATCMD_MAX_BUF_SIZE);
 800b76c:	4c37      	ldr	r4, [pc, #220]	; (800b84c <ATCoreTaskBody+0x494>)
 800b76e:	2280      	movs	r2, #128	; 0x80
 800b770:	2100      	movs	r1, #0
 800b772:	4620      	mov	r0, r4
 800b774:	f01a faef 	bl	8025d56 <memset>
              retUrc = ATParser_get_urc(&at_context[athandle], urc_buf);
 800b778:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b77c:	4621      	mov	r1, r4
 800b77e:	4b34      	ldr	r3, [pc, #208]	; (800b850 <ATCoreTaskBody+0x498>)
 800b780:	f240 609c 	movw	r0, #1692	; 0x69c
 800b784:	fb00 3002 	mla	r0, r0, r2, r3
 800b788:	f009 fa5d 	bl	8014c46 <ATParser_get_urc>
              if ((retUrc == ATSTATUS_OK) || (retUrc == ATSTATUS_OK_PENDING_URC))
 800b78c:	4604      	mov	r4, r0
 800b78e:	2800      	cmp	r0, #0
 800b790:	d0e3      	beq.n	800b75a <ATCoreTaskBody+0x3a2>
 800b792:	2803      	cmp	r0, #3
 800b794:	d1e8      	bne.n	800b768 <ATCoreTaskBody+0x3b0>
 800b796:	e7e0      	b.n	800b75a <ATCoreTaskBody+0x3a2>
        }
      }
      else
      {
        /* should not happen */
        TRACE_INFO("an unexpected event has been received !!!")
 800b798:	46ac      	mov	ip, r5
 800b79a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b79e:	6020      	str	r0, [r4, #0]
 800b7a0:	6061      	str	r1, [r4, #4]
 800b7a2:	60a2      	str	r2, [r4, #8]
 800b7a4:	60e3      	str	r3, [r4, #12]
 800b7a6:	4665      	mov	r5, ip
 800b7a8:	3410      	adds	r4, #16
 800b7aa:	45b4      	cmp	ip, r6
 800b7ac:	d1f4      	bne.n	800b798 <ATCoreTaskBody+0x3e0>
 800b7ae:	f8bc 2000 	ldrh.w	r2, [ip]
 800b7b2:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800b7b6:	8022      	strh	r2, [r4, #0]
 800b7b8:	70a3      	strb	r3, [r4, #2]
 800b7ba:	4c22      	ldr	r4, [pc, #136]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b7bc:	4620      	mov	r0, r4
 800b7be:	f013 fca8 	bl	801f112 <crs_strlen>
 800b7c2:	b283      	uxth	r3, r0
 800b7c4:	4622      	mov	r2, r4
 800b7c6:	2101      	movs	r1, #1
 800b7c8:	2002      	movs	r0, #2
 800b7ca:	f013 fce5 	bl	801f198 <traceIF_itmPrint>
 800b7ce:	4620      	mov	r0, r4
 800b7d0:	f013 fc9f 	bl	801f112 <crs_strlen>
 800b7d4:	b283      	uxth	r3, r0
 800b7d6:	4622      	mov	r2, r4
 800b7d8:	2101      	movs	r1, #1
 800b7da:	2002      	movs	r0, #2
 800b7dc:	f013 fcfe 	bl	801f1dc <traceIF_uartPrint>
    status = rtosalMessageQueueGet(q_msg_IPC_received_Id,
 800b7e0:	f04f 32ff 	mov.w	r2, #4294967295
 800b7e4:	4669      	mov	r1, sp
 800b7e6:	4b1b      	ldr	r3, [pc, #108]	; (800b854 <ATCoreTaskBody+0x49c>)
 800b7e8:	6818      	ldr	r0, [r3, #0]
 800b7ea:	f013 fbc4 	bl	801ef76 <rtosalMessageQueueGet>
    if ((status == osEventMessage) || (status == osOK))
 800b7ee:	2810      	cmp	r0, #16
 800b7f0:	d001      	beq.n	800b7f6 <ATCoreTaskBody+0x43e>
 800b7f2:	2800      	cmp	r0, #0
 800b7f4:	d1f4      	bne.n	800b7e0 <ATCoreTaskBody+0x428>
      TRACE_DBG("<ATCore TASK> - received msg event= 0x%lx", msg)
 800b7f6:	4c13      	ldr	r4, [pc, #76]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b7f8:	9a00      	ldr	r2, [sp, #0]
 800b7fa:	4917      	ldr	r1, [pc, #92]	; (800b858 <ATCoreTaskBody+0x4a0>)
 800b7fc:	4620      	mov	r0, r4
 800b7fe:	f01a fa37 	bl	8025c70 <sprintf>
 800b802:	4620      	mov	r0, r4
 800b804:	f013 fc85 	bl	801f112 <crs_strlen>
 800b808:	b283      	uxth	r3, r0
 800b80a:	4622      	mov	r2, r4
 800b80c:	2102      	movs	r1, #2
 800b80e:	4608      	mov	r0, r1
 800b810:	f013 fcc2 	bl	801f198 <traceIF_itmPrint>
 800b814:	4620      	mov	r0, r4
 800b816:	f013 fc7c 	bl	801f112 <crs_strlen>
 800b81a:	b283      	uxth	r3, r0
 800b81c:	4622      	mov	r2, r4
 800b81e:	2102      	movs	r1, #2
 800b820:	4608      	mov	r0, r1
 800b822:	f013 fcdb 	bl	801f1dc <traceIF_uartPrint>
      if (msg == (SIG_IPC_MSG))
 800b826:	9b00      	ldr	r3, [sp, #0]
 800b828:	2b01      	cmp	r3, #1
 800b82a:	f43f ade9 	beq.w	800b400 <ATCoreTaskBody+0x48>
      else if (msg == (SIG_INTERNAL_EVENT_MODEM))
 800b82e:	2b02      	cmp	r3, #2
 800b830:	f43f af60 	beq.w	800b6f4 <ATCoreTaskBody+0x33c>
        TRACE_INFO("an unexpected event has been received !!!")
 800b834:	4d09      	ldr	r5, [pc, #36]	; (800b85c <ATCoreTaskBody+0x4a4>)
 800b836:	4c03      	ldr	r4, [pc, #12]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b838:	f105 0630 	add.w	r6, r5, #48	; 0x30
 800b83c:	e7ac      	b.n	800b798 <ATCoreTaskBody+0x3e0>
 800b83e:	bf00      	nop
 800b840:	0802d530 	.word	0x0802d530
 800b844:	200048dc 	.word	0x200048dc
 800b848:	20003540 	.word	0x20003540
 800b84c:	20003548 	.word	0x20003548
 800b850:	2000188c 	.word	0x2000188c
 800b854:	2000353c 	.word	0x2000353c
 800b858:	0802d40c 	.word	0x0802d40c
 800b85c:	0802d568 	.word	0x0802d568

0800b860 <AT_init>:
{
 800b860:	b510      	push	{r4, lr}
  if (AT_Core_initialized == 1U)
 800b862:	4b1a      	ldr	r3, [pc, #104]	; (800b8cc <AT_init+0x6c>)
 800b864:	781c      	ldrb	r4, [r3, #0]
 800b866:	2c01      	cmp	r4, #1
 800b868:	d12e      	bne.n	800b8c8 <AT_init+0x68>
    LOG_ERROR(1, ERROR_WARNING);
 800b86a:	2202      	movs	r2, #2
 800b86c:	2101      	movs	r1, #1
 800b86e:	4610      	mov	r0, r2
 800b870:	f012 fc6c 	bl	801e14c <ERROR_Handler>
}
 800b874:	4620      	mov	r0, r4
 800b876:	bd10      	pop	{r4, pc}
      MsgReceived[idx] = 0U;
 800b878:	2100      	movs	r1, #0
 800b87a:	4b15      	ldr	r3, [pc, #84]	; (800b8d0 <AT_init+0x70>)
 800b87c:	5519      	strb	r1, [r3, r4]
      register_URC_callback[idx] = NULL;
 800b87e:	4b15      	ldr	r3, [pc, #84]	; (800b8d4 <AT_init+0x74>)
 800b880:	f843 1024 	str.w	r1, [r3, r4, lsl #2]
      at_context[idx].device_type = DEVTYPE_INVALID;
 800b884:	4814      	ldr	r0, [pc, #80]	; (800b8d8 <AT_init+0x78>)
 800b886:	f240 639c 	movw	r3, #1692	; 0x69c
 800b88a:	fb04 f303 	mul.w	r3, r4, r3
 800b88e:	18c2      	adds	r2, r0, r3
 800b890:	f04f 0c01 	mov.w	ip, #1
 800b894:	f800 c003 	strb.w	ip, [r0, r3]
      at_context[idx].in_data_mode = AT_FALSE;
 800b898:	7291      	strb	r1, [r2, #10]
      at_context[idx].processing_cmd = 0U;
 800b89a:	72d1      	strb	r1, [r2, #11]
      at_context[idx].dataSent = AT_FALSE;
 800b89c:	7311      	strb	r1, [r2, #12]
      at_context[idx].action_flags = ATACTION_RSP_NO_ACTION;
 800b89e:	f8a2 1690 	strh.w	r1, [r2, #1680]	; 0x690
      at_context[idx].p_rsp_buf = NULL;
 800b8a2:	f8c2 1694 	str.w	r1, [r2, #1684]	; 0x694
      at_context[idx].s_SendConfirm_SemaphoreId = NULL;
 800b8a6:	f8c2 1698 	str.w	r1, [r2, #1688]	; 0x698
      (void) memset((void *)&at_context[idx].parser, 0, sizeof(atparser_context_t));
 800b8aa:	3310      	adds	r3, #16
 800b8ac:	f44f 62d0 	mov.w	r2, #1664	; 0x680
 800b8b0:	4418      	add	r0, r3
 800b8b2:	f01a fa50 	bl	8025d56 <memset>
    for (idx = 0; idx < ATCORE_MAX_HANDLES; idx++)
 800b8b6:	3401      	adds	r4, #1
 800b8b8:	b224      	sxth	r4, r4
 800b8ba:	2c00      	cmp	r4, #0
 800b8bc:	dddc      	ble.n	800b878 <AT_init+0x18>
    AT_Core_initialized = 1U;
 800b8be:	4b03      	ldr	r3, [pc, #12]	; (800b8cc <AT_init+0x6c>)
 800b8c0:	2201      	movs	r2, #1
 800b8c2:	701a      	strb	r2, [r3, #0]
    retval = ATSTATUS_OK;
 800b8c4:	2400      	movs	r4, #0
 800b8c6:	e7d5      	b.n	800b874 <AT_init+0x14>
    for (idx = 0; idx < ATCORE_MAX_HANDLES; idx++)
 800b8c8:	2400      	movs	r4, #0
 800b8ca:	e7f6      	b.n	800b8ba <AT_init+0x5a>
 800b8cc:	20001884 	.word	0x20001884
 800b8d0:	20001888 	.word	0x20001888
 800b8d4:	20003540 	.word	0x20003540
 800b8d8:	2000188c 	.word	0x2000188c

0800b8dc <AT_open>:
{
 800b8dc:	b570      	push	{r4, r5, r6, lr}
 800b8de:	b082      	sub	sp, #8
 800b8e0:	4604      	mov	r4, r0
 800b8e2:	4615      	mov	r5, r2
  if (ATParser_initParsers(p_device_infos->type) != ATSTATUS_OK)
 800b8e4:	7800      	ldrb	r0, [r0, #0]
 800b8e6:	f009 f801 	bl	80148ec <ATParser_initParsers>
 800b8ea:	b318      	cbz	r0, 800b934 <AT_open+0x58>
    affectedHandle = AT_HANDLE_INVALID;
 800b8ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b8f0:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (affectedHandle != AT_HANDLE_INVALID)
 800b8f4:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b8f8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b8fc:	d016      	beq.n	800b92c <AT_open+0x50>
    at_context[affectedHandle].ipc_handle = &ipcHandleTab[affectedHandle];
 800b8fe:	ebc3 2103 	rsb	r1, r3, r3, lsl #8
 800b902:	4a30      	ldr	r2, [pc, #192]	; (800b9c4 <AT_open+0xe8>)
 800b904:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800b908:	4e2f      	ldr	r6, [pc, #188]	; (800b9c8 <AT_open+0xec>)
 800b90a:	f240 619c 	movw	r1, #1692	; 0x69c
 800b90e:	fb03 f101 	mul.w	r1, r3, r1
 800b912:	1870      	adds	r0, r6, r1
 800b914:	6042      	str	r2, [r0, #4]
    at_context[affectedHandle].device_type = p_device_infos->type;
 800b916:	7822      	ldrb	r2, [r4, #0]
 800b918:	5472      	strb	r2, [r6, r1]
    at_context[affectedHandle].ipc_device  = p_device_infos->ipc_device;
 800b91a:	7862      	ldrb	r2, [r4, #1]
 800b91c:	7202      	strb	r2, [r0, #8]
    if (p_device_infos->ipc_interface == IPC_INTERFACE_UART)
 800b91e:	78a2      	ldrb	r2, [r4, #2]
 800b920:	2a01      	cmp	r2, #1
 800b922:	d012      	beq.n	800b94a <AT_open+0x6e>
      affectedHandle = AT_HANDLE_INVALID;
 800b924:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b928:	f8ad 3006 	strh.w	r3, [sp, #6]
}
 800b92c:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
 800b930:	b002      	add	sp, #8
 800b932:	bd70      	pop	{r4, r5, r6, pc}
  else if (allocate_ATHandle(&affectedHandle) != ATSTATUS_OK)
 800b934:	f10d 0006 	add.w	r0, sp, #6
 800b938:	f7ff f8da 	bl	800aaf0 <allocate_ATHandle>
 800b93c:	2800      	cmp	r0, #0
 800b93e:	d0d9      	beq.n	800b8f4 <AT_open+0x18>
    affectedHandle = AT_HANDLE_INVALID;
 800b940:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b944:	f8ad 3006 	strh.w	r3, [sp, #6]
 800b948:	e7d4      	b.n	800b8f4 <AT_open+0x18>
      at_context[affectedHandle].ipc_mode = IPC_MODE_UART_CHARACTER;
 800b94a:	4604      	mov	r4, r0
 800b94c:	2300      	movs	r3, #0
 800b94e:	7243      	strb	r3, [r0, #9]
      at_context[affectedHandle].in_data_mode = AT_FALSE;
 800b950:	7283      	strb	r3, [r0, #10]
      at_context[affectedHandle].processing_cmd = 0U;
 800b952:	72c3      	strb	r3, [r0, #11]
      at_context[affectedHandle].dataSent = AT_FALSE;
 800b954:	7303      	strb	r3, [r0, #12]
        rtosalSemaphoreNew((const rtosal_char_t *)"ATCORE_SEM_SEND",
 800b956:	2101      	movs	r1, #1
 800b958:	481c      	ldr	r0, [pc, #112]	; (800b9cc <AT_open+0xf0>)
 800b95a:	f013 fad8 	bl	801ef0e <rtosalSemaphoreNew>
      at_context[affectedHandle].s_SendConfirm_SemaphoreId =
 800b95e:	f8c4 0698 	str.w	r0, [r4, #1688]	; 0x698
      if (at_context[affectedHandle].s_SendConfirm_SemaphoreId != NULL)
 800b962:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b966:	b180      	cbz	r0, 800b98a <AT_open+0xae>
        (void) rtosalSemaphoreAcquire(at_context[affectedHandle].s_SendConfirm_SemaphoreId, 5000U);
 800b968:	f241 3188 	movw	r1, #5000	; 0x1388
 800b96c:	f013 fad9 	bl	801ef22 <rtosalSemaphoreAcquire>
        register_URC_callback[affectedHandle] = urc_callback;
 800b970:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b974:	4a16      	ldr	r2, [pc, #88]	; (800b9d0 <AT_open+0xf4>)
 800b976:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
        ATParser_init(&at_context[affectedHandle], &custom_checkEndOfMsgCallback);
 800b97a:	4916      	ldr	r1, [pc, #88]	; (800b9d4 <AT_open+0xf8>)
 800b97c:	f240 609c 	movw	r0, #1692	; 0x69c
 800b980:	fb00 6003 	mla	r0, r0, r3, r6
 800b984:	f008 ffb6 	bl	80148f4 <ATParser_init>
 800b988:	e7d0      	b.n	800b92c <AT_open+0x50>
        TRACE_ERR("SendSemaphoreId creation error for handle = %d", affectedHandle)
 800b98a:	4c13      	ldr	r4, [pc, #76]	; (800b9d8 <AT_open+0xfc>)
 800b98c:	4913      	ldr	r1, [pc, #76]	; (800b9dc <AT_open+0x100>)
 800b98e:	4620      	mov	r0, r4
 800b990:	f01a f96e 	bl	8025c70 <sprintf>
 800b994:	4620      	mov	r0, r4
 800b996:	f013 fbbc 	bl	801f112 <crs_strlen>
 800b99a:	b283      	uxth	r3, r0
 800b99c:	4622      	mov	r2, r4
 800b99e:	2110      	movs	r1, #16
 800b9a0:	2002      	movs	r0, #2
 800b9a2:	f013 fbf9 	bl	801f198 <traceIF_itmPrint>
 800b9a6:	4620      	mov	r0, r4
 800b9a8:	f013 fbb3 	bl	801f112 <crs_strlen>
 800b9ac:	b283      	uxth	r3, r0
 800b9ae:	4622      	mov	r2, r4
 800b9b0:	2110      	movs	r1, #16
 800b9b2:	2002      	movs	r0, #2
 800b9b4:	f013 fc12 	bl	801f1dc <traceIF_uartPrint>
        affectedHandle = AT_HANDLE_INVALID;
 800b9b8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b9bc:	f8ad 3006 	strh.w	r3, [sp, #6]
 800b9c0:	e7b4      	b.n	800b92c <AT_open+0x50>
 800b9c2:	bf00      	nop
 800b9c4:	20002570 	.word	0x20002570
 800b9c8:	2000188c 	.word	0x2000188c
 800b9cc:	0802d59c 	.word	0x0802d59c
 800b9d0:	20003540 	.word	0x20003540
 800b9d4:	2000256c 	.word	0x2000256c
 800b9d8:	200048dc 	.word	0x200048dc
 800b9dc:	0802d5ac 	.word	0x0802d5ac

0800b9e0 <AT_open_channel>:
{
 800b9e0:	b570      	push	{r4, r5, r6, lr}
 800b9e2:	b082      	sub	sp, #8
  if (athandle != AT_HANDLE_INVALID)
 800b9e4:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b9e8:	d063      	beq.n	800bab2 <AT_open_channel+0xd2>
    at_context[athandle].in_data_mode = AT_FALSE;
 800b9ea:	4c46      	ldr	r4, [pc, #280]	; (800bb04 <AT_open_channel+0x124>)
 800b9ec:	f240 639c 	movw	r3, #1692	; 0x69c
 800b9f0:	fb03 4400 	mla	r4, r3, r0, r4
 800b9f4:	2300      	movs	r3, #0
 800b9f6:	72a3      	strb	r3, [r4, #10]
    at_context[athandle].processing_cmd = 0U;
 800b9f8:	72e3      	strb	r3, [r4, #11]
    at_context[athandle].dataSent = AT_FALSE;
 800b9fa:	7323      	strb	r3, [r4, #12]
    at_context[athandle].action_flags = ATACTION_RSP_NO_ACTION;
 800b9fc:	f8a4 3690 	strh.w	r3, [r4, #1680]	; 0x690
    if (IPC_open(at_context[athandle].ipc_handle,
 800ba00:	4b41      	ldr	r3, [pc, #260]	; (800bb08 <AT_open_channel+0x128>)
 800ba02:	681b      	ldr	r3, [r3, #0]
 800ba04:	9301      	str	r3, [sp, #4]
 800ba06:	4b41      	ldr	r3, [pc, #260]	; (800bb0c <AT_open_channel+0x12c>)
 800ba08:	9300      	str	r3, [sp, #0]
 800ba0a:	4b41      	ldr	r3, [pc, #260]	; (800bb10 <AT_open_channel+0x130>)
 800ba0c:	7a62      	ldrb	r2, [r4, #9]
 800ba0e:	7a21      	ldrb	r1, [r4, #8]
 800ba10:	6860      	ldr	r0, [r4, #4]
 800ba12:	f012 fc63 	bl	801e2dc <IPC_open>
 800ba16:	bb58      	cbnz	r0, 800ba70 <AT_open_channel+0x90>
      if (IPC_select(at_context[athandle].ipc_handle) == IPC_OK)
 800ba18:	6860      	ldr	r0, [r4, #4]
 800ba1a:	f012 fca0 	bl	801e35e <IPC_select>
 800ba1e:	2800      	cmp	r0, #0
 800ba20:	d06d      	beq.n	800bafe <AT_open_channel+0x11e>
        TRACE_ERR("IPC selection error")
 800ba22:	4e3c      	ldr	r6, [pc, #240]	; (800bb14 <AT_open_channel+0x134>)
 800ba24:	4c3c      	ldr	r4, [pc, #240]	; (800bb18 <AT_open_channel+0x138>)
 800ba26:	f106 0c20 	add.w	ip, r6, #32
 800ba2a:	4635      	mov	r5, r6
 800ba2c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ba2e:	6020      	str	r0, [r4, #0]
 800ba30:	6061      	str	r1, [r4, #4]
 800ba32:	60a2      	str	r2, [r4, #8]
 800ba34:	60e3      	str	r3, [r4, #12]
 800ba36:	462e      	mov	r6, r5
 800ba38:	3410      	adds	r4, #16
 800ba3a:	4565      	cmp	r5, ip
 800ba3c:	d1f5      	bne.n	800ba2a <AT_open_channel+0x4a>
 800ba3e:	882a      	ldrh	r2, [r5, #0]
 800ba40:	78ab      	ldrb	r3, [r5, #2]
 800ba42:	8022      	strh	r2, [r4, #0]
 800ba44:	70a3      	strb	r3, [r4, #2]
 800ba46:	4c34      	ldr	r4, [pc, #208]	; (800bb18 <AT_open_channel+0x138>)
 800ba48:	4620      	mov	r0, r4
 800ba4a:	f013 fb62 	bl	801f112 <crs_strlen>
 800ba4e:	b283      	uxth	r3, r0
 800ba50:	4622      	mov	r2, r4
 800ba52:	2110      	movs	r1, #16
 800ba54:	2002      	movs	r0, #2
 800ba56:	f013 fb9f 	bl	801f198 <traceIF_itmPrint>
 800ba5a:	4620      	mov	r0, r4
 800ba5c:	f013 fb59 	bl	801f112 <crs_strlen>
 800ba60:	b283      	uxth	r3, r0
 800ba62:	4622      	mov	r2, r4
 800ba64:	2110      	movs	r1, #16
 800ba66:	2002      	movs	r0, #2
 800ba68:	f013 fbb8 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800ba6c:	2001      	movs	r0, #1
 800ba6e:	e046      	b.n	800bafe <AT_open_channel+0x11e>
      TRACE_ERR("IPC open error")
 800ba70:	4c29      	ldr	r4, [pc, #164]	; (800bb18 <AT_open_channel+0x138>)
 800ba72:	4d2a      	ldr	r5, [pc, #168]	; (800bb1c <AT_open_channel+0x13c>)
 800ba74:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ba76:	6020      	str	r0, [r4, #0]
 800ba78:	6061      	str	r1, [r4, #4]
 800ba7a:	60a2      	str	r2, [r4, #8]
 800ba7c:	60e3      	str	r3, [r4, #12]
 800ba7e:	cd07      	ldmia	r5!, {r0, r1, r2}
 800ba80:	6120      	str	r0, [r4, #16]
 800ba82:	6161      	str	r1, [r4, #20]
 800ba84:	61a2      	str	r2, [r4, #24]
 800ba86:	882b      	ldrh	r3, [r5, #0]
 800ba88:	83a3      	strh	r3, [r4, #28]
 800ba8a:	4620      	mov	r0, r4
 800ba8c:	f013 fb41 	bl	801f112 <crs_strlen>
 800ba90:	b283      	uxth	r3, r0
 800ba92:	4622      	mov	r2, r4
 800ba94:	2110      	movs	r1, #16
 800ba96:	2002      	movs	r0, #2
 800ba98:	f013 fb7e 	bl	801f198 <traceIF_itmPrint>
 800ba9c:	4620      	mov	r0, r4
 800ba9e:	f013 fb38 	bl	801f112 <crs_strlen>
 800baa2:	b283      	uxth	r3, r0
 800baa4:	4622      	mov	r2, r4
 800baa6:	2110      	movs	r1, #16
 800baa8:	2002      	movs	r0, #2
 800baaa:	f013 fb97 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800baae:	2001      	movs	r0, #1
 800bab0:	e025      	b.n	800bafe <AT_open_channel+0x11e>
    TRACE_ERR("IPC invalid handle")
 800bab2:	4d1b      	ldr	r5, [pc, #108]	; (800bb20 <AT_open_channel+0x140>)
 800bab4:	4c18      	ldr	r4, [pc, #96]	; (800bb18 <AT_open_channel+0x138>)
 800bab6:	f105 0620 	add.w	r6, r5, #32
 800baba:	46ac      	mov	ip, r5
 800babc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bac0:	6020      	str	r0, [r4, #0]
 800bac2:	6061      	str	r1, [r4, #4]
 800bac4:	60a2      	str	r2, [r4, #8]
 800bac6:	60e3      	str	r3, [r4, #12]
 800bac8:	4665      	mov	r5, ip
 800baca:	3410      	adds	r4, #16
 800bacc:	45b4      	cmp	ip, r6
 800bace:	d1f4      	bne.n	800baba <AT_open_channel+0xda>
 800bad0:	f8bc 3000 	ldrh.w	r3, [ip]
 800bad4:	8023      	strh	r3, [r4, #0]
 800bad6:	4c10      	ldr	r4, [pc, #64]	; (800bb18 <AT_open_channel+0x138>)
 800bad8:	4620      	mov	r0, r4
 800bada:	f013 fb1a 	bl	801f112 <crs_strlen>
 800bade:	b283      	uxth	r3, r0
 800bae0:	4622      	mov	r2, r4
 800bae2:	2110      	movs	r1, #16
 800bae4:	2002      	movs	r0, #2
 800bae6:	f013 fb57 	bl	801f198 <traceIF_itmPrint>
 800baea:	4620      	mov	r0, r4
 800baec:	f013 fb11 	bl	801f112 <crs_strlen>
 800baf0:	b283      	uxth	r3, r0
 800baf2:	4622      	mov	r2, r4
 800baf4:	2110      	movs	r1, #16
 800baf6:	2002      	movs	r0, #2
 800baf8:	f013 fb70 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800bafc:	2001      	movs	r0, #1
}
 800bafe:	b002      	add	sp, #8
 800bb00:	bd70      	pop	{r4, r5, r6, pc}
 800bb02:	bf00      	nop
 800bb04:	2000188c 	.word	0x2000188c
 800bb08:	2000256c 	.word	0x2000256c
 800bb0c:	0800ac61 	.word	0x0800ac61
 800bb10:	0800ac85 	.word	0x0800ac85
 800bb14:	0802d5ec 	.word	0x0802d5ec
 800bb18:	200048dc 	.word	0x200048dc
 800bb1c:	0802d610 	.word	0x0802d610
 800bb20:	0802d630 	.word	0x0802d630

0800bb24 <AT_close_channel>:
{
 800bb24:	b538      	push	{r3, r4, r5, lr}
  if (athandle != AT_HANDLE_INVALID)
 800bb26:	f1b0 3fff 	cmp.w	r0, #4294967295
 800bb2a:	d02c      	beq.n	800bb86 <AT_close_channel+0x62>
    if (IPC_close(at_context[athandle].ipc_handle) == IPC_OK)
 800bb2c:	4b29      	ldr	r3, [pc, #164]	; (800bbd4 <AT_close_channel+0xb0>)
 800bb2e:	f240 629c 	movw	r2, #1692	; 0x69c
 800bb32:	fb02 3300 	mla	r3, r2, r0, r3
 800bb36:	6858      	ldr	r0, [r3, #4]
 800bb38:	f012 fbfc 	bl	801e334 <IPC_close>
 800bb3c:	b900      	cbnz	r0, 800bb40 <AT_close_channel+0x1c>
}
 800bb3e:	bd38      	pop	{r3, r4, r5, pc}
      TRACE_ERR("IPC close error")
 800bb40:	4c25      	ldr	r4, [pc, #148]	; (800bbd8 <AT_close_channel+0xb4>)
 800bb42:	4d26      	ldr	r5, [pc, #152]	; (800bbdc <AT_close_channel+0xb8>)
 800bb44:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800bb46:	6020      	str	r0, [r4, #0]
 800bb48:	6061      	str	r1, [r4, #4]
 800bb4a:	60a2      	str	r2, [r4, #8]
 800bb4c:	60e3      	str	r3, [r4, #12]
 800bb4e:	cd07      	ldmia	r5!, {r0, r1, r2}
 800bb50:	6120      	str	r0, [r4, #16]
 800bb52:	6161      	str	r1, [r4, #20]
 800bb54:	61a2      	str	r2, [r4, #24]
 800bb56:	882a      	ldrh	r2, [r5, #0]
 800bb58:	78ab      	ldrb	r3, [r5, #2]
 800bb5a:	83a2      	strh	r2, [r4, #28]
 800bb5c:	77a3      	strb	r3, [r4, #30]
 800bb5e:	4620      	mov	r0, r4
 800bb60:	f013 fad7 	bl	801f112 <crs_strlen>
 800bb64:	b283      	uxth	r3, r0
 800bb66:	4622      	mov	r2, r4
 800bb68:	2110      	movs	r1, #16
 800bb6a:	2002      	movs	r0, #2
 800bb6c:	f013 fb14 	bl	801f198 <traceIF_itmPrint>
 800bb70:	4620      	mov	r0, r4
 800bb72:	f013 face 	bl	801f112 <crs_strlen>
 800bb76:	b283      	uxth	r3, r0
 800bb78:	4622      	mov	r2, r4
 800bb7a:	2110      	movs	r1, #16
 800bb7c:	2002      	movs	r0, #2
 800bb7e:	f013 fb2d 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800bb82:	2001      	movs	r0, #1
 800bb84:	e7db      	b.n	800bb3e <AT_close_channel+0x1a>
    TRACE_ERR("IPC invalid handle")
 800bb86:	4d16      	ldr	r5, [pc, #88]	; (800bbe0 <AT_close_channel+0xbc>)
 800bb88:	4c13      	ldr	r4, [pc, #76]	; (800bbd8 <AT_close_channel+0xb4>)
 800bb8a:	f105 0e20 	add.w	lr, r5, #32
 800bb8e:	46ac      	mov	ip, r5
 800bb90:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bb94:	6020      	str	r0, [r4, #0]
 800bb96:	6061      	str	r1, [r4, #4]
 800bb98:	60a2      	str	r2, [r4, #8]
 800bb9a:	60e3      	str	r3, [r4, #12]
 800bb9c:	4665      	mov	r5, ip
 800bb9e:	3410      	adds	r4, #16
 800bba0:	45f4      	cmp	ip, lr
 800bba2:	d1f4      	bne.n	800bb8e <AT_close_channel+0x6a>
 800bba4:	f8bc 3000 	ldrh.w	r3, [ip]
 800bba8:	8023      	strh	r3, [r4, #0]
 800bbaa:	4c0b      	ldr	r4, [pc, #44]	; (800bbd8 <AT_close_channel+0xb4>)
 800bbac:	4620      	mov	r0, r4
 800bbae:	f013 fab0 	bl	801f112 <crs_strlen>
 800bbb2:	b283      	uxth	r3, r0
 800bbb4:	4622      	mov	r2, r4
 800bbb6:	2110      	movs	r1, #16
 800bbb8:	2002      	movs	r0, #2
 800bbba:	f013 faed 	bl	801f198 <traceIF_itmPrint>
 800bbbe:	4620      	mov	r0, r4
 800bbc0:	f013 faa7 	bl	801f112 <crs_strlen>
 800bbc4:	b283      	uxth	r3, r0
 800bbc6:	4622      	mov	r2, r4
 800bbc8:	2110      	movs	r1, #16
 800bbca:	2002      	movs	r0, #2
 800bbcc:	f013 fb06 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800bbd0:	2001      	movs	r0, #1
 800bbd2:	e7b4      	b.n	800bb3e <AT_close_channel+0x1a>
 800bbd4:	2000188c 	.word	0x2000188c
 800bbd8:	200048dc 	.word	0x200048dc
 800bbdc:	0802d654 	.word	0x0802d654
 800bbe0:	0802d630 	.word	0x0802d630

0800bbe4 <AT_sendcmd>:
{
 800bbe4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (athandle == AT_HANDLE_INVALID)
 800bbe8:	f1b0 3fff 	cmp.w	r0, #4294967295
 800bbec:	d05f      	beq.n	800bcae <AT_sendcmd+0xca>
 800bbee:	4604      	mov	r4, r0
 800bbf0:	460e      	mov	r6, r1
 800bbf2:	4617      	mov	r7, r2
 800bbf4:	461d      	mov	r5, r3
    if (at_context[athandle].processing_cmd == 1U)
 800bbf6:	4b96      	ldr	r3, [pc, #600]	; (800be50 <AT_sendcmd+0x26c>)
 800bbf8:	f240 629c 	movw	r2, #1692	; 0x69c
 800bbfc:	fb02 3300 	mla	r3, r2, r0, r3
 800bc00:	f893 800b 	ldrb.w	r8, [r3, #11]
 800bc04:	f1b8 0f01 	cmp.w	r8, #1
 800bc08:	d059      	beq.n	800bcbe <AT_sendcmd+0xda>
    (void) memset((void *)p_rsp_buf, 0, ATCMD_MAX_BUF_SIZE);
 800bc0a:	2280      	movs	r2, #128	; 0x80
 800bc0c:	2100      	movs	r1, #0
 800bc0e:	4628      	mov	r0, r5
 800bc10:	f01a f8a1 	bl	8025d56 <memset>
    at_context[athandle].processing_cmd = 1U;
 800bc14:	4b8e      	ldr	r3, [pc, #568]	; (800be50 <AT_sendcmd+0x26c>)
 800bc16:	f240 629c 	movw	r2, #1692	; 0x69c
 800bc1a:	fb02 3304 	mla	r3, r2, r4, r3
 800bc1e:	2201      	movs	r2, #1
 800bc20:	72da      	strb	r2, [r3, #11]
    at_context[athandle].p_rsp_buf = p_rsp_buf;
 800bc22:	f8c3 5694 	str.w	r5, [r3, #1684]	; 0x694
    if (at_context[athandle].in_data_mode == AT_TRUE)
 800bc26:	7a9b      	ldrb	r3, [r3, #10]
 800bc28:	2b00      	cmp	r3, #0
 800bc2a:	d066      	beq.n	800bcfa <AT_sendcmd+0x116>
      if (msg_in_id == (at_msg_t) SID_CS_DATA_SUSPEND)
 800bc2c:	2e7e      	cmp	r6, #126	; 0x7e
 800bc2e:	d166      	bne.n	800bcfe <AT_sendcmd+0x11a>
        TRACE_DBG("<<< restore IPC COMMAND channel >>>")
 800bc30:	f8df e230 	ldr.w	lr, [pc, #560]	; 800be64 <AT_sendcmd+0x280>
 800bc34:	f8df c21c 	ldr.w	ip, [pc, #540]	; 800be54 <AT_sendcmd+0x270>
 800bc38:	f10e 0920 	add.w	r9, lr, #32
 800bc3c:	46f0      	mov	r8, lr
 800bc3e:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 800bc42:	f8cc 0000 	str.w	r0, [ip]
 800bc46:	f8cc 1004 	str.w	r1, [ip, #4]
 800bc4a:	f8cc 2008 	str.w	r2, [ip, #8]
 800bc4e:	f8cc 300c 	str.w	r3, [ip, #12]
 800bc52:	46c6      	mov	lr, r8
 800bc54:	f10c 0c10 	add.w	ip, ip, #16
 800bc58:	45c8      	cmp	r8, r9
 800bc5a:	d1ef      	bne.n	800bc3c <AT_sendcmd+0x58>
 800bc5c:	e8be 0007 	ldmia.w	lr!, {r0, r1, r2}
 800bc60:	f8cc 0000 	str.w	r0, [ip]
 800bc64:	f8cc 1004 	str.w	r1, [ip, #4]
 800bc68:	f8cc 2008 	str.w	r2, [ip, #8]
 800bc6c:	f89e 3000 	ldrb.w	r3, [lr]
 800bc70:	f88c 300c 	strb.w	r3, [ip, #12]
 800bc74:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 800be54 <AT_sendcmd+0x270>
 800bc78:	4640      	mov	r0, r8
 800bc7a:	f013 fa4a 	bl	801f112 <crs_strlen>
 800bc7e:	b283      	uxth	r3, r0
 800bc80:	4642      	mov	r2, r8
 800bc82:	2102      	movs	r1, #2
 800bc84:	4608      	mov	r0, r1
 800bc86:	f013 fa87 	bl	801f198 <traceIF_itmPrint>
 800bc8a:	4640      	mov	r0, r8
 800bc8c:	f013 fa41 	bl	801f112 <crs_strlen>
 800bc90:	b283      	uxth	r3, r0
 800bc92:	4642      	mov	r2, r8
 800bc94:	2102      	movs	r1, #2
 800bc96:	4608      	mov	r0, r1
 800bc98:	f013 faa0 	bl	801f1dc <traceIF_uartPrint>
        (void) IPC_select(at_context[athandle].ipc_handle);
 800bc9c:	4b6c      	ldr	r3, [pc, #432]	; (800be50 <AT_sendcmd+0x26c>)
 800bc9e:	f240 629c 	movw	r2, #1692	; 0x69c
 800bca2:	fb02 3304 	mla	r3, r2, r4, r3
 800bca6:	6858      	ldr	r0, [r3, #4]
 800bca8:	f012 fb59 	bl	801e35e <IPC_select>
 800bcac:	e027      	b.n	800bcfe <AT_sendcmd+0x11a>
    LOG_ERROR(21, ERROR_WARNING);
 800bcae:	2202      	movs	r2, #2
 800bcb0:	2115      	movs	r1, #21
 800bcb2:	4610      	mov	r0, r2
 800bcb4:	f012 fa4a 	bl	801e14c <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800bcb8:	f04f 0801 	mov.w	r8, #1
 800bcbc:	e03b      	b.n	800bd36 <AT_sendcmd+0x152>
      TRACE_ERR("!!!!!!!!!!!!!!!!!! WARNING COMMAND IS UNDER PROCESS !!!!!!!!!!!!!!!!!!")
 800bcbe:	4d65      	ldr	r5, [pc, #404]	; (800be54 <AT_sendcmd+0x270>)
 800bcc0:	2256      	movs	r2, #86	; 0x56
 800bcc2:	4965      	ldr	r1, [pc, #404]	; (800be58 <AT_sendcmd+0x274>)
 800bcc4:	4628      	mov	r0, r5
 800bcc6:	f01a f923 	bl	8025f10 <memcpy>
 800bcca:	4628      	mov	r0, r5
 800bccc:	f013 fa21 	bl	801f112 <crs_strlen>
 800bcd0:	b283      	uxth	r3, r0
 800bcd2:	462a      	mov	r2, r5
 800bcd4:	2110      	movs	r1, #16
 800bcd6:	2002      	movs	r0, #2
 800bcd8:	f013 fa5e 	bl	801f198 <traceIF_itmPrint>
 800bcdc:	4628      	mov	r0, r5
 800bcde:	f013 fa18 	bl	801f112 <crs_strlen>
 800bce2:	b283      	uxth	r3, r0
 800bce4:	462a      	mov	r2, r5
 800bce6:	2110      	movs	r1, #16
 800bce8:	2002      	movs	r0, #2
 800bcea:	f013 fa77 	bl	801f1dc <traceIF_uartPrint>
      LOG_ERROR(2, ERROR_WARNING);
 800bcee:	2202      	movs	r2, #2
 800bcf0:	4611      	mov	r1, r2
 800bcf2:	4610      	mov	r0, r2
 800bcf4:	f012 fa2a 	bl	801e14c <ERROR_Handler>
      goto exit_func;
 800bcf8:	e016      	b.n	800bd28 <AT_sendcmd+0x144>
    else if (msg_in_id == (at_msg_t) SID_CS_DATA_SUSPEND)
 800bcfa:	2e7e      	cmp	r6, #126	; 0x7e
 800bcfc:	d01e      	beq.n	800bd3c <AT_sendcmd+0x158>
    ATParser_process_request(&at_context[athandle], msg_in_id, p_cmd_in_buf);
 800bcfe:	4b54      	ldr	r3, [pc, #336]	; (800be50 <AT_sendcmd+0x26c>)
 800bd00:	f240 629c 	movw	r2, #1692	; 0x69c
 800bd04:	fb02 3904 	mla	r9, r2, r4, r3
 800bd08:	463a      	mov	r2, r7
 800bd0a:	4631      	mov	r1, r6
 800bd0c:	4648      	mov	r0, r9
 800bd0e:	f008 fe0b 	bl	8014928 <ATParser_process_request>
    retval = process_AT_transaction(athandle, msg_in_id, p_rsp_buf);
 800bd12:	462a      	mov	r2, r5
 800bd14:	4631      	mov	r1, r6
 800bd16:	4620      	mov	r0, r4
 800bd18:	f7ff f918 	bl	800af4c <process_AT_transaction>
    if (retval != ATSTATUS_OK)
 800bd1c:	4680      	mov	r8, r0
 800bd1e:	bbb0      	cbnz	r0, 800bd8e <AT_sendcmd+0x1aa>
    (void) ATParser_get_rsp(&at_context[athandle], p_rsp_buf);
 800bd20:	4629      	mov	r1, r5
 800bd22:	4648      	mov	r0, r9
 800bd24:	f008 ff84 	bl	8014c30 <ATParser_get_rsp>
    at_context[athandle].processing_cmd = 0U;
 800bd28:	4b49      	ldr	r3, [pc, #292]	; (800be50 <AT_sendcmd+0x26c>)
 800bd2a:	f240 629c 	movw	r2, #1692	; 0x69c
 800bd2e:	fb02 3304 	mla	r3, r2, r4, r3
 800bd32:	2200      	movs	r2, #0
 800bd34:	72da      	strb	r2, [r3, #11]
}
 800bd36:	4640      	mov	r0, r8
 800bd38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      LOG_ERROR(3, ERROR_WARNING);
 800bd3c:	2202      	movs	r2, #2
 800bd3e:	2103      	movs	r1, #3
 800bd40:	4610      	mov	r0, r2
 800bd42:	f012 fa03 	bl	801e14c <ERROR_Handler>
      TRACE_ERR("DATA not active")
 800bd46:	4d43      	ldr	r5, [pc, #268]	; (800be54 <AT_sendcmd+0x270>)
 800bd48:	4e44      	ldr	r6, [pc, #272]	; (800be5c <AT_sendcmd+0x278>)
 800bd4a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800bd4c:	6028      	str	r0, [r5, #0]
 800bd4e:	6069      	str	r1, [r5, #4]
 800bd50:	60aa      	str	r2, [r5, #8]
 800bd52:	60eb      	str	r3, [r5, #12]
 800bd54:	ce07      	ldmia	r6!, {r0, r1, r2}
 800bd56:	6128      	str	r0, [r5, #16]
 800bd58:	6169      	str	r1, [r5, #20]
 800bd5a:	61aa      	str	r2, [r5, #24]
 800bd5c:	8832      	ldrh	r2, [r6, #0]
 800bd5e:	78b3      	ldrb	r3, [r6, #2]
 800bd60:	83aa      	strh	r2, [r5, #28]
 800bd62:	77ab      	strb	r3, [r5, #30]
 800bd64:	4628      	mov	r0, r5
 800bd66:	f013 f9d4 	bl	801f112 <crs_strlen>
 800bd6a:	b283      	uxth	r3, r0
 800bd6c:	462a      	mov	r2, r5
 800bd6e:	2110      	movs	r1, #16
 800bd70:	2002      	movs	r0, #2
 800bd72:	f013 fa11 	bl	801f198 <traceIF_itmPrint>
 800bd76:	4628      	mov	r0, r5
 800bd78:	f013 f9cb 	bl	801f112 <crs_strlen>
 800bd7c:	b283      	uxth	r3, r0
 800bd7e:	462a      	mov	r2, r5
 800bd80:	2110      	movs	r1, #16
 800bd82:	2002      	movs	r0, #2
 800bd84:	f013 fa2a 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800bd88:	f04f 0801 	mov.w	r8, #1
      goto exit_func;
 800bd8c:	e7cc      	b.n	800bd28 <AT_sendcmd+0x144>
      TRACE_DBG("AT_sendcmd error: process AT transaction")
 800bd8e:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 800be68 <AT_sendcmd+0x284>
 800bd92:	4f30      	ldr	r7, [pc, #192]	; (800be54 <AT_sendcmd+0x270>)
 800bd94:	f10e 0a30 	add.w	sl, lr, #48	; 0x30
 800bd98:	46f4      	mov	ip, lr
 800bd9a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bd9e:	6038      	str	r0, [r7, #0]
 800bda0:	6079      	str	r1, [r7, #4]
 800bda2:	60ba      	str	r2, [r7, #8]
 800bda4:	60fb      	str	r3, [r7, #12]
 800bda6:	46e6      	mov	lr, ip
 800bda8:	3710      	adds	r7, #16
 800bdaa:	45d4      	cmp	ip, sl
 800bdac:	d1f4      	bne.n	800bd98 <AT_sendcmd+0x1b4>
 800bdae:	f8bc 3000 	ldrh.w	r3, [ip]
 800bdb2:	803b      	strh	r3, [r7, #0]
 800bdb4:	4f27      	ldr	r7, [pc, #156]	; (800be54 <AT_sendcmd+0x270>)
 800bdb6:	4638      	mov	r0, r7
 800bdb8:	f013 f9ab 	bl	801f112 <crs_strlen>
 800bdbc:	b283      	uxth	r3, r0
 800bdbe:	463a      	mov	r2, r7
 800bdc0:	2102      	movs	r1, #2
 800bdc2:	4608      	mov	r0, r1
 800bdc4:	f013 f9e8 	bl	801f198 <traceIF_itmPrint>
 800bdc8:	4638      	mov	r0, r7
 800bdca:	f013 f9a2 	bl	801f112 <crs_strlen>
 800bdce:	b283      	uxth	r3, r0
 800bdd0:	463a      	mov	r2, r7
 800bdd2:	2102      	movs	r1, #2
 800bdd4:	4608      	mov	r0, r1
 800bdd6:	f013 fa01 	bl	801f1dc <traceIF_uartPrint>
      (void) ATParser_get_error(&at_context[athandle], p_rsp_buf);
 800bdda:	4629      	mov	r1, r5
 800bddc:	4648      	mov	r0, r9
 800bdde:	f008 ff36 	bl	8014c4e <ATParser_get_error>
      ATParser_abort_request(&at_context[athandle]);
 800bde2:	4648      	mov	r0, r9
 800bde4:	f008 ff37 	bl	8014c56 <ATParser_abort_request>
      if (msg_in_id == (at_msg_t) SID_CS_DATA_SUSPEND)
 800bde8:	2e7e      	cmp	r6, #126	; 0x7e
 800bdea:	d19d      	bne.n	800bd28 <AT_sendcmd+0x144>
        TRACE_ERR("force to return to COMMAND mode")
 800bdec:	4e1c      	ldr	r6, [pc, #112]	; (800be60 <AT_sendcmd+0x27c>)
 800bdee:	463d      	mov	r5, r7
 800bdf0:	f106 0c20 	add.w	ip, r6, #32
 800bdf4:	4637      	mov	r7, r6
 800bdf6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800bdf8:	6028      	str	r0, [r5, #0]
 800bdfa:	6069      	str	r1, [r5, #4]
 800bdfc:	60aa      	str	r2, [r5, #8]
 800bdfe:	60eb      	str	r3, [r5, #12]
 800be00:	463e      	mov	r6, r7
 800be02:	3510      	adds	r5, #16
 800be04:	4567      	cmp	r7, ip
 800be06:	d1f5      	bne.n	800bdf4 <AT_sendcmd+0x210>
 800be08:	ce07      	ldmia	r6!, {r0, r1, r2}
 800be0a:	6028      	str	r0, [r5, #0]
 800be0c:	6069      	str	r1, [r5, #4]
 800be0e:	60aa      	str	r2, [r5, #8]
 800be10:	8832      	ldrh	r2, [r6, #0]
 800be12:	78b3      	ldrb	r3, [r6, #2]
 800be14:	81aa      	strh	r2, [r5, #12]
 800be16:	73ab      	strb	r3, [r5, #14]
 800be18:	4d0e      	ldr	r5, [pc, #56]	; (800be54 <AT_sendcmd+0x270>)
 800be1a:	4628      	mov	r0, r5
 800be1c:	f013 f979 	bl	801f112 <crs_strlen>
 800be20:	b283      	uxth	r3, r0
 800be22:	462a      	mov	r2, r5
 800be24:	2110      	movs	r1, #16
 800be26:	2002      	movs	r0, #2
 800be28:	f013 f9b6 	bl	801f198 <traceIF_itmPrint>
 800be2c:	4628      	mov	r0, r5
 800be2e:	f013 f970 	bl	801f112 <crs_strlen>
 800be32:	b283      	uxth	r3, r0
 800be34:	462a      	mov	r2, r5
 800be36:	2110      	movs	r1, #16
 800be38:	2002      	movs	r0, #2
 800be3a:	f013 f9cf 	bl	801f1dc <traceIF_uartPrint>
        at_context[athandle].in_data_mode = AT_FALSE ;
 800be3e:	4b04      	ldr	r3, [pc, #16]	; (800be50 <AT_sendcmd+0x26c>)
 800be40:	f240 629c 	movw	r2, #1692	; 0x69c
 800be44:	fb02 3304 	mla	r3, r2, r4, r3
 800be48:	2200      	movs	r2, #0
 800be4a:	729a      	strb	r2, [r3, #10]
      goto exit_func;
 800be4c:	e76c      	b.n	800bd28 <AT_sendcmd+0x144>
 800be4e:	bf00      	nop
 800be50:	2000188c 	.word	0x2000188c
 800be54:	200048dc 	.word	0x200048dc
 800be58:	0802d674 	.word	0x0802d674
 800be5c:	0802d6fc 	.word	0x0802d6fc
 800be60:	0802d750 	.word	0x0802d750
 800be64:	0802d6cc 	.word	0x0802d6cc
 800be68:	0802d71c 	.word	0x0802d71c

0800be6c <AT_internalEvent>:
  if (deviceType == DEVTYPE_MODEM_CELLULAR)
 800be6c:	b100      	cbz	r0, 800be70 <AT_internalEvent+0x4>
 800be6e:	4770      	bx	lr
{
 800be70:	b510      	push	{r4, lr}
    if (rtosalMessageQueuePut(q_msg_IPC_received_Id,
 800be72:	2200      	movs	r2, #0
 800be74:	2102      	movs	r1, #2
 800be76:	4b0f      	ldr	r3, [pc, #60]	; (800beb4 <AT_internalEvent+0x48>)
 800be78:	6818      	ldr	r0, [r3, #0]
 800be7a:	f013 f878 	bl	801ef6e <rtosalMessageQueuePut>
 800be7e:	b900      	cbnz	r0, 800be82 <AT_internalEvent+0x16>
}
 800be80:	bd10      	pop	{r4, pc}
      TRACE_ERR("q_msg_IPC_received_Id error for SIG_INTERNAL_EVENT_MODEM")
 800be82:	4c0d      	ldr	r4, [pc, #52]	; (800beb8 <AT_internalEvent+0x4c>)
 800be84:	2248      	movs	r2, #72	; 0x48
 800be86:	490d      	ldr	r1, [pc, #52]	; (800bebc <AT_internalEvent+0x50>)
 800be88:	4620      	mov	r0, r4
 800be8a:	f01a f841 	bl	8025f10 <memcpy>
 800be8e:	4620      	mov	r0, r4
 800be90:	f013 f93f 	bl	801f112 <crs_strlen>
 800be94:	b283      	uxth	r3, r0
 800be96:	4622      	mov	r2, r4
 800be98:	2110      	movs	r1, #16
 800be9a:	2002      	movs	r0, #2
 800be9c:	f013 f97c 	bl	801f198 <traceIF_itmPrint>
 800bea0:	4620      	mov	r0, r4
 800bea2:	f013 f936 	bl	801f112 <crs_strlen>
 800bea6:	b283      	uxth	r3, r0
 800bea8:	4622      	mov	r2, r4
 800beaa:	2110      	movs	r1, #16
 800beac:	2002      	movs	r0, #2
 800beae:	f013 f995 	bl	801f1dc <traceIF_uartPrint>
}
 800beb2:	e7e5      	b.n	800be80 <AT_internalEvent+0x14>
 800beb4:	2000353c 	.word	0x2000353c
 800beb8:	200048dc 	.word	0x200048dc
 800bebc:	0802d780 	.word	0x0802d780

0800bec0 <atcore_task_start>:
{
 800bec0:	b570      	push	{r4, r5, r6, lr}
 800bec2:	b082      	sub	sp, #8
  if (AT_Core_initialized != 1U)
 800bec4:	4c57      	ldr	r4, [pc, #348]	; (800c024 <atcore_task_start+0x164>)
 800bec6:	7824      	ldrb	r4, [r4, #0]
 800bec8:	2c01      	cmp	r4, #1
 800beca:	d02a      	beq.n	800bf22 <atcore_task_start+0x62>
    TRACE_ERR("error, ATCore is not initialized")
 800becc:	4d56      	ldr	r5, [pc, #344]	; (800c028 <atcore_task_start+0x168>)
 800bece:	4c57      	ldr	r4, [pc, #348]	; (800c02c <atcore_task_start+0x16c>)
 800bed0:	f105 0630 	add.w	r6, r5, #48	; 0x30
 800bed4:	46ac      	mov	ip, r5
 800bed6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800beda:	6020      	str	r0, [r4, #0]
 800bedc:	6061      	str	r1, [r4, #4]
 800bede:	60a2      	str	r2, [r4, #8]
 800bee0:	60e3      	str	r3, [r4, #12]
 800bee2:	4665      	mov	r5, ip
 800bee4:	3410      	adds	r4, #16
 800bee6:	45b4      	cmp	ip, r6
 800bee8:	d1f4      	bne.n	800bed4 <atcore_task_start+0x14>
 800beea:	4c50      	ldr	r4, [pc, #320]	; (800c02c <atcore_task_start+0x16c>)
 800beec:	4620      	mov	r0, r4
 800beee:	f013 f910 	bl	801f112 <crs_strlen>
 800bef2:	b283      	uxth	r3, r0
 800bef4:	4622      	mov	r2, r4
 800bef6:	2110      	movs	r1, #16
 800bef8:	2002      	movs	r0, #2
 800befa:	f013 f94d 	bl	801f198 <traceIF_itmPrint>
 800befe:	4620      	mov	r0, r4
 800bf00:	f013 f907 	bl	801f112 <crs_strlen>
 800bf04:	b283      	uxth	r3, r0
 800bf06:	4622      	mov	r2, r4
 800bf08:	2110      	movs	r1, #16
 800bf0a:	2002      	movs	r0, #2
 800bf0c:	f013 f966 	bl	801f1dc <traceIF_uartPrint>
    LOG_ERROR(17, ERROR_WARNING);
 800bf10:	2202      	movs	r2, #2
 800bf12:	2111      	movs	r1, #17
 800bf14:	4610      	mov	r0, r2
 800bf16:	f012 f919 	bl	801e14c <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800bf1a:	2401      	movs	r4, #1
}
 800bf1c:	4620      	mov	r0, r4
 800bf1e:	b002      	add	sp, #8
 800bf20:	bd70      	pop	{r4, r5, r6, pc}
 800bf22:	4606      	mov	r6, r0
 800bf24:	460d      	mov	r5, r1
    s_WaitAnswer_SemaphoreId = rtosalSemaphoreNew((const rtosal_char_t *) "ATCORE_SEM_WAIT_ANSWER",
 800bf26:	2101      	movs	r1, #1
 800bf28:	4841      	ldr	r0, [pc, #260]	; (800c030 <atcore_task_start+0x170>)
 800bf2a:	f012 fff0 	bl	801ef0e <rtosalSemaphoreNew>
 800bf2e:	4b41      	ldr	r3, [pc, #260]	; (800c034 <atcore_task_start+0x174>)
 800bf30:	6018      	str	r0, [r3, #0]
    if (s_WaitAnswer_SemaphoreId == NULL)
 800bf32:	b1b0      	cbz	r0, 800bf62 <atcore_task_start+0xa2>
      (void) rtosalSemaphoreAcquire(s_WaitAnswer_SemaphoreId, 15000U);
 800bf34:	f643 2198 	movw	r1, #15000	; 0x3a98
 800bf38:	f012 fff3 	bl	801ef22 <rtosalSemaphoreAcquire>
      q_msg_IPC_received_Id = rtosalMessageQueueNew((const rtosal_char_t *) "IPC_MSG_RCV",
 800bf3c:	2180      	movs	r1, #128	; 0x80
 800bf3e:	483e      	ldr	r0, [pc, #248]	; (800c038 <atcore_task_start+0x178>)
 800bf40:	f013 f809 	bl	801ef56 <rtosalMessageQueueNew>
 800bf44:	4b3d      	ldr	r3, [pc, #244]	; (800c03c <atcore_task_start+0x17c>)
 800bf46:	6018      	str	r0, [r3, #0]
      atcoreTaskId = rtosalThreadNew((const rtosal_char_t *)"atcoreTask",
 800bf48:	2300      	movs	r3, #0
 800bf4a:	9300      	str	r3, [sp, #0]
 800bf4c:	462b      	mov	r3, r5
 800bf4e:	4632      	mov	r2, r6
 800bf50:	493b      	ldr	r1, [pc, #236]	; (800c040 <atcore_task_start+0x180>)
 800bf52:	483c      	ldr	r0, [pc, #240]	; (800c044 <atcore_task_start+0x184>)
 800bf54:	f012 ffcb 	bl	801eeee <rtosalThreadNew>
 800bf58:	4b3b      	ldr	r3, [pc, #236]	; (800c048 <atcore_task_start+0x188>)
 800bf5a:	6018      	str	r0, [r3, #0]
      if (atcoreTaskId == NULL)
 800bf5c:	b390      	cbz	r0, 800bfc4 <atcore_task_start+0x104>
        retval = ATSTATUS_OK;
 800bf5e:	2400      	movs	r4, #0
 800bf60:	e7dc      	b.n	800bf1c <atcore_task_start+0x5c>
      TRACE_ERR("s_WaitAnswer_SemaphoreId creation error")
 800bf62:	4e3a      	ldr	r6, [pc, #232]	; (800c04c <atcore_task_start+0x18c>)
 800bf64:	4d31      	ldr	r5, [pc, #196]	; (800c02c <atcore_task_start+0x16c>)
 800bf66:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 800bf6a:	46b4      	mov	ip, r6
 800bf6c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bf70:	6028      	str	r0, [r5, #0]
 800bf72:	6069      	str	r1, [r5, #4]
 800bf74:	60aa      	str	r2, [r5, #8]
 800bf76:	60eb      	str	r3, [r5, #12]
 800bf78:	4666      	mov	r6, ip
 800bf7a:	3510      	adds	r5, #16
 800bf7c:	45f4      	cmp	ip, lr
 800bf7e:	d1f4      	bne.n	800bf6a <atcore_task_start+0xaa>
 800bf80:	f8dc 0000 	ldr.w	r0, [ip]
 800bf84:	6028      	str	r0, [r5, #0]
 800bf86:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800bf8a:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800bf8e:	80aa      	strh	r2, [r5, #4]
 800bf90:	71ab      	strb	r3, [r5, #6]
 800bf92:	4d26      	ldr	r5, [pc, #152]	; (800c02c <atcore_task_start+0x16c>)
 800bf94:	4628      	mov	r0, r5
 800bf96:	f013 f8bc 	bl	801f112 <crs_strlen>
 800bf9a:	b283      	uxth	r3, r0
 800bf9c:	462a      	mov	r2, r5
 800bf9e:	2110      	movs	r1, #16
 800bfa0:	2002      	movs	r0, #2
 800bfa2:	f013 f8f9 	bl	801f198 <traceIF_itmPrint>
 800bfa6:	4628      	mov	r0, r5
 800bfa8:	f013 f8b3 	bl	801f112 <crs_strlen>
 800bfac:	b283      	uxth	r3, r0
 800bfae:	462a      	mov	r2, r5
 800bfb0:	2110      	movs	r1, #16
 800bfb2:	2002      	movs	r0, #2
 800bfb4:	f013 f912 	bl	801f1dc <traceIF_uartPrint>
      LOG_ERROR(18, ERROR_WARNING);
 800bfb8:	2202      	movs	r2, #2
 800bfba:	2112      	movs	r1, #18
 800bfbc:	4610      	mov	r0, r2
 800bfbe:	f012 f8c5 	bl	801e14c <ERROR_Handler>
      retval = ATSTATUS_ERROR;
 800bfc2:	e7ab      	b.n	800bf1c <atcore_task_start+0x5c>
        TRACE_ERR("atcoreTaskId creation error")
 800bfc4:	4e22      	ldr	r6, [pc, #136]	; (800c050 <atcore_task_start+0x190>)
 800bfc6:	4d19      	ldr	r5, [pc, #100]	; (800c02c <atcore_task_start+0x16c>)
 800bfc8:	f106 0e20 	add.w	lr, r6, #32
 800bfcc:	46b4      	mov	ip, r6
 800bfce:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bfd2:	6028      	str	r0, [r5, #0]
 800bfd4:	6069      	str	r1, [r5, #4]
 800bfd6:	60aa      	str	r2, [r5, #8]
 800bfd8:	60eb      	str	r3, [r5, #12]
 800bfda:	4666      	mov	r6, ip
 800bfdc:	3510      	adds	r5, #16
 800bfde:	45f4      	cmp	ip, lr
 800bfe0:	d1f4      	bne.n	800bfcc <atcore_task_start+0x10c>
 800bfe2:	ce03      	ldmia	r6!, {r0, r1}
 800bfe4:	6028      	str	r0, [r5, #0]
 800bfe6:	6069      	str	r1, [r5, #4]
 800bfe8:	8832      	ldrh	r2, [r6, #0]
 800bfea:	78b3      	ldrb	r3, [r6, #2]
 800bfec:	812a      	strh	r2, [r5, #8]
 800bfee:	72ab      	strb	r3, [r5, #10]
 800bff0:	4d0e      	ldr	r5, [pc, #56]	; (800c02c <atcore_task_start+0x16c>)
 800bff2:	4628      	mov	r0, r5
 800bff4:	f013 f88d 	bl	801f112 <crs_strlen>
 800bff8:	b283      	uxth	r3, r0
 800bffa:	462a      	mov	r2, r5
 800bffc:	2110      	movs	r1, #16
 800bffe:	2002      	movs	r0, #2
 800c000:	f013 f8ca 	bl	801f198 <traceIF_itmPrint>
 800c004:	4628      	mov	r0, r5
 800c006:	f013 f884 	bl	801f112 <crs_strlen>
 800c00a:	b283      	uxth	r3, r0
 800c00c:	462a      	mov	r2, r5
 800c00e:	2110      	movs	r1, #16
 800c010:	2002      	movs	r0, #2
 800c012:	f013 f8e3 	bl	801f1dc <traceIF_uartPrint>
        LOG_ERROR(19, ERROR_WARNING);
 800c016:	2202      	movs	r2, #2
 800c018:	2113      	movs	r1, #19
 800c01a:	4610      	mov	r0, r2
 800c01c:	f012 f896 	bl	801e14c <ERROR_Handler>
        retval = ATSTATUS_ERROR;
 800c020:	e77c      	b.n	800bf1c <atcore_task_start+0x5c>
 800c022:	bf00      	nop
 800c024:	20001884 	.word	0x20001884
 800c028:	0802d7c8 	.word	0x0802d7c8
 800c02c:	200048dc 	.word	0x200048dc
 800c030:	0802d7f8 	.word	0x0802d7f8
 800c034:	20003544 	.word	0x20003544
 800c038:	0802d848 	.word	0x0802d848
 800c03c:	2000353c 	.word	0x2000353c
 800c040:	0800b3b9 	.word	0x0800b3b9
 800c044:	0802d854 	.word	0x0802d854
 800c048:	20001f28 	.word	0x20001f28
 800c04c:	0802d810 	.word	0x0802d810
 800c050:	0802d860 	.word	0x0802d860

0800c054 <DATAPACK_writePtr>:
  * @param  msgtype Type of message
  * @param  p_data Pointer to user data structure
  * @retval DataPack_Status_t
  */
DataPack_Status_t DATAPACK_writePtr(uint8_t *p_buf, uint16_t msgtype, void *p_data)
{
 800c054:	4603      	mov	r3, r0
  uint16_t size = (uint16_t) sizeof(datapack_structptr_t);
  datapack_structptr_t sptr;
  sptr.structptr = p_data;

  /* check pointers */
  if ((p_data == NULL) || (p_buf == NULL))
 800c056:	4694      	mov	ip, r2
 800c058:	b162      	cbz	r2, 800c074 <DATAPACK_writePtr+0x20>
 800c05a:	b158      	cbz	r0, 800c074 <DATAPACK_writePtr+0x20>
    retvalue = DATAPACK_ERROR;
  }
  else
  {
    /* write header: message type */
    p_buf[0] = (uint8_t)(msgtype >> 8);
 800c05c:	0a0a      	lsrs	r2, r1, #8
 800c05e:	7002      	strb	r2, [r0, #0]
    p_buf[1] = (uint8_t)(msgtype & 0x00FFU);
 800c060:	7041      	strb	r1, [r0, #1]

    /* write header: size */
    p_buf[2] = (uint8_t)(size >> 8);
 800c062:	2000      	movs	r0, #0
 800c064:	7098      	strb	r0, [r3, #2]
    p_buf[3] = (uint8_t)(size & 0x00FFU);
 800c066:	2204      	movs	r2, #4
 800c068:	70da      	strb	r2, [r3, #3]

    /* write header: content type (pointer of data) */
    p_buf[4] = DATASTRUCT_POINTER_TYPE;
 800c06a:	2201      	movs	r2, #1
 800c06c:	711a      	strb	r2, [r3, #4]

    /* write pointer on user data structure */
    (void) memcpy((void *)&p_buf[DATAPACK_HEADER_BYTE_SIZE + 1U], (void *)&sptr, sizeof(datapack_structptr_t));
 800c06e:	f8c3 c005 	str.w	ip, [r3, #5]

    retvalue = DATAPACK_OK;
  }
  return (retvalue);
}
 800c072:	4770      	bx	lr
{
 800c074:	b510      	push	{r4, lr}
    PRINT_ERR("DATAPACK_writePtr error (%p, %p)", p_data, p_buf)
 800c076:	4c0d      	ldr	r4, [pc, #52]	; (800c0ac <DATAPACK_writePtr+0x58>)
 800c078:	4662      	mov	r2, ip
 800c07a:	490d      	ldr	r1, [pc, #52]	; (800c0b0 <DATAPACK_writePtr+0x5c>)
 800c07c:	4620      	mov	r0, r4
 800c07e:	f019 fdf7 	bl	8025c70 <sprintf>
 800c082:	4620      	mov	r0, r4
 800c084:	f013 f845 	bl	801f112 <crs_strlen>
 800c088:	b283      	uxth	r3, r0
 800c08a:	4622      	mov	r2, r4
 800c08c:	2110      	movs	r1, #16
 800c08e:	2002      	movs	r0, #2
 800c090:	f013 f882 	bl	801f198 <traceIF_itmPrint>
 800c094:	4620      	mov	r0, r4
 800c096:	f013 f83c 	bl	801f112 <crs_strlen>
 800c09a:	b283      	uxth	r3, r0
 800c09c:	4622      	mov	r2, r4
 800c09e:	2110      	movs	r1, #16
 800c0a0:	2002      	movs	r0, #2
 800c0a2:	f013 f89b 	bl	801f1dc <traceIF_uartPrint>
    retvalue = DATAPACK_ERROR;
 800c0a6:	2001      	movs	r0, #1
}
 800c0a8:	bd10      	pop	{r4, pc}
 800c0aa:	bf00      	nop
 800c0ac:	200048dc 	.word	0x200048dc
 800c0b0:	0802d88c 	.word	0x0802d88c

0800c0b4 <DATAPACK_writeStruct>:
  * @param  size Size of the structure
  * @param  p_data Pointer to user data structure
  * @retval DataPack_Status_t
  */
DataPack_Status_t DATAPACK_writeStruct(uint8_t *p_buf, uint16_t msgtype, uint16_t size, void *p_data)
{
 800c0b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c0b8:	b082      	sub	sp, #8
 800c0ba:	4606      	mov	r6, r0
 800c0bc:	460f      	mov	r7, r1
 800c0be:	4614      	mov	r4, r2
 800c0c0:	4698      	mov	r8, r3

  DataPack_Status_t retvalue;

#if (USE_TRACE_ATDATAPACK == 1U)
  static uint32_t datapack_biggest_size = 0U; /* for debug only, used to track maximum struct size */
  if (size > datapack_biggest_size)
 800c0c2:	4b2f      	ldr	r3, [pc, #188]	; (800c180 <DATAPACK_writeStruct+0xcc>)
 800c0c4:	681b      	ldr	r3, [r3, #0]
 800c0c6:	429a      	cmp	r2, r3
 800c0c8:	d901      	bls.n	800c0ce <DATAPACK_writeStruct+0x1a>
  {
    datapack_biggest_size = size;
 800c0ca:	4b2d      	ldr	r3, [pc, #180]	; (800c180 <DATAPACK_writeStruct+0xcc>)
 800c0cc:	601a      	str	r2, [r3, #0]
  }
  PRINT_DBG("<MAX SIZE INFO> msgtype=%d size=%d (biggest =%ld)", msgtype, size, datapack_biggest_size)
 800c0ce:	4b2c      	ldr	r3, [pc, #176]	; (800c180 <DATAPACK_writeStruct+0xcc>)
 800c0d0:	681b      	ldr	r3, [r3, #0]
 800c0d2:	4d2c      	ldr	r5, [pc, #176]	; (800c184 <DATAPACK_writeStruct+0xd0>)
 800c0d4:	9300      	str	r3, [sp, #0]
 800c0d6:	4623      	mov	r3, r4
 800c0d8:	463a      	mov	r2, r7
 800c0da:	492b      	ldr	r1, [pc, #172]	; (800c188 <DATAPACK_writeStruct+0xd4>)
 800c0dc:	4628      	mov	r0, r5
 800c0de:	f019 fdc7 	bl	8025c70 <sprintf>
 800c0e2:	4628      	mov	r0, r5
 800c0e4:	f013 f815 	bl	801f112 <crs_strlen>
 800c0e8:	b283      	uxth	r3, r0
 800c0ea:	462a      	mov	r2, r5
 800c0ec:	2102      	movs	r1, #2
 800c0ee:	4608      	mov	r0, r1
 800c0f0:	f013 f852 	bl	801f198 <traceIF_itmPrint>
 800c0f4:	4628      	mov	r0, r5
 800c0f6:	f013 f80c 	bl	801f112 <crs_strlen>
 800c0fa:	b283      	uxth	r3, r0
 800c0fc:	462a      	mov	r2, r5
 800c0fe:	2102      	movs	r1, #2
 800c100:	4608      	mov	r0, r1
 800c102:	f013 f86b 	bl	801f1dc <traceIF_uartPrint>
#endif /* USE_TRACE_ATDATAPACK */

  /* check maximum size and pointer */
  if (((size - DATAPACK_HEADER_BYTE_SIZE) > DATAPACK_MAX_BUF_SIZE) || (p_buf == NULL))
 800c106:	2c84      	cmp	r4, #132	; 0x84
 800c108:	d80f      	bhi.n	800c12a <DATAPACK_writeStruct+0x76>
 800c10a:	b176      	cbz	r6, 800c12a <DATAPACK_writeStruct+0x76>
    retvalue = DATAPACK_ERROR;
  }
  else
  {
    /* write header: message type */
    p_buf[0] = (uint8_t)(msgtype >> 8);
 800c10c:	0a3b      	lsrs	r3, r7, #8
 800c10e:	7033      	strb	r3, [r6, #0]
    p_buf[1] = (uint8_t)(msgtype & 0x00FFU);
 800c110:	7077      	strb	r7, [r6, #1]

    /* write header: size */
    p_buf[2] = (uint8_t)(size >> 8);
 800c112:	0a23      	lsrs	r3, r4, #8
 800c114:	70b3      	strb	r3, [r6, #2]
    p_buf[3] = (uint8_t)(size & 0x00FFU);
 800c116:	70f4      	strb	r4, [r6, #3]

    /* write header: content type (pointer of data) */
    p_buf[4] = DATASTRUCT_CONTENT_TYPE;
 800c118:	2302      	movs	r3, #2
 800c11a:	7133      	strb	r3, [r6, #4]

    /* transmit structure content */
    (void) memcpy((void *)&p_buf[DATAPACK_HEADER_BYTE_SIZE + 1U],
 800c11c:	4622      	mov	r2, r4
 800c11e:	4641      	mov	r1, r8
 800c120:	1d70      	adds	r0, r6, #5
 800c122:	f019 fef5 	bl	8025f10 <memcpy>
                  (void *)p_data,
                  (size_t) size);

    retvalue = DATAPACK_OK;
 800c126:	2000      	movs	r0, #0
 800c128:	e026      	b.n	800c178 <DATAPACK_writeStruct+0xc4>
    PRINT_ERR("DATAPACK_writeStruct error")
 800c12a:	4c18      	ldr	r4, [pc, #96]	; (800c18c <DATAPACK_writeStruct+0xd8>)
 800c12c:	4d15      	ldr	r5, [pc, #84]	; (800c184 <DATAPACK_writeStruct+0xd0>)
 800c12e:	f104 0620 	add.w	r6, r4, #32
 800c132:	46a4      	mov	ip, r4
 800c134:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800c138:	6028      	str	r0, [r5, #0]
 800c13a:	6069      	str	r1, [r5, #4]
 800c13c:	60aa      	str	r2, [r5, #8]
 800c13e:	60eb      	str	r3, [r5, #12]
 800c140:	4664      	mov	r4, ip
 800c142:	3510      	adds	r5, #16
 800c144:	45b4      	cmp	ip, r6
 800c146:	d1f4      	bne.n	800c132 <DATAPACK_writeStruct+0x7e>
 800c148:	cc07      	ldmia	r4!, {r0, r1, r2}
 800c14a:	6028      	str	r0, [r5, #0]
 800c14c:	6069      	str	r1, [r5, #4]
 800c14e:	60aa      	str	r2, [r5, #8]
 800c150:	4c0c      	ldr	r4, [pc, #48]	; (800c184 <DATAPACK_writeStruct+0xd0>)
 800c152:	4620      	mov	r0, r4
 800c154:	f012 ffdd 	bl	801f112 <crs_strlen>
 800c158:	b283      	uxth	r3, r0
 800c15a:	4622      	mov	r2, r4
 800c15c:	2110      	movs	r1, #16
 800c15e:	2002      	movs	r0, #2
 800c160:	f013 f81a 	bl	801f198 <traceIF_itmPrint>
 800c164:	4620      	mov	r0, r4
 800c166:	f012 ffd4 	bl	801f112 <crs_strlen>
 800c16a:	b283      	uxth	r3, r0
 800c16c:	4622      	mov	r2, r4
 800c16e:	2110      	movs	r1, #16
 800c170:	2002      	movs	r0, #2
 800c172:	f013 f833 	bl	801f1dc <traceIF_uartPrint>
    retvalue = DATAPACK_ERROR;
 800c176:	2001      	movs	r0, #1
  }

  return (retvalue);
}
 800c178:	b002      	add	sp, #8
 800c17a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c17e:	bf00      	nop
 800c180:	200035c8 	.word	0x200035c8
 800c184:	200048dc 	.word	0x200048dc
 800c188:	0802d8c0 	.word	0x0802d8c0
 800c18c:	0802d900 	.word	0x0802d900

0800c190 <DATAPACK_readMsgType>:

uint16_t DATAPACK_readMsgType(uint8_t *p_buf)
{
  uint16_t msgtype;
  /* read header: message type */
  msgtype = ((uint16_t)p_buf[0] << 8) + (uint16_t)p_buf[1];
 800c190:	7803      	ldrb	r3, [r0, #0]
 800c192:	7840      	ldrb	r0, [r0, #1]
 800c194:	eb00 2003 	add.w	r0, r0, r3, lsl #8
  return ((uint16_t)msgtype);
}
 800c198:	b280      	uxth	r0, r0
 800c19a:	4770      	bx	lr

0800c19c <DATAPACK_readSize>:

uint16_t DATAPACK_readSize(uint8_t *p_buf)
{
  uint16_t size;
  /* read header: size */
  size = ((uint16_t)p_buf[2] << 8) + (uint16_t)p_buf[3];
 800c19c:	7883      	ldrb	r3, [r0, #2]
 800c19e:	78c0      	ldrb	r0, [r0, #3]
 800c1a0:	eb00 2003 	add.w	r0, r0, r3, lsl #8
  return (size);
}
 800c1a4:	b280      	uxth	r0, r0
 800c1a6:	4770      	bx	lr

0800c1a8 <check_structure_to_read>:

/* static functions ---------------------------------------------------------------------- */
static DataPack_Status_t check_structure_to_read(uint8_t *p_buf, uint16_t msgtype,
                                                 uint16_t expect_size, uint8_t expect_type)
{
 800c1a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c1aa:	4605      	mov	r5, r0
 800c1ac:	460c      	mov	r4, r1
 800c1ae:	4616      	mov	r6, r2
 800c1b0:	461f      	mov	r7, r3
  DataPack_Status_t retval;
  uint16_t rx_msgtype;

  /* check that indicated msg type and received msg type are matching */
  rx_msgtype = DATAPACK_readMsgType(p_buf);
 800c1b2:	f7ff ffed 	bl	800c190 <DATAPACK_readMsgType>
  if (rx_msgtype != msgtype)
 800c1b6:	42a0      	cmp	r0, r4
 800c1b8:	d109      	bne.n	800c1ce <check_structure_to_read+0x26>
  }
  else
  {
    /* check that expect_size and received size are matching */
    uint16_t rx_size;
    rx_size = DATAPACK_readSize(p_buf);
 800c1ba:	4628      	mov	r0, r5
 800c1bc:	f7ff ffee 	bl	800c19c <DATAPACK_readSize>
    if (rx_size != expect_size)
 800c1c0:	42b0      	cmp	r0, r6
 800c1c2:	d11f      	bne.n	800c204 <check_structure_to_read+0x5c>
    }
    else
    {
      /* check that expect_type corresponds to the received content type */
      uint8_t rx_contenttype;
      rx_contenttype = p_buf[4];
 800c1c4:	792b      	ldrb	r3, [r5, #4]
      if (rx_contenttype != expect_type)
 800c1c6:	42bb      	cmp	r3, r7
 800c1c8:	d137      	bne.n	800c23a <check_structure_to_read+0x92>
        PRINT_ERR("DATAPACK read content type not matching")
        retval = DATAPACK_ERROR;
      }
      else
      {
        retval = DATAPACK_OK;
 800c1ca:	2000      	movs	r0, #0
 800c1cc:	e019      	b.n	800c202 <check_structure_to_read+0x5a>
    PRINT_INFO("DATAPACK read msgtype not matching (%d vs %d)", rx_msgtype, msgtype)
 800c1ce:	4d2f      	ldr	r5, [pc, #188]	; (800c28c <check_structure_to_read+0xe4>)
 800c1d0:	4623      	mov	r3, r4
 800c1d2:	4602      	mov	r2, r0
 800c1d4:	492e      	ldr	r1, [pc, #184]	; (800c290 <check_structure_to_read+0xe8>)
 800c1d6:	4628      	mov	r0, r5
 800c1d8:	f019 fd4a 	bl	8025c70 <sprintf>
 800c1dc:	4628      	mov	r0, r5
 800c1de:	f012 ff98 	bl	801f112 <crs_strlen>
 800c1e2:	b283      	uxth	r3, r0
 800c1e4:	462a      	mov	r2, r5
 800c1e6:	2101      	movs	r1, #1
 800c1e8:	2002      	movs	r0, #2
 800c1ea:	f012 ffd5 	bl	801f198 <traceIF_itmPrint>
 800c1ee:	4628      	mov	r0, r5
 800c1f0:	f012 ff8f 	bl	801f112 <crs_strlen>
 800c1f4:	b283      	uxth	r3, r0
 800c1f6:	462a      	mov	r2, r5
 800c1f8:	2101      	movs	r1, #1
 800c1fa:	2002      	movs	r0, #2
 800c1fc:	f012 ffee 	bl	801f1dc <traceIF_uartPrint>
    retval = DATAPACK_ERROR;
 800c200:	2001      	movs	r0, #1
      }
    }
  }

  return (retval);
}
 800c202:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      PRINT_ERR("DATAPACK read size error (%d, %d)", rx_size, expect_size)
 800c204:	4c21      	ldr	r4, [pc, #132]	; (800c28c <check_structure_to_read+0xe4>)
 800c206:	4633      	mov	r3, r6
 800c208:	4602      	mov	r2, r0
 800c20a:	4922      	ldr	r1, [pc, #136]	; (800c294 <check_structure_to_read+0xec>)
 800c20c:	4620      	mov	r0, r4
 800c20e:	f019 fd2f 	bl	8025c70 <sprintf>
 800c212:	4620      	mov	r0, r4
 800c214:	f012 ff7d 	bl	801f112 <crs_strlen>
 800c218:	b283      	uxth	r3, r0
 800c21a:	4622      	mov	r2, r4
 800c21c:	2110      	movs	r1, #16
 800c21e:	2002      	movs	r0, #2
 800c220:	f012 ffba 	bl	801f198 <traceIF_itmPrint>
 800c224:	4620      	mov	r0, r4
 800c226:	f012 ff74 	bl	801f112 <crs_strlen>
 800c22a:	b283      	uxth	r3, r0
 800c22c:	4622      	mov	r2, r4
 800c22e:	2110      	movs	r1, #16
 800c230:	2002      	movs	r0, #2
 800c232:	f012 ffd3 	bl	801f1dc <traceIF_uartPrint>
      retval = DATAPACK_ERROR;
 800c236:	2001      	movs	r0, #1
 800c238:	e7e3      	b.n	800c202 <check_structure_to_read+0x5a>
        PRINT_ERR("DATAPACK read content type not matching")
 800c23a:	4d17      	ldr	r5, [pc, #92]	; (800c298 <check_structure_to_read+0xf0>)
 800c23c:	4c13      	ldr	r4, [pc, #76]	; (800c28c <check_structure_to_read+0xe4>)
 800c23e:	f105 0730 	add.w	r7, r5, #48	; 0x30
 800c242:	462e      	mov	r6, r5
 800c244:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800c246:	6020      	str	r0, [r4, #0]
 800c248:	6061      	str	r1, [r4, #4]
 800c24a:	60a2      	str	r2, [r4, #8]
 800c24c:	60e3      	str	r3, [r4, #12]
 800c24e:	4635      	mov	r5, r6
 800c250:	3410      	adds	r4, #16
 800c252:	42be      	cmp	r6, r7
 800c254:	d1f5      	bne.n	800c242 <check_structure_to_read+0x9a>
 800c256:	cd03      	ldmia	r5!, {r0, r1}
 800c258:	6020      	str	r0, [r4, #0]
 800c25a:	6061      	str	r1, [r4, #4]
 800c25c:	782b      	ldrb	r3, [r5, #0]
 800c25e:	7223      	strb	r3, [r4, #8]
 800c260:	4c0a      	ldr	r4, [pc, #40]	; (800c28c <check_structure_to_read+0xe4>)
 800c262:	4620      	mov	r0, r4
 800c264:	f012 ff55 	bl	801f112 <crs_strlen>
 800c268:	b283      	uxth	r3, r0
 800c26a:	4622      	mov	r2, r4
 800c26c:	2110      	movs	r1, #16
 800c26e:	2002      	movs	r0, #2
 800c270:	f012 ff92 	bl	801f198 <traceIF_itmPrint>
 800c274:	4620      	mov	r0, r4
 800c276:	f012 ff4c 	bl	801f112 <crs_strlen>
 800c27a:	b283      	uxth	r3, r0
 800c27c:	4622      	mov	r2, r4
 800c27e:	2110      	movs	r1, #16
 800c280:	2002      	movs	r0, #2
 800c282:	f012 ffab 	bl	801f1dc <traceIF_uartPrint>
        retval = DATAPACK_ERROR;
 800c286:	2001      	movs	r0, #1
 800c288:	e7bb      	b.n	800c202 <check_structure_to_read+0x5a>
 800c28a:	bf00      	nop
 800c28c:	200048dc 	.word	0x200048dc
 800c290:	0802d92c 	.word	0x0802d92c
 800c294:	0802d968 	.word	0x0802d968
 800c298:	0802d99c 	.word	0x0802d99c

0800c29c <DATAPACK_readPtr>:
{
 800c29c:	b538      	push	{r3, r4, r5, lr}
  if (p_buf == NULL)
 800c29e:	4605      	mov	r5, r0
 800c2a0:	b148      	cbz	r0, 800c2b6 <DATAPACK_readPtr+0x1a>
 800c2a2:	4614      	mov	r4, r2
    retval = check_structure_to_read(p_buf, msgtype, size, DATASTRUCT_POINTER_TYPE);
 800c2a4:	2301      	movs	r3, #1
 800c2a6:	2204      	movs	r2, #4
 800c2a8:	f7ff ff7e 	bl	800c1a8 <check_structure_to_read>
    if (retval == DATAPACK_OK)
 800c2ac:	b910      	cbnz	r0, 800c2b4 <DATAPACK_readPtr+0x18>
      (void) memcpy((void *)&sptr,
 800c2ae:	f8d5 3005 	ldr.w	r3, [r5, #5]
      *p_data = sptr.structptr;
 800c2b2:	6023      	str	r3, [r4, #0]
}
 800c2b4:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_ERR("DATAPACK_readPtr pointer error (%p)", p_buf)
 800c2b6:	4c0d      	ldr	r4, [pc, #52]	; (800c2ec <DATAPACK_readPtr+0x50>)
 800c2b8:	4602      	mov	r2, r0
 800c2ba:	490d      	ldr	r1, [pc, #52]	; (800c2f0 <DATAPACK_readPtr+0x54>)
 800c2bc:	4620      	mov	r0, r4
 800c2be:	f019 fcd7 	bl	8025c70 <sprintf>
 800c2c2:	4620      	mov	r0, r4
 800c2c4:	f012 ff25 	bl	801f112 <crs_strlen>
 800c2c8:	b283      	uxth	r3, r0
 800c2ca:	4622      	mov	r2, r4
 800c2cc:	2110      	movs	r1, #16
 800c2ce:	2002      	movs	r0, #2
 800c2d0:	f012 ff62 	bl	801f198 <traceIF_itmPrint>
 800c2d4:	4620      	mov	r0, r4
 800c2d6:	f012 ff1c 	bl	801f112 <crs_strlen>
 800c2da:	b283      	uxth	r3, r0
 800c2dc:	4622      	mov	r2, r4
 800c2de:	2110      	movs	r1, #16
 800c2e0:	2002      	movs	r0, #2
 800c2e2:	f012 ff7b 	bl	801f1dc <traceIF_uartPrint>
    retval = DATAPACK_ERROR;
 800c2e6:	2001      	movs	r0, #1
 800c2e8:	e7e4      	b.n	800c2b4 <DATAPACK_readPtr+0x18>
 800c2ea:	bf00      	nop
 800c2ec:	200048dc 	.word	0x200048dc
 800c2f0:	0802d9d8 	.word	0x0802d9d8

0800c2f4 <DATAPACK_readStruct>:
{
 800c2f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c2f6:	4604      	mov	r4, r0
  if ((p_data == NULL) || (p_buf == NULL))
 800c2f8:	461f      	mov	r7, r3
 800c2fa:	b163      	cbz	r3, 800c316 <DATAPACK_readStruct+0x22>
 800c2fc:	4615      	mov	r5, r2
 800c2fe:	b150      	cbz	r0, 800c316 <DATAPACK_readStruct+0x22>
    retval = check_structure_to_read(p_buf, msgtype, size, DATASTRUCT_CONTENT_TYPE);
 800c300:	2302      	movs	r3, #2
 800c302:	f7ff ff51 	bl	800c1a8 <check_structure_to_read>
    if (retval == DATAPACK_OK)
 800c306:	4606      	mov	r6, r0
 800c308:	b9f8      	cbnz	r0, 800c34a <DATAPACK_readStruct+0x56>
      (void) memcpy((void *)p_data,
 800c30a:	462a      	mov	r2, r5
 800c30c:	1d61      	adds	r1, r4, #5
 800c30e:	4638      	mov	r0, r7
 800c310:	f019 fdfe 	bl	8025f10 <memcpy>
 800c314:	e019      	b.n	800c34a <DATAPACK_readStruct+0x56>
    PRINT_ERR("DATAPACK_readStruct pointer error( %p, %p)", p_data, p_buf)
 800c316:	4d0e      	ldr	r5, [pc, #56]	; (800c350 <DATAPACK_readStruct+0x5c>)
 800c318:	4623      	mov	r3, r4
 800c31a:	463a      	mov	r2, r7
 800c31c:	490d      	ldr	r1, [pc, #52]	; (800c354 <DATAPACK_readStruct+0x60>)
 800c31e:	4628      	mov	r0, r5
 800c320:	f019 fca6 	bl	8025c70 <sprintf>
 800c324:	4628      	mov	r0, r5
 800c326:	f012 fef4 	bl	801f112 <crs_strlen>
 800c32a:	b283      	uxth	r3, r0
 800c32c:	462a      	mov	r2, r5
 800c32e:	2110      	movs	r1, #16
 800c330:	2002      	movs	r0, #2
 800c332:	f012 ff31 	bl	801f198 <traceIF_itmPrint>
 800c336:	4628      	mov	r0, r5
 800c338:	f012 feeb 	bl	801f112 <crs_strlen>
 800c33c:	b283      	uxth	r3, r0
 800c33e:	462a      	mov	r2, r5
 800c340:	2110      	movs	r1, #16
 800c342:	2002      	movs	r0, #2
 800c344:	f012 ff4a 	bl	801f1dc <traceIF_uartPrint>
    retval = DATAPACK_ERROR;
 800c348:	2601      	movs	r6, #1
}
 800c34a:	4630      	mov	r0, r6
 800c34c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c34e:	bf00      	nop
 800c350:	200048dc 	.word	0x200048dc
 800c354:	0802da10 	.word	0x0802da10

0800c358 <atcc_initParsers>:
  * @brief  Initialize modem parsers.
  * @param  deviceType Device ID on which the event has been received.
  * @retval at_status_t
  */
at_status_t atcc_initParsers(sysctrl_device_type_t device_type)
{
 800c358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c35a:	4604      	mov	r4, r0
  at_status_t retval;

  /* check if device is already initialized */
  if (at_custom_func[device_type].initialized == 0U)
 800c35c:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 800c360:	011b      	lsls	r3, r3, #4
 800c362:	4a15      	ldr	r2, [pc, #84]	; (800c3b8 <atcc_initParsers+0x60>)
 800c364:	5cd5      	ldrb	r5, [r2, r3]
 800c366:	b96d      	cbnz	r5, 800c384 <atcc_initParsers+0x2c>
  {
    /* Init  AT functions pointers */
    atcma_init_at_func_ptrs(&at_custom_func[device_type]);
 800c368:	4617      	mov	r7, r2
 800c36a:	0046      	lsls	r6, r0, #1
 800c36c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c370:	eb02 1000 	add.w	r0, r2, r0, lsl #4
 800c374:	f7f5 ff3a 	bl	80021ec <atcma_init_at_func_ptrs>
    /* device is initialized now */
    at_custom_func[device_type].initialized = 1U;
 800c378:	4426      	add	r6, r4
 800c37a:	0136      	lsls	r6, r6, #4
 800c37c:	2301      	movs	r3, #1
 800c37e:	55bb      	strb	r3, [r7, r6]
    PRINT_ERR("Device type %d AT functions already initialized", device_type);
    retval = ATSTATUS_ERROR;
  }

  return (retval);
}
 800c380:	4628      	mov	r0, r5
 800c382:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_ERR("Device type %d AT functions already initialized", device_type);
 800c384:	4d0d      	ldr	r5, [pc, #52]	; (800c3bc <atcc_initParsers+0x64>)
 800c386:	4602      	mov	r2, r0
 800c388:	490d      	ldr	r1, [pc, #52]	; (800c3c0 <atcc_initParsers+0x68>)
 800c38a:	4628      	mov	r0, r5
 800c38c:	f019 fc70 	bl	8025c70 <sprintf>
 800c390:	4628      	mov	r0, r5
 800c392:	f012 febe 	bl	801f112 <crs_strlen>
 800c396:	b283      	uxth	r3, r0
 800c398:	462a      	mov	r2, r5
 800c39a:	2110      	movs	r1, #16
 800c39c:	2002      	movs	r0, #2
 800c39e:	f012 fefb 	bl	801f198 <traceIF_itmPrint>
 800c3a2:	4628      	mov	r0, r5
 800c3a4:	f012 feb5 	bl	801f112 <crs_strlen>
 800c3a8:	b283      	uxth	r3, r0
 800c3aa:	462a      	mov	r2, r5
 800c3ac:	2110      	movs	r1, #16
 800c3ae:	2002      	movs	r0, #2
 800c3b0:	f012 ff14 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800c3b4:	2501      	movs	r5, #1
 800c3b6:	e7e3      	b.n	800c380 <atcc_initParsers+0x28>
 800c3b8:	200035cc 	.word	0x200035cc
 800c3bc:	200048dc 	.word	0x200048dc
 800c3c0:	0802da4c 	.word	0x0802da4c

0800c3c4 <atcc_init>:
  * @brief  Call modem initialization function.
  * @param  p_at_ctxt Pointer to the modem context.
  * @retval none
  */
void atcc_init(at_context_t *p_at_ctxt)
{
 800c3c4:	b508      	push	{r3, lr}
  (* at_custom_func[p_at_ctxt->device_type].f_init)(&p_at_ctxt->parser);
 800c3c6:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c3ca:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c3ce:	4a03      	ldr	r2, [pc, #12]	; (800c3dc <atcc_init+0x18>)
 800c3d0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c3d4:	685b      	ldr	r3, [r3, #4]
 800c3d6:	4798      	blx	r3
}
 800c3d8:	bd08      	pop	{r3, pc}
 800c3da:	bf00      	nop
 800c3dc:	200035cc 	.word	0x200035cc

0800c3e0 <atcc_checkEndOfMsgCallback>:
  * @retval none
  */
ATC_checkEndOfMsgCallbackTypeDef atcc_checkEndOfMsgCallback(const at_context_t *p_at_ctxt)
{
  /* called under interruption, do not put trace here */
  return (at_custom_func[p_at_ctxt->device_type].f_checkEndOfMsgCallback);
 800c3e0:	7803      	ldrb	r3, [r0, #0]
 800c3e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c3e6:	4a02      	ldr	r2, [pc, #8]	; (800c3f0 <atcc_checkEndOfMsgCallback+0x10>)
 800c3e8:	eb02 1303 	add.w	r3, r2, r3, lsl #4
}
 800c3ec:	6898      	ldr	r0, [r3, #8]
 800c3ee:	4770      	bx	lr
 800c3f0:	200035cc 	.word	0x200035cc

0800c3f4 <atcc_getCmd>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_ATcmdTimeout Timeout value to apply for this command.
  * @retval at_status_t
  */
at_status_t atcc_getCmd(at_context_t *p_at_ctxt, uint32_t *p_ATcmdTimeout)
{
 800c3f4:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_getCmd)(p_at_ctxt, p_ATcmdTimeout);
 800c3f6:	7803      	ldrb	r3, [r0, #0]
 800c3f8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c3fc:	4a0f      	ldr	r2, [pc, #60]	; (800c43c <atcc_getCmd+0x48>)
 800c3fe:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c402:	68db      	ldr	r3, [r3, #12]
 800c404:	4798      	blx	r3
 800c406:	4605      	mov	r5, r0

  PRINT_DBG("atcc_getCmd returned status = %d", retval)
 800c408:	4c0d      	ldr	r4, [pc, #52]	; (800c440 <atcc_getCmd+0x4c>)
 800c40a:	4602      	mov	r2, r0
 800c40c:	490d      	ldr	r1, [pc, #52]	; (800c444 <atcc_getCmd+0x50>)
 800c40e:	4620      	mov	r0, r4
 800c410:	f019 fc2e 	bl	8025c70 <sprintf>
 800c414:	4620      	mov	r0, r4
 800c416:	f012 fe7c 	bl	801f112 <crs_strlen>
 800c41a:	b283      	uxth	r3, r0
 800c41c:	4622      	mov	r2, r4
 800c41e:	2102      	movs	r1, #2
 800c420:	4608      	mov	r0, r1
 800c422:	f012 feb9 	bl	801f198 <traceIF_itmPrint>
 800c426:	4620      	mov	r0, r4
 800c428:	f012 fe73 	bl	801f112 <crs_strlen>
 800c42c:	b283      	uxth	r3, r0
 800c42e:	4622      	mov	r2, r4
 800c430:	2102      	movs	r1, #2
 800c432:	4608      	mov	r0, r1
 800c434:	f012 fed2 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c438:	4628      	mov	r0, r5
 800c43a:	bd38      	pop	{r3, r4, r5, pc}
 800c43c:	200035cc 	.word	0x200035cc
 800c440:	200048dc 	.word	0x200048dc
 800c444:	0802da90 	.word	0x0802da90

0800c448 <atcc_extractElement>:
  * @retval at_endmsg_t Indicates if this is the last message.
  */
at_endmsg_t atcc_extractElement(at_context_t *p_at_ctxt,
                                const IPC_RxMessage_t *p_msg_in,
                                at_element_info_t *element_infos)
{
 800c448:	b570      	push	{r4, r5, r6, lr}
 800c44a:	b082      	sub	sp, #8
 800c44c:	4615      	mov	r5, r2
  at_endmsg_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_extractElement)(&p_at_ctxt->parser, p_msg_in, element_infos);
 800c44e:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c452:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c456:	4c1f      	ldr	r4, [pc, #124]	; (800c4d4 <atcc_extractElement+0x8c>)
 800c458:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800c45c:	691b      	ldr	r3, [r3, #16]
 800c45e:	4798      	blx	r3
 800c460:	4606      	mov	r6, r0

  PRINT_DBG("start idx=%d  end idx=%d  size=%d rank=%d",
 800c462:	89eb      	ldrh	r3, [r5, #14]
 800c464:	892a      	ldrh	r2, [r5, #8]
 800c466:	4c1c      	ldr	r4, [pc, #112]	; (800c4d8 <atcc_extractElement+0x90>)
 800c468:	9201      	str	r2, [sp, #4]
 800c46a:	9300      	str	r3, [sp, #0]
 800c46c:	89ab      	ldrh	r3, [r5, #12]
 800c46e:	896a      	ldrh	r2, [r5, #10]
 800c470:	491a      	ldr	r1, [pc, #104]	; (800c4dc <atcc_extractElement+0x94>)
 800c472:	4620      	mov	r0, r4
 800c474:	f019 fbfc 	bl	8025c70 <sprintf>
 800c478:	4620      	mov	r0, r4
 800c47a:	f012 fe4a 	bl	801f112 <crs_strlen>
 800c47e:	b283      	uxth	r3, r0
 800c480:	4622      	mov	r2, r4
 800c482:	2102      	movs	r1, #2
 800c484:	4608      	mov	r0, r1
 800c486:	f012 fe87 	bl	801f198 <traceIF_itmPrint>
 800c48a:	4620      	mov	r0, r4
 800c48c:	f012 fe41 	bl	801f112 <crs_strlen>
 800c490:	b283      	uxth	r3, r0
 800c492:	4622      	mov	r2, r4
 800c494:	2102      	movs	r1, #2
 800c496:	4608      	mov	r0, r1
 800c498:	f012 fea0 	bl	801f1dc <traceIF_uartPrint>
            element_infos->str_start_idx, element_infos->str_end_idx,
            element_infos->str_size, element_infos->param_rank)
  PRINT_DBG("atcc_extractElement returned endmsg = %d", (retval == ATENDMSG_YES) ? 1 : 0)
 800c49c:	fab6 f286 	clz	r2, r6
 800c4a0:	0952      	lsrs	r2, r2, #5
 800c4a2:	490f      	ldr	r1, [pc, #60]	; (800c4e0 <atcc_extractElement+0x98>)
 800c4a4:	4620      	mov	r0, r4
 800c4a6:	f019 fbe3 	bl	8025c70 <sprintf>
 800c4aa:	4620      	mov	r0, r4
 800c4ac:	f012 fe31 	bl	801f112 <crs_strlen>
 800c4b0:	b283      	uxth	r3, r0
 800c4b2:	4622      	mov	r2, r4
 800c4b4:	2102      	movs	r1, #2
 800c4b6:	4608      	mov	r0, r1
 800c4b8:	f012 fe6e 	bl	801f198 <traceIF_itmPrint>
 800c4bc:	4620      	mov	r0, r4
 800c4be:	f012 fe28 	bl	801f112 <crs_strlen>
 800c4c2:	b283      	uxth	r3, r0
 800c4c4:	4622      	mov	r2, r4
 800c4c6:	2102      	movs	r1, #2
 800c4c8:	4608      	mov	r0, r1
 800c4ca:	f012 fe87 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c4ce:	4630      	mov	r0, r6
 800c4d0:	b002      	add	sp, #8
 800c4d2:	bd70      	pop	{r4, r5, r6, pc}
 800c4d4:	200035cc 	.word	0x200035cc
 800c4d8:	200048dc 	.word	0x200048dc
 800c4dc:	0802dabc 	.word	0x0802dabc
 800c4e0:	0802daf4 	.word	0x0802daf4

0800c4e4 <atcc_analyzeCmd>:
  * @retval at_action_rsp_t Indicates next action.
  */
at_action_rsp_t atcc_analyzeCmd(at_context_t *p_at_ctxt,
                                const IPC_RxMessage_t *p_msg_in,
                                at_element_info_t *element_infos)
{
 800c4e4:	b538      	push	{r3, r4, r5, lr}
  at_action_rsp_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_analyzeCmd)(p_at_ctxt, p_msg_in, element_infos);
 800c4e6:	7803      	ldrb	r3, [r0, #0]
 800c4e8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c4ec:	4c0f      	ldr	r4, [pc, #60]	; (800c52c <atcc_analyzeCmd+0x48>)
 800c4ee:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800c4f2:	695b      	ldr	r3, [r3, #20]
 800c4f4:	4798      	blx	r3
 800c4f6:	4605      	mov	r5, r0

  PRINT_DBG("atcc_analyzeCmd returned action = 0x%x", retval)
 800c4f8:	4c0d      	ldr	r4, [pc, #52]	; (800c530 <atcc_analyzeCmd+0x4c>)
 800c4fa:	4602      	mov	r2, r0
 800c4fc:	490d      	ldr	r1, [pc, #52]	; (800c534 <atcc_analyzeCmd+0x50>)
 800c4fe:	4620      	mov	r0, r4
 800c500:	f019 fbb6 	bl	8025c70 <sprintf>
 800c504:	4620      	mov	r0, r4
 800c506:	f012 fe04 	bl	801f112 <crs_strlen>
 800c50a:	b283      	uxth	r3, r0
 800c50c:	4622      	mov	r2, r4
 800c50e:	2102      	movs	r1, #2
 800c510:	4608      	mov	r0, r1
 800c512:	f012 fe41 	bl	801f198 <traceIF_itmPrint>
 800c516:	4620      	mov	r0, r4
 800c518:	f012 fdfb 	bl	801f112 <crs_strlen>
 800c51c:	b283      	uxth	r3, r0
 800c51e:	4622      	mov	r2, r4
 800c520:	2102      	movs	r1, #2
 800c522:	4608      	mov	r0, r1
 800c524:	f012 fe5a 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c528:	4628      	mov	r0, r5
 800c52a:	bd38      	pop	{r3, r4, r5, pc}
 800c52c:	200035cc 	.word	0x200035cc
 800c530:	200048dc 	.word	0x200048dc
 800c534:	0802db28 	.word	0x0802db28

0800c538 <atcc_analyzeParam>:
  * @retval at_action_rsp_t Indicates next action.
  */
at_action_rsp_t atcc_analyzeParam(at_context_t *p_at_ctxt,
                                  const IPC_RxMessage_t *p_msg_in,
                                  at_element_info_t *element_infos)
{
 800c538:	b538      	push	{r3, r4, r5, lr}
  at_action_rsp_t retval_final;

  retval_final = (*at_custom_func[p_at_ctxt->device_type].f_analyzeParam)(p_at_ctxt, p_msg_in, element_infos);
 800c53a:	7803      	ldrb	r3, [r0, #0]
 800c53c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c540:	4c0f      	ldr	r4, [pc, #60]	; (800c580 <atcc_analyzeParam+0x48>)
 800c542:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800c546:	699b      	ldr	r3, [r3, #24]
 800c548:	4798      	blx	r3
 800c54a:	4605      	mov	r5, r0

  PRINT_DBG("atcc_analyzeParam returned action = 0x%x", retval_final)
 800c54c:	4c0d      	ldr	r4, [pc, #52]	; (800c584 <atcc_analyzeParam+0x4c>)
 800c54e:	4602      	mov	r2, r0
 800c550:	490d      	ldr	r1, [pc, #52]	; (800c588 <atcc_analyzeParam+0x50>)
 800c552:	4620      	mov	r0, r4
 800c554:	f019 fb8c 	bl	8025c70 <sprintf>
 800c558:	4620      	mov	r0, r4
 800c55a:	f012 fdda 	bl	801f112 <crs_strlen>
 800c55e:	b283      	uxth	r3, r0
 800c560:	4622      	mov	r2, r4
 800c562:	2102      	movs	r1, #2
 800c564:	4608      	mov	r0, r1
 800c566:	f012 fe17 	bl	801f198 <traceIF_itmPrint>
 800c56a:	4620      	mov	r0, r4
 800c56c:	f012 fdd1 	bl	801f112 <crs_strlen>
 800c570:	b283      	uxth	r3, r0
 800c572:	4622      	mov	r2, r4
 800c574:	2102      	movs	r1, #2
 800c576:	4608      	mov	r0, r1
 800c578:	f012 fe30 	bl	801f1dc <traceIF_uartPrint>
  return (retval_final);
}
 800c57c:	4628      	mov	r0, r5
 800c57e:	bd38      	pop	{r3, r4, r5, pc}
 800c580:	200035cc 	.word	0x200035cc
 800c584:	200048dc 	.word	0x200048dc
 800c588:	0802db5c 	.word	0x0802db5c

0800c58c <atcc_terminateCmd>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  element_infos Pointer to the structure with extracted information.
  * @retval at_action_rsp_t Indicates next action.
  */
at_action_rsp_t atcc_terminateCmd(at_context_t *p_at_ctxt, at_element_info_t *element_infos)
{
 800c58c:	b538      	push	{r3, r4, r5, lr}
  at_action_rsp_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_terminateCmd)(&p_at_ctxt->parser, element_infos);
 800c58e:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c592:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c596:	4a10      	ldr	r2, [pc, #64]	; (800c5d8 <atcc_terminateCmd+0x4c>)
 800c598:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c59c:	69db      	ldr	r3, [r3, #28]
 800c59e:	4798      	blx	r3
 800c5a0:	4605      	mov	r5, r0

  PRINT_DBG("atcc_terminateCmd returned action = 0x%x", retval)
 800c5a2:	4c0e      	ldr	r4, [pc, #56]	; (800c5dc <atcc_terminateCmd+0x50>)
 800c5a4:	4602      	mov	r2, r0
 800c5a6:	490e      	ldr	r1, [pc, #56]	; (800c5e0 <atcc_terminateCmd+0x54>)
 800c5a8:	4620      	mov	r0, r4
 800c5aa:	f019 fb61 	bl	8025c70 <sprintf>
 800c5ae:	4620      	mov	r0, r4
 800c5b0:	f012 fdaf 	bl	801f112 <crs_strlen>
 800c5b4:	b283      	uxth	r3, r0
 800c5b6:	4622      	mov	r2, r4
 800c5b8:	2102      	movs	r1, #2
 800c5ba:	4608      	mov	r0, r1
 800c5bc:	f012 fdec 	bl	801f198 <traceIF_itmPrint>
 800c5c0:	4620      	mov	r0, r4
 800c5c2:	f012 fda6 	bl	801f112 <crs_strlen>
 800c5c6:	b283      	uxth	r3, r0
 800c5c8:	4622      	mov	r2, r4
 800c5ca:	2102      	movs	r1, #2
 800c5cc:	4608      	mov	r0, r1
 800c5ce:	f012 fe05 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c5d2:	4628      	mov	r0, r5
 800c5d4:	bd38      	pop	{r3, r4, r5, pc}
 800c5d6:	bf00      	nop
 800c5d8:	200035cc 	.word	0x200035cc
 800c5dc:	200048dc 	.word	0x200048dc
 800c5e0:	0802db90 	.word	0x0802db90

0800c5e4 <atcc_get_rsp>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_rsp_buf Pointer to the buffer to return the message.
  * @retval at_status_t
  */
at_status_t atcc_get_rsp(at_context_t *p_at_ctxt, at_buf_t *p_rsp_buf)
{
 800c5e4:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_get_rsp)(&p_at_ctxt->parser, p_rsp_buf);
 800c5e6:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c5ea:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c5ee:	4a10      	ldr	r2, [pc, #64]	; (800c630 <atcc_get_rsp+0x4c>)
 800c5f0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c5f4:	6a1b      	ldr	r3, [r3, #32]
 800c5f6:	4798      	blx	r3
 800c5f8:	4605      	mov	r5, r0

  PRINT_DBG("atcc_get_rsp returned status = %d", retval)
 800c5fa:	4c0e      	ldr	r4, [pc, #56]	; (800c634 <atcc_get_rsp+0x50>)
 800c5fc:	4602      	mov	r2, r0
 800c5fe:	490e      	ldr	r1, [pc, #56]	; (800c638 <atcc_get_rsp+0x54>)
 800c600:	4620      	mov	r0, r4
 800c602:	f019 fb35 	bl	8025c70 <sprintf>
 800c606:	4620      	mov	r0, r4
 800c608:	f012 fd83 	bl	801f112 <crs_strlen>
 800c60c:	b283      	uxth	r3, r0
 800c60e:	4622      	mov	r2, r4
 800c610:	2102      	movs	r1, #2
 800c612:	4608      	mov	r0, r1
 800c614:	f012 fdc0 	bl	801f198 <traceIF_itmPrint>
 800c618:	4620      	mov	r0, r4
 800c61a:	f012 fd7a 	bl	801f112 <crs_strlen>
 800c61e:	b283      	uxth	r3, r0
 800c620:	4622      	mov	r2, r4
 800c622:	2102      	movs	r1, #2
 800c624:	4608      	mov	r0, r1
 800c626:	f012 fdd9 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c62a:	4628      	mov	r0, r5
 800c62c:	bd38      	pop	{r3, r4, r5, pc}
 800c62e:	bf00      	nop
 800c630:	200035cc 	.word	0x200035cc
 800c634:	200048dc 	.word	0x200048dc
 800c638:	0802dbc4 	.word	0x0802dbc4

0800c63c <atcc_get_urc>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_rsp_buf Pointer to the buffer to return the message.
  * @retval at_status_t
  */
at_status_t atcc_get_urc(at_context_t *p_at_ctxt, at_buf_t *p_rsp_buf)
{
 800c63c:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_get_urc)(&p_at_ctxt->parser, p_rsp_buf);
 800c63e:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c642:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c646:	4a10      	ldr	r2, [pc, #64]	; (800c688 <atcc_get_urc+0x4c>)
 800c648:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c64c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c64e:	4798      	blx	r3
 800c650:	4605      	mov	r5, r0

  PRINT_DBG("atcc_get_urc returned status = %d", retval)
 800c652:	4c0e      	ldr	r4, [pc, #56]	; (800c68c <atcc_get_urc+0x50>)
 800c654:	4602      	mov	r2, r0
 800c656:	490e      	ldr	r1, [pc, #56]	; (800c690 <atcc_get_urc+0x54>)
 800c658:	4620      	mov	r0, r4
 800c65a:	f019 fb09 	bl	8025c70 <sprintf>
 800c65e:	4620      	mov	r0, r4
 800c660:	f012 fd57 	bl	801f112 <crs_strlen>
 800c664:	b283      	uxth	r3, r0
 800c666:	4622      	mov	r2, r4
 800c668:	2102      	movs	r1, #2
 800c66a:	4608      	mov	r0, r1
 800c66c:	f012 fd94 	bl	801f198 <traceIF_itmPrint>
 800c670:	4620      	mov	r0, r4
 800c672:	f012 fd4e 	bl	801f112 <crs_strlen>
 800c676:	b283      	uxth	r3, r0
 800c678:	4622      	mov	r2, r4
 800c67a:	2102      	movs	r1, #2
 800c67c:	4608      	mov	r0, r1
 800c67e:	f012 fdad 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c682:	4628      	mov	r0, r5
 800c684:	bd38      	pop	{r3, r4, r5, pc}
 800c686:	bf00      	nop
 800c688:	200035cc 	.word	0x200035cc
 800c68c:	200048dc 	.word	0x200048dc
 800c690:	0802dbf4 	.word	0x0802dbf4

0800c694 <atcc_get_error>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_rsp_buf Pointer to the buffer to return the message.
  * @retval at_status_t
  */
at_status_t atcc_get_error(at_context_t *p_at_ctxt, at_buf_t *p_rsp_buf)
{
 800c694:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_get_error)(&p_at_ctxt->parser, p_rsp_buf);
 800c696:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c69a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c69e:	4a10      	ldr	r2, [pc, #64]	; (800c6e0 <atcc_get_error+0x4c>)
 800c6a0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c6a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c6a6:	4798      	blx	r3
 800c6a8:	4605      	mov	r5, r0

  PRINT_DBG("atcc_get_error returned status = %d", retval)
 800c6aa:	4c0e      	ldr	r4, [pc, #56]	; (800c6e4 <atcc_get_error+0x50>)
 800c6ac:	4602      	mov	r2, r0
 800c6ae:	490e      	ldr	r1, [pc, #56]	; (800c6e8 <atcc_get_error+0x54>)
 800c6b0:	4620      	mov	r0, r4
 800c6b2:	f019 fadd 	bl	8025c70 <sprintf>
 800c6b6:	4620      	mov	r0, r4
 800c6b8:	f012 fd2b 	bl	801f112 <crs_strlen>
 800c6bc:	b283      	uxth	r3, r0
 800c6be:	4622      	mov	r2, r4
 800c6c0:	2102      	movs	r1, #2
 800c6c2:	4608      	mov	r0, r1
 800c6c4:	f012 fd68 	bl	801f198 <traceIF_itmPrint>
 800c6c8:	4620      	mov	r0, r4
 800c6ca:	f012 fd22 	bl	801f112 <crs_strlen>
 800c6ce:	b283      	uxth	r3, r0
 800c6d0:	4622      	mov	r2, r4
 800c6d2:	2102      	movs	r1, #2
 800c6d4:	4608      	mov	r0, r1
 800c6d6:	f012 fd81 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800c6da:	4628      	mov	r0, r5
 800c6dc:	bd38      	pop	{r3, r4, r5, pc}
 800c6de:	bf00      	nop
 800c6e0:	200035cc 	.word	0x200035cc
 800c6e4:	200048dc 	.word	0x200048dc
 800c6e8:	0802dc24 	.word	0x0802dc24

0800c6ec <atcc_hw_event>:
void atcc_hw_event(sysctrl_device_type_t deviceType, at_hw_event_t hwEvent, GPIO_PinState gstate)
{
  /* Do not add traces (called under interrupt if GPIO event)
   * device type = modem
   */
  if (deviceType == DEVTYPE_MODEM_CELLULAR)
 800c6ec:	b930      	cbnz	r0, 800c6fc <atcc_hw_event+0x10>
{
 800c6ee:	b510      	push	{r4, lr}
 800c6f0:	4603      	mov	r3, r0
  {
    (void)(*at_custom_func[DEVTYPE_MODEM_CELLULAR].f_hw_event)(deviceType, hwEvent, gstate);
 800c6f2:	4803      	ldr	r0, [pc, #12]	; (800c700 <atcc_hw_event+0x14>)
 800c6f4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800c6f6:	4618      	mov	r0, r3
 800c6f8:	47a0      	blx	r4
  }
}
 800c6fa:	bd10      	pop	{r4, pc}
 800c6fc:	4770      	bx	lr
 800c6fe:	bf00      	nop
 800c700:	200035cc 	.word	0x200035cc

0800c704 <affect_modem_cid>:

/*
*  Affect a modem cid to the specified user PDP config
*/
static void affect_modem_cid(atcustom_persistent_context_t *p_persistent_ctxt, CS_PDN_conf_id_t conf_id)
{
 800c704:	b538      	push	{r3, r4, r5, lr}

  /* only for CS_PDN_USER_CONFIG_1 to CS_PDN_USER_CONFIG_5 */
  if ((conf_id == CS_PDN_USER_CONFIG_1) ||
      (conf_id == CS_PDN_USER_CONFIG_2) ||
      (conf_id == CS_PDN_USER_CONFIG_3) ||
      (conf_id == CS_PDN_USER_CONFIG_4) ||
 800c706:	1e4b      	subs	r3, r1, #1
 800c708:	b2db      	uxtb	r3, r3
  if ((conf_id == CS_PDN_USER_CONFIG_1) ||
 800c70a:	2b04      	cmp	r3, #4
 800c70c:	d925      	bls.n	800c75a <affect_modem_cid+0x56>
      i++;
    } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
  }
  else
  {
    PRINT_ERR("Trying to affect a non-valid modem CID")
 800c70e:	4c1f      	ldr	r4, [pc, #124]	; (800c78c <affect_modem_cid+0x88>)
 800c710:	4d1f      	ldr	r5, [pc, #124]	; (800c790 <affect_modem_cid+0x8c>)
 800c712:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 800c716:	46a4      	mov	ip, r4
 800c718:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800c71c:	6028      	str	r0, [r5, #0]
 800c71e:	6069      	str	r1, [r5, #4]
 800c720:	60aa      	str	r2, [r5, #8]
 800c722:	60eb      	str	r3, [r5, #12]
 800c724:	4664      	mov	r4, ip
 800c726:	3510      	adds	r5, #16
 800c728:	45f4      	cmp	ip, lr
 800c72a:	d1f4      	bne.n	800c716 <affect_modem_cid+0x12>
 800c72c:	cc03      	ldmia	r4!, {r0, r1}
 800c72e:	6028      	str	r0, [r5, #0]
 800c730:	6069      	str	r1, [r5, #4]
 800c732:	4c17      	ldr	r4, [pc, #92]	; (800c790 <affect_modem_cid+0x8c>)
 800c734:	4620      	mov	r0, r4
 800c736:	f012 fcec 	bl	801f112 <crs_strlen>
 800c73a:	b283      	uxth	r3, r0
 800c73c:	4622      	mov	r2, r4
 800c73e:	2110      	movs	r1, #16
 800c740:	2002      	movs	r0, #2
 800c742:	f012 fd29 	bl	801f198 <traceIF_itmPrint>
 800c746:	4620      	mov	r0, r4
 800c748:	f012 fce3 	bl	801f112 <crs_strlen>
 800c74c:	b283      	uxth	r3, r0
 800c74e:	4622      	mov	r2, r4
 800c750:	2110      	movs	r1, #16
 800c752:	2002      	movs	r0, #2
 800c754:	f012 fd42 	bl	801f1dc <traceIF_uartPrint>
  }

  return;
}
 800c758:	bd38      	pop	{r3, r4, r5, pc}
    uint8_t i = 0U;
 800c75a:	2300      	movs	r3, #0
    bool leave_loop = false;
 800c75c:	461c      	mov	r4, r3
 800c75e:	e005      	b.n	800c76c <affect_modem_cid+0x68>
      i++;
 800c760:	3301      	adds	r3, #1
 800c762:	b2db      	uxtb	r3, r3
    } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800c764:	2c00      	cmp	r4, #0
 800c766:	d1f7      	bne.n	800c758 <affect_modem_cid+0x54>
 800c768:	2b05      	cmp	r3, #5
 800c76a:	d8f5      	bhi.n	800c758 <affect_modem_cid+0x54>
      if (conf_id == p_tmp->affected_config)
 800c76c:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800c770:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800c774:	f892 2352 	ldrb.w	r2, [r2, #850]	; 0x352
 800c778:	428a      	cmp	r2, r1
 800c77a:	d1f1      	bne.n	800c760 <affect_modem_cid+0x5c>
        p_tmp->pdn_defined = AT_TRUE;
 800c77c:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800c780:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800c784:	2401      	movs	r4, #1
 800c786:	f882 4351 	strb.w	r4, [r2, #849]	; 0x351
        leave_loop = true;
 800c78a:	e7e9      	b.n	800c760 <affect_modem_cid+0x5c>
 800c78c:	0802dc54 	.word	0x0802dc54
 800c790:	200048dc 	.word	0x200048dc

0800c794 <atcm_put_IP_address_infos>:
  * @retval none
  */
void atcm_put_IP_address_infos(atcustom_persistent_context_t *p_persistent_ctxt,
                               uint8_t modem_cid,
                               csint_ip_addr_info_t *ip_addr_info)
{
 800c794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c796:	4605      	mov	r5, r0
 800c798:	460e      	mov	r6, r1
 800c79a:	4617      	mov	r7, r2
  bool leave_loop = false;
  uint8_t i = 0U;
 800c79c:	2400      	movs	r4, #0
  bool leave_loop = false;
 800c79e:	4622      	mov	r2, r4
  do
  {
    atcustom_modem_cid_table_t *p_tmp;
    p_tmp = &p_persistent_ctxt->modem_cid_table[i];
    if (p_tmp->mdm_cid_value == modem_cid)
 800c7a0:	eb04 1304 	add.w	r3, r4, r4, lsl #4
 800c7a4:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800c7a8:	f893 3350 	ldrb.w	r3, [r3, #848]	; 0x350
 800c7ac:	42b3      	cmp	r3, r6
 800c7ae:	d005      	beq.n	800c7bc <atcm_put_IP_address_infos+0x28>
      (void) memcpy((void *)& p_tmp->ip_addr_infos,
                    (void *)ip_addr_info,
                    sizeof(csint_ip_addr_info_t));
      leave_loop = true;
    }
    i++;
 800c7b0:	3401      	adds	r4, #1
 800c7b2:	b2e4      	uxtb	r4, r4
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800c7b4:	b90a      	cbnz	r2, 800c7ba <atcm_put_IP_address_infos+0x26>
 800c7b6:	2c05      	cmp	r4, #5
 800c7b8:	d9f2      	bls.n	800c7a0 <atcm_put_IP_address_infos+0xc>

  return;
}
 800c7ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void) memcpy((void *)& p_tmp->ip_addr_infos,
 800c7bc:	eb04 1004 	add.w	r0, r4, r4, lsl #4
 800c7c0:	0080      	lsls	r0, r0, #2
 800c7c2:	f500 7054 	add.w	r0, r0, #848	; 0x350
 800c7c6:	4428      	add	r0, r5
 800c7c8:	2241      	movs	r2, #65	; 0x41
 800c7ca:	4639      	mov	r1, r7
 800c7cc:	3003      	adds	r0, #3
 800c7ce:	f019 fb9f 	bl	8025f10 <memcpy>
      leave_loop = true;
 800c7d2:	2201      	movs	r2, #1
 800c7d4:	e7ec      	b.n	800c7b0 <atcm_put_IP_address_infos+0x1c>

0800c7d6 <atcm_get_IP_address_infos>:
  * @retval none
  */
void atcm_get_IP_address_infos(atcustom_persistent_context_t *p_persistent_ctxt,
                               CS_PDN_conf_id_t conf_id,
                               csint_ip_addr_info_t  *ip_addr_info)
{
 800c7d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c7d8:	4605      	mov	r5, r0
 800c7da:	460e      	mov	r6, r1
 800c7dc:	4617      	mov	r7, r2
  bool leave_loop = false;
  uint8_t i = 0U;
 800c7de:	2400      	movs	r4, #0
  bool leave_loop = false;
 800c7e0:	4622      	mov	r2, r4
  do
  {
    atcustom_modem_cid_table_t *p_tmp;
    p_tmp = &p_persistent_ctxt->modem_cid_table[i];
    if (p_tmp->affected_config == conf_id)
 800c7e2:	eb04 1304 	add.w	r3, r4, r4, lsl #4
 800c7e6:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800c7ea:	f893 3352 	ldrb.w	r3, [r3, #850]	; 0x352
 800c7ee:	42b3      	cmp	r3, r6
 800c7f0:	d005      	beq.n	800c7fe <atcm_get_IP_address_infos+0x28>
      (void) memcpy((void *)ip_addr_info,
                    (void *)& p_tmp->ip_addr_infos,
                    sizeof(csint_ip_addr_info_t));
      leave_loop = true;
    }
    i++;
 800c7f2:	3401      	adds	r4, #1
 800c7f4:	b2e4      	uxtb	r4, r4
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800c7f6:	b90a      	cbnz	r2, 800c7fc <atcm_get_IP_address_infos+0x26>
 800c7f8:	2c05      	cmp	r4, #5
 800c7fa:	d9f2      	bls.n	800c7e2 <atcm_get_IP_address_infos+0xc>

  return;
}
 800c7fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    (void *)& p_tmp->ip_addr_infos,
 800c7fe:	eb04 1104 	add.w	r1, r4, r4, lsl #4
 800c802:	0089      	lsls	r1, r1, #2
 800c804:	f501 7154 	add.w	r1, r1, #848	; 0x350
 800c808:	4429      	add	r1, r5
      (void) memcpy((void *)ip_addr_info,
 800c80a:	2241      	movs	r2, #65	; 0x41
 800c80c:	3103      	adds	r1, #3
 800c80e:	4638      	mov	r0, r7
 800c810:	f019 fb7e 	bl	8025f10 <memcpy>
      leave_loop = true;
 800c814:	2201      	movs	r2, #1
 800c816:	e7ec      	b.n	800c7f2 <atcm_get_IP_address_infos+0x1c>

0800c818 <atcm_get_ip_address_type>:
  *                According to 3GP TS27.007, IPv6 can also use IPv4-like dot-notation:
  *                format= a1.a2.a3.a4.a5a.a6.a7.a8.a9.a10.a11.a12a.a13.a14.a15.a16  (where 0<=ax<=255)
  *                (max string size = 63 characters )
  *
  */
  if (p_addr_str != NULL)
 800c818:	b328      	cbz	r0, 800c866 <atcm_get_ip_address_type+0x4e>
{
 800c81a:	b510      	push	{r4, lr}
 800c81c:	4604      	mov	r4, r0
  {
    uint8_t str_size_cpt = (uint8_t) strlen((const CRC_CHAR_t *)p_addr_str);
 800c81e:	f7f3 fce9 	bl	80001f4 <strlen>
 800c822:	b2c0      	uxtb	r0, r0
    str_size_cpt = (str_size_cpt > 39U) ? 39U : str_size_cpt;
 800c824:	2827      	cmp	r0, #39	; 0x27
 800c826:	bf28      	it	cs
 800c828:	2027      	movcs	r0, #39	; 0x27
    uint8_t count_dots = 0U;
    uint8_t count_colons = 0U;
 800c82a:	2100      	movs	r1, #0
    uint8_t count_dots = 0U;
 800c82c:	460a      	mov	r2, r1
 800c82e:	e006      	b.n	800c83e <atcm_get_ip_address_type+0x26>

    do
    {
      if (*pTmp == ((AT_CHAR_t)'.'))
      {
        count_dots++;
 800c830:	3201      	adds	r2, #1
 800c832:	b2d2      	uxtb	r2, r2
      else
      {
        /* nothing to do - MISRA */
      }
      /* next character */
      pTmp++;
 800c834:	3401      	adds	r4, #1
      str_size_cpt--;
 800c836:	3801      	subs	r0, #1
    }  while (str_size_cpt > 0U);
 800c838:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 800c83c:	d007      	beq.n	800c84e <atcm_get_ip_address_type+0x36>
      if (*pTmp == ((AT_CHAR_t)'.'))
 800c83e:	7823      	ldrb	r3, [r4, #0]
 800c840:	2b2e      	cmp	r3, #46	; 0x2e
 800c842:	d0f5      	beq.n	800c830 <atcm_get_ip_address_type+0x18>
      else if (*pTmp == ((AT_CHAR_t)':'))
 800c844:	2b3a      	cmp	r3, #58	; 0x3a
 800c846:	d1f5      	bne.n	800c834 <atcm_get_ip_address_type+0x1c>
        count_colons++;
 800c848:	3101      	adds	r1, #1
 800c84a:	b2c9      	uxtb	r1, r1
 800c84c:	e7f2      	b.n	800c834 <atcm_get_ip_address_type+0x1c>

    /* analyze result */
    if ((count_dots >= 1U) && (count_dots <= 3U))
 800c84e:	1e53      	subs	r3, r2, #1
 800c850:	b2db      	uxtb	r3, r3
 800c852:	2b02      	cmp	r3, #2
 800c854:	d909      	bls.n	800c86a <atcm_get_ip_address_type+0x52>
    {
      retval = CS_IPAT_IPV4;
    }
    else if (((count_colons >= 1U) && (count_colons <= 7U)) ||
 800c856:	3901      	subs	r1, #1
 800c858:	b2c9      	uxtb	r1, r1
 800c85a:	2906      	cmp	r1, #6
 800c85c:	d907      	bls.n	800c86e <atcm_get_ip_address_type+0x56>
 800c85e:	2a03      	cmp	r2, #3
 800c860:	d904      	bls.n	800c86c <atcm_get_ip_address_type+0x54>
             (count_dots > 3U))
    {
      retval = CS_IPAT_IPV6;
 800c862:	2002      	movs	r0, #2
 800c864:	e002      	b.n	800c86c <atcm_get_ip_address_type+0x54>
      retval = CS_IPAT_INVALID;
    }
  }
  else
  {
    retval = CS_IPAT_INVALID;
 800c866:	2000      	movs	r0, #0
  }

  return (retval);
}
 800c868:	4770      	bx	lr
      retval = CS_IPAT_IPV4;
 800c86a:	2001      	movs	r0, #1
}
 800c86c:	bd10      	pop	{r4, pc}
      retval = CS_IPAT_IPV6;
 800c86e:	2002      	movs	r0, #2
 800c870:	e7fc      	b.n	800c86c <atcm_get_ip_address_type+0x54>

0800c872 <atcm_extract_IP_address>:
  * @param  p_Dst ptr to Destination Buffer !!! this buffer has to be defined
  *               with buffer[MAX_IP_ADDR_SIZE] !!!
  * @retval at_status_t.
  */
void atcm_extract_IP_address(const uint8_t *p_Src, uint16_t size, uint8_t *p_Dst)
{
 800c872:	b570      	push	{r4, r5, r6, lr}
 800c874:	4605      	mov	r5, r0
 800c876:	460c      	mov	r4, r1
 800c878:	4616      	mov	r6, r2
  uint16_t src_idx;
  uint16_t dest_idx = 0U;

  /* reset p_Dst buffer */
  (void) memset((void *)p_Dst, 0, MAX_IP_ADDR_SIZE);
 800c87a:	2240      	movs	r2, #64	; 0x40
 800c87c:	2100      	movs	r1, #0
 800c87e:	4630      	mov	r0, r6
 800c880:	f019 fa69 	bl	8025d56 <memset>
  uint16_t dest_idx = 0U;
 800c884:	f04f 0c00 	mov.w	ip, #0

  /* parse p_Src */
  for (src_idx = 0; ((src_idx < size) && (dest_idx < MAX_IP_ADDR_SIZE)); src_idx++)
 800c888:	4663      	mov	r3, ip
 800c88a:	e001      	b.n	800c890 <atcm_extract_IP_address+0x1e>
 800c88c:	3301      	adds	r3, #1
 800c88e:	b29b      	uxth	r3, r3
 800c890:	42a3      	cmp	r3, r4
 800c892:	d20e      	bcs.n	800c8b2 <atcm_extract_IP_address+0x40>
 800c894:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
 800c898:	d80b      	bhi.n	800c8b2 <atcm_extract_IP_address+0x40>
  {
    /* remove quotes from the string */
    if (p_Src[src_idx] != 0x22U)
 800c89a:	f815 e003 	ldrb.w	lr, [r5, r3]
 800c89e:	f1be 0f22 	cmp.w	lr, #34	; 0x22
 800c8a2:	d0f3      	beq.n	800c88c <atcm_extract_IP_address+0x1a>
    {
      /* write to p_Dst*/
      p_Dst[dest_idx] = p_Src[src_idx];
 800c8a4:	f806 e00c 	strb.w	lr, [r6, ip]
      dest_idx++;
 800c8a8:	f10c 0c01 	add.w	ip, ip, #1
 800c8ac:	fa1f fc8c 	uxth.w	ip, ip
 800c8b0:	e7ec      	b.n	800c88c <atcm_extract_IP_address+0x1a>
    }
  }
}
 800c8b2:	bd70      	pop	{r4, r5, r6, pc}

0800c8b4 <atcm_get_cid_current_SID>:
  * @brief  Get conf_ig in current SID context (interpret default if needed)
  * @param  p_modem_ctxt
  * @retval CS_PDN_conf_id_t
  */
CS_PDN_conf_id_t atcm_get_cid_current_SID(atcustom_modem_context_t *p_modem_ctxt)
{
 800c8b4:	b538      	push	{r3, r4, r5, lr}
  /* get conf_id received for current SID */
  CS_PDN_conf_id_t current_conf_id = p_modem_ctxt->SID_ctxt.pdn_conf_id;
 800c8b6:	f890 46c9 	ldrb.w	r4, [r0, #1737]	; 0x6c9

  /* if default PDN is required, retrieve corresponding conf_id */
  if (current_conf_id == CS_PDN_CONFIG_DEFAULT)
 800c8ba:	2c0b      	cmp	r4, #11
 800c8bc:	d001      	beq.n	800c8c2 <atcm_get_cid_current_SID+0xe>
    current_conf_id = p_modem_ctxt->persist.pdn_default_conf_id;
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
  }

  return (current_conf_id);
}
 800c8be:	4620      	mov	r0, r4
 800c8c0:	bd38      	pop	{r3, r4, r5, pc}
    current_conf_id = p_modem_ctxt->persist.pdn_default_conf_id;
 800c8c2:	f890 44f4 	ldrb.w	r4, [r0, #1268]	; 0x4f4
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
 800c8c6:	4d0c      	ldr	r5, [pc, #48]	; (800c8f8 <atcm_get_cid_current_SID+0x44>)
 800c8c8:	4622      	mov	r2, r4
 800c8ca:	490c      	ldr	r1, [pc, #48]	; (800c8fc <atcm_get_cid_current_SID+0x48>)
 800c8cc:	4628      	mov	r0, r5
 800c8ce:	f019 f9cf 	bl	8025c70 <sprintf>
 800c8d2:	4628      	mov	r0, r5
 800c8d4:	f012 fc1d 	bl	801f112 <crs_strlen>
 800c8d8:	b283      	uxth	r3, r0
 800c8da:	462a      	mov	r2, r5
 800c8dc:	2102      	movs	r1, #2
 800c8de:	4608      	mov	r0, r1
 800c8e0:	f012 fc5a 	bl	801f198 <traceIF_itmPrint>
 800c8e4:	4628      	mov	r0, r5
 800c8e6:	f012 fc14 	bl	801f112 <crs_strlen>
 800c8ea:	b283      	uxth	r3, r0
 800c8ec:	462a      	mov	r2, r5
 800c8ee:	2102      	movs	r1, #2
 800c8f0:	4608      	mov	r0, r1
 800c8f2:	f012 fc73 	bl	801f1dc <traceIF_uartPrint>
 800c8f6:	e7e2      	b.n	800c8be <atcm_get_cid_current_SID+0xa>
 800c8f8:	200048dc 	.word	0x200048dc
 800c8fc:	0802dc8c 	.word	0x0802dc8c

0800c900 <atcm_get_CmdStr>:
  const AT_CHAR_t *retval = ((uint8_t *)"");
  uint16_t i = 0U;
  bool leave_loop = false;

  /* check if this is the invalid cmd id*/
  if (cmd_id != CMD_AT_INVALID)
 800c900:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c904:	d101      	bne.n	800c90a <atcm_get_CmdStr+0xa>
  const AT_CHAR_t *retval = ((uint8_t *)"");
 800c906:	480e      	ldr	r0, [pc, #56]	; (800c940 <atcm_get_CmdStr+0x40>)
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c908:	4770      	bx	lr
{
 800c90a:	b530      	push	{r4, r5, lr}
 800c90c:	4603      	mov	r3, r0
  bool leave_loop = false;
 800c90e:	2500      	movs	r5, #0
  uint16_t i = 0U;
 800c910:	462a      	mov	r2, r5
  const AT_CHAR_t *retval = ((uint8_t *)"");
 800c912:	480b      	ldr	r0, [pc, #44]	; (800c940 <atcm_get_CmdStr+0x40>)
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c914:	685c      	ldr	r4, [r3, #4]
 800c916:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800c91a:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c91e:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c922:	f854 400e 	ldr.w	r4, [r4, lr]
 800c926:	428c      	cmp	r4, r1
 800c928:	d006      	beq.n	800c938 <atcm_get_CmdStr+0x38>
      i++;
 800c92a:	3201      	adds	r2, #1
 800c92c:	b292      	uxth	r2, r2
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c92e:	b915      	cbnz	r5, 800c936 <atcm_get_CmdStr+0x36>
 800c930:	681c      	ldr	r4, [r3, #0]
 800c932:	42a2      	cmp	r2, r4
 800c934:	d3ee      	bcc.n	800c914 <atcm_get_CmdStr+0x14>
}
 800c936:	bd30      	pop	{r4, r5, pc}
        retval = (const AT_CHAR_t *)(&p_modem_ctxt->p_modem_LUT[i].cmd_str);
 800c938:	f10c 0004 	add.w	r0, ip, #4
        leave_loop = true;
 800c93c:	2501      	movs	r5, #1
 800c93e:	e7f4      	b.n	800c92a <atcm_get_CmdStr+0x2a>
 800c940:	08034f74 	.word	0x08034f74

0800c944 <atcm_get_CmdTimeout>:
uint32_t atcm_get_CmdTimeout(const atcustom_modem_context_t *p_modem_ctxt, uint32_t cmd_id)
{
  uint32_t retval = MODEM_DEFAULT_TIMEOUT;

  /* check if this is the invalid cmd id */
  if (cmd_id != CMD_AT_INVALID)
 800c944:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c948:	d102      	bne.n	800c950 <atcm_get_CmdTimeout+0xc>
  uint32_t retval = MODEM_DEFAULT_TIMEOUT;
 800c94a:	f242 7010 	movw	r0, #10000	; 0x2710
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c94e:	4770      	bx	lr
{
 800c950:	b530      	push	{r4, r5, lr}
 800c952:	4602      	mov	r2, r0
    uint16_t i = 0U;
 800c954:	2300      	movs	r3, #0
    bool leave_loop = false;
 800c956:	461d      	mov	r5, r3
  uint32_t retval = MODEM_DEFAULT_TIMEOUT;
 800c958:	f242 7010 	movw	r0, #10000	; 0x2710
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c95c:	6854      	ldr	r4, [r2, #4]
 800c95e:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 800c962:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c966:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c96a:	f854 400e 	ldr.w	r4, [r4, lr]
 800c96e:	428c      	cmp	r4, r1
 800c970:	d006      	beq.n	800c980 <atcm_get_CmdTimeout+0x3c>
      i++;
 800c972:	3301      	adds	r3, #1
 800c974:	b29b      	uxth	r3, r3
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c976:	b915      	cbnz	r5, 800c97e <atcm_get_CmdTimeout+0x3a>
 800c978:	6814      	ldr	r4, [r2, #0]
 800c97a:	42a3      	cmp	r3, r4
 800c97c:	d3ee      	bcc.n	800c95c <atcm_get_CmdTimeout+0x18>
}
 800c97e:	bd30      	pop	{r4, r5, pc}
        retval = p_modem_ctxt->p_modem_LUT[i].cmd_timeout;
 800c980:	f8dc 0024 	ldr.w	r0, [ip, #36]	; 0x24
        leave_loop = true;
 800c984:	2501      	movs	r5, #1
 800c986:	e7f4      	b.n	800c972 <atcm_get_CmdTimeout+0x2e>

0800c988 <atcm_get_CmdBuildFunc>:
  */
CmdBuildFuncTypeDef atcm_get_CmdBuildFunc(const atcustom_modem_context_t *p_modem_ctxt, uint32_t cmd_id)
{
  CmdBuildFuncTypeDef retval = fCmdBuild_NoParams; /* return default value */

  if (cmd_id != CMD_AT_INVALID)
 800c988:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c98c:	d101      	bne.n	800c992 <atcm_get_CmdBuildFunc+0xa>
  CmdBuildFuncTypeDef retval = fCmdBuild_NoParams; /* return default value */
 800c98e:	480e      	ldr	r0, [pc, #56]	; (800c9c8 <atcm_get_CmdBuildFunc+0x40>)
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c990:	4770      	bx	lr
{
 800c992:	b530      	push	{r4, r5, lr}
 800c994:	4603      	mov	r3, r0
    bool leave_loop = false;
 800c996:	2500      	movs	r5, #0
    uint16_t i = 0U;
 800c998:	462a      	mov	r2, r5
  CmdBuildFuncTypeDef retval = fCmdBuild_NoParams; /* return default value */
 800c99a:	480b      	ldr	r0, [pc, #44]	; (800c9c8 <atcm_get_CmdBuildFunc+0x40>)
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c99c:	685c      	ldr	r4, [r3, #4]
 800c99e:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800c9a2:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c9a6:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c9aa:	f854 400e 	ldr.w	r4, [r4, lr]
 800c9ae:	428c      	cmp	r4, r1
 800c9b0:	d006      	beq.n	800c9c0 <atcm_get_CmdBuildFunc+0x38>
      i++;
 800c9b2:	3201      	adds	r2, #1
 800c9b4:	b292      	uxth	r2, r2
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c9b6:	b915      	cbnz	r5, 800c9be <atcm_get_CmdBuildFunc+0x36>
 800c9b8:	681c      	ldr	r4, [r3, #0]
 800c9ba:	42a2      	cmp	r2, r4
 800c9bc:	d3ee      	bcc.n	800c99c <atcm_get_CmdBuildFunc+0x14>
}
 800c9be:	bd30      	pop	{r4, r5, pc}
        retval = p_modem_ctxt->p_modem_LUT[i].cmd_BuildFunc;
 800c9c0:	f8dc 0028 	ldr.w	r0, [ip, #40]	; 0x28
        leave_loop = true;
 800c9c4:	2501      	movs	r5, #1
 800c9c6:	e7f4      	b.n	800c9b2 <atcm_get_CmdBuildFunc+0x2a>
 800c9c8:	0800ed0d 	.word	0x0800ed0d

0800c9cc <atcm_get_CmdAnalyzeFunc>:
  */
CmdAnalyzeFuncTypeDef atcm_get_CmdAnalyzeFunc(const atcustom_modem_context_t *p_modem_ctxt, uint32_t cmd_id)
{
  CmdAnalyzeFuncTypeDef retval = fRspAnalyze_None;

  if (cmd_id != CMD_AT_INVALID)
 800c9cc:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c9d0:	d101      	bne.n	800c9d6 <atcm_get_CmdAnalyzeFunc+0xa>
  CmdAnalyzeFuncTypeDef retval = fRspAnalyze_None;
 800c9d2:	480e      	ldr	r0, [pc, #56]	; (800ca0c <atcm_get_CmdAnalyzeFunc+0x40>)
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c9d4:	4770      	bx	lr
{
 800c9d6:	b530      	push	{r4, r5, lr}
 800c9d8:	4603      	mov	r3, r0
    bool leave_loop = false;
 800c9da:	2500      	movs	r5, #0
    uint16_t i = 0U;
 800c9dc:	462a      	mov	r2, r5
  CmdAnalyzeFuncTypeDef retval = fRspAnalyze_None;
 800c9de:	480b      	ldr	r0, [pc, #44]	; (800ca0c <atcm_get_CmdAnalyzeFunc+0x40>)
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c9e0:	685c      	ldr	r4, [r3, #4]
 800c9e2:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800c9e6:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c9ea:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c9ee:	f854 400e 	ldr.w	r4, [r4, lr]
 800c9f2:	428c      	cmp	r4, r1
 800c9f4:	d006      	beq.n	800ca04 <atcm_get_CmdAnalyzeFunc+0x38>
      i++;
 800c9f6:	3201      	adds	r2, #1
 800c9f8:	b292      	uxth	r2, r2
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c9fa:	b915      	cbnz	r5, 800ca02 <atcm_get_CmdAnalyzeFunc+0x36>
 800c9fc:	681c      	ldr	r4, [r3, #0]
 800c9fe:	42a2      	cmp	r2, r4
 800ca00:	d3ee      	bcc.n	800c9e0 <atcm_get_CmdAnalyzeFunc+0x14>
}
 800ca02:	bd30      	pop	{r4, r5, pc}
        retval = p_modem_ctxt->p_modem_LUT[i].rsp_AnalyzeFunc;
 800ca04:	f8dc 002c 	ldr.w	r0, [ip, #44]	; 0x2c
        leave_loop = true;
 800ca08:	2501      	movs	r5, #1
 800ca0a:	e7f4      	b.n	800c9f6 <atcm_get_CmdAnalyzeFunc+0x2a>
 800ca0c:	08010075 	.word	0x08010075

0800ca10 <atcm_get_PDPtypeStr>:
  * @brief  Get type of PDP address
  * @param  pdp_type
  * @retval AT_CHAR_t
  */
const AT_CHAR_t *atcm_get_PDPtypeStr(CS_PDPtype_t pdp_type)
{
 800ca10:	b410      	push	{r4}
 800ca12:	4684      	mov	ip, r0
    {CS_PDPTYPE_IPV4V6, "IPV4V6"},
    {CS_PDPTYPE_PPP,    "PPP"},
  };
  uint16_t i = 0U;
  uint16_t max_array_size = (uint16_t)(sizeof(ACTM_PDP_TYPE_LUT) / sizeof(atcm_pdp_type_LUT_t));
  bool leave_loop = false;
 800ca14:	2400      	movs	r4, #0
  uint16_t i = 0U;
 800ca16:	4623      	mov	r3, r4
  const AT_CHAR_t *retval = ((uint8_t *)"");
 800ca18:	480b      	ldr	r0, [pc, #44]	; (800ca48 <atcm_get_PDPtypeStr+0x38>)
 800ca1a:	e004      	b.n	800ca26 <atcm_get_PDPtypeStr+0x16>
    if (pdp_type == ACTM_PDP_TYPE_LUT[i].pdp_type)
    {
      retval = ((const AT_CHAR_t *)(&ACTM_PDP_TYPE_LUT[i].pdp_type_string));
      leave_loop = true;
    }
    i++;
 800ca1c:	3301      	adds	r3, #1
 800ca1e:	b29b      	uxth	r3, r3
  } while ((leave_loop == false) && (i < max_array_size));
 800ca20:	b974      	cbnz	r4, 800ca40 <atcm_get_PDPtypeStr+0x30>
 800ca22:	2b03      	cmp	r3, #3
 800ca24:	d80c      	bhi.n	800ca40 <atcm_get_PDPtypeStr+0x30>
    if (pdp_type == ACTM_PDP_TYPE_LUT[i].pdp_type)
 800ca26:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800ca2a:	4908      	ldr	r1, [pc, #32]	; (800ca4c <atcm_get_PDPtypeStr+0x3c>)
 800ca2c:	5c8a      	ldrb	r2, [r1, r2]
 800ca2e:	4562      	cmp	r2, ip
 800ca30:	d1f4      	bne.n	800ca1c <atcm_get_PDPtypeStr+0xc>
      retval = ((const AT_CHAR_t *)(&ACTM_PDP_TYPE_LUT[i].pdp_type_string));
 800ca32:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 800ca36:	4a05      	ldr	r2, [pc, #20]	; (800ca4c <atcm_get_PDPtypeStr+0x3c>)
 800ca38:	440a      	add	r2, r1
 800ca3a:	1c50      	adds	r0, r2, #1
      leave_loop = true;
 800ca3c:	2401      	movs	r4, #1
 800ca3e:	e7ed      	b.n	800ca1c <atcm_get_PDPtypeStr+0xc>

  /* string no found, return empty string */
  return (retval);
}
 800ca40:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ca44:	4770      	bx	lr
 800ca46:	bf00      	nop
 800ca48:	08034f74 	.word	0x08034f74
 800ca4c:	0802e29c 	.word	0x0802e29c

0800ca50 <atcm_program_AT_CMD>:
void atcm_program_AT_CMD(atcustom_modem_context_t *p_modem_ctxt,
                         atparser_context_t *p_atp_ctxt,
                         at_type_t cmd_type,
                         uint32_t cmd_id,
                         atcustom_FinalCmd_t final)
{
 800ca50:	b510      	push	{r4, lr}
 800ca52:	460c      	mov	r4, r1
 800ca54:	4619      	mov	r1, r3
 800ca56:	f89d 3008 	ldrb.w	r3, [sp, #8]
  /* command type */
  p_atp_ctxt->current_atcmd.type = cmd_type;
 800ca5a:	8122      	strh	r2, [r4, #8]
  /* command id */
  p_atp_ctxt->current_atcmd.id = cmd_id;
 800ca5c:	60e1      	str	r1, [r4, #12]
  /* is it final command ? */
  p_atp_ctxt->is_final_cmd = (final == FINAL_CMD) ? 1U : 0U;
 800ca5e:	2b01      	cmp	r3, #1
 800ca60:	d000      	beq.n	800ca64 <atcm_program_AT_CMD+0x14>
 800ca62:	2300      	movs	r3, #0
 800ca64:	7123      	strb	r3, [r4, #4]
  /* an answer is expected */
  p_atp_ctxt->answer_expected = CMD_MANDATORY_ANSWER_EXPECTED;
 800ca66:	2300      	movs	r3, #0
 800ca68:	70e3      	strb	r3, [r4, #3]

  /* set command timeout according to LUT */
  p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800ca6a:	f7ff ff6b 	bl	800c944 <atcm_get_CmdTimeout>
 800ca6e:	f8c4 0678 	str.w	r0, [r4, #1656]	; 0x678
}
 800ca72:	bd10      	pop	{r4, pc}

0800ca74 <atcm_program_AT_CMD_ANSWER_OPTIONAL>:
void atcm_program_AT_CMD_ANSWER_OPTIONAL(atcustom_modem_context_t *p_modem_ctxt,
                                         atparser_context_t *p_atp_ctxt,
                                         at_type_t cmd_type,
                                         uint32_t cmd_id,
                                         atcustom_FinalCmd_t final)
{
 800ca74:	b510      	push	{r4, lr}
 800ca76:	460c      	mov	r4, r1
 800ca78:	4619      	mov	r1, r3
 800ca7a:	f89d 3008 	ldrb.w	r3, [sp, #8]
  /* command type */
  p_atp_ctxt->current_atcmd.type = cmd_type;
 800ca7e:	8122      	strh	r2, [r4, #8]
  /* command id */
  p_atp_ctxt->current_atcmd.id = cmd_id;
 800ca80:	60e1      	str	r1, [r4, #12]
  /* is it final command ? */
  p_atp_ctxt->is_final_cmd = (final == FINAL_CMD) ? 1U : 0U;
 800ca82:	2b01      	cmp	r3, #1
 800ca84:	d000      	beq.n	800ca88 <atcm_program_AT_CMD_ANSWER_OPTIONAL+0x14>
 800ca86:	2300      	movs	r3, #0
 800ca88:	7123      	strb	r3, [r4, #4]
  /* an answer is expected */
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800ca8a:	2301      	movs	r3, #1
 800ca8c:	70e3      	strb	r3, [r4, #3]

  /* set command timeout according to LUT */
  p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800ca8e:	f7ff ff59 	bl	800c944 <atcm_get_CmdTimeout>
 800ca92:	f8c4 0678 	str.w	r0, [r4, #1656]	; 0x678
}
 800ca96:	bd10      	pop	{r4, pc}

0800ca98 <atcm_program_CMD_TIMEOUT>:
  * @retval none
  */
void atcm_program_CMD_TIMEOUT(atcustom_modem_context_t *p_modem_ctxt,
                              atparser_context_t *p_atp_ctxt,
                              uint32_t new_timeout)
{
 800ca98:	b510      	push	{r4, lr}
 800ca9a:	460c      	mov	r4, r1
  if (new_timeout == 0U)
 800ca9c:	b112      	cbz	r2, 800caa4 <atcm_program_CMD_TIMEOUT+0xc>
    /* set command timeout according to LUT */
    p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
  }
  else
  {
    p_atp_ctxt->cmd_timeout = new_timeout;
 800ca9e:	f8c4 2678 	str.w	r2, [r4, #1656]	; 0x678
  }
}
 800caa2:	bd10      	pop	{r4, pc}
    p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800caa4:	68c9      	ldr	r1, [r1, #12]
 800caa6:	f7ff ff4d 	bl	800c944 <atcm_get_CmdTimeout>
 800caaa:	f8c4 0678 	str.w	r0, [r4, #1656]	; 0x678
 800caae:	e7f8      	b.n	800caa2 <atcm_program_CMD_TIMEOUT+0xa>

0800cab0 <atcm_program_TEMPO>:
  * @param  tempo_value
  * @param  final
  * @retval none
  */
void atcm_program_TEMPO(atparser_context_t *p_atp_ctxt, uint32_t tempo_value, atcustom_FinalCmd_t final)
{
 800cab0:	b538      	push	{r3, r4, r5, lr}
  p_atp_ctxt->current_atcmd.type = ATTYPE_NO_CMD;
 800cab2:	2305      	movs	r3, #5
 800cab4:	8103      	strh	r3, [r0, #8]
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 800cab6:	f04f 33ff 	mov.w	r3, #4294967295
 800caba:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->is_final_cmd = (final == FINAL_CMD) ? 1U : 0U;
 800cabc:	2a01      	cmp	r2, #1
 800cabe:	d000      	beq.n	800cac2 <atcm_program_TEMPO+0x12>
 800cac0:	2200      	movs	r2, #0
 800cac2:	7102      	strb	r2, [r0, #4]
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800cac4:	2501      	movs	r5, #1
 800cac6:	70c5      	strb	r5, [r0, #3]
  p_atp_ctxt->cmd_timeout = tempo_value;
 800cac8:	f8c0 1678 	str.w	r1, [r0, #1656]	; 0x678

  PRINT_INFO("Tempo started (%ld ms)...", tempo_value)
 800cacc:	4c0c      	ldr	r4, [pc, #48]	; (800cb00 <atcm_program_TEMPO+0x50>)
 800cace:	460a      	mov	r2, r1
 800cad0:	490c      	ldr	r1, [pc, #48]	; (800cb04 <atcm_program_TEMPO+0x54>)
 800cad2:	4620      	mov	r0, r4
 800cad4:	f019 f8cc 	bl	8025c70 <sprintf>
 800cad8:	4620      	mov	r0, r4
 800cada:	f012 fb1a 	bl	801f112 <crs_strlen>
 800cade:	b283      	uxth	r3, r0
 800cae0:	4622      	mov	r2, r4
 800cae2:	4629      	mov	r1, r5
 800cae4:	2002      	movs	r0, #2
 800cae6:	f012 fb57 	bl	801f198 <traceIF_itmPrint>
 800caea:	4620      	mov	r0, r4
 800caec:	f012 fb11 	bl	801f112 <crs_strlen>
 800caf0:	b283      	uxth	r3, r0
 800caf2:	4622      	mov	r2, r4
 800caf4:	4629      	mov	r1, r5
 800caf6:	2002      	movs	r0, #2
 800caf8:	f012 fb70 	bl	801f1dc <traceIF_uartPrint>
}
 800cafc:	bd38      	pop	{r3, r4, r5, pc}
 800cafe:	bf00      	nop
 800cb00:	200048dc 	.word	0x200048dc
 800cb04:	0802dcc4 	.word	0x0802dcc4

0800cb08 <atcm_program_NO_MORE_CMD>:
  * @param  p_atp_ctxt
  * @retval none
  */
void atcm_program_NO_MORE_CMD(atparser_context_t *p_atp_ctxt)
{
  p_atp_ctxt->current_atcmd.type = ATTYPE_NO_CMD;
 800cb08:	2305      	movs	r3, #5
 800cb0a:	8103      	strh	r3, [r0, #8]
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 800cb0c:	f04f 33ff 	mov.w	r3, #4294967295
 800cb10:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->is_final_cmd = 1U;
 800cb12:	2301      	movs	r3, #1
 800cb14:	7103      	strb	r3, [r0, #4]
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800cb16:	70c3      	strb	r3, [r0, #3]
  p_atp_ctxt->cmd_timeout = 0U;
 800cb18:	2300      	movs	r3, #0
 800cb1a:	f8c0 3678 	str.w	r3, [r0, #1656]	; 0x678
}
 800cb1e:	4770      	bx	lr

0800cb20 <atcm_program_SKIP_CMD>:
  * @param  p_atp_ctxt
  * @retval none
  */
void atcm_program_SKIP_CMD(atparser_context_t *p_atp_ctxt)
{
  p_atp_ctxt->current_atcmd.type = ATTYPE_NO_CMD;
 800cb20:	2305      	movs	r3, #5
 800cb22:	8103      	strh	r3, [r0, #8]
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 800cb24:	f04f 33ff 	mov.w	r3, #4294967295
 800cb28:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->is_final_cmd = 0U;
 800cb2a:	2300      	movs	r3, #0
 800cb2c:	7103      	strb	r3, [r0, #4]
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800cb2e:	2201      	movs	r2, #1
 800cb30:	70c2      	strb	r2, [r0, #3]
  p_atp_ctxt->cmd_timeout = 0U;
 800cb32:	f8c0 3678 	str.w	r3, [r0, #1656]	; 0x678
}
 800cb36:	4770      	bx	lr

0800cb38 <atcm_modem_build_cmd>:
  * @retval at_status_t
  */
at_status_t atcm_modem_build_cmd(atcustom_modem_context_t *p_modem_ctxt,
                                 atparser_context_t *p_atp_ctxt,
                                 uint32_t *p_ATcmdTimeout)
{
 800cb38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cb3c:	b083      	sub	sp, #12
 800cb3e:	4607      	mov	r7, r0
 800cb40:	460c      	mov	r4, r1
 800cb42:	4690      	mov	r8, r2
  at_status_t retval = ATSTATUS_OK;

  /* 1- set the commande name (get it from LUT) */
  const AT_CHAR_t *p_cmd_name_string = atcm_get_CmdStr(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800cb44:	68c9      	ldr	r1, [r1, #12]
 800cb46:	f7ff fedb 	bl	800c900 <atcm_get_CmdStr>
 800cb4a:	4605      	mov	r5, r0
  uint8_t string_length = (uint8_t) strlen((const CRC_CHAR_t *) p_cmd_name_string);
 800cb4c:	f7f3 fb52 	bl	80001f4 <strlen>
  (void) memcpy((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.name,
 800cb50:	f104 0910 	add.w	r9, r4, #16
 800cb54:	b2c6      	uxtb	r6, r0
 800cb56:	4632      	mov	r2, r6
 800cb58:	4629      	mov	r1, r5
 800cb5a:	4648      	mov	r0, r9
 800cb5c:	f019 f9d8 	bl	8025f10 <memcpy>
                p_cmd_name_string,
                string_length);

  PRINT_DBG("<modem custom> build the cmd %s (type=%d, length=%d)",
 800cb60:	4d32      	ldr	r5, [pc, #200]	; (800cc2c <atcm_modem_build_cmd+0xf4>)
 800cb62:	9600      	str	r6, [sp, #0]
 800cb64:	8923      	ldrh	r3, [r4, #8]
 800cb66:	464a      	mov	r2, r9
 800cb68:	4931      	ldr	r1, [pc, #196]	; (800cc30 <atcm_modem_build_cmd+0xf8>)
 800cb6a:	4628      	mov	r0, r5
 800cb6c:	f019 f880 	bl	8025c70 <sprintf>
 800cb70:	4628      	mov	r0, r5
 800cb72:	f012 face 	bl	801f112 <crs_strlen>
 800cb76:	b283      	uxth	r3, r0
 800cb78:	462a      	mov	r2, r5
 800cb7a:	2102      	movs	r1, #2
 800cb7c:	4608      	mov	r0, r1
 800cb7e:	f012 fb0b 	bl	801f198 <traceIF_itmPrint>
 800cb82:	4628      	mov	r0, r5
 800cb84:	f012 fac5 	bl	801f112 <crs_strlen>
 800cb88:	b283      	uxth	r3, r0
 800cb8a:	462a      	mov	r2, r5
 800cb8c:	2102      	movs	r1, #2
 800cb8e:	4608      	mov	r0, r1
 800cb90:	f012 fb24 	bl	801f1dc <traceIF_uartPrint>
            p_atp_ctxt->current_atcmd.name,
            p_atp_ctxt->current_atcmd.type,
            string_length)

  /* 2- set the command parameters (only for write or execution commands or for data) */
  if ((p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD) ||
 800cb94:	8922      	ldrh	r2, [r4, #8]
 800cb96:	1ed3      	subs	r3, r2, #3
 800cb98:	b29b      	uxth	r3, r3
 800cb9a:	2b01      	cmp	r3, #1
 800cb9c:	d903      	bls.n	800cba6 <atcm_modem_build_cmd+0x6e>
      (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD) ||
 800cb9e:	2a06      	cmp	r2, #6
 800cba0:	d001      	beq.n	800cba6 <atcm_modem_build_cmd+0x6e>
  at_status_t retval = ATSTATUS_OK;
 800cba2:	2600      	movs	r6, #0
 800cba4:	e008      	b.n	800cbb8 <atcm_modem_build_cmd+0x80>
      (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD))
  {
    retval = (atcm_get_CmdBuildFunc(p_modem_ctxt, p_atp_ctxt->current_atcmd.id))(p_atp_ctxt, p_modem_ctxt);
 800cba6:	68e1      	ldr	r1, [r4, #12]
 800cba8:	4638      	mov	r0, r7
 800cbaa:	f7ff feed 	bl	800c988 <atcm_get_CmdBuildFunc>
 800cbae:	4603      	mov	r3, r0
 800cbb0:	4639      	mov	r1, r7
 800cbb2:	4620      	mov	r0, r4
 800cbb4:	4798      	blx	r3
 800cbb6:	4606      	mov	r6, r0
  }

  /* 3- set command timeout (has been set in command programmation) */
  *p_ATcmdTimeout = p_atp_ctxt->cmd_timeout;
 800cbb8:	f8d4 2678 	ldr.w	r2, [r4, #1656]	; 0x678
 800cbbc:	f8c8 2000 	str.w	r2, [r8]
  PRINT_DBG("==== CMD TIMEOUT = %ld ====", *p_ATcmdTimeout)
 800cbc0:	4d1a      	ldr	r5, [pc, #104]	; (800cc2c <atcm_modem_build_cmd+0xf4>)
 800cbc2:	491c      	ldr	r1, [pc, #112]	; (800cc34 <atcm_modem_build_cmd+0xfc>)
 800cbc4:	4628      	mov	r0, r5
 800cbc6:	f019 f853 	bl	8025c70 <sprintf>
 800cbca:	4628      	mov	r0, r5
 800cbcc:	f012 faa1 	bl	801f112 <crs_strlen>
 800cbd0:	b283      	uxth	r3, r0
 800cbd2:	462a      	mov	r2, r5
 800cbd4:	2102      	movs	r1, #2
 800cbd6:	4608      	mov	r0, r1
 800cbd8:	f012 fade 	bl	801f198 <traceIF_itmPrint>
 800cbdc:	4628      	mov	r0, r5
 800cbde:	f012 fa98 	bl	801f112 <crs_strlen>
 800cbe2:	b283      	uxth	r3, r0
 800cbe4:	462a      	mov	r2, r5
 800cbe6:	2102      	movs	r1, #2
 800cbe8:	4608      	mov	r0, r1
 800cbea:	f012 faf7 	bl	801f1dc <traceIF_uartPrint>

  /* increment step in SID treatment */
  p_atp_ctxt->step++;
 800cbee:	78a3      	ldrb	r3, [r4, #2]
 800cbf0:	3301      	adds	r3, #1
 800cbf2:	70a3      	strb	r3, [r4, #2]

  PRINT_DBG("atcm_modem_build_cmd returned status = %d", retval)
 800cbf4:	4632      	mov	r2, r6
 800cbf6:	4910      	ldr	r1, [pc, #64]	; (800cc38 <atcm_modem_build_cmd+0x100>)
 800cbf8:	4628      	mov	r0, r5
 800cbfa:	f019 f839 	bl	8025c70 <sprintf>
 800cbfe:	4628      	mov	r0, r5
 800cc00:	f012 fa87 	bl	801f112 <crs_strlen>
 800cc04:	b283      	uxth	r3, r0
 800cc06:	462a      	mov	r2, r5
 800cc08:	2102      	movs	r1, #2
 800cc0a:	4608      	mov	r0, r1
 800cc0c:	f012 fac4 	bl	801f198 <traceIF_itmPrint>
 800cc10:	4628      	mov	r0, r5
 800cc12:	f012 fa7e 	bl	801f112 <crs_strlen>
 800cc16:	b283      	uxth	r3, r0
 800cc18:	462a      	mov	r2, r5
 800cc1a:	2102      	movs	r1, #2
 800cc1c:	4608      	mov	r0, r1
 800cc1e:	f012 fadd 	bl	801f1dc <traceIF_uartPrint>
  return (retval);
}
 800cc22:	4630      	mov	r0, r6
 800cc24:	b003      	add	sp, #12
 800cc26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800cc2a:	bf00      	nop
 800cc2c:	200048dc 	.word	0x200048dc
 800cc30:	0802dcec 	.word	0x0802dcec
 800cc34:	0802dd2c 	.word	0x0802dd2c
 800cc38:	0802dd54 	.word	0x0802dd54

0800cc3c <atcm_modem_get_rsp>:
  * @retval at_status_t
  */
at_status_t atcm_modem_get_rsp(atcustom_modem_context_t *p_modem_ctxt,
                               const atparser_context_t *p_atp_ctxt,
                               at_buf_t *p_rsp_buf)
{
 800cc3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cc3e:	b093      	sub	sp, #76	; 0x4c
 800cc40:	4604      	mov	r4, r0
 800cc42:	4615      	mov	r5, r2

  /* prepare response for a SID
  *  all common behaviors for SID which are returning data in rsp_buf have to be implemented here
  */

  switch (p_atp_ctxt->current_SID)
 800cc44:	880b      	ldrh	r3, [r1, #0]
 800cc46:	3b69      	subs	r3, #105	; 0x69
 800cc48:	2b1f      	cmp	r3, #31
 800cc4a:	f200 8192 	bhi.w	800cf72 <atcm_modem_get_rsp+0x336>
 800cc4e:	e8df f013 	tbh	[pc, r3, lsl #1]
 800cc52:	00ce      	.short	0x00ce
 800cc54:	01900190 	.word	0x01900190
 800cc58:	002000ce 	.word	0x002000ce
 800cc5c:	01900190 	.word	0x01900190
 800cc60:	01900190 	.word	0x01900190
 800cc64:	01900190 	.word	0x01900190
 800cc68:	01090190 	.word	0x01090190
 800cc6c:	01900190 	.word	0x01900190
 800cc70:	01900190 	.word	0x01900190
 800cc74:	00510190 	.word	0x00510190
 800cc78:	01900082 	.word	0x01900082
 800cc7c:	01900190 	.word	0x01900190
 800cc80:	01900190 	.word	0x01900190
 800cc84:	01900190 	.word	0x01900190
 800cc88:	01900190 	.word	0x01900190
 800cc8c:	01900190 	.word	0x01900190
 800cc90:	0160      	.short	0x0160
  {
    case SID_CS_GET_ATTACHSTATUS:
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800cc92:	f200 6365 	addw	r3, r0, #1637	; 0x665
 800cc96:	2201      	movs	r2, #1
 800cc98:	2113      	movs	r1, #19
 800cc9a:	4628      	mov	r0, r5
 800cc9c:	f7ff fa0a 	bl	800c0b4 <DATAPACK_writeStruct>
 800cca0:	2800      	cmp	r0, #0
 800cca2:	f000 8167 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_ATTACHSTATUS,
                               (uint16_t) sizeof(CS_PSattach_t),
                               (void *)&p_modem_ctxt->SID_ctxt.attach_status) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800cca6:	4eb4      	ldr	r6, [pc, #720]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800cca8:	4cb4      	ldr	r4, [pc, #720]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ccaa:	f106 0720 	add.w	r7, r6, #32
 800ccae:	4635      	mov	r5, r6
 800ccb0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ccb2:	6020      	str	r0, [r4, #0]
 800ccb4:	6061      	str	r1, [r4, #4]
 800ccb6:	60a2      	str	r2, [r4, #8]
 800ccb8:	60e3      	str	r3, [r4, #12]
 800ccba:	462e      	mov	r6, r5
 800ccbc:	3410      	adds	r4, #16
 800ccbe:	42bd      	cmp	r5, r7
 800ccc0:	d1f5      	bne.n	800ccae <atcm_modem_get_rsp+0x72>
 800ccc2:	6828      	ldr	r0, [r5, #0]
 800ccc4:	6020      	str	r0, [r4, #0]
 800ccc6:	792b      	ldrb	r3, [r5, #4]
 800ccc8:	7123      	strb	r3, [r4, #4]
 800ccca:	4cac      	ldr	r4, [pc, #688]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cccc:	4620      	mov	r0, r4
 800ccce:	f012 fa20 	bl	801f112 <crs_strlen>
 800ccd2:	b283      	uxth	r3, r0
 800ccd4:	4622      	mov	r2, r4
 800ccd6:	2110      	movs	r1, #16
 800ccd8:	2002      	movs	r0, #2
 800ccda:	f012 fa5d 	bl	801f198 <traceIF_itmPrint>
 800ccde:	4620      	mov	r0, r4
 800cce0:	f012 fa17 	bl	801f112 <crs_strlen>
 800cce4:	b283      	uxth	r3, r0
 800cce6:	4622      	mov	r2, r4
 800cce8:	2110      	movs	r1, #16
 800ccea:	2002      	movs	r0, #2
 800ccec:	f012 fa76 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800ccf0:	2001      	movs	r0, #1
 800ccf2:	e13f      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
      }
      break;

    case SID_CS_RECEIVE_DATA:
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800ccf4:	f500 63ea 	add.w	r3, r0, #1872	; 0x750
 800ccf8:	2204      	movs	r2, #4
 800ccfa:	211a      	movs	r1, #26
 800ccfc:	4628      	mov	r0, r5
 800ccfe:	f7ff f9d9 	bl	800c0b4 <DATAPACK_writeStruct>
 800cd02:	2800      	cmp	r0, #0
 800cd04:	f000 8136 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_SOCKET_RXDATA,
                               (uint16_t) sizeof(uint32_t),
                               (void *)&p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800cd08:	4e9b      	ldr	r6, [pc, #620]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800cd0a:	4c9c      	ldr	r4, [pc, #624]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cd0c:	f106 0720 	add.w	r7, r6, #32
 800cd10:	4635      	mov	r5, r6
 800cd12:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800cd14:	6020      	str	r0, [r4, #0]
 800cd16:	6061      	str	r1, [r4, #4]
 800cd18:	60a2      	str	r2, [r4, #8]
 800cd1a:	60e3      	str	r3, [r4, #12]
 800cd1c:	462e      	mov	r6, r5
 800cd1e:	3410      	adds	r4, #16
 800cd20:	42bd      	cmp	r5, r7
 800cd22:	d1f5      	bne.n	800cd10 <atcm_modem_get_rsp+0xd4>
 800cd24:	6828      	ldr	r0, [r5, #0]
 800cd26:	6020      	str	r0, [r4, #0]
 800cd28:	792b      	ldrb	r3, [r5, #4]
 800cd2a:	7123      	strb	r3, [r4, #4]
 800cd2c:	4c93      	ldr	r4, [pc, #588]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cd2e:	4620      	mov	r0, r4
 800cd30:	f012 f9ef 	bl	801f112 <crs_strlen>
 800cd34:	b283      	uxth	r3, r0
 800cd36:	4622      	mov	r2, r4
 800cd38:	2110      	movs	r1, #16
 800cd3a:	2002      	movs	r0, #2
 800cd3c:	f012 fa2c 	bl	801f198 <traceIF_itmPrint>
 800cd40:	4620      	mov	r0, r4
 800cd42:	f012 f9e6 	bl	801f112 <crs_strlen>
 800cd46:	b283      	uxth	r3, r0
 800cd48:	4622      	mov	r2, r4
 800cd4a:	2110      	movs	r1, #16
 800cd4c:	2002      	movs	r0, #2
 800cd4e:	f012 fa45 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cd52:	2001      	movs	r0, #1
 800cd54:	e10e      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
      break;

    case SID_CS_RECEIVE_DATA_FROM:
    {
      csint_socket_rxdata_from_t  rxdata_from;
      (void) memset((void *)&rxdata_from, 0, sizeof(csint_socket_rxdata_from_t));
 800cd56:	2648      	movs	r6, #72	; 0x48
 800cd58:	4632      	mov	r2, r6
 800cd5a:	2100      	movs	r1, #0
 800cd5c:	4668      	mov	r0, sp
 800cd5e:	f018 fffa 	bl	8025d56 <memset>
      /* recopy info received */
      rxdata_from.bytes_received = p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size;
 800cd62:	f8d4 3750 	ldr.w	r3, [r4, #1872]	; 0x750
 800cd66:	9300      	str	r3, [sp, #0]
      (void) memcpy((void *)&rxdata_from.ip_addr_value,
                    (void *)p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value,
 800cd68:	f204 7759 	addw	r7, r4, #1881	; 0x759
      (void) memcpy((void *)&rxdata_from.ip_addr_value,
 800cd6c:	4638      	mov	r0, r7
 800cd6e:	f7f3 fa41 	bl	80001f4 <strlen>
 800cd72:	4602      	mov	r2, r0
 800cd74:	4639      	mov	r1, r7
 800cd76:	f10d 0005 	add.w	r0, sp, #5
 800cd7a:	f019 f8c9 	bl	8025f10 <memcpy>
                    strlen((CRC_CHAR_t *)p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value));
      rxdata_from.remote_port = p_modem_ctxt->socket_ctxt.socketReceivedata.remote_port;
 800cd7e:	f8b4 379a 	ldrh.w	r3, [r4, #1946]	; 0x79a
 800cd82:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
      if (DATAPACK_writeStruct(p_rsp_buf,
 800cd86:	466b      	mov	r3, sp
 800cd88:	4632      	mov	r2, r6
 800cd8a:	211b      	movs	r1, #27
 800cd8c:	4628      	mov	r0, r5
 800cd8e:	f7ff f991 	bl	800c0b4 <DATAPACK_writeStruct>
 800cd92:	2800      	cmp	r0, #0
 800cd94:	f000 80ee 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_SOCKET_RXDATA_FROM,
                               (uint16_t) sizeof(csint_socket_rxdata_from_t),
                               (void *)&rxdata_from) != DATAPACK_OK)
      {
        PRINT_ERR("Receive data from problem")
 800cd98:	4d79      	ldr	r5, [pc, #484]	; (800cf80 <atcm_modem_get_rsp+0x344>)
 800cd9a:	4c78      	ldr	r4, [pc, #480]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cd9c:	f105 0620 	add.w	r6, r5, #32
 800cda0:	46ac      	mov	ip, r5
 800cda2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cda6:	6020      	str	r0, [r4, #0]
 800cda8:	6061      	str	r1, [r4, #4]
 800cdaa:	60a2      	str	r2, [r4, #8]
 800cdac:	60e3      	str	r3, [r4, #12]
 800cdae:	4665      	mov	r5, ip
 800cdb0:	3410      	adds	r4, #16
 800cdb2:	45b4      	cmp	ip, r6
 800cdb4:	d1f4      	bne.n	800cda0 <atcm_modem_get_rsp+0x164>
 800cdb6:	cd03      	ldmia	r5!, {r0, r1}
 800cdb8:	6020      	str	r0, [r4, #0]
 800cdba:	6061      	str	r1, [r4, #4]
 800cdbc:	882a      	ldrh	r2, [r5, #0]
 800cdbe:	78ab      	ldrb	r3, [r5, #2]
 800cdc0:	8122      	strh	r2, [r4, #8]
 800cdc2:	72a3      	strb	r3, [r4, #10]
 800cdc4:	4c6d      	ldr	r4, [pc, #436]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cdc6:	4620      	mov	r0, r4
 800cdc8:	f012 f9a3 	bl	801f112 <crs_strlen>
 800cdcc:	b283      	uxth	r3, r0
 800cdce:	4622      	mov	r2, r4
 800cdd0:	2110      	movs	r1, #16
 800cdd2:	2002      	movs	r0, #2
 800cdd4:	f012 f9e0 	bl	801f198 <traceIF_itmPrint>
 800cdd8:	4620      	mov	r0, r4
 800cdda:	f012 f99a 	bl	801f112 <crs_strlen>
 800cdde:	b283      	uxth	r3, r0
 800cde0:	4622      	mov	r2, r4
 800cde2:	2110      	movs	r1, #16
 800cde4:	2002      	movs	r0, #2
 800cde6:	f012 f9f9 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cdea:	2001      	movs	r0, #1
      }
      break;
 800cdec:	e0c2      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
    }

    case SID_CS_REGISTER_NET:
    case SID_CS_GET_NETSTATUS:
      /* Add EPS, GPRS and CS registration states (from CREG, CGREG, CEREG commands) */
      p_modem_ctxt->SID_ctxt.read_operator_infos.EPS_NetworkRegState = p_modem_ctxt->persist.eps_network_state;
 800cdee:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 800cdf0:	f8a0 3612 	strh.w	r3, [r0, #1554]	; 0x612
      p_modem_ctxt->SID_ctxt.read_operator_infos.GPRS_NetworkRegState = p_modem_ctxt->persist.gprs_network_state;
 800cdf4:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
 800cdf6:	f8a0 3614 	strh.w	r3, [r0, #1556]	; 0x614
      p_modem_ctxt->SID_ctxt.read_operator_infos.CS_NetworkRegState = p_modem_ctxt->persist.cs_network_state;
 800cdfa:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
 800cdfe:	f8a0 3616 	strh.w	r3, [r0, #1558]	; 0x616
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800ce02:	f500 63c2 	add.w	r3, r0, #1552	; 0x610
 800ce06:	224e      	movs	r2, #78	; 0x4e
 800ce08:	2115      	movs	r1, #21
 800ce0a:	4628      	mov	r0, r5
 800ce0c:	f7ff f952 	bl	800c0b4 <DATAPACK_writeStruct>
 800ce10:	2800      	cmp	r0, #0
 800ce12:	f000 80af 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_REGISTRATIONSTATUS,
                               (uint16_t) sizeof(CS_RegistrationStatus_t),
                               (void *)&p_modem_ctxt->SID_ctxt.read_operator_infos) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800ce16:	4e58      	ldr	r6, [pc, #352]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800ce18:	4c58      	ldr	r4, [pc, #352]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ce1a:	f106 0720 	add.w	r7, r6, #32
 800ce1e:	4635      	mov	r5, r6
 800ce20:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ce22:	6020      	str	r0, [r4, #0]
 800ce24:	6061      	str	r1, [r4, #4]
 800ce26:	60a2      	str	r2, [r4, #8]
 800ce28:	60e3      	str	r3, [r4, #12]
 800ce2a:	462e      	mov	r6, r5
 800ce2c:	3410      	adds	r4, #16
 800ce2e:	42bd      	cmp	r5, r7
 800ce30:	d1f5      	bne.n	800ce1e <atcm_modem_get_rsp+0x1e2>
 800ce32:	6828      	ldr	r0, [r5, #0]
 800ce34:	6020      	str	r0, [r4, #0]
 800ce36:	792b      	ldrb	r3, [r5, #4]
 800ce38:	7123      	strb	r3, [r4, #4]
 800ce3a:	4c50      	ldr	r4, [pc, #320]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ce3c:	4620      	mov	r0, r4
 800ce3e:	f012 f968 	bl	801f112 <crs_strlen>
 800ce42:	b283      	uxth	r3, r0
 800ce44:	4622      	mov	r2, r4
 800ce46:	2110      	movs	r1, #16
 800ce48:	2002      	movs	r0, #2
 800ce4a:	f012 f9a5 	bl	801f198 <traceIF_itmPrint>
 800ce4e:	4620      	mov	r0, r4
 800ce50:	f012 f95f 	bl	801f112 <crs_strlen>
 800ce54:	b283      	uxth	r3, r0
 800ce56:	4622      	mov	r2, r4
 800ce58:	2110      	movs	r1, #16
 800ce5a:	2002      	movs	r0, #2
 800ce5c:	f012 f9be 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800ce60:	2001      	movs	r0, #1
 800ce62:	e087      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
      }
      break;

    case SID_CS_GET_IP_ADDRESS:
    {
      CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800ce64:	f7ff fd26 	bl	800c8b4 <atcm_get_cid_current_SID>
 800ce68:	4606      	mov	r6, r0
      csint_ip_addr_info_t ip_addr_info;
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 800ce6a:	2741      	movs	r7, #65	; 0x41
 800ce6c:	463a      	mov	r2, r7
 800ce6e:	2100      	movs	r1, #0
 800ce70:	4668      	mov	r0, sp
 800ce72:	f018 ff70 	bl	8025d56 <memset>
      /* retrieve IP infos for request config_id */
      atcm_get_IP_address_infos(&p_modem_ctxt->persist, current_conf_id, &ip_addr_info);
 800ce76:	466a      	mov	r2, sp
 800ce78:	4631      	mov	r1, r6
 800ce7a:	f104 000c 	add.w	r0, r4, #12
 800ce7e:	f7ff fcaa 	bl	800c7d6 <atcm_get_IP_address_infos>
      PRINT_DBG("retrieve IP address for cid %d = %s", current_conf_id, ip_addr_info.ip_addr_value)
 800ce82:	4c3e      	ldr	r4, [pc, #248]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ce84:	f10d 0301 	add.w	r3, sp, #1
 800ce88:	4632      	mov	r2, r6
 800ce8a:	493e      	ldr	r1, [pc, #248]	; (800cf84 <atcm_modem_get_rsp+0x348>)
 800ce8c:	4620      	mov	r0, r4
 800ce8e:	f018 feef 	bl	8025c70 <sprintf>
 800ce92:	4620      	mov	r0, r4
 800ce94:	f012 f93d 	bl	801f112 <crs_strlen>
 800ce98:	b283      	uxth	r3, r0
 800ce9a:	4622      	mov	r2, r4
 800ce9c:	2102      	movs	r1, #2
 800ce9e:	4608      	mov	r0, r1
 800cea0:	f012 f97a 	bl	801f198 <traceIF_itmPrint>
 800cea4:	4620      	mov	r0, r4
 800cea6:	f012 f934 	bl	801f112 <crs_strlen>
 800ceaa:	b283      	uxth	r3, r0
 800ceac:	4622      	mov	r2, r4
 800ceae:	2102      	movs	r1, #2
 800ceb0:	4608      	mov	r0, r1
 800ceb2:	f012 f993 	bl	801f1dc <traceIF_uartPrint>
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800ceb6:	466b      	mov	r3, sp
 800ceb8:	463a      	mov	r2, r7
 800ceba:	2125      	movs	r1, #37	; 0x25
 800cebc:	4628      	mov	r0, r5
 800cebe:	f7ff f8f9 	bl	800c0b4 <DATAPACK_writeStruct>
 800cec2:	2800      	cmp	r0, #0
 800cec4:	d056      	beq.n	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_GET_IP_ADDRESS,
                               (uint16_t) sizeof(csint_ip_addr_info_t),
                               (void *)&ip_addr_info) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800cec6:	4e2c      	ldr	r6, [pc, #176]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800cec8:	f106 0720 	add.w	r7, r6, #32
 800cecc:	4635      	mov	r5, r6
 800cece:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ced0:	6020      	str	r0, [r4, #0]
 800ced2:	6061      	str	r1, [r4, #4]
 800ced4:	60a2      	str	r2, [r4, #8]
 800ced6:	60e3      	str	r3, [r4, #12]
 800ced8:	462e      	mov	r6, r5
 800ceda:	3410      	adds	r4, #16
 800cedc:	42bd      	cmp	r5, r7
 800cede:	d1f5      	bne.n	800cecc <atcm_modem_get_rsp+0x290>
 800cee0:	6828      	ldr	r0, [r5, #0]
 800cee2:	6020      	str	r0, [r4, #0]
 800cee4:	792b      	ldrb	r3, [r5, #4]
 800cee6:	7123      	strb	r3, [r4, #4]
 800cee8:	4c24      	ldr	r4, [pc, #144]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ceea:	4620      	mov	r0, r4
 800ceec:	f012 f911 	bl	801f112 <crs_strlen>
 800cef0:	b283      	uxth	r3, r0
 800cef2:	4622      	mov	r2, r4
 800cef4:	2110      	movs	r1, #16
 800cef6:	2002      	movs	r0, #2
 800cef8:	f012 f94e 	bl	801f198 <traceIF_itmPrint>
 800cefc:	4620      	mov	r0, r4
 800cefe:	f012 f908 	bl	801f112 <crs_strlen>
 800cf02:	b283      	uxth	r3, r0
 800cf04:	4622      	mov	r2, r4
 800cf06:	2110      	movs	r1, #16
 800cf08:	2002      	movs	r0, #2
 800cf0a:	f012 f967 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cf0e:	2001      	movs	r0, #1
      }
      break;
 800cf10:	e030      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
    }

    case SID_CS_SIM_GENERIC_ACCESS:
    {
      /* recopy info received for cellular service in p_rsp_buf */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800cf12:	f500 63cd 	add.w	r3, r0, #1640	; 0x668
 800cf16:	2208      	movs	r2, #8
 800cf18:	212d      	movs	r1, #45	; 0x2d
 800cf1a:	4628      	mov	r0, r5
 800cf1c:	f7ff f8ca 	bl	800c0b4 <DATAPACK_writeStruct>
 800cf20:	b340      	cbz	r0, 800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_SIM_GENERIC_ACCESS,
                               (uint16_t) sizeof(csint_sim_generic_access_t),
                               (void *)&p_modem_ctxt->SID_ctxt.sim_generic_access) != DATAPACK_OK)
      {
        PRINT_ERR("SIM generic access problem")
 800cf22:	4d19      	ldr	r5, [pc, #100]	; (800cf88 <atcm_modem_get_rsp+0x34c>)
 800cf24:	4c15      	ldr	r4, [pc, #84]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cf26:	f105 0620 	add.w	r6, r5, #32
 800cf2a:	46ac      	mov	ip, r5
 800cf2c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cf30:	6020      	str	r0, [r4, #0]
 800cf32:	6061      	str	r1, [r4, #4]
 800cf34:	60a2      	str	r2, [r4, #8]
 800cf36:	60e3      	str	r3, [r4, #12]
 800cf38:	4665      	mov	r5, ip
 800cf3a:	3410      	adds	r4, #16
 800cf3c:	45b4      	cmp	ip, r6
 800cf3e:	d1f4      	bne.n	800cf2a <atcm_modem_get_rsp+0x2ee>
 800cf40:	cd07      	ldmia	r5!, {r0, r1, r2}
 800cf42:	6020      	str	r0, [r4, #0]
 800cf44:	6061      	str	r1, [r4, #4]
 800cf46:	60a2      	str	r2, [r4, #8]
 800cf48:	4c0c      	ldr	r4, [pc, #48]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cf4a:	4620      	mov	r0, r4
 800cf4c:	f012 f8e1 	bl	801f112 <crs_strlen>
 800cf50:	b283      	uxth	r3, r0
 800cf52:	4622      	mov	r2, r4
 800cf54:	2110      	movs	r1, #16
 800cf56:	2002      	movs	r0, #2
 800cf58:	f012 f91e 	bl	801f198 <traceIF_itmPrint>
 800cf5c:	4620      	mov	r0, r4
 800cf5e:	f012 f8d8 	bl	801f112 <crs_strlen>
 800cf62:	b283      	uxth	r3, r0
 800cf64:	4622      	mov	r2, r4
 800cf66:	2110      	movs	r1, #16
 800cf68:	2002      	movs	r0, #2
 800cf6a:	f012 f937 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cf6e:	2001      	movs	r0, #1
 800cf70:	e000      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
  switch (p_atp_ctxt->current_SID)
 800cf72:	2000      	movs	r0, #0
    default:
      break;
  }

  return (retval);
}
 800cf74:	b013      	add	sp, #76	; 0x4c
 800cf76:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cf78:	0802dd8c 	.word	0x0802dd8c
 800cf7c:	200048dc 	.word	0x200048dc
 800cf80:	0802ddb4 	.word	0x0802ddb4
 800cf84:	0802dde0 	.word	0x0802dde0
 800cf88:	0802de10 	.word	0x0802de10

0800cf8c <atcm_modem_get_error>:
  * @retval at_status_t
  */
at_status_t atcm_modem_get_error(atcustom_modem_context_t *p_modem_ctxt,
                                 const atparser_context_t *p_atp_ctxt,
                                 at_buf_t *p_rsp_buf)
{
 800cf8c:	b538      	push	{r3, r4, r5, lr}
 800cf8e:	4603      	mov	r3, r0
 800cf90:	4610      	mov	r0, r2
  UNUSED(p_atp_ctxt);
  at_status_t retval = ATSTATUS_OK;

  /* prepare error report */
  if (DATAPACK_writeStruct(p_rsp_buf,
 800cf92:	f203 732a 	addw	r3, r3, #1834	; 0x72a
 800cf96:	2202      	movs	r2, #2
 800cf98:	212a      	movs	r1, #42	; 0x2a
 800cf9a:	f7ff f88b 	bl	800c0b4 <DATAPACK_writeStruct>
 800cf9e:	b900      	cbnz	r0, 800cfa2 <atcm_modem_get_error+0x16>
  {
    PRINT_ERR("Buffer size problem")
    retval = ATSTATUS_ERROR;
  }
  return (retval);
}
 800cfa0:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_ERR("Buffer size problem")
 800cfa2:	4d15      	ldr	r5, [pc, #84]	; (800cff8 <atcm_modem_get_error+0x6c>)
 800cfa4:	4c15      	ldr	r4, [pc, #84]	; (800cffc <atcm_modem_get_error+0x70>)
 800cfa6:	f105 0e20 	add.w	lr, r5, #32
 800cfaa:	46ac      	mov	ip, r5
 800cfac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cfb0:	6020      	str	r0, [r4, #0]
 800cfb2:	6061      	str	r1, [r4, #4]
 800cfb4:	60a2      	str	r2, [r4, #8]
 800cfb6:	60e3      	str	r3, [r4, #12]
 800cfb8:	4665      	mov	r5, ip
 800cfba:	3410      	adds	r4, #16
 800cfbc:	45f4      	cmp	ip, lr
 800cfbe:	d1f4      	bne.n	800cfaa <atcm_modem_get_error+0x1e>
 800cfc0:	f8dc 0000 	ldr.w	r0, [ip]
 800cfc4:	6020      	str	r0, [r4, #0]
 800cfc6:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800cfca:	7123      	strb	r3, [r4, #4]
 800cfcc:	4c0b      	ldr	r4, [pc, #44]	; (800cffc <atcm_modem_get_error+0x70>)
 800cfce:	4620      	mov	r0, r4
 800cfd0:	f012 f89f 	bl	801f112 <crs_strlen>
 800cfd4:	b283      	uxth	r3, r0
 800cfd6:	4622      	mov	r2, r4
 800cfd8:	2110      	movs	r1, #16
 800cfda:	2002      	movs	r0, #2
 800cfdc:	f012 f8dc 	bl	801f198 <traceIF_itmPrint>
 800cfe0:	4620      	mov	r0, r4
 800cfe2:	f012 f896 	bl	801f112 <crs_strlen>
 800cfe6:	b283      	uxth	r3, r0
 800cfe8:	4622      	mov	r2, r4
 800cfea:	2110      	movs	r1, #16
 800cfec:	2002      	movs	r0, #2
 800cfee:	f012 f8f5 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800cff2:	2001      	movs	r0, #1
 800cff4:	e7d4      	b.n	800cfa0 <atcm_modem_get_error+0x14>
 800cff6:	bf00      	nop
 800cff8:	0802dd8c 	.word	0x0802dd8c
 800cffc:	200048dc 	.word	0x200048dc

0800d000 <atcm_subscribe_net_event>:
  * @param  p_modem_ctxt  pointer to modem context
  * @param  p_atp_ctxt    pointer to parser context
  * @retval at_status_t
  */
at_status_t atcm_subscribe_net_event(atcustom_modem_context_t *p_modem_ctxt, atparser_context_t *p_atp_ctxt)
{
 800d000:	b500      	push	{lr}
 800d002:	b083      	sub	sp, #12
  /* Retrieve urc event request: CEREG, CREG or CGREG ?
  *  note: only one event at same time
  */
  CS_UrcEvent_t urcEvent = p_modem_ctxt->SID_ctxt.urcEvent;
 800d004:	f890 3664 	ldrb.w	r3, [r0, #1636]	; 0x664

  /* is an event linked to CEREG ? */
  if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO))
 800d008:	1e5a      	subs	r2, r3, #1
 800d00a:	b2d2      	uxtb	r2, r2
 800d00c:	2a01      	cmp	r2, #1
 800d00e:	d918      	bls.n	800d042 <atcm_subscribe_net_event+0x42>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CGREG ?  */
  else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 800d010:	1eda      	subs	r2, r3, #3
 800d012:	b2d2      	uxtb	r2, r2
 800d014:	2a01      	cmp	r2, #1
 800d016:	d938      	bls.n	800d08a <atcm_subscribe_net_event+0x8a>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CREG ? */
  else if ((urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 800d018:	1f5a      	subs	r2, r3, #5
 800d01a:	b2d2      	uxtb	r2, r2
 800d01c:	2a01      	cmp	r2, #1
 800d01e:	d822      	bhi.n	800d066 <atcm_subscribe_net_event+0x66>
  {
    /* if CREG not yet subscbribe */
    if ((p_modem_ctxt->persist.urc_subscript_cs_networkReg == CELLULAR_FALSE) &&
 800d020:	8a02      	ldrh	r2, [r0, #16]
 800d022:	2a00      	cmp	r2, #0
 800d024:	d158      	bne.n	800d0d8 <atcm_subscribe_net_event+0xd8>
        (p_modem_ctxt->persist.urc_subscript_cs_locationInfo == CELLULAR_FALSE))
    {
      /* set event as subscribed */
      if (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT)
 800d026:	2b05      	cmp	r3, #5
 800d028:	d050      	beq.n	800d0cc <atcm_subscribe_net_event+0xcc>
      {
        p_modem_ctxt->persist.urc_subscript_cs_networkReg = CELLULAR_TRUE;
      }
      if (urcEvent == CS_URCEVENT_CS_LOCATION_INFO)
 800d02a:	2b06      	cmp	r3, #6
 800d02c:	d051      	beq.n	800d0d2 <atcm_subscribe_net_event+0xd2>
      {
        p_modem_ctxt->persist.urc_subscript_cs_locationInfo = CELLULAR_TRUE;
      }

      /* request all URC, we will filter them */
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800d02e:	2302      	movs	r3, #2
 800d030:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CREG, FINAL_CMD);
 800d034:	2301      	movs	r3, #1
 800d036:	9300      	str	r3, [sp, #0]
 800d038:	2317      	movs	r3, #23
 800d03a:	2203      	movs	r2, #3
 800d03c:	f7ff fd08 	bl	800ca50 <atcm_program_AT_CMD>
 800d040:	e011      	b.n	800d066 <atcm_subscribe_net_event+0x66>
    if ((p_modem_ctxt->persist.urc_subscript_eps_networkReg == CELLULAR_FALSE) &&
 800d042:	8982      	ldrh	r2, [r0, #12]
 800d044:	b9ea      	cbnz	r2, 800d082 <atcm_subscribe_net_event+0x82>
      if (urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT)
 800d046:	2b01      	cmp	r3, #1
 800d048:	d011      	beq.n	800d06e <atcm_subscribe_net_event+0x6e>
      if (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO)
 800d04a:	2b02      	cmp	r3, #2
 800d04c:	d012      	beq.n	800d074 <atcm_subscribe_net_event+0x74>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800d04e:	f890 350d 	ldrb.w	r3, [r0, #1293]	; 0x50d
 800d052:	b193      	cbz	r3, 800d07a <atcm_subscribe_net_event+0x7a>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800d054:	2304      	movs	r3, #4
 800d056:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEREG, FINAL_CMD);
 800d05a:	2301      	movs	r3, #1
 800d05c:	9300      	str	r3, [sp, #0]
 800d05e:	2319      	movs	r3, #25
 800d060:	2203      	movs	r2, #3
 800d062:	f7ff fcf5 	bl	800ca50 <atcm_program_AT_CMD>
  {
    /* nothing to do */
  }

  return (ATSTATUS_OK);
}
 800d066:	2000      	movs	r0, #0
 800d068:	b003      	add	sp, #12
 800d06a:	f85d fb04 	ldr.w	pc, [sp], #4
        p_modem_ctxt->persist.urc_subscript_eps_networkReg = CELLULAR_TRUE;
 800d06e:	2201      	movs	r2, #1
 800d070:	7302      	strb	r2, [r0, #12]
 800d072:	e7ea      	b.n	800d04a <atcm_subscribe_net_event+0x4a>
        p_modem_ctxt->persist.urc_subscript_eps_locationInfo = CELLULAR_TRUE;
 800d074:	2301      	movs	r3, #1
 800d076:	7343      	strb	r3, [r0, #13]
 800d078:	e7e9      	b.n	800d04e <atcm_subscribe_net_event+0x4e>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800d07a:	2302      	movs	r3, #2
 800d07c:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
 800d080:	e7eb      	b.n	800d05a <atcm_subscribe_net_event+0x5a>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d082:	4608      	mov	r0, r1
 800d084:	f7ff fd40 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d088:	e7ed      	b.n	800d066 <atcm_subscribe_net_event+0x66>
    if ((p_modem_ctxt->persist.urc_subscript_gprs_networkReg == CELLULAR_FALSE) &&
 800d08a:	89c2      	ldrh	r2, [r0, #14]
 800d08c:	b9d2      	cbnz	r2, 800d0c4 <atcm_subscribe_net_event+0xc4>
      if (urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT)
 800d08e:	2b03      	cmp	r3, #3
 800d090:	d00e      	beq.n	800d0b0 <atcm_subscribe_net_event+0xb0>
      if (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO)
 800d092:	2b04      	cmp	r3, #4
 800d094:	d00f      	beq.n	800d0b6 <atcm_subscribe_net_event+0xb6>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800d096:	f890 350d 	ldrb.w	r3, [r0, #1293]	; 0x50d
 800d09a:	b17b      	cbz	r3, 800d0bc <atcm_subscribe_net_event+0xbc>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800d09c:	2304      	movs	r3, #4
 800d09e:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGREG, FINAL_CMD);
 800d0a2:	2301      	movs	r3, #1
 800d0a4:	9300      	str	r3, [sp, #0]
 800d0a6:	2318      	movs	r3, #24
 800d0a8:	2203      	movs	r2, #3
 800d0aa:	f7ff fcd1 	bl	800ca50 <atcm_program_AT_CMD>
 800d0ae:	e7da      	b.n	800d066 <atcm_subscribe_net_event+0x66>
        p_modem_ctxt->persist.urc_subscript_gprs_networkReg = CELLULAR_TRUE;
 800d0b0:	2201      	movs	r2, #1
 800d0b2:	7382      	strb	r2, [r0, #14]
 800d0b4:	e7ed      	b.n	800d092 <atcm_subscribe_net_event+0x92>
        p_modem_ctxt->persist.urc_subscript_gprs_locationInfo = CELLULAR_TRUE;
 800d0b6:	2301      	movs	r3, #1
 800d0b8:	73c3      	strb	r3, [r0, #15]
 800d0ba:	e7ec      	b.n	800d096 <atcm_subscribe_net_event+0x96>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800d0bc:	2302      	movs	r3, #2
 800d0be:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
 800d0c2:	e7ee      	b.n	800d0a2 <atcm_subscribe_net_event+0xa2>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d0c4:	4608      	mov	r0, r1
 800d0c6:	f7ff fd1f 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d0ca:	e7cc      	b.n	800d066 <atcm_subscribe_net_event+0x66>
        p_modem_ctxt->persist.urc_subscript_cs_networkReg = CELLULAR_TRUE;
 800d0cc:	2201      	movs	r2, #1
 800d0ce:	7402      	strb	r2, [r0, #16]
 800d0d0:	e7ab      	b.n	800d02a <atcm_subscribe_net_event+0x2a>
        p_modem_ctxt->persist.urc_subscript_cs_locationInfo = CELLULAR_TRUE;
 800d0d2:	2301      	movs	r3, #1
 800d0d4:	7443      	strb	r3, [r0, #17]
 800d0d6:	e7aa      	b.n	800d02e <atcm_subscribe_net_event+0x2e>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d0d8:	4608      	mov	r0, r1
 800d0da:	f7ff fd15 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d0de:	e7c2      	b.n	800d066 <atcm_subscribe_net_event+0x66>

0800d0e0 <atcm_unsubscribe_net_event>:
  * @param  p_modem_ctxt  pointer to modem context
  * @param  p_atp_ctxt    pointer to parser context
  * @retval at_status_t
  */
at_status_t atcm_unsubscribe_net_event(atcustom_modem_context_t *p_modem_ctxt, atparser_context_t *p_atp_ctxt)
{
 800d0e0:	b500      	push	{lr}
 800d0e2:	b083      	sub	sp, #12
  /* Retrieve urc event request: CEREG, CREG or CGREG ?
  *  note: only one event at same time
  */
  CS_UrcEvent_t urcEvent = p_modem_ctxt->SID_ctxt.urcEvent;
 800d0e4:	f890 3664 	ldrb.w	r3, [r0, #1636]	; 0x664

  /* is an event linked to CEREG ? */
  if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO))
 800d0e8:	1e5a      	subs	r2, r3, #1
 800d0ea:	b2d2      	uxtb	r2, r2
 800d0ec:	2a01      	cmp	r2, #1
 800d0ee:	d90b      	bls.n	800d108 <atcm_unsubscribe_net_event+0x28>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CGREG ? */
  else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 800d0f0:	1eda      	subs	r2, r3, #3
 800d0f2:	b2d2      	uxtb	r2, r2
 800d0f4:	2a01      	cmp	r2, #1
 800d0f6:	d920      	bls.n	800d13a <atcm_unsubscribe_net_event+0x5a>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CREG ? */
  else if ((urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 800d0f8:	1f5a      	subs	r2, r3, #5
 800d0fa:	b2d2      	uxtb	r2, r2
 800d0fc:	2a01      	cmp	r2, #1
 800d0fe:	d935      	bls.n	800d16c <atcm_unsubscribe_net_event+0x8c>
  {
    /* nothing to do */
  }

  return (ATSTATUS_OK);
}
 800d100:	2000      	movs	r0, #0
 800d102:	b003      	add	sp, #12
 800d104:	f85d fb04 	ldr.w	pc, [sp], #4
    if (urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT)
 800d108:	2b01      	cmp	r3, #1
 800d10a:	d00c      	beq.n	800d126 <atcm_unsubscribe_net_event+0x46>
    if (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO)
 800d10c:	2b02      	cmp	r3, #2
 800d10e:	d00d      	beq.n	800d12c <atcm_unsubscribe_net_event+0x4c>
    if ((p_modem_ctxt->persist.urc_subscript_eps_networkReg == CELLULAR_FALSE) &&
 800d110:	8983      	ldrh	r3, [r0, #12]
 800d112:	b973      	cbnz	r3, 800d132 <atcm_unsubscribe_net_event+0x52>
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d114:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEREG, FINAL_CMD);
 800d118:	2301      	movs	r3, #1
 800d11a:	9300      	str	r3, [sp, #0]
 800d11c:	2319      	movs	r3, #25
 800d11e:	2203      	movs	r2, #3
 800d120:	f7ff fc96 	bl	800ca50 <atcm_program_AT_CMD>
 800d124:	e7ec      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
      p_modem_ctxt->persist.urc_subscript_eps_networkReg = CELLULAR_FALSE;
 800d126:	2200      	movs	r2, #0
 800d128:	7302      	strb	r2, [r0, #12]
 800d12a:	e7ef      	b.n	800d10c <atcm_unsubscribe_net_event+0x2c>
      p_modem_ctxt->persist.urc_subscript_eps_locationInfo = CELLULAR_FALSE;
 800d12c:	2300      	movs	r3, #0
 800d12e:	7343      	strb	r3, [r0, #13]
 800d130:	e7ee      	b.n	800d110 <atcm_unsubscribe_net_event+0x30>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d132:	4608      	mov	r0, r1
 800d134:	f7ff fce8 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d138:	e7e2      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
    if (urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT)
 800d13a:	2b03      	cmp	r3, #3
 800d13c:	d00c      	beq.n	800d158 <atcm_unsubscribe_net_event+0x78>
    if (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO)
 800d13e:	2b04      	cmp	r3, #4
 800d140:	d00d      	beq.n	800d15e <atcm_unsubscribe_net_event+0x7e>
    if ((p_modem_ctxt->persist.urc_subscript_gprs_networkReg == CELLULAR_FALSE) &&
 800d142:	89c3      	ldrh	r3, [r0, #14]
 800d144:	b973      	cbnz	r3, 800d164 <atcm_unsubscribe_net_event+0x84>
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d146:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGREG, FINAL_CMD);
 800d14a:	2301      	movs	r3, #1
 800d14c:	9300      	str	r3, [sp, #0]
 800d14e:	2318      	movs	r3, #24
 800d150:	2203      	movs	r2, #3
 800d152:	f7ff fc7d 	bl	800ca50 <atcm_program_AT_CMD>
 800d156:	e7d3      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
      p_modem_ctxt->persist.urc_subscript_gprs_networkReg = CELLULAR_FALSE;
 800d158:	2200      	movs	r2, #0
 800d15a:	7382      	strb	r2, [r0, #14]
 800d15c:	e7ef      	b.n	800d13e <atcm_unsubscribe_net_event+0x5e>
      p_modem_ctxt->persist.urc_subscript_gprs_locationInfo = CELLULAR_FALSE;
 800d15e:	2300      	movs	r3, #0
 800d160:	73c3      	strb	r3, [r0, #15]
 800d162:	e7ee      	b.n	800d142 <atcm_unsubscribe_net_event+0x62>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d164:	4608      	mov	r0, r1
 800d166:	f7ff fccf 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d16a:	e7c9      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
    if (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT)
 800d16c:	2b05      	cmp	r3, #5
 800d16e:	d00c      	beq.n	800d18a <atcm_unsubscribe_net_event+0xaa>
    if (urcEvent == CS_URCEVENT_CS_LOCATION_INFO)
 800d170:	2b06      	cmp	r3, #6
 800d172:	d00d      	beq.n	800d190 <atcm_unsubscribe_net_event+0xb0>
    if ((p_modem_ctxt->persist.urc_subscript_cs_networkReg == CELLULAR_FALSE) &&
 800d174:	8a03      	ldrh	r3, [r0, #16]
 800d176:	b973      	cbnz	r3, 800d196 <atcm_unsubscribe_net_event+0xb6>
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d178:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CREG, FINAL_CMD);
 800d17c:	2301      	movs	r3, #1
 800d17e:	9300      	str	r3, [sp, #0]
 800d180:	2317      	movs	r3, #23
 800d182:	2203      	movs	r2, #3
 800d184:	f7ff fc64 	bl	800ca50 <atcm_program_AT_CMD>
 800d188:	e7ba      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
      p_modem_ctxt->persist.urc_subscript_cs_networkReg = CELLULAR_FALSE;
 800d18a:	2200      	movs	r2, #0
 800d18c:	7402      	strb	r2, [r0, #16]
 800d18e:	e7ef      	b.n	800d170 <atcm_unsubscribe_net_event+0x90>
      p_modem_ctxt->persist.urc_subscript_cs_locationInfo = CELLULAR_FALSE;
 800d190:	2300      	movs	r3, #0
 800d192:	7443      	strb	r3, [r0, #17]
 800d194:	e7ee      	b.n	800d174 <atcm_unsubscribe_net_event+0x94>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d196:	4608      	mov	r0, r1
 800d198:	f7ff fcb6 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d19c:	e7b0      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>

0800d19e <atcm_validate_ping_request>:
  *         - synchronous: call this function when requesting ping to te modem.
  * @param  p_modem_ctxt Pointer to the modem context
  * @retval none
  */
void atcm_validate_ping_request(atcustom_modem_context_t *p_modem_ctxt)
{
 800d19e:	b570      	push	{r4, r5, r6, lr}
 800d1a0:	4604      	mov	r4, r0
  /* PING request is valid */
  /* reset and copy SID ping parameters to persistent context */
  (void) memset((void *)&p_modem_ctxt->persist.ping_infos, 0, sizeof(csint_ping_params_t));
 800d1a2:	f200 5516 	addw	r5, r0, #1302	; 0x516
 800d1a6:	2643      	movs	r6, #67	; 0x43
 800d1a8:	4632      	mov	r2, r6
 800d1aa:	2100      	movs	r1, #0
 800d1ac:	4628      	mov	r0, r5
 800d1ae:	f018 fdd2 	bl	8025d56 <memset>
  (void) memcpy((void *)&p_modem_ctxt->persist.ping_infos, (void *)&p_modem_ctxt->SID_ctxt.ping_infos,
 800d1b2:	4632      	mov	r2, r6
 800d1b4:	f504 61da 	add.w	r1, r4, #1744	; 0x6d0
 800d1b8:	4628      	mov	r0, r5
 800d1ba:	f018 fea9 	bl	8025f10 <memcpy>
                sizeof(csint_ping_params_t));
  /* reset other parameters */
  (void) memset((void *)&p_modem_ctxt->persist.ping_resp_urc, 0, sizeof(CS_Ping_response_t));
 800d1be:	2250      	movs	r2, #80	; 0x50
 800d1c0:	2100      	movs	r1, #0
 800d1c2:	f204 505c 	addw	r0, r4, #1372	; 0x55c
 800d1c6:	f018 fdc6 	bl	8025d56 <memset>
  /* initialize ping index to invalid value */
  p_modem_ctxt->persist.ping_resp_urc.index = PING_INVALID_INDEX;
 800d1ca:	23ff      	movs	r3, #255	; 0xff
 800d1cc:	f884 355c 	strb.w	r3, [r4, #1372]	; 0x55c
  /* initialize ping URC to "not available" */
  p_modem_ctxt->persist.urc_avail_ping_rsp = AT_FALSE;
 800d1d0:	2300      	movs	r3, #0
 800d1d2:	f884 35ac 	strb.w	r3, [r4, #1452]	; 0x5ac
}
 800d1d6:	bd70      	pop	{r4, r5, r6, pc}

0800d1d8 <atcm_modem_event_received>:
at_bool_t atcm_modem_event_received(atcustom_modem_context_t *p_modem_ctxt, CS_ModemEvent_t mdm_evt)
{
  at_bool_t event_subscribed = AT_FALSE;

  /* if the event received is subscribed, save it */
  if ((p_modem_ctxt->persist.modem_events_subscript & mdm_evt) != 0U) /* bitmask check */
 800d1d8:	8c43      	ldrh	r3, [r0, #34]	; 0x22
 800d1da:	420b      	tst	r3, r1
 800d1dc:	d004      	beq.n	800d1e8 <atcm_modem_event_received+0x10>
  {
    p_modem_ctxt->persist.urc_avail_modem_events |= mdm_evt;
 800d1de:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 800d1e0:	4319      	orrs	r1, r3
 800d1e2:	8481      	strh	r1, [r0, #36]	; 0x24
    event_subscribed = AT_TRUE;
 800d1e4:	2001      	movs	r0, #1
 800d1e6:	4770      	bx	lr
  at_bool_t event_subscribed = AT_FALSE;
 800d1e8:	2000      	movs	r0, #0
  }

  /* returns true only if event has been subscribed */
  return (event_subscribed);
}
 800d1ea:	4770      	bx	lr

0800d1ec <atcm_reset_SID_context>:
  * @brief  atcm_reset_SID_context
  * @param  p_sid_ctxt
  * @retval none
  */
void atcm_reset_SID_context(atcustom_SID_context_t *p_sid_ctxt)
{
 800d1ec:	b570      	push	{r4, r5, r6, lr}
 800d1ee:	4604      	mov	r4, r0
  PRINT_API("enter reset_SID_context()")
 800d1f0:	4d38      	ldr	r5, [pc, #224]	; (800d2d4 <atcm_reset_SID_context+0xe8>)
 800d1f2:	4e39      	ldr	r6, [pc, #228]	; (800d2d8 <atcm_reset_SID_context+0xec>)
 800d1f4:	f105 0e20 	add.w	lr, r5, #32
 800d1f8:	46ac      	mov	ip, r5
 800d1fa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d1fe:	6030      	str	r0, [r6, #0]
 800d200:	6071      	str	r1, [r6, #4]
 800d202:	60b2      	str	r2, [r6, #8]
 800d204:	60f3      	str	r3, [r6, #12]
 800d206:	4665      	mov	r5, ip
 800d208:	3610      	adds	r6, #16
 800d20a:	45f4      	cmp	ip, lr
 800d20c:	d1f4      	bne.n	800d1f8 <atcm_reset_SID_context+0xc>
 800d20e:	cd03      	ldmia	r5!, {r0, r1}
 800d210:	6030      	str	r0, [r6, #0]
 800d212:	6071      	str	r1, [r6, #4]
 800d214:	782b      	ldrb	r3, [r5, #0]
 800d216:	7233      	strb	r3, [r6, #8]
 800d218:	4d2f      	ldr	r5, [pc, #188]	; (800d2d8 <atcm_reset_SID_context+0xec>)
 800d21a:	4628      	mov	r0, r5
 800d21c:	f011 ff79 	bl	801f112 <crs_strlen>
 800d220:	b283      	uxth	r3, r0
 800d222:	462a      	mov	r2, r5
 800d224:	2104      	movs	r1, #4
 800d226:	2002      	movs	r0, #2
 800d228:	f011 ffb6 	bl	801f198 <traceIF_itmPrint>
 800d22c:	4628      	mov	r0, r5
 800d22e:	f011 ff70 	bl	801f112 <crs_strlen>
 800d232:	b283      	uxth	r3, r0
 800d234:	462a      	mov	r2, r5
 800d236:	2104      	movs	r1, #4
 800d238:	2002      	movs	r0, #2
 800d23a:	f011 ffcf 	bl	801f1dc <traceIF_uartPrint>

  p_sid_ctxt->attach_status = CS_PS_DETACHED;
 800d23e:	2500      	movs	r5, #0
 800d240:	f884 50b5 	strb.w	r5, [r4, #181]	; 0xb5
  p_sid_ctxt->cfun_status = CS_CMI_MINI;
 800d244:	f884 50b6 	strb.w	r5, [r4, #182]	; 0xb6

  (void) memset((void *)&p_sid_ctxt->write_operator_infos, 0, sizeof(CS_OperatorSelector_t));
 800d248:	2248      	movs	r2, #72	; 0x48
 800d24a:	4629      	mov	r1, r5
 800d24c:	f104 0018 	add.w	r0, r4, #24
 800d250:	f018 fd81 	bl	8025d56 <memset>
  p_sid_ctxt->write_operator_infos.format = CS_ONF_NOT_PRESENT;
 800d254:	2309      	movs	r3, #9
 800d256:	8363      	strh	r3, [r4, #26]
  /* code commented to avoid Code Sonar error (variable already initialized with same value)
   * p_sid_ctxt->write_operator_infos.AcT_present = CELLULAR_FALSE;
   */

  (void) memset((void *)&p_sid_ctxt->read_operator_infos, 0, sizeof(CS_RegistrationStatus_t));
 800d258:	224e      	movs	r2, #78	; 0x4e
 800d25a:	4629      	mov	r1, r5
 800d25c:	f104 0060 	add.w	r0, r4, #96	; 0x60
 800d260:	f018 fd79 	bl	8025d56 <memset>
  * read_operator_infos.EPS_NetworkRegState = CS_NRS_NOT_REGISTERED_NOT_SEARCHING;
  * read_operator_infos.GPRS_NetworkRegState = CS_NRS_NOT_REGISTERED_NOT_SEARCHING;
  * read_operator_infos.CS_NetworkRegState = CS_NRS_NOT_REGISTERED_NOT_SEARCHING;
  * read_operator_infos.optional_fields_presence = CS_RSF_NONE;
  */
  p_sid_ctxt->modem_init.init = CS_CMI_MINI;
 800d264:	7065      	strb	r5, [r4, #1]
  p_sid_ctxt->modem_init.reset = CELLULAR_FALSE;
 800d266:	70a5      	strb	r5, [r4, #2]
  (void) memset((void *)&p_sid_ctxt->modem_init.pincode.pincode, 0, sizeof(csint_pinCode_t));
 800d268:	f8c4 5003 	str.w	r5, [r4, #3]
 800d26c:	f8c4 5007 	str.w	r5, [r4, #7]
 800d270:	f8c4 500b 	str.w	r5, [r4, #11]
 800d274:	f8c4 500f 	str.w	r5, [r4, #15]

  p_sid_ctxt->device_info = NULL;
 800d278:	6165      	str	r5, [r4, #20]
  p_sid_ctxt->signal_quality = NULL;
 800d27a:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
  p_sid_ctxt->dns_request_infos = NULL;
 800d27e:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
  p_sid_ctxt->direct_cmd_tx = NULL;
 800d282:	f8c4 5164 	str.w	r5, [r4, #356]	; 0x164
  p_sid_ctxt->sim_generic_access.data = NULL;
 800d286:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
  p_sid_ctxt->sim_generic_access.bytes_received = 0U;
 800d28a:	f8c4 50bc 	str.w	r5, [r4, #188]	; 0xbc

  (void) memset((void *)&p_sid_ctxt->init_power_config, 0, sizeof(CS_init_power_config_t));
 800d28e:	f8c4 5168 	str.w	r5, [r4, #360]	; 0x168
 800d292:	f8c4 516b 	str.w	r5, [r4, #363]	; 0x16b
  (void) memset((void *)&p_sid_ctxt->set_power_config, 0, sizeof(CS_set_power_config_t));
 800d296:	f8c4 516f 	str.w	r5, [r4, #367]	; 0x16f
 800d29a:	f8c4 5173 	str.w	r5, [r4, #371]	; 0x173
 800d29e:	f8a4 5177 	strh.w	r5, [r4, #375]	; 0x177

  p_sid_ctxt->wakeup_origin = UNKNOWN_WAKEUP;
 800d2a2:	f884 5179 	strb.w	r5, [r4, #377]	; 0x179

  p_sid_ctxt->urcEvent = CS_URCEVENT_NONE;
 800d2a6:	f884 50b4 	strb.w	r5, [r4, #180]	; 0xb4
  p_sid_ctxt->pdn_conf_id = CS_PDN_CONFIG_DEFAULT;
 800d2aa:	230b      	movs	r3, #11
 800d2ac:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119

  (void) memset((void *)&p_sid_ctxt->socketSendData_struct, 0, sizeof(csint_socket_data_buffer_t));
 800d2b0:	2258      	movs	r2, #88	; 0x58
 800d2b2:	4629      	mov	r1, r5
 800d2b4:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
 800d2b8:	f018 fd4d 	bl	8025d56 <memset>
  (void) memset((void *)&p_sid_ctxt->ping_infos, 0, sizeof(csint_ping_params_t));
 800d2bc:	2243      	movs	r2, #67	; 0x43
 800d2be:	4629      	mov	r1, r5
 800d2c0:	f504 7090 	add.w	r0, r4, #288	; 0x120
 800d2c4:	f018 fd47 	bl	8025d56 <memset>

  p_sid_ctxt->error_report.error_type = CSERR_UNKNOWN;
 800d2c8:	f884 517a 	strb.w	r5, [r4, #378]	; 0x17a
  p_sid_ctxt->error_report.sim_state = CS_SIMSTATE_UNKNOWN;
 800d2cc:	f884 517b 	strb.w	r5, [r4, #379]	; 0x17b
}
 800d2d0:	bd70      	pop	{r4, r5, r6, pc}
 800d2d2:	bf00      	nop
 800d2d4:	0802de3c 	.word	0x0802de3c
 800d2d8:	200048dc 	.word	0x200048dc

0800d2dc <atcm_reset_CMD_context>:
  * @brief  atcm_reset_CMD_context
  * @param  p_cmd_ctxt
  * @retval none
  */
void atcm_reset_CMD_context(atcustom_CMD_context_t *p_cmd_ctxt)
{
 800d2dc:	b570      	push	{r4, r5, r6, lr}
 800d2de:	4605      	mov	r5, r0
  PRINT_API("enter reset_CMD_context()")
 800d2e0:	4c1a      	ldr	r4, [pc, #104]	; (800d34c <atcm_reset_CMD_context+0x70>)
 800d2e2:	4e1b      	ldr	r6, [pc, #108]	; (800d350 <atcm_reset_CMD_context+0x74>)
 800d2e4:	f104 0e20 	add.w	lr, r4, #32
 800d2e8:	46a4      	mov	ip, r4
 800d2ea:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d2ee:	6030      	str	r0, [r6, #0]
 800d2f0:	6071      	str	r1, [r6, #4]
 800d2f2:	60b2      	str	r2, [r6, #8]
 800d2f4:	60f3      	str	r3, [r6, #12]
 800d2f6:	4664      	mov	r4, ip
 800d2f8:	3610      	adds	r6, #16
 800d2fa:	45f4      	cmp	ip, lr
 800d2fc:	d1f4      	bne.n	800d2e8 <atcm_reset_CMD_context+0xc>
 800d2fe:	cc03      	ldmia	r4!, {r0, r1}
 800d300:	6030      	str	r0, [r6, #0]
 800d302:	6071      	str	r1, [r6, #4]
 800d304:	7823      	ldrb	r3, [r4, #0]
 800d306:	7233      	strb	r3, [r6, #8]
 800d308:	4c11      	ldr	r4, [pc, #68]	; (800d350 <atcm_reset_CMD_context+0x74>)
 800d30a:	4620      	mov	r0, r4
 800d30c:	f011 ff01 	bl	801f112 <crs_strlen>
 800d310:	b283      	uxth	r3, r0
 800d312:	4622      	mov	r2, r4
 800d314:	2104      	movs	r1, #4
 800d316:	2002      	movs	r0, #2
 800d318:	f011 ff3e 	bl	801f198 <traceIF_itmPrint>
 800d31c:	4620      	mov	r0, r4
 800d31e:	f011 fef8 	bl	801f112 <crs_strlen>
 800d322:	b283      	uxth	r3, r0
 800d324:	4622      	mov	r2, r4
 800d326:	2104      	movs	r1, #4
 800d328:	2002      	movs	r0, #2
 800d32a:	f011 ff57 	bl	801f1dc <traceIF_uartPrint>

  /* p_cmd_ctxt->cgsn_write_cmd_param parameter used in fCmdBuild_CGSN() for AT+GCSN cmd */
  p_cmd_ctxt->cgatt_write_cmd_param = CGATT_UNKNOWN;
 800d32e:	2302      	movs	r3, #2
 800d330:	706b      	strb	r3, [r5, #1]
  p_cmd_ctxt->cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d332:	2300      	movs	r3, #0
 800d334:	70ab      	strb	r3, [r5, #2]
  /* p_cmd_ctxt->command_echo parameter  used in fCmdBuild_ATE() for ATE cmd */
  /* p_cmd_ctxt->dce_full_resp_format parameter used in fCmdBuild_ATV() for ATV cmd*/
  p_cmd_ctxt->pdn_state = PDN_STATE_ACTIVATE;
 800d336:	2301      	movs	r3, #1
 800d338:	716b      	strb	r3, [r5, #5]
  p_cmd_ctxt->modem_cid = 0xFFFFU;
 800d33a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d33e:	60aa      	str	r2, [r5, #8]
  p_cmd_ctxt->baud_rate = MODEM_UART_BAUDRATE;
 800d340:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800d344:	60ea      	str	r2, [r5, #12]
  p_cmd_ctxt->cfun_value = 1U;
 800d346:	746b      	strb	r3, [r5, #17]
#if (CONFIG_MODEM_UART_RTS_CTS == 1)
  p_cmd_ctxt->flow_control_cts_rts = AT_TRUE;
 800d348:	742b      	strb	r3, [r5, #16]
#else
  p_cmd_ctxt->flow_control_cts_rts = AT_FALSE;
#endif /* CONFIG_MODEM_UART_RTS_CTS */
}
 800d34a:	bd70      	pop	{r4, r5, r6, pc}
 800d34c:	0802de68 	.word	0x0802de68
 800d350:	200048dc 	.word	0x200048dc

0800d354 <atcm_reset_SOCKET_context>:
  * @brief  atcm_reset_SOCKET_context
  * @param  p_modem_ctxt
  * @retval none
  */
void atcm_reset_SOCKET_context(atcustom_modem_context_t *p_modem_ctxt)
{
 800d354:	b570      	push	{r4, r5, r6, lr}
 800d356:	4604      	mov	r4, r0
  PRINT_API("enter atcm_reset_SOCKET_context()")
 800d358:	4e1d      	ldr	r6, [pc, #116]	; (800d3d0 <atcm_reset_SOCKET_context+0x7c>)
 800d35a:	4d1e      	ldr	r5, [pc, #120]	; (800d3d4 <atcm_reset_SOCKET_context+0x80>)
 800d35c:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 800d360:	46b4      	mov	ip, r6
 800d362:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d366:	6028      	str	r0, [r5, #0]
 800d368:	6069      	str	r1, [r5, #4]
 800d36a:	60aa      	str	r2, [r5, #8]
 800d36c:	60eb      	str	r3, [r5, #12]
 800d36e:	4666      	mov	r6, ip
 800d370:	3510      	adds	r5, #16
 800d372:	45f4      	cmp	ip, lr
 800d374:	d1f4      	bne.n	800d360 <atcm_reset_SOCKET_context+0xc>
 800d376:	f89c 3000 	ldrb.w	r3, [ip]
 800d37a:	702b      	strb	r3, [r5, #0]
 800d37c:	4d15      	ldr	r5, [pc, #84]	; (800d3d4 <atcm_reset_SOCKET_context+0x80>)
 800d37e:	4628      	mov	r0, r5
 800d380:	f011 fec7 	bl	801f112 <crs_strlen>
 800d384:	b283      	uxth	r3, r0
 800d386:	462a      	mov	r2, r5
 800d388:	2104      	movs	r1, #4
 800d38a:	2002      	movs	r0, #2
 800d38c:	f011 ff04 	bl	801f198 <traceIF_itmPrint>
 800d390:	4628      	mov	r0, r5
 800d392:	f011 febe 	bl	801f112 <crs_strlen>
 800d396:	b283      	uxth	r3, r0
 800d398:	462a      	mov	r2, r5
 800d39a:	2104      	movs	r1, #4
 800d39c:	2002      	movs	r0, #2
 800d39e:	f011 ff1d 	bl	801f1dc <traceIF_uartPrint>

  p_modem_ctxt->socket_ctxt.socket_info = NULL;
 800d3a2:	2500      	movs	r5, #0
 800d3a4:	f8c4 5740 	str.w	r5, [r4, #1856]	; 0x740
  (void) memset((void *)&p_modem_ctxt->socket_ctxt.socketReceivedata, 0, sizeof(csint_socket_data_buffer_t));
 800d3a8:	2258      	movs	r2, #88	; 0x58
 800d3aa:	4629      	mov	r1, r5
 800d3ac:	f204 7044 	addw	r0, r4, #1860	; 0x744
 800d3b0:	f018 fcd1 	bl	8025d56 <memset>
  p_modem_ctxt->socket_ctxt.socket_current_connId = 0U;
 800d3b4:	f8c4 579c 	str.w	r5, [r4, #1948]	; 0x79c
  p_modem_ctxt->socket_ctxt.socket_rx_expected_buf_size = 0U;
 800d3b8:	f8c4 57a0 	str.w	r5, [r4, #1952]	; 0x7a0
  p_modem_ctxt->socket_ctxt.socket_rx_count_bytes_received = 0U;
 800d3bc:	f8c4 57a4 	str.w	r5, [r4, #1956]	; 0x7a4

  p_modem_ctxt->socket_ctxt.socket_send_state = SocketSendState_No_Activity;
 800d3c0:	f884 57ac 	strb.w	r5, [r4, #1964]	; 0x7ac
  p_modem_ctxt->socket_ctxt.socket_receive_state = SocketRcvState_No_Activity;
 800d3c4:	f884 57ad 	strb.w	r5, [r4, #1965]	; 0x7ad
  p_modem_ctxt->socket_ctxt.socket_RxData_state = SocketRxDataState_not_started;
 800d3c8:	f884 57ae 	strb.w	r5, [r4, #1966]	; 0x7ae
}
 800d3cc:	bd70      	pop	{r4, r5, r6, pc}
 800d3ce:	bf00      	nop
 800d3d0:	0802de94 	.word	0x0802de94
 800d3d4:	200048dc 	.word	0x200048dc

0800d3d8 <atcm_searchCmdInLUT>:
  */
at_status_t atcm_searchCmdInLUT(atcustom_modem_context_t *p_modem_ctxt,
                                const atparser_context_t  *p_atp_ctxt,
                                const IPC_RxMessage_t *p_msg_in,
                                at_element_info_t *element_infos)
{
 800d3d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d3dc:	b083      	sub	sp, #12
 800d3de:	9201      	str	r2, [sp, #4]
 800d3e0:	4698      	mov	r8, r3
  UNUSED(p_atp_ctxt);
  at_status_t retval = ATSTATUS_ERROR;

  element_infos->cmd_id_received = CMD_AT_INVALID;
 800d3e2:	f04f 33ff 	mov.w	r3, #4294967295
 800d3e6:	f8c8 3004 	str.w	r3, [r8, #4]

  /* check if we receive empty command */
  if (element_infos->str_size == 0U)
 800d3ea:	f8b8 300e 	ldrh.w	r3, [r8, #14]
 800d3ee:	b933      	cbnz	r3, 800d3fe <atcm_searchCmdInLUT+0x26>
  {
    /* empty answer */
    element_infos->cmd_id_received = (CMD_ID_t) CMD_AT;
 800d3f0:	f8c8 3004 	str.w	r3, [r8, #4]
    /* null size string */
    retval = ATSTATUS_OK;
 800d3f4:	469b      	mov	fp, r3
      }
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }
  return (retval);
}
 800d3f6:	4658      	mov	r0, fp
 800d3f8:	b003      	add	sp, #12
 800d3fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d3fe:	4606      	mov	r6, r0
    uint16_t i = 0U;
 800d400:	2400      	movs	r4, #0
    bool leave_loop = false;
 800d402:	46a1      	mov	r9, r4
  at_status_t retval = ATSTATUS_ERROR;
 800d404:	f04f 0b01 	mov.w	fp, #1
 800d408:	e007      	b.n	800d41a <atcm_searchCmdInLUT+0x42>
      i++;
 800d40a:	3401      	adds	r4, #1
 800d40c:	b2a4      	uxth	r4, r4
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800d40e:	f1b9 0f00 	cmp.w	r9, #0
 800d412:	d1f0      	bne.n	800d3f6 <atcm_searchCmdInLUT+0x1e>
 800d414:	6833      	ldr	r3, [r6, #0]
 800d416:	429c      	cmp	r4, r3
 800d418:	d2ed      	bcs.n	800d3f6 <atcm_searchCmdInLUT+0x1e>
      if (strlen((const CRC_CHAR_t *)(p_modem_ctxt->p_modem_LUT)[i].cmd_str) > 0U)
 800d41a:	6877      	ldr	r7, [r6, #4]
 800d41c:	eb04 0544 	add.w	r5, r4, r4, lsl #1
 800d420:	ea4f 1a05 	mov.w	sl, r5, lsl #4
 800d424:	eb07 1505 	add.w	r5, r7, r5, lsl #4
 800d428:	792b      	ldrb	r3, [r5, #4]
 800d42a:	2b00      	cmp	r3, #0
 800d42c:	d0ed      	beq.n	800d40a <atcm_searchCmdInLUT+0x32>
        if ((strlen((const CRC_CHAR_t *)(p_modem_ctxt->p_modem_LUT)[i].cmd_str) == element_infos->str_size))
 800d42e:	3504      	adds	r5, #4
 800d430:	4628      	mov	r0, r5
 800d432:	f7f2 fedf 	bl	80001f4 <strlen>
 800d436:	f8b8 200e 	ldrh.w	r2, [r8, #14]
 800d43a:	4290      	cmp	r0, r2
 800d43c:	d1e5      	bne.n	800d40a <atcm_searchCmdInLUT+0x32>
          if (0 == memcmp((const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 800d43e:	f8b8 000a 	ldrh.w	r0, [r8, #10]
 800d442:	4629      	mov	r1, r5
 800d444:	9b01      	ldr	r3, [sp, #4]
 800d446:	4418      	add	r0, r3
 800d448:	f018 fc75 	bl	8025d36 <memcmp>
 800d44c:	2800      	cmp	r0, #0
 800d44e:	d1dc      	bne.n	800d40a <atcm_searchCmdInLUT+0x32>
            PRINT_DBG("we received LUT#%ld : %s \r\n", (p_modem_ctxt->p_modem_LUT)[i].cmd_id,
 800d450:	f8df 904c 	ldr.w	r9, [pc, #76]	; 800d4a0 <atcm_searchCmdInLUT+0xc8>
 800d454:	462b      	mov	r3, r5
 800d456:	f857 200a 	ldr.w	r2, [r7, sl]
 800d45a:	4910      	ldr	r1, [pc, #64]	; (800d49c <atcm_searchCmdInLUT+0xc4>)
 800d45c:	4648      	mov	r0, r9
 800d45e:	f018 fc07 	bl	8025c70 <sprintf>
 800d462:	4648      	mov	r0, r9
 800d464:	f011 fe55 	bl	801f112 <crs_strlen>
 800d468:	b283      	uxth	r3, r0
 800d46a:	464a      	mov	r2, r9
 800d46c:	2102      	movs	r1, #2
 800d46e:	4608      	mov	r0, r1
 800d470:	f011 fe92 	bl	801f198 <traceIF_itmPrint>
 800d474:	4648      	mov	r0, r9
 800d476:	f011 fe4c 	bl	801f112 <crs_strlen>
 800d47a:	b283      	uxth	r3, r0
 800d47c:	464a      	mov	r2, r9
 800d47e:	2102      	movs	r1, #2
 800d480:	4608      	mov	r0, r1
 800d482:	f011 feab 	bl	801f1dc <traceIF_uartPrint>
            element_infos->cmd_id_received = (p_modem_ctxt->p_modem_LUT)[i].cmd_id;
 800d486:	6873      	ldr	r3, [r6, #4]
 800d488:	f853 300a 	ldr.w	r3, [r3, sl]
 800d48c:	f8c8 3004 	str.w	r3, [r8, #4]
            leave_loop = true;
 800d490:	f04f 0901 	mov.w	r9, #1
            retval = ATSTATUS_OK;
 800d494:	f04f 0b00 	mov.w	fp, #0
 800d498:	e7b7      	b.n	800d40a <atcm_searchCmdInLUT+0x32>
 800d49a:	bf00      	nop
 800d49c:	0802dec8 	.word	0x0802dec8
 800d4a0:	200048dc 	.word	0x200048dc

0800d4a4 <atcm_check_text_line_cmd>:
  */
at_action_rsp_t atcm_check_text_line_cmd(atcustom_modem_context_t *p_modem_ctxt,
                                         at_context_t *p_at_ctxt,
                                         const IPC_RxMessage_t *p_msg_in,
                                         at_element_info_t *element_infos)
{
 800d4a4:	b508      	push	{r3, lr}
 800d4a6:	4686      	mov	lr, r0
 800d4a8:	4608      	mov	r0, r1
  const atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_ERROR;

  /* in this section, we treat all commands which can return text lines */
  switch (p_atp_ctxt->current_atcmd.id)
 800d4aa:	69c9      	ldr	r1, [r1, #28]
 800d4ac:	f1a1 0c0b 	sub.w	ip, r1, #11
 800d4b0:	f1bc 0f27 	cmp.w	ip, #39	; 0x27
 800d4b4:	d854      	bhi.n	800d560 <atcm_check_text_line_cmd+0xbc>
 800d4b6:	e8df f00c 	tbb	[pc, ip]
 800d4ba:	1b14      	.short	0x1b14
 800d4bc:	53452922 	.word	0x53452922
 800d4c0:	53535353 	.word	0x53535353
 800d4c4:	53535353 	.word	0x53535353
 800d4c8:	53535353 	.word	0x53535353
 800d4cc:	53535353 	.word	0x53535353
 800d4d0:	5353534c 	.word	0x5353534c
 800d4d4:	53535353 	.word	0x53535353
 800d4d8:	53535353 	.word	0x53535353
 800d4dc:	30535353 	.word	0x30535353
 800d4e0:	3e37      	.short	0x3e37
  {
    case CMD_AT_CGMI:
      if (fRspAnalyze_CGMI(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d4e2:	4671      	mov	r1, lr
 800d4e4:	f003 f8f2 	bl	80106cc <fRspAnalyze_CGMI>
 800d4e8:	2804      	cmp	r0, #4
 800d4ea:	d03a      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        retval = ATACTION_RSP_INTERMEDIATE;
 800d4ec:	2008      	movs	r0, #8
 800d4ee:	e038      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGMM:
      if (fRspAnalyze_CGMM(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d4f0:	4671      	mov	r1, lr
 800d4f2:	f003 f951 	bl	8010798 <fRspAnalyze_CGMM>
 800d4f6:	2804      	cmp	r0, #4
 800d4f8:	d033      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d4fa:	2008      	movs	r0, #8
 800d4fc:	e031      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGMR:
      if (fRspAnalyze_CGMR(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d4fe:	4671      	mov	r1, lr
 800d500:	f003 f9ac 	bl	801085c <fRspAnalyze_CGMR>
 800d504:	2804      	cmp	r0, #4
 800d506:	d02c      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d508:	2008      	movs	r0, #8
 800d50a:	e02a      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGSN:
      if (fRspAnalyze_CGSN(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d50c:	4671      	mov	r1, lr
 800d50e:	f003 fa09 	bl	8010924 <fRspAnalyze_CGSN>
 800d512:	2804      	cmp	r0, #4
 800d514:	d025      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d516:	2008      	movs	r0, #8
 800d518:	e023      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_GSN:
      if (fRspAnalyze_GSN(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d51a:	4671      	mov	r1, lr
 800d51c:	f006 fbf6 	bl	8013d0c <fRspAnalyze_GSN>
 800d520:	2804      	cmp	r0, #4
 800d522:	d01e      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d524:	2008      	movs	r0, #8
 800d526:	e01c      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_IPR:
      if (fRspAnalyze_IPR(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d528:	4671      	mov	r1, lr
 800d52a:	f006 fc57 	bl	8013ddc <fRspAnalyze_IPR>
 800d52e:	2804      	cmp	r0, #4
 800d530:	d017      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d532:	2008      	movs	r0, #8
 800d534:	e015      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_IFC:
      if (fRspAnalyze_IFC(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d536:	4671      	mov	r1, lr
 800d538:	f006 fcdc 	bl	8013ef4 <fRspAnalyze_IFC>
 800d53c:	2804      	cmp	r0, #4
 800d53e:	d010      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d540:	2008      	movs	r0, #8
 800d542:	e00e      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CIMI:
      if (fRspAnalyze_CIMI(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d544:	4671      	mov	r1, lr
 800d546:	f003 fb3d 	bl	8010bc4 <fRspAnalyze_CIMI>
 800d54a:	2804      	cmp	r0, #4
 800d54c:	d009      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d54e:	2008      	movs	r0, #8
 800d550:	e007      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGPADDR:
      if (fRspAnalyze_CGPADDR(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d552:	4671      	mov	r1, lr
 800d554:	f005 ff08 	bl	8013368 <fRspAnalyze_CGPADDR>
 800d558:	2804      	cmp	r0, #4
 800d55a:	d002      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d55c:	2008      	movs	r0, #8
 800d55e:	e000      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
  switch (p_atp_ctxt->current_atcmd.id)
 800d560:	2000      	movs	r0, #0
      retval = ATACTION_RSP_NO_ACTION;
      break;
  }

  return (retval);
}
 800d562:	bd08      	pop	{r3, pc}

0800d564 <atcm_retrieve_SID_parameters>:
  * @param  p_modem_ctxt
  * @param  p_atp_ctxt
  * @retval at_status_t
  */
at_status_t atcm_retrieve_SID_parameters(atcustom_modem_context_t *p_modem_ctxt, atparser_context_t *p_atp_ctxt)
{
 800d564:	b530      	push	{r4, r5, lr}
 800d566:	b083      	sub	sp, #12
  at_status_t retval = ATSTATUS_OK;

  /* only retrieve SID parameters on first call (step = 0)*/
  if (p_atp_ctxt->step == 0U)
 800d568:	788c      	ldrb	r4, [r1, #2]
 800d56a:	2c00      	cmp	r4, #0
 800d56c:	f040 821c 	bne.w	800d9a8 <atcm_retrieve_SID_parameters+0x444>
 800d570:	4605      	mov	r5, r0
 800d572:	468c      	mov	ip, r1
  {
    switch (p_atp_ctxt->current_SID)
 800d574:	880a      	ldrh	r2, [r1, #0]
 800d576:	f1a2 0364 	sub.w	r3, r2, #100	; 0x64
 800d57a:	2b2a      	cmp	r3, #42	; 0x2a
 800d57c:	f200 81fb 	bhi.w	800d976 <atcm_retrieve_SID_parameters+0x412>
 800d580:	e8df f013 	tbh	[pc, r3, lsl #1]
 800d584:	018b018b 	.word	0x018b018b
 800d588:	0039018b 	.word	0x0039018b
 800d58c:	00610047 	.word	0x00610047
 800d590:	007d006f 	.word	0x007d006f
 800d594:	018b018b 	.word	0x018b018b
 800d598:	00cf0054 	.word	0x00cf0054
 800d59c:	018b018b 	.word	0x018b018b
 800d5a0:	01a300dd 	.word	0x01a300dd
 800d5a4:	011701a3 	.word	0x011701a3
 800d5a8:	010900eb 	.word	0x010900eb
 800d5ac:	008b01f9 	.word	0x008b01f9
 800d5b0:	00a60098 	.word	0x00a60098
 800d5b4:	00b400a6 	.word	0x00b400a6
 800d5b8:	018b018b 	.word	0x018b018b
 800d5bc:	013600c1 	.word	0x013600c1
 800d5c0:	0125002b 	.word	0x0125002b
 800d5c4:	01430151 	.word	0x01430151
 800d5c8:	016f0162 	.word	0x016f0162
 800d5cc:	01bb017d 	.word	0x01bb017d
 800d5d0:	01d501c8 	.word	0x01d501c8
 800d5d4:	01d501d5 	.word	0x01d501d5
 800d5d8:	01ed      	.short	0x01ed
    {
      case SID_CS_MODEM_CONFIG:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d5da:	f500 63b6 	add.w	r3, r0, #1456	; 0x5b0
 800d5de:	2201      	movs	r2, #1
 800d5e0:	2126      	movs	r1, #38	; 0x26
 800d5e2:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d5e6:	f7fe fe85 	bl	800c2f4 <DATAPACK_readStruct>
 800d5ea:	4604      	mov	r4, r0
 800d5ec:	2800      	cmp	r0, #0
 800d5ee:	f000 81dc 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_MODEMCONFIG,
                                (uint16_t) sizeof(CS_ModemConfig_t),
                                (void *)&p_modem_ctxt->SID_ctxt.modem_config) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d5f2:	2401      	movs	r4, #1
 800d5f4:	e1d9      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_INIT_MODEM:
        /* retrieve  client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d5f6:	f200 53b1 	addw	r3, r0, #1457	; 0x5b1
 800d5fa:	2212      	movs	r2, #18
 800d5fc:	4611      	mov	r1, r2
 800d5fe:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d602:	f7fe fe77 	bl	800c2f4 <DATAPACK_readStruct>
 800d606:	4604      	mov	r4, r0
 800d608:	2800      	cmp	r0, #0
 800d60a:	f000 81ce 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_INITMODEM,
                                (uint16_t) sizeof(csint_modemInit_t),
                                (void *)&p_modem_ctxt->SID_ctxt.modem_init) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d60e:	2401      	movs	r4, #1
 800d610:	e1cb      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_GET_DEVICE_INFO:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d612:	f200 52c4 	addw	r2, r0, #1476	; 0x5c4
 800d616:	2117      	movs	r1, #23
 800d618:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d61c:	f7fe fe3e 	bl	800c29c <DATAPACK_readPtr>
 800d620:	4604      	mov	r4, r0
 800d622:	2800      	cmp	r0, #0
 800d624:	f000 81c1 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_DEVICE_INFO,
                             (void **)&p_modem_ctxt->SID_ctxt.device_info) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d628:	2401      	movs	r4, #1
 800d62a:	e1be      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_GET_SIGNAL_QUALITY:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d62c:	f500 62cc 	add.w	r2, r0, #1632	; 0x660
 800d630:	211d      	movs	r1, #29
 800d632:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d636:	f7fe fe31 	bl	800c29c <DATAPACK_readPtr>
 800d63a:	4604      	mov	r4, r0
 800d63c:	2800      	cmp	r0, #0
 800d63e:	f000 81b4 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SIGNAL_QUALITY,
                             (void **)&p_modem_ctxt->SID_ctxt.signal_quality) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d642:	2401      	movs	r4, #1
 800d644:	e1b1      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_REGISTER_NET:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d646:	f500 63b9 	add.w	r3, r0, #1480	; 0x5c8
 800d64a:	2248      	movs	r2, #72	; 0x48
 800d64c:	2114      	movs	r1, #20
 800d64e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d652:	f7fe fe4f 	bl	800c2f4 <DATAPACK_readStruct>
 800d656:	4604      	mov	r4, r0
 800d658:	2800      	cmp	r0, #0
 800d65a:	f000 81a6 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_OPERATORSELECT,
                                (uint16_t) sizeof(CS_OperatorSelector_t),
                                (void *)&p_modem_ctxt->SID_ctxt.write_operator_infos) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d65e:	2401      	movs	r4, #1
 800d660:	e1a3      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SUSBCRIBE_NET_EVENT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d662:	f200 6364 	addw	r3, r0, #1636	; 0x664
 800d666:	2201      	movs	r2, #1
 800d668:	2116      	movs	r1, #22
 800d66a:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d66e:	f7fe fe41 	bl	800c2f4 <DATAPACK_readStruct>
 800d672:	4604      	mov	r4, r0
 800d674:	2800      	cmp	r0, #0
 800d676:	f000 8198 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_URC_EVENT,
                                (uint16_t) sizeof(CS_UrcEvent_t),
                                (void *)&p_modem_ctxt->SID_ctxt.urcEvent) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d67a:	2401      	movs	r4, #1
 800d67c:	e195      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_UNSUSBCRIBE_NET_EVENT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d67e:	f200 6364 	addw	r3, r0, #1636	; 0x664
 800d682:	2201      	movs	r2, #1
 800d684:	2116      	movs	r1, #22
 800d686:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d68a:	f7fe fe33 	bl	800c2f4 <DATAPACK_readStruct>
 800d68e:	4604      	mov	r4, r0
 800d690:	2800      	cmp	r0, #0
 800d692:	f000 818a 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_URC_EVENT,
                                (uint16_t) sizeof(CS_UrcEvent_t),
                                (void *)&p_modem_ctxt->SID_ctxt.urcEvent) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d696:	2401      	movs	r4, #1
 800d698:	e187      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DIAL_COMMAND:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d69a:	f500 62e8 	add.w	r2, r0, #1856	; 0x740
 800d69e:	2118      	movs	r1, #24
 800d6a0:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6a4:	f7fe fdfa 	bl	800c29c <DATAPACK_readPtr>
 800d6a8:	4604      	mov	r4, r0
 800d6aa:	2800      	cmp	r0, #0
 800d6ac:	f000 817d 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SOCKET_INFO,
                             (void **)&p_modem_ctxt->socket_ctxt.socket_info) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d6b0:	2401      	movs	r4, #1
 800d6b2:	e17a      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SEND_DATA:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d6b4:	f500 63ce 	add.w	r3, r0, #1648	; 0x670
 800d6b8:	2258      	movs	r2, #88	; 0x58
 800d6ba:	2119      	movs	r1, #25
 800d6bc:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6c0:	f7fe fe18 	bl	800c2f4 <DATAPACK_readStruct>
 800d6c4:	4604      	mov	r4, r0
 800d6c6:	2800      	cmp	r0, #0
 800d6c8:	f000 816f 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SOCKET_DATA_BUFFER,
                                (uint16_t) sizeof(csint_socket_data_buffer_t),
                                &p_modem_ctxt->SID_ctxt.socketSendData_struct) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d6cc:	2401      	movs	r4, #1
 800d6ce:	e16c      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        break;

      case SID_CS_RECEIVE_DATA:
      case SID_CS_RECEIVE_DATA_FROM:
        /* retrieve pointer on client structure */
        if (DATAPACK_readStruct(p_atp_ctxt->p_cmd_input,
 800d6d0:	f200 7344 	addw	r3, r0, #1860	; 0x744
 800d6d4:	2258      	movs	r2, #88	; 0x58
 800d6d6:	2119      	movs	r1, #25
 800d6d8:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6dc:	f7fe fe0a 	bl	800c2f4 <DATAPACK_readStruct>
 800d6e0:	4604      	mov	r4, r0
 800d6e2:	2800      	cmp	r0, #0
 800d6e4:	f000 8161 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SOCKET_DATA_BUFFER,
                                (uint16_t) sizeof(csint_socket_data_buffer_t),
                                (void *)&p_modem_ctxt->socket_ctxt.socketReceivedata) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d6e8:	2401      	movs	r4, #1
 800d6ea:	e15e      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SOCKET_CLOSE:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d6ec:	f500 62e8 	add.w	r2, r0, #1856	; 0x740
 800d6f0:	2118      	movs	r1, #24
 800d6f2:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6f6:	f7fe fdd1 	bl	800c29c <DATAPACK_readPtr>
 800d6fa:	4604      	mov	r4, r0
 800d6fc:	2800      	cmp	r0, #0
 800d6fe:	f000 8154 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SOCKET_INFO,
                             (void **)&p_modem_ctxt->socket_ctxt.socket_info) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d702:	2401      	movs	r4, #1
 800d704:	e151      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_RESET:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d706:	f500 63d9 	add.w	r3, r0, #1736	; 0x6c8
 800d70a:	2201      	movs	r2, #1
 800d70c:	2120      	movs	r1, #32
 800d70e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d712:	f7fe fdef 	bl	800c2f4 <DATAPACK_readStruct>
 800d716:	4604      	mov	r4, r0
 800d718:	2800      	cmp	r0, #0
 800d71a:	f000 8146 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_RESET,
                                (uint16_t) sizeof(CS_Reset_t),
                                (void *)&p_modem_ctxt->SID_ctxt.reset_type) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d71e:	2401      	movs	r4, #1
 800d720:	e143      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_ACTIVATE_PDN:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d722:	f200 63c9 	addw	r3, r0, #1737	; 0x6c9
 800d726:	2201      	movs	r2, #1
 800d728:	2121      	movs	r1, #33	; 0x21
 800d72a:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d72e:	f7fe fde1 	bl	800c2f4 <DATAPACK_readStruct>
 800d732:	4604      	mov	r4, r0
 800d734:	2800      	cmp	r0, #0
 800d736:	f000 8138 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_ACTIVATE_PDN,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->SID_ctxt.pdn_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d73a:	2401      	movs	r4, #1
 800d73c:	e135      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DEACTIVATE_PDN:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d73e:	f200 63c9 	addw	r3, r0, #1737	; 0x6c9
 800d742:	2201      	movs	r2, #1
 800d744:	2122      	movs	r1, #34	; 0x22
 800d746:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d74a:	f7fe fdd3 	bl	800c2f4 <DATAPACK_readStruct>
 800d74e:	4604      	mov	r4, r0
 800d750:	2800      	cmp	r0, #0
 800d752:	f000 812a 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_DEACTIVATE_PDN,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->SID_ctxt.pdn_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d756:	2401      	movs	r4, #1
 800d758:	e127      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_DEFINE_PDN:
      {
        csint_pdn_infos_t *ptr_pdn_infos;
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d75a:	aa01      	add	r2, sp, #4
 800d75c:	2123      	movs	r1, #35	; 0x23
 800d75e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d762:	f7fe fd9b 	bl	800c29c <DATAPACK_readPtr>
 800d766:	4604      	mov	r4, r0
 800d768:	b108      	cbz	r0, 800d76e <atcm_retrieve_SID_parameters+0x20a>
          /* affect a modem cid to this configuration */
          affect_modem_cid(&p_modem_ctxt->persist, ptr_pdn_infos->conf_id);
        }
        else
        {
          retval = ATSTATUS_ERROR;
 800d76a:	2401      	movs	r4, #1
        }
        break;
 800d76c:	e11d      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
          (void) memcpy((void *)&p_modem_ctxt->persist.pdp_ctxt_infos[ptr_pdn_infos->conf_id],
 800d76e:	9901      	ldr	r1, [sp, #4]
 800d770:	780b      	ldrb	r3, [r1, #0]
 800d772:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 800d776:	0058      	lsls	r0, r3, #1
 800d778:	3048      	adds	r0, #72	; 0x48
 800d77a:	4428      	add	r0, r5
 800d77c:	2282      	movs	r2, #130	; 0x82
 800d77e:	3008      	adds	r0, #8
 800d780:	f018 fbc6 	bl	8025f10 <memcpy>
          p_modem_ctxt->SID_ctxt.pdn_conf_id = ptr_pdn_infos->conf_id;
 800d784:	9b01      	ldr	r3, [sp, #4]
 800d786:	7819      	ldrb	r1, [r3, #0]
 800d788:	f885 16c9 	strb.w	r1, [r5, #1737]	; 0x6c9
          affect_modem_cid(&p_modem_ctxt->persist, ptr_pdn_infos->conf_id);
 800d78c:	f105 000c 	add.w	r0, r5, #12
 800d790:	f7fe ffb8 	bl	800c704 <affect_modem_cid>
 800d794:	e109      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
      }

      case SID_CS_SET_DEFAULT_PDN:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d796:	f200 43f4 	addw	r3, r0, #1268	; 0x4f4
 800d79a:	2201      	movs	r2, #1
 800d79c:	2124      	movs	r1, #36	; 0x24
 800d79e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7a2:	f7fe fda7 	bl	800c2f4 <DATAPACK_readStruct>
 800d7a6:	4604      	mov	r4, r0
 800d7a8:	2800      	cmp	r0, #0
 800d7aa:	f000 80fe 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SET_DEFAULT_PDN,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->persist.pdn_default_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d7ae:	2401      	movs	r4, #1
 800d7b0:	e0fb      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_GET_IP_ADDRESS:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d7b2:	f200 63c9 	addw	r3, r0, #1737	; 0x6c9
 800d7b6:	2201      	movs	r2, #1
 800d7b8:	2125      	movs	r1, #37	; 0x25
 800d7ba:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7be:	f7fe fd99 	bl	800c2f4 <DATAPACK_readStruct>
 800d7c2:	4604      	mov	r4, r0
 800d7c4:	2800      	cmp	r0, #0
 800d7c6:	f000 80f0 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_GET_IP_ADDRESS,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->SID_ctxt.pdn_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d7ca:	2401      	movs	r4, #1
 800d7cc:	e0ed      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DNS_REQ:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d7ce:	f200 62cc 	addw	r2, r0, #1740	; 0x6cc
 800d7d2:	2127      	movs	r1, #39	; 0x27
 800d7d4:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7d8:	f7fe fd60 	bl	800c29c <DATAPACK_readPtr>
 800d7dc:	4604      	mov	r4, r0
 800d7de:	2800      	cmp	r0, #0
 800d7e0:	f040 80e6 	bne.w	800d9b0 <atcm_retrieve_SID_parameters+0x44c>
                             (uint16_t) CSMT_DNS_REQ,
                             (void **)&p_modem_ctxt->SID_ctxt.dns_request_infos) == DATAPACK_OK)
        {
          /* set SID ctxt pdn conf id */
          p_modem_ctxt->SID_ctxt.pdn_conf_id = p_modem_ctxt->SID_ctxt.dns_request_infos->conf_id;
 800d7e4:	f8d5 36cc 	ldr.w	r3, [r5, #1740]	; 0x6cc
 800d7e8:	781b      	ldrb	r3, [r3, #0]
 800d7ea:	f885 36c9 	strb.w	r3, [r5, #1737]	; 0x6c9
 800d7ee:	e0dc      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SOCKET_CNX_STATUS:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d7f0:	f500 62f5 	add.w	r2, r0, #1960	; 0x7a8
 800d7f4:	211c      	movs	r1, #28
 800d7f6:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7fa:	f7fe fd4f 	bl	800c29c <DATAPACK_readPtr>
 800d7fe:	4604      	mov	r4, r0
 800d800:	2800      	cmp	r0, #0
 800d802:	f000 80d2 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SOCKET_CNX_STATUS,
                             (void **)&p_modem_ctxt->socket_ctxt.socket_cnx_infos) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d806:	2401      	movs	r4, #1
 800d808:	e0cf      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SUSBCRIBE_MODEM_EVENT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d80a:	f100 0322 	add.w	r3, r0, #34	; 0x22
 800d80e:	2202      	movs	r2, #2
 800d810:	2129      	movs	r1, #41	; 0x29
 800d812:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d816:	f7fe fd6d 	bl	800c2f4 <DATAPACK_readStruct>
 800d81a:	4604      	mov	r4, r0
 800d81c:	2800      	cmp	r0, #0
 800d81e:	f000 80c4 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_MODEM_EVENT,
                                (uint16_t) sizeof(CS_ModemEvent_t),
                                (void *)&p_modem_ctxt->persist.modem_events_subscript) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d822:	2401      	movs	r4, #1
 800d824:	e0c1      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_PING_IP_ADDRESS:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d826:	f500 63da 	add.w	r3, r0, #1744	; 0x6d0
 800d82a:	2243      	movs	r2, #67	; 0x43
 800d82c:	2128      	movs	r1, #40	; 0x28
 800d82e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d832:	f7fe fd5f 	bl	800c2f4 <DATAPACK_readStruct>
 800d836:	4604      	mov	r4, r0
 800d838:	2800      	cmp	r0, #0
 800d83a:	f040 80bb 	bne.w	800d9b4 <atcm_retrieve_SID_parameters+0x450>
                                (uint16_t) CSMT_PING_ADDRESS,
                                (uint16_t) sizeof(csint_ping_params_t),
                                (void *)&p_modem_ctxt->SID_ctxt.ping_infos) == DATAPACK_OK)
        {
          /* set SID ctxt pdn conf id */
          p_modem_ctxt->SID_ctxt.pdn_conf_id = p_modem_ctxt->SID_ctxt.ping_infos.conf_id;
 800d83e:	f895 36d0 	ldrb.w	r3, [r5, #1744]	; 0x6d0
 800d842:	f885 36c9 	strb.w	r3, [r5, #1737]	; 0x6c9
 800d846:	e0b0      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DIRECT_CMD:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d848:	f200 7214 	addw	r2, r0, #1812	; 0x714
 800d84c:	212b      	movs	r1, #43	; 0x2b
 800d84e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d852:	f7fe fd23 	bl	800c29c <DATAPACK_readPtr>
 800d856:	4604      	mov	r4, r0
 800d858:	2800      	cmp	r0, #0
 800d85a:	f000 80a6 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_DIRECT_CMD,
                             (void **)&p_modem_ctxt->SID_ctxt.direct_cmd_tx) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d85e:	2401      	movs	r4, #1
 800d860:	e0a3      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SIM_SELECT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d862:	f200 5312 	addw	r3, r0, #1298	; 0x512
 800d866:	2201      	movs	r2, #1
 800d868:	212c      	movs	r1, #44	; 0x2c
 800d86a:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d86e:	f7fe fd41 	bl	800c2f4 <DATAPACK_readStruct>
 800d872:	4604      	mov	r4, r0
 800d874:	2800      	cmp	r0, #0
 800d876:	f000 8098 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SIM_SELECT,
                                (uint16_t) sizeof(CS_SimSlot_t),
                                (void *)&p_modem_ctxt->persist.sim_selected) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d87a:	2401      	movs	r4, #1
 800d87c:	e095      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SIM_GENERIC_ACCESS:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d87e:	f500 63cd 	add.w	r3, r0, #1640	; 0x668
 800d882:	2208      	movs	r2, #8
 800d884:	212d      	movs	r1, #45	; 0x2d
 800d886:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d88a:	f7fe fd33 	bl	800c2f4 <DATAPACK_readStruct>
 800d88e:	4604      	mov	r4, r0
 800d890:	2800      	cmp	r0, #0
 800d892:	f000 808a 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SIM_GENERIC_ACCESS,
                                (uint16_t) sizeof(csint_sim_generic_access_t),
                                &p_modem_ctxt->SID_ctxt.sim_generic_access) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d896:	2401      	movs	r4, #1
 800d898:	e087      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
      case SID_CS_GET_ATTACHSTATUS:
      case SID_ATTACH_PS_DOMAIN:
      case SID_DETACH_PS_DOMAIN:
      case SID_CS_DATA_SUSPEND:
      case SID_CS_DATA_RESUME:
        PRINT_DBG("No data to unpack for SID %d", p_atp_ctxt->current_SID)
 800d89a:	4d47      	ldr	r5, [pc, #284]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d89c:	4947      	ldr	r1, [pc, #284]	; (800d9bc <atcm_retrieve_SID_parameters+0x458>)
 800d89e:	4628      	mov	r0, r5
 800d8a0:	f018 f9e6 	bl	8025c70 <sprintf>
 800d8a4:	4628      	mov	r0, r5
 800d8a6:	f011 fc34 	bl	801f112 <crs_strlen>
 800d8aa:	b283      	uxth	r3, r0
 800d8ac:	462a      	mov	r2, r5
 800d8ae:	2102      	movs	r1, #2
 800d8b0:	4608      	mov	r0, r1
 800d8b2:	f011 fc71 	bl	801f198 <traceIF_itmPrint>
 800d8b6:	4628      	mov	r0, r5
 800d8b8:	f011 fc2b 	bl	801f112 <crs_strlen>
 800d8bc:	b283      	uxth	r3, r0
 800d8be:	462a      	mov	r2, r5
 800d8c0:	2102      	movs	r1, #2
 800d8c2:	4608      	mov	r0, r1
 800d8c4:	f011 fc8a 	bl	801f1dc <traceIF_uartPrint>
        break;
 800d8c8:	e06f      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_REGISTER_PDN_EVENT:
      case SID_CS_DEREGISTER_PDN_EVENT:
        PRINT_DBG("No data to unpack for SID %d", p_atp_ctxt->current_SID)
 800d8ca:	4d3b      	ldr	r5, [pc, #236]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d8cc:	493b      	ldr	r1, [pc, #236]	; (800d9bc <atcm_retrieve_SID_parameters+0x458>)
 800d8ce:	4628      	mov	r0, r5
 800d8d0:	f018 f9ce 	bl	8025c70 <sprintf>
 800d8d4:	4628      	mov	r0, r5
 800d8d6:	f011 fc1c 	bl	801f112 <crs_strlen>
 800d8da:	b283      	uxth	r3, r0
 800d8dc:	462a      	mov	r2, r5
 800d8de:	2102      	movs	r1, #2
 800d8e0:	4608      	mov	r0, r1
 800d8e2:	f011 fc59 	bl	801f198 <traceIF_itmPrint>
 800d8e6:	4628      	mov	r0, r5
 800d8e8:	f011 fc13 	bl	801f112 <crs_strlen>
 800d8ec:	b283      	uxth	r3, r0
 800d8ee:	462a      	mov	r2, r5
 800d8f0:	2102      	movs	r1, #2
 800d8f2:	4608      	mov	r0, r1
 800d8f4:	f011 fc72 	bl	801f1dc <traceIF_uartPrint>
        break;
 800d8f8:	e057      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_INIT_POWER_CONFIG:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d8fa:	f500 63e3 	add.w	r3, r0, #1816	; 0x718
 800d8fe:	2207      	movs	r2, #7
 800d900:	212e      	movs	r1, #46	; 0x2e
 800d902:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d906:	f7fe fcf5 	bl	800c2f4 <DATAPACK_readStruct>
 800d90a:	4604      	mov	r4, r0
 800d90c:	2800      	cmp	r0, #0
 800d90e:	d04c      	beq.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_INIT_POWER_CONFIG,
                                (uint16_t) sizeof(CS_init_power_config_t),
                                (void *)&p_modem_ctxt->SID_ctxt.init_power_config) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d910:	2401      	movs	r4, #1
 800d912:	e04a      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SET_POWER_CONFIG:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d914:	f200 731f 	addw	r3, r0, #1823	; 0x71f
 800d918:	220a      	movs	r2, #10
 800d91a:	212f      	movs	r1, #47	; 0x2f
 800d91c:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d920:	f7fe fce8 	bl	800c2f4 <DATAPACK_readStruct>
 800d924:	4604      	mov	r4, r0
 800d926:	2800      	cmp	r0, #0
 800d928:	d03f      	beq.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SET_POWER_CONFIG,
                                (uint16_t) sizeof(CS_set_power_config_t),
                                (void *)&p_modem_ctxt->SID_ctxt.set_power_config) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d92a:	2401      	movs	r4, #1
 800d92c:	e03d      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>


      case SID_CS_SLEEP_REQUEST:
      case SID_CS_SLEEP_COMPLETE:
      case SID_CS_SLEEP_CANCEL:
        PRINT_DBG("No data to unpack for SID %d", p_atp_ctxt->current_SID)
 800d92e:	4d22      	ldr	r5, [pc, #136]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d930:	4922      	ldr	r1, [pc, #136]	; (800d9bc <atcm_retrieve_SID_parameters+0x458>)
 800d932:	4628      	mov	r0, r5
 800d934:	f018 f99c 	bl	8025c70 <sprintf>
 800d938:	4628      	mov	r0, r5
 800d93a:	f011 fbea 	bl	801f112 <crs_strlen>
 800d93e:	b283      	uxth	r3, r0
 800d940:	462a      	mov	r2, r5
 800d942:	2102      	movs	r1, #2
 800d944:	4608      	mov	r0, r1
 800d946:	f011 fc27 	bl	801f198 <traceIF_itmPrint>
 800d94a:	4628      	mov	r0, r5
 800d94c:	f011 fbe1 	bl	801f112 <crs_strlen>
 800d950:	b283      	uxth	r3, r0
 800d952:	462a      	mov	r2, r5
 800d954:	2102      	movs	r1, #2
 800d956:	4608      	mov	r0, r1
 800d958:	f011 fc40 	bl	801f1dc <traceIF_uartPrint>
        break;
 800d95c:	e025      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_WAKEUP:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d95e:	f200 7329 	addw	r3, r0, #1833	; 0x729
 800d962:	2201      	movs	r2, #1
 800d964:	2130      	movs	r1, #48	; 0x30
 800d966:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d96a:	f7fe fcc3 	bl	800c2f4 <DATAPACK_readStruct>
 800d96e:	4604      	mov	r4, r0
 800d970:	b1d8      	cbz	r0, 800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_WAKEUP_ORIGIN,
                                (uint16_t) sizeof(CS_wakeup_origin_t),
                                (void *)&p_modem_ctxt->SID_ctxt.wakeup_origin) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d972:	2401      	movs	r4, #1
 800d974:	e019      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        SID_CS_SOCKET_CREATE, - not needed, config is done at CS level
        SID_CS_SOCKET_SET_OPTION, - not needed, config is done at CS level
        SID_CS_SOCKET_GET_OPTION, - not needed, config is done at CS level
        ***************/
      default:
        PRINT_ERR("Missing treatment for SID %d", p_atp_ctxt->current_SID)
 800d976:	4c10      	ldr	r4, [pc, #64]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d978:	4911      	ldr	r1, [pc, #68]	; (800d9c0 <atcm_retrieve_SID_parameters+0x45c>)
 800d97a:	4620      	mov	r0, r4
 800d97c:	f018 f978 	bl	8025c70 <sprintf>
 800d980:	4620      	mov	r0, r4
 800d982:	f011 fbc6 	bl	801f112 <crs_strlen>
 800d986:	b283      	uxth	r3, r0
 800d988:	4622      	mov	r2, r4
 800d98a:	2110      	movs	r1, #16
 800d98c:	2002      	movs	r0, #2
 800d98e:	f011 fc03 	bl	801f198 <traceIF_itmPrint>
 800d992:	4620      	mov	r0, r4
 800d994:	f011 fbbd 	bl	801f112 <crs_strlen>
 800d998:	b283      	uxth	r3, r0
 800d99a:	4622      	mov	r2, r4
 800d99c:	2110      	movs	r1, #16
 800d99e:	2002      	movs	r0, #2
 800d9a0:	f011 fc1c 	bl	801f1dc <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800d9a4:	2401      	movs	r4, #1
        break;
 800d9a6:	e000      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
  at_status_t retval = ATSTATUS_OK;
 800d9a8:	2400      	movs	r4, #0
    }

  }

  return (retval);
}
 800d9aa:	4620      	mov	r0, r4
 800d9ac:	b003      	add	sp, #12
 800d9ae:	bd30      	pop	{r4, r5, pc}
          retval = ATSTATUS_ERROR;
 800d9b0:	2401      	movs	r4, #1
 800d9b2:	e7fa      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
          retval = ATSTATUS_ERROR;
 800d9b4:	2401      	movs	r4, #1
 800d9b6:	e7f8      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
 800d9b8:	200048dc 	.word	0x200048dc
 800d9bc:	0802def0 	.word	0x0802def0
 800d9c0:	0802df18 	.word	0x0802df18

0800d9c4 <atcm_get_affected_modem_cid>:
  * @param  p_persistent_ctxt
  * @param  conf_id
  * @retval uint8_t affected modem CID
  */
uint8_t atcm_get_affected_modem_cid(atcustom_persistent_context_t *p_persistent_ctxt, CS_PDN_conf_id_t conf_id)
{
 800d9c4:	b570      	push	{r4, r5, r6, lr}
 800d9c6:	4604      	mov	r4, r0
 800d9c8:	460d      	mov	r5, r1
  uint8_t retval = 1U; /* return first valid cid by default (do not return 0 which is a special cid value !!!) */
  CS_PDN_conf_id_t current_conf_id = conf_id;

  /* if default PDN is required, retrieve corresponding conf_id */
  if (conf_id == CS_PDN_CONFIG_DEFAULT)
 800d9ca:	290b      	cmp	r1, #11
 800d9cc:	d003      	beq.n	800d9d6 <atcm_get_affected_modem_cid+0x12>
    current_conf_id = p_persistent_ctxt->pdn_default_conf_id;
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
  }

  bool leave_loop = false;
  uint8_t i = 0U;
 800d9ce:	2300      	movs	r3, #0
  bool leave_loop = false;
 800d9d0:	4619      	mov	r1, r3
  uint8_t retval = 1U; /* return first valid cid by default (do not return 0 which is a special cid value !!!) */
 800d9d2:	2001      	movs	r0, #1
 800d9d4:	e01f      	b.n	800da16 <atcm_get_affected_modem_cid+0x52>
    current_conf_id = p_persistent_ctxt->pdn_default_conf_id;
 800d9d6:	f890 54e8 	ldrb.w	r5, [r0, #1256]	; 0x4e8
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
 800d9da:	4e17      	ldr	r6, [pc, #92]	; (800da38 <atcm_get_affected_modem_cid+0x74>)
 800d9dc:	462a      	mov	r2, r5
 800d9de:	4917      	ldr	r1, [pc, #92]	; (800da3c <atcm_get_affected_modem_cid+0x78>)
 800d9e0:	4630      	mov	r0, r6
 800d9e2:	f018 f945 	bl	8025c70 <sprintf>
 800d9e6:	4630      	mov	r0, r6
 800d9e8:	f011 fb93 	bl	801f112 <crs_strlen>
 800d9ec:	b283      	uxth	r3, r0
 800d9ee:	4632      	mov	r2, r6
 800d9f0:	2102      	movs	r1, #2
 800d9f2:	4608      	mov	r0, r1
 800d9f4:	f011 fbd0 	bl	801f198 <traceIF_itmPrint>
 800d9f8:	4630      	mov	r0, r6
 800d9fa:	f011 fb8a 	bl	801f112 <crs_strlen>
 800d9fe:	b283      	uxth	r3, r0
 800da00:	4632      	mov	r2, r6
 800da02:	2102      	movs	r1, #2
 800da04:	4608      	mov	r0, r1
 800da06:	f011 fbe9 	bl	801f1dc <traceIF_uartPrint>
 800da0a:	e7e0      	b.n	800d9ce <atcm_get_affected_modem_cid+0xa>
    {
      /* return affected modem cid */
      retval = p_tmp->mdm_cid_value;
      leave_loop = true;
    }
    i++;
 800da0c:	3301      	adds	r3, #1
 800da0e:	b2db      	uxtb	r3, r3
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800da10:	b989      	cbnz	r1, 800da36 <atcm_get_affected_modem_cid+0x72>
 800da12:	2b05      	cmp	r3, #5
 800da14:	d80f      	bhi.n	800da36 <atcm_get_affected_modem_cid+0x72>
    if (p_tmp->affected_config == current_conf_id)
 800da16:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da1a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800da1e:	f892 2352 	ldrb.w	r2, [r2, #850]	; 0x352
 800da22:	42aa      	cmp	r2, r5
 800da24:	d1f2      	bne.n	800da0c <atcm_get_affected_modem_cid+0x48>
      retval = p_tmp->mdm_cid_value;
 800da26:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da2a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800da2e:	f892 0350 	ldrb.w	r0, [r2, #848]	; 0x350
      leave_loop = true;
 800da32:	2101      	movs	r1, #1
 800da34:	e7ea      	b.n	800da0c <atcm_get_affected_modem_cid+0x48>

  return (retval);
}
 800da36:	bd70      	pop	{r4, r5, r6, pc}
 800da38:	200048dc 	.word	0x200048dc
 800da3c:	0802dc8c 	.word	0x0802dc8c

0800da40 <atcm_get_configID_for_modem_cid>:
  * @param  modem_cid
  * @retval CS_PDN_conf_id_t
  */
CS_PDN_conf_id_t atcm_get_configID_for_modem_cid(const atcustom_persistent_context_t *p_persistent_ctxt,
                                                 uint8_t modem_cid)
{
 800da40:	b410      	push	{r4}
 800da42:	4684      	mov	ip, r0
  CS_PDN_conf_id_t retval = CS_PDN_NOT_DEFINED;
  bool leave_loop = false;
  uint8_t i = 0U;
 800da44:	2300      	movs	r3, #0
  bool leave_loop = false;
 800da46:	461c      	mov	r4, r3
  CS_PDN_conf_id_t retval = CS_PDN_NOT_DEFINED;
 800da48:	200c      	movs	r0, #12
 800da4a:	e004      	b.n	800da56 <atcm_get_configID_for_modem_cid+0x16>
    {
      /* return corresponding Used Config ID */
      retval = p_tmp->affected_config;
      leave_loop = true;
    }
    i++;
 800da4c:	3301      	adds	r3, #1
 800da4e:	b2db      	uxtb	r3, r3
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800da50:	b98c      	cbnz	r4, 800da76 <atcm_get_configID_for_modem_cid+0x36>
 800da52:	2b05      	cmp	r3, #5
 800da54:	d80f      	bhi.n	800da76 <atcm_get_configID_for_modem_cid+0x36>
    if (p_tmp->mdm_cid_value == modem_cid)
 800da56:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da5a:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
 800da5e:	f892 2350 	ldrb.w	r2, [r2, #848]	; 0x350
 800da62:	428a      	cmp	r2, r1
 800da64:	d1f2      	bne.n	800da4c <atcm_get_configID_for_modem_cid+0xc>
      retval = p_tmp->affected_config;
 800da66:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da6a:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
 800da6e:	f892 0352 	ldrb.w	r0, [r2, #850]	; 0x352
      leave_loop = true;
 800da72:	2401      	movs	r4, #1
 800da74:	e7ea      	b.n	800da4c <atcm_get_configID_for_modem_cid+0xc>

  return (retval);
}
 800da76:	f85d 4b04 	ldr.w	r4, [sp], #4
 800da7a:	4770      	bx	lr

0800da7c <atcm_convert_index_to_PDN_conf>:
  * @retval CS_PDN_conf_id_t
  */
CS_PDN_conf_id_t atcm_convert_index_to_PDN_conf(uint8_t index)
{
  CS_PDN_conf_id_t PDNconf;
  switch (index)
 800da7c:	2805      	cmp	r0, #5
 800da7e:	d804      	bhi.n	800da8a <atcm_convert_index_to_PDN_conf+0xe>
 800da80:	e8df f000 	tbb	[pc, r0]
 800da84:	04040404 	.word	0x04040404
 800da88:	0404      	.short	0x0404
      break;
    case 5:
      PDNconf = CS_PDN_USER_CONFIG_5;
      break;
    default:
      PDNconf = CS_PDN_NOT_DEFINED;
 800da8a:	200c      	movs	r0, #12
      break;
  }
  return (PDNconf);
}
 800da8c:	4770      	bx	lr
	...

0800da90 <reserve_user_modem_cid>:
{
 800da90:	b538      	push	{r3, r4, r5, lr}
 800da92:	4605      	mov	r5, r0
 800da94:	4614      	mov	r4, r2
  CS_PDN_conf_id_t user_pdn_conf = atcm_convert_index_to_PDN_conf(reserved_user_modem_cid);
 800da96:	4610      	mov	r0, r2
 800da98:	f7ff fff0 	bl	800da7c <atcm_convert_index_to_PDN_conf>
      (user_pdn_conf == CS_PDN_USER_CONFIG_4) ||
 800da9c:	1e43      	subs	r3, r0, #1
 800da9e:	b2db      	uxtb	r3, r3
  if ((user_pdn_conf == CS_PDN_USER_CONFIG_1) ||
 800daa0:	2b04      	cmp	r3, #4
 800daa2:	d925      	bls.n	800daf0 <reserve_user_modem_cid+0x60>
    PRINT_ERR("Trying to affect a non-valid modem CID")
 800daa4:	4c1f      	ldr	r4, [pc, #124]	; (800db24 <reserve_user_modem_cid+0x94>)
 800daa6:	4d20      	ldr	r5, [pc, #128]	; (800db28 <reserve_user_modem_cid+0x98>)
 800daa8:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 800daac:	46a4      	mov	ip, r4
 800daae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dab2:	6028      	str	r0, [r5, #0]
 800dab4:	6069      	str	r1, [r5, #4]
 800dab6:	60aa      	str	r2, [r5, #8]
 800dab8:	60eb      	str	r3, [r5, #12]
 800daba:	4664      	mov	r4, ip
 800dabc:	3510      	adds	r5, #16
 800dabe:	45f4      	cmp	ip, lr
 800dac0:	d1f4      	bne.n	800daac <reserve_user_modem_cid+0x1c>
 800dac2:	cc03      	ldmia	r4!, {r0, r1}
 800dac4:	6028      	str	r0, [r5, #0]
 800dac6:	6069      	str	r1, [r5, #4]
 800dac8:	4c17      	ldr	r4, [pc, #92]	; (800db28 <reserve_user_modem_cid+0x98>)
 800daca:	4620      	mov	r0, r4
 800dacc:	f011 fb21 	bl	801f112 <crs_strlen>
 800dad0:	b283      	uxth	r3, r0
 800dad2:	4622      	mov	r2, r4
 800dad4:	2110      	movs	r1, #16
 800dad6:	2002      	movs	r0, #2
 800dad8:	f011 fb5e 	bl	801f198 <traceIF_itmPrint>
 800dadc:	4620      	mov	r0, r4
 800dade:	f011 fb18 	bl	801f112 <crs_strlen>
 800dae2:	b283      	uxth	r3, r0
 800dae4:	4622      	mov	r2, r4
 800dae6:	2110      	movs	r1, #16
 800dae8:	2002      	movs	r0, #2
 800daea:	f011 fb77 	bl	801f1dc <traceIF_uartPrint>
}
 800daee:	bd38      	pop	{r3, r4, r5, pc}
    uint8_t i = 0U;
 800daf0:	2300      	movs	r3, #0
    bool leave_loop = false;
 800daf2:	461a      	mov	r2, r3
 800daf4:	e005      	b.n	800db02 <reserve_user_modem_cid+0x72>
      i++;
 800daf6:	3301      	adds	r3, #1
 800daf8:	b2db      	uxtb	r3, r3
    } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800dafa:	2a00      	cmp	r2, #0
 800dafc:	d1f7      	bne.n	800daee <reserve_user_modem_cid+0x5e>
 800dafe:	2b05      	cmp	r3, #5
 800db00:	d8f5      	bhi.n	800daee <reserve_user_modem_cid+0x5e>
      if (reserved_user_modem_cid == p_tmp->mdm_cid_value)
 800db02:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 800db06:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 800db0a:	f891 1350 	ldrb.w	r1, [r1, #848]	; 0x350
 800db0e:	42a1      	cmp	r1, r4
 800db10:	d1f1      	bne.n	800daf6 <reserve_user_modem_cid+0x66>
        p_tmp->pdn_defined = AT_TRUE;
 800db12:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 800db16:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 800db1a:	2201      	movs	r2, #1
 800db1c:	f881 2351 	strb.w	r2, [r1, #849]	; 0x351
        leave_loop = true;
 800db20:	e7e9      	b.n	800daf6 <reserve_user_modem_cid+0x66>
 800db22:	bf00      	nop
 800db24:	0802dc54 	.word	0x0802dc54
 800db28:	200048dc 	.word	0x200048dc

0800db2c <reset_pdn_event>:
  * @param  p_persistent_ctxt
  * @retval none
  */
void reset_pdn_event(atcustom_persistent_context_t *p_persistent_ctxt)
{
  p_persistent_ctxt->pdn_event.event_origine = CGEV_EVENT_UNDEFINE;
 800db2c:	2300      	movs	r3, #0
 800db2e:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  p_persistent_ctxt->pdn_event.event_scope   = CGEV_EVENT_SCOPE_GLOBAL;
 800db32:	220b      	movs	r2, #11
 800db34:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
  p_persistent_ctxt->pdn_event.event_type    = CGEV_EVENT_UNDEFINE;
 800db38:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  p_persistent_ctxt->pdn_event.conf_id       = CS_PDN_NOT_DEFINED;
 800db3c:	230c      	movs	r3, #12
 800db3e:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
}
 800db42:	4770      	bx	lr

0800db44 <atcm_modem_get_urc>:
{
 800db44:	b5f0      	push	{r4, r5, r6, r7, lr}
 800db46:	b083      	sub	sp, #12
 800db48:	4604      	mov	r4, r0
 800db4a:	4617      	mov	r7, r2
  if (p_modem_ctxt->persist.urc_avail_eps_network_registration == AT_TRUE)
 800db4c:	7d03      	ldrb	r3, [r0, #20]
 800db4e:	2b00      	cmp	r3, #0
 800db50:	d149      	bne.n	800dbe6 <atcm_modem_get_urc+0xa2>
  else if (p_modem_ctxt->persist.urc_avail_gprs_network_registration == AT_TRUE)
 800db52:	7dc3      	ldrb	r3, [r0, #23]
 800db54:	2b00      	cmp	r3, #0
 800db56:	f040 80ba 	bne.w	800dcce <atcm_modem_get_urc+0x18a>
  else if (p_modem_ctxt->persist.urc_avail_cs_network_registration == AT_TRUE)
 800db5a:	7e83      	ldrb	r3, [r0, #26]
 800db5c:	2b00      	cmp	r3, #0
 800db5e:	f040 80ed 	bne.w	800dd3c <atcm_modem_get_urc+0x1f8>
  else if ((p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE)
 800db62:	7d43      	ldrb	r3, [r0, #21]
 800db64:	b91b      	cbnz	r3, 800db6e <atcm_modem_get_urc+0x2a>
           || (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE))
 800db66:	7d83      	ldrb	r3, [r0, #22]
 800db68:	2b00      	cmp	r3, #0
 800db6a:	f000 811c 	beq.w	800dda6 <atcm_modem_get_urc+0x262>
    PRINT_DBG("urc_avail_eps_location_info_tac or urc_avail_eps_location_info_ci")
 800db6e:	4daf      	ldr	r5, [pc, #700]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800db70:	224d      	movs	r2, #77	; 0x4d
 800db72:	49af      	ldr	r1, [pc, #700]	; (800de30 <atcm_modem_get_urc+0x2ec>)
 800db74:	4628      	mov	r0, r5
 800db76:	f018 f9cb 	bl	8025f10 <memcpy>
 800db7a:	4628      	mov	r0, r5
 800db7c:	f011 fac9 	bl	801f112 <crs_strlen>
 800db80:	b283      	uxth	r3, r0
 800db82:	462a      	mov	r2, r5
 800db84:	2102      	movs	r1, #2
 800db86:	4608      	mov	r0, r1
 800db88:	f011 fb06 	bl	801f198 <traceIF_itmPrint>
 800db8c:	4628      	mov	r0, r5
 800db8e:	f011 fac0 	bl	801f112 <crs_strlen>
 800db92:	b283      	uxth	r3, r0
 800db94:	462a      	mov	r2, r5
 800db96:	2102      	movs	r1, #2
 800db98:	4608      	mov	r0, r1
 800db9a:	f011 fb1f 	bl	801f1dc <traceIF_uartPrint>
    csint_location_info_t loc_struct = { .ci_updated = CELLULAR_FALSE, .lac_updated = CELLULAR_FALSE, };
 800db9e:	2300      	movs	r3, #0
 800dba0:	9300      	str	r3, [sp, #0]
 800dba2:	9301      	str	r3, [sp, #4]
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE)
 800dba4:	7d63      	ldrb	r3, [r4, #21]
 800dba6:	b12b      	cbz	r3, 800dbb4 <atcm_modem_get_urc+0x70>
      loc_struct.lac = p_modem_ctxt->persist.eps_location_info.lac;
 800dba8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800dbaa:	f8ad 3004 	strh.w	r3, [sp, #4]
      loc_struct.lac_updated = CELLULAR_TRUE;
 800dbae:	2301      	movs	r3, #1
 800dbb0:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE)
 800dbb4:	7da3      	ldrb	r3, [r4, #22]
 800dbb6:	b123      	cbz	r3, 800dbc2 <atcm_modem_get_urc+0x7e>
      loc_struct.ci = p_modem_ctxt->persist.eps_location_info.ci;
 800dbb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800dbba:	9300      	str	r3, [sp, #0]
      loc_struct.ci_updated = CELLULAR_TRUE;
 800dbbc:	2301      	movs	r3, #1
 800dbbe:	f88d 3006 	strb.w	r3, [sp, #6]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dbc2:	466b      	mov	r3, sp
 800dbc4:	2208      	movs	r2, #8
 800dbc6:	2106      	movs	r1, #6
 800dbc8:	4638      	mov	r0, r7
 800dbca:	f7fe fa73 	bl	800c0b4 <DATAPACK_writeStruct>
 800dbce:	4605      	mov	r5, r0
 800dbd0:	b100      	cbz	r0, 800dbd4 <atcm_modem_get_urc+0x90>
      retval = ATSTATUS_ERROR;
 800dbd2:	2501      	movs	r5, #1
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE)
 800dbd4:	7d63      	ldrb	r3, [r4, #21]
 800dbd6:	b10b      	cbz	r3, 800dbdc <atcm_modem_get_urc+0x98>
      p_modem_ctxt->persist.urc_avail_eps_location_info_tac = AT_FALSE;
 800dbd8:	2300      	movs	r3, #0
 800dbda:	7563      	strb	r3, [r4, #21]
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE)
 800dbdc:	7da3      	ldrb	r3, [r4, #22]
 800dbde:	b3b3      	cbz	r3, 800dc4e <atcm_modem_get_urc+0x10a>
      p_modem_ctxt->persist.urc_avail_eps_location_info_ci = AT_FALSE;
 800dbe0:	2300      	movs	r3, #0
 800dbe2:	75a3      	strb	r3, [r4, #22]
  {
 800dbe4:	e033      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_eps_network_registration")
 800dbe6:	4e93      	ldr	r6, [pc, #588]	; (800de34 <atcm_modem_get_urc+0x2f0>)
 800dbe8:	4d90      	ldr	r5, [pc, #576]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dbea:	f106 0e20 	add.w	lr, r6, #32
 800dbee:	46b4      	mov	ip, r6
 800dbf0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dbf4:	6028      	str	r0, [r5, #0]
 800dbf6:	6069      	str	r1, [r5, #4]
 800dbf8:	60aa      	str	r2, [r5, #8]
 800dbfa:	60eb      	str	r3, [r5, #12]
 800dbfc:	4666      	mov	r6, ip
 800dbfe:	3510      	adds	r5, #16
 800dc00:	45f4      	cmp	ip, lr
 800dc02:	d1f4      	bne.n	800dbee <atcm_modem_get_urc+0xaa>
 800dc04:	ce07      	ldmia	r6!, {r0, r1, r2}
 800dc06:	6028      	str	r0, [r5, #0]
 800dc08:	6069      	str	r1, [r5, #4]
 800dc0a:	60aa      	str	r2, [r5, #8]
 800dc0c:	8833      	ldrh	r3, [r6, #0]
 800dc0e:	81ab      	strh	r3, [r5, #12]
 800dc10:	4d86      	ldr	r5, [pc, #536]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dc12:	4628      	mov	r0, r5
 800dc14:	f011 fa7d 	bl	801f112 <crs_strlen>
 800dc18:	b283      	uxth	r3, r0
 800dc1a:	462a      	mov	r2, r5
 800dc1c:	2102      	movs	r1, #2
 800dc1e:	4608      	mov	r0, r1
 800dc20:	f011 faba 	bl	801f198 <traceIF_itmPrint>
 800dc24:	4628      	mov	r0, r5
 800dc26:	f011 fa74 	bl	801f112 <crs_strlen>
 800dc2a:	b283      	uxth	r3, r0
 800dc2c:	462a      	mov	r2, r5
 800dc2e:	2102      	movs	r1, #2
 800dc30:	4608      	mov	r0, r1
 800dc32:	f011 fad3 	bl	801f1dc <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dc36:	f104 0330 	add.w	r3, r4, #48	; 0x30
 800dc3a:	2202      	movs	r2, #2
 800dc3c:	2105      	movs	r1, #5
 800dc3e:	4638      	mov	r0, r7
 800dc40:	f7fe fa38 	bl	800c0b4 <DATAPACK_writeStruct>
 800dc44:	4605      	mov	r5, r0
 800dc46:	b100      	cbz	r0, 800dc4a <atcm_modem_get_urc+0x106>
      retval = ATSTATUS_ERROR;
 800dc48:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_eps_network_registration = AT_FALSE;
 800dc4a:	2300      	movs	r3, #0
 800dc4c:	7523      	strb	r3, [r4, #20]
  if ((p_modem_ctxt->persist.urc_avail_eps_network_registration == AT_TRUE) ||
 800dc4e:	7d23      	ldrb	r3, [r4, #20]
 800dc50:	2b00      	cmp	r3, #0
 800dc52:	f040 8322 	bne.w	800e29a <atcm_modem_get_urc+0x756>
      (p_modem_ctxt->persist.urc_avail_gprs_network_registration == AT_TRUE) ||
 800dc56:	7de3      	ldrb	r3, [r4, #23]
  if ((p_modem_ctxt->persist.urc_avail_eps_network_registration == AT_TRUE) ||
 800dc58:	2b00      	cmp	r3, #0
 800dc5a:	f040 8322 	bne.w	800e2a2 <atcm_modem_get_urc+0x75e>
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE) ||
 800dc5e:	7e23      	ldrb	r3, [r4, #24]
      (p_modem_ctxt->persist.urc_avail_gprs_network_registration == AT_TRUE) ||
 800dc60:	2b00      	cmp	r3, #0
 800dc62:	f040 8320 	bne.w	800e2a6 <atcm_modem_get_urc+0x762>
      (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE) ||
 800dc66:	7d63      	ldrb	r3, [r4, #21]
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE) ||
 800dc68:	2b00      	cmp	r3, #0
 800dc6a:	f040 831e 	bne.w	800e2aa <atcm_modem_get_urc+0x766>
      (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE) ||
 800dc6e:	7da3      	ldrb	r3, [r4, #22]
      (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE) ||
 800dc70:	2b00      	cmp	r3, #0
 800dc72:	f040 831c 	bne.w	800e2ae <atcm_modem_get_urc+0x76a>
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE) ||
 800dc76:	7e63      	ldrb	r3, [r4, #25]
      (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE) ||
 800dc78:	2b00      	cmp	r3, #0
 800dc7a:	f040 831a 	bne.w	800e2b2 <atcm_modem_get_urc+0x76e>
      (p_modem_ctxt->persist.urc_avail_cs_network_registration == AT_TRUE) ||
 800dc7e:	7ea3      	ldrb	r3, [r4, #26]
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE) ||
 800dc80:	2b00      	cmp	r3, #0
 800dc82:	f040 8318 	bne.w	800e2b6 <atcm_modem_get_urc+0x772>
      (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE) ||
 800dc86:	7ee3      	ldrb	r3, [r4, #27]
      (p_modem_ctxt->persist.urc_avail_cs_network_registration == AT_TRUE) ||
 800dc88:	2b00      	cmp	r3, #0
 800dc8a:	f040 8316 	bne.w	800e2ba <atcm_modem_get_urc+0x776>
      (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE) ||
 800dc8e:	7f23      	ldrb	r3, [r4, #28]
      (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE) ||
 800dc90:	2b00      	cmp	r3, #0
 800dc92:	f040 8314 	bne.w	800e2be <atcm_modem_get_urc+0x77a>
      (p_modem_ctxt->persist.urc_avail_signal_quality == AT_TRUE) ||
 800dc96:	7f63      	ldrb	r3, [r4, #29]
      (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE) ||
 800dc98:	2b00      	cmp	r3, #0
 800dc9a:	f040 8312 	bne.w	800e2c2 <atcm_modem_get_urc+0x77e>
      (p_modem_ctxt->persist.urc_avail_socket_data_pending == AT_TRUE) ||
 800dc9e:	7fa3      	ldrb	r3, [r4, #30]
      (p_modem_ctxt->persist.urc_avail_signal_quality == AT_TRUE) ||
 800dca0:	2b00      	cmp	r3, #0
 800dca2:	f040 8310 	bne.w	800e2c6 <atcm_modem_get_urc+0x782>
      (p_modem_ctxt->persist.urc_avail_socket_closed_by_remote == AT_TRUE) ||
 800dca6:	7fe3      	ldrb	r3, [r4, #31]
      (p_modem_ctxt->persist.urc_avail_socket_data_pending == AT_TRUE) ||
 800dca8:	2b00      	cmp	r3, #0
 800dcaa:	f040 830e 	bne.w	800e2ca <atcm_modem_get_urc+0x786>
      (p_modem_ctxt->persist.urc_avail_pdn_event == AT_TRUE) ||
 800dcae:	f894 3020 	ldrb.w	r3, [r4, #32]
      (p_modem_ctxt->persist.urc_avail_socket_closed_by_remote == AT_TRUE) ||
 800dcb2:	2b00      	cmp	r3, #0
 800dcb4:	f040 830b 	bne.w	800e2ce <atcm_modem_get_urc+0x78a>
      (p_modem_ctxt->persist.urc_avail_ping_rsp == AT_TRUE) ||
 800dcb8:	f894 35ac 	ldrb.w	r3, [r4, #1452]	; 0x5ac
      (p_modem_ctxt->persist.urc_avail_pdn_event == AT_TRUE) ||
 800dcbc:	2b00      	cmp	r3, #0
 800dcbe:	f040 8308 	bne.w	800e2d2 <atcm_modem_get_urc+0x78e>
      (p_modem_ctxt->persist.urc_avail_modem_events != CS_MDMEVENT_NONE))
 800dcc2:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
      (p_modem_ctxt->persist.urc_avail_ping_rsp == AT_TRUE) ||
 800dcc4:	2b00      	cmp	r3, #0
 800dcc6:	f000 82e9 	beq.w	800e29c <atcm_modem_get_urc+0x758>
    retval = ATSTATUS_OK_PENDING_URC;
 800dcca:	2503      	movs	r5, #3
 800dccc:	e2e6      	b.n	800e29c <atcm_modem_get_urc+0x758>
    PRINT_DBG("urc_avail_gprs_network_registration")
 800dcce:	4e5a      	ldr	r6, [pc, #360]	; (800de38 <atcm_modem_get_urc+0x2f4>)
 800dcd0:	4d56      	ldr	r5, [pc, #344]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dcd2:	f106 0e20 	add.w	lr, r6, #32
 800dcd6:	46b4      	mov	ip, r6
 800dcd8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dcdc:	6028      	str	r0, [r5, #0]
 800dcde:	6069      	str	r1, [r5, #4]
 800dce0:	60aa      	str	r2, [r5, #8]
 800dce2:	60eb      	str	r3, [r5, #12]
 800dce4:	4666      	mov	r6, ip
 800dce6:	3510      	adds	r5, #16
 800dce8:	45f4      	cmp	ip, lr
 800dcea:	d1f4      	bne.n	800dcd6 <atcm_modem_get_urc+0x192>
 800dcec:	ce07      	ldmia	r6!, {r0, r1, r2}
 800dcee:	6028      	str	r0, [r5, #0]
 800dcf0:	6069      	str	r1, [r5, #4]
 800dcf2:	60aa      	str	r2, [r5, #8]
 800dcf4:	8832      	ldrh	r2, [r6, #0]
 800dcf6:	78b3      	ldrb	r3, [r6, #2]
 800dcf8:	81aa      	strh	r2, [r5, #12]
 800dcfa:	73ab      	strb	r3, [r5, #14]
 800dcfc:	4d4b      	ldr	r5, [pc, #300]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dcfe:	4628      	mov	r0, r5
 800dd00:	f011 fa07 	bl	801f112 <crs_strlen>
 800dd04:	b283      	uxth	r3, r0
 800dd06:	462a      	mov	r2, r5
 800dd08:	2102      	movs	r1, #2
 800dd0a:	4608      	mov	r0, r1
 800dd0c:	f011 fa44 	bl	801f198 <traceIF_itmPrint>
 800dd10:	4628      	mov	r0, r5
 800dd12:	f011 f9fe 	bl	801f112 <crs_strlen>
 800dd16:	b283      	uxth	r3, r0
 800dd18:	462a      	mov	r2, r5
 800dd1a:	2102      	movs	r1, #2
 800dd1c:	4608      	mov	r0, r1
 800dd1e:	f011 fa5d 	bl	801f1dc <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dd22:	f104 033c 	add.w	r3, r4, #60	; 0x3c
 800dd26:	2202      	movs	r2, #2
 800dd28:	2107      	movs	r1, #7
 800dd2a:	4638      	mov	r0, r7
 800dd2c:	f7fe f9c2 	bl	800c0b4 <DATAPACK_writeStruct>
 800dd30:	4605      	mov	r5, r0
 800dd32:	b100      	cbz	r0, 800dd36 <atcm_modem_get_urc+0x1f2>
      retval = ATSTATUS_ERROR;
 800dd34:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_gprs_network_registration = AT_FALSE;
 800dd36:	2300      	movs	r3, #0
 800dd38:	75e3      	strb	r3, [r4, #23]
 800dd3a:	e788      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_cs_network_registration")
 800dd3c:	4e3f      	ldr	r6, [pc, #252]	; (800de3c <atcm_modem_get_urc+0x2f8>)
 800dd3e:	4d3b      	ldr	r5, [pc, #236]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dd40:	f106 0e20 	add.w	lr, r6, #32
 800dd44:	46b4      	mov	ip, r6
 800dd46:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dd4a:	6028      	str	r0, [r5, #0]
 800dd4c:	6069      	str	r1, [r5, #4]
 800dd4e:	60aa      	str	r2, [r5, #8]
 800dd50:	60eb      	str	r3, [r5, #12]
 800dd52:	4666      	mov	r6, ip
 800dd54:	3510      	adds	r5, #16
 800dd56:	45f4      	cmp	ip, lr
 800dd58:	d1f4      	bne.n	800dd44 <atcm_modem_get_urc+0x200>
 800dd5a:	ce07      	ldmia	r6!, {r0, r1, r2}
 800dd5c:	6028      	str	r0, [r5, #0]
 800dd5e:	6069      	str	r1, [r5, #4]
 800dd60:	60aa      	str	r2, [r5, #8]
 800dd62:	7833      	ldrb	r3, [r6, #0]
 800dd64:	732b      	strb	r3, [r5, #12]
 800dd66:	4d31      	ldr	r5, [pc, #196]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dd68:	4628      	mov	r0, r5
 800dd6a:	f011 f9d2 	bl	801f112 <crs_strlen>
 800dd6e:	b283      	uxth	r3, r0
 800dd70:	462a      	mov	r2, r5
 800dd72:	2102      	movs	r1, #2
 800dd74:	4608      	mov	r0, r1
 800dd76:	f011 fa0f 	bl	801f198 <traceIF_itmPrint>
 800dd7a:	4628      	mov	r0, r5
 800dd7c:	f011 f9c9 	bl	801f112 <crs_strlen>
 800dd80:	b283      	uxth	r3, r0
 800dd82:	462a      	mov	r2, r5
 800dd84:	2102      	movs	r1, #2
 800dd86:	4608      	mov	r0, r1
 800dd88:	f011 fa28 	bl	801f1dc <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dd8c:	f104 0348 	add.w	r3, r4, #72	; 0x48
 800dd90:	2202      	movs	r2, #2
 800dd92:	2109      	movs	r1, #9
 800dd94:	4638      	mov	r0, r7
 800dd96:	f7fe f98d 	bl	800c0b4 <DATAPACK_writeStruct>
 800dd9a:	4605      	mov	r5, r0
 800dd9c:	b100      	cbz	r0, 800dda0 <atcm_modem_get_urc+0x25c>
      retval = ATSTATUS_ERROR;
 800dd9e:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_cs_network_registration = AT_FALSE;
 800dda0:	2300      	movs	r3, #0
 800dda2:	76a3      	strb	r3, [r4, #26]
 800dda4:	e753      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
  else if ((p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE)
 800dda6:	7e03      	ldrb	r3, [r0, #24]
 800dda8:	b913      	cbnz	r3, 800ddb0 <atcm_modem_get_urc+0x26c>
           || (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE))
 800ddaa:	7e43      	ldrb	r3, [r0, #25]
 800ddac:	2b00      	cmp	r3, #0
 800ddae:	d049      	beq.n	800de44 <atcm_modem_get_urc+0x300>
    PRINT_DBG("urc_avail_gprs_location_info_tac or urc_avail_gprs_location_info_ci")
 800ddb0:	4d1e      	ldr	r5, [pc, #120]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800ddb2:	224f      	movs	r2, #79	; 0x4f
 800ddb4:	4922      	ldr	r1, [pc, #136]	; (800de40 <atcm_modem_get_urc+0x2fc>)
 800ddb6:	4628      	mov	r0, r5
 800ddb8:	f018 f8aa 	bl	8025f10 <memcpy>
 800ddbc:	4628      	mov	r0, r5
 800ddbe:	f011 f9a8 	bl	801f112 <crs_strlen>
 800ddc2:	b283      	uxth	r3, r0
 800ddc4:	462a      	mov	r2, r5
 800ddc6:	2102      	movs	r1, #2
 800ddc8:	4608      	mov	r0, r1
 800ddca:	f011 f9e5 	bl	801f198 <traceIF_itmPrint>
 800ddce:	4628      	mov	r0, r5
 800ddd0:	f011 f99f 	bl	801f112 <crs_strlen>
 800ddd4:	b283      	uxth	r3, r0
 800ddd6:	462a      	mov	r2, r5
 800ddd8:	2102      	movs	r1, #2
 800ddda:	4608      	mov	r0, r1
 800dddc:	f011 f9fe 	bl	801f1dc <traceIF_uartPrint>
    csint_location_info_t loc_struct = { .ci_updated = CELLULAR_FALSE, .lac_updated = CELLULAR_FALSE, };
 800dde0:	2300      	movs	r3, #0
 800dde2:	9300      	str	r3, [sp, #0]
 800dde4:	9301      	str	r3, [sp, #4]
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE)
 800dde6:	7e23      	ldrb	r3, [r4, #24]
 800dde8:	b12b      	cbz	r3, 800ddf6 <atcm_modem_get_urc+0x2b2>
      loc_struct.lac = p_modem_ctxt->persist.gprs_location_info.lac;
 800ddea:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800ddec:	f8ad 3004 	strh.w	r3, [sp, #4]
      loc_struct.lac_updated = CELLULAR_TRUE;
 800ddf0:	2301      	movs	r3, #1
 800ddf2:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE)
 800ddf6:	7e63      	ldrb	r3, [r4, #25]
 800ddf8:	b123      	cbz	r3, 800de04 <atcm_modem_get_urc+0x2c0>
      loc_struct.ci = p_modem_ctxt->persist.gprs_location_info.ci;
 800ddfa:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800ddfc:	9300      	str	r3, [sp, #0]
      loc_struct.ci_updated = CELLULAR_TRUE;
 800ddfe:	2301      	movs	r3, #1
 800de00:	f88d 3006 	strb.w	r3, [sp, #6]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800de04:	466b      	mov	r3, sp
 800de06:	2208      	movs	r2, #8
 800de08:	4611      	mov	r1, r2
 800de0a:	4638      	mov	r0, r7
 800de0c:	f7fe f952 	bl	800c0b4 <DATAPACK_writeStruct>
 800de10:	4605      	mov	r5, r0
 800de12:	b100      	cbz	r0, 800de16 <atcm_modem_get_urc+0x2d2>
      retval = ATSTATUS_ERROR;
 800de14:	2501      	movs	r5, #1
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE)
 800de16:	7e23      	ldrb	r3, [r4, #24]
 800de18:	b10b      	cbz	r3, 800de1e <atcm_modem_get_urc+0x2da>
      p_modem_ctxt->persist.urc_avail_gprs_location_info_lac = AT_FALSE;
 800de1a:	2300      	movs	r3, #0
 800de1c:	7623      	strb	r3, [r4, #24]
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE)
 800de1e:	7e63      	ldrb	r3, [r4, #25]
 800de20:	2b00      	cmp	r3, #0
 800de22:	f43f af14 	beq.w	800dc4e <atcm_modem_get_urc+0x10a>
      p_modem_ctxt->persist.urc_avail_gprs_location_info_ci = AT_FALSE;
 800de26:	2300      	movs	r3, #0
 800de28:	7663      	strb	r3, [r4, #25]
  {
 800de2a:	e710      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
 800de2c:	200048dc 	.word	0x200048dc
 800de30:	0802dfd8 	.word	0x0802dfd8
 800de34:	0802df48 	.word	0x0802df48
 800de38:	0802df78 	.word	0x0802df78
 800de3c:	0802dfa8 	.word	0x0802dfa8
 800de40:	0802e028 	.word	0x0802e028
  else if ((p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE)
 800de44:	7ec3      	ldrb	r3, [r0, #27]
 800de46:	b913      	cbnz	r3, 800de4e <atcm_modem_get_urc+0x30a>
           || (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE))
 800de48:	7f03      	ldrb	r3, [r0, #28]
 800de4a:	2b00      	cmp	r3, #0
 800de4c:	d03e      	beq.n	800decc <atcm_modem_get_urc+0x388>
    PRINT_DBG("urc_avail_cs_location_info_lac or urc_avail_cs_location_info_ci")
 800de4e:	4dc3      	ldr	r5, [pc, #780]	; (800e15c <atcm_modem_get_urc+0x618>)
 800de50:	224b      	movs	r2, #75	; 0x4b
 800de52:	49c3      	ldr	r1, [pc, #780]	; (800e160 <atcm_modem_get_urc+0x61c>)
 800de54:	4628      	mov	r0, r5
 800de56:	f018 f85b 	bl	8025f10 <memcpy>
 800de5a:	4628      	mov	r0, r5
 800de5c:	f011 f959 	bl	801f112 <crs_strlen>
 800de60:	b283      	uxth	r3, r0
 800de62:	462a      	mov	r2, r5
 800de64:	2102      	movs	r1, #2
 800de66:	4608      	mov	r0, r1
 800de68:	f011 f996 	bl	801f198 <traceIF_itmPrint>
 800de6c:	4628      	mov	r0, r5
 800de6e:	f011 f950 	bl	801f112 <crs_strlen>
 800de72:	b283      	uxth	r3, r0
 800de74:	462a      	mov	r2, r5
 800de76:	2102      	movs	r1, #2
 800de78:	4608      	mov	r0, r1
 800de7a:	f011 f9af 	bl	801f1dc <traceIF_uartPrint>
    csint_location_info_t loc_struct = { .ci_updated = CELLULAR_FALSE, .lac_updated = CELLULAR_FALSE, };
 800de7e:	2300      	movs	r3, #0
 800de80:	9300      	str	r3, [sp, #0]
 800de82:	9301      	str	r3, [sp, #4]
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE)
 800de84:	7ee3      	ldrb	r3, [r4, #27]
 800de86:	b133      	cbz	r3, 800de96 <atcm_modem_get_urc+0x352>
      loc_struct.lac = p_modem_ctxt->persist.cs_location_info.lac;
 800de88:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
 800de8c:	f8ad 3004 	strh.w	r3, [sp, #4]
      loc_struct.lac_updated = CELLULAR_TRUE;
 800de90:	2301      	movs	r3, #1
 800de92:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE)
 800de96:	7f23      	ldrb	r3, [r4, #28]
 800de98:	b123      	cbz	r3, 800dea4 <atcm_modem_get_urc+0x360>
      loc_struct.ci = p_modem_ctxt->persist.cs_location_info.ci;
 800de9a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800de9c:	9300      	str	r3, [sp, #0]
      loc_struct.ci_updated = CELLULAR_TRUE;
 800de9e:	2301      	movs	r3, #1
 800dea0:	f88d 3006 	strb.w	r3, [sp, #6]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dea4:	466b      	mov	r3, sp
 800dea6:	2208      	movs	r2, #8
 800dea8:	210a      	movs	r1, #10
 800deaa:	4638      	mov	r0, r7
 800deac:	f7fe f902 	bl	800c0b4 <DATAPACK_writeStruct>
 800deb0:	4605      	mov	r5, r0
 800deb2:	b100      	cbz	r0, 800deb6 <atcm_modem_get_urc+0x372>
      retval = ATSTATUS_ERROR;
 800deb4:	2501      	movs	r5, #1
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE)
 800deb6:	7ee3      	ldrb	r3, [r4, #27]
 800deb8:	b10b      	cbz	r3, 800debe <atcm_modem_get_urc+0x37a>
      p_modem_ctxt->persist.urc_avail_cs_location_info_lac = AT_FALSE;
 800deba:	2300      	movs	r3, #0
 800debc:	76e3      	strb	r3, [r4, #27]
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE)
 800debe:	7f23      	ldrb	r3, [r4, #28]
 800dec0:	2b00      	cmp	r3, #0
 800dec2:	f43f aec4 	beq.w	800dc4e <atcm_modem_get_urc+0x10a>
      p_modem_ctxt->persist.urc_avail_cs_location_info_ci = AT_FALSE;
 800dec6:	2300      	movs	r3, #0
 800dec8:	7723      	strb	r3, [r4, #28]
  {
 800deca:	e6c0      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
  else if (p_modem_ctxt->persist.urc_avail_signal_quality == AT_TRUE)
 800decc:	7f43      	ldrb	r3, [r0, #29]
 800dece:	2b00      	cmp	r3, #0
 800ded0:	d145      	bne.n	800df5e <atcm_modem_get_urc+0x41a>
  else if (p_modem_ctxt->persist.urc_avail_socket_data_pending == AT_TRUE)
 800ded2:	7f83      	ldrb	r3, [r0, #30]
 800ded4:	2b00      	cmp	r3, #0
 800ded6:	d17a      	bne.n	800dfce <atcm_modem_get_urc+0x48a>
  else if (p_modem_ctxt->persist.urc_avail_socket_closed_by_remote == AT_TRUE)
 800ded8:	7fc3      	ldrb	r3, [r0, #31]
 800deda:	2b00      	cmp	r3, #0
 800dedc:	f040 80b2 	bne.w	800e044 <atcm_modem_get_urc+0x500>
  else if (p_modem_ctxt->persist.urc_avail_pdn_event == AT_TRUE)
 800dee0:	f890 3020 	ldrb.w	r3, [r0, #32]
 800dee4:	2b00      	cmp	r3, #0
 800dee6:	f040 80e9 	bne.w	800e0bc <atcm_modem_get_urc+0x578>
  else if (p_modem_ctxt->persist.urc_avail_ping_rsp == AT_TRUE)
 800deea:	f890 35ac 	ldrb.w	r3, [r0, #1452]	; 0x5ac
 800deee:	2b00      	cmp	r3, #0
 800def0:	f040 8186 	bne.w	800e200 <atcm_modem_get_urc+0x6bc>
  else if (p_modem_ctxt->persist.urc_avail_modem_events != CS_MDMEVENT_NONE)
 800def4:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 800def6:	2b00      	cmp	r3, #0
 800def8:	f000 81af 	beq.w	800e25a <atcm_modem_get_urc+0x716>
    PRINT_DBG("urc_avail_modem_events")
 800defc:	f8df c268 	ldr.w	ip, [pc, #616]	; 800e168 <atcm_modem_get_urc+0x624>
 800df00:	4d96      	ldr	r5, [pc, #600]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df02:	f10c 0e20 	add.w	lr, ip, #32
 800df06:	4666      	mov	r6, ip
 800df08:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800df0a:	6028      	str	r0, [r5, #0]
 800df0c:	6069      	str	r1, [r5, #4]
 800df0e:	60aa      	str	r2, [r5, #8]
 800df10:	60eb      	str	r3, [r5, #12]
 800df12:	46b4      	mov	ip, r6
 800df14:	3510      	adds	r5, #16
 800df16:	4576      	cmp	r6, lr
 800df18:	d1f5      	bne.n	800df06 <atcm_modem_get_urc+0x3c2>
 800df1a:	8833      	ldrh	r3, [r6, #0]
 800df1c:	802b      	strh	r3, [r5, #0]
 800df1e:	4d8f      	ldr	r5, [pc, #572]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df20:	4628      	mov	r0, r5
 800df22:	f011 f8f6 	bl	801f112 <crs_strlen>
 800df26:	b283      	uxth	r3, r0
 800df28:	462a      	mov	r2, r5
 800df2a:	2102      	movs	r1, #2
 800df2c:	4608      	mov	r0, r1
 800df2e:	f011 f933 	bl	801f198 <traceIF_itmPrint>
 800df32:	4628      	mov	r0, r5
 800df34:	f011 f8ed 	bl	801f112 <crs_strlen>
 800df38:	b283      	uxth	r3, r0
 800df3a:	462a      	mov	r2, r5
 800df3c:	2102      	movs	r1, #2
 800df3e:	4608      	mov	r0, r1
 800df40:	f011 f94c 	bl	801f1dc <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800df44:	f104 0324 	add.w	r3, r4, #36	; 0x24
 800df48:	2202      	movs	r2, #2
 800df4a:	210f      	movs	r1, #15
 800df4c:	4638      	mov	r0, r7
 800df4e:	f7fe f8b1 	bl	800c0b4 <DATAPACK_writeStruct>
 800df52:	4605      	mov	r5, r0
 800df54:	b100      	cbz	r0, 800df58 <atcm_modem_get_urc+0x414>
      retval = ATSTATUS_ERROR;
 800df56:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_modem_events = CS_MDMEVENT_NONE;
 800df58:	2300      	movs	r3, #0
 800df5a:	84a3      	strh	r3, [r4, #36]	; 0x24
 800df5c:	e677      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_signal_quality")
 800df5e:	f8df c20c 	ldr.w	ip, [pc, #524]	; 800e16c <atcm_modem_get_urc+0x628>
 800df62:	4e7e      	ldr	r6, [pc, #504]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df64:	f10c 0e20 	add.w	lr, ip, #32
 800df68:	4665      	mov	r5, ip
 800df6a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800df6c:	6030      	str	r0, [r6, #0]
 800df6e:	6071      	str	r1, [r6, #4]
 800df70:	60b2      	str	r2, [r6, #8]
 800df72:	60f3      	str	r3, [r6, #12]
 800df74:	46ac      	mov	ip, r5
 800df76:	3610      	adds	r6, #16
 800df78:	4575      	cmp	r5, lr
 800df7a:	d1f5      	bne.n	800df68 <atcm_modem_get_urc+0x424>
 800df7c:	6828      	ldr	r0, [r5, #0]
 800df7e:	6030      	str	r0, [r6, #0]
 800df80:	4d76      	ldr	r5, [pc, #472]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df82:	4628      	mov	r0, r5
 800df84:	f011 f8c5 	bl	801f112 <crs_strlen>
 800df88:	b283      	uxth	r3, r0
 800df8a:	462a      	mov	r2, r5
 800df8c:	2102      	movs	r1, #2
 800df8e:	4608      	mov	r0, r1
 800df90:	f011 f902 	bl	801f198 <traceIF_itmPrint>
 800df94:	4628      	mov	r0, r5
 800df96:	f011 f8bc 	bl	801f112 <crs_strlen>
 800df9a:	b283      	uxth	r3, r0
 800df9c:	462a      	mov	r2, r5
 800df9e:	2102      	movs	r1, #2
 800dfa0:	4608      	mov	r0, r1
 800dfa2:	f011 f91b 	bl	801f1dc <traceIF_uartPrint>
    signal_quality_struct.rssi = p_modem_ctxt->persist.signal_quality.rssi;
 800dfa6:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
 800dfaa:	f88d 3000 	strb.w	r3, [sp]
    signal_quality_struct.ber = p_modem_ctxt->persist.signal_quality.ber;
 800dfae:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
 800dfb2:	f88d 3001 	strb.w	r3, [sp, #1]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dfb6:	466b      	mov	r3, sp
 800dfb8:	2202      	movs	r2, #2
 800dfba:	210b      	movs	r1, #11
 800dfbc:	4638      	mov	r0, r7
 800dfbe:	f7fe f879 	bl	800c0b4 <DATAPACK_writeStruct>
 800dfc2:	4605      	mov	r5, r0
 800dfc4:	b100      	cbz	r0, 800dfc8 <atcm_modem_get_urc+0x484>
      retval = ATSTATUS_ERROR;
 800dfc6:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_signal_quality = AT_FALSE;
 800dfc8:	2300      	movs	r3, #0
 800dfca:	7763      	strb	r3, [r4, #29]
 800dfcc:	e63f      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_socket_data_pending")
 800dfce:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 800e170 <atcm_modem_get_urc+0x62c>
 800dfd2:	4d62      	ldr	r5, [pc, #392]	; (800e15c <atcm_modem_get_urc+0x618>)
 800dfd4:	f10c 0e20 	add.w	lr, ip, #32
 800dfd8:	4666      	mov	r6, ip
 800dfda:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800dfdc:	6028      	str	r0, [r5, #0]
 800dfde:	6069      	str	r1, [r5, #4]
 800dfe0:	60aa      	str	r2, [r5, #8]
 800dfe2:	60eb      	str	r3, [r5, #12]
 800dfe4:	46b4      	mov	ip, r6
 800dfe6:	3510      	adds	r5, #16
 800dfe8:	4576      	cmp	r6, lr
 800dfea:	d1f5      	bne.n	800dfd8 <atcm_modem_get_urc+0x494>
 800dfec:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 800dff0:	6028      	str	r0, [r5, #0]
 800dff2:	6069      	str	r1, [r5, #4]
 800dff4:	f89c 3000 	ldrb.w	r3, [ip]
 800dff8:	722b      	strb	r3, [r5, #8]
 800dffa:	4d58      	ldr	r5, [pc, #352]	; (800e15c <atcm_modem_get_urc+0x618>)
 800dffc:	4628      	mov	r0, r5
 800dffe:	f011 f888 	bl	801f112 <crs_strlen>
 800e002:	b283      	uxth	r3, r0
 800e004:	462a      	mov	r2, r5
 800e006:	2102      	movs	r1, #2
 800e008:	4608      	mov	r0, r1
 800e00a:	f011 f8c5 	bl	801f198 <traceIF_itmPrint>
 800e00e:	4628      	mov	r0, r5
 800e010:	f011 f87f 	bl	801f112 <crs_strlen>
 800e014:	b283      	uxth	r3, r0
 800e016:	462a      	mov	r2, r5
 800e018:	2102      	movs	r1, #2
 800e01a:	4608      	mov	r0, r1
 800e01c:	f011 f8de 	bl	801f1dc <traceIF_uartPrint>
    socket_handle_t sockHandle = atcm_socket_get_hdle_urc_data_pending(p_modem_ctxt);
 800e020:	4620      	mov	r0, r4
 800e022:	f006 f987 	bl	8014334 <atcm_socket_get_hdle_urc_data_pending>
 800e026:	9000      	str	r0, [sp, #0]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800e028:	466b      	mov	r3, sp
 800e02a:	2204      	movs	r2, #4
 800e02c:	210d      	movs	r1, #13
 800e02e:	4638      	mov	r0, r7
 800e030:	f7fe f840 	bl	800c0b4 <DATAPACK_writeStruct>
 800e034:	4605      	mov	r5, r0
 800e036:	b100      	cbz	r0, 800e03a <atcm_modem_get_urc+0x4f6>
      retval = ATSTATUS_ERROR;
 800e038:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_socket_data_pending = atcm_socket_remaining_urc_data_pending(p_modem_ctxt);
 800e03a:	4620      	mov	r0, r4
 800e03c:	f006 fa08 	bl	8014450 <atcm_socket_remaining_urc_data_pending>
 800e040:	77a0      	strb	r0, [r4, #30]
 800e042:	e604      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_socket_closed_by_remote")
 800e044:	f8df c12c 	ldr.w	ip, [pc, #300]	; 800e174 <atcm_modem_get_urc+0x630>
 800e048:	4d44      	ldr	r5, [pc, #272]	; (800e15c <atcm_modem_get_urc+0x618>)
 800e04a:	f10c 0e20 	add.w	lr, ip, #32
 800e04e:	4666      	mov	r6, ip
 800e050:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e052:	6028      	str	r0, [r5, #0]
 800e054:	6069      	str	r1, [r5, #4]
 800e056:	60aa      	str	r2, [r5, #8]
 800e058:	60eb      	str	r3, [r5, #12]
 800e05a:	46b4      	mov	ip, r6
 800e05c:	3510      	adds	r5, #16
 800e05e:	4576      	cmp	r6, lr
 800e060:	d1f5      	bne.n	800e04e <atcm_modem_get_urc+0x50a>
 800e062:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 800e066:	6028      	str	r0, [r5, #0]
 800e068:	6069      	str	r1, [r5, #4]
 800e06a:	60aa      	str	r2, [r5, #8]
 800e06c:	f89c 3000 	ldrb.w	r3, [ip]
 800e070:	732b      	strb	r3, [r5, #12]
 800e072:	4d3a      	ldr	r5, [pc, #232]	; (800e15c <atcm_modem_get_urc+0x618>)
 800e074:	4628      	mov	r0, r5
 800e076:	f011 f84c 	bl	801f112 <crs_strlen>
 800e07a:	b283      	uxth	r3, r0
 800e07c:	462a      	mov	r2, r5
 800e07e:	2102      	movs	r1, #2
 800e080:	4608      	mov	r0, r1
 800e082:	f011 f889 	bl	801f198 <traceIF_itmPrint>
 800e086:	4628      	mov	r0, r5
 800e088:	f011 f843 	bl	801f112 <crs_strlen>
 800e08c:	b283      	uxth	r3, r0
 800e08e:	462a      	mov	r2, r5
 800e090:	2102      	movs	r1, #2
 800e092:	4608      	mov	r0, r1
 800e094:	f011 f8a2 	bl	801f1dc <traceIF_uartPrint>
    socket_handle_t sockHandle = atcm_socket_get_hdlr_urc_closed_by_remote(p_modem_ctxt);
 800e098:	4620      	mov	r0, r4
 800e09a:	f006 f991 	bl	80143c0 <atcm_socket_get_hdlr_urc_closed_by_remote>
 800e09e:	9000      	str	r0, [sp, #0]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800e0a0:	466b      	mov	r3, sp
 800e0a2:	2204      	movs	r2, #4
 800e0a4:	210e      	movs	r1, #14
 800e0a6:	4638      	mov	r0, r7
 800e0a8:	f7fe f804 	bl	800c0b4 <DATAPACK_writeStruct>
 800e0ac:	4605      	mov	r5, r0
 800e0ae:	b100      	cbz	r0, 800e0b2 <atcm_modem_get_urc+0x56e>
      retval = ATSTATUS_ERROR;
 800e0b0:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_socket_closed_by_remote = atcm_socket_remaining_urc_closed_by_remote(p_modem_ctxt);
 800e0b2:	4620      	mov	r0, r4
 800e0b4:	f006 fa06 	bl	80144c4 <atcm_socket_remaining_urc_closed_by_remote>
 800e0b8:	77e0      	strb	r0, [r4, #31]
 800e0ba:	e5c8      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_pdn_event")
 800e0bc:	4d27      	ldr	r5, [pc, #156]	; (800e15c <atcm_modem_get_urc+0x618>)
 800e0be:	4e29      	ldr	r6, [pc, #164]	; (800e164 <atcm_modem_get_urc+0x620>)
 800e0c0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e0c2:	6028      	str	r0, [r5, #0]
 800e0c4:	6069      	str	r1, [r5, #4]
 800e0c6:	60aa      	str	r2, [r5, #8]
 800e0c8:	60eb      	str	r3, [r5, #12]
 800e0ca:	ce07      	ldmia	r6!, {r0, r1, r2}
 800e0cc:	6128      	str	r0, [r5, #16]
 800e0ce:	6169      	str	r1, [r5, #20]
 800e0d0:	61aa      	str	r2, [r5, #24]
 800e0d2:	8832      	ldrh	r2, [r6, #0]
 800e0d4:	78b3      	ldrb	r3, [r6, #2]
 800e0d6:	83aa      	strh	r2, [r5, #28]
 800e0d8:	77ab      	strb	r3, [r5, #30]
 800e0da:	4628      	mov	r0, r5
 800e0dc:	f011 f819 	bl	801f112 <crs_strlen>
 800e0e0:	b283      	uxth	r3, r0
 800e0e2:	462a      	mov	r2, r5
 800e0e4:	2102      	movs	r1, #2
 800e0e6:	4608      	mov	r0, r1
 800e0e8:	f011 f856 	bl	801f198 <traceIF_itmPrint>
 800e0ec:	4628      	mov	r0, r5
 800e0ee:	f011 f810 	bl	801f112 <crs_strlen>
 800e0f2:	b283      	uxth	r3, r0
 800e0f4:	462a      	mov	r2, r5
 800e0f6:	2102      	movs	r1, #2
 800e0f8:	4608      	mov	r0, r1
 800e0fa:	f011 f86f 	bl	801f1dc <traceIF_uartPrint>
    if (p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW)
 800e0fe:	f894 504c 	ldrb.w	r5, [r4, #76]	; 0x4c
 800e102:	2d01      	cmp	r5, #1
 800e104:	d150      	bne.n	800e1a8 <atcm_modem_get_urc+0x664>
      switch (p_modem_ctxt->persist.pdn_event.event_type)
 800e106:	f894 204e 	ldrb.w	r2, [r4, #78]	; 0x4e
 800e10a:	2a0d      	cmp	r2, #13
 800e10c:	d00c      	beq.n	800e128 <atcm_modem_get_urc+0x5e4>
 800e10e:	2a0f      	cmp	r2, #15
 800e110:	d132      	bne.n	800e178 <atcm_modem_get_urc+0x634>
          if (DATAPACK_writeStruct(p_rsp_buf,
 800e112:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 800e116:	2204      	movs	r2, #4
 800e118:	210c      	movs	r1, #12
 800e11a:	4638      	mov	r0, r7
 800e11c:	f7fd ffca 	bl	800c0b4 <DATAPACK_writeStruct>
 800e120:	2800      	cmp	r0, #0
 800e122:	d165      	bne.n	800e1f0 <atcm_modem_get_urc+0x6ac>
  at_status_t retval = ATSTATUS_OK;
 800e124:	4605      	mov	r5, r0
 800e126:	e063      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
          if (p_modem_ctxt->persist.pdn_event.event_scope == CGEV_EVENT_SCOPE_PDN)
 800e128:	f894 304d 	ldrb.w	r3, [r4, #77]	; 0x4d
 800e12c:	2b0a      	cmp	r3, #10
 800e12e:	d00a      	beq.n	800e146 <atcm_modem_get_urc+0x602>
            if (DATAPACK_writeStruct(p_rsp_buf,
 800e130:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 800e134:	2204      	movs	r2, #4
 800e136:	210c      	movs	r1, #12
 800e138:	4638      	mov	r0, r7
 800e13a:	f7fd ffbb 	bl	800c0b4 <DATAPACK_writeStruct>
 800e13e:	2800      	cmp	r0, #0
 800e140:	d156      	bne.n	800e1f0 <atcm_modem_get_urc+0x6ac>
  at_status_t retval = ATSTATUS_OK;
 800e142:	4605      	mov	r5, r0
 800e144:	e054      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
            if (DATAPACK_writeStruct(p_rsp_buf,
 800e146:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 800e14a:	2204      	movs	r2, #4
 800e14c:	210c      	movs	r1, #12
 800e14e:	4638      	mov	r0, r7
 800e150:	f7fd ffb0 	bl	800c0b4 <DATAPACK_writeStruct>
 800e154:	2800      	cmp	r0, #0
 800e156:	d14b      	bne.n	800e1f0 <atcm_modem_get_urc+0x6ac>
  at_status_t retval = ATSTATUS_OK;
 800e158:	4605      	mov	r5, r0
 800e15a:	e049      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
 800e15c:	200048dc 	.word	0x200048dc
 800e160:	0802e078 	.word	0x0802e078
 800e164:	0802e144 	.word	0x0802e144
 800e168:	0802e1d8 	.word	0x0802e1d8
 800e16c:	0802e0c4 	.word	0x0802e0c4
 800e170:	0802e0e8 	.word	0x0802e0e8
 800e174:	0802e114 	.word	0x0802e114
          PRINT_INFO("+CGEV URC discarded (NW), type=%d", p_modem_ctxt->persist.pdn_event.event_type)
 800e178:	4e57      	ldr	r6, [pc, #348]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e17a:	4958      	ldr	r1, [pc, #352]	; (800e2dc <atcm_modem_get_urc+0x798>)
 800e17c:	4630      	mov	r0, r6
 800e17e:	f017 fd77 	bl	8025c70 <sprintf>
 800e182:	4630      	mov	r0, r6
 800e184:	f010 ffc5 	bl	801f112 <crs_strlen>
 800e188:	b283      	uxth	r3, r0
 800e18a:	4632      	mov	r2, r6
 800e18c:	2101      	movs	r1, #1
 800e18e:	2002      	movs	r0, #2
 800e190:	f011 f802 	bl	801f198 <traceIF_itmPrint>
 800e194:	4630      	mov	r0, r6
 800e196:	f010 ffbc 	bl	801f112 <crs_strlen>
 800e19a:	b283      	uxth	r3, r0
 800e19c:	4632      	mov	r2, r6
 800e19e:	2101      	movs	r1, #1
 800e1a0:	2002      	movs	r0, #2
 800e1a2:	f011 f81b 	bl	801f1dc <traceIF_uartPrint>
          break;
 800e1a6:	e023      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
      PRINT_INFO("+CGEV URC discarded (ME)")
 800e1a8:	4e4d      	ldr	r6, [pc, #308]	; (800e2e0 <atcm_modem_get_urc+0x79c>)
 800e1aa:	4d4b      	ldr	r5, [pc, #300]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e1ac:	f106 0c20 	add.w	ip, r6, #32
 800e1b0:	4637      	mov	r7, r6
 800e1b2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800e1b4:	6028      	str	r0, [r5, #0]
 800e1b6:	6069      	str	r1, [r5, #4]
 800e1b8:	60aa      	str	r2, [r5, #8]
 800e1ba:	60eb      	str	r3, [r5, #12]
 800e1bc:	463e      	mov	r6, r7
 800e1be:	3510      	adds	r5, #16
 800e1c0:	4567      	cmp	r7, ip
 800e1c2:	d1f5      	bne.n	800e1b0 <atcm_modem_get_urc+0x66c>
 800e1c4:	6838      	ldr	r0, [r7, #0]
 800e1c6:	6028      	str	r0, [r5, #0]
 800e1c8:	4d43      	ldr	r5, [pc, #268]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e1ca:	4628      	mov	r0, r5
 800e1cc:	f010 ffa1 	bl	801f112 <crs_strlen>
 800e1d0:	b283      	uxth	r3, r0
 800e1d2:	462a      	mov	r2, r5
 800e1d4:	2101      	movs	r1, #1
 800e1d6:	2002      	movs	r0, #2
 800e1d8:	f010 ffde 	bl	801f198 <traceIF_itmPrint>
 800e1dc:	4628      	mov	r0, r5
 800e1de:	f010 ff98 	bl	801f112 <crs_strlen>
 800e1e2:	b283      	uxth	r3, r0
 800e1e4:	462a      	mov	r2, r5
 800e1e6:	2101      	movs	r1, #1
 800e1e8:	2002      	movs	r0, #2
 800e1ea:	f010 fff7 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800e1ee:	2501      	movs	r5, #1
    reset_pdn_event(&p_modem_ctxt->persist);
 800e1f0:	f104 000c 	add.w	r0, r4, #12
 800e1f4:	f7ff fc9a 	bl	800db2c <reset_pdn_event>
    p_modem_ctxt->persist.urc_avail_pdn_event = AT_FALSE;
 800e1f8:	2300      	movs	r3, #0
 800e1fa:	f884 3020 	strb.w	r3, [r4, #32]
 800e1fe:	e526      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_ping_rsp")
 800e200:	4d35      	ldr	r5, [pc, #212]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e202:	4e38      	ldr	r6, [pc, #224]	; (800e2e4 <atcm_modem_get_urc+0x7a0>)
 800e204:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e206:	6028      	str	r0, [r5, #0]
 800e208:	6069      	str	r1, [r5, #4]
 800e20a:	60aa      	str	r2, [r5, #8]
 800e20c:	60eb      	str	r3, [r5, #12]
 800e20e:	ce07      	ldmia	r6!, {r0, r1, r2}
 800e210:	6128      	str	r0, [r5, #16]
 800e212:	6169      	str	r1, [r5, #20]
 800e214:	61aa      	str	r2, [r5, #24]
 800e216:	8833      	ldrh	r3, [r6, #0]
 800e218:	83ab      	strh	r3, [r5, #28]
 800e21a:	4628      	mov	r0, r5
 800e21c:	f010 ff79 	bl	801f112 <crs_strlen>
 800e220:	b283      	uxth	r3, r0
 800e222:	462a      	mov	r2, r5
 800e224:	2102      	movs	r1, #2
 800e226:	4608      	mov	r0, r1
 800e228:	f010 ffb6 	bl	801f198 <traceIF_itmPrint>
 800e22c:	4628      	mov	r0, r5
 800e22e:	f010 ff70 	bl	801f112 <crs_strlen>
 800e232:	b283      	uxth	r3, r0
 800e234:	462a      	mov	r2, r5
 800e236:	2102      	movs	r1, #2
 800e238:	4608      	mov	r0, r1
 800e23a:	f010 ffcf 	bl	801f1dc <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800e23e:	f204 535c 	addw	r3, r4, #1372	; 0x55c
 800e242:	2250      	movs	r2, #80	; 0x50
 800e244:	2110      	movs	r1, #16
 800e246:	4638      	mov	r0, r7
 800e248:	f7fd ff34 	bl	800c0b4 <DATAPACK_writeStruct>
 800e24c:	4605      	mov	r5, r0
 800e24e:	b100      	cbz	r0, 800e252 <atcm_modem_get_urc+0x70e>
      retval = ATSTATUS_ERROR;
 800e250:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_ping_rsp = AT_FALSE;
 800e252:	2300      	movs	r3, #0
 800e254:	f884 35ac 	strb.w	r3, [r4, #1452]	; 0x5ac
 800e258:	e4f9      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_ERR("unexpected URC")
 800e25a:	4d1f      	ldr	r5, [pc, #124]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e25c:	4e22      	ldr	r6, [pc, #136]	; (800e2e8 <atcm_modem_get_urc+0x7a4>)
 800e25e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e260:	6028      	str	r0, [r5, #0]
 800e262:	6069      	str	r1, [r5, #4]
 800e264:	60aa      	str	r2, [r5, #8]
 800e266:	60eb      	str	r3, [r5, #12]
 800e268:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e26a:	6128      	str	r0, [r5, #16]
 800e26c:	6169      	str	r1, [r5, #20]
 800e26e:	61aa      	str	r2, [r5, #24]
 800e270:	61eb      	str	r3, [r5, #28]
 800e272:	4628      	mov	r0, r5
 800e274:	f010 ff4d 	bl	801f112 <crs_strlen>
 800e278:	b283      	uxth	r3, r0
 800e27a:	462a      	mov	r2, r5
 800e27c:	2110      	movs	r1, #16
 800e27e:	2002      	movs	r0, #2
 800e280:	f010 ff8a 	bl	801f198 <traceIF_itmPrint>
 800e284:	4628      	mov	r0, r5
 800e286:	f010 ff44 	bl	801f112 <crs_strlen>
 800e28a:	b283      	uxth	r3, r0
 800e28c:	462a      	mov	r2, r5
 800e28e:	2110      	movs	r1, #16
 800e290:	2002      	movs	r0, #2
 800e292:	f010 ffa3 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800e296:	2501      	movs	r5, #1
 800e298:	e4d9      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    retval = ATSTATUS_OK_PENDING_URC;
 800e29a:	2503      	movs	r5, #3
}
 800e29c:	4628      	mov	r0, r5
 800e29e:	b003      	add	sp, #12
 800e2a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    retval = ATSTATUS_OK_PENDING_URC;
 800e2a2:	2503      	movs	r5, #3
 800e2a4:	e7fa      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2a6:	2503      	movs	r5, #3
 800e2a8:	e7f8      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2aa:	2503      	movs	r5, #3
 800e2ac:	e7f6      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ae:	2503      	movs	r5, #3
 800e2b0:	e7f4      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2b2:	2503      	movs	r5, #3
 800e2b4:	e7f2      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2b6:	2503      	movs	r5, #3
 800e2b8:	e7f0      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ba:	2503      	movs	r5, #3
 800e2bc:	e7ee      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2be:	2503      	movs	r5, #3
 800e2c0:	e7ec      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2c2:	2503      	movs	r5, #3
 800e2c4:	e7ea      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2c6:	2503      	movs	r5, #3
 800e2c8:	e7e8      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ca:	2503      	movs	r5, #3
 800e2cc:	e7e6      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ce:	2503      	movs	r5, #3
 800e2d0:	e7e4      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2d2:	2503      	movs	r5, #3
 800e2d4:	e7e2      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2d6:	bf00      	nop
 800e2d8:	200048dc 	.word	0x200048dc
 800e2dc:	0802e164 	.word	0x0802e164
 800e2e0:	0802e194 	.word	0x0802e194
 800e2e4:	0802e1b8 	.word	0x0802e1b8
 800e2e8:	0802e1fc 	.word	0x0802e1fc

0800e2ec <atcm_reset_persistent_context>:
{
 800e2ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e2f0:	4605      	mov	r5, r0
  PRINT_API("enter reset_persistent_context()")
 800e2f2:	4f61      	ldr	r7, [pc, #388]	; (800e478 <atcm_reset_persistent_context+0x18c>)
 800e2f4:	4e61      	ldr	r6, [pc, #388]	; (800e47c <atcm_reset_persistent_context+0x190>)
 800e2f6:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 800e2fa:	463c      	mov	r4, r7
 800e2fc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800e2fe:	6030      	str	r0, [r6, #0]
 800e300:	6071      	str	r1, [r6, #4]
 800e302:	60b2      	str	r2, [r6, #8]
 800e304:	60f3      	str	r3, [r6, #12]
 800e306:	4627      	mov	r7, r4
 800e308:	3610      	adds	r6, #16
 800e30a:	4564      	cmp	r4, ip
 800e30c:	d1f5      	bne.n	800e2fa <atcm_reset_persistent_context+0xe>
 800e30e:	4c5b      	ldr	r4, [pc, #364]	; (800e47c <atcm_reset_persistent_context+0x190>)
 800e310:	4620      	mov	r0, r4
 800e312:	f010 fefe 	bl	801f112 <crs_strlen>
 800e316:	b283      	uxth	r3, r0
 800e318:	4622      	mov	r2, r4
 800e31a:	2104      	movs	r1, #4
 800e31c:	2002      	movs	r0, #2
 800e31e:	f010 ff3b 	bl	801f198 <traceIF_itmPrint>
 800e322:	4620      	mov	r0, r4
 800e324:	f010 fef5 	bl	801f112 <crs_strlen>
 800e328:	b283      	uxth	r3, r0
 800e32a:	4622      	mov	r2, r4
 800e32c:	2104      	movs	r1, #4
 800e32e:	2002      	movs	r0, #2
 800e330:	f010 ff54 	bl	801f1dc <traceIF_uartPrint>
  p_persistent_ctxt->urc_subscript_eps_networkReg = CELLULAR_FALSE;
 800e334:	2400      	movs	r4, #0
 800e336:	702c      	strb	r4, [r5, #0]
  p_persistent_ctxt->urc_subscript_eps_locationInfo = CELLULAR_FALSE;
 800e338:	706c      	strb	r4, [r5, #1]
  p_persistent_ctxt->urc_subscript_gprs_networkReg = CELLULAR_FALSE;
 800e33a:	70ac      	strb	r4, [r5, #2]
  p_persistent_ctxt->urc_subscript_gprs_locationInfo = CELLULAR_FALSE;
 800e33c:	70ec      	strb	r4, [r5, #3]
  p_persistent_ctxt->urc_subscript_cs_networkReg = CELLULAR_FALSE;
 800e33e:	712c      	strb	r4, [r5, #4]
  p_persistent_ctxt->urc_subscript_cs_locationInfo = CELLULAR_FALSE;
 800e340:	716c      	strb	r4, [r5, #5]
  p_persistent_ctxt->urc_subscript_signalQuality = CELLULAR_FALSE;
 800e342:	71ac      	strb	r4, [r5, #6]
  p_persistent_ctxt->urc_subscript_pdn_event = CELLULAR_FALSE;
 800e344:	71ec      	strb	r4, [r5, #7]
  p_persistent_ctxt->urc_avail_eps_network_registration = AT_FALSE;
 800e346:	722c      	strb	r4, [r5, #8]
  p_persistent_ctxt->urc_avail_eps_location_info_tac = AT_FALSE;
 800e348:	726c      	strb	r4, [r5, #9]
  p_persistent_ctxt->urc_avail_eps_location_info_ci = AT_FALSE;
 800e34a:	72ac      	strb	r4, [r5, #10]
  p_persistent_ctxt->urc_avail_gprs_network_registration = AT_FALSE;
 800e34c:	72ec      	strb	r4, [r5, #11]
  p_persistent_ctxt->urc_avail_gprs_location_info_lac = AT_FALSE;
 800e34e:	732c      	strb	r4, [r5, #12]
  p_persistent_ctxt->urc_avail_gprs_location_info_ci = AT_FALSE;
 800e350:	736c      	strb	r4, [r5, #13]
  p_persistent_ctxt->urc_avail_cs_network_registration = AT_FALSE;
 800e352:	73ac      	strb	r4, [r5, #14]
  p_persistent_ctxt->urc_avail_cs_location_info_lac = AT_FALSE;
 800e354:	73ec      	strb	r4, [r5, #15]
  p_persistent_ctxt->urc_avail_cs_location_info_ci = AT_FALSE;
 800e356:	742c      	strb	r4, [r5, #16]
  p_persistent_ctxt->urc_avail_signal_quality = AT_FALSE;
 800e358:	746c      	strb	r4, [r5, #17]
  p_persistent_ctxt->urc_avail_socket_data_pending = AT_FALSE;
 800e35a:	74ac      	strb	r4, [r5, #18]
  p_persistent_ctxt->urc_avail_socket_closed_by_remote = AT_FALSE;
 800e35c:	74ec      	strb	r4, [r5, #19]
  p_persistent_ctxt->urc_avail_pdn_event = AT_FALSE;
 800e35e:	752c      	strb	r4, [r5, #20]
  p_persistent_ctxt->modem_events_subscript = CS_MDMEVENT_NONE;
 800e360:	82ec      	strh	r4, [r5, #22]
  p_persistent_ctxt->urc_avail_modem_events = CS_MDMEVENT_NONE;
 800e362:	832c      	strh	r4, [r5, #24]
  reset_pdn_event(p_persistent_ctxt);
 800e364:	4628      	mov	r0, r5
 800e366:	f7ff fbe1 	bl	800db2c <reset_pdn_event>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e36a:	e01c      	b.n	800e3a6 <atcm_reset_persistent_context+0xba>
    p_tmp->mdm_cid_value = i; /* modem cid value (0 is a reserved value) */
 800e36c:	0126      	lsls	r6, r4, #4
 800e36e:	eb04 1804 	add.w	r8, r4, r4, lsl #4
 800e372:	eb05 0888 	add.w	r8, r5, r8, lsl #2
 800e376:	f888 4350 	strb.w	r4, [r8, #848]	; 0x350
    p_tmp->pdn_defined = AT_FALSE;
 800e37a:	2700      	movs	r7, #0
 800e37c:	f888 7351 	strb.w	r7, [r8, #849]	; 0x351
    p_tmp->affected_config = atcm_convert_index_to_PDN_conf(i);
 800e380:	4620      	mov	r0, r4
 800e382:	f7ff fb7b 	bl	800da7c <atcm_convert_index_to_PDN_conf>
 800e386:	f888 0352 	strb.w	r0, [r8, #850]	; 0x352
    p_tmp->ip_addr_infos.ip_addr_type = CS_IPAT_INVALID;
 800e38a:	f888 7353 	strb.w	r7, [r8, #851]	; 0x353
    (void) memset((void *)&p_tmp->ip_addr_infos.ip_addr_value, 0, MAX_IP_ADDR_SIZE);
 800e38e:	1930      	adds	r0, r6, r4
 800e390:	0080      	lsls	r0, r0, #2
 800e392:	f500 7054 	add.w	r0, r0, #848	; 0x350
 800e396:	4428      	add	r0, r5
 800e398:	2240      	movs	r2, #64	; 0x40
 800e39a:	4639      	mov	r1, r7
 800e39c:	3004      	adds	r0, #4
 800e39e:	f017 fcda 	bl	8025d56 <memset>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e3a2:	3401      	adds	r4, #1
 800e3a4:	b2e4      	uxtb	r4, r4
 800e3a6:	2c05      	cmp	r4, #5
 800e3a8:	d9e0      	bls.n	800e36c <atcm_reset_persistent_context+0x80>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e3aa:	2400      	movs	r4, #0
 800e3ac:	e01c      	b.n	800e3e8 <atcm_reset_persistent_context+0xfc>
    p_tmp->conf_id = CS_PDN_NOT_DEFINED; /* not used */
 800e3ae:	01a6      	lsls	r6, r4, #6
 800e3b0:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800e3b4:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800e3b8:	220c      	movs	r2, #12
 800e3ba:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    (void) memset((void *)&p_tmp->apn, 0, MAX_APN_SIZE);
 800e3be:	eb04 1084 	add.w	r0, r4, r4, lsl #6
 800e3c2:	0040      	lsls	r0, r0, #1
 800e3c4:	3040      	adds	r0, #64	; 0x40
 800e3c6:	4428      	add	r0, r5
 800e3c8:	2240      	movs	r2, #64	; 0x40
 800e3ca:	2100      	movs	r1, #0
 800e3cc:	3005      	adds	r0, #5
 800e3ce:	f017 fcc2 	bl	8025d56 <memset>
    (void) memset((void *)&p_tmp->pdn_conf, 0, sizeof(CS_PDN_configuration_t));
 800e3d2:	1930      	adds	r0, r6, r4
 800e3d4:	0040      	lsls	r0, r0, #1
 800e3d6:	3080      	adds	r0, #128	; 0x80
 800e3d8:	4428      	add	r0, r5
 800e3da:	2241      	movs	r2, #65	; 0x41
 800e3dc:	2100      	movs	r1, #0
 800e3de:	3005      	adds	r0, #5
 800e3e0:	f017 fcb9 	bl	8025d56 <memset>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e3e4:	3401      	adds	r4, #1
 800e3e6:	b2e4      	uxtb	r4, r4
 800e3e8:	2c05      	cmp	r4, #5
 800e3ea:	d9e0      	bls.n	800e3ae <atcm_reset_persistent_context+0xc2>
  p_persistent_ctxt->pdn_default_conf_id = CS_PDN_PREDEF_CONFIG;
 800e3ec:	2400      	movs	r4, #0
 800e3ee:	f885 44e8 	strb.w	r4, [r5, #1256]	; 0x4e8
  p_predef->conf_id = CS_PDN_PREDEF_CONFIG;
 800e3f2:	f885 4044 	strb.w	r4, [r5, #68]	; 0x44
  reserve_user_modem_cid(p_persistent_ctxt, CS_PDN_PREDEF_CONFIG, 1U);
 800e3f6:	2201      	movs	r2, #1
 800e3f8:	4621      	mov	r1, r4
 800e3fa:	4628      	mov	r0, r5
 800e3fc:	f7ff fb48 	bl	800da90 <reserve_user_modem_cid>
  p_predef->pdn_conf.pdp_type = CS_PDPTYPE_IP;
 800e400:	f885 4085 	strb.w	r4, [r5, #133]	; 0x85
  (void) memcpy((AT_CHAR_t *)&p_predef->apn, "", sizeof(""));
 800e404:	f885 4045 	strb.w	r4, [r5, #69]	; 0x45
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 800e408:	4621      	mov	r1, r4
 800e40a:	e00b      	b.n	800e424 <atcm_reset_persistent_context+0x138>
    p_tmp = &p_persistent_ctxt->socket[i];
 800e40c:	460b      	mov	r3, r1
    p_tmp->socket_connId_value = ((uint8_t)i + 1U); /* socket ID range from 1 to 6,
 800e40e:	3101      	adds	r1, #1
 800e410:	b2c9      	uxtb	r1, r1
 800e412:	f503 739d 	add.w	r3, r3, #314	; 0x13a
 800e416:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800e41a:	7059      	strb	r1, [r3, #1]
    p_tmp->socket_connected = AT_FALSE;
 800e41c:	2200      	movs	r2, #0
 800e41e:	709a      	strb	r2, [r3, #2]
    p_tmp->socket_data_pending_urc = AT_FALSE;
 800e420:	70da      	strb	r2, [r3, #3]
    p_tmp->socket_closed_pending_urc = AT_FALSE;
 800e422:	711a      	strb	r2, [r3, #4]
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 800e424:	2905      	cmp	r1, #5
 800e426:	d9f1      	bls.n	800e40c <atcm_reset_persistent_context+0x120>
  p_persistent_ctxt->psm_urc_requested = AT_FALSE;       /* PSM default value */
 800e428:	2400      	movs	r4, #0
 800e42a:	f885 4501 	strb.w	r4, [r5, #1281]	; 0x501
  p_persistent_ctxt->modem_at_ready = AT_FALSE;     /* modem ready to receive AT commands */
 800e42e:	f885 4502 	strb.w	r4, [r5, #1282]	; 0x502
  p_persistent_ctxt->modem_sim_ready = AT_FALSE;    /* modem sim ready */
 800e432:	f885 4503 	strb.w	r4, [r5, #1283]	; 0x503
  p_persistent_ctxt->sim_pin_code_ready = AT_FALSE; /* modem pin code status */
 800e436:	f885 4504 	strb.w	r4, [r5, #1284]	; 0x504
  p_persistent_ctxt->cmee_level = CMEE_VERBOSE;
 800e43a:	2302      	movs	r3, #2
 800e43c:	f885 3507 	strb.w	r3, [r5, #1287]	; 0x507
  p_persistent_ctxt->sim_state = CS_SIMSTATE_UNKNOWN;
 800e440:	f885 4505 	strb.w	r4, [r5, #1285]	; 0x505
  p_persistent_ctxt->sim_selected = CS_MODEM_SIM_SOCKET_0; /* default SIM slot selected */
 800e444:	f885 4506 	strb.w	r4, [r5, #1286]	; 0x506
  p_persistent_ctxt->flowCtrl_RTS = 0xFF;       /* not initialized (from AT+IFC) */
 800e448:	26ff      	movs	r6, #255	; 0xff
 800e44a:	f885 6508 	strb.w	r6, [r5, #1288]	; 0x508
  p_persistent_ctxt->flowCtrl_CTS = 0xFF;       /* not initialized (from AT+IFC) */
 800e44e:	f885 6509 	strb.w	r6, [r5, #1289]	; 0x509
  (void) memset((void *)&p_persistent_ctxt->ping_infos, 0, sizeof(csint_ping_params_t));
 800e452:	2243      	movs	r2, #67	; 0x43
 800e454:	4621      	mov	r1, r4
 800e456:	f205 500a 	addw	r0, r5, #1290	; 0x50a
 800e45a:	f017 fc7c 	bl	8025d56 <memset>
  (void) memset((void *)&p_persistent_ctxt->ping_resp_urc, 0, sizeof(CS_Ping_response_t));
 800e45e:	2250      	movs	r2, #80	; 0x50
 800e460:	4621      	mov	r1, r4
 800e462:	f505 60aa 	add.w	r0, r5, #1360	; 0x550
 800e466:	f017 fc76 	bl	8025d56 <memset>
  p_persistent_ctxt->ping_resp_urc.index = PING_INVALID_INDEX;
 800e46a:	f885 6550 	strb.w	r6, [r5, #1360]	; 0x550
  p_persistent_ctxt->urc_avail_ping_rsp = AT_FALSE;
 800e46e:	f885 45a0 	strb.w	r4, [r5, #1440]	; 0x5a0
}
 800e472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e476:	bf00      	nop
 800e478:	0802e21c 	.word	0x0802e21c
 800e47c:	200048dc 	.word	0x200048dc

0800e480 <atcm_modem_init>:
{
 800e480:	b570      	push	{r4, r5, r6, lr}
 800e482:	4605      	mov	r5, r0
  PRINT_API("enter atcm_modem_init")
 800e484:	4e1c      	ldr	r6, [pc, #112]	; (800e4f8 <atcm_modem_init+0x78>)
 800e486:	4c1d      	ldr	r4, [pc, #116]	; (800e4fc <atcm_modem_init+0x7c>)
 800e488:	f106 0e20 	add.w	lr, r6, #32
 800e48c:	46b4      	mov	ip, r6
 800e48e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800e492:	6020      	str	r0, [r4, #0]
 800e494:	6061      	str	r1, [r4, #4]
 800e496:	60a2      	str	r2, [r4, #8]
 800e498:	60e3      	str	r3, [r4, #12]
 800e49a:	4666      	mov	r6, ip
 800e49c:	3410      	adds	r4, #16
 800e49e:	45f4      	cmp	ip, lr
 800e4a0:	d1f4      	bne.n	800e48c <atcm_modem_init+0xc>
 800e4a2:	f8dc 0000 	ldr.w	r0, [ip]
 800e4a6:	6020      	str	r0, [r4, #0]
 800e4a8:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800e4ac:	7123      	strb	r3, [r4, #4]
 800e4ae:	4c13      	ldr	r4, [pc, #76]	; (800e4fc <atcm_modem_init+0x7c>)
 800e4b0:	4620      	mov	r0, r4
 800e4b2:	f010 fe2e 	bl	801f112 <crs_strlen>
 800e4b6:	b283      	uxth	r3, r0
 800e4b8:	4622      	mov	r2, r4
 800e4ba:	2104      	movs	r1, #4
 800e4bc:	2002      	movs	r0, #2
 800e4be:	f010 fe6b 	bl	801f198 <traceIF_itmPrint>
 800e4c2:	4620      	mov	r0, r4
 800e4c4:	f010 fe25 	bl	801f112 <crs_strlen>
 800e4c8:	b283      	uxth	r3, r0
 800e4ca:	4622      	mov	r2, r4
 800e4cc:	2104      	movs	r1, #4
 800e4ce:	2002      	movs	r0, #2
 800e4d0:	f010 fe84 	bl	801f1dc <traceIF_uartPrint>
  atcm_reset_persistent_context(&p_modem_ctxt->persist);
 800e4d4:	f105 000c 	add.w	r0, r5, #12
 800e4d8:	f7ff ff08 	bl	800e2ec <atcm_reset_persistent_context>
  atcm_reset_SID_context(&p_modem_ctxt->SID_ctxt);
 800e4dc:	f505 60b6 	add.w	r0, r5, #1456	; 0x5b0
 800e4e0:	f7fe fe84 	bl	800d1ec <atcm_reset_SID_context>
  atcm_reset_CMD_context(&p_modem_ctxt->CMD_ctxt);
 800e4e4:	f205 702c 	addw	r0, r5, #1836	; 0x72c
 800e4e8:	f7fe fef8 	bl	800d2dc <atcm_reset_CMD_context>
  atcm_reset_SOCKET_context(p_modem_ctxt);
 800e4ec:	4628      	mov	r0, r5
 800e4ee:	f7fe ff31 	bl	800d354 <atcm_reset_SOCKET_context>
  p_modem_ctxt->state_SyntaxAutomaton = WAITING_FOR_INIT_CR;
 800e4f2:	2300      	movs	r3, #0
 800e4f4:	722b      	strb	r3, [r5, #8]
}
 800e4f6:	bd70      	pop	{r4, r5, r6, pc}
 800e4f8:	0802e24c 	.word	0x0802e24c
 800e4fc:	200048dc 	.word	0x200048dc

0800e500 <atcm_modem_reset>:
{
 800e500:	b570      	push	{r4, r5, r6, lr}
 800e502:	4606      	mov	r6, r0
  PRINT_API("enter atcm_modem_reset")
 800e504:	4d1a      	ldr	r5, [pc, #104]	; (800e570 <atcm_modem_reset+0x70>)
 800e506:	4c1b      	ldr	r4, [pc, #108]	; (800e574 <atcm_modem_reset+0x74>)
 800e508:	f105 0e20 	add.w	lr, r5, #32
 800e50c:	46ac      	mov	ip, r5
 800e50e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800e512:	6020      	str	r0, [r4, #0]
 800e514:	6061      	str	r1, [r4, #4]
 800e516:	60a2      	str	r2, [r4, #8]
 800e518:	60e3      	str	r3, [r4, #12]
 800e51a:	4665      	mov	r5, ip
 800e51c:	3410      	adds	r4, #16
 800e51e:	45f4      	cmp	ip, lr
 800e520:	d1f4      	bne.n	800e50c <atcm_modem_reset+0xc>
 800e522:	f8dc 0000 	ldr.w	r0, [ip]
 800e526:	6020      	str	r0, [r4, #0]
 800e528:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800e52c:	80a3      	strh	r3, [r4, #4]
 800e52e:	4c11      	ldr	r4, [pc, #68]	; (800e574 <atcm_modem_reset+0x74>)
 800e530:	4620      	mov	r0, r4
 800e532:	f010 fdee 	bl	801f112 <crs_strlen>
 800e536:	b283      	uxth	r3, r0
 800e538:	4622      	mov	r2, r4
 800e53a:	2104      	movs	r1, #4
 800e53c:	2002      	movs	r0, #2
 800e53e:	f010 fe2b 	bl	801f198 <traceIF_itmPrint>
 800e542:	4620      	mov	r0, r4
 800e544:	f010 fde5 	bl	801f112 <crs_strlen>
 800e548:	b283      	uxth	r3, r0
 800e54a:	4622      	mov	r2, r4
 800e54c:	2104      	movs	r1, #4
 800e54e:	2002      	movs	r0, #2
 800e550:	f010 fe44 	bl	801f1dc <traceIF_uartPrint>
  atcm_reset_persistent_context(&p_modem_ctxt->persist);
 800e554:	f106 000c 	add.w	r0, r6, #12
 800e558:	f7ff fec8 	bl	800e2ec <atcm_reset_persistent_context>
  atcm_reset_CMD_context(&p_modem_ctxt->CMD_ctxt);
 800e55c:	f206 702c 	addw	r0, r6, #1836	; 0x72c
 800e560:	f7fe febc 	bl	800d2dc <atcm_reset_CMD_context>
  atcm_reset_SOCKET_context(p_modem_ctxt);
 800e564:	4630      	mov	r0, r6
 800e566:	f7fe fef5 	bl	800d354 <atcm_reset_SOCKET_context>
  p_modem_ctxt->state_SyntaxAutomaton = WAITING_FOR_INIT_CR;
 800e56a:	2300      	movs	r3, #0
 800e56c:	7233      	strb	r3, [r6, #8]
}
 800e56e:	bd70      	pop	{r4, r5, r6, pc}
 800e570:	0802e274 	.word	0x0802e274
 800e574:	200048dc 	.word	0x200048dc

0800e578 <set_error_report>:
/*
 * Update error report that will be sent to Cellular Service
 */
static void set_error_report(csint_error_type_t err_type, atcustom_modem_context_t *p_modem_ctxt)
{
  p_modem_ctxt->SID_ctxt.error_report.error_type = err_type;
 800e578:	f881 072a 	strb.w	r0, [r1, #1834]	; 0x72a

  switch (err_type)
 800e57c:	2801      	cmp	r0, #1
 800e57e:	d000      	beq.n	800e582 <set_error_report+0xa>

    default:
      /* nothing to do*/
      break;
  }
}
 800e580:	4770      	bx	lr
      p_modem_ctxt->SID_ctxt.error_report.sim_state = p_modem_ctxt->persist.sim_state;
 800e582:	f891 3511 	ldrb.w	r3, [r1, #1297]	; 0x511
 800e586:	f881 372b 	strb.w	r3, [r1, #1835]	; 0x72b
}
 800e58a:	e7f9      	b.n	800e580 <set_error_report+0x8>

0800e58c <display_clear_network_state>:
{
 800e58c:	b538      	push	{r3, r4, r5, lr}
  if (network_type <= EPS_NETWORK_TYPE)
 800e58e:	2903      	cmp	r1, #3
 800e590:	f200 815b 	bhi.w	800e84a <display_clear_network_state+0x2be>
    switch (state)
 800e594:	280a      	cmp	r0, #10
 800e596:	f200 8136 	bhi.w	800e806 <display_clear_network_state+0x27a>
 800e59a:	e8df f010 	tbh	[pc, r0, lsl #1]
 800e59e:	000b      	.short	0x000b
 800e5a0:	00410026 	.word	0x00410026
 800e5a4:	0077005c 	.word	0x0077005c
 800e5a8:	00ad0092 	.word	0x00ad0092
 800e5ac:	00e300c8 	.word	0x00e300c8
 800e5b0:	011900fe 	.word	0x011900fe
        PRINT_INFO("NetworkState %s = NOT_REGISTERED_NOT_SEARCHING", NETWORK_TYPE_LUT[network_type])
 800e5b4:	4cb1      	ldr	r4, [pc, #708]	; (800e87c <display_clear_network_state+0x2f0>)
 800e5b6:	4ab2      	ldr	r2, [pc, #712]	; (800e880 <display_clear_network_state+0x2f4>)
 800e5b8:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e5bc:	49b1      	ldr	r1, [pc, #708]	; (800e884 <display_clear_network_state+0x2f8>)
 800e5be:	4620      	mov	r0, r4
 800e5c0:	f017 fb56 	bl	8025c70 <sprintf>
 800e5c4:	4620      	mov	r0, r4
 800e5c6:	f010 fda4 	bl	801f112 <crs_strlen>
 800e5ca:	b283      	uxth	r3, r0
 800e5cc:	4622      	mov	r2, r4
 800e5ce:	2101      	movs	r1, #1
 800e5d0:	2002      	movs	r0, #2
 800e5d2:	f010 fde1 	bl	801f198 <traceIF_itmPrint>
 800e5d6:	4620      	mov	r0, r4
 800e5d8:	f010 fd9b 	bl	801f112 <crs_strlen>
 800e5dc:	b283      	uxth	r3, r0
 800e5de:	4622      	mov	r2, r4
 800e5e0:	2101      	movs	r1, #1
 800e5e2:	2002      	movs	r0, #2
 800e5e4:	f010 fdfa 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e5e8:	e147      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_HOME_NETWORK", NETWORK_TYPE_LUT[network_type])
 800e5ea:	4ca4      	ldr	r4, [pc, #656]	; (800e87c <display_clear_network_state+0x2f0>)
 800e5ec:	4aa4      	ldr	r2, [pc, #656]	; (800e880 <display_clear_network_state+0x2f4>)
 800e5ee:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e5f2:	49a5      	ldr	r1, [pc, #660]	; (800e888 <display_clear_network_state+0x2fc>)
 800e5f4:	4620      	mov	r0, r4
 800e5f6:	f017 fb3b 	bl	8025c70 <sprintf>
 800e5fa:	4620      	mov	r0, r4
 800e5fc:	f010 fd89 	bl	801f112 <crs_strlen>
 800e600:	b283      	uxth	r3, r0
 800e602:	4622      	mov	r2, r4
 800e604:	2101      	movs	r1, #1
 800e606:	2002      	movs	r0, #2
 800e608:	f010 fdc6 	bl	801f198 <traceIF_itmPrint>
 800e60c:	4620      	mov	r0, r4
 800e60e:	f010 fd80 	bl	801f112 <crs_strlen>
 800e612:	b283      	uxth	r3, r0
 800e614:	4622      	mov	r2, r4
 800e616:	2101      	movs	r1, #1
 800e618:	2002      	movs	r0, #2
 800e61a:	f010 fddf 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e61e:	e12c      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = NOT_REGISTERED_SEARCHING", NETWORK_TYPE_LUT[network_type])
 800e620:	4c96      	ldr	r4, [pc, #600]	; (800e87c <display_clear_network_state+0x2f0>)
 800e622:	4a97      	ldr	r2, [pc, #604]	; (800e880 <display_clear_network_state+0x2f4>)
 800e624:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e628:	4998      	ldr	r1, [pc, #608]	; (800e88c <display_clear_network_state+0x300>)
 800e62a:	4620      	mov	r0, r4
 800e62c:	f017 fb20 	bl	8025c70 <sprintf>
 800e630:	4620      	mov	r0, r4
 800e632:	f010 fd6e 	bl	801f112 <crs_strlen>
 800e636:	b283      	uxth	r3, r0
 800e638:	4622      	mov	r2, r4
 800e63a:	2101      	movs	r1, #1
 800e63c:	2002      	movs	r0, #2
 800e63e:	f010 fdab 	bl	801f198 <traceIF_itmPrint>
 800e642:	4620      	mov	r0, r4
 800e644:	f010 fd65 	bl	801f112 <crs_strlen>
 800e648:	b283      	uxth	r3, r0
 800e64a:	4622      	mov	r2, r4
 800e64c:	2101      	movs	r1, #1
 800e64e:	2002      	movs	r0, #2
 800e650:	f010 fdc4 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e654:	e111      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTRATION_DENIED", NETWORK_TYPE_LUT[network_type])
 800e656:	4c89      	ldr	r4, [pc, #548]	; (800e87c <display_clear_network_state+0x2f0>)
 800e658:	4a89      	ldr	r2, [pc, #548]	; (800e880 <display_clear_network_state+0x2f4>)
 800e65a:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e65e:	498c      	ldr	r1, [pc, #560]	; (800e890 <display_clear_network_state+0x304>)
 800e660:	4620      	mov	r0, r4
 800e662:	f017 fb05 	bl	8025c70 <sprintf>
 800e666:	4620      	mov	r0, r4
 800e668:	f010 fd53 	bl	801f112 <crs_strlen>
 800e66c:	b283      	uxth	r3, r0
 800e66e:	4622      	mov	r2, r4
 800e670:	2101      	movs	r1, #1
 800e672:	2002      	movs	r0, #2
 800e674:	f010 fd90 	bl	801f198 <traceIF_itmPrint>
 800e678:	4620      	mov	r0, r4
 800e67a:	f010 fd4a 	bl	801f112 <crs_strlen>
 800e67e:	b283      	uxth	r3, r0
 800e680:	4622      	mov	r2, r4
 800e682:	2101      	movs	r1, #1
 800e684:	2002      	movs	r0, #2
 800e686:	f010 fda9 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e68a:	e0f6      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = UNKNOWN", NETWORK_TYPE_LUT[network_type])
 800e68c:	4c7b      	ldr	r4, [pc, #492]	; (800e87c <display_clear_network_state+0x2f0>)
 800e68e:	4a7c      	ldr	r2, [pc, #496]	; (800e880 <display_clear_network_state+0x2f4>)
 800e690:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e694:	497f      	ldr	r1, [pc, #508]	; (800e894 <display_clear_network_state+0x308>)
 800e696:	4620      	mov	r0, r4
 800e698:	f017 faea 	bl	8025c70 <sprintf>
 800e69c:	4620      	mov	r0, r4
 800e69e:	f010 fd38 	bl	801f112 <crs_strlen>
 800e6a2:	b283      	uxth	r3, r0
 800e6a4:	4622      	mov	r2, r4
 800e6a6:	2101      	movs	r1, #1
 800e6a8:	2002      	movs	r0, #2
 800e6aa:	f010 fd75 	bl	801f198 <traceIF_itmPrint>
 800e6ae:	4620      	mov	r0, r4
 800e6b0:	f010 fd2f 	bl	801f112 <crs_strlen>
 800e6b4:	b283      	uxth	r3, r0
 800e6b6:	4622      	mov	r2, r4
 800e6b8:	2101      	movs	r1, #1
 800e6ba:	2002      	movs	r0, #2
 800e6bc:	f010 fd8e 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e6c0:	e0db      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_ROAMING", NETWORK_TYPE_LUT[network_type])
 800e6c2:	4c6e      	ldr	r4, [pc, #440]	; (800e87c <display_clear_network_state+0x2f0>)
 800e6c4:	4a6e      	ldr	r2, [pc, #440]	; (800e880 <display_clear_network_state+0x2f4>)
 800e6c6:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e6ca:	4973      	ldr	r1, [pc, #460]	; (800e898 <display_clear_network_state+0x30c>)
 800e6cc:	4620      	mov	r0, r4
 800e6ce:	f017 facf 	bl	8025c70 <sprintf>
 800e6d2:	4620      	mov	r0, r4
 800e6d4:	f010 fd1d 	bl	801f112 <crs_strlen>
 800e6d8:	b283      	uxth	r3, r0
 800e6da:	4622      	mov	r2, r4
 800e6dc:	2101      	movs	r1, #1
 800e6de:	2002      	movs	r0, #2
 800e6e0:	f010 fd5a 	bl	801f198 <traceIF_itmPrint>
 800e6e4:	4620      	mov	r0, r4
 800e6e6:	f010 fd14 	bl	801f112 <crs_strlen>
 800e6ea:	b283      	uxth	r3, r0
 800e6ec:	4622      	mov	r2, r4
 800e6ee:	2101      	movs	r1, #1
 800e6f0:	2002      	movs	r0, #2
 800e6f2:	f010 fd73 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e6f6:	e0c0      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_SMS_ONLY_HOME_NETWORK", NETWORK_TYPE_LUT[network_type])
 800e6f8:	4c60      	ldr	r4, [pc, #384]	; (800e87c <display_clear_network_state+0x2f0>)
 800e6fa:	4a61      	ldr	r2, [pc, #388]	; (800e880 <display_clear_network_state+0x2f4>)
 800e6fc:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e700:	4966      	ldr	r1, [pc, #408]	; (800e89c <display_clear_network_state+0x310>)
 800e702:	4620      	mov	r0, r4
 800e704:	f017 fab4 	bl	8025c70 <sprintf>
 800e708:	4620      	mov	r0, r4
 800e70a:	f010 fd02 	bl	801f112 <crs_strlen>
 800e70e:	b283      	uxth	r3, r0
 800e710:	4622      	mov	r2, r4
 800e712:	2101      	movs	r1, #1
 800e714:	2002      	movs	r0, #2
 800e716:	f010 fd3f 	bl	801f198 <traceIF_itmPrint>
 800e71a:	4620      	mov	r0, r4
 800e71c:	f010 fcf9 	bl	801f112 <crs_strlen>
 800e720:	b283      	uxth	r3, r0
 800e722:	4622      	mov	r2, r4
 800e724:	2101      	movs	r1, #1
 800e726:	2002      	movs	r0, #2
 800e728:	f010 fd58 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e72c:	e0a5      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_SMS_ONLY_ROAMING", NETWORK_TYPE_LUT[network_type])
 800e72e:	4c53      	ldr	r4, [pc, #332]	; (800e87c <display_clear_network_state+0x2f0>)
 800e730:	4a53      	ldr	r2, [pc, #332]	; (800e880 <display_clear_network_state+0x2f4>)
 800e732:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e736:	495a      	ldr	r1, [pc, #360]	; (800e8a0 <display_clear_network_state+0x314>)
 800e738:	4620      	mov	r0, r4
 800e73a:	f017 fa99 	bl	8025c70 <sprintf>
 800e73e:	4620      	mov	r0, r4
 800e740:	f010 fce7 	bl	801f112 <crs_strlen>
 800e744:	b283      	uxth	r3, r0
 800e746:	4622      	mov	r2, r4
 800e748:	2101      	movs	r1, #1
 800e74a:	2002      	movs	r0, #2
 800e74c:	f010 fd24 	bl	801f198 <traceIF_itmPrint>
 800e750:	4620      	mov	r0, r4
 800e752:	f010 fcde 	bl	801f112 <crs_strlen>
 800e756:	b283      	uxth	r3, r0
 800e758:	4622      	mov	r2, r4
 800e75a:	2101      	movs	r1, #1
 800e75c:	2002      	movs	r0, #2
 800e75e:	f010 fd3d 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e762:	e08a      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = EMERGENCY_ONLY", NETWORK_TYPE_LUT[network_type])
 800e764:	4c45      	ldr	r4, [pc, #276]	; (800e87c <display_clear_network_state+0x2f0>)
 800e766:	4a46      	ldr	r2, [pc, #280]	; (800e880 <display_clear_network_state+0x2f4>)
 800e768:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e76c:	494d      	ldr	r1, [pc, #308]	; (800e8a4 <display_clear_network_state+0x318>)
 800e76e:	4620      	mov	r0, r4
 800e770:	f017 fa7e 	bl	8025c70 <sprintf>
 800e774:	4620      	mov	r0, r4
 800e776:	f010 fccc 	bl	801f112 <crs_strlen>
 800e77a:	b283      	uxth	r3, r0
 800e77c:	4622      	mov	r2, r4
 800e77e:	2101      	movs	r1, #1
 800e780:	2002      	movs	r0, #2
 800e782:	f010 fd09 	bl	801f198 <traceIF_itmPrint>
 800e786:	4620      	mov	r0, r4
 800e788:	f010 fcc3 	bl	801f112 <crs_strlen>
 800e78c:	b283      	uxth	r3, r0
 800e78e:	4622      	mov	r2, r4
 800e790:	2101      	movs	r1, #1
 800e792:	2002      	movs	r0, #2
 800e794:	f010 fd22 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e798:	e06f      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_CFSB_NP_HOME_NETWORK", NETWORK_TYPE_LUT[network_type])
 800e79a:	4c38      	ldr	r4, [pc, #224]	; (800e87c <display_clear_network_state+0x2f0>)
 800e79c:	4a38      	ldr	r2, [pc, #224]	; (800e880 <display_clear_network_state+0x2f4>)
 800e79e:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e7a2:	4941      	ldr	r1, [pc, #260]	; (800e8a8 <display_clear_network_state+0x31c>)
 800e7a4:	4620      	mov	r0, r4
 800e7a6:	f017 fa63 	bl	8025c70 <sprintf>
 800e7aa:	4620      	mov	r0, r4
 800e7ac:	f010 fcb1 	bl	801f112 <crs_strlen>
 800e7b0:	b283      	uxth	r3, r0
 800e7b2:	4622      	mov	r2, r4
 800e7b4:	2101      	movs	r1, #1
 800e7b6:	2002      	movs	r0, #2
 800e7b8:	f010 fcee 	bl	801f198 <traceIF_itmPrint>
 800e7bc:	4620      	mov	r0, r4
 800e7be:	f010 fca8 	bl	801f112 <crs_strlen>
 800e7c2:	b283      	uxth	r3, r0
 800e7c4:	4622      	mov	r2, r4
 800e7c6:	2101      	movs	r1, #1
 800e7c8:	2002      	movs	r0, #2
 800e7ca:	f010 fd07 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e7ce:	e054      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_CFSB_NP_ROAMING", NETWORK_TYPE_LUT[network_type])
 800e7d0:	4c2a      	ldr	r4, [pc, #168]	; (800e87c <display_clear_network_state+0x2f0>)
 800e7d2:	4a2b      	ldr	r2, [pc, #172]	; (800e880 <display_clear_network_state+0x2f4>)
 800e7d4:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e7d8:	4934      	ldr	r1, [pc, #208]	; (800e8ac <display_clear_network_state+0x320>)
 800e7da:	4620      	mov	r0, r4
 800e7dc:	f017 fa48 	bl	8025c70 <sprintf>
 800e7e0:	4620      	mov	r0, r4
 800e7e2:	f010 fc96 	bl	801f112 <crs_strlen>
 800e7e6:	b283      	uxth	r3, r0
 800e7e8:	4622      	mov	r2, r4
 800e7ea:	2101      	movs	r1, #1
 800e7ec:	2002      	movs	r0, #2
 800e7ee:	f010 fcd3 	bl	801f198 <traceIF_itmPrint>
 800e7f2:	4620      	mov	r0, r4
 800e7f4:	f010 fc8d 	bl	801f112 <crs_strlen>
 800e7f8:	b283      	uxth	r3, r0
 800e7fa:	4622      	mov	r2, r4
 800e7fc:	2101      	movs	r1, #1
 800e7fe:	2002      	movs	r0, #2
 800e800:	f010 fcec 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e804:	e039      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("unknown state value")
 800e806:	4c1d      	ldr	r4, [pc, #116]	; (800e87c <display_clear_network_state+0x2f0>)
 800e808:	4d29      	ldr	r5, [pc, #164]	; (800e8b0 <display_clear_network_state+0x324>)
 800e80a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e80c:	6020      	str	r0, [r4, #0]
 800e80e:	6061      	str	r1, [r4, #4]
 800e810:	60a2      	str	r2, [r4, #8]
 800e812:	60e3      	str	r3, [r4, #12]
 800e814:	cd07      	ldmia	r5!, {r0, r1, r2}
 800e816:	6120      	str	r0, [r4, #16]
 800e818:	6161      	str	r1, [r4, #20]
 800e81a:	61a2      	str	r2, [r4, #24]
 800e81c:	882a      	ldrh	r2, [r5, #0]
 800e81e:	78ab      	ldrb	r3, [r5, #2]
 800e820:	83a2      	strh	r2, [r4, #28]
 800e822:	77a3      	strb	r3, [r4, #30]
 800e824:	4620      	mov	r0, r4
 800e826:	f010 fc74 	bl	801f112 <crs_strlen>
 800e82a:	b283      	uxth	r3, r0
 800e82c:	4622      	mov	r2, r4
 800e82e:	2101      	movs	r1, #1
 800e830:	2002      	movs	r0, #2
 800e832:	f010 fcb1 	bl	801f198 <traceIF_itmPrint>
 800e836:	4620      	mov	r0, r4
 800e838:	f010 fc6b 	bl	801f112 <crs_strlen>
 800e83c:	b283      	uxth	r3, r0
 800e83e:	4622      	mov	r2, r4
 800e840:	2101      	movs	r1, #1
 800e842:	2002      	movs	r0, #2
 800e844:	f010 fcca 	bl	801f1dc <traceIF_uartPrint>
        break;
 800e848:	e017      	b.n	800e87a <display_clear_network_state+0x2ee>
    PRINT_ERR("Invalid network type %d", network_type)
 800e84a:	4c0c      	ldr	r4, [pc, #48]	; (800e87c <display_clear_network_state+0x2f0>)
 800e84c:	460a      	mov	r2, r1
 800e84e:	4919      	ldr	r1, [pc, #100]	; (800e8b4 <display_clear_network_state+0x328>)
 800e850:	4620      	mov	r0, r4
 800e852:	f017 fa0d 	bl	8025c70 <sprintf>
 800e856:	4620      	mov	r0, r4
 800e858:	f010 fc5b 	bl	801f112 <crs_strlen>
 800e85c:	b283      	uxth	r3, r0
 800e85e:	4622      	mov	r2, r4
 800e860:	2110      	movs	r1, #16
 800e862:	2002      	movs	r0, #2
 800e864:	f010 fc98 	bl	801f198 <traceIF_itmPrint>
 800e868:	4620      	mov	r0, r4
 800e86a:	f010 fc52 	bl	801f112 <crs_strlen>
 800e86e:	b283      	uxth	r3, r0
 800e870:	4622      	mov	r2, r4
 800e872:	2110      	movs	r1, #16
 800e874:	2002      	movs	r0, #2
 800e876:	f010 fcb1 	bl	801f1dc <traceIF_uartPrint>
}
 800e87a:	bd38      	pop	{r3, r4, r5, pc}
 800e87c:	200048dc 	.word	0x200048dc
 800e880:	08030778 	.word	0x08030778
 800e884:	0802e2e0 	.word	0x0802e2e0
 800e888:	0802e31c 	.word	0x0802e31c
 800e88c:	0802e354 	.word	0x0802e354
 800e890:	0802e38c 	.word	0x0802e38c
 800e894:	0802e3c0 	.word	0x0802e3c0
 800e898:	0802e3e8 	.word	0x0802e3e8
 800e89c:	0802e418 	.word	0x0802e418
 800e8a0:	0802e458 	.word	0x0802e458
 800e8a4:	0802e494 	.word	0x0802e494
 800e8a8:	0802e4c0 	.word	0x0802e4c0
 800e8ac:	0802e500 	.word	0x0802e500
 800e8b0:	0802e538 	.word	0x0802e538
 800e8b4:	0802e558 	.word	0x0802e558

0800e8b8 <convert_NetworkState>:
{
 800e8b8:	b510      	push	{r4, lr}
  switch (state)
 800e8ba:	280a      	cmp	r0, #10
 800e8bc:	d81f      	bhi.n	800e8fe <convert_NetworkState+0x46>
 800e8be:	e8df f000 	tbb	[pc, r0]
 800e8c2:	2006      	.short	0x2006
 800e8c4:	12100e0c 	.word	0x12100e0c
 800e8c8:	1a181614 	.word	0x1a181614
 800e8cc:	1c          	.byte	0x1c
 800e8cd:	00          	.byte	0x00
 800e8ce:	2400      	movs	r4, #0
  display_clear_network_state(retval, network_type);
 800e8d0:	4620      	mov	r0, r4
 800e8d2:	f7ff fe5b 	bl	800e58c <display_clear_network_state>
}
 800e8d6:	4620      	mov	r0, r4
 800e8d8:	bd10      	pop	{r4, pc}
      retval = CS_NRS_NOT_REGISTERED_SEARCHING;
 800e8da:	2402      	movs	r4, #2
      break;
 800e8dc:	e7f8      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTRATION_DENIED;
 800e8de:	2403      	movs	r4, #3
      break;
 800e8e0:	e7f6      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_UNKNOWN;
 800e8e2:	2404      	movs	r4, #4
      break;
 800e8e4:	e7f4      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_ROAMING;
 800e8e6:	2405      	movs	r4, #5
      break;
 800e8e8:	e7f2      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_SMS_ONLY_HOME_NETWORK;
 800e8ea:	2406      	movs	r4, #6
      break;
 800e8ec:	e7f0      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_SMS_ONLY_ROAMING;
 800e8ee:	2407      	movs	r4, #7
      break;
 800e8f0:	e7ee      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_EMERGENCY_ONLY;
 800e8f2:	2408      	movs	r4, #8
      break;
 800e8f4:	e7ec      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_CFSB_NP_HOME_NETWORK;
 800e8f6:	2409      	movs	r4, #9
      break;
 800e8f8:	e7ea      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_CFSB_NP_ROAMING;
 800e8fa:	240a      	movs	r4, #10
      break;
 800e8fc:	e7e8      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_UNKNOWN;
 800e8fe:	2404      	movs	r4, #4
      break;
 800e900:	e7e6      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_HOME_NETWORK;
 800e902:	2401      	movs	r4, #1
 800e904:	e7e4      	b.n	800e8d0 <convert_NetworkState+0x18>
	...

0800e908 <analyze_CmeError>:
{
 800e908:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e90c:	b088      	sub	sp, #32
 800e90e:	4680      	mov	r8, r0
 800e910:	4689      	mov	r9, r1
 800e912:	4617      	mov	r7, r2
 800e914:	461e      	mov	r6, r3
  PRINT_API("enter analyze_CmeError_CPIN()")
 800e916:	4ca9      	ldr	r4, [pc, #676]	; (800ebbc <analyze_CmeError+0x2b4>)
 800e918:	4da9      	ldr	r5, [pc, #676]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e91a:	f104 0e20 	add.w	lr, r4, #32
 800e91e:	46a4      	mov	ip, r4
 800e920:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800e924:	6028      	str	r0, [r5, #0]
 800e926:	6069      	str	r1, [r5, #4]
 800e928:	60aa      	str	r2, [r5, #8]
 800e92a:	60eb      	str	r3, [r5, #12]
 800e92c:	4664      	mov	r4, ip
 800e92e:	3510      	adds	r5, #16
 800e930:	45f4      	cmp	ip, lr
 800e932:	d1f4      	bne.n	800e91e <analyze_CmeError+0x16>
 800e934:	cc07      	ldmia	r4!, {r0, r1, r2}
 800e936:	6028      	str	r0, [r5, #0]
 800e938:	6069      	str	r1, [r5, #4]
 800e93a:	60aa      	str	r2, [r5, #8]
 800e93c:	7823      	ldrb	r3, [r4, #0]
 800e93e:	732b      	strb	r3, [r5, #12]
 800e940:	4c9f      	ldr	r4, [pc, #636]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e942:	4620      	mov	r0, r4
 800e944:	f010 fbe5 	bl	801f112 <crs_strlen>
 800e948:	b283      	uxth	r3, r0
 800e94a:	4622      	mov	r2, r4
 800e94c:	2104      	movs	r1, #4
 800e94e:	2002      	movs	r0, #2
 800e950:	f010 fc22 	bl	801f198 <traceIF_itmPrint>
 800e954:	4620      	mov	r0, r4
 800e956:	f010 fbdc 	bl	801f112 <crs_strlen>
 800e95a:	b283      	uxth	r3, r0
 800e95c:	4622      	mov	r2, r4
 800e95e:	2104      	movs	r1, #4
 800e960:	2002      	movs	r0, #2
 800e962:	f010 fc3b 	bl	801f1dc <traceIF_uartPrint>
  START_PARAM_LOOP()
 800e966:	2400      	movs	r4, #0
 800e968:	4632      	mov	r2, r6
 800e96a:	4639      	mov	r1, r7
 800e96c:	4640      	mov	r0, r8
 800e96e:	f7fd fd6b 	bl	800c448 <atcc_extractElement>
 800e972:	2801      	cmp	r0, #1
 800e974:	d000      	beq.n	800e978 <analyze_CmeError+0x70>
 800e976:	2401      	movs	r4, #1
 800e978:	89f3      	ldrh	r3, [r6, #14]
 800e97a:	b113      	cbz	r3, 800e982 <analyze_CmeError+0x7a>
  if (element_infos->param_rank == 2U)
 800e97c:	8933      	ldrh	r3, [r6, #8]
 800e97e:	2b02      	cmp	r3, #2
 800e980:	d005      	beq.n	800e98e <analyze_CmeError+0x86>
  END_PARAM_LOOP()
 800e982:	2c00      	cmp	r4, #0
 800e984:	d0f0      	beq.n	800e968 <analyze_CmeError+0x60>
}
 800e986:	2010      	movs	r0, #16
 800e988:	b008      	add	sp, #32
 800e98a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    AT_CHAR_t line[32] = {0U};
 800e98e:	2300      	movs	r3, #0
 800e990:	9300      	str	r3, [sp, #0]
 800e992:	9301      	str	r3, [sp, #4]
 800e994:	9302      	str	r3, [sp, #8]
 800e996:	9303      	str	r3, [sp, #12]
 800e998:	9304      	str	r3, [sp, #16]
 800e99a:	9305      	str	r3, [sp, #20]
 800e99c:	9306      	str	r3, [sp, #24]
 800e99e:	9307      	str	r3, [sp, #28]
    PRINT_DBG("CME ERROR parameter received:")
 800e9a0:	f8df c248 	ldr.w	ip, [pc, #584]	; 800ebec <analyze_CmeError+0x2e4>
 800e9a4:	4d86      	ldr	r5, [pc, #536]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e9a6:	f10c 0a20 	add.w	sl, ip, #32
 800e9aa:	46e6      	mov	lr, ip
 800e9ac:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800e9b0:	6028      	str	r0, [r5, #0]
 800e9b2:	6069      	str	r1, [r5, #4]
 800e9b4:	60aa      	str	r2, [r5, #8]
 800e9b6:	60eb      	str	r3, [r5, #12]
 800e9b8:	46f4      	mov	ip, lr
 800e9ba:	3510      	adds	r5, #16
 800e9bc:	45d6      	cmp	lr, sl
 800e9be:	d1f4      	bne.n	800e9aa <analyze_CmeError+0xa2>
 800e9c0:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 800e9c4:	6028      	str	r0, [r5, #0]
 800e9c6:	6069      	str	r1, [r5, #4]
 800e9c8:	f89c 3000 	ldrb.w	r3, [ip]
 800e9cc:	722b      	strb	r3, [r5, #8]
 800e9ce:	4d7c      	ldr	r5, [pc, #496]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e9d0:	4628      	mov	r0, r5
 800e9d2:	f010 fb9e 	bl	801f112 <crs_strlen>
 800e9d6:	b283      	uxth	r3, r0
 800e9d8:	462a      	mov	r2, r5
 800e9da:	2102      	movs	r1, #2
 800e9dc:	4608      	mov	r0, r1
 800e9de:	f010 fbdb 	bl	801f198 <traceIF_itmPrint>
 800e9e2:	4628      	mov	r0, r5
 800e9e4:	f010 fb95 	bl	801f112 <crs_strlen>
 800e9e8:	b283      	uxth	r3, r0
 800e9ea:	462a      	mov	r2, r5
 800e9ec:	2102      	movs	r1, #2
 800e9ee:	4608      	mov	r0, r1
 800e9f0:	f010 fbf4 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 800e9f4:	8972      	ldrh	r2, [r6, #10]
 800e9f6:	89f3      	ldrh	r3, [r6, #14]
 800e9f8:	443a      	add	r2, r7
 800e9fa:	2102      	movs	r1, #2
 800e9fc:	4608      	mov	r0, r1
 800e9fe:	f010 feb9 	bl	801f774 <traceIF_BufCharPrint>
    if (element_infos->str_size <= 32U)
 800ea02:	89f2      	ldrh	r2, [r6, #14]
 800ea04:	2a20      	cmp	r2, #32
 800ea06:	d805      	bhi.n	800ea14 <analyze_CmeError+0x10c>
                    (const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 800ea08:	8971      	ldrh	r1, [r6, #10]
      (void) memcpy((void *)&line[0],
 800ea0a:	4439      	add	r1, r7
 800ea0c:	4668      	mov	r0, sp
 800ea0e:	f017 fa7f 	bl	8025f10 <memcpy>
 800ea12:	e02c      	b.n	800ea6e <analyze_CmeError+0x166>
      PRINT_ERR("line exceed maximum size, line ignored...")
 800ea14:	f8df c1d8 	ldr.w	ip, [pc, #472]	; 800ebf0 <analyze_CmeError+0x2e8>
 800ea18:	4d69      	ldr	r5, [pc, #420]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800ea1a:	f10c 0a30 	add.w	sl, ip, #48	; 0x30
 800ea1e:	46e6      	mov	lr, ip
 800ea20:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800ea24:	6028      	str	r0, [r5, #0]
 800ea26:	6069      	str	r1, [r5, #4]
 800ea28:	60aa      	str	r2, [r5, #8]
 800ea2a:	60eb      	str	r3, [r5, #12]
 800ea2c:	46f4      	mov	ip, lr
 800ea2e:	3510      	adds	r5, #16
 800ea30:	45d6      	cmp	lr, sl
 800ea32:	d1f4      	bne.n	800ea1e <analyze_CmeError+0x116>
 800ea34:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 800ea38:	6028      	str	r0, [r5, #0]
 800ea3a:	6069      	str	r1, [r5, #4]
 800ea3c:	f8bc 2000 	ldrh.w	r2, [ip]
 800ea40:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800ea44:	812a      	strh	r2, [r5, #8]
 800ea46:	72ab      	strb	r3, [r5, #10]
 800ea48:	4d5d      	ldr	r5, [pc, #372]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800ea4a:	4628      	mov	r0, r5
 800ea4c:	f010 fb61 	bl	801f112 <crs_strlen>
 800ea50:	b283      	uxth	r3, r0
 800ea52:	462a      	mov	r2, r5
 800ea54:	2110      	movs	r1, #16
 800ea56:	2002      	movs	r0, #2
 800ea58:	f010 fb9e 	bl	801f198 <traceIF_itmPrint>
 800ea5c:	4628      	mov	r0, r5
 800ea5e:	f010 fb58 	bl	801f112 <crs_strlen>
 800ea62:	b283      	uxth	r3, r0
 800ea64:	462a      	mov	r2, r5
 800ea66:	2110      	movs	r1, #16
 800ea68:	2002      	movs	r0, #2
 800ea6a:	f010 fbb7 	bl	801f1dc <traceIF_uartPrint>
    ATutil_convertStringToUpperCase(&line[0], 32U);
 800ea6e:	2120      	movs	r1, #32
 800ea70:	4668      	mov	r0, sp
 800ea72:	f006 f9e9 	bl	8014e48 <ATutil_convertStringToUpperCase>
    if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM NOT INSERTED") != NULL)
 800ea76:	4953      	ldr	r1, [pc, #332]	; (800ebc4 <analyze_CmeError+0x2bc>)
 800ea78:	4668      	mov	r0, sp
 800ea7a:	f017 f9b7 	bl	8025dec <strstr>
 800ea7e:	b150      	cbz	r0, 800ea96 <analyze_CmeError+0x18e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800ea80:	2300      	movs	r3, #0
 800ea82:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_NOT_INSERTED;
 800ea86:	2302      	movs	r3, #2
 800ea88:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800ea8c:	4649      	mov	r1, r9
 800ea8e:	2001      	movs	r0, #1
 800ea90:	f7ff fd72 	bl	800e578 <set_error_report>
 800ea94:	e775      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN NECESSARY") != NULL)
 800ea96:	494c      	ldr	r1, [pc, #304]	; (800ebc8 <analyze_CmeError+0x2c0>)
 800ea98:	4668      	mov	r0, sp
 800ea9a:	f017 f9a7 	bl	8025dec <strstr>
 800ea9e:	b150      	cbz	r0, 800eab6 <analyze_CmeError+0x1ae>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eaa0:	2300      	movs	r3, #0
 800eaa2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN_REQUIRED;
 800eaa6:	2306      	movs	r3, #6
 800eaa8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eaac:	4649      	mov	r1, r9
 800eaae:	2001      	movs	r0, #1
 800eab0:	f7ff fd62 	bl	800e578 <set_error_report>
 800eab4:	e765      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN REQUIRED") != NULL)
 800eab6:	4945      	ldr	r1, [pc, #276]	; (800ebcc <analyze_CmeError+0x2c4>)
 800eab8:	4668      	mov	r0, sp
 800eaba:	f017 f997 	bl	8025dec <strstr>
 800eabe:	b150      	cbz	r0, 800ead6 <analyze_CmeError+0x1ce>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eac0:	2300      	movs	r3, #0
 800eac2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN_REQUIRED;
 800eac6:	2306      	movs	r3, #6
 800eac8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eacc:	4649      	mov	r1, r9
 800eace:	2001      	movs	r0, #1
 800ead0:	f7ff fd52 	bl	800e578 <set_error_report>
 800ead4:	e755      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK REQUIRED") != NULL)
 800ead6:	493e      	ldr	r1, [pc, #248]	; (800ebd0 <analyze_CmeError+0x2c8>)
 800ead8:	4668      	mov	r0, sp
 800eada:	f017 f987 	bl	8025dec <strstr>
 800eade:	b150      	cbz	r0, 800eaf6 <analyze_CmeError+0x1ee>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eae0:	2300      	movs	r3, #0
 800eae2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK_REQUIRED;
 800eae6:	2308      	movs	r3, #8
 800eae8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eaec:	4649      	mov	r1, r9
 800eaee:	2001      	movs	r0, #1
 800eaf0:	f7ff fd42 	bl	800e578 <set_error_report>
 800eaf4:	e745      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM FAILURE") != NULL)
 800eaf6:	4937      	ldr	r1, [pc, #220]	; (800ebd4 <analyze_CmeError+0x2cc>)
 800eaf8:	4668      	mov	r0, sp
 800eafa:	f017 f977 	bl	8025dec <strstr>
 800eafe:	b150      	cbz	r0, 800eb16 <analyze_CmeError+0x20e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb00:	2300      	movs	r3, #0
 800eb02:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_FAILURE;
 800eb06:	2304      	movs	r3, #4
 800eb08:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb0c:	4649      	mov	r1, r9
 800eb0e:	2001      	movs	r0, #1
 800eb10:	f7ff fd32 	bl	800e578 <set_error_report>
 800eb14:	e735      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM BUSY") != NULL)
 800eb16:	4930      	ldr	r1, [pc, #192]	; (800ebd8 <analyze_CmeError+0x2d0>)
 800eb18:	4668      	mov	r0, sp
 800eb1a:	f017 f967 	bl	8025dec <strstr>
 800eb1e:	b150      	cbz	r0, 800eb36 <analyze_CmeError+0x22e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb20:	2300      	movs	r3, #0
 800eb22:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_BUSY;
 800eb26:	2303      	movs	r3, #3
 800eb28:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb2c:	4649      	mov	r1, r9
 800eb2e:	2001      	movs	r0, #1
 800eb30:	f7ff fd22 	bl	800e578 <set_error_report>
 800eb34:	e725      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM WRONG") != NULL)
 800eb36:	4929      	ldr	r1, [pc, #164]	; (800ebdc <analyze_CmeError+0x2d4>)
 800eb38:	4668      	mov	r0, sp
 800eb3a:	f017 f957 	bl	8025dec <strstr>
 800eb3e:	b150      	cbz	r0, 800eb56 <analyze_CmeError+0x24e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb40:	2300      	movs	r3, #0
 800eb42:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_WRONG;
 800eb46:	2305      	movs	r3, #5
 800eb48:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb4c:	4649      	mov	r1, r9
 800eb4e:	2001      	movs	r0, #1
 800eb50:	f7ff fd12 	bl	800e578 <set_error_report>
 800eb54:	e715      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "INCORRECT PASSWORD") != NULL)
 800eb56:	4922      	ldr	r1, [pc, #136]	; (800ebe0 <analyze_CmeError+0x2d8>)
 800eb58:	4668      	mov	r0, sp
 800eb5a:	f017 f947 	bl	8025dec <strstr>
 800eb5e:	b150      	cbz	r0, 800eb76 <analyze_CmeError+0x26e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb60:	2300      	movs	r3, #0
 800eb62:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_INCORRECT_PASSWORD;
 800eb66:	230a      	movs	r3, #10
 800eb68:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb6c:	4649      	mov	r1, r9
 800eb6e:	2001      	movs	r0, #1
 800eb70:	f7ff fd02 	bl	800e578 <set_error_report>
 800eb74:	e705      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN2 REQUIRED") != NULL)
 800eb76:	491b      	ldr	r1, [pc, #108]	; (800ebe4 <analyze_CmeError+0x2dc>)
 800eb78:	4668      	mov	r0, sp
 800eb7a:	f017 f937 	bl	8025dec <strstr>
 800eb7e:	b150      	cbz	r0, 800eb96 <analyze_CmeError+0x28e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb80:	2300      	movs	r3, #0
 800eb82:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN2_REQUIRED;
 800eb86:	2307      	movs	r3, #7
 800eb88:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb8c:	4649      	mov	r1, r9
 800eb8e:	2001      	movs	r0, #1
 800eb90:	f7ff fcf2 	bl	800e578 <set_error_report>
 800eb94:	e6f5      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK2 REQUIRED") != NULL)
 800eb96:	4914      	ldr	r1, [pc, #80]	; (800ebe8 <analyze_CmeError+0x2e0>)
 800eb98:	4668      	mov	r0, sp
 800eb9a:	f017 f927 	bl	8025dec <strstr>
 800eb9e:	b150      	cbz	r0, 800ebb6 <analyze_CmeError+0x2ae>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eba0:	2300      	movs	r3, #0
 800eba2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK2_REQUIRED;
 800eba6:	2309      	movs	r3, #9
 800eba8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800ebac:	4649      	mov	r1, r9
 800ebae:	2001      	movs	r0, #1
 800ebb0:	f7ff fce2 	bl	800e578 <set_error_report>
 800ebb4:	e6e5      	b.n	800e982 <analyze_CmeError+0x7a>
      __NOP();
 800ebb6:	bf00      	nop
 800ebb8:	e6e3      	b.n	800e982 <analyze_CmeError+0x7a>
 800ebba:	bf00      	nop
 800ebbc:	0802e584 	.word	0x0802e584
 800ebc0:	200048dc 	.word	0x200048dc
 800ebc4:	0802e61c 	.word	0x0802e61c
 800ebc8:	0802e630 	.word	0x0802e630
 800ebcc:	0802e644 	.word	0x0802e644
 800ebd0:	0802e658 	.word	0x0802e658
 800ebd4:	0802e66c 	.word	0x0802e66c
 800ebd8:	0802e678 	.word	0x0802e678
 800ebdc:	0802e684 	.word	0x0802e684
 800ebe0:	080334b0 	.word	0x080334b0
 800ebe4:	0802e690 	.word	0x0802e690
 800ebe8:	0802e6a4 	.word	0x0802e6a4
 800ebec:	0802e5b4 	.word	0x0802e5b4
 800ebf0:	0802e5e0 	.word	0x0802e5e0

0800ebf4 <extract_hex_value_from_quotes>:
#define MAX_PARAM_SIZE 8 /* max of previous values         */
/*
 * Extract the value of an hexadecimal parameter from a string
 */
static uint32_t extract_hex_value_from_quotes(const uint8_t *p_str, uint16_t str_size, uint8_t param_size)
{
 800ebf4:	b510      	push	{r4, lr}
 800ebf6:	b082      	sub	sp, #8
 800ebf8:	4613      	mov	r3, r2
  uint8_t tmp_array[MAX_PARAM_SIZE] = {0};
 800ebfa:	2400      	movs	r4, #0
 800ebfc:	9400      	str	r4, [sp, #0]
 800ebfe:	9401      	str	r4, [sp, #4]
  uint16_t real_size;
  uint32_t converted_value;
  real_size = ATutil_remove_quotes(p_str, str_size, &tmp_array[0], param_size);
 800ec00:	466a      	mov	r2, sp
 800ec02:	f006 f95e 	bl	8014ec2 <ATutil_remove_quotes>
 800ec06:	4601      	mov	r1, r0
  converted_value = ATutil_convertHexaStringToInt32(&tmp_array[0], real_size);
 800ec08:	4668      	mov	r0, sp
 800ec0a:	f006 f837 	bl	8014c7c <ATutil_convertHexaStringToInt32>

  return (converted_value);
}
 800ec0e:	b002      	add	sp, #8
 800ec10:	bd10      	pop	{r4, pc}

0800ec12 <extract_bin_value_from_quotes>:
#if (SW_DEBUG_VERSION == 1U)
/*
 * Extract the value of an binary parameter from a string
 */
static uint32_t extract_bin_value_from_quotes(const uint8_t *p_str, uint16_t str_size, uint8_t param_size)
{
 800ec12:	b510      	push	{r4, lr}
 800ec14:	b082      	sub	sp, #8
 800ec16:	4613      	mov	r3, r2
  uint8_t tmp_array[MAX_PARAM_SIZE] = {0};
 800ec18:	2400      	movs	r4, #0
 800ec1a:	9400      	str	r4, [sp, #0]
 800ec1c:	9401      	str	r4, [sp, #4]
  uint16_t real_size;
  uint32_t converted_value;
  real_size = ATutil_remove_quotes(p_str, str_size, &tmp_array[0], param_size);
 800ec1e:	466a      	mov	r2, sp
 800ec20:	f006 f94f 	bl	8014ec2 <ATutil_remove_quotes>
 800ec24:	4601      	mov	r1, r0
  converted_value = ATutil_convertBinStringToInt32(&tmp_array[0], real_size);
 800ec26:	4668      	mov	r0, sp
 800ec28:	f006 f8ef 	bl	8014e0a <ATutil_convertBinStringToInt32>

  return (converted_value);
}
 800ec2c:	b002      	add	sp, #8
 800ec2e:	bd10      	pop	{r4, pc}

0800ec30 <find_user_cid_with_matching_ip_addr>:
{
 800ec30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ec34:	b082      	sub	sp, #8
 800ec36:	4607      	mov	r7, r0
 800ec38:	460e      	mov	r6, r1
  for (uint8_t loop = 0U; loop < MODEM_MAX_NB_PDP_CTXT; loop++)
 800ec3a:	2500      	movs	r5, #0
  CS_PDN_conf_id_t user_cid = CS_PDN_NOT_DEFINED;
 800ec3c:	f04f 080c 	mov.w	r8, #12
  for (uint8_t loop = 0U; loop < MODEM_MAX_NB_PDP_CTXT; loop++)
 800ec40:	e001      	b.n	800ec46 <find_user_cid_with_matching_ip_addr+0x16>
 800ec42:	3501      	adds	r5, #1
 800ec44:	b2ed      	uxtb	r5, r5
 800ec46:	2d05      	cmp	r5, #5
 800ec48:	d856      	bhi.n	800ecf8 <find_user_cid_with_matching_ip_addr+0xc8>
    PRINT_DBG("[Compare ip addr with user cid=%d]: <%s> vs <%s>",
 800ec4a:	f106 0a01 	add.w	sl, r6, #1
 800ec4e:	eb05 1405 	add.w	r4, r5, r5, lsl #4
 800ec52:	00a4      	lsls	r4, r4, #2
 800ec54:	f504 7454 	add.w	r4, r4, #848	; 0x350
 800ec58:	443c      	add	r4, r7
 800ec5a:	3404      	adds	r4, #4
 800ec5c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 800ed04 <find_user_cid_with_matching_ip_addr+0xd4>
 800ec60:	9400      	str	r4, [sp, #0]
 800ec62:	4653      	mov	r3, sl
 800ec64:	462a      	mov	r2, r5
 800ec66:	4926      	ldr	r1, [pc, #152]	; (800ed00 <find_user_cid_with_matching_ip_addr+0xd0>)
 800ec68:	4648      	mov	r0, r9
 800ec6a:	f017 f801 	bl	8025c70 <sprintf>
 800ec6e:	4648      	mov	r0, r9
 800ec70:	f010 fa4f 	bl	801f112 <crs_strlen>
 800ec74:	b283      	uxth	r3, r0
 800ec76:	464a      	mov	r2, r9
 800ec78:	2102      	movs	r1, #2
 800ec7a:	4608      	mov	r0, r1
 800ec7c:	f010 fa8c 	bl	801f198 <traceIF_itmPrint>
 800ec80:	4648      	mov	r0, r9
 800ec82:	f010 fa46 	bl	801f112 <crs_strlen>
 800ec86:	b283      	uxth	r3, r0
 800ec88:	464a      	mov	r2, r9
 800ec8a:	2102      	movs	r1, #2
 800ec8c:	4608      	mov	r0, r1
 800ec8e:	f010 faa5 	bl	801f1dc <traceIF_uartPrint>
    size1 = (uint8_t) strlen((CRC_CHAR_t *)&ip_addr_struct->ip_addr_value);
 800ec92:	4650      	mov	r0, sl
 800ec94:	f7f1 faae 	bl	80001f4 <strlen>
 800ec98:	fa5f f980 	uxtb.w	r9, r0
    size2 = (uint8_t) strlen((CRC_CHAR_t *)&p_tmp->ip_addr_infos.ip_addr_value);
 800ec9c:	4620      	mov	r0, r4
 800ec9e:	f7f1 faa9 	bl	80001f4 <strlen>
 800eca2:	b2c0      	uxtb	r0, r0
    minsize = (size1 < size2) ? size1 : size2;
 800eca4:	4581      	cmp	r9, r0
 800eca6:	bf28      	it	cs
 800eca8:	4681      	movcs	r9, r0
    if ((0 == memcmp((AT_CHAR_t *)&ip_addr_struct->ip_addr_value[0],
 800ecaa:	464a      	mov	r2, r9
 800ecac:	4621      	mov	r1, r4
 800ecae:	4650      	mov	r0, sl
 800ecb0:	f017 f841 	bl	8025d36 <memcmp>
 800ecb4:	2800      	cmp	r0, #0
 800ecb6:	d1c4      	bne.n	800ec42 <find_user_cid_with_matching_ip_addr+0x12>
                     (size_t) minsize)) &&
 800ecb8:	f1b9 0f00 	cmp.w	r9, #0
 800ecbc:	d0c1      	beq.n	800ec42 <find_user_cid_with_matching_ip_addr+0x12>
      user_cid = atcm_convert_index_to_PDN_conf(loop);
 800ecbe:	4628      	mov	r0, r5
 800ecc0:	f7fe fedc 	bl	800da7c <atcm_convert_index_to_PDN_conf>
 800ecc4:	4680      	mov	r8, r0
      PRINT_DBG("Found matching user cid=%d", user_cid)
 800ecc6:	4c0f      	ldr	r4, [pc, #60]	; (800ed04 <find_user_cid_with_matching_ip_addr+0xd4>)
 800ecc8:	4602      	mov	r2, r0
 800ecca:	490f      	ldr	r1, [pc, #60]	; (800ed08 <find_user_cid_with_matching_ip_addr+0xd8>)
 800eccc:	4620      	mov	r0, r4
 800ecce:	f016 ffcf 	bl	8025c70 <sprintf>
 800ecd2:	4620      	mov	r0, r4
 800ecd4:	f010 fa1d 	bl	801f112 <crs_strlen>
 800ecd8:	b283      	uxth	r3, r0
 800ecda:	4622      	mov	r2, r4
 800ecdc:	2102      	movs	r1, #2
 800ecde:	4608      	mov	r0, r1
 800ece0:	f010 fa5a 	bl	801f198 <traceIF_itmPrint>
 800ece4:	4620      	mov	r0, r4
 800ece6:	f010 fa14 	bl	801f112 <crs_strlen>
 800ecea:	b283      	uxth	r3, r0
 800ecec:	4622      	mov	r2, r4
 800ecee:	2102      	movs	r1, #2
 800ecf0:	4608      	mov	r0, r1
 800ecf2:	f010 fa73 	bl	801f1dc <traceIF_uartPrint>
 800ecf6:	e7a4      	b.n	800ec42 <find_user_cid_with_matching_ip_addr+0x12>
}
 800ecf8:	4640      	mov	r0, r8
 800ecfa:	b002      	add	sp, #8
 800ecfc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ed00:	0802e6b8 	.word	0x0802e6b8
 800ed04:	200048dc 	.word	0x200048dc
 800ed08:	0802e6f4 	.word	0x0802e6f4

0800ed0c <fCmdBuild_NoParams>:
#endif /* (SW_DEBUG_VERSION == 1U) */
/* Functions Definition ------------------------------------------------------*/

/* ==========================  Build 3GPP TS 27.007 commands ========================== */
at_status_t fCmdBuild_NoParams(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ed0c:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_atp_ctxt);
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  /* Command as no parameters - STUB function */
  PRINT_API("enter fCmdBuild_NoParams()")
 800ed0e:	4c14      	ldr	r4, [pc, #80]	; (800ed60 <fCmdBuild_NoParams+0x54>)
 800ed10:	4d14      	ldr	r5, [pc, #80]	; (800ed64 <fCmdBuild_NoParams+0x58>)
 800ed12:	f104 0e20 	add.w	lr, r4, #32
 800ed16:	46a4      	mov	ip, r4
 800ed18:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ed1c:	6028      	str	r0, [r5, #0]
 800ed1e:	6069      	str	r1, [r5, #4]
 800ed20:	60aa      	str	r2, [r5, #8]
 800ed22:	60eb      	str	r3, [r5, #12]
 800ed24:	4664      	mov	r4, ip
 800ed26:	3510      	adds	r5, #16
 800ed28:	45f4      	cmp	ip, lr
 800ed2a:	d1f4      	bne.n	800ed16 <fCmdBuild_NoParams+0xa>
 800ed2c:	cc03      	ldmia	r4!, {r0, r1}
 800ed2e:	6028      	str	r0, [r5, #0]
 800ed30:	6069      	str	r1, [r5, #4]
 800ed32:	8823      	ldrh	r3, [r4, #0]
 800ed34:	812b      	strh	r3, [r5, #8]
 800ed36:	4c0b      	ldr	r4, [pc, #44]	; (800ed64 <fCmdBuild_NoParams+0x58>)
 800ed38:	4620      	mov	r0, r4
 800ed3a:	f010 f9ea 	bl	801f112 <crs_strlen>
 800ed3e:	b283      	uxth	r3, r0
 800ed40:	4622      	mov	r2, r4
 800ed42:	2104      	movs	r1, #4
 800ed44:	2002      	movs	r0, #2
 800ed46:	f010 fa27 	bl	801f198 <traceIF_itmPrint>
 800ed4a:	4620      	mov	r0, r4
 800ed4c:	f010 f9e1 	bl	801f112 <crs_strlen>
 800ed50:	b283      	uxth	r3, r0
 800ed52:	4622      	mov	r2, r4
 800ed54:	2104      	movs	r1, #4
 800ed56:	2002      	movs	r0, #2
 800ed58:	f010 fa40 	bl	801f1dc <traceIF_uartPrint>

  return (retval);
}
 800ed5c:	2000      	movs	r0, #0
 800ed5e:	bd38      	pop	{r3, r4, r5, pc}
 800ed60:	0802e71c 	.word	0x0802e71c
 800ed64:	200048dc 	.word	0x200048dc

0800ed68 <fCmdBuild_CGSN>:

at_status_t fCmdBuild_CGSN(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ed68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ed6a:	4606      	mov	r6, r0
 800ed6c:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGSN()")
 800ed6e:	4d1a      	ldr	r5, [pc, #104]	; (800edd8 <fCmdBuild_CGSN+0x70>)
 800ed70:	4c1a      	ldr	r4, [pc, #104]	; (800eddc <fCmdBuild_CGSN+0x74>)
 800ed72:	f105 0e20 	add.w	lr, r5, #32
 800ed76:	46ac      	mov	ip, r5
 800ed78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ed7c:	6020      	str	r0, [r4, #0]
 800ed7e:	6061      	str	r1, [r4, #4]
 800ed80:	60a2      	str	r2, [r4, #8]
 800ed82:	60e3      	str	r3, [r4, #12]
 800ed84:	4665      	mov	r5, ip
 800ed86:	3410      	adds	r4, #16
 800ed88:	45f4      	cmp	ip, lr
 800ed8a:	d1f4      	bne.n	800ed76 <fCmdBuild_CGSN+0xe>
 800ed8c:	f8dc 0000 	ldr.w	r0, [ip]
 800ed90:	6020      	str	r0, [r4, #0]
 800ed92:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ed96:	80a3      	strh	r3, [r4, #4]
 800ed98:	4c10      	ldr	r4, [pc, #64]	; (800eddc <fCmdBuild_CGSN+0x74>)
 800ed9a:	4620      	mov	r0, r4
 800ed9c:	f010 f9b9 	bl	801f112 <crs_strlen>
 800eda0:	b283      	uxth	r3, r0
 800eda2:	4622      	mov	r2, r4
 800eda4:	2104      	movs	r1, #4
 800eda6:	2002      	movs	r0, #2
 800eda8:	f010 f9f6 	bl	801f198 <traceIF_itmPrint>
 800edac:	4620      	mov	r0, r4
 800edae:	f010 f9b0 	bl	801f112 <crs_strlen>
 800edb2:	b283      	uxth	r3, r0
 800edb4:	4622      	mov	r2, r4
 800edb6:	2104      	movs	r1, #4
 800edb8:	2002      	movs	r0, #2
 800edba:	f010 fa0f 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800edbe:	8933      	ldrh	r3, [r6, #8]
 800edc0:	2b03      	cmp	r3, #3
 800edc2:	d001      	beq.n	800edc8 <fCmdBuild_CGSN+0x60>
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
                   p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param);
  }
  return (retval);
}
 800edc4:	2000      	movs	r0, #0
 800edc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800edc8:	f897 272c 	ldrb.w	r2, [r7, #1836]	; 0x72c
 800edcc:	4904      	ldr	r1, [pc, #16]	; (800ede0 <fCmdBuild_CGSN+0x78>)
 800edce:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800edd2:	f016 ff4d 	bl	8025c70 <sprintf>
 800edd6:	e7f5      	b.n	800edc4 <fCmdBuild_CGSN+0x5c>
 800edd8:	0802e748 	.word	0x0802e748
 800eddc:	200048dc 	.word	0x200048dc
 800ede0:	0802e834 	.word	0x0802e834

0800ede4 <fCmdBuild_CMEE>:

at_status_t fCmdBuild_CMEE(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ede4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ede6:	4606      	mov	r6, r0
 800ede8:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CMEE()")
 800edea:	4d1a      	ldr	r5, [pc, #104]	; (800ee54 <fCmdBuild_CMEE+0x70>)
 800edec:	4c1a      	ldr	r4, [pc, #104]	; (800ee58 <fCmdBuild_CMEE+0x74>)
 800edee:	f105 0e20 	add.w	lr, r5, #32
 800edf2:	46ac      	mov	ip, r5
 800edf4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800edf8:	6020      	str	r0, [r4, #0]
 800edfa:	6061      	str	r1, [r4, #4]
 800edfc:	60a2      	str	r2, [r4, #8]
 800edfe:	60e3      	str	r3, [r4, #12]
 800ee00:	4665      	mov	r5, ip
 800ee02:	3410      	adds	r4, #16
 800ee04:	45f4      	cmp	ip, lr
 800ee06:	d1f4      	bne.n	800edf2 <fCmdBuild_CMEE+0xe>
 800ee08:	f8dc 0000 	ldr.w	r0, [ip]
 800ee0c:	6020      	str	r0, [r4, #0]
 800ee0e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ee12:	80a3      	strh	r3, [r4, #4]
 800ee14:	4c10      	ldr	r4, [pc, #64]	; (800ee58 <fCmdBuild_CMEE+0x74>)
 800ee16:	4620      	mov	r0, r4
 800ee18:	f010 f97b 	bl	801f112 <crs_strlen>
 800ee1c:	b283      	uxth	r3, r0
 800ee1e:	4622      	mov	r2, r4
 800ee20:	2104      	movs	r1, #4
 800ee22:	2002      	movs	r0, #2
 800ee24:	f010 f9b8 	bl	801f198 <traceIF_itmPrint>
 800ee28:	4620      	mov	r0, r4
 800ee2a:	f010 f972 	bl	801f112 <crs_strlen>
 800ee2e:	b283      	uxth	r3, r0
 800ee30:	4622      	mov	r2, r4
 800ee32:	2104      	movs	r1, #4
 800ee34:	2002      	movs	r0, #2
 800ee36:	f010 f9d1 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800ee3a:	8933      	ldrh	r3, [r6, #8]
 800ee3c:	2b03      	cmp	r3, #3
 800ee3e:	d001      	beq.n	800ee44 <fCmdBuild_CMEE+0x60>
      * 2: <err> result code enabled and verbose <ERR> values used
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", p_modem_ctxt->persist.cmee_level);
  }
  return (retval);
}
 800ee40:	2000      	movs	r0, #0
 800ee42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", p_modem_ctxt->persist.cmee_level);
 800ee44:	f897 2513 	ldrb.w	r2, [r7, #1299]	; 0x513
 800ee48:	4904      	ldr	r1, [pc, #16]	; (800ee5c <fCmdBuild_CMEE+0x78>)
 800ee4a:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ee4e:	f016 ff0f 	bl	8025c70 <sprintf>
 800ee52:	e7f5      	b.n	800ee40 <fCmdBuild_CMEE+0x5c>
 800ee54:	0802e770 	.word	0x0802e770
 800ee58:	200048dc 	.word	0x200048dc
 800ee5c:	0802e834 	.word	0x0802e834

0800ee60 <fCmdBuild_CPIN>:

at_status_t fCmdBuild_CPIN(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ee60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ee62:	4606      	mov	r6, r0
 800ee64:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CPIN()")
 800ee66:	4d26      	ldr	r5, [pc, #152]	; (800ef00 <fCmdBuild_CPIN+0xa0>)
 800ee68:	4c26      	ldr	r4, [pc, #152]	; (800ef04 <fCmdBuild_CPIN+0xa4>)
 800ee6a:	f105 0e20 	add.w	lr, r5, #32
 800ee6e:	46ac      	mov	ip, r5
 800ee70:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ee74:	6020      	str	r0, [r4, #0]
 800ee76:	6061      	str	r1, [r4, #4]
 800ee78:	60a2      	str	r2, [r4, #8]
 800ee7a:	60e3      	str	r3, [r4, #12]
 800ee7c:	4665      	mov	r5, ip
 800ee7e:	3410      	adds	r4, #16
 800ee80:	45f4      	cmp	ip, lr
 800ee82:	d1f4      	bne.n	800ee6e <fCmdBuild_CPIN+0xe>
 800ee84:	f8dc 0000 	ldr.w	r0, [ip]
 800ee88:	6020      	str	r0, [r4, #0]
 800ee8a:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ee8e:	80a3      	strh	r3, [r4, #4]
 800ee90:	4c1c      	ldr	r4, [pc, #112]	; (800ef04 <fCmdBuild_CPIN+0xa4>)
 800ee92:	4620      	mov	r0, r4
 800ee94:	f010 f93d 	bl	801f112 <crs_strlen>
 800ee98:	b283      	uxth	r3, r0
 800ee9a:	4622      	mov	r2, r4
 800ee9c:	2104      	movs	r1, #4
 800ee9e:	2002      	movs	r0, #2
 800eea0:	f010 f97a 	bl	801f198 <traceIF_itmPrint>
 800eea4:	4620      	mov	r0, r4
 800eea6:	f010 f934 	bl	801f112 <crs_strlen>
 800eeaa:	b283      	uxth	r3, r0
 800eeac:	4622      	mov	r2, r4
 800eeae:	2104      	movs	r1, #4
 800eeb0:	2002      	movs	r0, #2
 800eeb2:	f010 f993 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800eeb6:	8933      	ldrh	r3, [r6, #8]
 800eeb8:	2b03      	cmp	r3, #3
 800eeba:	d001      	beq.n	800eec0 <fCmdBuild_CPIN+0x60>

    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\"",
                   p_modem_ctxt->SID_ctxt.modem_init.pincode.pincode);
  }
  return (retval);
}
 800eebc:	2000      	movs	r0, #0
 800eebe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_DBG("pin code= %s", p_modem_ctxt->SID_ctxt.modem_init.pincode.pincode)
 800eec0:	f207 57b3 	addw	r7, r7, #1459	; 0x5b3
 800eec4:	463a      	mov	r2, r7
 800eec6:	4910      	ldr	r1, [pc, #64]	; (800ef08 <fCmdBuild_CPIN+0xa8>)
 800eec8:	4620      	mov	r0, r4
 800eeca:	f016 fed1 	bl	8025c70 <sprintf>
 800eece:	4620      	mov	r0, r4
 800eed0:	f010 f91f 	bl	801f112 <crs_strlen>
 800eed4:	b283      	uxth	r3, r0
 800eed6:	4622      	mov	r2, r4
 800eed8:	2102      	movs	r1, #2
 800eeda:	4608      	mov	r0, r1
 800eedc:	f010 f95c 	bl	801f198 <traceIF_itmPrint>
 800eee0:	4620      	mov	r0, r4
 800eee2:	f010 f916 	bl	801f112 <crs_strlen>
 800eee6:	b283      	uxth	r3, r0
 800eee8:	4622      	mov	r2, r4
 800eeea:	2102      	movs	r1, #2
 800eeec:	4608      	mov	r0, r1
 800eeee:	f010 f975 	bl	801f1dc <traceIF_uartPrint>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\"",
 800eef2:	463a      	mov	r2, r7
 800eef4:	4905      	ldr	r1, [pc, #20]	; (800ef0c <fCmdBuild_CPIN+0xac>)
 800eef6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800eefa:	f016 feb9 	bl	8025c70 <sprintf>
 800eefe:	e7dd      	b.n	800eebc <fCmdBuild_CPIN+0x5c>
 800ef00:	0802e798 	.word	0x0802e798
 800ef04:	200048dc 	.word	0x200048dc
 800ef08:	0802e7c0 	.word	0x0802e7c0
 800ef0c:	0802a984 	.word	0x0802a984

0800ef10 <fCmdBuild_CFUN>:

at_status_t fCmdBuild_CFUN(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ef10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ef12:	4606      	mov	r6, r0
 800ef14:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CFUN()")
 800ef16:	4d26      	ldr	r5, [pc, #152]	; (800efb0 <fCmdBuild_CFUN+0xa0>)
 800ef18:	4c26      	ldr	r4, [pc, #152]	; (800efb4 <fCmdBuild_CFUN+0xa4>)
 800ef1a:	f105 0e20 	add.w	lr, r5, #32
 800ef1e:	46ac      	mov	ip, r5
 800ef20:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ef24:	6020      	str	r0, [r4, #0]
 800ef26:	6061      	str	r1, [r4, #4]
 800ef28:	60a2      	str	r2, [r4, #8]
 800ef2a:	60e3      	str	r3, [r4, #12]
 800ef2c:	4665      	mov	r5, ip
 800ef2e:	3410      	adds	r4, #16
 800ef30:	45f4      	cmp	ip, lr
 800ef32:	d1f4      	bne.n	800ef1e <fCmdBuild_CFUN+0xe>
 800ef34:	f8dc 0000 	ldr.w	r0, [ip]
 800ef38:	6020      	str	r0, [r4, #0]
 800ef3a:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ef3e:	80a3      	strh	r3, [r4, #4]
 800ef40:	4c1c      	ldr	r4, [pc, #112]	; (800efb4 <fCmdBuild_CFUN+0xa4>)
 800ef42:	4620      	mov	r0, r4
 800ef44:	f010 f8e5 	bl	801f112 <crs_strlen>
 800ef48:	b283      	uxth	r3, r0
 800ef4a:	4622      	mov	r2, r4
 800ef4c:	2104      	movs	r1, #4
 800ef4e:	2002      	movs	r0, #2
 800ef50:	f010 f922 	bl	801f198 <traceIF_itmPrint>
 800ef54:	4620      	mov	r0, r4
 800ef56:	f010 f8dc 	bl	801f112 <crs_strlen>
 800ef5a:	b283      	uxth	r3, r0
 800ef5c:	4622      	mov	r2, r4
 800ef5e:	2104      	movs	r1, #4
 800ef60:	2002      	movs	r0, #2
 800ef62:	f010 f93b 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800ef66:	8933      	ldrh	r3, [r6, #8]
 800ef68:	2b03      	cmp	r3, #3
 800ef6a:	d001      	beq.n	800ef70 <fCmdBuild_CFUN+0x60>
      /* set parameter defined by user */
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,0", p_modem_ctxt->CMD_ctxt.cfun_value);
    }
  }
  return (retval);
}
 800ef6c:	2000      	movs	r0, #0
 800ef6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_INIT_MODEM)
 800ef70:	8833      	ldrh	r3, [r6, #0]
 800ef72:	2b67      	cmp	r3, #103	; 0x67
 800ef74:	d113      	bne.n	800ef9e <fCmdBuild_CFUN+0x8e>
      if (modemInit_struct->init == CS_CMI_FULL)
 800ef76:	f897 25b1 	ldrb.w	r2, [r7, #1457]	; 0x5b1
 800ef7a:	2a01      	cmp	r2, #1
 800ef7c:	d002      	beq.n	800ef84 <fCmdBuild_CFUN+0x74>
      else if (modemInit_struct->init == CS_CMI_SIM_ONLY)
 800ef7e:	2a02      	cmp	r2, #2
 800ef80:	d00b      	beq.n	800ef9a <fCmdBuild_CFUN+0x8a>
        fun = 0U; /* default value, if CS_CMI_MINI */
 800ef82:	2200      	movs	r2, #0
      (modemInit_struct->reset == CELLULAR_TRUE) ? (rst = 1U) : (rst = 0U);
 800ef84:	f897 35b2 	ldrb.w	r3, [r7, #1458]	; 0x5b2
 800ef88:	2b01      	cmp	r3, #1
 800ef8a:	d000      	beq.n	800ef8e <fCmdBuild_CFUN+0x7e>
 800ef8c:	2300      	movs	r3, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d", fun, rst);
 800ef8e:	490a      	ldr	r1, [pc, #40]	; (800efb8 <fCmdBuild_CFUN+0xa8>)
 800ef90:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ef94:	f016 fe6c 	bl	8025c70 <sprintf>
 800ef98:	e7e8      	b.n	800ef6c <fCmdBuild_CFUN+0x5c>
        fun = 4U;
 800ef9a:	2204      	movs	r2, #4
 800ef9c:	e7f2      	b.n	800ef84 <fCmdBuild_CFUN+0x74>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,0", p_modem_ctxt->CMD_ctxt.cfun_value);
 800ef9e:	f897 273d 	ldrb.w	r2, [r7, #1853]	; 0x73d
 800efa2:	4906      	ldr	r1, [pc, #24]	; (800efbc <fCmdBuild_CFUN+0xac>)
 800efa4:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800efa8:	f016 fe62 	bl	8025c70 <sprintf>
 800efac:	e7de      	b.n	800ef6c <fCmdBuild_CFUN+0x5c>
 800efae:	bf00      	nop
 800efb0:	0802e7d8 	.word	0x0802e7d8
 800efb4:	200048dc 	.word	0x200048dc
 800efb8:	0802ac14 	.word	0x0802ac14
 800efbc:	0802e800 	.word	0x0802e800

0800efc0 <fCmdBuild_COPS>:

at_status_t fCmdBuild_COPS(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800efc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800efc2:	b083      	sub	sp, #12
 800efc4:	4606      	mov	r6, r0
 800efc6:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_COPS()")
 800efc8:	4d4e      	ldr	r5, [pc, #312]	; (800f104 <fCmdBuild_COPS+0x144>)
 800efca:	4c4f      	ldr	r4, [pc, #316]	; (800f108 <fCmdBuild_COPS+0x148>)
 800efcc:	f105 0e20 	add.w	lr, r5, #32
 800efd0:	46ac      	mov	ip, r5
 800efd2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800efd6:	6020      	str	r0, [r4, #0]
 800efd8:	6061      	str	r1, [r4, #4]
 800efda:	60a2      	str	r2, [r4, #8]
 800efdc:	60e3      	str	r3, [r4, #12]
 800efde:	4665      	mov	r5, ip
 800efe0:	3410      	adds	r4, #16
 800efe2:	45f4      	cmp	ip, lr
 800efe4:	d1f4      	bne.n	800efd0 <fCmdBuild_COPS+0x10>
 800efe6:	f8dc 0000 	ldr.w	r0, [ip]
 800efea:	6020      	str	r0, [r4, #0]
 800efec:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800eff0:	80a3      	strh	r3, [r4, #4]
 800eff2:	4c45      	ldr	r4, [pc, #276]	; (800f108 <fCmdBuild_COPS+0x148>)
 800eff4:	4620      	mov	r0, r4
 800eff6:	f010 f88c 	bl	801f112 <crs_strlen>
 800effa:	b283      	uxth	r3, r0
 800effc:	4622      	mov	r2, r4
 800effe:	2104      	movs	r1, #4
 800f000:	2002      	movs	r0, #2
 800f002:	f010 f8c9 	bl	801f198 <traceIF_itmPrint>
 800f006:	4620      	mov	r0, r4
 800f008:	f010 f883 	bl	801f112 <crs_strlen>
 800f00c:	b283      	uxth	r3, r0
 800f00e:	4622      	mov	r2, r4
 800f010:	2104      	movs	r1, #4
 800f012:	2002      	movs	r0, #2
 800f014:	f010 f8e2 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f018:	8933      	ldrh	r3, [r6, #8]
 800f01a:	2b03      	cmp	r3, #3
 800f01c:	d003      	beq.n	800f026 <fCmdBuild_COPS+0x66>
  at_status_t retval = ATSTATUS_OK;
 800f01e:	2400      	movs	r4, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
    }
  }

  return (retval);
}
 800f020:	4620      	mov	r0, r4
 800f022:	b003      	add	sp, #12
 800f024:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (operatorSelect->mode == CS_NRM_AUTO)
 800f026:	f8b7 35c8 	ldrh.w	r3, [r7, #1480]	; 0x5c8
 800f02a:	b97b      	cbnz	r3, 800f04c <fCmdBuild_COPS+0x8c>
      if (operatorSelect->AcT_present == CELLULAR_FALSE)
 800f02c:	f897 460c 	ldrb.w	r4, [r7, #1548]	; 0x60c
 800f030:	b91c      	cbnz	r4, 800f03a <fCmdBuild_COPS+0x7a>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f032:	4b36      	ldr	r3, [pc, #216]	; (800f10c <fCmdBuild_COPS+0x14c>)
 800f034:	881b      	ldrh	r3, [r3, #0]
 800f036:	8633      	strh	r3, [r6, #48]	; 0x30
 800f038:	e7f2      	b.n	800f020 <fCmdBuild_COPS+0x60>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0,,,%d",
 800f03a:	f8b7 260e 	ldrh.w	r2, [r7, #1550]	; 0x60e
 800f03e:	4934      	ldr	r1, [pc, #208]	; (800f110 <fCmdBuild_COPS+0x150>)
 800f040:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f044:	f016 fe14 	bl	8025c70 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800f048:	2400      	movs	r4, #0
 800f04a:	e7e9      	b.n	800f020 <fCmdBuild_COPS+0x60>
    else if ((operatorSelect->mode == CS_NRM_MANUAL) ||
 800f04c:	2b01      	cmp	r3, #1
 800f04e:	d02f      	beq.n	800f0b0 <fCmdBuild_COPS+0xf0>
 800f050:	2b04      	cmp	r3, #4
 800f052:	d02d      	beq.n	800f0b0 <fCmdBuild_COPS+0xf0>
    else if (operatorSelect->mode == CS_NRM_DEREGISTER)
 800f054:	2b02      	cmp	r3, #2
 800f056:	d04d      	beq.n	800f0f4 <fCmdBuild_COPS+0x134>
      PRINT_ERR("invalid mode value for +COPS")
 800f058:	4d2e      	ldr	r5, [pc, #184]	; (800f114 <fCmdBuild_COPS+0x154>)
 800f05a:	4c2b      	ldr	r4, [pc, #172]	; (800f108 <fCmdBuild_COPS+0x148>)
 800f05c:	f105 0c20 	add.w	ip, r5, #32
 800f060:	462f      	mov	r7, r5
 800f062:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800f064:	6020      	str	r0, [r4, #0]
 800f066:	6061      	str	r1, [r4, #4]
 800f068:	60a2      	str	r2, [r4, #8]
 800f06a:	60e3      	str	r3, [r4, #12]
 800f06c:	463d      	mov	r5, r7
 800f06e:	3410      	adds	r4, #16
 800f070:	4567      	cmp	r7, ip
 800f072:	d1f5      	bne.n	800f060 <fCmdBuild_COPS+0xa0>
 800f074:	cd07      	ldmia	r5!, {r0, r1, r2}
 800f076:	6020      	str	r0, [r4, #0]
 800f078:	6061      	str	r1, [r4, #4]
 800f07a:	60a2      	str	r2, [r4, #8]
 800f07c:	882b      	ldrh	r3, [r5, #0]
 800f07e:	81a3      	strh	r3, [r4, #12]
 800f080:	4c21      	ldr	r4, [pc, #132]	; (800f108 <fCmdBuild_COPS+0x148>)
 800f082:	4620      	mov	r0, r4
 800f084:	f010 f845 	bl	801f112 <crs_strlen>
 800f088:	b283      	uxth	r3, r0
 800f08a:	4622      	mov	r2, r4
 800f08c:	2110      	movs	r1, #16
 800f08e:	2002      	movs	r0, #2
 800f090:	f010 f882 	bl	801f198 <traceIF_itmPrint>
 800f094:	4620      	mov	r0, r4
 800f096:	f010 f83c 	bl	801f112 <crs_strlen>
 800f09a:	b283      	uxth	r3, r0
 800f09c:	4622      	mov	r2, r4
 800f09e:	2110      	movs	r1, #16
 800f0a0:	2002      	movs	r0, #2
 800f0a2:	f010 f89b 	bl	801f1dc <traceIF_uartPrint>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f0a6:	4b19      	ldr	r3, [pc, #100]	; (800f10c <fCmdBuild_COPS+0x14c>)
 800f0a8:	881b      	ldrh	r3, [r3, #0]
 800f0aa:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f0ac:	2400      	movs	r4, #0
 800f0ae:	e7b7      	b.n	800f020 <fCmdBuild_COPS+0x60>
      if (operatorSelect->mode == CS_NRM_MANUAL)
 800f0b0:	2b01      	cmp	r3, #1
 800f0b2:	d010      	beq.n	800f0d6 <fCmdBuild_COPS+0x116>
        selected_mode = 4U;
 800f0b4:	2204      	movs	r2, #4
      if (operatorSelect->format != CS_ONF_NOT_PRESENT)
 800f0b6:	f8b7 35ca 	ldrh.w	r3, [r7, #1482]	; 0x5ca
 800f0ba:	2b09      	cmp	r3, #9
 800f0bc:	d01f      	beq.n	800f0fe <fCmdBuild_COPS+0x13e>
        if (operatorSelect->AcT_present == CELLULAR_FALSE)
 800f0be:	f897 460c 	ldrb.w	r4, [r7, #1548]	; 0x60c
 800f0c2:	b954      	cbnz	r4, 800f0da <fCmdBuild_COPS+0x11a>
                         operatorSelect->operator_name);
 800f0c4:	f207 57cc 	addw	r7, r7, #1484	; 0x5cc
          (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d,\"%s\"",
 800f0c8:	9700      	str	r7, [sp, #0]
 800f0ca:	4913      	ldr	r1, [pc, #76]	; (800f118 <fCmdBuild_COPS+0x158>)
 800f0cc:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f0d0:	f016 fdce 	bl	8025c70 <sprintf>
 800f0d4:	e7a4      	b.n	800f020 <fCmdBuild_COPS+0x60>
        selected_mode = 1U;
 800f0d6:	2201      	movs	r2, #1
 800f0d8:	e7ed      	b.n	800f0b6 <fCmdBuild_COPS+0xf6>
                         operatorSelect->operator_name,
 800f0da:	f207 51cc 	addw	r1, r7, #1484	; 0x5cc
                         operatorSelect->AcT);
 800f0de:	f8b7 060e 	ldrh.w	r0, [r7, #1550]	; 0x60e
          (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d,\"%s\",%d",
 800f0e2:	9001      	str	r0, [sp, #4]
 800f0e4:	9100      	str	r1, [sp, #0]
 800f0e6:	490d      	ldr	r1, [pc, #52]	; (800f11c <fCmdBuild_COPS+0x15c>)
 800f0e8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f0ec:	f016 fdc0 	bl	8025c70 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800f0f0:	2400      	movs	r4, #0
 800f0f2:	e795      	b.n	800f020 <fCmdBuild_COPS+0x60>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "2");
 800f0f4:	4b0a      	ldr	r3, [pc, #40]	; (800f120 <fCmdBuild_COPS+0x160>)
 800f0f6:	881b      	ldrh	r3, [r3, #0]
 800f0f8:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f0fa:	2400      	movs	r4, #0
 800f0fc:	e790      	b.n	800f020 <fCmdBuild_COPS+0x60>
        retval = ATSTATUS_ERROR;
 800f0fe:	2401      	movs	r4, #1
 800f100:	e78e      	b.n	800f020 <fCmdBuild_COPS+0x60>
 800f102:	bf00      	nop
 800f104:	0802e808 	.word	0x0802e808
 800f108:	200048dc 	.word	0x200048dc
 800f10c:	080335d8 	.word	0x080335d8
 800f110:	0802e830 	.word	0x0802e830
 800f114:	0802e858 	.word	0x0802e858
 800f118:	0802e838 	.word	0x0802e838
 800f11c:	0802e844 	.word	0x0802e844
 800f120:	0802e854 	.word	0x0802e854

0800f124 <fCmdBuild_CGATT>:

at_status_t fCmdBuild_CGATT(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f124:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f126:	4606      	mov	r6, r0
 800f128:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGATT()")
 800f12a:	4d37      	ldr	r5, [pc, #220]	; (800f208 <fCmdBuild_CGATT+0xe4>)
 800f12c:	4c37      	ldr	r4, [pc, #220]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f12e:	f105 0e20 	add.w	lr, r5, #32
 800f132:	46ac      	mov	ip, r5
 800f134:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f138:	6020      	str	r0, [r4, #0]
 800f13a:	6061      	str	r1, [r4, #4]
 800f13c:	60a2      	str	r2, [r4, #8]
 800f13e:	60e3      	str	r3, [r4, #12]
 800f140:	4665      	mov	r5, ip
 800f142:	3410      	adds	r4, #16
 800f144:	45f4      	cmp	ip, lr
 800f146:	d1f4      	bne.n	800f132 <fCmdBuild_CGATT+0xe>
 800f148:	f8dc 0000 	ldr.w	r0, [ip]
 800f14c:	6020      	str	r0, [r4, #0]
 800f14e:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f152:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f156:	80a2      	strh	r2, [r4, #4]
 800f158:	71a3      	strb	r3, [r4, #6]
 800f15a:	4c2c      	ldr	r4, [pc, #176]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f15c:	4620      	mov	r0, r4
 800f15e:	f00f ffd8 	bl	801f112 <crs_strlen>
 800f162:	b283      	uxth	r3, r0
 800f164:	4622      	mov	r2, r4
 800f166:	2104      	movs	r1, #4
 800f168:	2002      	movs	r0, #2
 800f16a:	f010 f815 	bl	801f198 <traceIF_itmPrint>
 800f16e:	4620      	mov	r0, r4
 800f170:	f00f ffcf 	bl	801f112 <crs_strlen>
 800f174:	b283      	uxth	r3, r0
 800f176:	4622      	mov	r2, r4
 800f178:	2104      	movs	r1, #4
 800f17a:	2002      	movs	r0, #2
 800f17c:	f010 f82e 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f180:	8933      	ldrh	r3, [r6, #8]
 800f182:	2b03      	cmp	r3, #3
 800f184:	d001      	beq.n	800f18a <fCmdBuild_CGATT+0x66>
  at_status_t retval = ATSTATUS_OK;
 800f186:	2000      	movs	r0, #0
      retval = ATSTATUS_ERROR;
    }
  }

  return (retval);
}
 800f188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((p_modem_ctxt->CMD_ctxt.cgatt_write_cmd_param == CGATT_ATTACHED) ||
 800f18a:	f897 372d 	ldrb.w	r3, [r7, #1837]	; 0x72d
 800f18e:	2b01      	cmp	r3, #1
 800f190:	d00a      	beq.n	800f1a8 <fCmdBuild_CGATT+0x84>
        (p_atp_ctxt->current_SID == (at_msg_t) SID_ATTACH_PS_DOMAIN))
 800f192:	8832      	ldrh	r2, [r6, #0]
    if ((p_modem_ctxt->CMD_ctxt.cgatt_write_cmd_param == CGATT_ATTACHED) ||
 800f194:	2a70      	cmp	r2, #112	; 0x70
 800f196:	d007      	beq.n	800f1a8 <fCmdBuild_CGATT+0x84>
    else if ((p_modem_ctxt->CMD_ctxt.cgatt_write_cmd_param == CGATT_DETACHED) ||
 800f198:	b10b      	cbz	r3, 800f19e <fCmdBuild_CGATT+0x7a>
 800f19a:	2a71      	cmp	r2, #113	; 0x71
 800f19c:	d109      	bne.n	800f1b2 <fCmdBuild_CGATT+0x8e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f19e:	4b1c      	ldr	r3, [pc, #112]	; (800f210 <fCmdBuild_CGATT+0xec>)
 800f1a0:	881b      	ldrh	r3, [r3, #0]
 800f1a2:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f1a4:	2000      	movs	r0, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f1a6:	e7ef      	b.n	800f188 <fCmdBuild_CGATT+0x64>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f1a8:	4b1a      	ldr	r3, [pc, #104]	; (800f214 <fCmdBuild_CGATT+0xf0>)
 800f1aa:	881b      	ldrh	r3, [r3, #0]
 800f1ac:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f1ae:	2000      	movs	r0, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f1b0:	e7ea      	b.n	800f188 <fCmdBuild_CGATT+0x64>
      PRINT_ERR("CGATT state parameter not set")
 800f1b2:	4d19      	ldr	r5, [pc, #100]	; (800f218 <fCmdBuild_CGATT+0xf4>)
 800f1b4:	4c15      	ldr	r4, [pc, #84]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f1b6:	f105 0720 	add.w	r7, r5, #32
 800f1ba:	462e      	mov	r6, r5
 800f1bc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800f1be:	6020      	str	r0, [r4, #0]
 800f1c0:	6061      	str	r1, [r4, #4]
 800f1c2:	60a2      	str	r2, [r4, #8]
 800f1c4:	60e3      	str	r3, [r4, #12]
 800f1c6:	4635      	mov	r5, r6
 800f1c8:	3410      	adds	r4, #16
 800f1ca:	42be      	cmp	r6, r7
 800f1cc:	d1f5      	bne.n	800f1ba <fCmdBuild_CGATT+0x96>
 800f1ce:	cd07      	ldmia	r5!, {r0, r1, r2}
 800f1d0:	6020      	str	r0, [r4, #0]
 800f1d2:	6061      	str	r1, [r4, #4]
 800f1d4:	60a2      	str	r2, [r4, #8]
 800f1d6:	882a      	ldrh	r2, [r5, #0]
 800f1d8:	78ab      	ldrb	r3, [r5, #2]
 800f1da:	81a2      	strh	r2, [r4, #12]
 800f1dc:	73a3      	strb	r3, [r4, #14]
 800f1de:	4c0b      	ldr	r4, [pc, #44]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f1e0:	4620      	mov	r0, r4
 800f1e2:	f00f ff96 	bl	801f112 <crs_strlen>
 800f1e6:	b283      	uxth	r3, r0
 800f1e8:	4622      	mov	r2, r4
 800f1ea:	2110      	movs	r1, #16
 800f1ec:	2002      	movs	r0, #2
 800f1ee:	f00f ffd3 	bl	801f198 <traceIF_itmPrint>
 800f1f2:	4620      	mov	r0, r4
 800f1f4:	f00f ff8d 	bl	801f112 <crs_strlen>
 800f1f8:	b283      	uxth	r3, r0
 800f1fa:	4622      	mov	r2, r4
 800f1fc:	2110      	movs	r1, #16
 800f1fe:	2002      	movs	r0, #2
 800f200:	f00f ffec 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800f204:	2001      	movs	r0, #1
 800f206:	e7bf      	b.n	800f188 <fCmdBuild_CGATT+0x64>
 800f208:	0802e888 	.word	0x0802e888
 800f20c:	200048dc 	.word	0x200048dc
 800f210:	080335d8 	.word	0x080335d8
 800f214:	080335c4 	.word	0x080335c4
 800f218:	0802e8b0 	.word	0x0802e8b0

0800f21c <fCmdBuild_CREG>:

at_status_t fCmdBuild_CREG(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f21c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f21e:	4606      	mov	r6, r0
 800f220:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CREG()")
 800f222:	4d22      	ldr	r5, [pc, #136]	; (800f2ac <fCmdBuild_CREG+0x90>)
 800f224:	4c22      	ldr	r4, [pc, #136]	; (800f2b0 <fCmdBuild_CREG+0x94>)
 800f226:	f105 0e20 	add.w	lr, r5, #32
 800f22a:	46ac      	mov	ip, r5
 800f22c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f230:	6020      	str	r0, [r4, #0]
 800f232:	6061      	str	r1, [r4, #4]
 800f234:	60a2      	str	r2, [r4, #8]
 800f236:	60e3      	str	r3, [r4, #12]
 800f238:	4665      	mov	r5, ip
 800f23a:	3410      	adds	r4, #16
 800f23c:	45f4      	cmp	ip, lr
 800f23e:	d1f4      	bne.n	800f22a <fCmdBuild_CREG+0xe>
 800f240:	f8dc 0000 	ldr.w	r0, [ip]
 800f244:	6020      	str	r0, [r4, #0]
 800f246:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800f24a:	80a3      	strh	r3, [r4, #4]
 800f24c:	4c18      	ldr	r4, [pc, #96]	; (800f2b0 <fCmdBuild_CREG+0x94>)
 800f24e:	4620      	mov	r0, r4
 800f250:	f00f ff5f 	bl	801f112 <crs_strlen>
 800f254:	b283      	uxth	r3, r0
 800f256:	4622      	mov	r2, r4
 800f258:	2104      	movs	r1, #4
 800f25a:	2002      	movs	r0, #2
 800f25c:	f00f ff9c 	bl	801f198 <traceIF_itmPrint>
 800f260:	4620      	mov	r0, r4
 800f262:	f00f ff56 	bl	801f112 <crs_strlen>
 800f266:	b283      	uxth	r3, r0
 800f268:	4622      	mov	r2, r4
 800f26a:	2104      	movs	r1, #4
 800f26c:	2002      	movs	r0, #2
 800f26e:	f00f ffb5 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f272:	8933      	ldrh	r3, [r6, #8]
 800f274:	2b03      	cmp	r3, #3
 800f276:	d001      	beq.n	800f27c <fCmdBuild_CREG+0x60>
                     (uint8_t) p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param);
    }
  }

  return (retval);
}
 800f278:	2000      	movs	r0, #0
 800f27a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT)
 800f27c:	8833      	ldrh	r3, [r6, #0]
 800f27e:	2b6a      	cmp	r3, #106	; 0x6a
 800f280:	d009      	beq.n	800f296 <fCmdBuild_CREG+0x7a>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_UNSUSBCRIBE_NET_EVENT)
 800f282:	2b6b      	cmp	r3, #107	; 0x6b
 800f284:	d00e      	beq.n	800f2a4 <fCmdBuild_CREG+0x88>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800f286:	f897 272e 	ldrb.w	r2, [r7, #1838]	; 0x72e
 800f28a:	490a      	ldr	r1, [pc, #40]	; (800f2b4 <fCmdBuild_CREG+0x98>)
 800f28c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f290:	f016 fcee 	bl	8025c70 <sprintf>
 800f294:	e7f0      	b.n	800f278 <fCmdBuild_CREG+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", (uint8_t)CXREG_ENABLE_NETWK_REG_LOC_URC);
 800f296:	2202      	movs	r2, #2
 800f298:	4906      	ldr	r1, [pc, #24]	; (800f2b4 <fCmdBuild_CREG+0x98>)
 800f29a:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f29e:	f016 fce7 	bl	8025c70 <sprintf>
 800f2a2:	e7e9      	b.n	800f278 <fCmdBuild_CREG+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f2a4:	4b04      	ldr	r3, [pc, #16]	; (800f2b8 <fCmdBuild_CREG+0x9c>)
 800f2a6:	881b      	ldrh	r3, [r3, #0]
 800f2a8:	8633      	strh	r3, [r6, #48]	; 0x30
 800f2aa:	e7e5      	b.n	800f278 <fCmdBuild_CREG+0x5c>
 800f2ac:	0802e8e0 	.word	0x0802e8e0
 800f2b0:	200048dc 	.word	0x200048dc
 800f2b4:	0802e834 	.word	0x0802e834
 800f2b8:	080335d8 	.word	0x080335d8

0800f2bc <fCmdBuild_CGREG>:

at_status_t fCmdBuild_CGREG(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f2bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f2be:	4606      	mov	r6, r0
 800f2c0:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGREG()")
 800f2c2:	4d26      	ldr	r5, [pc, #152]	; (800f35c <fCmdBuild_CGREG+0xa0>)
 800f2c4:	4c26      	ldr	r4, [pc, #152]	; (800f360 <fCmdBuild_CGREG+0xa4>)
 800f2c6:	f105 0e20 	add.w	lr, r5, #32
 800f2ca:	46ac      	mov	ip, r5
 800f2cc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f2d0:	6020      	str	r0, [r4, #0]
 800f2d2:	6061      	str	r1, [r4, #4]
 800f2d4:	60a2      	str	r2, [r4, #8]
 800f2d6:	60e3      	str	r3, [r4, #12]
 800f2d8:	4665      	mov	r5, ip
 800f2da:	3410      	adds	r4, #16
 800f2dc:	45f4      	cmp	ip, lr
 800f2de:	d1f4      	bne.n	800f2ca <fCmdBuild_CGREG+0xe>
 800f2e0:	f8dc 0000 	ldr.w	r0, [ip]
 800f2e4:	6020      	str	r0, [r4, #0]
 800f2e6:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f2ea:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f2ee:	80a2      	strh	r2, [r4, #4]
 800f2f0:	71a3      	strb	r3, [r4, #6]
 800f2f2:	4c1b      	ldr	r4, [pc, #108]	; (800f360 <fCmdBuild_CGREG+0xa4>)
 800f2f4:	4620      	mov	r0, r4
 800f2f6:	f00f ff0c 	bl	801f112 <crs_strlen>
 800f2fa:	b283      	uxth	r3, r0
 800f2fc:	4622      	mov	r2, r4
 800f2fe:	2104      	movs	r1, #4
 800f300:	2002      	movs	r0, #2
 800f302:	f00f ff49 	bl	801f198 <traceIF_itmPrint>
 800f306:	4620      	mov	r0, r4
 800f308:	f00f ff03 	bl	801f112 <crs_strlen>
 800f30c:	b283      	uxth	r3, r0
 800f30e:	4622      	mov	r2, r4
 800f310:	2104      	movs	r1, #4
 800f312:	2002      	movs	r0, #2
 800f314:	f00f ff62 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f318:	8933      	ldrh	r3, [r6, #8]
 800f31a:	2b03      	cmp	r3, #3
 800f31c:	d001      	beq.n	800f322 <fCmdBuild_CGREG+0x66>
                     (uint8_t) p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param);
    }
  }

  return (retval);
}
 800f31e:	2000      	movs	r0, #0
 800f320:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT)
 800f322:	8833      	ldrh	r3, [r6, #0]
 800f324:	2b6a      	cmp	r3, #106	; 0x6a
 800f326:	d009      	beq.n	800f33c <fCmdBuild_CGREG+0x80>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_UNSUSBCRIBE_NET_EVENT)
 800f328:	2b6b      	cmp	r3, #107	; 0x6b
 800f32a:	d013      	beq.n	800f354 <fCmdBuild_CGREG+0x98>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800f32c:	f897 272e 	ldrb.w	r2, [r7, #1838]	; 0x72e
 800f330:	490c      	ldr	r1, [pc, #48]	; (800f364 <fCmdBuild_CGREG+0xa8>)
 800f332:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f336:	f016 fc9b 	bl	8025c70 <sprintf>
 800f33a:	e7f0      	b.n	800f31e <fCmdBuild_CGREG+0x62>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800f33c:	f897 350d 	ldrb.w	r3, [r7, #1293]	; 0x50d
 800f340:	b133      	cbz	r3, 800f350 <fCmdBuild_CGREG+0x94>
        param_value = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800f342:	2204      	movs	r2, #4
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", (uint8_t) param_value);
 800f344:	4907      	ldr	r1, [pc, #28]	; (800f364 <fCmdBuild_CGREG+0xa8>)
 800f346:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f34a:	f016 fc91 	bl	8025c70 <sprintf>
 800f34e:	e7e6      	b.n	800f31e <fCmdBuild_CGREG+0x62>
        param_value = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800f350:	2202      	movs	r2, #2
 800f352:	e7f7      	b.n	800f344 <fCmdBuild_CGREG+0x88>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f354:	4b04      	ldr	r3, [pc, #16]	; (800f368 <fCmdBuild_CGREG+0xac>)
 800f356:	881b      	ldrh	r3, [r3, #0]
 800f358:	8633      	strh	r3, [r6, #48]	; 0x30
 800f35a:	e7e0      	b.n	800f31e <fCmdBuild_CGREG+0x62>
 800f35c:	0802e908 	.word	0x0802e908
 800f360:	200048dc 	.word	0x200048dc
 800f364:	0802e834 	.word	0x0802e834
 800f368:	080335d8 	.word	0x080335d8

0800f36c <fCmdBuild_CEREG>:

at_status_t fCmdBuild_CEREG(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f36c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f36e:	4606      	mov	r6, r0
 800f370:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CEREG()")
 800f372:	4d26      	ldr	r5, [pc, #152]	; (800f40c <fCmdBuild_CEREG+0xa0>)
 800f374:	4c26      	ldr	r4, [pc, #152]	; (800f410 <fCmdBuild_CEREG+0xa4>)
 800f376:	f105 0e20 	add.w	lr, r5, #32
 800f37a:	46ac      	mov	ip, r5
 800f37c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f380:	6020      	str	r0, [r4, #0]
 800f382:	6061      	str	r1, [r4, #4]
 800f384:	60a2      	str	r2, [r4, #8]
 800f386:	60e3      	str	r3, [r4, #12]
 800f388:	4665      	mov	r5, ip
 800f38a:	3410      	adds	r4, #16
 800f38c:	45f4      	cmp	ip, lr
 800f38e:	d1f4      	bne.n	800f37a <fCmdBuild_CEREG+0xe>
 800f390:	f8dc 0000 	ldr.w	r0, [ip]
 800f394:	6020      	str	r0, [r4, #0]
 800f396:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f39a:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f39e:	80a2      	strh	r2, [r4, #4]
 800f3a0:	71a3      	strb	r3, [r4, #6]
 800f3a2:	4c1b      	ldr	r4, [pc, #108]	; (800f410 <fCmdBuild_CEREG+0xa4>)
 800f3a4:	4620      	mov	r0, r4
 800f3a6:	f00f feb4 	bl	801f112 <crs_strlen>
 800f3aa:	b283      	uxth	r3, r0
 800f3ac:	4622      	mov	r2, r4
 800f3ae:	2104      	movs	r1, #4
 800f3b0:	2002      	movs	r0, #2
 800f3b2:	f00f fef1 	bl	801f198 <traceIF_itmPrint>
 800f3b6:	4620      	mov	r0, r4
 800f3b8:	f00f feab 	bl	801f112 <crs_strlen>
 800f3bc:	b283      	uxth	r3, r0
 800f3be:	4622      	mov	r2, r4
 800f3c0:	2104      	movs	r1, #4
 800f3c2:	2002      	movs	r0, #2
 800f3c4:	f00f ff0a 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f3c8:	8933      	ldrh	r3, [r6, #8]
 800f3ca:	2b03      	cmp	r3, #3
 800f3cc:	d001      	beq.n	800f3d2 <fCmdBuild_CEREG+0x66>
                     (uint8_t) p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param);
    }
  }

  return (retval);
}
 800f3ce:	2000      	movs	r0, #0
 800f3d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT)
 800f3d2:	8833      	ldrh	r3, [r6, #0]
 800f3d4:	2b6a      	cmp	r3, #106	; 0x6a
 800f3d6:	d009      	beq.n	800f3ec <fCmdBuild_CEREG+0x80>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_UNSUSBCRIBE_NET_EVENT)
 800f3d8:	2b6b      	cmp	r3, #107	; 0x6b
 800f3da:	d013      	beq.n	800f404 <fCmdBuild_CEREG+0x98>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800f3dc:	f897 272e 	ldrb.w	r2, [r7, #1838]	; 0x72e
 800f3e0:	490c      	ldr	r1, [pc, #48]	; (800f414 <fCmdBuild_CEREG+0xa8>)
 800f3e2:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f3e6:	f016 fc43 	bl	8025c70 <sprintf>
 800f3ea:	e7f0      	b.n	800f3ce <fCmdBuild_CEREG+0x62>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800f3ec:	f897 350d 	ldrb.w	r3, [r7, #1293]	; 0x50d
 800f3f0:	b133      	cbz	r3, 800f400 <fCmdBuild_CEREG+0x94>
        param_value = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800f3f2:	2204      	movs	r2, #4
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", (uint8_t)param_value);
 800f3f4:	4907      	ldr	r1, [pc, #28]	; (800f414 <fCmdBuild_CEREG+0xa8>)
 800f3f6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f3fa:	f016 fc39 	bl	8025c70 <sprintf>
 800f3fe:	e7e6      	b.n	800f3ce <fCmdBuild_CEREG+0x62>
        param_value = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800f400:	2202      	movs	r2, #2
 800f402:	e7f7      	b.n	800f3f4 <fCmdBuild_CEREG+0x88>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f404:	4b04      	ldr	r3, [pc, #16]	; (800f418 <fCmdBuild_CEREG+0xac>)
 800f406:	881b      	ldrh	r3, [r3, #0]
 800f408:	8633      	strh	r3, [r6, #48]	; 0x30
 800f40a:	e7e0      	b.n	800f3ce <fCmdBuild_CEREG+0x62>
 800f40c:	0802e930 	.word	0x0802e930
 800f410:	200048dc 	.word	0x200048dc
 800f414:	0802e834 	.word	0x0802e834
 800f418:	080335d8 	.word	0x080335d8

0800f41c <fCmdBuild_CGEREP>:

at_status_t fCmdBuild_CGEREP(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f41c:	b570      	push	{r4, r5, r6, lr}
 800f41e:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGEREP()")
 800f420:	4c1b      	ldr	r4, [pc, #108]	; (800f490 <fCmdBuild_CGEREP+0x74>)
 800f422:	4d1c      	ldr	r5, [pc, #112]	; (800f494 <fCmdBuild_CGEREP+0x78>)
 800f424:	f104 0e20 	add.w	lr, r4, #32
 800f428:	46a4      	mov	ip, r4
 800f42a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f42e:	6028      	str	r0, [r5, #0]
 800f430:	6069      	str	r1, [r5, #4]
 800f432:	60aa      	str	r2, [r5, #8]
 800f434:	60eb      	str	r3, [r5, #12]
 800f436:	4664      	mov	r4, ip
 800f438:	3510      	adds	r5, #16
 800f43a:	45f4      	cmp	ip, lr
 800f43c:	d1f4      	bne.n	800f428 <fCmdBuild_CGEREP+0xc>
 800f43e:	cc03      	ldmia	r4!, {r0, r1}
 800f440:	6028      	str	r0, [r5, #0]
 800f442:	6069      	str	r1, [r5, #4]
 800f444:	4c13      	ldr	r4, [pc, #76]	; (800f494 <fCmdBuild_CGEREP+0x78>)
 800f446:	4620      	mov	r0, r4
 800f448:	f00f fe63 	bl	801f112 <crs_strlen>
 800f44c:	b283      	uxth	r3, r0
 800f44e:	4622      	mov	r2, r4
 800f450:	2104      	movs	r1, #4
 800f452:	2002      	movs	r0, #2
 800f454:	f00f fea0 	bl	801f198 <traceIF_itmPrint>
 800f458:	4620      	mov	r0, r4
 800f45a:	f00f fe5a 	bl	801f112 <crs_strlen>
 800f45e:	b283      	uxth	r3, r0
 800f460:	4622      	mov	r2, r4
 800f462:	2104      	movs	r1, #4
 800f464:	2002      	movs	r0, #2
 800f466:	f00f feb9 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f46a:	8933      	ldrh	r3, [r6, #8]
 800f46c:	2b03      	cmp	r3, #3
 800f46e:	d001      	beq.n	800f474 <fCmdBuild_CGEREP+0x58>
      /* nothing to do */
    }
  }

  return (retval);
}
 800f470:	2000      	movs	r0, #0
 800f472:	bd70      	pop	{r4, r5, r6, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_REGISTER_PDN_EVENT)
 800f474:	8833      	ldrh	r3, [r6, #0]
 800f476:	2b73      	cmp	r3, #115	; 0x73
 800f478:	d005      	beq.n	800f486 <fCmdBuild_CGEREP+0x6a>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_DEREGISTER_PDN_EVENT)
 800f47a:	2b74      	cmp	r3, #116	; 0x74
 800f47c:	d1f8      	bne.n	800f470 <fCmdBuild_CGEREP+0x54>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f47e:	4b06      	ldr	r3, [pc, #24]	; (800f498 <fCmdBuild_CGEREP+0x7c>)
 800f480:	881b      	ldrh	r3, [r3, #0]
 800f482:	8633      	strh	r3, [r6, #48]	; 0x30
 800f484:	e7f4      	b.n	800f470 <fCmdBuild_CGEREP+0x54>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1,0");
 800f486:	4b05      	ldr	r3, [pc, #20]	; (800f49c <fCmdBuild_CGEREP+0x80>)
 800f488:	6818      	ldr	r0, [r3, #0]
 800f48a:	6330      	str	r0, [r6, #48]	; 0x30
 800f48c:	e7f0      	b.n	800f470 <fCmdBuild_CGEREP+0x54>
 800f48e:	bf00      	nop
 800f490:	0802e958 	.word	0x0802e958
 800f494:	200048dc 	.word	0x200048dc
 800f498:	080335d8 	.word	0x080335d8
 800f49c:	0802e980 	.word	0x0802e980

0800f4a0 <fCmdBuild_CGDCONT>:

at_status_t fCmdBuild_CGDCONT(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f4a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f4a4:	b082      	sub	sp, #8
 800f4a6:	4607      	mov	r7, r0
 800f4a8:	460e      	mov	r6, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGDCONT()")
 800f4aa:	4c45      	ldr	r4, [pc, #276]	; (800f5c0 <fCmdBuild_CGDCONT+0x120>)
 800f4ac:	4d45      	ldr	r5, [pc, #276]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f4ae:	f104 0e20 	add.w	lr, r4, #32
 800f4b2:	46a4      	mov	ip, r4
 800f4b4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f4b8:	6028      	str	r0, [r5, #0]
 800f4ba:	6069      	str	r1, [r5, #4]
 800f4bc:	60aa      	str	r2, [r5, #8]
 800f4be:	60eb      	str	r3, [r5, #12]
 800f4c0:	4664      	mov	r4, ip
 800f4c2:	3510      	adds	r5, #16
 800f4c4:	45f4      	cmp	ip, lr
 800f4c6:	d1f4      	bne.n	800f4b2 <fCmdBuild_CGDCONT+0x12>
 800f4c8:	cc03      	ldmia	r4!, {r0, r1}
 800f4ca:	6028      	str	r0, [r5, #0]
 800f4cc:	6069      	str	r1, [r5, #4]
 800f4ce:	7823      	ldrb	r3, [r4, #0]
 800f4d0:	722b      	strb	r3, [r5, #8]
 800f4d2:	4c3c      	ldr	r4, [pc, #240]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f4d4:	4620      	mov	r0, r4
 800f4d6:	f00f fe1c 	bl	801f112 <crs_strlen>
 800f4da:	b283      	uxth	r3, r0
 800f4dc:	4622      	mov	r2, r4
 800f4de:	2104      	movs	r1, #4
 800f4e0:	2002      	movs	r0, #2
 800f4e2:	f00f fe59 	bl	801f198 <traceIF_itmPrint>
 800f4e6:	4620      	mov	r0, r4
 800f4e8:	f00f fe13 	bl	801f112 <crs_strlen>
 800f4ec:	b283      	uxth	r3, r0
 800f4ee:	4622      	mov	r2, r4
 800f4f0:	2104      	movs	r1, #4
 800f4f2:	2002      	movs	r0, #2
 800f4f4:	f00f fe72 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f4f8:	893b      	ldrh	r3, [r7, #8]
 800f4fa:	2b03      	cmp	r3, #3
 800f4fc:	d003      	beq.n	800f506 <fCmdBuild_CGDCONT+0x66>
  at_status_t retval = ATSTATUS_OK;
 800f4fe:	2000      	movs	r0, #0
      retval = ATSTATUS_ERROR;
    }
  }

  return (retval);
}
 800f500:	b002      	add	sp, #8
 800f502:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f506:	4630      	mov	r0, r6
 800f508:	f7fd f9d4 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f50c:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f50e:	4601      	mov	r1, r0
 800f510:	f106 000c 	add.w	r0, r6, #12
 800f514:	f7fe fa56 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f518:	4680      	mov	r8, r0
    PRINT_INFO("user cid = %d, modem cid = %d", (uint8_t)current_conf_id, modem_cid)
 800f51a:	4d2a      	ldr	r5, [pc, #168]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f51c:	4603      	mov	r3, r0
 800f51e:	4622      	mov	r2, r4
 800f520:	4929      	ldr	r1, [pc, #164]	; (800f5c8 <fCmdBuild_CGDCONT+0x128>)
 800f522:	4628      	mov	r0, r5
 800f524:	f016 fba4 	bl	8025c70 <sprintf>
 800f528:	4628      	mov	r0, r5
 800f52a:	f00f fdf2 	bl	801f112 <crs_strlen>
 800f52e:	b283      	uxth	r3, r0
 800f530:	462a      	mov	r2, r5
 800f532:	2101      	movs	r1, #1
 800f534:	2002      	movs	r0, #2
 800f536:	f00f fe2f 	bl	801f198 <traceIF_itmPrint>
 800f53a:	4628      	mov	r0, r5
 800f53c:	f00f fde9 	bl	801f112 <crs_strlen>
 800f540:	b283      	uxth	r3, r0
 800f542:	462a      	mov	r2, r5
 800f544:	2101      	movs	r1, #1
 800f546:	2002      	movs	r0, #2
 800f548:	f00f fe48 	bl	801f1dc <traceIF_uartPrint>
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id != CS_PDN_NOT_DEFINED)
 800f54c:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f550:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800f554:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f558:	2b0c      	cmp	r3, #12
 800f55a:	d017      	beq.n	800f58c <fCmdBuild_CGDCONT+0xec>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 800f55c:	3730      	adds	r7, #48	; 0x30
 800f55e:	01a5      	lsls	r5, r4, #6
 800f560:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f564:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800f568:	f893 0091 	ldrb.w	r0, [r3, #145]	; 0x91
 800f56c:	f7fd fa50 	bl	800ca10 <atcm_get_PDPtypeStr>
 800f570:	4603      	mov	r3, r0
                     p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].apn);
 800f572:	4425      	add	r5, r4
 800f574:	006d      	lsls	r5, r5, #1
 800f576:	3548      	adds	r5, #72	; 0x48
 800f578:	442e      	add	r6, r5
 800f57a:	3609      	adds	r6, #9
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 800f57c:	9600      	str	r6, [sp, #0]
 800f57e:	4642      	mov	r2, r8
 800f580:	4912      	ldr	r1, [pc, #72]	; (800f5cc <fCmdBuild_CGDCONT+0x12c>)
 800f582:	4638      	mov	r0, r7
 800f584:	f016 fb74 	bl	8025c70 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800f588:	2000      	movs	r0, #0
 800f58a:	e7b9      	b.n	800f500 <fCmdBuild_CGDCONT+0x60>
      PRINT_ERR("PDP context not defined for conf_id %d", current_conf_id)
 800f58c:	4d0d      	ldr	r5, [pc, #52]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f58e:	4622      	mov	r2, r4
 800f590:	490f      	ldr	r1, [pc, #60]	; (800f5d0 <fCmdBuild_CGDCONT+0x130>)
 800f592:	4628      	mov	r0, r5
 800f594:	f016 fb6c 	bl	8025c70 <sprintf>
 800f598:	4628      	mov	r0, r5
 800f59a:	f00f fdba 	bl	801f112 <crs_strlen>
 800f59e:	b283      	uxth	r3, r0
 800f5a0:	462a      	mov	r2, r5
 800f5a2:	2110      	movs	r1, #16
 800f5a4:	2002      	movs	r0, #2
 800f5a6:	f00f fdf7 	bl	801f198 <traceIF_itmPrint>
 800f5aa:	4628      	mov	r0, r5
 800f5ac:	f00f fdb1 	bl	801f112 <crs_strlen>
 800f5b0:	b283      	uxth	r3, r0
 800f5b2:	462a      	mov	r2, r5
 800f5b4:	2110      	movs	r1, #16
 800f5b6:	2002      	movs	r0, #2
 800f5b8:	f00f fe10 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800f5bc:	2001      	movs	r0, #1
 800f5be:	e79f      	b.n	800f500 <fCmdBuild_CGDCONT+0x60>
 800f5c0:	0802e984 	.word	0x0802e984
 800f5c4:	200048dc 	.word	0x200048dc
 800f5c8:	0802e9b0 	.word	0x0802e9b0
 800f5cc:	0802a95c 	.word	0x0802a95c
 800f5d0:	0802e9dc 	.word	0x0802e9dc

0800f5d4 <fCmdBuild_CGACT>:

at_status_t fCmdBuild_CGACT(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f5d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f5d8:	4606      	mov	r6, r0
 800f5da:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGACT()")
 800f5dc:	4d34      	ldr	r5, [pc, #208]	; (800f6b0 <fCmdBuild_CGACT+0xdc>)
 800f5de:	4c35      	ldr	r4, [pc, #212]	; (800f6b4 <fCmdBuild_CGACT+0xe0>)
 800f5e0:	f105 0e20 	add.w	lr, r5, #32
 800f5e4:	46ac      	mov	ip, r5
 800f5e6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f5ea:	6020      	str	r0, [r4, #0]
 800f5ec:	6061      	str	r1, [r4, #4]
 800f5ee:	60a2      	str	r2, [r4, #8]
 800f5f0:	60e3      	str	r3, [r4, #12]
 800f5f2:	4665      	mov	r5, ip
 800f5f4:	3410      	adds	r4, #16
 800f5f6:	45f4      	cmp	ip, lr
 800f5f8:	d1f4      	bne.n	800f5e4 <fCmdBuild_CGACT+0x10>
 800f5fa:	f8dc 0000 	ldr.w	r0, [ip]
 800f5fe:	6020      	str	r0, [r4, #0]
 800f600:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f604:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f608:	80a2      	strh	r2, [r4, #4]
 800f60a:	71a3      	strb	r3, [r4, #6]
 800f60c:	4c29      	ldr	r4, [pc, #164]	; (800f6b4 <fCmdBuild_CGACT+0xe0>)
 800f60e:	4620      	mov	r0, r4
 800f610:	f00f fd7f 	bl	801f112 <crs_strlen>
 800f614:	b283      	uxth	r3, r0
 800f616:	4622      	mov	r2, r4
 800f618:	2104      	movs	r1, #4
 800f61a:	2002      	movs	r0, #2
 800f61c:	f00f fdbc 	bl	801f198 <traceIF_itmPrint>
 800f620:	4620      	mov	r0, r4
 800f622:	f00f fd76 	bl	801f112 <crs_strlen>
 800f626:	b283      	uxth	r3, r0
 800f628:	4622      	mov	r2, r4
 800f62a:	2104      	movs	r1, #4
 800f62c:	2002      	movs	r0, #2
 800f62e:	f00f fdd5 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f632:	8933      	ldrh	r3, [r6, #8]
 800f634:	2b03      	cmp	r3, #3
 800f636:	d002      	beq.n	800f63e <fCmdBuild_CGACT+0x6a>
                   ((p_modem_ctxt->CMD_ctxt.pdn_state == PDN_STATE_ACTIVATE) ? 1 : 0),
                   modem_cid);
  }

  return (retval);
}
 800f638:	2000      	movs	r0, #0
 800f63a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f63e:	4638      	mov	r0, r7
 800f640:	f7fd f938 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f644:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f646:	4601      	mov	r1, r0
 800f648:	f107 000c 	add.w	r0, r7, #12
 800f64c:	f7fe f9ba 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f650:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 800f652:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f656:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 800f65a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f65e:	2b0c      	cmp	r3, #12
 800f660:	d00c      	beq.n	800f67c <fCmdBuild_CGACT+0xa8>
                   ((p_modem_ctxt->CMD_ctxt.pdn_state == PDN_STATE_ACTIVATE) ? 1 : 0),
 800f662:	f897 2731 	ldrb.w	r2, [r7, #1841]	; 0x731
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d",
 800f666:	462b      	mov	r3, r5
 800f668:	2a01      	cmp	r2, #1
 800f66a:	bf14      	ite	ne
 800f66c:	2200      	movne	r2, #0
 800f66e:	2201      	moveq	r2, #1
 800f670:	4911      	ldr	r1, [pc, #68]	; (800f6b8 <fCmdBuild_CGACT+0xe4>)
 800f672:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f676:	f016 fafb 	bl	8025c70 <sprintf>
 800f67a:	e7dd      	b.n	800f638 <fCmdBuild_CGACT+0x64>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 800f67c:	f8df 8034 	ldr.w	r8, [pc, #52]	; 800f6b4 <fCmdBuild_CGACT+0xe0>
 800f680:	4622      	mov	r2, r4
 800f682:	490e      	ldr	r1, [pc, #56]	; (800f6bc <fCmdBuild_CGACT+0xe8>)
 800f684:	4640      	mov	r0, r8
 800f686:	f016 faf3 	bl	8025c70 <sprintf>
 800f68a:	4640      	mov	r0, r8
 800f68c:	f00f fd41 	bl	801f112 <crs_strlen>
 800f690:	b283      	uxth	r3, r0
 800f692:	4642      	mov	r2, r8
 800f694:	2101      	movs	r1, #1
 800f696:	2002      	movs	r0, #2
 800f698:	f00f fd7e 	bl	801f198 <traceIF_itmPrint>
 800f69c:	4640      	mov	r0, r8
 800f69e:	f00f fd38 	bl	801f112 <crs_strlen>
 800f6a2:	b283      	uxth	r3, r0
 800f6a4:	4642      	mov	r2, r8
 800f6a6:	2101      	movs	r1, #1
 800f6a8:	2002      	movs	r0, #2
 800f6aa:	f00f fd97 	bl	801f1dc <traceIF_uartPrint>
 800f6ae:	e7d8      	b.n	800f662 <fCmdBuild_CGACT+0x8e>
 800f6b0:	0802ea14 	.word	0x0802ea14
 800f6b4:	200048dc 	.word	0x200048dc
 800f6b8:	0802ac14 	.word	0x0802ac14
 800f6bc:	0802ea3c 	.word	0x0802ea3c

0800f6c0 <fCmdBuild_CGDATA>:

  return (retval);
}

at_status_t fCmdBuild_CGDATA(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f6c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f6c2:	4606      	mov	r6, r0
 800f6c4:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGDATA()")
 800f6c6:	4c2e      	ldr	r4, [pc, #184]	; (800f780 <fCmdBuild_CGDATA+0xc0>)
 800f6c8:	4d2e      	ldr	r5, [pc, #184]	; (800f784 <fCmdBuild_CGDATA+0xc4>)
 800f6ca:	f104 0e20 	add.w	lr, r4, #32
 800f6ce:	46a4      	mov	ip, r4
 800f6d0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f6d4:	6028      	str	r0, [r5, #0]
 800f6d6:	6069      	str	r1, [r5, #4]
 800f6d8:	60aa      	str	r2, [r5, #8]
 800f6da:	60eb      	str	r3, [r5, #12]
 800f6dc:	4664      	mov	r4, ip
 800f6de:	3510      	adds	r5, #16
 800f6e0:	45f4      	cmp	ip, lr
 800f6e2:	d1f4      	bne.n	800f6ce <fCmdBuild_CGDATA+0xe>
 800f6e4:	cc03      	ldmia	r4!, {r0, r1}
 800f6e6:	6028      	str	r0, [r5, #0]
 800f6e8:	6069      	str	r1, [r5, #4]
 800f6ea:	4c26      	ldr	r4, [pc, #152]	; (800f784 <fCmdBuild_CGDATA+0xc4>)
 800f6ec:	4620      	mov	r0, r4
 800f6ee:	f00f fd10 	bl	801f112 <crs_strlen>
 800f6f2:	b283      	uxth	r3, r0
 800f6f4:	4622      	mov	r2, r4
 800f6f6:	2104      	movs	r1, #4
 800f6f8:	2002      	movs	r0, #2
 800f6fa:	f00f fd4d 	bl	801f198 <traceIF_itmPrint>
 800f6fe:	4620      	mov	r0, r4
 800f700:	f00f fd07 	bl	801f112 <crs_strlen>
 800f704:	b283      	uxth	r3, r0
 800f706:	4622      	mov	r2, r4
 800f708:	2104      	movs	r1, #4
 800f70a:	2002      	movs	r0, #2
 800f70c:	f00f fd66 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f710:	8933      	ldrh	r3, [r6, #8]
 800f712:	2b03      	cmp	r3, #3
 800f714:	d001      	beq.n	800f71a <fCmdBuild_CGDATA+0x5a>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"PPP\",%d",
                   modem_cid);
  }

  return (retval);
}
 800f716:	2000      	movs	r0, #0
 800f718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f71a:	4638      	mov	r0, r7
 800f71c:	f7fd f8ca 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f720:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f722:	4601      	mov	r1, r0
 800f724:	f107 000c 	add.w	r0, r7, #12
 800f728:	f7fe f94c 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f72c:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 800f72e:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f732:	eb07 0743 	add.w	r7, r7, r3, lsl #1
 800f736:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800f73a:	2b0c      	cmp	r3, #12
 800f73c:	d006      	beq.n	800f74c <fCmdBuild_CGDATA+0x8c>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"PPP\",%d",
 800f73e:	462a      	mov	r2, r5
 800f740:	4911      	ldr	r1, [pc, #68]	; (800f788 <fCmdBuild_CGDATA+0xc8>)
 800f742:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f746:	f016 fa93 	bl	8025c70 <sprintf>
 800f74a:	e7e4      	b.n	800f716 <fCmdBuild_CGDATA+0x56>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 800f74c:	4f0d      	ldr	r7, [pc, #52]	; (800f784 <fCmdBuild_CGDATA+0xc4>)
 800f74e:	4622      	mov	r2, r4
 800f750:	490e      	ldr	r1, [pc, #56]	; (800f78c <fCmdBuild_CGDATA+0xcc>)
 800f752:	4638      	mov	r0, r7
 800f754:	f016 fa8c 	bl	8025c70 <sprintf>
 800f758:	4638      	mov	r0, r7
 800f75a:	f00f fcda 	bl	801f112 <crs_strlen>
 800f75e:	b283      	uxth	r3, r0
 800f760:	463a      	mov	r2, r7
 800f762:	2101      	movs	r1, #1
 800f764:	2002      	movs	r0, #2
 800f766:	f00f fd17 	bl	801f198 <traceIF_itmPrint>
 800f76a:	4638      	mov	r0, r7
 800f76c:	f00f fcd1 	bl	801f112 <crs_strlen>
 800f770:	b283      	uxth	r3, r0
 800f772:	463a      	mov	r2, r7
 800f774:	2101      	movs	r1, #1
 800f776:	2002      	movs	r0, #2
 800f778:	f00f fd30 	bl	801f1dc <traceIF_uartPrint>
 800f77c:	e7df      	b.n	800f73e <fCmdBuild_CGDATA+0x7e>
 800f77e:	bf00      	nop
 800f780:	0802ea90 	.word	0x0802ea90
 800f784:	200048dc 	.word	0x200048dc
 800f788:	0802eab8 	.word	0x0802eab8
 800f78c:	0802ea3c 	.word	0x0802ea3c

0800f790 <fCmdBuild_CGPADDR>:

at_status_t fCmdBuild_CGPADDR(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f792:	4606      	mov	r6, r0
 800f794:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGPADDR()")
 800f796:	4c2f      	ldr	r4, [pc, #188]	; (800f854 <fCmdBuild_CGPADDR+0xc4>)
 800f798:	4d2f      	ldr	r5, [pc, #188]	; (800f858 <fCmdBuild_CGPADDR+0xc8>)
 800f79a:	f104 0e20 	add.w	lr, r4, #32
 800f79e:	46a4      	mov	ip, r4
 800f7a0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f7a4:	6028      	str	r0, [r5, #0]
 800f7a6:	6069      	str	r1, [r5, #4]
 800f7a8:	60aa      	str	r2, [r5, #8]
 800f7aa:	60eb      	str	r3, [r5, #12]
 800f7ac:	4664      	mov	r4, ip
 800f7ae:	3510      	adds	r5, #16
 800f7b0:	45f4      	cmp	ip, lr
 800f7b2:	d1f4      	bne.n	800f79e <fCmdBuild_CGPADDR+0xe>
 800f7b4:	cc03      	ldmia	r4!, {r0, r1}
 800f7b6:	6028      	str	r0, [r5, #0]
 800f7b8:	6069      	str	r1, [r5, #4]
 800f7ba:	7823      	ldrb	r3, [r4, #0]
 800f7bc:	722b      	strb	r3, [r5, #8]
 800f7be:	4c26      	ldr	r4, [pc, #152]	; (800f858 <fCmdBuild_CGPADDR+0xc8>)
 800f7c0:	4620      	mov	r0, r4
 800f7c2:	f00f fca6 	bl	801f112 <crs_strlen>
 800f7c6:	b283      	uxth	r3, r0
 800f7c8:	4622      	mov	r2, r4
 800f7ca:	2104      	movs	r1, #4
 800f7cc:	2002      	movs	r0, #2
 800f7ce:	f00f fce3 	bl	801f198 <traceIF_itmPrint>
 800f7d2:	4620      	mov	r0, r4
 800f7d4:	f00f fc9d 	bl	801f112 <crs_strlen>
 800f7d8:	b283      	uxth	r3, r0
 800f7da:	4622      	mov	r2, r4
 800f7dc:	2104      	movs	r1, #4
 800f7de:	2002      	movs	r0, #2
 800f7e0:	f00f fcfc 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f7e4:	8933      	ldrh	r3, [r6, #8]
 800f7e6:	2b03      	cmp	r3, #3
 800f7e8:	d001      	beq.n	800f7ee <fCmdBuild_CGPADDR+0x5e>
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", modem_cid);
  }

  return (retval);
}
 800f7ea:	2000      	movs	r0, #0
 800f7ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f7ee:	4638      	mov	r0, r7
 800f7f0:	f7fd f860 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f7f4:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f7f6:	4601      	mov	r1, r0
 800f7f8:	f107 000c 	add.w	r0, r7, #12
 800f7fc:	f7fe f8e2 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f800:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 800f802:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f806:	eb07 0743 	add.w	r7, r7, r3, lsl #1
 800f80a:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800f80e:	2b0c      	cmp	r3, #12
 800f810:	d006      	beq.n	800f820 <fCmdBuild_CGPADDR+0x90>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", modem_cid);
 800f812:	462a      	mov	r2, r5
 800f814:	4911      	ldr	r1, [pc, #68]	; (800f85c <fCmdBuild_CGPADDR+0xcc>)
 800f816:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f81a:	f016 fa29 	bl	8025c70 <sprintf>
 800f81e:	e7e4      	b.n	800f7ea <fCmdBuild_CGPADDR+0x5a>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 800f820:	4f0d      	ldr	r7, [pc, #52]	; (800f858 <fCmdBuild_CGPADDR+0xc8>)
 800f822:	4622      	mov	r2, r4
 800f824:	490e      	ldr	r1, [pc, #56]	; (800f860 <fCmdBuild_CGPADDR+0xd0>)
 800f826:	4638      	mov	r0, r7
 800f828:	f016 fa22 	bl	8025c70 <sprintf>
 800f82c:	4638      	mov	r0, r7
 800f82e:	f00f fc70 	bl	801f112 <crs_strlen>
 800f832:	b283      	uxth	r3, r0
 800f834:	463a      	mov	r2, r7
 800f836:	2101      	movs	r1, #1
 800f838:	2002      	movs	r0, #2
 800f83a:	f00f fcad 	bl	801f198 <traceIF_itmPrint>
 800f83e:	4638      	mov	r0, r7
 800f840:	f00f fc67 	bl	801f112 <crs_strlen>
 800f844:	b283      	uxth	r3, r0
 800f846:	463a      	mov	r2, r7
 800f848:	2101      	movs	r1, #1
 800f84a:	2002      	movs	r0, #2
 800f84c:	f00f fcc6 	bl	801f1dc <traceIF_uartPrint>
 800f850:	e7df      	b.n	800f812 <fCmdBuild_CGPADDR+0x82>
 800f852:	bf00      	nop
 800f854:	0802eac4 	.word	0x0802eac4
 800f858:	200048dc 	.word	0x200048dc
 800f85c:	0802e834 	.word	0x0802e834
 800f860:	0802ea3c 	.word	0x0802ea3c

0800f864 <fCmdBuild_ATE>:
  }
  return (retval);
}

at_status_t fCmdBuild_ATE(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f864:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f866:	4606      	mov	r6, r0
 800f868:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATE()")
 800f86a:	4d1c      	ldr	r5, [pc, #112]	; (800f8dc <fCmdBuild_ATE+0x78>)
 800f86c:	4c1c      	ldr	r4, [pc, #112]	; (800f8e0 <fCmdBuild_ATE+0x7c>)
 800f86e:	f105 0e20 	add.w	lr, r5, #32
 800f872:	46ac      	mov	ip, r5
 800f874:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f878:	6020      	str	r0, [r4, #0]
 800f87a:	6061      	str	r1, [r4, #4]
 800f87c:	60a2      	str	r2, [r4, #8]
 800f87e:	60e3      	str	r3, [r4, #12]
 800f880:	4665      	mov	r5, ip
 800f882:	3410      	adds	r4, #16
 800f884:	45f4      	cmp	ip, lr
 800f886:	d1f4      	bne.n	800f872 <fCmdBuild_ATE+0xe>
 800f888:	f8dc 0000 	ldr.w	r0, [ip]
 800f88c:	6020      	str	r0, [r4, #0]
 800f88e:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800f892:	7123      	strb	r3, [r4, #4]
 800f894:	4c12      	ldr	r4, [pc, #72]	; (800f8e0 <fCmdBuild_ATE+0x7c>)
 800f896:	4620      	mov	r0, r4
 800f898:	f00f fc3b 	bl	801f112 <crs_strlen>
 800f89c:	b283      	uxth	r3, r0
 800f89e:	4622      	mov	r2, r4
 800f8a0:	2104      	movs	r1, #4
 800f8a2:	2002      	movs	r0, #2
 800f8a4:	f00f fc78 	bl	801f198 <traceIF_itmPrint>
 800f8a8:	4620      	mov	r0, r4
 800f8aa:	f00f fc32 	bl	801f112 <crs_strlen>
 800f8ae:	b283      	uxth	r3, r0
 800f8b0:	4622      	mov	r2, r4
 800f8b2:	2104      	movs	r1, #4
 800f8b4:	2002      	movs	r0, #2
 800f8b6:	f00f fc91 	bl	801f1dc <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800f8ba:	8933      	ldrh	r3, [r6, #8]
 800f8bc:	2b04      	cmp	r3, #4
 800f8be:	d001      	beq.n	800f8c4 <fCmdBuild_ATE+0x60>
    {
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
    }
  }
  return (retval);
}
 800f8c0:	2000      	movs	r0, #0
 800f8c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->CMD_ctxt.command_echo == AT_TRUE)
 800f8c4:	f897 372f 	ldrb.w	r3, [r7, #1839]	; 0x72f
 800f8c8:	b11b      	cbz	r3, 800f8d2 <fCmdBuild_ATE+0x6e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f8ca:	4b06      	ldr	r3, [pc, #24]	; (800f8e4 <fCmdBuild_ATE+0x80>)
 800f8cc:	881b      	ldrh	r3, [r3, #0]
 800f8ce:	8633      	strh	r3, [r6, #48]	; 0x30
 800f8d0:	e7f6      	b.n	800f8c0 <fCmdBuild_ATE+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f8d2:	4b05      	ldr	r3, [pc, #20]	; (800f8e8 <fCmdBuild_ATE+0x84>)
 800f8d4:	881b      	ldrh	r3, [r3, #0]
 800f8d6:	8633      	strh	r3, [r6, #48]	; 0x30
 800f8d8:	e7f2      	b.n	800f8c0 <fCmdBuild_ATE+0x5c>
 800f8da:	bf00      	nop
 800f8dc:	0802eaf0 	.word	0x0802eaf0
 800f8e0:	200048dc 	.word	0x200048dc
 800f8e4:	080335c4 	.word	0x080335c4
 800f8e8:	080335d8 	.word	0x080335d8

0800f8ec <fCmdBuild_ATV>:

at_status_t fCmdBuild_ATV(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f8ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f8ee:	4606      	mov	r6, r0
 800f8f0:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATV()")
 800f8f2:	4d1c      	ldr	r5, [pc, #112]	; (800f964 <fCmdBuild_ATV+0x78>)
 800f8f4:	4c1c      	ldr	r4, [pc, #112]	; (800f968 <fCmdBuild_ATV+0x7c>)
 800f8f6:	f105 0e20 	add.w	lr, r5, #32
 800f8fa:	46ac      	mov	ip, r5
 800f8fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f900:	6020      	str	r0, [r4, #0]
 800f902:	6061      	str	r1, [r4, #4]
 800f904:	60a2      	str	r2, [r4, #8]
 800f906:	60e3      	str	r3, [r4, #12]
 800f908:	4665      	mov	r5, ip
 800f90a:	3410      	adds	r4, #16
 800f90c:	45f4      	cmp	ip, lr
 800f90e:	d1f4      	bne.n	800f8fa <fCmdBuild_ATV+0xe>
 800f910:	f8dc 0000 	ldr.w	r0, [ip]
 800f914:	6020      	str	r0, [r4, #0]
 800f916:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800f91a:	7123      	strb	r3, [r4, #4]
 800f91c:	4c12      	ldr	r4, [pc, #72]	; (800f968 <fCmdBuild_ATV+0x7c>)
 800f91e:	4620      	mov	r0, r4
 800f920:	f00f fbf7 	bl	801f112 <crs_strlen>
 800f924:	b283      	uxth	r3, r0
 800f926:	4622      	mov	r2, r4
 800f928:	2104      	movs	r1, #4
 800f92a:	2002      	movs	r0, #2
 800f92c:	f00f fc34 	bl	801f198 <traceIF_itmPrint>
 800f930:	4620      	mov	r0, r4
 800f932:	f00f fbee 	bl	801f112 <crs_strlen>
 800f936:	b283      	uxth	r3, r0
 800f938:	4622      	mov	r2, r4
 800f93a:	2104      	movs	r1, #4
 800f93c:	2002      	movs	r0, #2
 800f93e:	f00f fc4d 	bl	801f1dc <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800f942:	8933      	ldrh	r3, [r6, #8]
 800f944:	2b04      	cmp	r3, #4
 800f946:	d001      	beq.n	800f94c <fCmdBuild_ATV+0x60>
    {
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
    }
  }
  return (retval);
}
 800f948:	2000      	movs	r0, #0
 800f94a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->CMD_ctxt.dce_full_resp_format == AT_TRUE)
 800f94c:	f897 3730 	ldrb.w	r3, [r7, #1840]	; 0x730
 800f950:	b11b      	cbz	r3, 800f95a <fCmdBuild_ATV+0x6e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f952:	4b06      	ldr	r3, [pc, #24]	; (800f96c <fCmdBuild_ATV+0x80>)
 800f954:	881b      	ldrh	r3, [r3, #0]
 800f956:	8633      	strh	r3, [r6, #48]	; 0x30
 800f958:	e7f6      	b.n	800f948 <fCmdBuild_ATV+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f95a:	4b05      	ldr	r3, [pc, #20]	; (800f970 <fCmdBuild_ATV+0x84>)
 800f95c:	881b      	ldrh	r3, [r3, #0]
 800f95e:	8633      	strh	r3, [r6, #48]	; 0x30
 800f960:	e7f2      	b.n	800f948 <fCmdBuild_ATV+0x5c>
 800f962:	bf00      	nop
 800f964:	0802eb18 	.word	0x0802eb18
 800f968:	200048dc 	.word	0x200048dc
 800f96c:	080335c4 	.word	0x080335c4
 800f970:	080335d8 	.word	0x080335d8

0800f974 <fCmdBuild_ATX>:

at_status_t fCmdBuild_ATX(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f974:	b570      	push	{r4, r5, r6, lr}
 800f976:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATX()")
 800f978:	4d18      	ldr	r5, [pc, #96]	; (800f9dc <fCmdBuild_ATX+0x68>)
 800f97a:	4c19      	ldr	r4, [pc, #100]	; (800f9e0 <fCmdBuild_ATX+0x6c>)
 800f97c:	f105 0e20 	add.w	lr, r5, #32
 800f980:	46ac      	mov	ip, r5
 800f982:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f986:	6020      	str	r0, [r4, #0]
 800f988:	6061      	str	r1, [r4, #4]
 800f98a:	60a2      	str	r2, [r4, #8]
 800f98c:	60e3      	str	r3, [r4, #12]
 800f98e:	4665      	mov	r5, ip
 800f990:	3410      	adds	r4, #16
 800f992:	45f4      	cmp	ip, lr
 800f994:	d1f4      	bne.n	800f980 <fCmdBuild_ATX+0xc>
 800f996:	f8dc 0000 	ldr.w	r0, [ip]
 800f99a:	6020      	str	r0, [r4, #0]
 800f99c:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800f9a0:	7123      	strb	r3, [r4, #4]
 800f9a2:	4c0f      	ldr	r4, [pc, #60]	; (800f9e0 <fCmdBuild_ATX+0x6c>)
 800f9a4:	4620      	mov	r0, r4
 800f9a6:	f00f fbb4 	bl	801f112 <crs_strlen>
 800f9aa:	b283      	uxth	r3, r0
 800f9ac:	4622      	mov	r2, r4
 800f9ae:	2104      	movs	r1, #4
 800f9b0:	2002      	movs	r0, #2
 800f9b2:	f00f fbf1 	bl	801f198 <traceIF_itmPrint>
 800f9b6:	4620      	mov	r0, r4
 800f9b8:	f00f fbab 	bl	801f112 <crs_strlen>
 800f9bc:	b283      	uxth	r3, r0
 800f9be:	4622      	mov	r2, r4
 800f9c0:	2104      	movs	r1, #4
 800f9c2:	2002      	movs	r0, #2
 800f9c4:	f00f fc0a 	bl	801f1dc <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800f9c8:	8933      	ldrh	r3, [r6, #8]
 800f9ca:	2b04      	cmp	r3, #4
 800f9cc:	d001      	beq.n	800f9d2 <fCmdBuild_ATX+0x5e>
      *  for the moment, ATX0 to return result code only, dial tone and busy detection are both disabled
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
  }
  return (retval);
}
 800f9ce:	2000      	movs	r0, #0
 800f9d0:	bd70      	pop	{r4, r5, r6, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f9d2:	4b04      	ldr	r3, [pc, #16]	; (800f9e4 <fCmdBuild_ATX+0x70>)
 800f9d4:	881b      	ldrh	r3, [r3, #0]
 800f9d6:	8633      	strh	r3, [r6, #48]	; 0x30
 800f9d8:	e7f9      	b.n	800f9ce <fCmdBuild_ATX+0x5a>
 800f9da:	bf00      	nop
 800f9dc:	0802eb40 	.word	0x0802eb40
 800f9e0:	200048dc 	.word	0x200048dc
 800f9e4:	080335d8 	.word	0x080335d8

0800f9e8 <fCmdBuild_IPR>:
  }
  return (retval);
}

at_status_t fCmdBuild_IPR(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f9e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f9ea:	4606      	mov	r6, r0
 800f9ec:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_IPR()")
 800f9ee:	4d1a      	ldr	r5, [pc, #104]	; (800fa58 <fCmdBuild_IPR+0x70>)
 800f9f0:	4c1a      	ldr	r4, [pc, #104]	; (800fa5c <fCmdBuild_IPR+0x74>)
 800f9f2:	f105 0e20 	add.w	lr, r5, #32
 800f9f6:	46ac      	mov	ip, r5
 800f9f8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f9fc:	6020      	str	r0, [r4, #0]
 800f9fe:	6061      	str	r1, [r4, #4]
 800fa00:	60a2      	str	r2, [r4, #8]
 800fa02:	60e3      	str	r3, [r4, #12]
 800fa04:	4665      	mov	r5, ip
 800fa06:	3410      	adds	r4, #16
 800fa08:	45f4      	cmp	ip, lr
 800fa0a:	d1f4      	bne.n	800f9f6 <fCmdBuild_IPR+0xe>
 800fa0c:	f8dc 0000 	ldr.w	r0, [ip]
 800fa10:	6020      	str	r0, [r4, #0]
 800fa12:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800fa16:	7123      	strb	r3, [r4, #4]
 800fa18:	4c10      	ldr	r4, [pc, #64]	; (800fa5c <fCmdBuild_IPR+0x74>)
 800fa1a:	4620      	mov	r0, r4
 800fa1c:	f00f fb79 	bl	801f112 <crs_strlen>
 800fa20:	b283      	uxth	r3, r0
 800fa22:	4622      	mov	r2, r4
 800fa24:	2104      	movs	r1, #4
 800fa26:	2002      	movs	r0, #2
 800fa28:	f00f fbb6 	bl	801f198 <traceIF_itmPrint>
 800fa2c:	4620      	mov	r0, r4
 800fa2e:	f00f fb70 	bl	801f112 <crs_strlen>
 800fa32:	b283      	uxth	r3, r0
 800fa34:	4622      	mov	r2, r4
 800fa36:	2104      	movs	r1, #4
 800fa38:	2002      	movs	r0, #2
 800fa3a:	f00f fbcf 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800fa3e:	8933      	ldrh	r3, [r6, #8]
 800fa40:	2b03      	cmp	r3, #3
 800fa42:	d001      	beq.n	800fa48 <fCmdBuild_IPR+0x60>
  {
    /* set baud rate */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%ld", p_modem_ctxt->CMD_ctxt.baud_rate);
  }
  return (retval);
}
 800fa44:	2000      	movs	r0, #0
 800fa46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%ld", p_modem_ctxt->CMD_ctxt.baud_rate);
 800fa48:	f8d7 2738 	ldr.w	r2, [r7, #1848]	; 0x738
 800fa4c:	4904      	ldr	r1, [pc, #16]	; (800fa60 <fCmdBuild_IPR+0x78>)
 800fa4e:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800fa52:	f016 f90d 	bl	8025c70 <sprintf>
 800fa56:	e7f5      	b.n	800fa44 <fCmdBuild_IPR+0x5c>
 800fa58:	0802eb68 	.word	0x0802eb68
 800fa5c:	200048dc 	.word	0x200048dc
 800fa60:	0802eb90 	.word	0x0802eb90

0800fa64 <fCmdBuild_IFC>:

at_status_t fCmdBuild_IFC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fa64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fa66:	4606      	mov	r6, r0
 800fa68:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_IFC()")
 800fa6a:	4d1c      	ldr	r5, [pc, #112]	; (800fadc <fCmdBuild_IFC+0x78>)
 800fa6c:	4c1c      	ldr	r4, [pc, #112]	; (800fae0 <fCmdBuild_IFC+0x7c>)
 800fa6e:	f105 0e20 	add.w	lr, r5, #32
 800fa72:	46ac      	mov	ip, r5
 800fa74:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fa78:	6020      	str	r0, [r4, #0]
 800fa7a:	6061      	str	r1, [r4, #4]
 800fa7c:	60a2      	str	r2, [r4, #8]
 800fa7e:	60e3      	str	r3, [r4, #12]
 800fa80:	4665      	mov	r5, ip
 800fa82:	3410      	adds	r4, #16
 800fa84:	45f4      	cmp	ip, lr
 800fa86:	d1f4      	bne.n	800fa72 <fCmdBuild_IFC+0xe>
 800fa88:	f8dc 0000 	ldr.w	r0, [ip]
 800fa8c:	6020      	str	r0, [r4, #0]
 800fa8e:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800fa92:	7123      	strb	r3, [r4, #4]
 800fa94:	4c12      	ldr	r4, [pc, #72]	; (800fae0 <fCmdBuild_IFC+0x7c>)
 800fa96:	4620      	mov	r0, r4
 800fa98:	f00f fb3b 	bl	801f112 <crs_strlen>
 800fa9c:	b283      	uxth	r3, r0
 800fa9e:	4622      	mov	r2, r4
 800faa0:	2104      	movs	r1, #4
 800faa2:	2002      	movs	r0, #2
 800faa4:	f00f fb78 	bl	801f198 <traceIF_itmPrint>
 800faa8:	4620      	mov	r0, r4
 800faaa:	f00f fb32 	bl	801f112 <crs_strlen>
 800faae:	b283      	uxth	r3, r0
 800fab0:	4622      	mov	r2, r4
 800fab2:	2104      	movs	r1, #4
 800fab4:	2002      	movs	r0, #2
 800fab6:	f00f fb91 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800faba:	8933      	ldrh	r3, [r6, #8]
 800fabc:	2b03      	cmp	r3, #3
 800fabe:	d001      	beq.n	800fac4 <fCmdBuild_IFC+0x60>
      /* CTS/RTS activated */
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "2,2");
    }
  }
  return (retval);
}
 800fac0:	2000      	movs	r0, #0
 800fac2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->CMD_ctxt.flow_control_cts_rts == AT_FALSE)
 800fac4:	f897 373c 	ldrb.w	r3, [r7, #1852]	; 0x73c
 800fac8:	b91b      	cbnz	r3, 800fad2 <fCmdBuild_IFC+0x6e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0,0");
 800faca:	4b06      	ldr	r3, [pc, #24]	; (800fae4 <fCmdBuild_IFC+0x80>)
 800facc:	6818      	ldr	r0, [r3, #0]
 800face:	6330      	str	r0, [r6, #48]	; 0x30
 800fad0:	e7f6      	b.n	800fac0 <fCmdBuild_IFC+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "2,2");
 800fad2:	4b05      	ldr	r3, [pc, #20]	; (800fae8 <fCmdBuild_IFC+0x84>)
 800fad4:	6818      	ldr	r0, [r3, #0]
 800fad6:	6330      	str	r0, [r6, #48]	; 0x30
 800fad8:	e7f2      	b.n	800fac0 <fCmdBuild_IFC+0x5c>
 800fada:	bf00      	nop
 800fadc:	0802eb94 	.word	0x0802eb94
 800fae0:	200048dc 	.word	0x200048dc
 800fae4:	0802ebbc 	.word	0x0802ebbc
 800fae8:	0802ebc0 	.word	0x0802ebc0

0800faec <fCmdBuild_ESCAPE_CMD>:

at_status_t fCmdBuild_ESCAPE_CMD(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800faec:	b570      	push	{r4, r5, r6, lr}
 800faee:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ESCAPE_CMD()")
 800faf0:	4c1c      	ldr	r4, [pc, #112]	; (800fb64 <fCmdBuild_ESCAPE_CMD+0x78>)
 800faf2:	4d1d      	ldr	r5, [pc, #116]	; (800fb68 <fCmdBuild_ESCAPE_CMD+0x7c>)
 800faf4:	f104 0e20 	add.w	lr, r4, #32
 800faf8:	46a4      	mov	ip, r4
 800fafa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fafe:	6028      	str	r0, [r5, #0]
 800fb00:	6069      	str	r1, [r5, #4]
 800fb02:	60aa      	str	r2, [r5, #8]
 800fb04:	60eb      	str	r3, [r5, #12]
 800fb06:	4664      	mov	r4, ip
 800fb08:	3510      	adds	r5, #16
 800fb0a:	45f4      	cmp	ip, lr
 800fb0c:	d1f4      	bne.n	800faf8 <fCmdBuild_ESCAPE_CMD+0xc>
 800fb0e:	cc07      	ldmia	r4!, {r0, r1, r2}
 800fb10:	6028      	str	r0, [r5, #0]
 800fb12:	6069      	str	r1, [r5, #4]
 800fb14:	60aa      	str	r2, [r5, #8]
 800fb16:	4c14      	ldr	r4, [pc, #80]	; (800fb68 <fCmdBuild_ESCAPE_CMD+0x7c>)
 800fb18:	4620      	mov	r0, r4
 800fb1a:	f00f fafa 	bl	801f112 <crs_strlen>
 800fb1e:	b283      	uxth	r3, r0
 800fb20:	4622      	mov	r2, r4
 800fb22:	2104      	movs	r1, #4
 800fb24:	2002      	movs	r0, #2
 800fb26:	f00f fb37 	bl	801f198 <traceIF_itmPrint>
 800fb2a:	4620      	mov	r0, r4
 800fb2c:	f00f faf1 	bl	801f112 <crs_strlen>
 800fb30:	b283      	uxth	r3, r0
 800fb32:	4622      	mov	r2, r4
 800fb34:	2104      	movs	r1, #4
 800fb36:	2002      	movs	r0, #2
 800fb38:	f00f fb50 	bl	801f1dc <traceIF_uartPrint>

  /* only for RAW command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD)
 800fb3c:	8933      	ldrh	r3, [r6, #8]
 800fb3e:	2b06      	cmp	r3, #6
 800fb40:	d001      	beq.n	800fb46 <fCmdBuild_ESCAPE_CMD+0x5a>
    /* set raw command size */
    p_atp_ctxt->current_atcmd.raw_cmd_size = strlen((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params);
  }
  else
  {
    retval = ATSTATUS_ERROR;
 800fb42:	2001      	movs	r0, #1
  }
  return (retval);
}
 800fb44:	bd70      	pop	{r4, r5, r6, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%s", p_atp_ctxt->current_atcmd.name);
 800fb46:	f106 0430 	add.w	r4, r6, #48	; 0x30
 800fb4a:	f106 0110 	add.w	r1, r6, #16
 800fb4e:	4620      	mov	r0, r4
 800fb50:	f016 f9d6 	bl	8025f00 <strcpy>
    p_atp_ctxt->current_atcmd.raw_cmd_size = strlen((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params);
 800fb54:	4620      	mov	r0, r4
 800fb56:	f7f0 fb4d 	bl	80001f4 <strlen>
 800fb5a:	f8c6 0670 	str.w	r0, [r6, #1648]	; 0x670
  at_status_t retval = ATSTATUS_OK;
 800fb5e:	2000      	movs	r0, #0
 800fb60:	e7f0      	b.n	800fb44 <fCmdBuild_ESCAPE_CMD+0x58>
 800fb62:	bf00      	nop
 800fb64:	0802ebc4 	.word	0x0802ebc4
 800fb68:	200048dc 	.word	0x200048dc

0800fb6c <fCmdBuild_AT_AND_D>:

at_status_t fCmdBuild_AT_AND_D(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fb6c:	b570      	push	{r4, r5, r6, lr}
 800fb6e:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_AT_AND_D()")
 800fb70:	4c17      	ldr	r4, [pc, #92]	; (800fbd0 <fCmdBuild_AT_AND_D+0x64>)
 800fb72:	4d18      	ldr	r5, [pc, #96]	; (800fbd4 <fCmdBuild_AT_AND_D+0x68>)
 800fb74:	f104 0e20 	add.w	lr, r4, #32
 800fb78:	46a4      	mov	ip, r4
 800fb7a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fb7e:	6028      	str	r0, [r5, #0]
 800fb80:	6069      	str	r1, [r5, #4]
 800fb82:	60aa      	str	r2, [r5, #8]
 800fb84:	60eb      	str	r3, [r5, #12]
 800fb86:	4664      	mov	r4, ip
 800fb88:	3510      	adds	r5, #16
 800fb8a:	45f4      	cmp	ip, lr
 800fb8c:	d1f4      	bne.n	800fb78 <fCmdBuild_AT_AND_D+0xc>
 800fb8e:	cc03      	ldmia	r4!, {r0, r1}
 800fb90:	6028      	str	r0, [r5, #0]
 800fb92:	6069      	str	r1, [r5, #4]
 800fb94:	8823      	ldrh	r3, [r4, #0]
 800fb96:	812b      	strh	r3, [r5, #8]
 800fb98:	4c0e      	ldr	r4, [pc, #56]	; (800fbd4 <fCmdBuild_AT_AND_D+0x68>)
 800fb9a:	4620      	mov	r0, r4
 800fb9c:	f00f fab9 	bl	801f112 <crs_strlen>
 800fba0:	b283      	uxth	r3, r0
 800fba2:	4622      	mov	r2, r4
 800fba4:	2104      	movs	r1, #4
 800fba6:	2002      	movs	r0, #2
 800fba8:	f00f faf6 	bl	801f198 <traceIF_itmPrint>
 800fbac:	4620      	mov	r0, r4
 800fbae:	f00f fab0 	bl	801f112 <crs_strlen>
 800fbb2:	b283      	uxth	r3, r0
 800fbb4:	4622      	mov	r2, r4
 800fbb6:	2104      	movs	r1, #4
 800fbb8:	2002      	movs	r0, #2
 800fbba:	f00f fb0f 	bl	801f1dc <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800fbbe:	8933      	ldrh	r3, [r6, #8]
 800fbc0:	2b04      	cmp	r3, #4
 800fbc2:	d001      	beq.n	800fbc8 <fCmdBuild_AT_AND_D+0x5c>
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
  }

  return (retval);
}
 800fbc4:	2000      	movs	r0, #0
 800fbc6:	bd70      	pop	{r4, r5, r6, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800fbc8:	4b03      	ldr	r3, [pc, #12]	; (800fbd8 <fCmdBuild_AT_AND_D+0x6c>)
 800fbca:	881b      	ldrh	r3, [r3, #0]
 800fbcc:	8633      	strh	r3, [r6, #48]	; 0x30
 800fbce:	e7f9      	b.n	800fbc4 <fCmdBuild_AT_AND_D+0x58>
 800fbd0:	0802ebf0 	.word	0x0802ebf0
 800fbd4:	200048dc 	.word	0x200048dc
 800fbd8:	080335d8 	.word	0x080335d8

0800fbdc <fCmdBuild_CPSMS>:

at_status_t fCmdBuild_CPSMS(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fbdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fbde:	b08f      	sub	sp, #60	; 0x3c
 800fbe0:	4607      	mov	r7, r0
 800fbe2:	460e      	mov	r6, r1
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CPSMS()")
 800fbe4:	4d61      	ldr	r5, [pc, #388]	; (800fd6c <fCmdBuild_CPSMS+0x190>)
 800fbe6:	4c62      	ldr	r4, [pc, #392]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fbe8:	f105 0e20 	add.w	lr, r5, #32
 800fbec:	46ac      	mov	ip, r5
 800fbee:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fbf2:	6020      	str	r0, [r4, #0]
 800fbf4:	6061      	str	r1, [r4, #4]
 800fbf6:	60a2      	str	r2, [r4, #8]
 800fbf8:	60e3      	str	r3, [r4, #12]
 800fbfa:	4665      	mov	r5, ip
 800fbfc:	3410      	adds	r4, #16
 800fbfe:	45f4      	cmp	ip, lr
 800fc00:	d1f4      	bne.n	800fbec <fCmdBuild_CPSMS+0x10>
 800fc02:	f8dc 0000 	ldr.w	r0, [ip]
 800fc06:	6020      	str	r0, [r4, #0]
 800fc08:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800fc0c:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800fc10:	80a2      	strh	r2, [r4, #4]
 800fc12:	71a3      	strb	r3, [r4, #6]
 800fc14:	4c56      	ldr	r4, [pc, #344]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fc16:	4620      	mov	r0, r4
 800fc18:	f00f fa7b 	bl	801f112 <crs_strlen>
 800fc1c:	b283      	uxth	r3, r0
 800fc1e:	4622      	mov	r2, r4
 800fc20:	2104      	movs	r1, #4
 800fc22:	2002      	movs	r0, #2
 800fc24:	f00f fab8 	bl	801f198 <traceIF_itmPrint>
 800fc28:	4620      	mov	r0, r4
 800fc2a:	f00f fa72 	bl	801f112 <crs_strlen>
 800fc2e:	b283      	uxth	r3, r0
 800fc30:	4622      	mov	r2, r4
 800fc32:	2104      	movs	r1, #4
 800fc34:	2002      	movs	r0, #2
 800fc36:	f00f fad1 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800fc3a:	893b      	ldrh	r3, [r7, #8]
 800fc3c:	2b03      	cmp	r3, #3
 800fc3e:	d027      	beq.n	800fc90 <fCmdBuild_CPSMS+0xb4>
      atcm_program_SKIP_CMD(p_atp_ctxt);
    }
  }
  else
  {
    PRINT_ERR("invalid pointer to PSM parameters")
 800fc40:	4e4c      	ldr	r6, [pc, #304]	; (800fd74 <fCmdBuild_CPSMS+0x198>)
 800fc42:	4c4b      	ldr	r4, [pc, #300]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fc44:	f106 0730 	add.w	r7, r6, #48	; 0x30
 800fc48:	4635      	mov	r5, r6
 800fc4a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fc4c:	6020      	str	r0, [r4, #0]
 800fc4e:	6061      	str	r1, [r4, #4]
 800fc50:	60a2      	str	r2, [r4, #8]
 800fc52:	60e3      	str	r3, [r4, #12]
 800fc54:	462e      	mov	r6, r5
 800fc56:	3410      	adds	r4, #16
 800fc58:	42bd      	cmp	r5, r7
 800fc5a:	d1f5      	bne.n	800fc48 <fCmdBuild_CPSMS+0x6c>
 800fc5c:	882a      	ldrh	r2, [r5, #0]
 800fc5e:	78ab      	ldrb	r3, [r5, #2]
 800fc60:	8022      	strh	r2, [r4, #0]
 800fc62:	70a3      	strb	r3, [r4, #2]
 800fc64:	4c42      	ldr	r4, [pc, #264]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fc66:	4620      	mov	r0, r4
 800fc68:	f00f fa53 	bl	801f112 <crs_strlen>
 800fc6c:	b283      	uxth	r3, r0
 800fc6e:	4622      	mov	r2, r4
 800fc70:	2110      	movs	r1, #16
 800fc72:	2002      	movs	r0, #2
 800fc74:	f00f fa90 	bl	801f198 <traceIF_itmPrint>
 800fc78:	4620      	mov	r0, r4
 800fc7a:	f00f fa4a 	bl	801f112 <crs_strlen>
 800fc7e:	b283      	uxth	r3, r0
 800fc80:	4622      	mov	r2, r4
 800fc82:	2110      	movs	r1, #16
 800fc84:	2002      	movs	r0, #2
 800fc86:	f00f faa9 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800fc8a:	2001      	movs	r0, #1
  }

  return (retval);
}
 800fc8c:	b00f      	add	sp, #60	; 0x3c
 800fc8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t req_periodic_rau[9] = {0U};
 800fc90:	2300      	movs	r3, #0
 800fc92:	9302      	str	r3, [sp, #8]
 800fc94:	9303      	str	r3, [sp, #12]
 800fc96:	f88d 3010 	strb.w	r3, [sp, #16]
    uint8_t req_gprs_ready_time[9] = {0U};
 800fc9a:	9305      	str	r3, [sp, #20]
 800fc9c:	9306      	str	r3, [sp, #24]
 800fc9e:	f88d 301c 	strb.w	r3, [sp, #28]
    uint8_t req_periodic_tau[9] = {0U};
 800fca2:	9308      	str	r3, [sp, #32]
 800fca4:	9309      	str	r3, [sp, #36]	; 0x24
 800fca6:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    uint8_t req_active_time[9] = {0U};
 800fcaa:	930b      	str	r3, [sp, #44]	; 0x2c
 800fcac:	930c      	str	r3, [sp, #48]	; 0x30
 800fcae:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    (void)ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_periodic_RAU,
 800fcb2:	ab02      	add	r3, sp, #8
 800fcb4:	2209      	movs	r2, #9
 800fcb6:	2108      	movs	r1, #8
 800fcb8:	f896 0722 	ldrb.w	r0, [r6, #1826]	; 0x722
 800fcbc:	f005 f8dc 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    (void)ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_GPRS_READY_timer,
 800fcc0:	ab05      	add	r3, sp, #20
 800fcc2:	2209      	movs	r2, #9
 800fcc4:	2108      	movs	r1, #8
 800fcc6:	f896 0723 	ldrb.w	r0, [r6, #1827]	; 0x723
 800fcca:	f005 f8d5 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    (void) ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_periodic_TAU,
 800fcce:	ab08      	add	r3, sp, #32
 800fcd0:	2209      	movs	r2, #9
 800fcd2:	2108      	movs	r1, #8
 800fcd4:	f896 0724 	ldrb.w	r0, [r6, #1828]	; 0x724
 800fcd8:	f005 f8ce 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    (void) ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_active_time,
 800fcdc:	ab0b      	add	r3, sp, #44	; 0x2c
 800fcde:	2209      	movs	r2, #9
 800fce0:	2108      	movs	r1, #8
 800fce2:	f896 0725 	ldrb.w	r0, [r6, #1829]	; 0x725
 800fce6:	f005 f8c7 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    if (p_modem_ctxt->SID_ctxt.set_power_config.psm_present == CELLULAR_TRUE)
 800fcea:	f896 371f 	ldrb.w	r3, [r6, #1823]	; 0x71f
 800fcee:	2b01      	cmp	r3, #1
 800fcf0:	d113      	bne.n	800fd1a <fCmdBuild_CPSMS+0x13e>
      if (p_modem_ctxt->SID_ctxt.set_power_config.psm_mode == PSM_MODE_DISABLE)
 800fcf2:	f896 3721 	ldrb.w	r3, [r6, #1825]	; 0x721
 800fcf6:	b933      	cbnz	r3, 800fd06 <fCmdBuild_CPSMS+0x12a>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800fcf8:	2200      	movs	r2, #0
 800fcfa:	491f      	ldr	r1, [pc, #124]	; (800fd78 <fCmdBuild_CPSMS+0x19c>)
 800fcfc:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800fd00:	f015 ffb6 	bl	8025c70 <sprintf>
 800fd04:	e030      	b.n	800fd68 <fCmdBuild_CPSMS+0x18c>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,,,\"%s\",\"%s\"",
 800fd06:	ab0b      	add	r3, sp, #44	; 0x2c
 800fd08:	9300      	str	r3, [sp, #0]
 800fd0a:	ab08      	add	r3, sp, #32
 800fd0c:	2201      	movs	r2, #1
 800fd0e:	491b      	ldr	r1, [pc, #108]	; (800fd7c <fCmdBuild_CPSMS+0x1a0>)
 800fd10:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800fd14:	f015 ffac 	bl	8025c70 <sprintf>
 800fd18:	e026      	b.n	800fd68 <fCmdBuild_CPSMS+0x18c>
      PRINT_INFO("No PSM parameters available, command skipped")
 800fd1a:	4e19      	ldr	r6, [pc, #100]	; (800fd80 <fCmdBuild_CPSMS+0x1a4>)
 800fd1c:	4c14      	ldr	r4, [pc, #80]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fd1e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 800fd22:	4635      	mov	r5, r6
 800fd24:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fd26:	6020      	str	r0, [r4, #0]
 800fd28:	6061      	str	r1, [r4, #4]
 800fd2a:	60a2      	str	r2, [r4, #8]
 800fd2c:	60e3      	str	r3, [r4, #12]
 800fd2e:	462e      	mov	r6, r5
 800fd30:	3410      	adds	r4, #16
 800fd32:	4565      	cmp	r5, ip
 800fd34:	d1f5      	bne.n	800fd22 <fCmdBuild_CPSMS+0x146>
 800fd36:	ce03      	ldmia	r6!, {r0, r1}
 800fd38:	6020      	str	r0, [r4, #0]
 800fd3a:	6061      	str	r1, [r4, #4]
 800fd3c:	4c0c      	ldr	r4, [pc, #48]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fd3e:	4620      	mov	r0, r4
 800fd40:	f00f f9e7 	bl	801f112 <crs_strlen>
 800fd44:	b283      	uxth	r3, r0
 800fd46:	4622      	mov	r2, r4
 800fd48:	2101      	movs	r1, #1
 800fd4a:	2002      	movs	r0, #2
 800fd4c:	f00f fa24 	bl	801f198 <traceIF_itmPrint>
 800fd50:	4620      	mov	r0, r4
 800fd52:	f00f f9de 	bl	801f112 <crs_strlen>
 800fd56:	b283      	uxth	r3, r0
 800fd58:	4622      	mov	r2, r4
 800fd5a:	2101      	movs	r1, #1
 800fd5c:	2002      	movs	r0, #2
 800fd5e:	f00f fa3d 	bl	801f1dc <traceIF_uartPrint>
      atcm_program_SKIP_CMD(p_atp_ctxt);
 800fd62:	4638      	mov	r0, r7
 800fd64:	f7fc fedc 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 800fd68:	2000      	movs	r0, #0
 800fd6a:	e78f      	b.n	800fc8c <fCmdBuild_CPSMS+0xb0>
 800fd6c:	0802ec1c 	.word	0x0802ec1c
 800fd70:	200048dc 	.word	0x200048dc
 800fd74:	0802ec8c 	.word	0x0802ec8c
 800fd78:	0802e834 	.word	0x0802e834
 800fd7c:	0802ec44 	.word	0x0802ec44
 800fd80:	0802ec54 	.word	0x0802ec54

0800fd84 <fCmdBuild_CEDRXS>:

at_status_t fCmdBuild_CEDRXS(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fd84:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fd86:	b085      	sub	sp, #20
 800fd88:	4606      	mov	r6, r0
 800fd8a:	460f      	mov	r7, r1
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CEDRXS()")
 800fd8c:	4c52      	ldr	r4, [pc, #328]	; (800fed8 <fCmdBuild_CEDRXS+0x154>)
 800fd8e:	4d53      	ldr	r5, [pc, #332]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fd90:	f104 0e20 	add.w	lr, r4, #32
 800fd94:	46a4      	mov	ip, r4
 800fd96:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fd9a:	6028      	str	r0, [r5, #0]
 800fd9c:	6069      	str	r1, [r5, #4]
 800fd9e:	60aa      	str	r2, [r5, #8]
 800fda0:	60eb      	str	r3, [r5, #12]
 800fda2:	4664      	mov	r4, ip
 800fda4:	3510      	adds	r5, #16
 800fda6:	45f4      	cmp	ip, lr
 800fda8:	d1f4      	bne.n	800fd94 <fCmdBuild_CEDRXS+0x10>
 800fdaa:	cc03      	ldmia	r4!, {r0, r1}
 800fdac:	6028      	str	r0, [r5, #0]
 800fdae:	6069      	str	r1, [r5, #4]
 800fdb0:	4c4a      	ldr	r4, [pc, #296]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fdb2:	4620      	mov	r0, r4
 800fdb4:	f00f f9ad 	bl	801f112 <crs_strlen>
 800fdb8:	b283      	uxth	r3, r0
 800fdba:	4622      	mov	r2, r4
 800fdbc:	2104      	movs	r1, #4
 800fdbe:	2002      	movs	r0, #2
 800fdc0:	f00f f9ea 	bl	801f198 <traceIF_itmPrint>
 800fdc4:	4620      	mov	r0, r4
 800fdc6:	f00f f9a4 	bl	801f112 <crs_strlen>
 800fdca:	b283      	uxth	r3, r0
 800fdcc:	4622      	mov	r2, r4
 800fdce:	2104      	movs	r1, #4
 800fdd0:	2002      	movs	r0, #2
 800fdd2:	f00f fa03 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800fdd6:	8933      	ldrh	r3, [r6, #8]
 800fdd8:	2b03      	cmp	r3, #3
 800fdda:	d157      	bne.n	800fe8c <fCmdBuild_CEDRXS+0x108>
     * exple:
     * AT+CEDRX=1,5,0000
     * Set the requested e-I-DRX value to 5.12 second
    */

    if (p_modem_ctxt->SID_ctxt.set_power_config.edrx_present == CELLULAR_TRUE)
 800fddc:	f897 4720 	ldrb.w	r4, [r7, #1824]	; 0x720
 800fde0:	2c01      	cmp	r4, #1
 800fde2:	d02b      	beq.n	800fe3c <fCmdBuild_CEDRXS+0xb8>
      }
    }
    else
    {
      /* no eDRX parameters, skip the command */
      PRINT_INFO("No EDRX parameters available, command skipped")
 800fde4:	4d3e      	ldr	r5, [pc, #248]	; (800fee0 <fCmdBuild_CEDRXS+0x15c>)
 800fde6:	4c3d      	ldr	r4, [pc, #244]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fde8:	f105 0730 	add.w	r7, r5, #48	; 0x30
 800fdec:	46ac      	mov	ip, r5
 800fdee:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fdf2:	6020      	str	r0, [r4, #0]
 800fdf4:	6061      	str	r1, [r4, #4]
 800fdf6:	60a2      	str	r2, [r4, #8]
 800fdf8:	60e3      	str	r3, [r4, #12]
 800fdfa:	4665      	mov	r5, ip
 800fdfc:	3410      	adds	r4, #16
 800fdfe:	45bc      	cmp	ip, r7
 800fe00:	d1f4      	bne.n	800fdec <fCmdBuild_CEDRXS+0x68>
 800fe02:	cd03      	ldmia	r5!, {r0, r1}
 800fe04:	6020      	str	r0, [r4, #0]
 800fe06:	6061      	str	r1, [r4, #4]
 800fe08:	782b      	ldrb	r3, [r5, #0]
 800fe0a:	7223      	strb	r3, [r4, #8]
 800fe0c:	4c33      	ldr	r4, [pc, #204]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fe0e:	4620      	mov	r0, r4
 800fe10:	f00f f97f 	bl	801f112 <crs_strlen>
 800fe14:	b283      	uxth	r3, r0
 800fe16:	4622      	mov	r2, r4
 800fe18:	2101      	movs	r1, #1
 800fe1a:	2002      	movs	r0, #2
 800fe1c:	f00f f9bc 	bl	801f198 <traceIF_itmPrint>
 800fe20:	4620      	mov	r0, r4
 800fe22:	f00f f976 	bl	801f112 <crs_strlen>
 800fe26:	b283      	uxth	r3, r0
 800fe28:	4622      	mov	r2, r4
 800fe2a:	2101      	movs	r1, #1
 800fe2c:	2002      	movs	r0, #2
 800fe2e:	f00f f9d5 	bl	801f1dc <traceIF_uartPrint>
      atcm_program_SKIP_CMD(p_atp_ctxt);
 800fe32:	4630      	mov	r0, r6
 800fe34:	f7fc fe74 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 800fe38:	2000      	movs	r0, #0
 800fe3a:	e04b      	b.n	800fed4 <fCmdBuild_CEDRXS+0x150>
      uint8_t edrx_req_value[5] = {0};
 800fe3c:	2300      	movs	r3, #0
 800fe3e:	9302      	str	r3, [sp, #8]
 800fe40:	f88d 300c 	strb.w	r3, [sp, #12]
      (void) ATutil_convert_uint8_to_binary_string((uint32_t) p_modem_ctxt->SID_ctxt.set_power_config.edrx.req_value,
 800fe44:	ab02      	add	r3, sp, #8
 800fe46:	2205      	movs	r2, #5
 800fe48:	2104      	movs	r1, #4
 800fe4a:	f897 0728 	ldrb.w	r0, [r7, #1832]	; 0x728
 800fe4e:	f005 f813 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
      if (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_DISABLE)
 800fe52:	f897 3726 	ldrb.w	r3, [r7, #1830]	; 0x726
 800fe56:	b17b      	cbz	r3, 800fe78 <fCmdBuild_CEDRXS+0xf4>
      else if (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_DISABLE_AND_RESET)
 800fe58:	2b03      	cmp	r3, #3
 800fe5a:	d011      	beq.n	800fe80 <fCmdBuild_CEDRXS+0xfc>
        edrx_mode = (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_ENABLE_WITH_URC) ? 2U : 1U;
 800fe5c:	2b02      	cmp	r3, #2
 800fe5e:	d013      	beq.n	800fe88 <fCmdBuild_CEDRXS+0x104>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d,\"%s\"",
 800fe60:	ab02      	add	r3, sp, #8
 800fe62:	9300      	str	r3, [sp, #0]
 800fe64:	f897 3727 	ldrb.w	r3, [r7, #1831]	; 0x727
 800fe68:	4622      	mov	r2, r4
 800fe6a:	491e      	ldr	r1, [pc, #120]	; (800fee4 <fCmdBuild_CEDRXS+0x160>)
 800fe6c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800fe70:	f015 fefe 	bl	8025c70 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800fe74:	2000      	movs	r0, #0
 800fe76:	e02d      	b.n	800fed4 <fCmdBuild_CEDRXS+0x150>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800fe78:	4b1b      	ldr	r3, [pc, #108]	; (800fee8 <fCmdBuild_CEDRXS+0x164>)
 800fe7a:	881b      	ldrh	r3, [r3, #0]
 800fe7c:	8633      	strh	r3, [r6, #48]	; 0x30
 800fe7e:	e7f9      	b.n	800fe74 <fCmdBuild_CEDRXS+0xf0>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "3");
 800fe80:	4b1a      	ldr	r3, [pc, #104]	; (800feec <fCmdBuild_CEDRXS+0x168>)
 800fe82:	881b      	ldrh	r3, [r3, #0]
 800fe84:	8633      	strh	r3, [r6, #48]	; 0x30
 800fe86:	e7f5      	b.n	800fe74 <fCmdBuild_CEDRXS+0xf0>
        edrx_mode = (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_ENABLE_WITH_URC) ? 2U : 1U;
 800fe88:	461c      	mov	r4, r3
 800fe8a:	e7e9      	b.n	800fe60 <fCmdBuild_CEDRXS+0xdc>
    }
  }
  else
  {
    PRINT_ERR("invalid pointer to EDRX parameters")
 800fe8c:	4e18      	ldr	r6, [pc, #96]	; (800fef0 <fCmdBuild_CEDRXS+0x16c>)
 800fe8e:	4d13      	ldr	r5, [pc, #76]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fe90:	f106 0730 	add.w	r7, r6, #48	; 0x30
 800fe94:	4634      	mov	r4, r6
 800fe96:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800fe98:	6028      	str	r0, [r5, #0]
 800fe9a:	6069      	str	r1, [r5, #4]
 800fe9c:	60aa      	str	r2, [r5, #8]
 800fe9e:	60eb      	str	r3, [r5, #12]
 800fea0:	4626      	mov	r6, r4
 800fea2:	3510      	adds	r5, #16
 800fea4:	42bc      	cmp	r4, r7
 800fea6:	d1f5      	bne.n	800fe94 <fCmdBuild_CEDRXS+0x110>
 800fea8:	6820      	ldr	r0, [r4, #0]
 800feaa:	6028      	str	r0, [r5, #0]
 800feac:	4c0b      	ldr	r4, [pc, #44]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800feae:	4620      	mov	r0, r4
 800feb0:	f00f f92f 	bl	801f112 <crs_strlen>
 800feb4:	b283      	uxth	r3, r0
 800feb6:	4622      	mov	r2, r4
 800feb8:	2110      	movs	r1, #16
 800feba:	2002      	movs	r0, #2
 800febc:	f00f f96c 	bl	801f198 <traceIF_itmPrint>
 800fec0:	4620      	mov	r0, r4
 800fec2:	f00f f926 	bl	801f112 <crs_strlen>
 800fec6:	b283      	uxth	r3, r0
 800fec8:	4622      	mov	r2, r4
 800feca:	2110      	movs	r1, #16
 800fecc:	2002      	movs	r0, #2
 800fece:	f00f f985 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800fed2:	2001      	movs	r0, #1
  }

  return (retval);
}
 800fed4:	b005      	add	sp, #20
 800fed6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fed8:	0802ecc0 	.word	0x0802ecc0
 800fedc:	200048dc 	.word	0x200048dc
 800fee0:	0802ecec 	.word	0x0802ecec
 800fee4:	0802e838 	.word	0x0802e838
 800fee8:	080335d8 	.word	0x080335d8
 800feec:	0802ece8 	.word	0x0802ece8
 800fef0:	0802ed28 	.word	0x0802ed28

0800fef4 <fCmdBuild_CSIM>:

at_status_t fCmdBuild_CSIM(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fef4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fef6:	b083      	sub	sp, #12
 800fef8:	4606      	mov	r6, r0
 800fefa:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CSIM()")
 800fefc:	4d1d      	ldr	r5, [pc, #116]	; (800ff74 <fCmdBuild_CSIM+0x80>)
 800fefe:	4c1e      	ldr	r4, [pc, #120]	; (800ff78 <fCmdBuild_CSIM+0x84>)
 800ff00:	f105 0e20 	add.w	lr, r5, #32
 800ff04:	46ac      	mov	ip, r5
 800ff06:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ff0a:	6020      	str	r0, [r4, #0]
 800ff0c:	6061      	str	r1, [r4, #4]
 800ff0e:	60a2      	str	r2, [r4, #8]
 800ff10:	60e3      	str	r3, [r4, #12]
 800ff12:	4665      	mov	r5, ip
 800ff14:	3410      	adds	r4, #16
 800ff16:	45f4      	cmp	ip, lr
 800ff18:	d1f4      	bne.n	800ff04 <fCmdBuild_CSIM+0x10>
 800ff1a:	f8dc 0000 	ldr.w	r0, [ip]
 800ff1e:	6020      	str	r0, [r4, #0]
 800ff20:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ff24:	80a3      	strh	r3, [r4, #4]
 800ff26:	4c14      	ldr	r4, [pc, #80]	; (800ff78 <fCmdBuild_CSIM+0x84>)
 800ff28:	4620      	mov	r0, r4
 800ff2a:	f00f f8f2 	bl	801f112 <crs_strlen>
 800ff2e:	b283      	uxth	r3, r0
 800ff30:	4622      	mov	r2, r4
 800ff32:	2104      	movs	r1, #4
 800ff34:	2002      	movs	r0, #2
 800ff36:	f00f f92f 	bl	801f198 <traceIF_itmPrint>
 800ff3a:	4620      	mov	r0, r4
 800ff3c:	f00f f8e9 	bl	801f112 <crs_strlen>
 800ff40:	b283      	uxth	r3, r0
 800ff42:	4622      	mov	r2, r4
 800ff44:	2104      	movs	r1, #4
 800ff46:	2002      	movs	r0, #2
 800ff48:	f00f f948 	bl	801f1dc <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800ff4c:	8933      	ldrh	r3, [r6, #8]
 800ff4e:	2b03      	cmp	r3, #3
 800ff50:	d002      	beq.n	800ff58 <fCmdBuild_CSIM+0x64>
                   length, (int16_t)length,
                   (const CS_CHAR_t *)p_modem_ctxt->SID_ctxt.sim_generic_access.data->p_cmd_str);
  }

  return (retval);
}
 800ff52:	2000      	movs	r0, #0
 800ff54:	b003      	add	sp, #12
 800ff56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    length = (uint16_t) p_modem_ctxt->SID_ctxt.sim_generic_access.data->cmd_str_size;
 800ff58:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
 800ff5c:	689a      	ldr	r2, [r3, #8]
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params,
 800ff5e:	681b      	ldr	r3, [r3, #0]
 800ff60:	9300      	str	r3, [sp, #0]
 800ff62:	b213      	sxth	r3, r2
 800ff64:	b292      	uxth	r2, r2
 800ff66:	4905      	ldr	r1, [pc, #20]	; (800ff7c <fCmdBuild_CSIM+0x88>)
 800ff68:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ff6c:	f015 fe80 	bl	8025c70 <sprintf>
 800ff70:	e7ef      	b.n	800ff52 <fCmdBuild_CSIM+0x5e>
 800ff72:	bf00      	nop
 800ff74:	0802ed5c 	.word	0x0802ed5c
 800ff78:	200048dc 	.word	0x200048dc
 800ff7c:	0802ed84 	.word	0x0802ed84

0800ff80 <fCmdBuild_DIRECT_CMD>:

at_status_t fCmdBuild_DIRECT_CMD(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ff80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ff82:	4606      	mov	r6, r0
 800ff84:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_DIRECT_CMD()")
 800ff86:	4c38      	ldr	r4, [pc, #224]	; (8010068 <fCmdBuild_DIRECT_CMD+0xe8>)
 800ff88:	4d38      	ldr	r5, [pc, #224]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 800ff8a:	f104 0e20 	add.w	lr, r4, #32
 800ff8e:	46a4      	mov	ip, r4
 800ff90:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ff94:	6028      	str	r0, [r5, #0]
 800ff96:	6069      	str	r1, [r5, #4]
 800ff98:	60aa      	str	r2, [r5, #8]
 800ff9a:	60eb      	str	r3, [r5, #12]
 800ff9c:	4664      	mov	r4, ip
 800ff9e:	3510      	adds	r5, #16
 800ffa0:	45f4      	cmp	ip, lr
 800ffa2:	d1f4      	bne.n	800ff8e <fCmdBuild_DIRECT_CMD+0xe>
 800ffa4:	cc07      	ldmia	r4!, {r0, r1, r2}
 800ffa6:	6028      	str	r0, [r5, #0]
 800ffa8:	6069      	str	r1, [r5, #4]
 800ffaa:	60aa      	str	r2, [r5, #8]
 800ffac:	4c2f      	ldr	r4, [pc, #188]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 800ffae:	4620      	mov	r0, r4
 800ffb0:	f00f f8af 	bl	801f112 <crs_strlen>
 800ffb4:	b283      	uxth	r3, r0
 800ffb6:	4622      	mov	r2, r4
 800ffb8:	2104      	movs	r1, #4
 800ffba:	2002      	movs	r0, #2
 800ffbc:	f00f f8ec 	bl	801f198 <traceIF_itmPrint>
 800ffc0:	4620      	mov	r0, r4
 800ffc2:	f00f f8a6 	bl	801f112 <crs_strlen>
 800ffc6:	b283      	uxth	r3, r0
 800ffc8:	4622      	mov	r2, r4
 800ffca:	2104      	movs	r1, #4
 800ffcc:	2002      	movs	r0, #2
 800ffce:	f00f f905 	bl	801f1dc <traceIF_uartPrint>

  /* only for RAW command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD)
 800ffd2:	8933      	ldrh	r3, [r6, #8]
 800ffd4:	2b06      	cmp	r3, #6
 800ffd6:	d001      	beq.n	800ffdc <fCmdBuild_DIRECT_CMD+0x5c>
  at_status_t retval = ATSTATUS_OK;
 800ffd8:	2000      	movs	r0, #0
      PRINT_ERR("ERROR, send buffer is empty")
      retval = ATSTATUS_ERROR;
    }
  }
  return (retval);
}
 800ffda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->SID_ctxt.direct_cmd_tx->cmd_size != 0U)
 800ffdc:	f8d7 1714 	ldr.w	r1, [r7, #1812]	; 0x714
 800ffe0:	f8b1 4076 	ldrh.w	r4, [r1, #118]	; 0x76
 800ffe4:	b1b4      	cbz	r4, 8010014 <fCmdBuild_DIRECT_CMD+0x94>
      (void) memcpy((void *)p_atp_ctxt->current_atcmd.params,
 800ffe6:	4622      	mov	r2, r4
 800ffe8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ffec:	f015 ff90 	bl	8025f10 <memcpy>
      uint32_t endstr_size = strlen((CRC_CHAR_t *)&p_atp_ctxt->endstr);
 800fff0:	f206 6774 	addw	r7, r6, #1652	; 0x674
 800fff4:	4638      	mov	r0, r7
 800fff6:	f7f0 f8fd 	bl	80001f4 <strlen>
 800fffa:	4605      	mov	r5, r0
      (void) memcpy((void *)&p_atp_ctxt->current_atcmd.params[str_size],
 800fffc:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8010000:	462a      	mov	r2, r5
 8010002:	4639      	mov	r1, r7
 8010004:	4430      	add	r0, r6
 8010006:	f015 ff83 	bl	8025f10 <memcpy>
      p_atp_ctxt->current_atcmd.raw_cmd_size = str_size + endstr_size;
 801000a:	442c      	add	r4, r5
 801000c:	f8c6 4670 	str.w	r4, [r6, #1648]	; 0x670
  at_status_t retval = ATSTATUS_OK;
 8010010:	2000      	movs	r0, #0
 8010012:	e7e2      	b.n	800ffda <fCmdBuild_DIRECT_CMD+0x5a>
      PRINT_ERR("ERROR, send buffer is empty")
 8010014:	4d16      	ldr	r5, [pc, #88]	; (8010070 <fCmdBuild_DIRECT_CMD+0xf0>)
 8010016:	4c15      	ldr	r4, [pc, #84]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 8010018:	f105 0720 	add.w	r7, r5, #32
 801001c:	462e      	mov	r6, r5
 801001e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8010020:	6020      	str	r0, [r4, #0]
 8010022:	6061      	str	r1, [r4, #4]
 8010024:	60a2      	str	r2, [r4, #8]
 8010026:	60e3      	str	r3, [r4, #12]
 8010028:	4635      	mov	r5, r6
 801002a:	3410      	adds	r4, #16
 801002c:	42be      	cmp	r6, r7
 801002e:	d1f5      	bne.n	801001c <fCmdBuild_DIRECT_CMD+0x9c>
 8010030:	cd07      	ldmia	r5!, {r0, r1, r2}
 8010032:	6020      	str	r0, [r4, #0]
 8010034:	6061      	str	r1, [r4, #4]
 8010036:	60a2      	str	r2, [r4, #8]
 8010038:	782b      	ldrb	r3, [r5, #0]
 801003a:	7323      	strb	r3, [r4, #12]
 801003c:	4c0b      	ldr	r4, [pc, #44]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 801003e:	4620      	mov	r0, r4
 8010040:	f00f f867 	bl	801f112 <crs_strlen>
 8010044:	b283      	uxth	r3, r0
 8010046:	4622      	mov	r2, r4
 8010048:	2110      	movs	r1, #16
 801004a:	2002      	movs	r0, #2
 801004c:	f00f f8a4 	bl	801f198 <traceIF_itmPrint>
 8010050:	4620      	mov	r0, r4
 8010052:	f00f f85e 	bl	801f112 <crs_strlen>
 8010056:	b283      	uxth	r3, r0
 8010058:	4622      	mov	r2, r4
 801005a:	2110      	movs	r1, #16
 801005c:	2002      	movs	r0, #2
 801005e:	f00f f8bd 	bl	801f1dc <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 8010062:	2001      	movs	r0, #1
 8010064:	e7b9      	b.n	800ffda <fCmdBuild_DIRECT_CMD+0x5a>
 8010066:	bf00      	nop
 8010068:	0802ed90 	.word	0x0802ed90
 801006c:	200048dc 	.word	0x200048dc
 8010070:	0802edbc 	.word	0x0802edbc

08010074 <fRspAnalyze_None>:

/* ==========================  Analyze 3GPP TS 27.007 commands ========================== */
at_action_rsp_t fRspAnalyze_None(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010074:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_None()")
 8010076:	4c13      	ldr	r4, [pc, #76]	; (80100c4 <fRspAnalyze_None+0x50>)
 8010078:	4d13      	ldr	r5, [pc, #76]	; (80100c8 <fRspAnalyze_None+0x54>)
 801007a:	f104 0e20 	add.w	lr, r4, #32
 801007e:	46a4      	mov	ip, r4
 8010080:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010084:	6028      	str	r0, [r5, #0]
 8010086:	6069      	str	r1, [r5, #4]
 8010088:	60aa      	str	r2, [r5, #8]
 801008a:	60eb      	str	r3, [r5, #12]
 801008c:	4664      	mov	r4, ip
 801008e:	3510      	adds	r5, #16
 8010090:	45f4      	cmp	ip, lr
 8010092:	d1f4      	bne.n	801007e <fRspAnalyze_None+0xa>
 8010094:	cc03      	ldmia	r4!, {r0, r1}
 8010096:	6028      	str	r0, [r5, #0]
 8010098:	6069      	str	r1, [r5, #4]
 801009a:	4c0b      	ldr	r4, [pc, #44]	; (80100c8 <fRspAnalyze_None+0x54>)
 801009c:	4620      	mov	r0, r4
 801009e:	f00f f838 	bl	801f112 <crs_strlen>
 80100a2:	b283      	uxth	r3, r0
 80100a4:	4622      	mov	r2, r4
 80100a6:	2104      	movs	r1, #4
 80100a8:	2002      	movs	r0, #2
 80100aa:	f00f f875 	bl	801f198 <traceIF_itmPrint>
 80100ae:	4620      	mov	r0, r4
 80100b0:	f00f f82f 	bl	801f112 <crs_strlen>
 80100b4:	b283      	uxth	r3, r0
 80100b6:	4622      	mov	r2, r4
 80100b8:	2104      	movs	r1, #4
 80100ba:	2002      	movs	r0, #2
 80100bc:	f00f f88e 	bl	801f1dc <traceIF_uartPrint>

  /* no parameters expected */

  return (retval);
}
 80100c0:	2010      	movs	r0, #16
 80100c2:	bd38      	pop	{r3, r4, r5, pc}
 80100c4:	0802edec 	.word	0x0802edec
 80100c8:	200048dc 	.word	0x200048dc

080100cc <fRspAnalyze_CmeErr>:
  return (retval);
}

at_action_rsp_t fRspAnalyze_CmeErr(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80100cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80100d0:	4606      	mov	r6, r0
 80100d2:	460f      	mov	r7, r1
 80100d4:	4690      	mov	r8, r2
 80100d6:	4699      	mov	r9, r3
  const atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  /*UNUSED(p_msg_in);*/
  /*UNUSED(element_infos);*/

  at_action_rsp_t retval = ATACTION_RSP_ERROR;
  PRINT_API("enter fRspAnalyze_CmeErr()")
 80100d8:	4cbc      	ldr	r4, [pc, #752]	; (80103cc <fRspAnalyze_CmeErr+0x300>)
 80100da:	4dbd      	ldr	r5, [pc, #756]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80100dc:	f104 0e20 	add.w	lr, r4, #32
 80100e0:	46a4      	mov	ip, r4
 80100e2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80100e6:	6028      	str	r0, [r5, #0]
 80100e8:	6069      	str	r1, [r5, #4]
 80100ea:	60aa      	str	r2, [r5, #8]
 80100ec:	60eb      	str	r3, [r5, #12]
 80100ee:	4664      	mov	r4, ip
 80100f0:	3510      	adds	r5, #16
 80100f2:	45f4      	cmp	ip, lr
 80100f4:	d1f4      	bne.n	80100e0 <fRspAnalyze_CmeErr+0x14>
 80100f6:	cc03      	ldmia	r4!, {r0, r1}
 80100f8:	6028      	str	r0, [r5, #0]
 80100fa:	6069      	str	r1, [r5, #4]
 80100fc:	8823      	ldrh	r3, [r4, #0]
 80100fe:	812b      	strh	r3, [r5, #8]
 8010100:	4cb3      	ldr	r4, [pc, #716]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010102:	4620      	mov	r0, r4
 8010104:	f00f f805 	bl	801f112 <crs_strlen>
 8010108:	b283      	uxth	r3, r0
 801010a:	4622      	mov	r2, r4
 801010c:	2104      	movs	r1, #4
 801010e:	2002      	movs	r0, #2
 8010110:	f00f f842 	bl	801f198 <traceIF_itmPrint>
 8010114:	4620      	mov	r0, r4
 8010116:	f00e fffc 	bl	801f112 <crs_strlen>
 801011a:	b283      	uxth	r3, r0
 801011c:	4622      	mov	r2, r4
 801011e:	2104      	movs	r1, #4
 8010120:	2002      	movs	r0, #2
 8010122:	f00f f85b 	bl	801f1dc <traceIF_uartPrint>

  /* Analyze CME error to report it to upper layers */
  (void) analyze_CmeError(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 8010126:	464b      	mov	r3, r9
 8010128:	4642      	mov	r2, r8
 801012a:	4639      	mov	r1, r7
 801012c:	4630      	mov	r0, r6
 801012e:	f7fe fbeb 	bl	800e908 <analyze_CmeError>

  /* specific treatments for +CME ERROR, depending of current command */
  switch (p_atp_ctxt->current_atcmd.id)
 8010132:	69f2      	ldr	r2, [r6, #28]
 8010134:	f1a2 030b 	sub.w	r3, r2, #11
 8010138:	2b25      	cmp	r3, #37	; 0x25
 801013a:	f200 8239 	bhi.w	80105b0 <fRspAnalyze_CmeErr+0x4e4>
 801013e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8010142:	0115      	.short	0x0115
 8010144:	01870157 	.word	0x01870157
 8010148:	00e40026 	.word	0x00e40026
 801014c:	02370237 	.word	0x02370237
 8010150:	02370212 	.word	0x02370212
 8010154:	01b60237 	.word	0x01b60237
 8010158:	02370237 	.word	0x02370237
 801015c:	02370237 	.word	0x02370237
 8010160:	02370237 	.word	0x02370237
 8010164:	02370237 	.word	0x02370237
 8010168:	02370237 	.word	0x02370237
 801016c:	02370237 	.word	0x02370237
 8010170:	02370237 	.word	0x02370237
 8010174:	02370237 	.word	0x02370237
 8010178:	02370237 	.word	0x02370237
 801017c:	02370237 	.word	0x02370237
 8010180:	02370237 	.word	0x02370237
 8010184:	02370237 	.word	0x02370237
 8010188:	02370237 	.word	0x02370237
 801018c:	01e5      	.short	0x01e5
  {
    case CMD_AT_CGSN:
    {
      if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SN)
 801018e:	f897 372c 	ldrb.w	r3, [r7, #1836]	; 0x72c
 8010192:	b36b      	cbz	r3, 80101f0 <fRspAnalyze_CmeErr+0x124>
      {
        PRINT_DBG("Modem Error for CGSN_SN, use unitialized value")
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number), 0, MAX_SIZE_SN);
      }
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEI)
 8010194:	2b01      	cmp	r3, #1
 8010196:	d059      	beq.n	801024c <fRspAnalyze_CmeErr+0x180>
      {
        PRINT_DBG("Modem Error for CGSN_IMEI, use unitialized value")
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei), 0, MAX_SIZE_IMEI);
      }
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEISV)
 8010198:	2b02      	cmp	r3, #2
 801019a:	f000 8084 	beq.w	80102a6 <fRspAnalyze_CmeErr+0x1da>
      {
        PRINT_DBG("Modem Error for CGSN_IMEISV, use unitialized value, parameter ignored")
      }
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SVN)
 801019e:	2b03      	cmp	r3, #3
 80101a0:	f000 809a 	beq.w	80102d8 <fRspAnalyze_CmeErr+0x20c>
      {
        PRINT_DBG("Modem Error for CGSN_SVN, use unitialized value, parameter ignored")
      }
      else
      {
        PRINT_DBG("Modem Error for CGSN, unexpected parameter")
 80101a4:	4e8b      	ldr	r6, [pc, #556]	; (80103d4 <fRspAnalyze_CmeErr+0x308>)
 80101a6:	4c8a      	ldr	r4, [pc, #552]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80101a8:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80101ac:	4635      	mov	r5, r6
 80101ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80101b0:	6020      	str	r0, [r4, #0]
 80101b2:	6061      	str	r1, [r4, #4]
 80101b4:	60a2      	str	r2, [r4, #8]
 80101b6:	60e3      	str	r3, [r4, #12]
 80101b8:	462e      	mov	r6, r5
 80101ba:	3410      	adds	r4, #16
 80101bc:	42bd      	cmp	r5, r7
 80101be:	d1f5      	bne.n	80101ac <fRspAnalyze_CmeErr+0xe0>
 80101c0:	6828      	ldr	r0, [r5, #0]
 80101c2:	6020      	str	r0, [r4, #0]
 80101c4:	88ab      	ldrh	r3, [r5, #4]
 80101c6:	80a3      	strh	r3, [r4, #4]
 80101c8:	4c81      	ldr	r4, [pc, #516]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80101ca:	4620      	mov	r0, r4
 80101cc:	f00e ffa1 	bl	801f112 <crs_strlen>
 80101d0:	b283      	uxth	r3, r0
 80101d2:	4622      	mov	r2, r4
 80101d4:	2102      	movs	r1, #2
 80101d6:	4608      	mov	r0, r1
 80101d8:	f00e ffde 	bl	801f198 <traceIF_itmPrint>
 80101dc:	4620      	mov	r0, r4
 80101de:	f00e ff98 	bl	801f112 <crs_strlen>
 80101e2:	b283      	uxth	r3, r0
 80101e4:	4622      	mov	r2, r4
 80101e6:	2102      	movs	r1, #2
 80101e8:	4608      	mov	r0, r1
 80101ea:	f00e fff7 	bl	801f1dc <traceIF_uartPrint>
        retval = ATACTION_RSP_ERROR;
 80101ee:	e0ba      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_SN, use unitialized value")
 80101f0:	4d79      	ldr	r5, [pc, #484]	; (80103d8 <fRspAnalyze_CmeErr+0x30c>)
 80101f2:	4c77      	ldr	r4, [pc, #476]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80101f4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80101f8:	462e      	mov	r6, r5
 80101fa:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80101fc:	6020      	str	r0, [r4, #0]
 80101fe:	6061      	str	r1, [r4, #4]
 8010200:	60a2      	str	r2, [r4, #8]
 8010202:	60e3      	str	r3, [r4, #12]
 8010204:	4635      	mov	r5, r6
 8010206:	3410      	adds	r4, #16
 8010208:	4566      	cmp	r6, ip
 801020a:	d1f5      	bne.n	80101f8 <fRspAnalyze_CmeErr+0x12c>
 801020c:	cd03      	ldmia	r5!, {r0, r1}
 801020e:	6020      	str	r0, [r4, #0]
 8010210:	6061      	str	r1, [r4, #4]
 8010212:	882b      	ldrh	r3, [r5, #0]
 8010214:	8123      	strh	r3, [r4, #8]
 8010216:	4c6e      	ldr	r4, [pc, #440]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010218:	4620      	mov	r0, r4
 801021a:	f00e ff7a 	bl	801f112 <crs_strlen>
 801021e:	b283      	uxth	r3, r0
 8010220:	4622      	mov	r2, r4
 8010222:	2102      	movs	r1, #2
 8010224:	4608      	mov	r0, r1
 8010226:	f00e ffb7 	bl	801f198 <traceIF_itmPrint>
 801022a:	4620      	mov	r0, r4
 801022c:	f00e ff71 	bl	801f112 <crs_strlen>
 8010230:	b283      	uxth	r3, r0
 8010232:	4622      	mov	r2, r4
 8010234:	2102      	movs	r1, #2
 8010236:	4608      	mov	r0, r1
 8010238:	f00e ffd0 	bl	801f1dc <traceIF_uartPrint>
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number), 0, MAX_SIZE_SN);
 801023c:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 8010240:	2240      	movs	r2, #64	; 0x40
 8010242:	2100      	movs	r1, #0
 8010244:	3002      	adds	r0, #2
 8010246:	f015 fd86 	bl	8025d56 <memset>
 801024a:	e08c      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_IMEI, use unitialized value")
 801024c:	4d63      	ldr	r5, [pc, #396]	; (80103dc <fRspAnalyze_CmeErr+0x310>)
 801024e:	4c60      	ldr	r4, [pc, #384]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010250:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8010254:	462e      	mov	r6, r5
 8010256:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8010258:	6020      	str	r0, [r4, #0]
 801025a:	6061      	str	r1, [r4, #4]
 801025c:	60a2      	str	r2, [r4, #8]
 801025e:	60e3      	str	r3, [r4, #12]
 8010260:	4635      	mov	r5, r6
 8010262:	3410      	adds	r4, #16
 8010264:	4566      	cmp	r6, ip
 8010266:	d1f5      	bne.n	8010254 <fRspAnalyze_CmeErr+0x188>
 8010268:	cd07      	ldmia	r5!, {r0, r1, r2}
 801026a:	6020      	str	r0, [r4, #0]
 801026c:	6061      	str	r1, [r4, #4]
 801026e:	60a2      	str	r2, [r4, #8]
 8010270:	4c57      	ldr	r4, [pc, #348]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010272:	4620      	mov	r0, r4
 8010274:	f00e ff4d 	bl	801f112 <crs_strlen>
 8010278:	b283      	uxth	r3, r0
 801027a:	4622      	mov	r2, r4
 801027c:	2102      	movs	r1, #2
 801027e:	4608      	mov	r0, r1
 8010280:	f00e ff8a 	bl	801f198 <traceIF_itmPrint>
 8010284:	4620      	mov	r0, r4
 8010286:	f00e ff44 	bl	801f112 <crs_strlen>
 801028a:	b283      	uxth	r3, r0
 801028c:	4622      	mov	r2, r4
 801028e:	2102      	movs	r1, #2
 8010290:	4608      	mov	r0, r1
 8010292:	f00e ffa3 	bl	801f1dc <traceIF_uartPrint>
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei), 0, MAX_SIZE_IMEI);
 8010296:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 801029a:	2240      	movs	r2, #64	; 0x40
 801029c:	2100      	movs	r1, #0
 801029e:	3002      	adds	r0, #2
 80102a0:	f015 fd59 	bl	8025d56 <memset>
 80102a4:	e05f      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_IMEISV, use unitialized value, parameter ignored")
 80102a6:	4c4a      	ldr	r4, [pc, #296]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80102a8:	2251      	movs	r2, #81	; 0x51
 80102aa:	494d      	ldr	r1, [pc, #308]	; (80103e0 <fRspAnalyze_CmeErr+0x314>)
 80102ac:	4620      	mov	r0, r4
 80102ae:	f015 fe2f 	bl	8025f10 <memcpy>
 80102b2:	4620      	mov	r0, r4
 80102b4:	f00e ff2d 	bl	801f112 <crs_strlen>
 80102b8:	b283      	uxth	r3, r0
 80102ba:	4622      	mov	r2, r4
 80102bc:	2102      	movs	r1, #2
 80102be:	4608      	mov	r0, r1
 80102c0:	f00e ff6a 	bl	801f198 <traceIF_itmPrint>
 80102c4:	4620      	mov	r0, r4
 80102c6:	f00e ff24 	bl	801f112 <crs_strlen>
 80102ca:	b283      	uxth	r3, r0
 80102cc:	4622      	mov	r2, r4
 80102ce:	2102      	movs	r1, #2
 80102d0:	4608      	mov	r0, r1
 80102d2:	f00e ff83 	bl	801f1dc <traceIF_uartPrint>
 80102d6:	e046      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_SVN, use unitialized value, parameter ignored")
 80102d8:	4c3d      	ldr	r4, [pc, #244]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80102da:	224e      	movs	r2, #78	; 0x4e
 80102dc:	4941      	ldr	r1, [pc, #260]	; (80103e4 <fRspAnalyze_CmeErr+0x318>)
 80102de:	4620      	mov	r0, r4
 80102e0:	f015 fe16 	bl	8025f10 <memcpy>
 80102e4:	4620      	mov	r0, r4
 80102e6:	f00e ff14 	bl	801f112 <crs_strlen>
 80102ea:	b283      	uxth	r3, r0
 80102ec:	4622      	mov	r2, r4
 80102ee:	2102      	movs	r1, #2
 80102f0:	4608      	mov	r0, r1
 80102f2:	f00e ff51 	bl	801f198 <traceIF_itmPrint>
 80102f6:	4620      	mov	r0, r4
 80102f8:	f00e ff0b 	bl	801f112 <crs_strlen>
 80102fc:	b283      	uxth	r3, r0
 80102fe:	4622      	mov	r2, r4
 8010300:	2102      	movs	r1, #2
 8010302:	4608      	mov	r0, r1
 8010304:	f00e ff6a 	bl	801f1dc <traceIF_uartPrint>
 8010308:	e02d      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      }
      break;
    }

    case CMD_AT_CIMI:
      PRINT_DBG("Modem Error for CIMI, use unitialized value")
 801030a:	4e37      	ldr	r6, [pc, #220]	; (80103e8 <fRspAnalyze_CmeErr+0x31c>)
 801030c:	4c30      	ldr	r4, [pc, #192]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 801030e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010312:	4635      	mov	r5, r6
 8010314:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010316:	6020      	str	r0, [r4, #0]
 8010318:	6061      	str	r1, [r4, #4]
 801031a:	60a2      	str	r2, [r4, #8]
 801031c:	60e3      	str	r3, [r4, #12]
 801031e:	462e      	mov	r6, r5
 8010320:	3410      	adds	r4, #16
 8010322:	4565      	cmp	r5, ip
 8010324:	d1f5      	bne.n	8010312 <fRspAnalyze_CmeErr+0x246>
 8010326:	6828      	ldr	r0, [r5, #0]
 8010328:	6020      	str	r0, [r4, #0]
 801032a:	88aa      	ldrh	r2, [r5, #4]
 801032c:	79ab      	ldrb	r3, [r5, #6]
 801032e:	80a2      	strh	r2, [r4, #4]
 8010330:	71a3      	strb	r3, [r4, #6]
 8010332:	4c27      	ldr	r4, [pc, #156]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010334:	4620      	mov	r0, r4
 8010336:	f00e feec 	bl	801f112 <crs_strlen>
 801033a:	b283      	uxth	r3, r0
 801033c:	4622      	mov	r2, r4
 801033e:	2102      	movs	r1, #2
 8010340:	4608      	mov	r0, r1
 8010342:	f00e ff29 	bl	801f198 <traceIF_itmPrint>
 8010346:	4620      	mov	r0, r4
 8010348:	f00e fee3 	bl	801f112 <crs_strlen>
 801034c:	b283      	uxth	r3, r0
 801034e:	4622      	mov	r2, r4
 8010350:	2102      	movs	r1, #2
 8010352:	4608      	mov	r0, r1
 8010354:	f00e ff42 	bl	801f1dc <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imsi), 0, MAX_SIZE_IMSI);
 8010358:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 801035c:	2240      	movs	r2, #64	; 0x40
 801035e:	2100      	movs	r1, #0
 8010360:	3002      	adds	r0, #2
 8010362:	f015 fcf8 	bl	8025d56 <memset>
      retval = ATACTION_RSP_ERROR;
      break;
  }

  return (retval);
}
 8010366:	2004      	movs	r0, #4
 8010368:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      PRINT_DBG("Modem Error for CGMI, use unitialized value")
 801036c:	4e1f      	ldr	r6, [pc, #124]	; (80103ec <fRspAnalyze_CmeErr+0x320>)
 801036e:	4c18      	ldr	r4, [pc, #96]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010370:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010374:	4635      	mov	r5, r6
 8010376:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010378:	6020      	str	r0, [r4, #0]
 801037a:	6061      	str	r1, [r4, #4]
 801037c:	60a2      	str	r2, [r4, #8]
 801037e:	60e3      	str	r3, [r4, #12]
 8010380:	462e      	mov	r6, r5
 8010382:	3410      	adds	r4, #16
 8010384:	4565      	cmp	r5, ip
 8010386:	d1f5      	bne.n	8010374 <fRspAnalyze_CmeErr+0x2a8>
 8010388:	6828      	ldr	r0, [r5, #0]
 801038a:	6020      	str	r0, [r4, #0]
 801038c:	88aa      	ldrh	r2, [r5, #4]
 801038e:	79ab      	ldrb	r3, [r5, #6]
 8010390:	80a2      	strh	r2, [r4, #4]
 8010392:	71a3      	strb	r3, [r4, #6]
 8010394:	4c0e      	ldr	r4, [pc, #56]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010396:	4620      	mov	r0, r4
 8010398:	f00e febb 	bl	801f112 <crs_strlen>
 801039c:	b283      	uxth	r3, r0
 801039e:	4622      	mov	r2, r4
 80103a0:	2102      	movs	r1, #2
 80103a2:	4608      	mov	r0, r1
 80103a4:	f00e fef8 	bl	801f198 <traceIF_itmPrint>
 80103a8:	4620      	mov	r0, r4
 80103aa:	f00e feb2 	bl	801f112 <crs_strlen>
 80103ae:	b283      	uxth	r3, r0
 80103b0:	4622      	mov	r2, r4
 80103b2:	2102      	movs	r1, #2
 80103b4:	4608      	mov	r0, r1
 80103b6:	f00e ff11 	bl	801f1dc <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.manufacturer_name), 0, MAX_SIZE_MANUFACT_NAME);
 80103ba:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 80103be:	f44f 7280 	mov.w	r2, #256	; 0x100
 80103c2:	2100      	movs	r1, #0
 80103c4:	3002      	adds	r0, #2
 80103c6:	f015 fcc6 	bl	8025d56 <memset>
      break;
 80103ca:	e7cc      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
 80103cc:	0802ee14 	.word	0x0802ee14
 80103d0:	200048dc 	.word	0x200048dc
 80103d4:	0802ef5c 	.word	0x0802ef5c
 80103d8:	0802ee40 	.word	0x0802ee40
 80103dc:	0802ee7c 	.word	0x0802ee7c
 80103e0:	0802eeb8 	.word	0x0802eeb8
 80103e4:	0802ef0c 	.word	0x0802ef0c
 80103e8:	0802ef94 	.word	0x0802ef94
 80103ec:	0802efcc 	.word	0x0802efcc
      PRINT_DBG("Modem Error for CGMM, use unitialized value")
 80103f0:	4e7b      	ldr	r6, [pc, #492]	; (80105e0 <fRspAnalyze_CmeErr+0x514>)
 80103f2:	4c7c      	ldr	r4, [pc, #496]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80103f4:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80103f8:	4635      	mov	r5, r6
 80103fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80103fc:	6020      	str	r0, [r4, #0]
 80103fe:	6061      	str	r1, [r4, #4]
 8010400:	60a2      	str	r2, [r4, #8]
 8010402:	60e3      	str	r3, [r4, #12]
 8010404:	462e      	mov	r6, r5
 8010406:	3410      	adds	r4, #16
 8010408:	4565      	cmp	r5, ip
 801040a:	d1f5      	bne.n	80103f8 <fRspAnalyze_CmeErr+0x32c>
 801040c:	6828      	ldr	r0, [r5, #0]
 801040e:	6020      	str	r0, [r4, #0]
 8010410:	88aa      	ldrh	r2, [r5, #4]
 8010412:	79ab      	ldrb	r3, [r5, #6]
 8010414:	80a2      	strh	r2, [r4, #4]
 8010416:	71a3      	strb	r3, [r4, #6]
 8010418:	4c72      	ldr	r4, [pc, #456]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801041a:	4620      	mov	r0, r4
 801041c:	f00e fe79 	bl	801f112 <crs_strlen>
 8010420:	b283      	uxth	r3, r0
 8010422:	4622      	mov	r2, r4
 8010424:	2102      	movs	r1, #2
 8010426:	4608      	mov	r0, r1
 8010428:	f00e feb6 	bl	801f198 <traceIF_itmPrint>
 801042c:	4620      	mov	r0, r4
 801042e:	f00e fe70 	bl	801f112 <crs_strlen>
 8010432:	b283      	uxth	r3, r0
 8010434:	4622      	mov	r2, r4
 8010436:	2102      	movs	r1, #2
 8010438:	4608      	mov	r0, r1
 801043a:	f00e fecf 	bl	801f1dc <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.model), 0, MAX_SIZE_MODEL);
 801043e:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 8010442:	f44f 7280 	mov.w	r2, #256	; 0x100
 8010446:	2100      	movs	r1, #0
 8010448:	3002      	adds	r0, #2
 801044a:	f015 fc84 	bl	8025d56 <memset>
      break;
 801044e:	e78a      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for CGMR, use unitialized value")
 8010450:	4e65      	ldr	r6, [pc, #404]	; (80105e8 <fRspAnalyze_CmeErr+0x51c>)
 8010452:	4c64      	ldr	r4, [pc, #400]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 8010454:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010458:	4635      	mov	r5, r6
 801045a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801045c:	6020      	str	r0, [r4, #0]
 801045e:	6061      	str	r1, [r4, #4]
 8010460:	60a2      	str	r2, [r4, #8]
 8010462:	60e3      	str	r3, [r4, #12]
 8010464:	462e      	mov	r6, r5
 8010466:	3410      	adds	r4, #16
 8010468:	4565      	cmp	r5, ip
 801046a:	d1f5      	bne.n	8010458 <fRspAnalyze_CmeErr+0x38c>
 801046c:	6828      	ldr	r0, [r5, #0]
 801046e:	6020      	str	r0, [r4, #0]
 8010470:	88aa      	ldrh	r2, [r5, #4]
 8010472:	79ab      	ldrb	r3, [r5, #6]
 8010474:	80a2      	strh	r2, [r4, #4]
 8010476:	71a3      	strb	r3, [r4, #6]
 8010478:	4c5a      	ldr	r4, [pc, #360]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801047a:	4620      	mov	r0, r4
 801047c:	f00e fe49 	bl	801f112 <crs_strlen>
 8010480:	b283      	uxth	r3, r0
 8010482:	4622      	mov	r2, r4
 8010484:	2102      	movs	r1, #2
 8010486:	4608      	mov	r0, r1
 8010488:	f00e fe86 	bl	801f198 <traceIF_itmPrint>
 801048c:	4620      	mov	r0, r4
 801048e:	f00e fe40 	bl	801f112 <crs_strlen>
 8010492:	b283      	uxth	r3, r0
 8010494:	4622      	mov	r2, r4
 8010496:	2102      	movs	r1, #2
 8010498:	4608      	mov	r0, r1
 801049a:	f00e fe9f 	bl	801f1dc <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.revision), 0, MAX_SIZE_REV);
 801049e:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 80104a2:	2240      	movs	r2, #64	; 0x40
 80104a4:	2100      	movs	r1, #0
 80104a6:	3002      	adds	r0, #2
 80104a8:	f015 fc55 	bl	8025d56 <memset>
      break;
 80104ac:	e75b      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for CNUM, use unitialized value")
 80104ae:	4e4f      	ldr	r6, [pc, #316]	; (80105ec <fRspAnalyze_CmeErr+0x520>)
 80104b0:	4c4c      	ldr	r4, [pc, #304]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80104b2:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80104b6:	4635      	mov	r5, r6
 80104b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80104ba:	6020      	str	r0, [r4, #0]
 80104bc:	6061      	str	r1, [r4, #4]
 80104be:	60a2      	str	r2, [r4, #8]
 80104c0:	60e3      	str	r3, [r4, #12]
 80104c2:	462e      	mov	r6, r5
 80104c4:	3410      	adds	r4, #16
 80104c6:	4565      	cmp	r5, ip
 80104c8:	d1f5      	bne.n	80104b6 <fRspAnalyze_CmeErr+0x3ea>
 80104ca:	6828      	ldr	r0, [r5, #0]
 80104cc:	6020      	str	r0, [r4, #0]
 80104ce:	88aa      	ldrh	r2, [r5, #4]
 80104d0:	79ab      	ldrb	r3, [r5, #6]
 80104d2:	80a2      	strh	r2, [r4, #4]
 80104d4:	71a3      	strb	r3, [r4, #6]
 80104d6:	4c43      	ldr	r4, [pc, #268]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80104d8:	4620      	mov	r0, r4
 80104da:	f00e fe1a 	bl	801f112 <crs_strlen>
 80104de:	b283      	uxth	r3, r0
 80104e0:	4622      	mov	r2, r4
 80104e2:	2102      	movs	r1, #2
 80104e4:	4608      	mov	r0, r1
 80104e6:	f00e fe57 	bl	801f198 <traceIF_itmPrint>
 80104ea:	4620      	mov	r0, r4
 80104ec:	f00e fe11 	bl	801f112 <crs_strlen>
 80104f0:	b283      	uxth	r3, r0
 80104f2:	4622      	mov	r2, r4
 80104f4:	2102      	movs	r1, #2
 80104f6:	4608      	mov	r0, r1
 80104f8:	f00e fe70 	bl	801f1dc <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.phone_number), 0, MAX_SIZE_PHONE_NBR);
 80104fc:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 8010500:	2240      	movs	r2, #64	; 0x40
 8010502:	2100      	movs	r1, #0
 8010504:	3002      	adds	r0, #2
 8010506:	f015 fc26 	bl	8025d56 <memset>
      break;
 801050a:	e72c      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for GSN, use unitialized value")
 801050c:	4e38      	ldr	r6, [pc, #224]	; (80105f0 <fRspAnalyze_CmeErr+0x524>)
 801050e:	4c35      	ldr	r4, [pc, #212]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 8010510:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010514:	4635      	mov	r5, r6
 8010516:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010518:	6020      	str	r0, [r4, #0]
 801051a:	6061      	str	r1, [r4, #4]
 801051c:	60a2      	str	r2, [r4, #8]
 801051e:	60e3      	str	r3, [r4, #12]
 8010520:	462e      	mov	r6, r5
 8010522:	3410      	adds	r4, #16
 8010524:	4565      	cmp	r5, ip
 8010526:	d1f5      	bne.n	8010514 <fRspAnalyze_CmeErr+0x448>
 8010528:	6828      	ldr	r0, [r5, #0]
 801052a:	6020      	str	r0, [r4, #0]
 801052c:	88ab      	ldrh	r3, [r5, #4]
 801052e:	80a3      	strh	r3, [r4, #4]
 8010530:	4c2c      	ldr	r4, [pc, #176]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 8010532:	4620      	mov	r0, r4
 8010534:	f00e fded 	bl	801f112 <crs_strlen>
 8010538:	b283      	uxth	r3, r0
 801053a:	4622      	mov	r2, r4
 801053c:	2102      	movs	r1, #2
 801053e:	4608      	mov	r0, r1
 8010540:	f00e fe2a 	bl	801f198 <traceIF_itmPrint>
 8010544:	4620      	mov	r0, r4
 8010546:	f00e fde4 	bl	801f112 <crs_strlen>
 801054a:	b283      	uxth	r3, r0
 801054c:	4622      	mov	r2, r4
 801054e:	2102      	movs	r1, #2
 8010550:	4608      	mov	r0, r1
 8010552:	f00e fe43 	bl	801f1dc <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei), 0, MAX_SIZE_IMEI);
 8010556:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 801055a:	2240      	movs	r2, #64	; 0x40
 801055c:	2100      	movs	r1, #0
 801055e:	3002      	adds	r0, #2
 8010560:	f015 fbf9 	bl	8025d56 <memset>
      break;
 8010564:	e6ff      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Analyze Modem Error for CPIN")
 8010566:	4e23      	ldr	r6, [pc, #140]	; (80105f4 <fRspAnalyze_CmeErr+0x528>)
 8010568:	4c1e      	ldr	r4, [pc, #120]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801056a:	f106 0720 	add.w	r7, r6, #32
 801056e:	4635      	mov	r5, r6
 8010570:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010572:	6020      	str	r0, [r4, #0]
 8010574:	6061      	str	r1, [r4, #4]
 8010576:	60a2      	str	r2, [r4, #8]
 8010578:	60e3      	str	r3, [r4, #12]
 801057a:	462e      	mov	r6, r5
 801057c:	3410      	adds	r4, #16
 801057e:	42bd      	cmp	r5, r7
 8010580:	d1f5      	bne.n	801056e <fRspAnalyze_CmeErr+0x4a2>
 8010582:	ce03      	ldmia	r6!, {r0, r1}
 8010584:	6020      	str	r0, [r4, #0]
 8010586:	6061      	str	r1, [r4, #4]
 8010588:	4c16      	ldr	r4, [pc, #88]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801058a:	4620      	mov	r0, r4
 801058c:	f00e fdc1 	bl	801f112 <crs_strlen>
 8010590:	b283      	uxth	r3, r0
 8010592:	4622      	mov	r2, r4
 8010594:	2102      	movs	r1, #2
 8010596:	4608      	mov	r0, r1
 8010598:	f00e fdfe 	bl	801f198 <traceIF_itmPrint>
 801059c:	4620      	mov	r0, r4
 801059e:	f00e fdb8 	bl	801f112 <crs_strlen>
 80105a2:	b283      	uxth	r3, r0
 80105a4:	4622      	mov	r2, r4
 80105a6:	2102      	movs	r1, #2
 80105a8:	4608      	mov	r0, r1
 80105aa:	f00e fe17 	bl	801f1dc <traceIF_uartPrint>
      break;
 80105ae:	e6da      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for cmd (id=%ld)", p_atp_ctxt->current_atcmd.id)
 80105b0:	4c0c      	ldr	r4, [pc, #48]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80105b2:	4911      	ldr	r1, [pc, #68]	; (80105f8 <fRspAnalyze_CmeErr+0x52c>)
 80105b4:	4620      	mov	r0, r4
 80105b6:	f015 fb5b 	bl	8025c70 <sprintf>
 80105ba:	4620      	mov	r0, r4
 80105bc:	f00e fda9 	bl	801f112 <crs_strlen>
 80105c0:	b283      	uxth	r3, r0
 80105c2:	4622      	mov	r2, r4
 80105c4:	2102      	movs	r1, #2
 80105c6:	4608      	mov	r0, r1
 80105c8:	f00e fde6 	bl	801f198 <traceIF_itmPrint>
 80105cc:	4620      	mov	r0, r4
 80105ce:	f00e fda0 	bl	801f112 <crs_strlen>
 80105d2:	b283      	uxth	r3, r0
 80105d4:	4622      	mov	r2, r4
 80105d6:	2102      	movs	r1, #2
 80105d8:	4608      	mov	r0, r1
 80105da:	f00e fdff 	bl	801f1dc <traceIF_uartPrint>
      break;
 80105de:	e6c2      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
 80105e0:	0802f004 	.word	0x0802f004
 80105e4:	200048dc 	.word	0x200048dc
 80105e8:	0802f03c 	.word	0x0802f03c
 80105ec:	0802f074 	.word	0x0802f074
 80105f0:	0802f0ac 	.word	0x0802f0ac
 80105f4:	0802f0e4 	.word	0x0802f0e4
 80105f8:	0802f10c 	.word	0x0802f10c

080105fc <fRspAnalyze_Error>:
{
 80105fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010600:	4606      	mov	r6, r0
 8010602:	460f      	mov	r7, r1
 8010604:	4690      	mov	r8, r2
 8010606:	4699      	mov	r9, r3
  PRINT_API("enter fRspAnalyze_Error()")
 8010608:	4c17      	ldr	r4, [pc, #92]	; (8010668 <fRspAnalyze_Error+0x6c>)
 801060a:	4d18      	ldr	r5, [pc, #96]	; (801066c <fRspAnalyze_Error+0x70>)
 801060c:	f104 0e20 	add.w	lr, r4, #32
 8010610:	46a4      	mov	ip, r4
 8010612:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010616:	6028      	str	r0, [r5, #0]
 8010618:	6069      	str	r1, [r5, #4]
 801061a:	60aa      	str	r2, [r5, #8]
 801061c:	60eb      	str	r3, [r5, #12]
 801061e:	4664      	mov	r4, ip
 8010620:	3510      	adds	r5, #16
 8010622:	45f4      	cmp	ip, lr
 8010624:	d1f4      	bne.n	8010610 <fRspAnalyze_Error+0x14>
 8010626:	cc03      	ldmia	r4!, {r0, r1}
 8010628:	6028      	str	r0, [r5, #0]
 801062a:	6069      	str	r1, [r5, #4]
 801062c:	7823      	ldrb	r3, [r4, #0]
 801062e:	722b      	strb	r3, [r5, #8]
 8010630:	4c0e      	ldr	r4, [pc, #56]	; (801066c <fRspAnalyze_Error+0x70>)
 8010632:	4620      	mov	r0, r4
 8010634:	f00e fd6d 	bl	801f112 <crs_strlen>
 8010638:	b283      	uxth	r3, r0
 801063a:	4622      	mov	r2, r4
 801063c:	2104      	movs	r1, #4
 801063e:	2002      	movs	r0, #2
 8010640:	f00e fdaa 	bl	801f198 <traceIF_itmPrint>
 8010644:	4620      	mov	r0, r4
 8010646:	f00e fd64 	bl	801f112 <crs_strlen>
 801064a:	b283      	uxth	r3, r0
 801064c:	4622      	mov	r2, r4
 801064e:	2104      	movs	r1, #4
 8010650:	2002      	movs	r0, #2
 8010652:	f00e fdc3 	bl	801f1dc <traceIF_uartPrint>
  retval = fRspAnalyze_CmeErr(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 8010656:	464b      	mov	r3, r9
 8010658:	4642      	mov	r2, r8
 801065a:	4639      	mov	r1, r7
 801065c:	4630      	mov	r0, r6
 801065e:	f7ff fd35 	bl	80100cc <fRspAnalyze_CmeErr>
}
 8010662:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010666:	bf00      	nop
 8010668:	0802f134 	.word	0x0802f134
 801066c:	200048dc 	.word	0x200048dc

08010670 <fRspAnalyze_CmsErr>:

at_action_rsp_t fRspAnalyze_CmsErr(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010670:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CmsErr()")
 8010672:	4c14      	ldr	r4, [pc, #80]	; (80106c4 <fRspAnalyze_CmsErr+0x54>)
 8010674:	4d14      	ldr	r5, [pc, #80]	; (80106c8 <fRspAnalyze_CmsErr+0x58>)
 8010676:	f104 0e20 	add.w	lr, r4, #32
 801067a:	46a4      	mov	ip, r4
 801067c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010680:	6028      	str	r0, [r5, #0]
 8010682:	6069      	str	r1, [r5, #4]
 8010684:	60aa      	str	r2, [r5, #8]
 8010686:	60eb      	str	r3, [r5, #12]
 8010688:	4664      	mov	r4, ip
 801068a:	3510      	adds	r5, #16
 801068c:	45f4      	cmp	ip, lr
 801068e:	d1f4      	bne.n	801067a <fRspAnalyze_CmsErr+0xa>
 8010690:	cc03      	ldmia	r4!, {r0, r1}
 8010692:	6028      	str	r0, [r5, #0]
 8010694:	6069      	str	r1, [r5, #4]
 8010696:	8823      	ldrh	r3, [r4, #0]
 8010698:	812b      	strh	r3, [r5, #8]
 801069a:	4c0b      	ldr	r4, [pc, #44]	; (80106c8 <fRspAnalyze_CmsErr+0x58>)
 801069c:	4620      	mov	r0, r4
 801069e:	f00e fd38 	bl	801f112 <crs_strlen>
 80106a2:	b283      	uxth	r3, r0
 80106a4:	4622      	mov	r2, r4
 80106a6:	2104      	movs	r1, #4
 80106a8:	2002      	movs	r0, #2
 80106aa:	f00e fd75 	bl	801f198 <traceIF_itmPrint>
 80106ae:	4620      	mov	r0, r4
 80106b0:	f00e fd2f 	bl	801f112 <crs_strlen>
 80106b4:	b283      	uxth	r3, r0
 80106b6:	4622      	mov	r2, r4
 80106b8:	2104      	movs	r1, #4
 80106ba:	2002      	movs	r0, #2
 80106bc:	f00e fd8e 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +CMS ERROR */
  /* Not implemented */

  return (retval);
}
 80106c0:	2010      	movs	r0, #16
 80106c2:	bd38      	pop	{r3, r4, r5, pc}
 80106c4:	0802f160 	.word	0x0802f160
 80106c8:	200048dc 	.word	0x200048dc

080106cc <fRspAnalyze_CGMI>:

at_action_rsp_t fRspAnalyze_CGMI(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80106cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80106d0:	4606      	mov	r6, r0
 80106d2:	4689      	mov	r9, r1
 80106d4:	4690      	mov	r8, r2
 80106d6:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGMI()")
 80106d8:	4c2c      	ldr	r4, [pc, #176]	; (801078c <fRspAnalyze_CGMI+0xc0>)
 80106da:	4d2d      	ldr	r5, [pc, #180]	; (8010790 <fRspAnalyze_CGMI+0xc4>)
 80106dc:	f104 0e20 	add.w	lr, r4, #32
 80106e0:	46a4      	mov	ip, r4
 80106e2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80106e6:	6028      	str	r0, [r5, #0]
 80106e8:	6069      	str	r1, [r5, #4]
 80106ea:	60aa      	str	r2, [r5, #8]
 80106ec:	60eb      	str	r3, [r5, #12]
 80106ee:	4664      	mov	r4, ip
 80106f0:	3510      	adds	r5, #16
 80106f2:	45f4      	cmp	ip, lr
 80106f4:	d1f4      	bne.n	80106e0 <fRspAnalyze_CGMI+0x14>
 80106f6:	cc03      	ldmia	r4!, {r0, r1}
 80106f8:	6028      	str	r0, [r5, #0]
 80106fa:	6069      	str	r1, [r5, #4]
 80106fc:	4c24      	ldr	r4, [pc, #144]	; (8010790 <fRspAnalyze_CGMI+0xc4>)
 80106fe:	4620      	mov	r0, r4
 8010700:	f00e fd07 	bl	801f112 <crs_strlen>
 8010704:	b283      	uxth	r3, r0
 8010706:	4622      	mov	r2, r4
 8010708:	2104      	movs	r1, #4
 801070a:	2002      	movs	r0, #2
 801070c:	f00e fd44 	bl	801f198 <traceIF_itmPrint>
 8010710:	4620      	mov	r0, r4
 8010712:	f00e fcfe 	bl	801f112 <crs_strlen>
 8010716:	b283      	uxth	r3, r0
 8010718:	4622      	mov	r2, r4
 801071a:	2104      	movs	r1, #4
 801071c:	2002      	movs	r0, #2
 801071e:	f00e fd5d 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +CGMI */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8010722:	8b33      	ldrh	r3, [r6, #24]
 8010724:	2b04      	cmp	r3, #4
 8010726:	d002      	beq.n	801072e <fRspAnalyze_CGMI+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t)element_infos->str_size);
  }

  return (retval);
}
 8010728:	2010      	movs	r0, #16
 801072a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("Manufacturer name:")
 801072e:	4d19      	ldr	r5, [pc, #100]	; (8010794 <fRspAnalyze_CGMI+0xc8>)
 8010730:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010732:	6020      	str	r0, [r4, #0]
 8010734:	6061      	str	r1, [r4, #4]
 8010736:	60a2      	str	r2, [r4, #8]
 8010738:	60e3      	str	r3, [r4, #12]
 801073a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801073c:	6120      	str	r0, [r4, #16]
 801073e:	6161      	str	r1, [r4, #20]
 8010740:	61a2      	str	r2, [r4, #24]
 8010742:	882b      	ldrh	r3, [r5, #0]
 8010744:	83a3      	strh	r3, [r4, #28]
 8010746:	4620      	mov	r0, r4
 8010748:	f00e fce3 	bl	801f112 <crs_strlen>
 801074c:	b283      	uxth	r3, r0
 801074e:	4622      	mov	r2, r4
 8010750:	2102      	movs	r1, #2
 8010752:	4608      	mov	r0, r1
 8010754:	f00e fd20 	bl	801f198 <traceIF_itmPrint>
 8010758:	4620      	mov	r0, r4
 801075a:	f00e fcda 	bl	801f112 <crs_strlen>
 801075e:	b283      	uxth	r3, r0
 8010760:	4622      	mov	r2, r4
 8010762:	2102      	movs	r1, #2
 8010764:	4608      	mov	r0, r1
 8010766:	f00e fd39 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 801076a:	897a      	ldrh	r2, [r7, #10]
 801076c:	89fb      	ldrh	r3, [r7, #14]
 801076e:	4442      	add	r2, r8
 8010770:	2102      	movs	r1, #2
 8010772:	4608      	mov	r0, r1
 8010774:	f00e fffe 	bl	801f774 <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.manufacturer_name),
 8010778:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 801077c:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.manufacturer_name),
 801077e:	89fa      	ldrh	r2, [r7, #14]
 8010780:	4441      	add	r1, r8
 8010782:	3002      	adds	r0, #2
 8010784:	f015 fbc4 	bl	8025f10 <memcpy>
 8010788:	e7ce      	b.n	8010728 <fRspAnalyze_CGMI+0x5c>
 801078a:	bf00      	nop
 801078c:	0802f18c 	.word	0x0802f18c
 8010790:	200048dc 	.word	0x200048dc
 8010794:	0802f1b4 	.word	0x0802f1b4

08010798 <fRspAnalyze_CGMM>:

at_action_rsp_t fRspAnalyze_CGMM(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010798:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801079c:	4606      	mov	r6, r0
 801079e:	4689      	mov	r9, r1
 80107a0:	4690      	mov	r8, r2
 80107a2:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGMM()")
 80107a4:	4c2a      	ldr	r4, [pc, #168]	; (8010850 <fRspAnalyze_CGMM+0xb8>)
 80107a6:	4d2b      	ldr	r5, [pc, #172]	; (8010854 <fRspAnalyze_CGMM+0xbc>)
 80107a8:	f104 0e20 	add.w	lr, r4, #32
 80107ac:	46a4      	mov	ip, r4
 80107ae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80107b2:	6028      	str	r0, [r5, #0]
 80107b4:	6069      	str	r1, [r5, #4]
 80107b6:	60aa      	str	r2, [r5, #8]
 80107b8:	60eb      	str	r3, [r5, #12]
 80107ba:	4664      	mov	r4, ip
 80107bc:	3510      	adds	r5, #16
 80107be:	45f4      	cmp	ip, lr
 80107c0:	d1f4      	bne.n	80107ac <fRspAnalyze_CGMM+0x14>
 80107c2:	cc03      	ldmia	r4!, {r0, r1}
 80107c4:	6028      	str	r0, [r5, #0]
 80107c6:	6069      	str	r1, [r5, #4]
 80107c8:	4c22      	ldr	r4, [pc, #136]	; (8010854 <fRspAnalyze_CGMM+0xbc>)
 80107ca:	4620      	mov	r0, r4
 80107cc:	f00e fca1 	bl	801f112 <crs_strlen>
 80107d0:	b283      	uxth	r3, r0
 80107d2:	4622      	mov	r2, r4
 80107d4:	2104      	movs	r1, #4
 80107d6:	2002      	movs	r0, #2
 80107d8:	f00e fcde 	bl	801f198 <traceIF_itmPrint>
 80107dc:	4620      	mov	r0, r4
 80107de:	f00e fc98 	bl	801f112 <crs_strlen>
 80107e2:	b283      	uxth	r3, r0
 80107e4:	4622      	mov	r2, r4
 80107e6:	2104      	movs	r1, #4
 80107e8:	2002      	movs	r0, #2
 80107ea:	f00e fcf7 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +CGMM */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 80107ee:	8b33      	ldrh	r3, [r6, #24]
 80107f0:	2b04      	cmp	r3, #4
 80107f2:	d002      	beq.n	80107fa <fRspAnalyze_CGMM+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t)element_infos->str_size);
  }

  return (retval);
}
 80107f4:	2010      	movs	r0, #16
 80107f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("Model:")
 80107fa:	4d17      	ldr	r5, [pc, #92]	; (8010858 <fRspAnalyze_CGMM+0xc0>)
 80107fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80107fe:	6020      	str	r0, [r4, #0]
 8010800:	6061      	str	r1, [r4, #4]
 8010802:	60a2      	str	r2, [r4, #8]
 8010804:	60e3      	str	r3, [r4, #12]
 8010806:	882b      	ldrh	r3, [r5, #0]
 8010808:	8223      	strh	r3, [r4, #16]
 801080a:	4620      	mov	r0, r4
 801080c:	f00e fc81 	bl	801f112 <crs_strlen>
 8010810:	b283      	uxth	r3, r0
 8010812:	4622      	mov	r2, r4
 8010814:	2102      	movs	r1, #2
 8010816:	4608      	mov	r0, r1
 8010818:	f00e fcbe 	bl	801f198 <traceIF_itmPrint>
 801081c:	4620      	mov	r0, r4
 801081e:	f00e fc78 	bl	801f112 <crs_strlen>
 8010822:	b283      	uxth	r3, r0
 8010824:	4622      	mov	r2, r4
 8010826:	2102      	movs	r1, #2
 8010828:	4608      	mov	r0, r1
 801082a:	f00e fcd7 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 801082e:	897a      	ldrh	r2, [r7, #10]
 8010830:	89fb      	ldrh	r3, [r7, #14]
 8010832:	4442      	add	r2, r8
 8010834:	2102      	movs	r1, #2
 8010836:	4608      	mov	r0, r1
 8010838:	f00e ff9c 	bl	801f774 <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.model),
 801083c:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010840:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.model),
 8010842:	89fa      	ldrh	r2, [r7, #14]
 8010844:	4441      	add	r1, r8
 8010846:	3002      	adds	r0, #2
 8010848:	f015 fb62 	bl	8025f10 <memcpy>
 801084c:	e7d2      	b.n	80107f4 <fRspAnalyze_CGMM+0x5c>
 801084e:	bf00      	nop
 8010850:	0802f1d4 	.word	0x0802f1d4
 8010854:	200048dc 	.word	0x200048dc
 8010858:	0802f1fc 	.word	0x0802f1fc

0801085c <fRspAnalyze_CGMR>:

at_action_rsp_t fRspAnalyze_CGMR(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 801085c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010860:	4606      	mov	r6, r0
 8010862:	4689      	mov	r9, r1
 8010864:	4690      	mov	r8, r2
 8010866:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGMR()")
 8010868:	4c2b      	ldr	r4, [pc, #172]	; (8010918 <fRspAnalyze_CGMR+0xbc>)
 801086a:	4d2c      	ldr	r5, [pc, #176]	; (801091c <fRspAnalyze_CGMR+0xc0>)
 801086c:	f104 0e20 	add.w	lr, r4, #32
 8010870:	46a4      	mov	ip, r4
 8010872:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010876:	6028      	str	r0, [r5, #0]
 8010878:	6069      	str	r1, [r5, #4]
 801087a:	60aa      	str	r2, [r5, #8]
 801087c:	60eb      	str	r3, [r5, #12]
 801087e:	4664      	mov	r4, ip
 8010880:	3510      	adds	r5, #16
 8010882:	45f4      	cmp	ip, lr
 8010884:	d1f4      	bne.n	8010870 <fRspAnalyze_CGMR+0x14>
 8010886:	cc03      	ldmia	r4!, {r0, r1}
 8010888:	6028      	str	r0, [r5, #0]
 801088a:	6069      	str	r1, [r5, #4]
 801088c:	4c23      	ldr	r4, [pc, #140]	; (801091c <fRspAnalyze_CGMR+0xc0>)
 801088e:	4620      	mov	r0, r4
 8010890:	f00e fc3f 	bl	801f112 <crs_strlen>
 8010894:	b283      	uxth	r3, r0
 8010896:	4622      	mov	r2, r4
 8010898:	2104      	movs	r1, #4
 801089a:	2002      	movs	r0, #2
 801089c:	f00e fc7c 	bl	801f198 <traceIF_itmPrint>
 80108a0:	4620      	mov	r0, r4
 80108a2:	f00e fc36 	bl	801f112 <crs_strlen>
 80108a6:	b283      	uxth	r3, r0
 80108a8:	4622      	mov	r2, r4
 80108aa:	2104      	movs	r1, #4
 80108ac:	2002      	movs	r0, #2
 80108ae:	f00e fc95 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +CGMR */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 80108b2:	8b33      	ldrh	r3, [r6, #24]
 80108b4:	2b04      	cmp	r3, #4
 80108b6:	d002      	beq.n	80108be <fRspAnalyze_CGMR+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t)element_infos->str_size);
  }

  return (retval);
}
 80108b8:	2010      	movs	r0, #16
 80108ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("Revision:")
 80108be:	4d18      	ldr	r5, [pc, #96]	; (8010920 <fRspAnalyze_CGMR+0xc4>)
 80108c0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80108c2:	6020      	str	r0, [r4, #0]
 80108c4:	6061      	str	r1, [r4, #4]
 80108c6:	60a2      	str	r2, [r4, #8]
 80108c8:	60e3      	str	r3, [r4, #12]
 80108ca:	6828      	ldr	r0, [r5, #0]
 80108cc:	6120      	str	r0, [r4, #16]
 80108ce:	792b      	ldrb	r3, [r5, #4]
 80108d0:	7523      	strb	r3, [r4, #20]
 80108d2:	4620      	mov	r0, r4
 80108d4:	f00e fc1d 	bl	801f112 <crs_strlen>
 80108d8:	b283      	uxth	r3, r0
 80108da:	4622      	mov	r2, r4
 80108dc:	2102      	movs	r1, #2
 80108de:	4608      	mov	r0, r1
 80108e0:	f00e fc5a 	bl	801f198 <traceIF_itmPrint>
 80108e4:	4620      	mov	r0, r4
 80108e6:	f00e fc14 	bl	801f112 <crs_strlen>
 80108ea:	b283      	uxth	r3, r0
 80108ec:	4622      	mov	r2, r4
 80108ee:	2102      	movs	r1, #2
 80108f0:	4608      	mov	r0, r1
 80108f2:	f00e fc73 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 80108f6:	897a      	ldrh	r2, [r7, #10]
 80108f8:	89fb      	ldrh	r3, [r7, #14]
 80108fa:	4442      	add	r2, r8
 80108fc:	2102      	movs	r1, #2
 80108fe:	4608      	mov	r0, r1
 8010900:	f00e ff38 	bl	801f774 <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.revision),
 8010904:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010908:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.revision),
 801090a:	89fa      	ldrh	r2, [r7, #14]
 801090c:	4441      	add	r1, r8
 801090e:	3002      	adds	r0, #2
 8010910:	f015 fafe 	bl	8025f10 <memcpy>
 8010914:	e7d0      	b.n	80108b8 <fRspAnalyze_CGMR+0x5c>
 8010916:	bf00      	nop
 8010918:	0802f210 	.word	0x0802f210
 801091c:	200048dc 	.word	0x200048dc
 8010920:	0802f238 	.word	0x0802f238

08010924 <fRspAnalyze_CGSN>:

at_action_rsp_t fRspAnalyze_CGSN(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010924:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010928:	b091      	sub	sp, #68	; 0x44
 801092a:	4606      	mov	r6, r0
 801092c:	4689      	mov	r9, r1
 801092e:	4690      	mov	r8, r2
 8010930:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGSN()")
 8010932:	4c9e      	ldr	r4, [pc, #632]	; (8010bac <fRspAnalyze_CGSN+0x288>)
 8010934:	4d9e      	ldr	r5, [pc, #632]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010936:	f104 0e20 	add.w	lr, r4, #32
 801093a:	46a4      	mov	ip, r4
 801093c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010940:	6028      	str	r0, [r5, #0]
 8010942:	6069      	str	r1, [r5, #4]
 8010944:	60aa      	str	r2, [r5, #8]
 8010946:	60eb      	str	r3, [r5, #12]
 8010948:	4664      	mov	r4, ip
 801094a:	3510      	adds	r5, #16
 801094c:	45f4      	cmp	ip, lr
 801094e:	d1f4      	bne.n	801093a <fRspAnalyze_CGSN+0x16>
 8010950:	cc03      	ldmia	r4!, {r0, r1}
 8010952:	6028      	str	r0, [r5, #0]
 8010954:	6069      	str	r1, [r5, #4]
 8010956:	4c96      	ldr	r4, [pc, #600]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010958:	4620      	mov	r0, r4
 801095a:	f00e fbda 	bl	801f112 <crs_strlen>
 801095e:	b283      	uxth	r3, r0
 8010960:	4622      	mov	r2, r4
 8010962:	2104      	movs	r1, #4
 8010964:	2002      	movs	r0, #2
 8010966:	f00e fc17 	bl	801f198 <traceIF_itmPrint>
 801096a:	4620      	mov	r0, r4
 801096c:	f00e fbd1 	bl	801f112 <crs_strlen>
 8010970:	b283      	uxth	r3, r0
 8010972:	4622      	mov	r2, r4
 8010974:	2104      	movs	r1, #4
 8010976:	2002      	movs	r0, #2
 8010978:	f00e fc30 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +CGSN */
  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 801097c:	8b33      	ldrh	r3, [r6, #24]
 801097e:	2b03      	cmp	r3, #3
 8010980:	d007      	beq.n	8010992 <fRspAnalyze_CGSN+0x6e>
    }
    END_PARAM_LOOP()
  }

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8010982:	8b33      	ldrh	r3, [r6, #24]
 8010984:	2b04      	cmp	r3, #4
 8010986:	f000 80e3 	beq.w	8010b50 <fRspAnalyze_CGSN+0x22c>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t) element_infos->str_size);
  }

  return (retval);
}
 801098a:	2010      	movs	r0, #16
 801098c:	b011      	add	sp, #68	; 0x44
 801098e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8010992:	2400      	movs	r4, #0
 8010994:	463a      	mov	r2, r7
 8010996:	4641      	mov	r1, r8
 8010998:	4630      	mov	r0, r6
 801099a:	f7fb fd55 	bl	800c448 <atcc_extractElement>
 801099e:	2801      	cmp	r0, #1
 80109a0:	d000      	beq.n	80109a4 <fRspAnalyze_CGSN+0x80>
 80109a2:	2401      	movs	r4, #1
 80109a4:	89fb      	ldrh	r3, [r7, #14]
 80109a6:	b113      	cbz	r3, 80109ae <fRspAnalyze_CGSN+0x8a>
    if (element_infos->param_rank == 2U)
 80109a8:	893b      	ldrh	r3, [r7, #8]
 80109aa:	2b02      	cmp	r3, #2
 80109ac:	d002      	beq.n	80109b4 <fRspAnalyze_CGSN+0x90>
    END_PARAM_LOOP()
 80109ae:	2c00      	cmp	r4, #0
 80109b0:	d1e7      	bne.n	8010982 <fRspAnalyze_CGSN+0x5e>
 80109b2:	e7ef      	b.n	8010994 <fRspAnalyze_CGSN+0x70>
      if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SN)
 80109b4:	f899 372c 	ldrb.w	r3, [r9, #1836]	; 0x72c
 80109b8:	b39b      	cbz	r3, 8010a22 <fRspAnalyze_CGSN+0xfe>
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEI)
 80109ba:	2b01      	cmp	r3, #1
 80109bc:	d063      	beq.n	8010a86 <fRspAnalyze_CGSN+0x162>
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEISV)
 80109be:	2b02      	cmp	r3, #2
 80109c0:	f000 809b 	beq.w	8010afa <fRspAnalyze_CGSN+0x1d6>
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SVN)
 80109c4:	2b03      	cmp	r3, #3
 80109c6:	d1f2      	bne.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("SVN (NOT USED):")
 80109c8:	4d79      	ldr	r5, [pc, #484]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 80109ca:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 8010bb8 <fRspAnalyze_CGSN+0x294>
 80109ce:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80109d2:	6028      	str	r0, [r5, #0]
 80109d4:	6069      	str	r1, [r5, #4]
 80109d6:	60aa      	str	r2, [r5, #8]
 80109d8:	60eb      	str	r3, [r5, #12]
 80109da:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 80109de:	6128      	str	r0, [r5, #16]
 80109e0:	6169      	str	r1, [r5, #20]
 80109e2:	f8bc 2000 	ldrh.w	r2, [ip]
 80109e6:	f89c 3002 	ldrb.w	r3, [ip, #2]
 80109ea:	832a      	strh	r2, [r5, #24]
 80109ec:	76ab      	strb	r3, [r5, #26]
 80109ee:	4628      	mov	r0, r5
 80109f0:	f00e fb8f 	bl	801f112 <crs_strlen>
 80109f4:	b283      	uxth	r3, r0
 80109f6:	462a      	mov	r2, r5
 80109f8:	2102      	movs	r1, #2
 80109fa:	4608      	mov	r0, r1
 80109fc:	f00e fbcc 	bl	801f198 <traceIF_itmPrint>
 8010a00:	4628      	mov	r0, r5
 8010a02:	f00e fb86 	bl	801f112 <crs_strlen>
 8010a06:	b283      	uxth	r3, r0
 8010a08:	462a      	mov	r2, r5
 8010a0a:	2102      	movs	r1, #2
 8010a0c:	4608      	mov	r0, r1
 8010a0e:	f00e fbe5 	bl	801f1dc <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010a12:	897a      	ldrh	r2, [r7, #10]
 8010a14:	89fb      	ldrh	r3, [r7, #14]
 8010a16:	4442      	add	r2, r8
 8010a18:	2102      	movs	r1, #2
 8010a1a:	4608      	mov	r0, r1
 8010a1c:	f00e feaa 	bl	801f774 <traceIF_BufCharPrint>
 8010a20:	e7c5      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("Serial Number:")
 8010a22:	4d63      	ldr	r5, [pc, #396]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010a24:	f8df c18c 	ldr.w	ip, [pc, #396]	; 8010bb4 <fRspAnalyze_CGSN+0x290>
 8010a28:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010a2c:	6028      	str	r0, [r5, #0]
 8010a2e:	6069      	str	r1, [r5, #4]
 8010a30:	60aa      	str	r2, [r5, #8]
 8010a32:	60eb      	str	r3, [r5, #12]
 8010a34:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 8010a38:	6128      	str	r0, [r5, #16]
 8010a3a:	6169      	str	r1, [r5, #20]
 8010a3c:	f8bc 3000 	ldrh.w	r3, [ip]
 8010a40:	832b      	strh	r3, [r5, #24]
 8010a42:	4628      	mov	r0, r5
 8010a44:	f00e fb65 	bl	801f112 <crs_strlen>
 8010a48:	b283      	uxth	r3, r0
 8010a4a:	462a      	mov	r2, r5
 8010a4c:	2102      	movs	r1, #2
 8010a4e:	4608      	mov	r0, r1
 8010a50:	f00e fba2 	bl	801f198 <traceIF_itmPrint>
 8010a54:	4628      	mov	r0, r5
 8010a56:	f00e fb5c 	bl	801f112 <crs_strlen>
 8010a5a:	b283      	uxth	r3, r0
 8010a5c:	462a      	mov	r2, r5
 8010a5e:	2102      	movs	r1, #2
 8010a60:	4608      	mov	r0, r1
 8010a62:	f00e fbbb 	bl	801f1dc <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010a66:	897a      	ldrh	r2, [r7, #10]
 8010a68:	89fb      	ldrh	r3, [r7, #14]
 8010a6a:	4442      	add	r2, r8
 8010a6c:	2102      	movs	r1, #2
 8010a6e:	4608      	mov	r0, r1
 8010a70:	f00e fe80 	bl	801f774 <traceIF_BufCharPrint>
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010a74:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                      (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010a78:	8979      	ldrh	r1, [r7, #10]
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010a7a:	89fa      	ldrh	r2, [r7, #14]
 8010a7c:	4441      	add	r1, r8
 8010a7e:	3002      	adds	r0, #2
 8010a80:	f015 fa46 	bl	8025f10 <memcpy>
 8010a84:	e793      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("IMEI:")
 8010a86:	4d4a      	ldr	r5, [pc, #296]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010a88:	f8df c130 	ldr.w	ip, [pc, #304]	; 8010bbc <fRspAnalyze_CGSN+0x298>
 8010a8c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010a90:	6028      	str	r0, [r5, #0]
 8010a92:	6069      	str	r1, [r5, #4]
 8010a94:	60aa      	str	r2, [r5, #8]
 8010a96:	60eb      	str	r3, [r5, #12]
 8010a98:	f89c 3000 	ldrb.w	r3, [ip]
 8010a9c:	742b      	strb	r3, [r5, #16]
 8010a9e:	4628      	mov	r0, r5
 8010aa0:	f00e fb37 	bl	801f112 <crs_strlen>
 8010aa4:	b283      	uxth	r3, r0
 8010aa6:	462a      	mov	r2, r5
 8010aa8:	2102      	movs	r1, #2
 8010aaa:	4608      	mov	r0, r1
 8010aac:	f00e fb74 	bl	801f198 <traceIF_itmPrint>
 8010ab0:	4628      	mov	r0, r5
 8010ab2:	f00e fb2e 	bl	801f112 <crs_strlen>
 8010ab6:	b283      	uxth	r3, r0
 8010ab8:	462a      	mov	r2, r5
 8010aba:	2102      	movs	r1, #2
 8010abc:	4608      	mov	r0, r1
 8010abe:	f00e fb8d 	bl	801f1dc <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010ac2:	897a      	ldrh	r2, [r7, #10]
 8010ac4:	89fb      	ldrh	r3, [r7, #14]
 8010ac6:	4442      	add	r2, r8
 8010ac8:	2102      	movs	r1, #2
 8010aca:	4608      	mov	r0, r1
 8010acc:	f00e fe52 	bl	801f774 <traceIF_BufCharPrint>
        uint8_t tmp_array[MAX_SIZE_IMEI] = {0};
 8010ad0:	2100      	movs	r1, #0
 8010ad2:	9100      	str	r1, [sp, #0]
 8010ad4:	223c      	movs	r2, #60	; 0x3c
 8010ad6:	a801      	add	r0, sp, #4
 8010ad8:	f015 f93d 	bl	8025d56 <memset>
        uint16_t real_size = ATutil_remove_quotes((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010adc:	8978      	ldrh	r0, [r7, #10]
 8010ade:	89f9      	ldrh	r1, [r7, #14]
 8010ae0:	460b      	mov	r3, r1
 8010ae2:	466a      	mov	r2, sp
 8010ae4:	4440      	add	r0, r8
 8010ae6:	f004 f9ec 	bl	8014ec2 <ATutil_remove_quotes>
 8010aea:	4602      	mov	r2, r0
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei),
 8010aec:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
 8010af0:	4669      	mov	r1, sp
 8010af2:	3002      	adds	r0, #2
 8010af4:	f015 fa0c 	bl	8025f10 <memcpy>
 8010af8:	e759      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("IMEISV (NOT USED):")
 8010afa:	4d2d      	ldr	r5, [pc, #180]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010afc:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 8010bc0 <fRspAnalyze_CGSN+0x29c>
 8010b00:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010b04:	6028      	str	r0, [r5, #0]
 8010b06:	6069      	str	r1, [r5, #4]
 8010b08:	60aa      	str	r2, [r5, #8]
 8010b0a:	60eb      	str	r3, [r5, #12]
 8010b0c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010b10:	6128      	str	r0, [r5, #16]
 8010b12:	6169      	str	r1, [r5, #20]
 8010b14:	61aa      	str	r2, [r5, #24]
 8010b16:	f8bc 3000 	ldrh.w	r3, [ip]
 8010b1a:	83ab      	strh	r3, [r5, #28]
 8010b1c:	4628      	mov	r0, r5
 8010b1e:	f00e faf8 	bl	801f112 <crs_strlen>
 8010b22:	b283      	uxth	r3, r0
 8010b24:	462a      	mov	r2, r5
 8010b26:	2102      	movs	r1, #2
 8010b28:	4608      	mov	r0, r1
 8010b2a:	f00e fb35 	bl	801f198 <traceIF_itmPrint>
 8010b2e:	4628      	mov	r0, r5
 8010b30:	f00e faef 	bl	801f112 <crs_strlen>
 8010b34:	b283      	uxth	r3, r0
 8010b36:	462a      	mov	r2, r5
 8010b38:	2102      	movs	r1, #2
 8010b3a:	4608      	mov	r0, r1
 8010b3c:	f00e fb4e 	bl	801f1dc <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010b40:	897a      	ldrh	r2, [r7, #10]
 8010b42:	89fb      	ldrh	r3, [r7, #14]
 8010b44:	4442      	add	r2, r8
 8010b46:	2102      	movs	r1, #2
 8010b48:	4608      	mov	r0, r1
 8010b4a:	f00e fe13 	bl	801f774 <traceIF_BufCharPrint>
 8010b4e:	e72e      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
    PRINT_DBG("Serial Number:")
 8010b50:	4c17      	ldr	r4, [pc, #92]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010b52:	4d18      	ldr	r5, [pc, #96]	; (8010bb4 <fRspAnalyze_CGSN+0x290>)
 8010b54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010b56:	6020      	str	r0, [r4, #0]
 8010b58:	6061      	str	r1, [r4, #4]
 8010b5a:	60a2      	str	r2, [r4, #8]
 8010b5c:	60e3      	str	r3, [r4, #12]
 8010b5e:	cd03      	ldmia	r5!, {r0, r1}
 8010b60:	6120      	str	r0, [r4, #16]
 8010b62:	6161      	str	r1, [r4, #20]
 8010b64:	882b      	ldrh	r3, [r5, #0]
 8010b66:	8323      	strh	r3, [r4, #24]
 8010b68:	4620      	mov	r0, r4
 8010b6a:	f00e fad2 	bl	801f112 <crs_strlen>
 8010b6e:	b283      	uxth	r3, r0
 8010b70:	4622      	mov	r2, r4
 8010b72:	2102      	movs	r1, #2
 8010b74:	4608      	mov	r0, r1
 8010b76:	f00e fb0f 	bl	801f198 <traceIF_itmPrint>
 8010b7a:	4620      	mov	r0, r4
 8010b7c:	f00e fac9 	bl	801f112 <crs_strlen>
 8010b80:	b283      	uxth	r3, r0
 8010b82:	4622      	mov	r2, r4
 8010b84:	2102      	movs	r1, #2
 8010b86:	4608      	mov	r0, r1
 8010b88:	f00e fb28 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010b8c:	897a      	ldrh	r2, [r7, #10]
 8010b8e:	89fb      	ldrh	r3, [r7, #14]
 8010b90:	4442      	add	r2, r8
 8010b92:	2102      	movs	r1, #2
 8010b94:	4608      	mov	r0, r1
 8010b96:	f00e fded 	bl	801f774 <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010b9a:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010b9e:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010ba0:	89fa      	ldrh	r2, [r7, #14]
 8010ba2:	4441      	add	r1, r8
 8010ba4:	3002      	adds	r0, #2
 8010ba6:	f015 f9b3 	bl	8025f10 <memcpy>
 8010baa:	e6ee      	b.n	801098a <fRspAnalyze_CGSN+0x66>
 8010bac:	0802f250 	.word	0x0802f250
 8010bb0:	200048dc 	.word	0x200048dc
 8010bb4:	0802f278 	.word	0x0802f278
 8010bb8:	0802f2c8 	.word	0x0802f2c8
 8010bbc:	0802f294 	.word	0x0802f294
 8010bc0:	0802f2a8 	.word	0x0802f2a8

08010bc4 <fRspAnalyze_CIMI>:

at_action_rsp_t fRspAnalyze_CIMI(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010bc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010bc8:	4606      	mov	r6, r0
 8010bca:	4689      	mov	r9, r1
 8010bcc:	4690      	mov	r8, r2
 8010bce:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CIMI()")
 8010bd0:	4c2a      	ldr	r4, [pc, #168]	; (8010c7c <fRspAnalyze_CIMI+0xb8>)
 8010bd2:	4d2b      	ldr	r5, [pc, #172]	; (8010c80 <fRspAnalyze_CIMI+0xbc>)
 8010bd4:	f104 0e20 	add.w	lr, r4, #32
 8010bd8:	46a4      	mov	ip, r4
 8010bda:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010bde:	6028      	str	r0, [r5, #0]
 8010be0:	6069      	str	r1, [r5, #4]
 8010be2:	60aa      	str	r2, [r5, #8]
 8010be4:	60eb      	str	r3, [r5, #12]
 8010be6:	4664      	mov	r4, ip
 8010be8:	3510      	adds	r5, #16
 8010bea:	45f4      	cmp	ip, lr
 8010bec:	d1f4      	bne.n	8010bd8 <fRspAnalyze_CIMI+0x14>
 8010bee:	cc03      	ldmia	r4!, {r0, r1}
 8010bf0:	6028      	str	r0, [r5, #0]
 8010bf2:	6069      	str	r1, [r5, #4]
 8010bf4:	4c22      	ldr	r4, [pc, #136]	; (8010c80 <fRspAnalyze_CIMI+0xbc>)
 8010bf6:	4620      	mov	r0, r4
 8010bf8:	f00e fa8b 	bl	801f112 <crs_strlen>
 8010bfc:	b283      	uxth	r3, r0
 8010bfe:	4622      	mov	r2, r4
 8010c00:	2104      	movs	r1, #4
 8010c02:	2002      	movs	r0, #2
 8010c04:	f00e fac8 	bl	801f198 <traceIF_itmPrint>
 8010c08:	4620      	mov	r0, r4
 8010c0a:	f00e fa82 	bl	801f112 <crs_strlen>
 8010c0e:	b283      	uxth	r3, r0
 8010c10:	4622      	mov	r2, r4
 8010c12:	2104      	movs	r1, #4
 8010c14:	2002      	movs	r0, #2
 8010c16:	f00e fae1 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +CIMI */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8010c1a:	8b33      	ldrh	r3, [r6, #24]
 8010c1c:	2b04      	cmp	r3, #4
 8010c1e:	d002      	beq.n	8010c26 <fRspAnalyze_CIMI+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t) element_infos->str_size);
  }

  return (retval);
}
 8010c20:	2010      	movs	r0, #16
 8010c22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("IMSI:")
 8010c26:	4d17      	ldr	r5, [pc, #92]	; (8010c84 <fRspAnalyze_CIMI+0xc0>)
 8010c28:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010c2a:	6020      	str	r0, [r4, #0]
 8010c2c:	6061      	str	r1, [r4, #4]
 8010c2e:	60a2      	str	r2, [r4, #8]
 8010c30:	60e3      	str	r3, [r4, #12]
 8010c32:	782b      	ldrb	r3, [r5, #0]
 8010c34:	7423      	strb	r3, [r4, #16]
 8010c36:	4620      	mov	r0, r4
 8010c38:	f00e fa6b 	bl	801f112 <crs_strlen>
 8010c3c:	b283      	uxth	r3, r0
 8010c3e:	4622      	mov	r2, r4
 8010c40:	2102      	movs	r1, #2
 8010c42:	4608      	mov	r0, r1
 8010c44:	f00e faa8 	bl	801f198 <traceIF_itmPrint>
 8010c48:	4620      	mov	r0, r4
 8010c4a:	f00e fa62 	bl	801f112 <crs_strlen>
 8010c4e:	b283      	uxth	r3, r0
 8010c50:	4622      	mov	r2, r4
 8010c52:	2102      	movs	r1, #2
 8010c54:	4608      	mov	r0, r1
 8010c56:	f00e fac1 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010c5a:	897a      	ldrh	r2, [r7, #10]
 8010c5c:	89fb      	ldrh	r3, [r7, #14]
 8010c5e:	4442      	add	r2, r8
 8010c60:	2102      	movs	r1, #2
 8010c62:	4608      	mov	r0, r1
 8010c64:	f00e fd86 	bl	801f774 <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imsi),
 8010c68:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010c6c:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imsi),
 8010c6e:	89fa      	ldrh	r2, [r7, #14]
 8010c70:	4441      	add	r1, r8
 8010c72:	3002      	adds	r0, #2
 8010c74:	f015 f94c 	bl	8025f10 <memcpy>
 8010c78:	e7d2      	b.n	8010c20 <fRspAnalyze_CIMI+0x5c>
 8010c7a:	bf00      	nop
 8010c7c:	0802f2e4 	.word	0x0802f2e4
 8010c80:	200048dc 	.word	0x200048dc
 8010c84:	0802f30c 	.word	0x0802f30c

08010c88 <fRspAnalyze_CEER>:

at_action_rsp_t fRspAnalyze_CEER(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010c88:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEER()")
 8010c8a:	4c13      	ldr	r4, [pc, #76]	; (8010cd8 <fRspAnalyze_CEER+0x50>)
 8010c8c:	4d13      	ldr	r5, [pc, #76]	; (8010cdc <fRspAnalyze_CEER+0x54>)
 8010c8e:	f104 0e20 	add.w	lr, r4, #32
 8010c92:	46a4      	mov	ip, r4
 8010c94:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010c98:	6028      	str	r0, [r5, #0]
 8010c9a:	6069      	str	r1, [r5, #4]
 8010c9c:	60aa      	str	r2, [r5, #8]
 8010c9e:	60eb      	str	r3, [r5, #12]
 8010ca0:	4664      	mov	r4, ip
 8010ca2:	3510      	adds	r5, #16
 8010ca4:	45f4      	cmp	ip, lr
 8010ca6:	d1f4      	bne.n	8010c92 <fRspAnalyze_CEER+0xa>
 8010ca8:	cc03      	ldmia	r4!, {r0, r1}
 8010caa:	6028      	str	r0, [r5, #0]
 8010cac:	6069      	str	r1, [r5, #4]
 8010cae:	4c0b      	ldr	r4, [pc, #44]	; (8010cdc <fRspAnalyze_CEER+0x54>)
 8010cb0:	4620      	mov	r0, r4
 8010cb2:	f00e fa2e 	bl	801f112 <crs_strlen>
 8010cb6:	b283      	uxth	r3, r0
 8010cb8:	4622      	mov	r2, r4
 8010cba:	2104      	movs	r1, #4
 8010cbc:	2002      	movs	r0, #2
 8010cbe:	f00e fa6b 	bl	801f198 <traceIF_itmPrint>
 8010cc2:	4620      	mov	r0, r4
 8010cc4:	f00e fa25 	bl	801f112 <crs_strlen>
 8010cc8:	b283      	uxth	r3, r0
 8010cca:	4622      	mov	r2, r4
 8010ccc:	2104      	movs	r1, #4
 8010cce:	2002      	movs	r0, #2
 8010cd0:	f00e fa84 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for CEER */

  return (retval);
}
 8010cd4:	2010      	movs	r0, #16
 8010cd6:	bd38      	pop	{r3, r4, r5, pc}
 8010cd8:	0802f320 	.word	0x0802f320
 8010cdc:	200048dc 	.word	0x200048dc

08010ce0 <fRspAnalyze_CPIN>:

at_action_rsp_t fRspAnalyze_CPIN(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010ce0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010ce4:	b088      	sub	sp, #32
 8010ce6:	4680      	mov	r8, r0
 8010ce8:	4689      	mov	r9, r1
 8010cea:	4617      	mov	r7, r2
 8010cec:	461e      	mov	r6, r3
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CPIN()")
 8010cee:	4cbe      	ldr	r4, [pc, #760]	; (8010fe8 <fRspAnalyze_CPIN+0x308>)
 8010cf0:	4dbe      	ldr	r5, [pc, #760]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010cf2:	f104 0e20 	add.w	lr, r4, #32
 8010cf6:	46a4      	mov	ip, r4
 8010cf8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010cfc:	6028      	str	r0, [r5, #0]
 8010cfe:	6069      	str	r1, [r5, #4]
 8010d00:	60aa      	str	r2, [r5, #8]
 8010d02:	60eb      	str	r3, [r5, #12]
 8010d04:	4664      	mov	r4, ip
 8010d06:	3510      	adds	r5, #16
 8010d08:	45f4      	cmp	ip, lr
 8010d0a:	d1f4      	bne.n	8010cf6 <fRspAnalyze_CPIN+0x16>
 8010d0c:	cc03      	ldmia	r4!, {r0, r1}
 8010d0e:	6028      	str	r0, [r5, #0]
 8010d10:	6069      	str	r1, [r5, #4]
 8010d12:	4cb6      	ldr	r4, [pc, #728]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010d14:	4620      	mov	r0, r4
 8010d16:	f00e f9fc 	bl	801f112 <crs_strlen>
 8010d1a:	b283      	uxth	r3, r0
 8010d1c:	4622      	mov	r2, r4
 8010d1e:	2104      	movs	r1, #4
 8010d20:	2002      	movs	r0, #2
 8010d22:	f00e fa39 	bl	801f198 <traceIF_itmPrint>
 8010d26:	4620      	mov	r0, r4
 8010d28:	f00e f9f3 	bl	801f112 <crs_strlen>
 8010d2c:	b283      	uxth	r3, r0
 8010d2e:	4622      	mov	r2, r4
 8010d30:	2104      	movs	r1, #4
 8010d32:	2002      	movs	r0, #2
 8010d34:	f00e fa52 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for CPIN */
  START_PARAM_LOOP()
 8010d38:	2400      	movs	r4, #0
 8010d3a:	4632      	mov	r2, r6
 8010d3c:	4639      	mov	r1, r7
 8010d3e:	4640      	mov	r0, r8
 8010d40:	f7fb fb82 	bl	800c448 <atcc_extractElement>
 8010d44:	2801      	cmp	r0, #1
 8010d46:	d000      	beq.n	8010d4a <fRspAnalyze_CPIN+0x6a>
 8010d48:	2401      	movs	r4, #1
 8010d4a:	89f3      	ldrh	r3, [r6, #14]
 8010d4c:	b113      	cbz	r3, 8010d54 <fRspAnalyze_CPIN+0x74>
  if (element_infos->param_rank == 2U)
 8010d4e:	8933      	ldrh	r3, [r6, #8]
 8010d50:	2b02      	cmp	r3, #2
 8010d52:	d005      	beq.n	8010d60 <fRspAnalyze_CPIN+0x80>
      PRINT_ERR("line exceed maximum size, line ignored...")
      retval = ATACTION_RSP_IGNORED;
    }

  }
  END_PARAM_LOOP()
 8010d54:	2c00      	cmp	r4, #0
 8010d56:	d0f0      	beq.n	8010d3a <fRspAnalyze_CPIN+0x5a>
  return (retval);
}
 8010d58:	2010      	movs	r0, #16
 8010d5a:	b008      	add	sp, #32
 8010d5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    AT_CHAR_t line[32] = {0U};
 8010d60:	2300      	movs	r3, #0
 8010d62:	9300      	str	r3, [sp, #0]
 8010d64:	9301      	str	r3, [sp, #4]
 8010d66:	9302      	str	r3, [sp, #8]
 8010d68:	9303      	str	r3, [sp, #12]
 8010d6a:	9304      	str	r3, [sp, #16]
 8010d6c:	9305      	str	r3, [sp, #20]
 8010d6e:	9306      	str	r3, [sp, #24]
 8010d70:	9307      	str	r3, [sp, #28]
    PRINT_DBG("CPIN parameter received:")
 8010d72:	f8df e290 	ldr.w	lr, [pc, #656]	; 8011004 <fRspAnalyze_CPIN+0x324>
 8010d76:	f8df c274 	ldr.w	ip, [pc, #628]	; 8010fec <fRspAnalyze_CPIN+0x30c>
 8010d7a:	f10e 0a20 	add.w	sl, lr, #32
 8010d7e:	4675      	mov	r5, lr
 8010d80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010d82:	f8cc 0000 	str.w	r0, [ip]
 8010d86:	f8cc 1004 	str.w	r1, [ip, #4]
 8010d8a:	f8cc 2008 	str.w	r2, [ip, #8]
 8010d8e:	f8cc 300c 	str.w	r3, [ip, #12]
 8010d92:	46ae      	mov	lr, r5
 8010d94:	f10c 0c10 	add.w	ip, ip, #16
 8010d98:	4555      	cmp	r5, sl
 8010d9a:	d1f0      	bne.n	8010d7e <fRspAnalyze_CPIN+0x9e>
 8010d9c:	6828      	ldr	r0, [r5, #0]
 8010d9e:	f8cc 0000 	str.w	r0, [ip]
 8010da2:	4d92      	ldr	r5, [pc, #584]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010da4:	4628      	mov	r0, r5
 8010da6:	f00e f9b4 	bl	801f112 <crs_strlen>
 8010daa:	b283      	uxth	r3, r0
 8010dac:	462a      	mov	r2, r5
 8010dae:	2102      	movs	r1, #2
 8010db0:	4608      	mov	r0, r1
 8010db2:	f00e f9f1 	bl	801f198 <traceIF_itmPrint>
 8010db6:	4628      	mov	r0, r5
 8010db8:	f00e f9ab 	bl	801f112 <crs_strlen>
 8010dbc:	b283      	uxth	r3, r0
 8010dbe:	462a      	mov	r2, r5
 8010dc0:	2102      	movs	r1, #2
 8010dc2:	4608      	mov	r0, r1
 8010dc4:	f00e fa0a 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010dc8:	8972      	ldrh	r2, [r6, #10]
 8010dca:	89f3      	ldrh	r3, [r6, #14]
 8010dcc:	443a      	add	r2, r7
 8010dce:	2102      	movs	r1, #2
 8010dd0:	4608      	mov	r0, r1
 8010dd2:	f00e fccf 	bl	801f774 <traceIF_BufCharPrint>
    if (element_infos->str_size <= 32U)
 8010dd6:	89f2      	ldrh	r2, [r6, #14]
 8010dd8:	2a20      	cmp	r2, #32
 8010dda:	f200 8153 	bhi.w	8011084 <fRspAnalyze_CPIN+0x3a4>
                    (const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 8010dde:	8971      	ldrh	r1, [r6, #10]
      (void) memcpy((void *)&line[0],
 8010de0:	4439      	add	r1, r7
 8010de2:	4668      	mov	r0, sp
 8010de4:	f015 f894 	bl	8025f10 <memcpy>
      if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN") != NULL)
 8010de8:	4981      	ldr	r1, [pc, #516]	; (8010ff0 <fRspAnalyze_CPIN+0x310>)
 8010dea:	4668      	mov	r0, sp
 8010dec:	f014 fffe 	bl	8025dec <strstr>
 8010df0:	b378      	cbz	r0, 8010e52 <fRspAnalyze_CPIN+0x172>
        PRINT_DBG("waiting for SIM PIN")
 8010df2:	f8df c214 	ldr.w	ip, [pc, #532]	; 8011008 <fRspAnalyze_CPIN+0x328>
 8010df6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010dfa:	6028      	str	r0, [r5, #0]
 8010dfc:	6069      	str	r1, [r5, #4]
 8010dfe:	60aa      	str	r2, [r5, #8]
 8010e00:	60eb      	str	r3, [r5, #12]
 8010e02:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010e06:	6128      	str	r0, [r5, #16]
 8010e08:	6169      	str	r1, [r5, #20]
 8010e0a:	61aa      	str	r2, [r5, #24]
 8010e0c:	f8bc 2000 	ldrh.w	r2, [ip]
 8010e10:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8010e14:	83aa      	strh	r2, [r5, #28]
 8010e16:	77ab      	strb	r3, [r5, #30]
 8010e18:	4628      	mov	r0, r5
 8010e1a:	f00e f97a 	bl	801f112 <crs_strlen>
 8010e1e:	b283      	uxth	r3, r0
 8010e20:	462a      	mov	r2, r5
 8010e22:	2102      	movs	r1, #2
 8010e24:	4608      	mov	r0, r1
 8010e26:	f00e f9b7 	bl	801f198 <traceIF_itmPrint>
 8010e2a:	4628      	mov	r0, r5
 8010e2c:	f00e f971 	bl	801f112 <crs_strlen>
 8010e30:	b283      	uxth	r3, r0
 8010e32:	462a      	mov	r2, r5
 8010e34:	2102      	movs	r1, #2
 8010e36:	4608      	mov	r0, r1
 8010e38:	f00e f9d0 	bl	801f1dc <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010e3c:	2300      	movs	r3, #0
 8010e3e:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN_REQUIRED;
 8010e42:	2306      	movs	r3, #6
 8010e44:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010e48:	4649      	mov	r1, r9
 8010e4a:	2001      	movs	r0, #1
 8010e4c:	f7fd fb94 	bl	800e578 <set_error_report>
 8010e50:	e780      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK") != NULL)
 8010e52:	4968      	ldr	r1, [pc, #416]	; (8010ff4 <fRspAnalyze_CPIN+0x314>)
 8010e54:	4668      	mov	r0, sp
 8010e56:	f014 ffc9 	bl	8025dec <strstr>
 8010e5a:	b380      	cbz	r0, 8010ebe <fRspAnalyze_CPIN+0x1de>
        PRINT_DBG("waiting for SIM PUK")
 8010e5c:	4d63      	ldr	r5, [pc, #396]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010e5e:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 801100c <fRspAnalyze_CPIN+0x32c>
 8010e62:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010e66:	6028      	str	r0, [r5, #0]
 8010e68:	6069      	str	r1, [r5, #4]
 8010e6a:	60aa      	str	r2, [r5, #8]
 8010e6c:	60eb      	str	r3, [r5, #12]
 8010e6e:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010e72:	6128      	str	r0, [r5, #16]
 8010e74:	6169      	str	r1, [r5, #20]
 8010e76:	61aa      	str	r2, [r5, #24]
 8010e78:	f8bc 2000 	ldrh.w	r2, [ip]
 8010e7c:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8010e80:	83aa      	strh	r2, [r5, #28]
 8010e82:	77ab      	strb	r3, [r5, #30]
 8010e84:	4628      	mov	r0, r5
 8010e86:	f00e f944 	bl	801f112 <crs_strlen>
 8010e8a:	b283      	uxth	r3, r0
 8010e8c:	462a      	mov	r2, r5
 8010e8e:	2102      	movs	r1, #2
 8010e90:	4608      	mov	r0, r1
 8010e92:	f00e f981 	bl	801f198 <traceIF_itmPrint>
 8010e96:	4628      	mov	r0, r5
 8010e98:	f00e f93b 	bl	801f112 <crs_strlen>
 8010e9c:	b283      	uxth	r3, r0
 8010e9e:	462a      	mov	r2, r5
 8010ea0:	2102      	movs	r1, #2
 8010ea2:	4608      	mov	r0, r1
 8010ea4:	f00e f99a 	bl	801f1dc <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010ea8:	2300      	movs	r3, #0
 8010eaa:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK_REQUIRED;
 8010eae:	2308      	movs	r3, #8
 8010eb0:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010eb4:	4649      	mov	r1, r9
 8010eb6:	2001      	movs	r0, #1
 8010eb8:	f7fd fb5e 	bl	800e578 <set_error_report>
 8010ebc:	e74a      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN2") != NULL)
 8010ebe:	494e      	ldr	r1, [pc, #312]	; (8010ff8 <fRspAnalyze_CPIN+0x318>)
 8010ec0:	4668      	mov	r0, sp
 8010ec2:	f014 ff93 	bl	8025dec <strstr>
 8010ec6:	b358      	cbz	r0, 8010f20 <fRspAnalyze_CPIN+0x240>
        PRINT_DBG("waiting for SIM PUK2")
 8010ec8:	4d48      	ldr	r5, [pc, #288]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010eca:	f8df c144 	ldr.w	ip, [pc, #324]	; 8011010 <fRspAnalyze_CPIN+0x330>
 8010ece:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010ed2:	6028      	str	r0, [r5, #0]
 8010ed4:	6069      	str	r1, [r5, #4]
 8010ed6:	60aa      	str	r2, [r5, #8]
 8010ed8:	60eb      	str	r3, [r5, #12]
 8010eda:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010ede:	6128      	str	r0, [r5, #16]
 8010ee0:	6169      	str	r1, [r5, #20]
 8010ee2:	61aa      	str	r2, [r5, #24]
 8010ee4:	61eb      	str	r3, [r5, #28]
 8010ee6:	4628      	mov	r0, r5
 8010ee8:	f00e f913 	bl	801f112 <crs_strlen>
 8010eec:	b283      	uxth	r3, r0
 8010eee:	462a      	mov	r2, r5
 8010ef0:	2102      	movs	r1, #2
 8010ef2:	4608      	mov	r0, r1
 8010ef4:	f00e f950 	bl	801f198 <traceIF_itmPrint>
 8010ef8:	4628      	mov	r0, r5
 8010efa:	f00e f90a 	bl	801f112 <crs_strlen>
 8010efe:	b283      	uxth	r3, r0
 8010f00:	462a      	mov	r2, r5
 8010f02:	2102      	movs	r1, #2
 8010f04:	4608      	mov	r0, r1
 8010f06:	f00e f969 	bl	801f1dc <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010f0a:	2300      	movs	r3, #0
 8010f0c:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK2_REQUIRED;
 8010f10:	2309      	movs	r3, #9
 8010f12:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010f16:	4649      	mov	r1, r9
 8010f18:	2001      	movs	r0, #1
 8010f1a:	f7fd fb2d 	bl	800e578 <set_error_report>
 8010f1e:	e719      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK2") != NULL)
 8010f20:	4936      	ldr	r1, [pc, #216]	; (8010ffc <fRspAnalyze_CPIN+0x31c>)
 8010f22:	4668      	mov	r0, sp
 8010f24:	f014 ff62 	bl	8025dec <strstr>
 8010f28:	b380      	cbz	r0, 8010f8c <fRspAnalyze_CPIN+0x2ac>
        PRINT_DBG("waiting for SIM PUK")
 8010f2a:	4d30      	ldr	r5, [pc, #192]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010f2c:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 801100c <fRspAnalyze_CPIN+0x32c>
 8010f30:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010f34:	6028      	str	r0, [r5, #0]
 8010f36:	6069      	str	r1, [r5, #4]
 8010f38:	60aa      	str	r2, [r5, #8]
 8010f3a:	60eb      	str	r3, [r5, #12]
 8010f3c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010f40:	6128      	str	r0, [r5, #16]
 8010f42:	6169      	str	r1, [r5, #20]
 8010f44:	61aa      	str	r2, [r5, #24]
 8010f46:	f8bc 2000 	ldrh.w	r2, [ip]
 8010f4a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8010f4e:	83aa      	strh	r2, [r5, #28]
 8010f50:	77ab      	strb	r3, [r5, #30]
 8010f52:	4628      	mov	r0, r5
 8010f54:	f00e f8dd 	bl	801f112 <crs_strlen>
 8010f58:	b283      	uxth	r3, r0
 8010f5a:	462a      	mov	r2, r5
 8010f5c:	2102      	movs	r1, #2
 8010f5e:	4608      	mov	r0, r1
 8010f60:	f00e f91a 	bl	801f198 <traceIF_itmPrint>
 8010f64:	4628      	mov	r0, r5
 8010f66:	f00e f8d4 	bl	801f112 <crs_strlen>
 8010f6a:	b283      	uxth	r3, r0
 8010f6c:	462a      	mov	r2, r5
 8010f6e:	2102      	movs	r1, #2
 8010f70:	4608      	mov	r0, r1
 8010f72:	f00e f933 	bl	801f1dc <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010f76:	2300      	movs	r3, #0
 8010f78:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK_REQUIRED;
 8010f7c:	2308      	movs	r3, #8
 8010f7e:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010f82:	4649      	mov	r1, r9
 8010f84:	2001      	movs	r0, #1
 8010f86:	f7fd faf7 	bl	800e578 <set_error_report>
 8010f8a:	e6e3      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "READY") != NULL)
 8010f8c:	491c      	ldr	r1, [pc, #112]	; (8011000 <fRspAnalyze_CPIN+0x320>)
 8010f8e:	4668      	mov	r0, sp
 8010f90:	f014 ff2c 	bl	8025dec <strstr>
 8010f94:	2800      	cmp	r0, #0
 8010f96:	d03f      	beq.n	8011018 <fRspAnalyze_CPIN+0x338>
        PRINT_DBG("CPIN READY")
 8010f98:	4d14      	ldr	r5, [pc, #80]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010f9a:	f8df c078 	ldr.w	ip, [pc, #120]	; 8011014 <fRspAnalyze_CPIN+0x334>
 8010f9e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010fa2:	6028      	str	r0, [r5, #0]
 8010fa4:	6069      	str	r1, [r5, #4]
 8010fa6:	60aa      	str	r2, [r5, #8]
 8010fa8:	60eb      	str	r3, [r5, #12]
 8010faa:	f8dc 0000 	ldr.w	r0, [ip]
 8010fae:	6128      	str	r0, [r5, #16]
 8010fb0:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8010fb4:	82ab      	strh	r3, [r5, #20]
 8010fb6:	4628      	mov	r0, r5
 8010fb8:	f00e f8ab 	bl	801f112 <crs_strlen>
 8010fbc:	b283      	uxth	r3, r0
 8010fbe:	462a      	mov	r2, r5
 8010fc0:	2102      	movs	r1, #2
 8010fc2:	4608      	mov	r0, r1
 8010fc4:	f00e f8e8 	bl	801f198 <traceIF_itmPrint>
 8010fc8:	4628      	mov	r0, r5
 8010fca:	f00e f8a2 	bl	801f112 <crs_strlen>
 8010fce:	b283      	uxth	r3, r0
 8010fd0:	462a      	mov	r2, r5
 8010fd2:	2102      	movs	r1, #2
 8010fd4:	4608      	mov	r0, r1
 8010fd6:	f00e f901 	bl	801f1dc <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_TRUE;
 8010fda:	2301      	movs	r3, #1
 8010fdc:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_READY;
 8010fe0:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
 8010fe4:	e6b6      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
 8010fe6:	bf00      	nop
 8010fe8:	0802f348 	.word	0x0802f348
 8010fec:	200048dc 	.word	0x200048dc
 8010ff0:	0802f394 	.word	0x0802f394
 8010ff4:	0802f3bc 	.word	0x0802f3bc
 8010ff8:	0802f3e4 	.word	0x0802f3e4
 8010ffc:	0802f410 	.word	0x0802f410
 8011000:	0802f41c 	.word	0x0802f41c
 8011004:	0802f370 	.word	0x0802f370
 8011008:	0802f39c 	.word	0x0802f39c
 801100c:	0802f3c4 	.word	0x0802f3c4
 8011010:	0802f3f0 	.word	0x0802f3f0
 8011014:	0802f424 	.word	0x0802f424
        PRINT_ERR("UNEXPECTED CPIN STATE")
 8011018:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 80110e4 <fRspAnalyze_CPIN+0x404>
 801101c:	4d30      	ldr	r5, [pc, #192]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 801101e:	f10e 0a20 	add.w	sl, lr, #32
 8011022:	46f4      	mov	ip, lr
 8011024:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011028:	6028      	str	r0, [r5, #0]
 801102a:	6069      	str	r1, [r5, #4]
 801102c:	60aa      	str	r2, [r5, #8]
 801102e:	60eb      	str	r3, [r5, #12]
 8011030:	46e6      	mov	lr, ip
 8011032:	3510      	adds	r5, #16
 8011034:	45d4      	cmp	ip, sl
 8011036:	d1f4      	bne.n	8011022 <fRspAnalyze_CPIN+0x342>
 8011038:	f8dc 0000 	ldr.w	r0, [ip]
 801103c:	6028      	str	r0, [r5, #0]
 801103e:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8011042:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8011046:	80aa      	strh	r2, [r5, #4]
 8011048:	71ab      	strb	r3, [r5, #6]
 801104a:	4d25      	ldr	r5, [pc, #148]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 801104c:	4628      	mov	r0, r5
 801104e:	f00e f860 	bl	801f112 <crs_strlen>
 8011052:	b283      	uxth	r3, r0
 8011054:	462a      	mov	r2, r5
 8011056:	2110      	movs	r1, #16
 8011058:	2002      	movs	r0, #2
 801105a:	f00e f89d 	bl	801f198 <traceIF_itmPrint>
 801105e:	4628      	mov	r0, r5
 8011060:	f00e f857 	bl	801f112 <crs_strlen>
 8011064:	b283      	uxth	r3, r0
 8011066:	462a      	mov	r2, r5
 8011068:	2110      	movs	r1, #16
 801106a:	2002      	movs	r0, #2
 801106c:	f00e f8b6 	bl	801f1dc <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8011070:	2300      	movs	r3, #0
 8011072:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_UNKNOWN;
 8011076:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 801107a:	4649      	mov	r1, r9
 801107c:	2001      	movs	r0, #1
 801107e:	f7fd fa7b 	bl	800e578 <set_error_report>
 8011082:	e667      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      PRINT_ERR("line exceed maximum size, line ignored...")
 8011084:	f8df c060 	ldr.w	ip, [pc, #96]	; 80110e8 <fRspAnalyze_CPIN+0x408>
 8011088:	4d15      	ldr	r5, [pc, #84]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 801108a:	f10c 0a30 	add.w	sl, ip, #48	; 0x30
 801108e:	46e6      	mov	lr, ip
 8011090:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8011094:	6028      	str	r0, [r5, #0]
 8011096:	6069      	str	r1, [r5, #4]
 8011098:	60aa      	str	r2, [r5, #8]
 801109a:	60eb      	str	r3, [r5, #12]
 801109c:	46f4      	mov	ip, lr
 801109e:	3510      	adds	r5, #16
 80110a0:	45d6      	cmp	lr, sl
 80110a2:	d1f4      	bne.n	801108e <fRspAnalyze_CPIN+0x3ae>
 80110a4:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 80110a8:	6028      	str	r0, [r5, #0]
 80110aa:	6069      	str	r1, [r5, #4]
 80110ac:	f8bc 2000 	ldrh.w	r2, [ip]
 80110b0:	f89c 3002 	ldrb.w	r3, [ip, #2]
 80110b4:	812a      	strh	r2, [r5, #8]
 80110b6:	72ab      	strb	r3, [r5, #10]
 80110b8:	4d09      	ldr	r5, [pc, #36]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 80110ba:	4628      	mov	r0, r5
 80110bc:	f00e f829 	bl	801f112 <crs_strlen>
 80110c0:	b283      	uxth	r3, r0
 80110c2:	462a      	mov	r2, r5
 80110c4:	2110      	movs	r1, #16
 80110c6:	2002      	movs	r0, #2
 80110c8:	f00e f866 	bl	801f198 <traceIF_itmPrint>
 80110cc:	4628      	mov	r0, r5
 80110ce:	f00e f820 	bl	801f112 <crs_strlen>
 80110d2:	b283      	uxth	r3, r0
 80110d4:	462a      	mov	r2, r5
 80110d6:	2110      	movs	r1, #16
 80110d8:	2002      	movs	r0, #2
 80110da:	f00e f87f 	bl	801f1dc <traceIF_uartPrint>
      retval = ATACTION_RSP_IGNORED;
 80110de:	e639      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
 80110e0:	200048dc 	.word	0x200048dc
 80110e4:	0802f43c 	.word	0x0802f43c
 80110e8:	0802e5e0 	.word	0x0802e5e0

080110ec <fRspAnalyze_COPS>:
  return (retval);
}

at_action_rsp_t fRspAnalyze_COPS(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80110ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80110f0:	4606      	mov	r6, r0
 80110f2:	4689      	mov	r9, r1
 80110f4:	4690      	mov	r8, r2
 80110f6:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_COPS()")
 80110f8:	4cc1      	ldr	r4, [pc, #772]	; (8011400 <fRspAnalyze_COPS+0x314>)
 80110fa:	4dc2      	ldr	r5, [pc, #776]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80110fc:	f104 0e20 	add.w	lr, r4, #32
 8011100:	46a4      	mov	ip, r4
 8011102:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011106:	6028      	str	r0, [r5, #0]
 8011108:	6069      	str	r1, [r5, #4]
 801110a:	60aa      	str	r2, [r5, #8]
 801110c:	60eb      	str	r3, [r5, #12]
 801110e:	4664      	mov	r4, ip
 8011110:	3510      	adds	r5, #16
 8011112:	45f4      	cmp	ip, lr
 8011114:	d1f4      	bne.n	8011100 <fRspAnalyze_COPS+0x14>
 8011116:	cc03      	ldmia	r4!, {r0, r1}
 8011118:	6028      	str	r0, [r5, #0]
 801111a:	6069      	str	r1, [r5, #4]
 801111c:	4cb9      	ldr	r4, [pc, #740]	; (8011404 <fRspAnalyze_COPS+0x318>)
 801111e:	4620      	mov	r0, r4
 8011120:	f00d fff7 	bl	801f112 <crs_strlen>
 8011124:	b283      	uxth	r3, r0
 8011126:	4622      	mov	r2, r4
 8011128:	2104      	movs	r1, #4
 801112a:	2002      	movs	r0, #2
 801112c:	f00e f834 	bl	801f198 <traceIF_itmPrint>
 8011130:	4620      	mov	r0, r4
 8011132:	f00d ffee 	bl	801f112 <crs_strlen>
 8011136:	b283      	uxth	r3, r0
 8011138:	4622      	mov	r2, r4
 801113a:	2104      	movs	r1, #4
 801113c:	2002      	movs	r0, #2
 801113e:	f00e f84d 	bl	801f1dc <traceIF_uartPrint>
    *  2/ answer to COPS test command
    *     +COPS: [list of supported (<stat>,long alphanumeric <oper>,
    *            short alphanumeric <oper>,numeric <oper>[,<AcT>])s]
    *            [,,(list ofsupported <mode>s),(list of supported <format>s)]
  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8011142:	8b33      	ldrh	r3, [r6, #24]
 8011144:	2b02      	cmp	r3, #2
 8011146:	d008      	beq.n	801115a <fRspAnalyze_COPS+0x6e>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8011148:	f04f 0a10 	mov.w	sl, #16
      /* parameters ignored */
    }
    END_PARAM_LOOP()
  }

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 801114c:	8b33      	ldrh	r3, [r6, #24]
 801114e:	2b01      	cmp	r3, #1
 8011150:	f000 8225 	beq.w	801159e <fRspAnalyze_COPS+0x4b2>
  {
    PRINT_DBG("+COPS for test cmd NOT IMPLEMENTED")
  }

  return (retval);
}
 8011154:	4650      	mov	r0, sl
 8011156:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    START_PARAM_LOOP()
 801115a:	2400      	movs	r4, #0
 801115c:	463a      	mov	r2, r7
 801115e:	4641      	mov	r1, r8
 8011160:	4630      	mov	r0, r6
 8011162:	f7fb f971 	bl	800c448 <atcc_extractElement>
 8011166:	2801      	cmp	r0, #1
 8011168:	d000      	beq.n	801116c <fRspAnalyze_COPS+0x80>
 801116a:	2401      	movs	r4, #1
 801116c:	89f9      	ldrh	r1, [r7, #14]
 801116e:	b179      	cbz	r1, 8011190 <fRspAnalyze_COPS+0xa4>
    if (element_infos->param_rank == 2U)
 8011170:	f8b7 a008 	ldrh.w	sl, [r7, #8]
 8011174:	f1ba 0f02 	cmp.w	sl, #2
 8011178:	d00f      	beq.n	801119a <fRspAnalyze_COPS+0xae>
    else if (element_infos->param_rank == 3U)
 801117a:	f1ba 0f03 	cmp.w	sl, #3
 801117e:	d06f      	beq.n	8011260 <fRspAnalyze_COPS+0x174>
    else if (element_infos->param_rank == 4U)
 8011180:	f1ba 0f04 	cmp.w	sl, #4
 8011184:	f000 80ce 	beq.w	8011324 <fRspAnalyze_COPS+0x238>
    else if (element_infos->param_rank == 5U)
 8011188:	f1ba 0f05 	cmp.w	sl, #5
 801118c:	f000 811d 	beq.w	80113ca <fRspAnalyze_COPS+0x2de>
    END_PARAM_LOOP()
 8011190:	2c00      	cmp	r4, #0
 8011192:	d0e3      	beq.n	801115c <fRspAnalyze_COPS+0x70>
 8011194:	f04f 0a10 	mov.w	sl, #16
 8011198:	e7d8      	b.n	801114c <fRspAnalyze_COPS+0x60>
      uint32_t mode = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 801119a:	8978      	ldrh	r0, [r7, #10]
 801119c:	4440      	add	r0, r8
 801119e:	f003 fdc9 	bl	8014d34 <ATutil_convertStringToInt>
      switch (mode)
 80111a2:	2804      	cmp	r0, #4
 80111a4:	d814      	bhi.n	80111d0 <fRspAnalyze_COPS+0xe4>
 80111a6:	e8df f000 	tbb	[pc, r0]
 80111aa:	0703      	.short	0x0703
 80111ac:	130b      	.short	0x130b
 80111ae:	0f          	.byte	0x0f
 80111af:	00          	.byte	0x00
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_AUTO;
 80111b0:	2300      	movs	r3, #0
 80111b2:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111b6:	e039      	b.n	801122c <fRspAnalyze_COPS+0x140>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_MANUAL;
 80111b8:	2301      	movs	r3, #1
 80111ba:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111be:	e035      	b.n	801122c <fRspAnalyze_COPS+0x140>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_DEREGISTER;
 80111c0:	2302      	movs	r3, #2
 80111c2:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111c6:	e031      	b.n	801122c <fRspAnalyze_COPS+0x140>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_MANUAL_THEN_AUTO;
 80111c8:	2304      	movs	r3, #4
 80111ca:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111ce:	e02d      	b.n	801122c <fRspAnalyze_COPS+0x140>
          PRINT_ERR("invalid mode value in +COPS")
 80111d0:	f8df c244 	ldr.w	ip, [pc, #580]	; 8011418 <fRspAnalyze_COPS+0x32c>
 80111d4:	4d8b      	ldr	r5, [pc, #556]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80111d6:	f10c 0a20 	add.w	sl, ip, #32
 80111da:	46e6      	mov	lr, ip
 80111dc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80111e0:	6028      	str	r0, [r5, #0]
 80111e2:	6069      	str	r1, [r5, #4]
 80111e4:	60aa      	str	r2, [r5, #8]
 80111e6:	60eb      	str	r3, [r5, #12]
 80111e8:	46f4      	mov	ip, lr
 80111ea:	3510      	adds	r5, #16
 80111ec:	45d6      	cmp	lr, sl
 80111ee:	d1f4      	bne.n	80111da <fRspAnalyze_COPS+0xee>
 80111f0:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80111f4:	6028      	str	r0, [r5, #0]
 80111f6:	6069      	str	r1, [r5, #4]
 80111f8:	60aa      	str	r2, [r5, #8]
 80111fa:	f89c 3000 	ldrb.w	r3, [ip]
 80111fe:	732b      	strb	r3, [r5, #12]
 8011200:	4d80      	ldr	r5, [pc, #512]	; (8011404 <fRspAnalyze_COPS+0x318>)
 8011202:	4628      	mov	r0, r5
 8011204:	f00d ff85 	bl	801f112 <crs_strlen>
 8011208:	b283      	uxth	r3, r0
 801120a:	462a      	mov	r2, r5
 801120c:	2110      	movs	r1, #16
 801120e:	2002      	movs	r0, #2
 8011210:	f00d ffc2 	bl	801f198 <traceIF_itmPrint>
 8011214:	4628      	mov	r0, r5
 8011216:	f00d ff7c 	bl	801f112 <crs_strlen>
 801121a:	b283      	uxth	r3, r0
 801121c:	462a      	mov	r2, r5
 801121e:	2110      	movs	r1, #16
 8011220:	2002      	movs	r0, #2
 8011222:	f00d ffdb 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_AUTO;
 8011226:	2300      	movs	r3, #0
 8011228:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
      PRINT_DBG("+COPS: mode = %d", p_modem_ctxt->SID_ctxt.read_operator_infos.mode)
 801122c:	4d75      	ldr	r5, [pc, #468]	; (8011404 <fRspAnalyze_COPS+0x318>)
 801122e:	f8b9 2610 	ldrh.w	r2, [r9, #1552]	; 0x610
 8011232:	4975      	ldr	r1, [pc, #468]	; (8011408 <fRspAnalyze_COPS+0x31c>)
 8011234:	4628      	mov	r0, r5
 8011236:	f014 fd1b 	bl	8025c70 <sprintf>
 801123a:	4628      	mov	r0, r5
 801123c:	f00d ff69 	bl	801f112 <crs_strlen>
 8011240:	b283      	uxth	r3, r0
 8011242:	462a      	mov	r2, r5
 8011244:	2102      	movs	r1, #2
 8011246:	4608      	mov	r0, r1
 8011248:	f00d ffa6 	bl	801f198 <traceIF_itmPrint>
 801124c:	4628      	mov	r0, r5
 801124e:	f00d ff60 	bl	801f112 <crs_strlen>
 8011252:	b283      	uxth	r3, r0
 8011254:	462a      	mov	r2, r5
 8011256:	2102      	movs	r1, #2
 8011258:	4608      	mov	r0, r1
 801125a:	f00d ffbf 	bl	801f1dc <traceIF_uartPrint>
 801125e:	e797      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
      uint32_t format = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011260:	8978      	ldrh	r0, [r7, #10]
 8011262:	4440      	add	r0, r8
 8011264:	f003 fd66 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->SID_ctxt.read_operator_infos.optional_fields_presence |= CS_RSF_FORMAT_PRESENT; /* bitfield */
 8011268:	f8b9 3618 	ldrh.w	r3, [r9, #1560]	; 0x618
 801126c:	f043 0301 	orr.w	r3, r3, #1
 8011270:	f8a9 3618 	strh.w	r3, [r9, #1560]	; 0x618
      switch (format)
 8011274:	2801      	cmp	r0, #1
 8011276:	d04d      	beq.n	8011314 <fRspAnalyze_COPS+0x228>
 8011278:	2802      	cmp	r0, #2
 801127a:	d04f      	beq.n	801131c <fRspAnalyze_COPS+0x230>
 801127c:	2800      	cmp	r0, #0
 801127e:	d045      	beq.n	801130c <fRspAnalyze_COPS+0x220>
          PRINT_ERR("invalid format value")
 8011280:	f8df e198 	ldr.w	lr, [pc, #408]	; 801141c <fRspAnalyze_COPS+0x330>
 8011284:	4d5f      	ldr	r5, [pc, #380]	; (8011404 <fRspAnalyze_COPS+0x318>)
 8011286:	f10e 0a20 	add.w	sl, lr, #32
 801128a:	46f4      	mov	ip, lr
 801128c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011290:	6028      	str	r0, [r5, #0]
 8011292:	6069      	str	r1, [r5, #4]
 8011294:	60aa      	str	r2, [r5, #8]
 8011296:	60eb      	str	r3, [r5, #12]
 8011298:	46e6      	mov	lr, ip
 801129a:	3510      	adds	r5, #16
 801129c:	45d4      	cmp	ip, sl
 801129e:	d1f4      	bne.n	801128a <fRspAnalyze_COPS+0x19e>
 80112a0:	f8dc 0000 	ldr.w	r0, [ip]
 80112a4:	6028      	str	r0, [r5, #0]
 80112a6:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80112aa:	80ab      	strh	r3, [r5, #4]
 80112ac:	4d55      	ldr	r5, [pc, #340]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80112ae:	4628      	mov	r0, r5
 80112b0:	f00d ff2f 	bl	801f112 <crs_strlen>
 80112b4:	b283      	uxth	r3, r0
 80112b6:	462a      	mov	r2, r5
 80112b8:	2110      	movs	r1, #16
 80112ba:	2002      	movs	r0, #2
 80112bc:	f00d ff6c 	bl	801f198 <traceIF_itmPrint>
 80112c0:	4628      	mov	r0, r5
 80112c2:	f00d ff26 	bl	801f112 <crs_strlen>
 80112c6:	b283      	uxth	r3, r0
 80112c8:	462a      	mov	r2, r5
 80112ca:	2110      	movs	r1, #16
 80112cc:	2002      	movs	r0, #2
 80112ce:	f00d ff85 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_NOT_PRESENT;
 80112d2:	2309      	movs	r3, #9
 80112d4:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
      PRINT_DBG("+COPS: format = %d", p_modem_ctxt->SID_ctxt.read_operator_infos.format)
 80112d8:	4d4a      	ldr	r5, [pc, #296]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80112da:	f8b9 261a 	ldrh.w	r2, [r9, #1562]	; 0x61a
 80112de:	494b      	ldr	r1, [pc, #300]	; (801140c <fRspAnalyze_COPS+0x320>)
 80112e0:	4628      	mov	r0, r5
 80112e2:	f014 fcc5 	bl	8025c70 <sprintf>
 80112e6:	4628      	mov	r0, r5
 80112e8:	f00d ff13 	bl	801f112 <crs_strlen>
 80112ec:	b283      	uxth	r3, r0
 80112ee:	462a      	mov	r2, r5
 80112f0:	2102      	movs	r1, #2
 80112f2:	4608      	mov	r0, r1
 80112f4:	f00d ff50 	bl	801f198 <traceIF_itmPrint>
 80112f8:	4628      	mov	r0, r5
 80112fa:	f00d ff0a 	bl	801f112 <crs_strlen>
 80112fe:	b283      	uxth	r3, r0
 8011300:	462a      	mov	r2, r5
 8011302:	2102      	movs	r1, #2
 8011304:	4608      	mov	r0, r1
 8011306:	f00d ff69 	bl	801f1dc <traceIF_uartPrint>
 801130a:	e741      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_LONG;
 801130c:	2300      	movs	r3, #0
 801130e:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
          break;
 8011312:	e7e1      	b.n	80112d8 <fRspAnalyze_COPS+0x1ec>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_SHORT;
 8011314:	2301      	movs	r3, #1
 8011316:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
          break;
 801131a:	e7dd      	b.n	80112d8 <fRspAnalyze_COPS+0x1ec>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_NUMERIC;
 801131c:	2302      	movs	r3, #2
 801131e:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
          break;
 8011322:	e7d9      	b.n	80112d8 <fRspAnalyze_COPS+0x1ec>
      if (element_infos->str_size <= MAX_SIZE_OPERATOR_NAME)
 8011324:	2940      	cmp	r1, #64	; 0x40
 8011326:	d826      	bhi.n	8011376 <fRspAnalyze_COPS+0x28a>
        p_modem_ctxt->SID_ctxt.read_operator_infos.optional_fields_presence |=
 8011328:	f8b9 3618 	ldrh.w	r3, [r9, #1560]	; 0x618
 801132c:	f043 0302 	orr.w	r3, r3, #2
 8011330:	f8a9 3618 	strh.w	r3, [r9, #1560]	; 0x618
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.read_operator_infos.operator_name[0]),
 8011334:	f209 6a1c 	addw	sl, r9, #1564	; 0x61c
                      (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8011338:	8979      	ldrh	r1, [r7, #10]
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.read_operator_infos.operator_name[0]),
 801133a:	89fa      	ldrh	r2, [r7, #14]
 801133c:	4441      	add	r1, r8
 801133e:	4650      	mov	r0, sl
 8011340:	f014 fde6 	bl	8025f10 <memcpy>
        PRINT_DBG("+COPS: operator name = %s", p_modem_ctxt->SID_ctxt.read_operator_infos.operator_name)
 8011344:	4d2f      	ldr	r5, [pc, #188]	; (8011404 <fRspAnalyze_COPS+0x318>)
 8011346:	4652      	mov	r2, sl
 8011348:	4931      	ldr	r1, [pc, #196]	; (8011410 <fRspAnalyze_COPS+0x324>)
 801134a:	4628      	mov	r0, r5
 801134c:	f014 fc90 	bl	8025c70 <sprintf>
 8011350:	4628      	mov	r0, r5
 8011352:	f00d fede 	bl	801f112 <crs_strlen>
 8011356:	b283      	uxth	r3, r0
 8011358:	462a      	mov	r2, r5
 801135a:	2102      	movs	r1, #2
 801135c:	4608      	mov	r0, r1
 801135e:	f00d ff1b 	bl	801f198 <traceIF_itmPrint>
 8011362:	4628      	mov	r0, r5
 8011364:	f00d fed5 	bl	801f112 <crs_strlen>
 8011368:	b283      	uxth	r3, r0
 801136a:	462a      	mov	r2, r5
 801136c:	2102      	movs	r1, #2
 801136e:	4608      	mov	r0, r1
 8011370:	f00d ff34 	bl	801f1dc <traceIF_uartPrint>
 8011374:	e70c      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
        PRINT_ERR("error, operator name too long")
 8011376:	4d27      	ldr	r5, [pc, #156]	; (8011414 <fRspAnalyze_COPS+0x328>)
 8011378:	4c22      	ldr	r4, [pc, #136]	; (8011404 <fRspAnalyze_COPS+0x318>)
 801137a:	f105 0c20 	add.w	ip, r5, #32
 801137e:	462f      	mov	r7, r5
 8011380:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8011382:	6020      	str	r0, [r4, #0]
 8011384:	6061      	str	r1, [r4, #4]
 8011386:	60a2      	str	r2, [r4, #8]
 8011388:	60e3      	str	r3, [r4, #12]
 801138a:	463d      	mov	r5, r7
 801138c:	3410      	adds	r4, #16
 801138e:	4567      	cmp	r7, ip
 8011390:	d1f5      	bne.n	801137e <fRspAnalyze_COPS+0x292>
 8011392:	cd07      	ldmia	r5!, {r0, r1, r2}
 8011394:	6020      	str	r0, [r4, #0]
 8011396:	6061      	str	r1, [r4, #4]
 8011398:	60a2      	str	r2, [r4, #8]
 801139a:	882a      	ldrh	r2, [r5, #0]
 801139c:	78ab      	ldrb	r3, [r5, #2]
 801139e:	81a2      	strh	r2, [r4, #12]
 80113a0:	73a3      	strb	r3, [r4, #14]
 80113a2:	4c18      	ldr	r4, [pc, #96]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80113a4:	4620      	mov	r0, r4
 80113a6:	f00d feb4 	bl	801f112 <crs_strlen>
 80113aa:	b283      	uxth	r3, r0
 80113ac:	4622      	mov	r2, r4
 80113ae:	2110      	movs	r1, #16
 80113b0:	2002      	movs	r0, #2
 80113b2:	f00d fef1 	bl	801f198 <traceIF_itmPrint>
 80113b6:	4620      	mov	r0, r4
 80113b8:	f00d feab 	bl	801f112 <crs_strlen>
 80113bc:	b283      	uxth	r3, r0
 80113be:	4622      	mov	r2, r4
 80113c0:	2110      	movs	r1, #16
 80113c2:	2002      	movs	r0, #2
 80113c4:	f00d ff0a 	bl	801f1dc <traceIF_uartPrint>
    END_PARAM_LOOP()
 80113c8:	e6c0      	b.n	801114c <fRspAnalyze_COPS+0x60>
      p_modem_ctxt->SID_ctxt.read_operator_infos.optional_fields_presence |= CS_RSF_ACT_PRESENT;  /* bitfield */
 80113ca:	f8b9 3618 	ldrh.w	r3, [r9, #1560]	; 0x618
 80113ce:	f043 0304 	orr.w	r3, r3, #4
 80113d2:	f8a9 3618 	strh.w	r3, [r9, #1560]	; 0x618
      uint32_t AcT = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80113d6:	8978      	ldrh	r0, [r7, #10]
 80113d8:	89f9      	ldrh	r1, [r7, #14]
 80113da:	4440      	add	r0, r8
 80113dc:	f003 fcaa 	bl	8014d34 <ATutil_convertStringToInt>
 80113e0:	4682      	mov	sl, r0
      switch (AcT)
 80113e2:	2809      	cmp	r0, #9
 80113e4:	f200 80b1 	bhi.w	801154a <fRspAnalyze_COPS+0x45e>
 80113e8:	e8df f000 	tbb	[pc, r0]
 80113ec:	221e1a05 	.word	0x221e1a05
 80113f0:	322e2a26 	.word	0x322e2a26
 80113f4:	7d79      	.short	0x7d79
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_GSM;
 80113f6:	2300      	movs	r3, #0
 80113f8:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 80113fc:	e056      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
 80113fe:	bf00      	nop
 8011400:	0802f464 	.word	0x0802f464
 8011404:	200048dc 	.word	0x200048dc
 8011408:	0802f4bc 	.word	0x0802f4bc
 801140c:	0802f500 	.word	0x0802f500
 8011410:	0802f520 	.word	0x0802f520
 8011414:	0802f548 	.word	0x0802f548
 8011418:	0802f48c 	.word	0x0802f48c
 801141c:	0802f4d8 	.word	0x0802f4d8
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_GSM_COMPACT;
 8011420:	2301      	movs	r3, #1
 8011422:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011426:	e041      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN;
 8011428:	2302      	movs	r3, #2
 801142a:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 801142e:	e03d      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_GSM_EDGE;
 8011430:	2303      	movs	r3, #3
 8011432:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011436:	e039      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN_HSDPA;
 8011438:	2304      	movs	r3, #4
 801143a:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 801143e:	e035      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN_HSUPA;
 8011440:	2305      	movs	r3, #5
 8011442:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011446:	e031      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN_HSDPA_HSUPA;
 8011448:	2306      	movs	r3, #6
 801144a:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 801144e:	e02d      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          PRINT_DBG(">>> Access Technology : LTE Cat.M1 <<<")
 8011450:	f8df e1a8 	ldr.w	lr, [pc, #424]	; 80115fc <fRspAnalyze_COPS+0x510>
 8011454:	f8df c198 	ldr.w	ip, [pc, #408]	; 80115f0 <fRspAnalyze_COPS+0x504>
 8011458:	f10e 0b30 	add.w	fp, lr, #48	; 0x30
 801145c:	4675      	mov	r5, lr
 801145e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8011460:	f8cc 0000 	str.w	r0, [ip]
 8011464:	f8cc 1004 	str.w	r1, [ip, #4]
 8011468:	f8cc 2008 	str.w	r2, [ip, #8]
 801146c:	f8cc 300c 	str.w	r3, [ip, #12]
 8011470:	46ae      	mov	lr, r5
 8011472:	f10c 0c10 	add.w	ip, ip, #16
 8011476:	455d      	cmp	r5, fp
 8011478:	d1f0      	bne.n	801145c <fRspAnalyze_COPS+0x370>
 801147a:	882b      	ldrh	r3, [r5, #0]
 801147c:	f8ac 3000 	strh.w	r3, [ip]
 8011480:	4d5b      	ldr	r5, [pc, #364]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 8011482:	4628      	mov	r0, r5
 8011484:	f00d fe45 	bl	801f112 <crs_strlen>
 8011488:	b283      	uxth	r3, r0
 801148a:	462a      	mov	r2, r5
 801148c:	2102      	movs	r1, #2
 801148e:	4608      	mov	r0, r1
 8011490:	f00d fe82 	bl	801f198 <traceIF_itmPrint>
 8011494:	4628      	mov	r0, r5
 8011496:	f00d fe3c 	bl	801f112 <crs_strlen>
 801149a:	b283      	uxth	r3, r0
 801149c:	462a      	mov	r2, r5
 801149e:	2102      	movs	r1, #2
 80114a0:	4608      	mov	r0, r1
 80114a2:	f00d fe9b 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_E_UTRAN;
 80114a6:	2307      	movs	r3, #7
 80114a8:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
      PRINT_DBG("+COPS: Access technology = %ld", AcT)
 80114ac:	4d50      	ldr	r5, [pc, #320]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 80114ae:	4652      	mov	r2, sl
 80114b0:	4950      	ldr	r1, [pc, #320]	; (80115f4 <fRspAnalyze_COPS+0x508>)
 80114b2:	4628      	mov	r0, r5
 80114b4:	f014 fbdc 	bl	8025c70 <sprintf>
 80114b8:	4628      	mov	r0, r5
 80114ba:	f00d fe2a 	bl	801f112 <crs_strlen>
 80114be:	b283      	uxth	r3, r0
 80114c0:	462a      	mov	r2, r5
 80114c2:	2102      	movs	r1, #2
 80114c4:	4608      	mov	r0, r1
 80114c6:	f00d fe67 	bl	801f198 <traceIF_itmPrint>
 80114ca:	4628      	mov	r0, r5
 80114cc:	f00d fe21 	bl	801f112 <crs_strlen>
 80114d0:	b283      	uxth	r3, r0
 80114d2:	462a      	mov	r2, r5
 80114d4:	2102      	movs	r1, #2
 80114d6:	4608      	mov	r0, r1
 80114d8:	f00d fe80 	bl	801f1dc <traceIF_uartPrint>
 80114dc:	e658      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_EC_GSM_IOT;
 80114de:	2308      	movs	r3, #8
 80114e0:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 80114e4:	e7e2      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          PRINT_DBG(">>> Access Technology : LTE Cat.NB1 <<<")
 80114e6:	f8df e118 	ldr.w	lr, [pc, #280]	; 8011600 <fRspAnalyze_COPS+0x514>
 80114ea:	f8df c104 	ldr.w	ip, [pc, #260]	; 80115f0 <fRspAnalyze_COPS+0x504>
 80114ee:	f10e 0b30 	add.w	fp, lr, #48	; 0x30
 80114f2:	4675      	mov	r5, lr
 80114f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80114f6:	f8cc 0000 	str.w	r0, [ip]
 80114fa:	f8cc 1004 	str.w	r1, [ip, #4]
 80114fe:	f8cc 2008 	str.w	r2, [ip, #8]
 8011502:	f8cc 300c 	str.w	r3, [ip, #12]
 8011506:	46ae      	mov	lr, r5
 8011508:	f10c 0c10 	add.w	ip, ip, #16
 801150c:	455d      	cmp	r5, fp
 801150e:	d1f0      	bne.n	80114f2 <fRspAnalyze_COPS+0x406>
 8011510:	882a      	ldrh	r2, [r5, #0]
 8011512:	78ab      	ldrb	r3, [r5, #2]
 8011514:	f8ac 2000 	strh.w	r2, [ip]
 8011518:	f88c 3002 	strb.w	r3, [ip, #2]
 801151c:	4d34      	ldr	r5, [pc, #208]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 801151e:	4628      	mov	r0, r5
 8011520:	f00d fdf7 	bl	801f112 <crs_strlen>
 8011524:	b283      	uxth	r3, r0
 8011526:	462a      	mov	r2, r5
 8011528:	2102      	movs	r1, #2
 801152a:	4608      	mov	r0, r1
 801152c:	f00d fe34 	bl	801f198 <traceIF_itmPrint>
 8011530:	4628      	mov	r0, r5
 8011532:	f00d fdee 	bl	801f112 <crs_strlen>
 8011536:	b283      	uxth	r3, r0
 8011538:	462a      	mov	r2, r5
 801153a:	2102      	movs	r1, #2
 801153c:	4608      	mov	r0, r1
 801153e:	f00d fe4d 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_E_UTRAN_NBS1;
 8011542:	2309      	movs	r3, #9
 8011544:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011548:	e7b0      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          PRINT_ERR("invalid AcT value")
 801154a:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8011604 <fRspAnalyze_COPS+0x518>
 801154e:	4d28      	ldr	r5, [pc, #160]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 8011550:	f10c 0b20 	add.w	fp, ip, #32
 8011554:	46e6      	mov	lr, ip
 8011556:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801155a:	6028      	str	r0, [r5, #0]
 801155c:	6069      	str	r1, [r5, #4]
 801155e:	60aa      	str	r2, [r5, #8]
 8011560:	60eb      	str	r3, [r5, #12]
 8011562:	46f4      	mov	ip, lr
 8011564:	3510      	adds	r5, #16
 8011566:	45de      	cmp	lr, fp
 8011568:	d1f4      	bne.n	8011554 <fRspAnalyze_COPS+0x468>
 801156a:	f8be 2000 	ldrh.w	r2, [lr]
 801156e:	f89e 3002 	ldrb.w	r3, [lr, #2]
 8011572:	802a      	strh	r2, [r5, #0]
 8011574:	70ab      	strb	r3, [r5, #2]
 8011576:	4d1e      	ldr	r5, [pc, #120]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 8011578:	4628      	mov	r0, r5
 801157a:	f00d fdca 	bl	801f112 <crs_strlen>
 801157e:	b283      	uxth	r3, r0
 8011580:	462a      	mov	r2, r5
 8011582:	2110      	movs	r1, #16
 8011584:	2002      	movs	r0, #2
 8011586:	f00d fe07 	bl	801f198 <traceIF_itmPrint>
 801158a:	4628      	mov	r0, r5
 801158c:	f00d fdc1 	bl	801f112 <crs_strlen>
 8011590:	b283      	uxth	r3, r0
 8011592:	462a      	mov	r2, r5
 8011594:	2110      	movs	r1, #16
 8011596:	2002      	movs	r0, #2
 8011598:	f00d fe20 	bl	801f1dc <traceIF_uartPrint>
          break;
 801159c:	e786      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
    PRINT_DBG("+COPS for test cmd NOT IMPLEMENTED")
 801159e:	4d16      	ldr	r5, [pc, #88]	; (80115f8 <fRspAnalyze_COPS+0x50c>)
 80115a0:	4c13      	ldr	r4, [pc, #76]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 80115a2:	f105 0720 	add.w	r7, r5, #32
 80115a6:	462e      	mov	r6, r5
 80115a8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80115aa:	6020      	str	r0, [r4, #0]
 80115ac:	6061      	str	r1, [r4, #4]
 80115ae:	60a2      	str	r2, [r4, #8]
 80115b0:	60e3      	str	r3, [r4, #12]
 80115b2:	4635      	mov	r5, r6
 80115b4:	3410      	adds	r4, #16
 80115b6:	42be      	cmp	r6, r7
 80115b8:	d1f5      	bne.n	80115a6 <fRspAnalyze_COPS+0x4ba>
 80115ba:	cd07      	ldmia	r5!, {r0, r1, r2}
 80115bc:	6020      	str	r0, [r4, #0]
 80115be:	6061      	str	r1, [r4, #4]
 80115c0:	60a2      	str	r2, [r4, #8]
 80115c2:	882b      	ldrh	r3, [r5, #0]
 80115c4:	81a3      	strh	r3, [r4, #12]
 80115c6:	4c0a      	ldr	r4, [pc, #40]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 80115c8:	4620      	mov	r0, r4
 80115ca:	f00d fda2 	bl	801f112 <crs_strlen>
 80115ce:	b283      	uxth	r3, r0
 80115d0:	4622      	mov	r2, r4
 80115d2:	2102      	movs	r1, #2
 80115d4:	4608      	mov	r0, r1
 80115d6:	f00d fddf 	bl	801f198 <traceIF_itmPrint>
 80115da:	4620      	mov	r0, r4
 80115dc:	f00d fd99 	bl	801f112 <crs_strlen>
 80115e0:	b283      	uxth	r3, r0
 80115e2:	4622      	mov	r2, r4
 80115e4:	2102      	movs	r1, #2
 80115e6:	4608      	mov	r0, r1
 80115e8:	f00d fdf8 	bl	801f1dc <traceIF_uartPrint>
 80115ec:	e5b2      	b.n	8011154 <fRspAnalyze_COPS+0x68>
 80115ee:	bf00      	nop
 80115f0:	200048dc 	.word	0x200048dc
 80115f4:	0802f604 	.word	0x0802f604
 80115f8:	0802f630 	.word	0x0802f630
 80115fc:	0802f578 	.word	0x0802f578
 8011600:	0802f5ac 	.word	0x0802f5ac
 8011604:	0802f5e0 	.word	0x0802f5e0

08011608 <fRspAnalyze_CNUM>:

at_action_rsp_t fRspAnalyze_CNUM(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8011608:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fCmdBuild_CNUM()")
 801160a:	4d2b      	ldr	r5, [pc, #172]	; (80116b8 <fRspAnalyze_CNUM+0xb0>)
 801160c:	4c2b      	ldr	r4, [pc, #172]	; (80116bc <fRspAnalyze_CNUM+0xb4>)
 801160e:	f105 0e20 	add.w	lr, r5, #32
 8011612:	46ac      	mov	ip, r5
 8011614:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011618:	6020      	str	r0, [r4, #0]
 801161a:	6061      	str	r1, [r4, #4]
 801161c:	60a2      	str	r2, [r4, #8]
 801161e:	60e3      	str	r3, [r4, #12]
 8011620:	4665      	mov	r5, ip
 8011622:	3410      	adds	r4, #16
 8011624:	45f4      	cmp	ip, lr
 8011626:	d1f4      	bne.n	8011612 <fRspAnalyze_CNUM+0xa>
 8011628:	f8dc 0000 	ldr.w	r0, [ip]
 801162c:	6020      	str	r0, [r4, #0]
 801162e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8011632:	80a3      	strh	r3, [r4, #4]
 8011634:	4c21      	ldr	r4, [pc, #132]	; (80116bc <fRspAnalyze_CNUM+0xb4>)
 8011636:	4620      	mov	r0, r4
 8011638:	f00d fd6b 	bl	801f112 <crs_strlen>
 801163c:	b283      	uxth	r3, r0
 801163e:	4622      	mov	r2, r4
 8011640:	2104      	movs	r1, #4
 8011642:	2002      	movs	r0, #2
 8011644:	f00d fda8 	bl	801f198 <traceIF_itmPrint>
 8011648:	4620      	mov	r0, r4
 801164a:	f00d fd62 	bl	801f112 <crs_strlen>
 801164e:	b283      	uxth	r3, r0
 8011650:	4622      	mov	r2, r4
 8011652:	2104      	movs	r1, #4
 8011654:	2002      	movs	r0, #2
 8011656:	f00d fdc1 	bl	801f1dc <traceIF_uartPrint>

  PRINT_DBG("+CNUM cmd NOT IMPLEMENTED")
 801165a:	4d19      	ldr	r5, [pc, #100]	; (80116c0 <fRspAnalyze_CNUM+0xb8>)
 801165c:	46a4      	mov	ip, r4
 801165e:	f105 0e20 	add.w	lr, r5, #32
 8011662:	462c      	mov	r4, r5
 8011664:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8011666:	f8cc 0000 	str.w	r0, [ip]
 801166a:	f8cc 1004 	str.w	r1, [ip, #4]
 801166e:	f8cc 2008 	str.w	r2, [ip, #8]
 8011672:	f8cc 300c 	str.w	r3, [ip, #12]
 8011676:	4625      	mov	r5, r4
 8011678:	f10c 0c10 	add.w	ip, ip, #16
 801167c:	4574      	cmp	r4, lr
 801167e:	d1f0      	bne.n	8011662 <fRspAnalyze_CNUM+0x5a>
 8011680:	6820      	ldr	r0, [r4, #0]
 8011682:	f8cc 0000 	str.w	r0, [ip]
 8011686:	7923      	ldrb	r3, [r4, #4]
 8011688:	f88c 3004 	strb.w	r3, [ip, #4]
 801168c:	4c0b      	ldr	r4, [pc, #44]	; (80116bc <fRspAnalyze_CNUM+0xb4>)
 801168e:	4620      	mov	r0, r4
 8011690:	f00d fd3f 	bl	801f112 <crs_strlen>
 8011694:	b283      	uxth	r3, r0
 8011696:	4622      	mov	r2, r4
 8011698:	2102      	movs	r1, #2
 801169a:	4608      	mov	r0, r1
 801169c:	f00d fd7c 	bl	801f198 <traceIF_itmPrint>
 80116a0:	4620      	mov	r0, r4
 80116a2:	f00d fd36 	bl	801f112 <crs_strlen>
 80116a6:	b283      	uxth	r3, r0
 80116a8:	4622      	mov	r2, r4
 80116aa:	2102      	movs	r1, #2
 80116ac:	4608      	mov	r0, r1
 80116ae:	f00d fd95 	bl	801f1dc <traceIF_uartPrint>

  return (retval);
}
 80116b2:	2010      	movs	r0, #16
 80116b4:	bd38      	pop	{r3, r4, r5, pc}
 80116b6:	bf00      	nop
 80116b8:	0802f660 	.word	0x0802f660
 80116bc:	200048dc 	.word	0x200048dc
 80116c0:	0802f688 	.word	0x0802f688

080116c4 <fRspAnalyze_CGATT>:

at_action_rsp_t fRspAnalyze_CGATT(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80116c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80116c8:	4606      	mov	r6, r0
 80116ca:	4689      	mov	r9, r1
 80116cc:	4690      	mov	r8, r2
 80116ce:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGATT()")
 80116d0:	4c46      	ldr	r4, [pc, #280]	; (80117ec <fRspAnalyze_CGATT+0x128>)
 80116d2:	4d47      	ldr	r5, [pc, #284]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 80116d4:	f104 0e20 	add.w	lr, r4, #32
 80116d8:	46a4      	mov	ip, r4
 80116da:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80116de:	6028      	str	r0, [r5, #0]
 80116e0:	6069      	str	r1, [r5, #4]
 80116e2:	60aa      	str	r2, [r5, #8]
 80116e4:	60eb      	str	r3, [r5, #12]
 80116e6:	4664      	mov	r4, ip
 80116e8:	3510      	adds	r5, #16
 80116ea:	45f4      	cmp	ip, lr
 80116ec:	d1f4      	bne.n	80116d8 <fRspAnalyze_CGATT+0x14>
 80116ee:	cc03      	ldmia	r4!, {r0, r1}
 80116f0:	6028      	str	r0, [r5, #0]
 80116f2:	6069      	str	r1, [r5, #4]
 80116f4:	7823      	ldrb	r3, [r4, #0]
 80116f6:	722b      	strb	r3, [r5, #8]
 80116f8:	4c3d      	ldr	r4, [pc, #244]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 80116fa:	4620      	mov	r0, r4
 80116fc:	f00d fd09 	bl	801f112 <crs_strlen>
 8011700:	b283      	uxth	r3, r0
 8011702:	4622      	mov	r2, r4
 8011704:	2104      	movs	r1, #4
 8011706:	2002      	movs	r0, #2
 8011708:	f00d fd46 	bl	801f198 <traceIF_itmPrint>
 801170c:	4620      	mov	r0, r4
 801170e:	f00d fd00 	bl	801f112 <crs_strlen>
 8011712:	b283      	uxth	r3, r0
 8011714:	4622      	mov	r2, r4
 8011716:	2104      	movs	r1, #4
 8011718:	2002      	movs	r0, #2
 801171a:	f00d fd5f 	bl	801f1dc <traceIF_uartPrint>
  *  1/ answer to CGATT read command
  *     +CGATT: <state>
  *  2/ answer to CGATT test command
  *     +CGATT: (list of supported <state>s)
  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 801171e:	8b33      	ldrh	r3, [r6, #24]
 8011720:	2b02      	cmp	r3, #2
 8011722:	d005      	beq.n	8011730 <fRspAnalyze_CGATT+0x6c>
      PRINT_DBG("attach status = %d", p_modem_ctxt->SID_ctxt.attach_status)
    }
    END_PARAM_LOOP()
  }

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8011724:	8b33      	ldrh	r3, [r6, #24]
 8011726:	2b01      	cmp	r3, #1
 8011728:	d035      	beq.n	8011796 <fRspAnalyze_CGATT+0xd2>
  {
    PRINT_DBG("+CGATT for test cmd NOT IMPLEMENTED")
  }

  return (retval);
}
 801172a:	2010      	movs	r0, #16
 801172c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8011730:	2400      	movs	r4, #0
 8011732:	463a      	mov	r2, r7
 8011734:	4641      	mov	r1, r8
 8011736:	4630      	mov	r0, r6
 8011738:	f7fa fe86 	bl	800c448 <atcc_extractElement>
 801173c:	2801      	cmp	r0, #1
 801173e:	d000      	beq.n	8011742 <fRspAnalyze_CGATT+0x7e>
 8011740:	2401      	movs	r4, #1
 8011742:	89f9      	ldrh	r1, [r7, #14]
 8011744:	b111      	cbz	r1, 801174c <fRspAnalyze_CGATT+0x88>
    if (element_infos->param_rank == 2U)
 8011746:	893b      	ldrh	r3, [r7, #8]
 8011748:	2b02      	cmp	r3, #2
 801174a:	d002      	beq.n	8011752 <fRspAnalyze_CGATT+0x8e>
    END_PARAM_LOOP()
 801174c:	2c00      	cmp	r4, #0
 801174e:	d1e9      	bne.n	8011724 <fRspAnalyze_CGATT+0x60>
 8011750:	e7ef      	b.n	8011732 <fRspAnalyze_CGATT+0x6e>
      uint32_t attach = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011752:	8978      	ldrh	r0, [r7, #10]
 8011754:	4440      	add	r0, r8
 8011756:	f003 faed 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->SID_ctxt.attach_status = (attach == 1U) ? CS_PS_ATTACHED : CS_PS_DETACHED;
 801175a:	2801      	cmp	r0, #1
 801175c:	bf14      	ite	ne
 801175e:	2200      	movne	r2, #0
 8011760:	2201      	moveq	r2, #1
 8011762:	f889 2665 	strb.w	r2, [r9, #1637]	; 0x665
      PRINT_DBG("attach status = %d", p_modem_ctxt->SID_ctxt.attach_status)
 8011766:	4d22      	ldr	r5, [pc, #136]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 8011768:	4922      	ldr	r1, [pc, #136]	; (80117f4 <fRspAnalyze_CGATT+0x130>)
 801176a:	4628      	mov	r0, r5
 801176c:	f014 fa80 	bl	8025c70 <sprintf>
 8011770:	4628      	mov	r0, r5
 8011772:	f00d fcce 	bl	801f112 <crs_strlen>
 8011776:	b283      	uxth	r3, r0
 8011778:	462a      	mov	r2, r5
 801177a:	2102      	movs	r1, #2
 801177c:	4608      	mov	r0, r1
 801177e:	f00d fd0b 	bl	801f198 <traceIF_itmPrint>
 8011782:	4628      	mov	r0, r5
 8011784:	f00d fcc5 	bl	801f112 <crs_strlen>
 8011788:	b283      	uxth	r3, r0
 801178a:	462a      	mov	r2, r5
 801178c:	2102      	movs	r1, #2
 801178e:	4608      	mov	r0, r1
 8011790:	f00d fd24 	bl	801f1dc <traceIF_uartPrint>
 8011794:	e7da      	b.n	801174c <fRspAnalyze_CGATT+0x88>
    PRINT_DBG("+CGATT for test cmd NOT IMPLEMENTED")
 8011796:	4d18      	ldr	r5, [pc, #96]	; (80117f8 <fRspAnalyze_CGATT+0x134>)
 8011798:	4c15      	ldr	r4, [pc, #84]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 801179a:	f105 0720 	add.w	r7, r5, #32
 801179e:	462e      	mov	r6, r5
 80117a0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80117a2:	6020      	str	r0, [r4, #0]
 80117a4:	6061      	str	r1, [r4, #4]
 80117a6:	60a2      	str	r2, [r4, #8]
 80117a8:	60e3      	str	r3, [r4, #12]
 80117aa:	4635      	mov	r5, r6
 80117ac:	3410      	adds	r4, #16
 80117ae:	42be      	cmp	r6, r7
 80117b0:	d1f5      	bne.n	801179e <fRspAnalyze_CGATT+0xda>
 80117b2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80117b4:	6020      	str	r0, [r4, #0]
 80117b6:	6061      	str	r1, [r4, #4]
 80117b8:	60a2      	str	r2, [r4, #8]
 80117ba:	882a      	ldrh	r2, [r5, #0]
 80117bc:	78ab      	ldrb	r3, [r5, #2]
 80117be:	81a2      	strh	r2, [r4, #12]
 80117c0:	73a3      	strb	r3, [r4, #14]
 80117c2:	4c0b      	ldr	r4, [pc, #44]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 80117c4:	4620      	mov	r0, r4
 80117c6:	f00d fca4 	bl	801f112 <crs_strlen>
 80117ca:	b283      	uxth	r3, r0
 80117cc:	4622      	mov	r2, r4
 80117ce:	2102      	movs	r1, #2
 80117d0:	4608      	mov	r0, r1
 80117d2:	f00d fce1 	bl	801f198 <traceIF_itmPrint>
 80117d6:	4620      	mov	r0, r4
 80117d8:	f00d fc9b 	bl	801f112 <crs_strlen>
 80117dc:	b283      	uxth	r3, r0
 80117de:	4622      	mov	r2, r4
 80117e0:	2102      	movs	r1, #2
 80117e2:	4608      	mov	r0, r1
 80117e4:	f00d fcfa 	bl	801f1dc <traceIF_uartPrint>
 80117e8:	e79f      	b.n	801172a <fRspAnalyze_CGATT+0x66>
 80117ea:	bf00      	nop
 80117ec:	0802f6b0 	.word	0x0802f6b0
 80117f0:	200048dc 	.word	0x200048dc
 80117f4:	0802f6dc 	.word	0x0802f6dc
 80117f8:	0802f6fc 	.word	0x0802f6fc

080117fc <fRspAnalyze_CREG>:

at_action_rsp_t fRspAnalyze_CREG(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80117fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011800:	4607      	mov	r7, r0
 8011802:	4689      	mov	r9, r1
 8011804:	4690      	mov	r8, r2
 8011806:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CREG()")
 8011808:	4cb9      	ldr	r4, [pc, #740]	; (8011af0 <fRspAnalyze_CREG+0x2f4>)
 801180a:	4dba      	ldr	r5, [pc, #744]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 801180c:	f104 0e20 	add.w	lr, r4, #32
 8011810:	46a4      	mov	ip, r4
 8011812:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011816:	6028      	str	r0, [r5, #0]
 8011818:	6069      	str	r1, [r5, #4]
 801181a:	60aa      	str	r2, [r5, #8]
 801181c:	60eb      	str	r3, [r5, #12]
 801181e:	4664      	mov	r4, ip
 8011820:	3510      	adds	r5, #16
 8011822:	45f4      	cmp	ip, lr
 8011824:	d1f4      	bne.n	8011810 <fRspAnalyze_CREG+0x14>
 8011826:	cc03      	ldmia	r4!, {r0, r1}
 8011828:	6028      	str	r0, [r5, #0]
 801182a:	6069      	str	r1, [r5, #4]
 801182c:	4cb1      	ldr	r4, [pc, #708]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 801182e:	4620      	mov	r0, r4
 8011830:	f00d fc6f 	bl	801f112 <crs_strlen>
 8011834:	b283      	uxth	r3, r0
 8011836:	4622      	mov	r2, r4
 8011838:	2104      	movs	r1, #4
 801183a:	2002      	movs	r0, #2
 801183c:	f00d fcac 	bl	801f198 <traceIF_itmPrint>
 8011840:	4620      	mov	r0, r4
 8011842:	f00d fc66 	bl	801f112 <crs_strlen>
 8011846:	b283      	uxth	r3, r0
 8011848:	4622      	mov	r2, r4
 801184a:	2104      	movs	r1, #4
 801184c:	2002      	movs	r0, #2
 801184e:	f00d fcc5 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("current cmd = %ld", p_atp_ctxt->current_atcmd.id)
 8011852:	69fa      	ldr	r2, [r7, #28]
 8011854:	49a8      	ldr	r1, [pc, #672]	; (8011af8 <fRspAnalyze_CREG+0x2fc>)
 8011856:	4620      	mov	r0, r4
 8011858:	f014 fa0a 	bl	8025c70 <sprintf>
 801185c:	4620      	mov	r0, r4
 801185e:	f00d fc58 	bl	801f112 <crs_strlen>
 8011862:	b283      	uxth	r3, r0
 8011864:	4622      	mov	r2, r4
 8011866:	2102      	movs	r1, #2
 8011868:	4608      	mov	r0, r1
 801186a:	f00d fc95 	bl	801f198 <traceIF_itmPrint>
 801186e:	4620      	mov	r0, r4
 8011870:	f00d fc4f 	bl	801f112 <crs_strlen>
 8011874:	b283      	uxth	r3, r0
 8011876:	4622      	mov	r2, r4
 8011878:	2102      	movs	r1, #2
 801187a:	4608      	mov	r0, r1
 801187c:	f00d fcae 	bl	801f1dc <traceIF_uartPrint>
  *  2/ answer to CREG test command
  *     +CREG: (list of supported <n>s)
  *  3/ URC:
  *     +CREG: <stat>[,[<lac>],[<ci>],[<AcT>]]
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CREG)
 8011880:	69fb      	ldr	r3, [r7, #28]
 8011882:	2b17      	cmp	r3, #23
 8011884:	f040 80f2 	bne.w	8011a6c <fRspAnalyze_CREG+0x270>
  {
    /* analyze parameters for +CREG */
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8011888:	8b3b      	ldrh	r3, [r7, #24]
 801188a:	2b02      	cmp	r3, #2
 801188c:	d005      	beq.n	801189a <fRspAnalyze_CREG+0x9e>
      }
      /* other parameters are not supported yet */
      END_PARAM_LOOP()
    }
    /* analyze parameters for +CREG */
    else if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 801188e:	2b01      	cmp	r3, #1
 8011890:	f000 80c4 	beq.w	8011a1c <fRspAnalyze_CREG+0x220>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8011894:	2010      	movs	r0, #16
 8011896:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      START_PARAM_LOOP()
 801189a:	2400      	movs	r4, #0
 801189c:	4632      	mov	r2, r6
 801189e:	4641      	mov	r1, r8
 80118a0:	4638      	mov	r0, r7
 80118a2:	f7fa fdd1 	bl	800c448 <atcc_extractElement>
 80118a6:	2801      	cmp	r0, #1
 80118a8:	d000      	beq.n	80118ac <fRspAnalyze_CREG+0xb0>
 80118aa:	2401      	movs	r4, #1
 80118ac:	89f1      	ldrh	r1, [r6, #14]
 80118ae:	b179      	cbz	r1, 80118d0 <fRspAnalyze_CREG+0xd4>
      if (element_infos->param_rank == 2U)
 80118b0:	8933      	ldrh	r3, [r6, #8]
 80118b2:	2b02      	cmp	r3, #2
 80118b4:	d00f      	beq.n	80118d6 <fRspAnalyze_CREG+0xda>
      if (element_infos->param_rank == 3U)
 80118b6:	8933      	ldrh	r3, [r6, #8]
 80118b8:	2b03      	cmp	r3, #3
 80118ba:	d029      	beq.n	8011910 <fRspAnalyze_CREG+0x114>
      if (element_infos->param_rank == 4U)
 80118bc:	8933      	ldrh	r3, [r6, #8]
 80118be:	2b04      	cmp	r3, #4
 80118c0:	d04a      	beq.n	8011958 <fRspAnalyze_CREG+0x15c>
      if (element_infos->param_rank == 5U)
 80118c2:	8933      	ldrh	r3, [r6, #8]
 80118c4:	2b05      	cmp	r3, #5
 80118c6:	d069      	beq.n	801199c <fRspAnalyze_CREG+0x1a0>
      if (element_infos->param_rank == 6U)
 80118c8:	8933      	ldrh	r3, [r6, #8]
 80118ca:	2b06      	cmp	r3, #6
 80118cc:	f000 8088 	beq.w	80119e0 <fRspAnalyze_CREG+0x1e4>
      END_PARAM_LOOP()
 80118d0:	2c00      	cmp	r4, #0
 80118d2:	d1df      	bne.n	8011894 <fRspAnalyze_CREG+0x98>
 80118d4:	e7e2      	b.n	801189c <fRspAnalyze_CREG+0xa0>
        PRINT_DBG("+CREG: n=%ld",
 80118d6:	8970      	ldrh	r0, [r6, #10]
 80118d8:	4440      	add	r0, r8
 80118da:	f003 fa2b 	bl	8014d34 <ATutil_convertStringToInt>
 80118de:	4602      	mov	r2, r0
 80118e0:	4d84      	ldr	r5, [pc, #528]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 80118e2:	4986      	ldr	r1, [pc, #536]	; (8011afc <fRspAnalyze_CREG+0x300>)
 80118e4:	4628      	mov	r0, r5
 80118e6:	f014 f9c3 	bl	8025c70 <sprintf>
 80118ea:	4628      	mov	r0, r5
 80118ec:	f00d fc11 	bl	801f112 <crs_strlen>
 80118f0:	b283      	uxth	r3, r0
 80118f2:	462a      	mov	r2, r5
 80118f4:	2102      	movs	r1, #2
 80118f6:	4608      	mov	r0, r1
 80118f8:	f00d fc4e 	bl	801f198 <traceIF_itmPrint>
 80118fc:	4628      	mov	r0, r5
 80118fe:	f00d fc08 	bl	801f112 <crs_strlen>
 8011902:	b283      	uxth	r3, r0
 8011904:	462a      	mov	r2, r5
 8011906:	2102      	movs	r1, #2
 8011908:	4608      	mov	r0, r1
 801190a:	f00d fc67 	bl	801f1dc <traceIF_uartPrint>
 801190e:	e7d2      	b.n	80118b6 <fRspAnalyze_CREG+0xba>
        uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011910:	8970      	ldrh	r0, [r6, #10]
 8011912:	89f1      	ldrh	r1, [r6, #14]
 8011914:	4440      	add	r0, r8
 8011916:	f003 fa0d 	bl	8014d34 <ATutil_convertStringToInt>
 801191a:	4682      	mov	sl, r0
        p_modem_ctxt->persist.cs_network_state = convert_NetworkState(stat, CS_NETWORK_TYPE);
 801191c:	2101      	movs	r1, #1
 801191e:	f7fc ffcb 	bl	800e8b8 <convert_NetworkState>
 8011922:	f8a9 0048 	strh.w	r0, [r9, #72]	; 0x48
        PRINT_DBG("+CREG: stat=%ld", stat)
 8011926:	4d73      	ldr	r5, [pc, #460]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011928:	4652      	mov	r2, sl
 801192a:	4975      	ldr	r1, [pc, #468]	; (8011b00 <fRspAnalyze_CREG+0x304>)
 801192c:	4628      	mov	r0, r5
 801192e:	f014 f99f 	bl	8025c70 <sprintf>
 8011932:	4628      	mov	r0, r5
 8011934:	f00d fbed 	bl	801f112 <crs_strlen>
 8011938:	b283      	uxth	r3, r0
 801193a:	462a      	mov	r2, r5
 801193c:	2102      	movs	r1, #2
 801193e:	4608      	mov	r0, r1
 8011940:	f00d fc2a 	bl	801f198 <traceIF_itmPrint>
 8011944:	4628      	mov	r0, r5
 8011946:	f00d fbe4 	bl	801f112 <crs_strlen>
 801194a:	b283      	uxth	r3, r0
 801194c:	462a      	mov	r2, r5
 801194e:	2102      	movs	r1, #2
 8011950:	4608      	mov	r0, r1
 8011952:	f00d fc43 	bl	801f1dc <traceIF_uartPrint>
 8011956:	e7b1      	b.n	80118bc <fRspAnalyze_CREG+0xc0>
        uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011958:	8970      	ldrh	r0, [r6, #10]
 801195a:	2204      	movs	r2, #4
 801195c:	89f1      	ldrh	r1, [r6, #14]
 801195e:	4440      	add	r0, r8
 8011960:	f7fd f948 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011964:	4602      	mov	r2, r0
        p_modem_ctxt->persist.cs_location_info.lac = (uint16_t)lac;
 8011966:	f8a9 0044 	strh.w	r0, [r9, #68]	; 0x44
        PRINT_INFO("+CREG: lac=%ld =0x%lx", lac, lac)
 801196a:	4d62      	ldr	r5, [pc, #392]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 801196c:	4603      	mov	r3, r0
 801196e:	4965      	ldr	r1, [pc, #404]	; (8011b04 <fRspAnalyze_CREG+0x308>)
 8011970:	4628      	mov	r0, r5
 8011972:	f014 f97d 	bl	8025c70 <sprintf>
 8011976:	4628      	mov	r0, r5
 8011978:	f00d fbcb 	bl	801f112 <crs_strlen>
 801197c:	b283      	uxth	r3, r0
 801197e:	462a      	mov	r2, r5
 8011980:	2101      	movs	r1, #1
 8011982:	2002      	movs	r0, #2
 8011984:	f00d fc08 	bl	801f198 <traceIF_itmPrint>
 8011988:	4628      	mov	r0, r5
 801198a:	f00d fbc2 	bl	801f112 <crs_strlen>
 801198e:	b283      	uxth	r3, r0
 8011990:	462a      	mov	r2, r5
 8011992:	2101      	movs	r1, #1
 8011994:	2002      	movs	r0, #2
 8011996:	f00d fc21 	bl	801f1dc <traceIF_uartPrint>
 801199a:	e792      	b.n	80118c2 <fRspAnalyze_CREG+0xc6>
        uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 801199c:	8970      	ldrh	r0, [r6, #10]
 801199e:	2208      	movs	r2, #8
 80119a0:	89f1      	ldrh	r1, [r6, #14]
 80119a2:	4440      	add	r0, r8
 80119a4:	f7fd f926 	bl	800ebf4 <extract_hex_value_from_quotes>
 80119a8:	4602      	mov	r2, r0
        p_modem_ctxt->persist.cs_location_info.ci = (uint32_t)ci;
 80119aa:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
        PRINT_INFO("+CREG: ci=%ld =0x%lx", ci, ci)
 80119ae:	4d51      	ldr	r5, [pc, #324]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 80119b0:	4603      	mov	r3, r0
 80119b2:	4955      	ldr	r1, [pc, #340]	; (8011b08 <fRspAnalyze_CREG+0x30c>)
 80119b4:	4628      	mov	r0, r5
 80119b6:	f014 f95b 	bl	8025c70 <sprintf>
 80119ba:	4628      	mov	r0, r5
 80119bc:	f00d fba9 	bl	801f112 <crs_strlen>
 80119c0:	b283      	uxth	r3, r0
 80119c2:	462a      	mov	r2, r5
 80119c4:	2101      	movs	r1, #1
 80119c6:	2002      	movs	r0, #2
 80119c8:	f00d fbe6 	bl	801f198 <traceIF_itmPrint>
 80119cc:	4628      	mov	r0, r5
 80119ce:	f00d fba0 	bl	801f112 <crs_strlen>
 80119d2:	b283      	uxth	r3, r0
 80119d4:	462a      	mov	r2, r5
 80119d6:	2101      	movs	r1, #1
 80119d8:	2002      	movs	r0, #2
 80119da:	f00d fbff 	bl	801f1dc <traceIF_uartPrint>
 80119de:	e773      	b.n	80118c8 <fRspAnalyze_CREG+0xcc>
        PRINT_DBG("+CREG: act=%ld",
 80119e0:	8970      	ldrh	r0, [r6, #10]
 80119e2:	89f1      	ldrh	r1, [r6, #14]
 80119e4:	4440      	add	r0, r8
 80119e6:	f003 f9a5 	bl	8014d34 <ATutil_convertStringToInt>
 80119ea:	4602      	mov	r2, r0
 80119ec:	4d41      	ldr	r5, [pc, #260]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 80119ee:	4947      	ldr	r1, [pc, #284]	; (8011b0c <fRspAnalyze_CREG+0x310>)
 80119f0:	4628      	mov	r0, r5
 80119f2:	f014 f93d 	bl	8025c70 <sprintf>
 80119f6:	4628      	mov	r0, r5
 80119f8:	f00d fb8b 	bl	801f112 <crs_strlen>
 80119fc:	b283      	uxth	r3, r0
 80119fe:	462a      	mov	r2, r5
 8011a00:	2102      	movs	r1, #2
 8011a02:	4608      	mov	r0, r1
 8011a04:	f00d fbc8 	bl	801f198 <traceIF_itmPrint>
 8011a08:	4628      	mov	r0, r5
 8011a0a:	f00d fb82 	bl	801f112 <crs_strlen>
 8011a0e:	b283      	uxth	r3, r0
 8011a10:	462a      	mov	r2, r5
 8011a12:	2102      	movs	r1, #2
 8011a14:	4608      	mov	r0, r1
 8011a16:	f00d fbe1 	bl	801f1dc <traceIF_uartPrint>
 8011a1a:	e759      	b.n	80118d0 <fRspAnalyze_CREG+0xd4>
      PRINT_DBG("+CREG for test cmd NOT IMPLEMENTED")
 8011a1c:	4d3c      	ldr	r5, [pc, #240]	; (8011b10 <fRspAnalyze_CREG+0x314>)
 8011a1e:	4c35      	ldr	r4, [pc, #212]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011a20:	f105 0720 	add.w	r7, r5, #32
 8011a24:	462e      	mov	r6, r5
 8011a26:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8011a28:	6020      	str	r0, [r4, #0]
 8011a2a:	6061      	str	r1, [r4, #4]
 8011a2c:	60a2      	str	r2, [r4, #8]
 8011a2e:	60e3      	str	r3, [r4, #12]
 8011a30:	4635      	mov	r5, r6
 8011a32:	3410      	adds	r4, #16
 8011a34:	42be      	cmp	r6, r7
 8011a36:	d1f5      	bne.n	8011a24 <fRspAnalyze_CREG+0x228>
 8011a38:	cd07      	ldmia	r5!, {r0, r1, r2}
 8011a3a:	6020      	str	r0, [r4, #0]
 8011a3c:	6061      	str	r1, [r4, #4]
 8011a3e:	60a2      	str	r2, [r4, #8]
 8011a40:	882b      	ldrh	r3, [r5, #0]
 8011a42:	81a3      	strh	r3, [r4, #12]
 8011a44:	4c2b      	ldr	r4, [pc, #172]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011a46:	4620      	mov	r0, r4
 8011a48:	f00d fb63 	bl	801f112 <crs_strlen>
 8011a4c:	b283      	uxth	r3, r0
 8011a4e:	4622      	mov	r2, r4
 8011a50:	2102      	movs	r1, #2
 8011a52:	4608      	mov	r0, r1
 8011a54:	f00d fba0 	bl	801f198 <traceIF_itmPrint>
 8011a58:	4620      	mov	r0, r4
 8011a5a:	f00d fb5a 	bl	801f112 <crs_strlen>
 8011a5e:	b283      	uxth	r3, r0
 8011a60:	4622      	mov	r2, r4
 8011a62:	2102      	movs	r1, #2
 8011a64:	4608      	mov	r0, r1
 8011a66:	f00d fbb9 	bl	801f1dc <traceIF_uartPrint>
 8011a6a:	e713      	b.n	8011894 <fRspAnalyze_CREG+0x98>
    START_PARAM_LOOP()
 8011a6c:	2400      	movs	r4, #0
 8011a6e:	4632      	mov	r2, r6
 8011a70:	4641      	mov	r1, r8
 8011a72:	4638      	mov	r0, r7
 8011a74:	f7fa fce8 	bl	800c448 <atcc_extractElement>
 8011a78:	2801      	cmp	r0, #1
 8011a7a:	d000      	beq.n	8011a7e <fRspAnalyze_CREG+0x282>
 8011a7c:	2401      	movs	r4, #1
 8011a7e:	89f1      	ldrh	r1, [r6, #14]
 8011a80:	b161      	cbz	r1, 8011a9c <fRspAnalyze_CREG+0x2a0>
    if (element_infos->param_rank == 2U)
 8011a82:	8933      	ldrh	r3, [r6, #8]
 8011a84:	2b02      	cmp	r3, #2
 8011a86:	d00d      	beq.n	8011aa4 <fRspAnalyze_CREG+0x2a8>
    if (element_infos->param_rank == 3U)
 8011a88:	8933      	ldrh	r3, [r6, #8]
 8011a8a:	2b03      	cmp	r3, #3
 8011a8c:	d044      	beq.n	8011b18 <fRspAnalyze_CREG+0x31c>
    if (element_infos->param_rank == 4U)
 8011a8e:	8933      	ldrh	r3, [r6, #8]
 8011a90:	2b04      	cmp	r3, #4
 8011a92:	d067      	beq.n	8011b64 <fRspAnalyze_CREG+0x368>
    if (element_infos->param_rank == 5U)
 8011a94:	8933      	ldrh	r3, [r6, #8]
 8011a96:	2b05      	cmp	r3, #5
 8011a98:	f000 808a 	beq.w	8011bb0 <fRspAnalyze_CREG+0x3b4>
    END_PARAM_LOOP()
 8011a9c:	2c00      	cmp	r4, #0
 8011a9e:	f47f aef9 	bne.w	8011894 <fRspAnalyze_CREG+0x98>
 8011aa2:	e7e4      	b.n	8011a6e <fRspAnalyze_CREG+0x272>
      uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011aa4:	8970      	ldrh	r0, [r6, #10]
 8011aa6:	4440      	add	r0, r8
 8011aa8:	f003 f944 	bl	8014d34 <ATutil_convertStringToInt>
 8011aac:	4682      	mov	sl, r0
      p_modem_ctxt->persist.urc_avail_cs_network_registration = AT_TRUE;
 8011aae:	2101      	movs	r1, #1
 8011ab0:	f889 101a 	strb.w	r1, [r9, #26]
      p_modem_ctxt->persist.cs_network_state = convert_NetworkState(stat, CS_NETWORK_TYPE);
 8011ab4:	f7fc ff00 	bl	800e8b8 <convert_NetworkState>
 8011ab8:	f8a9 0048 	strh.w	r0, [r9, #72]	; 0x48
      PRINT_DBG("+CREG URC: stat=%ld", stat)
 8011abc:	4d0d      	ldr	r5, [pc, #52]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011abe:	4652      	mov	r2, sl
 8011ac0:	4914      	ldr	r1, [pc, #80]	; (8011b14 <fRspAnalyze_CREG+0x318>)
 8011ac2:	4628      	mov	r0, r5
 8011ac4:	f014 f8d4 	bl	8025c70 <sprintf>
 8011ac8:	4628      	mov	r0, r5
 8011aca:	f00d fb22 	bl	801f112 <crs_strlen>
 8011ace:	b283      	uxth	r3, r0
 8011ad0:	462a      	mov	r2, r5
 8011ad2:	2102      	movs	r1, #2
 8011ad4:	4608      	mov	r0, r1
 8011ad6:	f00d fb5f 	bl	801f198 <traceIF_itmPrint>
 8011ada:	4628      	mov	r0, r5
 8011adc:	f00d fb19 	bl	801f112 <crs_strlen>
 8011ae0:	b283      	uxth	r3, r0
 8011ae2:	462a      	mov	r2, r5
 8011ae4:	2102      	movs	r1, #2
 8011ae6:	4608      	mov	r0, r1
 8011ae8:	f00d fb78 	bl	801f1dc <traceIF_uartPrint>
 8011aec:	e7cc      	b.n	8011a88 <fRspAnalyze_CREG+0x28c>
 8011aee:	bf00      	nop
 8011af0:	0802f72c 	.word	0x0802f72c
 8011af4:	200048dc 	.word	0x200048dc
 8011af8:	0802f754 	.word	0x0802f754
 8011afc:	0802f774 	.word	0x0802f774
 8011b00:	0802f78c 	.word	0x0802f78c
 8011b04:	0802f7a8 	.word	0x0802f7a8
 8011b08:	0802f7cc 	.word	0x0802f7cc
 8011b0c:	0802f7ec 	.word	0x0802f7ec
 8011b10:	0802f808 	.word	0x0802f808
 8011b14:	0802f838 	.word	0x0802f838
      uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011b18:	8970      	ldrh	r0, [r6, #10]
 8011b1a:	2204      	movs	r2, #4
 8011b1c:	89f1      	ldrh	r1, [r6, #14]
 8011b1e:	4440      	add	r0, r8
 8011b20:	f7fd f868 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011b24:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_cs_location_info_lac = AT_TRUE;
 8011b26:	f04f 0a01 	mov.w	sl, #1
 8011b2a:	f889 a01b 	strb.w	sl, [r9, #27]
      p_modem_ctxt->persist.cs_location_info.lac = (uint16_t)lac;
 8011b2e:	f8a9 0044 	strh.w	r0, [r9, #68]	; 0x44
      PRINT_INFO("+CREG URC: lac=%ld =0x%lx", lac, lac)
 8011b32:	4d2e      	ldr	r5, [pc, #184]	; (8011bec <fRspAnalyze_CREG+0x3f0>)
 8011b34:	4603      	mov	r3, r0
 8011b36:	492e      	ldr	r1, [pc, #184]	; (8011bf0 <fRspAnalyze_CREG+0x3f4>)
 8011b38:	4628      	mov	r0, r5
 8011b3a:	f014 f899 	bl	8025c70 <sprintf>
 8011b3e:	4628      	mov	r0, r5
 8011b40:	f00d fae7 	bl	801f112 <crs_strlen>
 8011b44:	b283      	uxth	r3, r0
 8011b46:	462a      	mov	r2, r5
 8011b48:	4651      	mov	r1, sl
 8011b4a:	2002      	movs	r0, #2
 8011b4c:	f00d fb24 	bl	801f198 <traceIF_itmPrint>
 8011b50:	4628      	mov	r0, r5
 8011b52:	f00d fade 	bl	801f112 <crs_strlen>
 8011b56:	b283      	uxth	r3, r0
 8011b58:	462a      	mov	r2, r5
 8011b5a:	4651      	mov	r1, sl
 8011b5c:	2002      	movs	r0, #2
 8011b5e:	f00d fb3d 	bl	801f1dc <traceIF_uartPrint>
 8011b62:	e794      	b.n	8011a8e <fRspAnalyze_CREG+0x292>
      uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011b64:	8970      	ldrh	r0, [r6, #10]
 8011b66:	2208      	movs	r2, #8
 8011b68:	89f1      	ldrh	r1, [r6, #14]
 8011b6a:	4440      	add	r0, r8
 8011b6c:	f7fd f842 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011b70:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_cs_location_info_ci = AT_TRUE;
 8011b72:	f04f 0a01 	mov.w	sl, #1
 8011b76:	f889 a01c 	strb.w	sl, [r9, #28]
      p_modem_ctxt->persist.cs_location_info.ci = (uint32_t)ci;
 8011b7a:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
      PRINT_INFO("+CREG URC: ci=%ld =0x%lx", ci, ci)
 8011b7e:	4d1b      	ldr	r5, [pc, #108]	; (8011bec <fRspAnalyze_CREG+0x3f0>)
 8011b80:	4603      	mov	r3, r0
 8011b82:	491c      	ldr	r1, [pc, #112]	; (8011bf4 <fRspAnalyze_CREG+0x3f8>)
 8011b84:	4628      	mov	r0, r5
 8011b86:	f014 f873 	bl	8025c70 <sprintf>
 8011b8a:	4628      	mov	r0, r5
 8011b8c:	f00d fac1 	bl	801f112 <crs_strlen>
 8011b90:	b283      	uxth	r3, r0
 8011b92:	462a      	mov	r2, r5
 8011b94:	4651      	mov	r1, sl
 8011b96:	2002      	movs	r0, #2
 8011b98:	f00d fafe 	bl	801f198 <traceIF_itmPrint>
 8011b9c:	4628      	mov	r0, r5
 8011b9e:	f00d fab8 	bl	801f112 <crs_strlen>
 8011ba2:	b283      	uxth	r3, r0
 8011ba4:	462a      	mov	r2, r5
 8011ba6:	4651      	mov	r1, sl
 8011ba8:	2002      	movs	r0, #2
 8011baa:	f00d fb17 	bl	801f1dc <traceIF_uartPrint>
 8011bae:	e771      	b.n	8011a94 <fRspAnalyze_CREG+0x298>
      PRINT_DBG("+CREG URC: act=%ld",
 8011bb0:	8970      	ldrh	r0, [r6, #10]
 8011bb2:	89f1      	ldrh	r1, [r6, #14]
 8011bb4:	4440      	add	r0, r8
 8011bb6:	f003 f8bd 	bl	8014d34 <ATutil_convertStringToInt>
 8011bba:	4602      	mov	r2, r0
 8011bbc:	4d0b      	ldr	r5, [pc, #44]	; (8011bec <fRspAnalyze_CREG+0x3f0>)
 8011bbe:	490e      	ldr	r1, [pc, #56]	; (8011bf8 <fRspAnalyze_CREG+0x3fc>)
 8011bc0:	4628      	mov	r0, r5
 8011bc2:	f014 f855 	bl	8025c70 <sprintf>
 8011bc6:	4628      	mov	r0, r5
 8011bc8:	f00d faa3 	bl	801f112 <crs_strlen>
 8011bcc:	b283      	uxth	r3, r0
 8011bce:	462a      	mov	r2, r5
 8011bd0:	2102      	movs	r1, #2
 8011bd2:	4608      	mov	r0, r1
 8011bd4:	f00d fae0 	bl	801f198 <traceIF_itmPrint>
 8011bd8:	4628      	mov	r0, r5
 8011bda:	f00d fa9a 	bl	801f112 <crs_strlen>
 8011bde:	b283      	uxth	r3, r0
 8011be0:	462a      	mov	r2, r5
 8011be2:	2102      	movs	r1, #2
 8011be4:	4608      	mov	r0, r1
 8011be6:	f00d faf9 	bl	801f1dc <traceIF_uartPrint>
 8011bea:	e757      	b.n	8011a9c <fRspAnalyze_CREG+0x2a0>
 8011bec:	200048dc 	.word	0x200048dc
 8011bf0:	0802f858 	.word	0x0802f858
 8011bf4:	0802f880 	.word	0x0802f880
 8011bf8:	0802f8a4 	.word	0x0802f8a4

08011bfc <fRspAnalyze_CGREG>:

at_action_rsp_t fRspAnalyze_CGREG(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8011bfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011c00:	4607      	mov	r7, r0
 8011c02:	4689      	mov	r9, r1
 8011c04:	4690      	mov	r8, r2
 8011c06:	461d      	mov	r5, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGREG()")
 8011c08:	4cbf      	ldr	r4, [pc, #764]	; (8011f08 <fRspAnalyze_CGREG+0x30c>)
 8011c0a:	4ec0      	ldr	r6, [pc, #768]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011c0c:	f104 0e20 	add.w	lr, r4, #32
 8011c10:	46a4      	mov	ip, r4
 8011c12:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011c16:	6030      	str	r0, [r6, #0]
 8011c18:	6071      	str	r1, [r6, #4]
 8011c1a:	60b2      	str	r2, [r6, #8]
 8011c1c:	60f3      	str	r3, [r6, #12]
 8011c1e:	4664      	mov	r4, ip
 8011c20:	3610      	adds	r6, #16
 8011c22:	45f4      	cmp	ip, lr
 8011c24:	d1f4      	bne.n	8011c10 <fRspAnalyze_CGREG+0x14>
 8011c26:	cc03      	ldmia	r4!, {r0, r1}
 8011c28:	6030      	str	r0, [r6, #0]
 8011c2a:	6071      	str	r1, [r6, #4]
 8011c2c:	7823      	ldrb	r3, [r4, #0]
 8011c2e:	7233      	strb	r3, [r6, #8]
 8011c30:	4cb6      	ldr	r4, [pc, #728]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011c32:	4620      	mov	r0, r4
 8011c34:	f00d fa6d 	bl	801f112 <crs_strlen>
 8011c38:	b283      	uxth	r3, r0
 8011c3a:	4622      	mov	r2, r4
 8011c3c:	2104      	movs	r1, #4
 8011c3e:	2002      	movs	r0, #2
 8011c40:	f00d faaa 	bl	801f198 <traceIF_itmPrint>
 8011c44:	4620      	mov	r0, r4
 8011c46:	f00d fa64 	bl	801f112 <crs_strlen>
 8011c4a:	b283      	uxth	r3, r0
 8011c4c:	4622      	mov	r2, r4
 8011c4e:	2104      	movs	r1, #4
 8011c50:	2002      	movs	r0, #2
 8011c52:	f00d fac3 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("current cmd = %ld", p_atp_ctxt->current_atcmd.id)
 8011c56:	69fa      	ldr	r2, [r7, #28]
 8011c58:	49ad      	ldr	r1, [pc, #692]	; (8011f10 <fRspAnalyze_CGREG+0x314>)
 8011c5a:	4620      	mov	r0, r4
 8011c5c:	f014 f808 	bl	8025c70 <sprintf>
 8011c60:	4620      	mov	r0, r4
 8011c62:	f00d fa56 	bl	801f112 <crs_strlen>
 8011c66:	b283      	uxth	r3, r0
 8011c68:	4622      	mov	r2, r4
 8011c6a:	2102      	movs	r1, #2
 8011c6c:	4608      	mov	r0, r1
 8011c6e:	f00d fa93 	bl	801f198 <traceIF_itmPrint>
 8011c72:	4620      	mov	r0, r4
 8011c74:	f00d fa4d 	bl	801f112 <crs_strlen>
 8011c78:	b283      	uxth	r3, r0
 8011c7a:	4622      	mov	r2, r4
 8011c7c:	2102      	movs	r1, #2
 8011c7e:	4608      	mov	r0, r1
 8011c80:	f00d faac 	bl	801f1dc <traceIF_uartPrint>
  *  2/ answer to CGREG test command
  *     +CGREG: (list of supported <n>s)
  *  3/ URC:
  *     +CGREG: <stat>[,[<lac>],[<ci>],[<AcT>],[<rac>]]
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CGREG)
 8011c84:	69fb      	ldr	r3, [r7, #28]
 8011c86:	2b18      	cmp	r3, #24
 8011c88:	f040 81db 	bne.w	8012042 <fRspAnalyze_CGREG+0x446>
  {
    /* analyze parameters for +CREG */
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8011c8c:	8b3b      	ldrh	r3, [r7, #24]
 8011c8e:	2b02      	cmp	r3, #2
 8011c90:	d005      	beq.n	8011c9e <fRspAnalyze_CGREG+0xa2>
                                                 element_infos->str_size, 8))
      }
      END_PARAM_LOOP()
    }
    /* analyze parameters for +CGREG */
    else if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8011c92:	2b01      	cmp	r3, #1
 8011c94:	f000 81ab 	beq.w	8011fee <fRspAnalyze_CGREG+0x3f2>
    END_PARAM_LOOP()
  }

  return (retval);

}
 8011c98:	2010      	movs	r0, #16
 8011c9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      START_PARAM_LOOP()
 8011c9e:	2400      	movs	r4, #0
 8011ca0:	462a      	mov	r2, r5
 8011ca2:	4641      	mov	r1, r8
 8011ca4:	4638      	mov	r0, r7
 8011ca6:	f7fa fbcf 	bl	800c448 <atcc_extractElement>
 8011caa:	2801      	cmp	r0, #1
 8011cac:	d000      	beq.n	8011cb0 <fRspAnalyze_CGREG+0xb4>
 8011cae:	2401      	movs	r4, #1
 8011cb0:	89e9      	ldrh	r1, [r5, #14]
 8011cb2:	b341      	cbz	r1, 8011d06 <fRspAnalyze_CGREG+0x10a>
      if (element_infos->param_rank == 2U)
 8011cb4:	892b      	ldrh	r3, [r5, #8]
 8011cb6:	2b02      	cmp	r3, #2
 8011cb8:	d028      	beq.n	8011d0c <fRspAnalyze_CGREG+0x110>
      if (element_infos->param_rank == 3U)
 8011cba:	892b      	ldrh	r3, [r5, #8]
 8011cbc:	2b03      	cmp	r3, #3
 8011cbe:	d042      	beq.n	8011d46 <fRspAnalyze_CGREG+0x14a>
      if (element_infos->param_rank == 4U)
 8011cc0:	892b      	ldrh	r3, [r5, #8]
 8011cc2:	2b04      	cmp	r3, #4
 8011cc4:	d063      	beq.n	8011d8e <fRspAnalyze_CGREG+0x192>
      if (element_infos->param_rank == 5U)
 8011cc6:	892b      	ldrh	r3, [r5, #8]
 8011cc8:	2b05      	cmp	r3, #5
 8011cca:	f000 8082 	beq.w	8011dd2 <fRspAnalyze_CGREG+0x1d6>
      if (element_infos->param_rank == 6U)
 8011cce:	892b      	ldrh	r3, [r5, #8]
 8011cd0:	2b06      	cmp	r3, #6
 8011cd2:	f000 80a0 	beq.w	8011e16 <fRspAnalyze_CGREG+0x21a>
      if (element_infos->param_rank == 7U)
 8011cd6:	892b      	ldrh	r3, [r5, #8]
 8011cd8:	2b07      	cmp	r3, #7
 8011cda:	f000 80ba 	beq.w	8011e52 <fRspAnalyze_CGREG+0x256>
      if (element_infos->param_rank == 8U)
 8011cde:	892b      	ldrh	r3, [r5, #8]
 8011ce0:	2b08      	cmp	r3, #8
 8011ce2:	f000 80d4 	beq.w	8011e8e <fRspAnalyze_CGREG+0x292>
      if (element_infos->param_rank == 9U)
 8011ce6:	892b      	ldrh	r3, [r5, #8]
 8011ce8:	2b09      	cmp	r3, #9
 8011cea:	f000 80ee 	beq.w	8011eca <fRspAnalyze_CGREG+0x2ce>
      if (element_infos->param_rank == 10U)
 8011cee:	892b      	ldrh	r3, [r5, #8]
 8011cf0:	2b0a      	cmp	r3, #10
 8011cf2:	f000 811f 	beq.w	8011f34 <fRspAnalyze_CGREG+0x338>
      if (element_infos->param_rank == 11U)
 8011cf6:	892b      	ldrh	r3, [r5, #8]
 8011cf8:	2b0b      	cmp	r3, #11
 8011cfa:	f000 813a 	beq.w	8011f72 <fRspAnalyze_CGREG+0x376>
      if (element_infos->param_rank == 12U)
 8011cfe:	892b      	ldrh	r3, [r5, #8]
 8011d00:	2b0c      	cmp	r3, #12
 8011d02:	f000 8155 	beq.w	8011fb0 <fRspAnalyze_CGREG+0x3b4>
      END_PARAM_LOOP()
 8011d06:	2c00      	cmp	r4, #0
 8011d08:	d1c6      	bne.n	8011c98 <fRspAnalyze_CGREG+0x9c>
 8011d0a:	e7c9      	b.n	8011ca0 <fRspAnalyze_CGREG+0xa4>
        PRINT_DBG("+CGREG: n=%ld",
 8011d0c:	8968      	ldrh	r0, [r5, #10]
 8011d0e:	4440      	add	r0, r8
 8011d10:	f003 f810 	bl	8014d34 <ATutil_convertStringToInt>
 8011d14:	4602      	mov	r2, r0
 8011d16:	4e7d      	ldr	r6, [pc, #500]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011d18:	497e      	ldr	r1, [pc, #504]	; (8011f14 <fRspAnalyze_CGREG+0x318>)
 8011d1a:	4630      	mov	r0, r6
 8011d1c:	f013 ffa8 	bl	8025c70 <sprintf>
 8011d20:	4630      	mov	r0, r6
 8011d22:	f00d f9f6 	bl	801f112 <crs_strlen>
 8011d26:	b283      	uxth	r3, r0
 8011d28:	4632      	mov	r2, r6
 8011d2a:	2102      	movs	r1, #2
 8011d2c:	4608      	mov	r0, r1
 8011d2e:	f00d fa33 	bl	801f198 <traceIF_itmPrint>
 8011d32:	4630      	mov	r0, r6
 8011d34:	f00d f9ed 	bl	801f112 <crs_strlen>
 8011d38:	b283      	uxth	r3, r0
 8011d3a:	4632      	mov	r2, r6
 8011d3c:	2102      	movs	r1, #2
 8011d3e:	4608      	mov	r0, r1
 8011d40:	f00d fa4c 	bl	801f1dc <traceIF_uartPrint>
 8011d44:	e7b9      	b.n	8011cba <fRspAnalyze_CGREG+0xbe>
        uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011d46:	8968      	ldrh	r0, [r5, #10]
 8011d48:	89e9      	ldrh	r1, [r5, #14]
 8011d4a:	4440      	add	r0, r8
 8011d4c:	f002 fff2 	bl	8014d34 <ATutil_convertStringToInt>
 8011d50:	4682      	mov	sl, r0
        p_modem_ctxt->persist.gprs_network_state = convert_NetworkState(stat, GPRS_NETWORK_TYPE);
 8011d52:	2102      	movs	r1, #2
 8011d54:	f7fc fdb0 	bl	800e8b8 <convert_NetworkState>
 8011d58:	f8a9 003c 	strh.w	r0, [r9, #60]	; 0x3c
        PRINT_DBG("+CGREG: stat=%ld", stat)
 8011d5c:	4e6b      	ldr	r6, [pc, #428]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011d5e:	4652      	mov	r2, sl
 8011d60:	496d      	ldr	r1, [pc, #436]	; (8011f18 <fRspAnalyze_CGREG+0x31c>)
 8011d62:	4630      	mov	r0, r6
 8011d64:	f013 ff84 	bl	8025c70 <sprintf>
 8011d68:	4630      	mov	r0, r6
 8011d6a:	f00d f9d2 	bl	801f112 <crs_strlen>
 8011d6e:	b283      	uxth	r3, r0
 8011d70:	4632      	mov	r2, r6
 8011d72:	2102      	movs	r1, #2
 8011d74:	4608      	mov	r0, r1
 8011d76:	f00d fa0f 	bl	801f198 <traceIF_itmPrint>
 8011d7a:	4630      	mov	r0, r6
 8011d7c:	f00d f9c9 	bl	801f112 <crs_strlen>
 8011d80:	b283      	uxth	r3, r0
 8011d82:	4632      	mov	r2, r6
 8011d84:	2102      	movs	r1, #2
 8011d86:	4608      	mov	r0, r1
 8011d88:	f00d fa28 	bl	801f1dc <traceIF_uartPrint>
 8011d8c:	e798      	b.n	8011cc0 <fRspAnalyze_CGREG+0xc4>
        uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011d8e:	8968      	ldrh	r0, [r5, #10]
 8011d90:	2204      	movs	r2, #4
 8011d92:	89e9      	ldrh	r1, [r5, #14]
 8011d94:	4440      	add	r0, r8
 8011d96:	f7fc ff2d 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011d9a:	4602      	mov	r2, r0
        p_modem_ctxt->persist.gprs_location_info.lac = (uint16_t)lac;
 8011d9c:	f8a9 0038 	strh.w	r0, [r9, #56]	; 0x38
        PRINT_INFO("+CGREG: lac=%ld =0x%lx", lac, lac)
 8011da0:	4e5a      	ldr	r6, [pc, #360]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011da2:	4603      	mov	r3, r0
 8011da4:	495d      	ldr	r1, [pc, #372]	; (8011f1c <fRspAnalyze_CGREG+0x320>)
 8011da6:	4630      	mov	r0, r6
 8011da8:	f013 ff62 	bl	8025c70 <sprintf>
 8011dac:	4630      	mov	r0, r6
 8011dae:	f00d f9b0 	bl	801f112 <crs_strlen>
 8011db2:	b283      	uxth	r3, r0
 8011db4:	4632      	mov	r2, r6
 8011db6:	2101      	movs	r1, #1
 8011db8:	2002      	movs	r0, #2
 8011dba:	f00d f9ed 	bl	801f198 <traceIF_itmPrint>
 8011dbe:	4630      	mov	r0, r6
 8011dc0:	f00d f9a7 	bl	801f112 <crs_strlen>
 8011dc4:	b283      	uxth	r3, r0
 8011dc6:	4632      	mov	r2, r6
 8011dc8:	2101      	movs	r1, #1
 8011dca:	2002      	movs	r0, #2
 8011dcc:	f00d fa06 	bl	801f1dc <traceIF_uartPrint>
 8011dd0:	e779      	b.n	8011cc6 <fRspAnalyze_CGREG+0xca>
        uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011dd2:	8968      	ldrh	r0, [r5, #10]
 8011dd4:	2208      	movs	r2, #8
 8011dd6:	89e9      	ldrh	r1, [r5, #14]
 8011dd8:	4440      	add	r0, r8
 8011dda:	f7fc ff0b 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011dde:	4602      	mov	r2, r0
        p_modem_ctxt->persist.gprs_location_info.ci = (uint32_t)ci;
 8011de0:	f8c9 0034 	str.w	r0, [r9, #52]	; 0x34
        PRINT_INFO("+CGREG: ci=%ld =0x%lx", ci, ci)
 8011de4:	4e49      	ldr	r6, [pc, #292]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011de6:	4603      	mov	r3, r0
 8011de8:	494d      	ldr	r1, [pc, #308]	; (8011f20 <fRspAnalyze_CGREG+0x324>)
 8011dea:	4630      	mov	r0, r6
 8011dec:	f013 ff40 	bl	8025c70 <sprintf>
 8011df0:	4630      	mov	r0, r6
 8011df2:	f00d f98e 	bl	801f112 <crs_strlen>
 8011df6:	b283      	uxth	r3, r0
 8011df8:	4632      	mov	r2, r6
 8011dfa:	2101      	movs	r1, #1
 8011dfc:	2002      	movs	r0, #2
 8011dfe:	f00d f9cb 	bl	801f198 <traceIF_itmPrint>
 8011e02:	4630      	mov	r0, r6
 8011e04:	f00d f985 	bl	801f112 <crs_strlen>
 8011e08:	b283      	uxth	r3, r0
 8011e0a:	4632      	mov	r2, r6
 8011e0c:	2101      	movs	r1, #1
 8011e0e:	2002      	movs	r0, #2
 8011e10:	f00d f9e4 	bl	801f1dc <traceIF_uartPrint>
 8011e14:	e75b      	b.n	8011cce <fRspAnalyze_CGREG+0xd2>
        PRINT_DBG("+CGREG: act=%ld",
 8011e16:	8968      	ldrh	r0, [r5, #10]
 8011e18:	89e9      	ldrh	r1, [r5, #14]
 8011e1a:	4440      	add	r0, r8
 8011e1c:	f002 ff8a 	bl	8014d34 <ATutil_convertStringToInt>
 8011e20:	4602      	mov	r2, r0
 8011e22:	4e3a      	ldr	r6, [pc, #232]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011e24:	493f      	ldr	r1, [pc, #252]	; (8011f24 <fRspAnalyze_CGREG+0x328>)
 8011e26:	4630      	mov	r0, r6
 8011e28:	f013 ff22 	bl	8025c70 <sprintf>
 8011e2c:	4630      	mov	r0, r6
 8011e2e:	f00d f970 	bl	801f112 <crs_strlen>
 8011e32:	b283      	uxth	r3, r0
 8011e34:	4632      	mov	r2, r6
 8011e36:	2102      	movs	r1, #2
 8011e38:	4608      	mov	r0, r1
 8011e3a:	f00d f9ad 	bl	801f198 <traceIF_itmPrint>
 8011e3e:	4630      	mov	r0, r6
 8011e40:	f00d f967 	bl	801f112 <crs_strlen>
 8011e44:	b283      	uxth	r3, r0
 8011e46:	4632      	mov	r2, r6
 8011e48:	2102      	movs	r1, #2
 8011e4a:	4608      	mov	r0, r1
 8011e4c:	f00d f9c6 	bl	801f1dc <traceIF_uartPrint>
 8011e50:	e741      	b.n	8011cd6 <fRspAnalyze_CGREG+0xda>
        PRINT_DBG("+CGREG: rac=%ld",
 8011e52:	8968      	ldrh	r0, [r5, #10]
 8011e54:	89e9      	ldrh	r1, [r5, #14]
 8011e56:	4440      	add	r0, r8
 8011e58:	f002 ff6c 	bl	8014d34 <ATutil_convertStringToInt>
 8011e5c:	4602      	mov	r2, r0
 8011e5e:	4e2b      	ldr	r6, [pc, #172]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011e60:	4931      	ldr	r1, [pc, #196]	; (8011f28 <fRspAnalyze_CGREG+0x32c>)
 8011e62:	4630      	mov	r0, r6
 8011e64:	f013 ff04 	bl	8025c70 <sprintf>
 8011e68:	4630      	mov	r0, r6
 8011e6a:	f00d f952 	bl	801f112 <crs_strlen>
 8011e6e:	b283      	uxth	r3, r0
 8011e70:	4632      	mov	r2, r6
 8011e72:	2102      	movs	r1, #2
 8011e74:	4608      	mov	r0, r1
 8011e76:	f00d f98f 	bl	801f198 <traceIF_itmPrint>
 8011e7a:	4630      	mov	r0, r6
 8011e7c:	f00d f949 	bl	801f112 <crs_strlen>
 8011e80:	b283      	uxth	r3, r0
 8011e82:	4632      	mov	r2, r6
 8011e84:	2102      	movs	r1, #2
 8011e86:	4608      	mov	r0, r1
 8011e88:	f00d f9a8 	bl	801f1dc <traceIF_uartPrint>
 8011e8c:	e727      	b.n	8011cde <fRspAnalyze_CGREG+0xe2>
        PRINT_DBG("+CGREG: cause_type=%ld",
 8011e8e:	8968      	ldrh	r0, [r5, #10]
 8011e90:	89e9      	ldrh	r1, [r5, #14]
 8011e92:	4440      	add	r0, r8
 8011e94:	f002 ff4e 	bl	8014d34 <ATutil_convertStringToInt>
 8011e98:	4602      	mov	r2, r0
 8011e9a:	4e1c      	ldr	r6, [pc, #112]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011e9c:	4923      	ldr	r1, [pc, #140]	; (8011f2c <fRspAnalyze_CGREG+0x330>)
 8011e9e:	4630      	mov	r0, r6
 8011ea0:	f013 fee6 	bl	8025c70 <sprintf>
 8011ea4:	4630      	mov	r0, r6
 8011ea6:	f00d f934 	bl	801f112 <crs_strlen>
 8011eaa:	b283      	uxth	r3, r0
 8011eac:	4632      	mov	r2, r6
 8011eae:	2102      	movs	r1, #2
 8011eb0:	4608      	mov	r0, r1
 8011eb2:	f00d f971 	bl	801f198 <traceIF_itmPrint>
 8011eb6:	4630      	mov	r0, r6
 8011eb8:	f00d f92b 	bl	801f112 <crs_strlen>
 8011ebc:	b283      	uxth	r3, r0
 8011ebe:	4632      	mov	r2, r6
 8011ec0:	2102      	movs	r1, #2
 8011ec2:	4608      	mov	r0, r1
 8011ec4:	f00d f98a 	bl	801f1dc <traceIF_uartPrint>
 8011ec8:	e70d      	b.n	8011ce6 <fRspAnalyze_CGREG+0xea>
        PRINT_DBG("+CGREG: reject_cause=%ld",
 8011eca:	8968      	ldrh	r0, [r5, #10]
 8011ecc:	89e9      	ldrh	r1, [r5, #14]
 8011ece:	4440      	add	r0, r8
 8011ed0:	f002 ff30 	bl	8014d34 <ATutil_convertStringToInt>
 8011ed4:	4602      	mov	r2, r0
 8011ed6:	4e0d      	ldr	r6, [pc, #52]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011ed8:	4915      	ldr	r1, [pc, #84]	; (8011f30 <fRspAnalyze_CGREG+0x334>)
 8011eda:	4630      	mov	r0, r6
 8011edc:	f013 fec8 	bl	8025c70 <sprintf>
 8011ee0:	4630      	mov	r0, r6
 8011ee2:	f00d f916 	bl	801f112 <crs_strlen>
 8011ee6:	b283      	uxth	r3, r0
 8011ee8:	4632      	mov	r2, r6
 8011eea:	2102      	movs	r1, #2
 8011eec:	4608      	mov	r0, r1
 8011eee:	f00d f953 	bl	801f198 <traceIF_itmPrint>
 8011ef2:	4630      	mov	r0, r6
 8011ef4:	f00d f90d 	bl	801f112 <crs_strlen>
 8011ef8:	b283      	uxth	r3, r0
 8011efa:	4632      	mov	r2, r6
 8011efc:	2102      	movs	r1, #2
 8011efe:	4608      	mov	r0, r1
 8011f00:	f00d f96c 	bl	801f1dc <traceIF_uartPrint>
 8011f04:	e6f3      	b.n	8011cee <fRspAnalyze_CGREG+0xf2>
 8011f06:	bf00      	nop
 8011f08:	0802f8c4 	.word	0x0802f8c4
 8011f0c:	200048dc 	.word	0x200048dc
 8011f10:	0802f754 	.word	0x0802f754
 8011f14:	0802f8f0 	.word	0x0802f8f0
 8011f18:	0802f90c 	.word	0x0802f90c
 8011f1c:	0802f928 	.word	0x0802f928
 8011f20:	0802f94c 	.word	0x0802f94c
 8011f24:	0802f970 	.word	0x0802f970
 8011f28:	0802f98c 	.word	0x0802f98c
 8011f2c:	0802f9a8 	.word	0x0802f9a8
 8011f30:	0802f9cc 	.word	0x0802f9cc
        PRINT_INFO("+CGREG: active_time= 0x%lx)",
 8011f34:	8968      	ldrh	r0, [r5, #10]
 8011f36:	2208      	movs	r2, #8
 8011f38:	89e9      	ldrh	r1, [r5, #14]
 8011f3a:	4440      	add	r0, r8
 8011f3c:	f7fc fe69 	bl	800ec12 <extract_bin_value_from_quotes>
 8011f40:	4602      	mov	r2, r0
 8011f42:	4ec0      	ldr	r6, [pc, #768]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011f44:	49c0      	ldr	r1, [pc, #768]	; (8012248 <fRspAnalyze_CGREG+0x64c>)
 8011f46:	4630      	mov	r0, r6
 8011f48:	f013 fe92 	bl	8025c70 <sprintf>
 8011f4c:	4630      	mov	r0, r6
 8011f4e:	f00d f8e0 	bl	801f112 <crs_strlen>
 8011f52:	b283      	uxth	r3, r0
 8011f54:	4632      	mov	r2, r6
 8011f56:	2101      	movs	r1, #1
 8011f58:	2002      	movs	r0, #2
 8011f5a:	f00d f91d 	bl	801f198 <traceIF_itmPrint>
 8011f5e:	4630      	mov	r0, r6
 8011f60:	f00d f8d7 	bl	801f112 <crs_strlen>
 8011f64:	b283      	uxth	r3, r0
 8011f66:	4632      	mov	r2, r6
 8011f68:	2101      	movs	r1, #1
 8011f6a:	2002      	movs	r0, #2
 8011f6c:	f00d f936 	bl	801f1dc <traceIF_uartPrint>
 8011f70:	e6c1      	b.n	8011cf6 <fRspAnalyze_CGREG+0xfa>
        PRINT_INFO("+CGREG: periodic_rau= 0x%lx",
 8011f72:	8968      	ldrh	r0, [r5, #10]
 8011f74:	2208      	movs	r2, #8
 8011f76:	89e9      	ldrh	r1, [r5, #14]
 8011f78:	4440      	add	r0, r8
 8011f7a:	f7fc fe4a 	bl	800ec12 <extract_bin_value_from_quotes>
 8011f7e:	4602      	mov	r2, r0
 8011f80:	4eb0      	ldr	r6, [pc, #704]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011f82:	49b2      	ldr	r1, [pc, #712]	; (801224c <fRspAnalyze_CGREG+0x650>)
 8011f84:	4630      	mov	r0, r6
 8011f86:	f013 fe73 	bl	8025c70 <sprintf>
 8011f8a:	4630      	mov	r0, r6
 8011f8c:	f00d f8c1 	bl	801f112 <crs_strlen>
 8011f90:	b283      	uxth	r3, r0
 8011f92:	4632      	mov	r2, r6
 8011f94:	2101      	movs	r1, #1
 8011f96:	2002      	movs	r0, #2
 8011f98:	f00d f8fe 	bl	801f198 <traceIF_itmPrint>
 8011f9c:	4630      	mov	r0, r6
 8011f9e:	f00d f8b8 	bl	801f112 <crs_strlen>
 8011fa2:	b283      	uxth	r3, r0
 8011fa4:	4632      	mov	r2, r6
 8011fa6:	2101      	movs	r1, #1
 8011fa8:	2002      	movs	r0, #2
 8011faa:	f00d f917 	bl	801f1dc <traceIF_uartPrint>
 8011fae:	e6a6      	b.n	8011cfe <fRspAnalyze_CGREG+0x102>
        PRINT_INFO("+CGREG: gprs_ready_timer= 0x%lx",
 8011fb0:	8968      	ldrh	r0, [r5, #10]
 8011fb2:	2208      	movs	r2, #8
 8011fb4:	89e9      	ldrh	r1, [r5, #14]
 8011fb6:	4440      	add	r0, r8
 8011fb8:	f7fc fe2b 	bl	800ec12 <extract_bin_value_from_quotes>
 8011fbc:	4602      	mov	r2, r0
 8011fbe:	4ea1      	ldr	r6, [pc, #644]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011fc0:	49a3      	ldr	r1, [pc, #652]	; (8012250 <fRspAnalyze_CGREG+0x654>)
 8011fc2:	4630      	mov	r0, r6
 8011fc4:	f013 fe54 	bl	8025c70 <sprintf>
 8011fc8:	4630      	mov	r0, r6
 8011fca:	f00d f8a2 	bl	801f112 <crs_strlen>
 8011fce:	b283      	uxth	r3, r0
 8011fd0:	4632      	mov	r2, r6
 8011fd2:	2101      	movs	r1, #1
 8011fd4:	2002      	movs	r0, #2
 8011fd6:	f00d f8df 	bl	801f198 <traceIF_itmPrint>
 8011fda:	4630      	mov	r0, r6
 8011fdc:	f00d f899 	bl	801f112 <crs_strlen>
 8011fe0:	b283      	uxth	r3, r0
 8011fe2:	4632      	mov	r2, r6
 8011fe4:	2101      	movs	r1, #1
 8011fe6:	2002      	movs	r0, #2
 8011fe8:	f00d f8f8 	bl	801f1dc <traceIF_uartPrint>
 8011fec:	e68b      	b.n	8011d06 <fRspAnalyze_CGREG+0x10a>
      PRINT_DBG("+CGREG for test cmd NOT IMPLEMENTED")
 8011fee:	4d99      	ldr	r5, [pc, #612]	; (8012254 <fRspAnalyze_CGREG+0x658>)
 8011ff0:	4c94      	ldr	r4, [pc, #592]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011ff2:	f105 0720 	add.w	r7, r5, #32
 8011ff6:	462e      	mov	r6, r5
 8011ff8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8011ffa:	6020      	str	r0, [r4, #0]
 8011ffc:	6061      	str	r1, [r4, #4]
 8011ffe:	60a2      	str	r2, [r4, #8]
 8012000:	60e3      	str	r3, [r4, #12]
 8012002:	4635      	mov	r5, r6
 8012004:	3410      	adds	r4, #16
 8012006:	42be      	cmp	r6, r7
 8012008:	d1f5      	bne.n	8011ff6 <fRspAnalyze_CGREG+0x3fa>
 801200a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801200c:	6020      	str	r0, [r4, #0]
 801200e:	6061      	str	r1, [r4, #4]
 8012010:	60a2      	str	r2, [r4, #8]
 8012012:	882a      	ldrh	r2, [r5, #0]
 8012014:	78ab      	ldrb	r3, [r5, #2]
 8012016:	81a2      	strh	r2, [r4, #12]
 8012018:	73a3      	strb	r3, [r4, #14]
 801201a:	4c8a      	ldr	r4, [pc, #552]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 801201c:	4620      	mov	r0, r4
 801201e:	f00d f878 	bl	801f112 <crs_strlen>
 8012022:	b283      	uxth	r3, r0
 8012024:	4622      	mov	r2, r4
 8012026:	2102      	movs	r1, #2
 8012028:	4608      	mov	r0, r1
 801202a:	f00d f8b5 	bl	801f198 <traceIF_itmPrint>
 801202e:	4620      	mov	r0, r4
 8012030:	f00d f86f 	bl	801f112 <crs_strlen>
 8012034:	b283      	uxth	r3, r0
 8012036:	4622      	mov	r2, r4
 8012038:	2102      	movs	r1, #2
 801203a:	4608      	mov	r0, r1
 801203c:	f00d f8ce 	bl	801f1dc <traceIF_uartPrint>
 8012040:	e62a      	b.n	8011c98 <fRspAnalyze_CGREG+0x9c>
    START_PARAM_LOOP()
 8012042:	2400      	movs	r4, #0
 8012044:	462a      	mov	r2, r5
 8012046:	4641      	mov	r1, r8
 8012048:	4638      	mov	r0, r7
 801204a:	f7fa f9fd 	bl	800c448 <atcc_extractElement>
 801204e:	2801      	cmp	r0, #1
 8012050:	d000      	beq.n	8012054 <fRspAnalyze_CGREG+0x458>
 8012052:	2401      	movs	r4, #1
 8012054:	89e9      	ldrh	r1, [r5, #14]
 8012056:	b321      	cbz	r1, 80120a2 <fRspAnalyze_CGREG+0x4a6>
    if (element_infos->param_rank == 2U)
 8012058:	892b      	ldrh	r3, [r5, #8]
 801205a:	2b02      	cmp	r3, #2
 801205c:	d025      	beq.n	80120aa <fRspAnalyze_CGREG+0x4ae>
    if (element_infos->param_rank == 3U)
 801205e:	892b      	ldrh	r3, [r5, #8]
 8012060:	2b03      	cmp	r3, #3
 8012062:	d048      	beq.n	80120f6 <fRspAnalyze_CGREG+0x4fa>
    if (element_infos->param_rank == 4U)
 8012064:	892b      	ldrh	r3, [r5, #8]
 8012066:	2b04      	cmp	r3, #4
 8012068:	d06b      	beq.n	8012142 <fRspAnalyze_CGREG+0x546>
    if (element_infos->param_rank == 5U)
 801206a:	892b      	ldrh	r3, [r5, #8]
 801206c:	2b05      	cmp	r3, #5
 801206e:	f000 808e 	beq.w	801218e <fRspAnalyze_CGREG+0x592>
    if (element_infos->param_rank == 6U)
 8012072:	892b      	ldrh	r3, [r5, #8]
 8012074:	2b06      	cmp	r3, #6
 8012076:	f000 80a8 	beq.w	80121ca <fRspAnalyze_CGREG+0x5ce>
    if (element_infos->param_rank == 7U)
 801207a:	892b      	ldrh	r3, [r5, #8]
 801207c:	2b07      	cmp	r3, #7
 801207e:	f000 80c3 	beq.w	8012208 <fRspAnalyze_CGREG+0x60c>
    if (element_infos->param_rank == 8U)
 8012082:	892b      	ldrh	r3, [r5, #8]
 8012084:	2b08      	cmp	r3, #8
 8012086:	f000 80f3 	beq.w	8012270 <fRspAnalyze_CGREG+0x674>
    if (element_infos->param_rank == 9U)
 801208a:	892b      	ldrh	r3, [r5, #8]
 801208c:	2b09      	cmp	r3, #9
 801208e:	f000 810d 	beq.w	80122ac <fRspAnalyze_CGREG+0x6b0>
    if (element_infos->param_rank == 10U)
 8012092:	892b      	ldrh	r3, [r5, #8]
 8012094:	2b0a      	cmp	r3, #10
 8012096:	f000 8128 	beq.w	80122ea <fRspAnalyze_CGREG+0x6ee>
    if (element_infos->param_rank == 11U)
 801209a:	892b      	ldrh	r3, [r5, #8]
 801209c:	2b0b      	cmp	r3, #11
 801209e:	f000 8143 	beq.w	8012328 <fRspAnalyze_CGREG+0x72c>
    END_PARAM_LOOP()
 80120a2:	2c00      	cmp	r4, #0
 80120a4:	f47f adf8 	bne.w	8011c98 <fRspAnalyze_CGREG+0x9c>
 80120a8:	e7cc      	b.n	8012044 <fRspAnalyze_CGREG+0x448>
      uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80120aa:	8968      	ldrh	r0, [r5, #10]
 80120ac:	4440      	add	r0, r8
 80120ae:	f002 fe41 	bl	8014d34 <ATutil_convertStringToInt>
 80120b2:	4682      	mov	sl, r0
      p_modem_ctxt->persist.urc_avail_gprs_network_registration = AT_TRUE;
 80120b4:	2301      	movs	r3, #1
 80120b6:	f889 3017 	strb.w	r3, [r9, #23]
      p_modem_ctxt->persist.gprs_network_state = convert_NetworkState(stat, GPRS_NETWORK_TYPE);
 80120ba:	2102      	movs	r1, #2
 80120bc:	f7fc fbfc 	bl	800e8b8 <convert_NetworkState>
 80120c0:	f8a9 003c 	strh.w	r0, [r9, #60]	; 0x3c
      PRINT_DBG("+CGREG URC: stat=%ld", stat)
 80120c4:	4e5f      	ldr	r6, [pc, #380]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 80120c6:	4652      	mov	r2, sl
 80120c8:	4963      	ldr	r1, [pc, #396]	; (8012258 <fRspAnalyze_CGREG+0x65c>)
 80120ca:	4630      	mov	r0, r6
 80120cc:	f013 fdd0 	bl	8025c70 <sprintf>
 80120d0:	4630      	mov	r0, r6
 80120d2:	f00d f81e 	bl	801f112 <crs_strlen>
 80120d6:	b283      	uxth	r3, r0
 80120d8:	4632      	mov	r2, r6
 80120da:	2102      	movs	r1, #2
 80120dc:	4608      	mov	r0, r1
 80120de:	f00d f85b 	bl	801f198 <traceIF_itmPrint>
 80120e2:	4630      	mov	r0, r6
 80120e4:	f00d f815 	bl	801f112 <crs_strlen>
 80120e8:	b283      	uxth	r3, r0
 80120ea:	4632      	mov	r2, r6
 80120ec:	2102      	movs	r1, #2
 80120ee:	4608      	mov	r0, r1
 80120f0:	f00d f874 	bl	801f1dc <traceIF_uartPrint>
 80120f4:	e7b3      	b.n	801205e <fRspAnalyze_CGREG+0x462>
      uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 80120f6:	8968      	ldrh	r0, [r5, #10]
 80120f8:	2204      	movs	r2, #4
 80120fa:	89e9      	ldrh	r1, [r5, #14]
 80120fc:	4440      	add	r0, r8
 80120fe:	f7fc fd79 	bl	800ebf4 <extract_hex_value_from_quotes>
 8012102:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_gprs_location_info_lac = AT_TRUE;
 8012104:	f04f 0a01 	mov.w	sl, #1
 8012108:	f889 a018 	strb.w	sl, [r9, #24]
      p_modem_ctxt->persist.gprs_location_info.lac = (uint16_t)lac;
 801210c:	f8a9 0038 	strh.w	r0, [r9, #56]	; 0x38
      PRINT_INFO("+CGREG URC: lac=%ld =0x%lx", lac, lac)
 8012110:	4e4c      	ldr	r6, [pc, #304]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8012112:	4603      	mov	r3, r0
 8012114:	4951      	ldr	r1, [pc, #324]	; (801225c <fRspAnalyze_CGREG+0x660>)
 8012116:	4630      	mov	r0, r6
 8012118:	f013 fdaa 	bl	8025c70 <sprintf>
 801211c:	4630      	mov	r0, r6
 801211e:	f00c fff8 	bl	801f112 <crs_strlen>
 8012122:	b283      	uxth	r3, r0
 8012124:	4632      	mov	r2, r6
 8012126:	4651      	mov	r1, sl
 8012128:	2002      	movs	r0, #2
 801212a:	f00d f835 	bl	801f198 <traceIF_itmPrint>
 801212e:	4630      	mov	r0, r6
 8012130:	f00c ffef 	bl	801f112 <crs_strlen>
 8012134:	b283      	uxth	r3, r0
 8012136:	4632      	mov	r2, r6
 8012138:	4651      	mov	r1, sl
 801213a:	2002      	movs	r0, #2
 801213c:	f00d f84e 	bl	801f1dc <traceIF_uartPrint>
 8012140:	e790      	b.n	8012064 <fRspAnalyze_CGREG+0x468>
      uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8012142:	8968      	ldrh	r0, [r5, #10]
 8012144:	2208      	movs	r2, #8
 8012146:	89e9      	ldrh	r1, [r5, #14]
 8012148:	4440      	add	r0, r8
 801214a:	f7fc fd53 	bl	800ebf4 <extract_hex_value_from_quotes>
 801214e:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_gprs_location_info_ci = AT_TRUE;
 8012150:	f04f 0a01 	mov.w	sl, #1
 8012154:	f889 a019 	strb.w	sl, [r9, #25]
      p_modem_ctxt->persist.gprs_location_info.ci = (uint32_t)ci;
 8012158:	f8c9 0034 	str.w	r0, [r9, #52]	; 0x34
      PRINT_INFO("+CGREG URC: ci=%ld =0x%lx", ci, ci)
 801215c:	4e39      	ldr	r6, [pc, #228]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 801215e:	4603      	mov	r3, r0
 8012160:	493f      	ldr	r1, [pc, #252]	; (8012260 <fRspAnalyze_CGREG+0x664>)
 8012162:	4630      	mov	r0, r6
 8012164:	f013 fd84 	bl	8025c70 <sprintf>
 8012168:	4630      	mov	r0, r6
 801216a:	f00c ffd2 	bl	801f112 <crs_strlen>
 801216e:	b283      	uxth	r3, r0
 8012170:	4632      	mov	r2, r6
 8012172:	4651      	mov	r1, sl
 8012174:	2002      	movs	r0, #2
 8012176:	f00d f80f 	bl	801f198 <traceIF_itmPrint>
 801217a:	4630      	mov	r0, r6
 801217c:	f00c ffc9 	bl	801f112 <crs_strlen>
 8012180:	b283      	uxth	r3, r0
 8012182:	4632      	mov	r2, r6
 8012184:	4651      	mov	r1, sl
 8012186:	2002      	movs	r0, #2
 8012188:	f00d f828 	bl	801f1dc <traceIF_uartPrint>
 801218c:	e76d      	b.n	801206a <fRspAnalyze_CGREG+0x46e>
      PRINT_DBG("+CGREG URC: act=%ld",
 801218e:	8968      	ldrh	r0, [r5, #10]
 8012190:	89e9      	ldrh	r1, [r5, #14]
 8012192:	4440      	add	r0, r8
 8012194:	f002 fdce 	bl	8014d34 <ATutil_convertStringToInt>
 8012198:	4602      	mov	r2, r0
 801219a:	4e2a      	ldr	r6, [pc, #168]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 801219c:	4931      	ldr	r1, [pc, #196]	; (8012264 <fRspAnalyze_CGREG+0x668>)
 801219e:	4630      	mov	r0, r6
 80121a0:	f013 fd66 	bl	8025c70 <sprintf>
 80121a4:	4630      	mov	r0, r6
 80121a6:	f00c ffb4 	bl	801f112 <crs_strlen>
 80121aa:	b283      	uxth	r3, r0
 80121ac:	4632      	mov	r2, r6
 80121ae:	2102      	movs	r1, #2
 80121b0:	4608      	mov	r0, r1
 80121b2:	f00c fff1 	bl	801f198 <traceIF_itmPrint>
 80121b6:	4630      	mov	r0, r6
 80121b8:	f00c ffab 	bl	801f112 <crs_strlen>
 80121bc:	b283      	uxth	r3, r0
 80121be:	4632      	mov	r2, r6
 80121c0:	2102      	movs	r1, #2
 80121c2:	4608      	mov	r0, r1
 80121c4:	f00d f80a 	bl	801f1dc <traceIF_uartPrint>
 80121c8:	e753      	b.n	8012072 <fRspAnalyze_CGREG+0x476>
      PRINT_DBG("+CGREG URC: rac=%ld",
 80121ca:	8968      	ldrh	r0, [r5, #10]
 80121cc:	2202      	movs	r2, #2
 80121ce:	89e9      	ldrh	r1, [r5, #14]
 80121d0:	4440      	add	r0, r8
 80121d2:	f7fc fd0f 	bl	800ebf4 <extract_hex_value_from_quotes>
 80121d6:	4602      	mov	r2, r0
 80121d8:	4e1a      	ldr	r6, [pc, #104]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 80121da:	4923      	ldr	r1, [pc, #140]	; (8012268 <fRspAnalyze_CGREG+0x66c>)
 80121dc:	4630      	mov	r0, r6
 80121de:	f013 fd47 	bl	8025c70 <sprintf>
 80121e2:	4630      	mov	r0, r6
 80121e4:	f00c ff95 	bl	801f112 <crs_strlen>
 80121e8:	b283      	uxth	r3, r0
 80121ea:	4632      	mov	r2, r6
 80121ec:	2102      	movs	r1, #2
 80121ee:	4608      	mov	r0, r1
 80121f0:	f00c ffd2 	bl	801f198 <traceIF_itmPrint>
 80121f4:	4630      	mov	r0, r6
 80121f6:	f00c ff8c 	bl	801f112 <crs_strlen>
 80121fa:	b283      	uxth	r3, r0
 80121fc:	4632      	mov	r2, r6
 80121fe:	2102      	movs	r1, #2
 8012200:	4608      	mov	r0, r1
 8012202:	f00c ffeb 	bl	801f1dc <traceIF_uartPrint>
 8012206:	e738      	b.n	801207a <fRspAnalyze_CGREG+0x47e>
      PRINT_DBG("+CGREG URC: cause_type=%ld",
 8012208:	8968      	ldrh	r0, [r5, #10]
 801220a:	89e9      	ldrh	r1, [r5, #14]
 801220c:	4440      	add	r0, r8
 801220e:	f002 fd91 	bl	8014d34 <ATutil_convertStringToInt>
 8012212:	4602      	mov	r2, r0
 8012214:	4e0b      	ldr	r6, [pc, #44]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8012216:	4915      	ldr	r1, [pc, #84]	; (801226c <fRspAnalyze_CGREG+0x670>)
 8012218:	4630      	mov	r0, r6
 801221a:	f013 fd29 	bl	8025c70 <sprintf>
 801221e:	4630      	mov	r0, r6
 8012220:	f00c ff77 	bl	801f112 <crs_strlen>
 8012224:	b283      	uxth	r3, r0
 8012226:	4632      	mov	r2, r6
 8012228:	2102      	movs	r1, #2
 801222a:	4608      	mov	r0, r1
 801222c:	f00c ffb4 	bl	801f198 <traceIF_itmPrint>
 8012230:	4630      	mov	r0, r6
 8012232:	f00c ff6e 	bl	801f112 <crs_strlen>
 8012236:	b283      	uxth	r3, r0
 8012238:	4632      	mov	r2, r6
 801223a:	2102      	movs	r1, #2
 801223c:	4608      	mov	r0, r1
 801223e:	f00c ffcd 	bl	801f1dc <traceIF_uartPrint>
 8012242:	e71e      	b.n	8012082 <fRspAnalyze_CGREG+0x486>
 8012244:	200048dc 	.word	0x200048dc
 8012248:	0802f9f0 	.word	0x0802f9f0
 801224c:	0802fa18 	.word	0x0802fa18
 8012250:	0802fa40 	.word	0x0802fa40
 8012254:	0802fa6c 	.word	0x0802fa6c
 8012258:	0802fa9c 	.word	0x0802fa9c
 801225c:	0802fabc 	.word	0x0802fabc
 8012260:	0802fae4 	.word	0x0802fae4
 8012264:	0802fb0c 	.word	0x0802fb0c
 8012268:	0802fb2c 	.word	0x0802fb2c
 801226c:	0802fb4c 	.word	0x0802fb4c
      PRINT_DBG("+CGREG URC: reject_cause=%ld",
 8012270:	8968      	ldrh	r0, [r5, #10]
 8012272:	89e9      	ldrh	r1, [r5, #14]
 8012274:	4440      	add	r0, r8
 8012276:	f002 fd5d 	bl	8014d34 <ATutil_convertStringToInt>
 801227a:	4602      	mov	r2, r0
 801227c:	4e3a      	ldr	r6, [pc, #232]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 801227e:	493b      	ldr	r1, [pc, #236]	; (801236c <fRspAnalyze_CGREG+0x770>)
 8012280:	4630      	mov	r0, r6
 8012282:	f013 fcf5 	bl	8025c70 <sprintf>
 8012286:	4630      	mov	r0, r6
 8012288:	f00c ff43 	bl	801f112 <crs_strlen>
 801228c:	b283      	uxth	r3, r0
 801228e:	4632      	mov	r2, r6
 8012290:	2102      	movs	r1, #2
 8012292:	4608      	mov	r0, r1
 8012294:	f00c ff80 	bl	801f198 <traceIF_itmPrint>
 8012298:	4630      	mov	r0, r6
 801229a:	f00c ff3a 	bl	801f112 <crs_strlen>
 801229e:	b283      	uxth	r3, r0
 80122a0:	4632      	mov	r2, r6
 80122a2:	2102      	movs	r1, #2
 80122a4:	4608      	mov	r0, r1
 80122a6:	f00c ff99 	bl	801f1dc <traceIF_uartPrint>
 80122aa:	e6ee      	b.n	801208a <fRspAnalyze_CGREG+0x48e>
      PRINT_INFO("+CGREG URC: active_time= 0x%lx",
 80122ac:	8968      	ldrh	r0, [r5, #10]
 80122ae:	2208      	movs	r2, #8
 80122b0:	89e9      	ldrh	r1, [r5, #14]
 80122b2:	4440      	add	r0, r8
 80122b4:	f7fc fcad 	bl	800ec12 <extract_bin_value_from_quotes>
 80122b8:	4602      	mov	r2, r0
 80122ba:	4e2b      	ldr	r6, [pc, #172]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 80122bc:	492c      	ldr	r1, [pc, #176]	; (8012370 <fRspAnalyze_CGREG+0x774>)
 80122be:	4630      	mov	r0, r6
 80122c0:	f013 fcd6 	bl	8025c70 <sprintf>
 80122c4:	4630      	mov	r0, r6
 80122c6:	f00c ff24 	bl	801f112 <crs_strlen>
 80122ca:	b283      	uxth	r3, r0
 80122cc:	4632      	mov	r2, r6
 80122ce:	2101      	movs	r1, #1
 80122d0:	2002      	movs	r0, #2
 80122d2:	f00c ff61 	bl	801f198 <traceIF_itmPrint>
 80122d6:	4630      	mov	r0, r6
 80122d8:	f00c ff1b 	bl	801f112 <crs_strlen>
 80122dc:	b283      	uxth	r3, r0
 80122de:	4632      	mov	r2, r6
 80122e0:	2101      	movs	r1, #1
 80122e2:	2002      	movs	r0, #2
 80122e4:	f00c ff7a 	bl	801f1dc <traceIF_uartPrint>
 80122e8:	e6d3      	b.n	8012092 <fRspAnalyze_CGREG+0x496>
      PRINT_INFO("+CGREG URC: periodic_rau= 0x%lx",
 80122ea:	8968      	ldrh	r0, [r5, #10]
 80122ec:	2208      	movs	r2, #8
 80122ee:	89e9      	ldrh	r1, [r5, #14]
 80122f0:	4440      	add	r0, r8
 80122f2:	f7fc fc8e 	bl	800ec12 <extract_bin_value_from_quotes>
 80122f6:	4602      	mov	r2, r0
 80122f8:	4e1b      	ldr	r6, [pc, #108]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 80122fa:	491e      	ldr	r1, [pc, #120]	; (8012374 <fRspAnalyze_CGREG+0x778>)
 80122fc:	4630      	mov	r0, r6
 80122fe:	f013 fcb7 	bl	8025c70 <sprintf>
 8012302:	4630      	mov	r0, r6
 8012304:	f00c ff05 	bl	801f112 <crs_strlen>
 8012308:	b283      	uxth	r3, r0
 801230a:	4632      	mov	r2, r6
 801230c:	2101      	movs	r1, #1
 801230e:	2002      	movs	r0, #2
 8012310:	f00c ff42 	bl	801f198 <traceIF_itmPrint>
 8012314:	4630      	mov	r0, r6
 8012316:	f00c fefc 	bl	801f112 <crs_strlen>
 801231a:	b283      	uxth	r3, r0
 801231c:	4632      	mov	r2, r6
 801231e:	2101      	movs	r1, #1
 8012320:	2002      	movs	r0, #2
 8012322:	f00c ff5b 	bl	801f1dc <traceIF_uartPrint>
 8012326:	e6b8      	b.n	801209a <fRspAnalyze_CGREG+0x49e>
      PRINT_INFO("+CGREG URC: gprs_ready_timer= 0x%lx",
 8012328:	8968      	ldrh	r0, [r5, #10]
 801232a:	2208      	movs	r2, #8
 801232c:	89e9      	ldrh	r1, [r5, #14]
 801232e:	4440      	add	r0, r8
 8012330:	f7fc fc6f 	bl	800ec12 <extract_bin_value_from_quotes>
 8012334:	4602      	mov	r2, r0
 8012336:	4e0c      	ldr	r6, [pc, #48]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 8012338:	490f      	ldr	r1, [pc, #60]	; (8012378 <fRspAnalyze_CGREG+0x77c>)
 801233a:	4630      	mov	r0, r6
 801233c:	f013 fc98 	bl	8025c70 <sprintf>
 8012340:	4630      	mov	r0, r6
 8012342:	f00c fee6 	bl	801f112 <crs_strlen>
 8012346:	b283      	uxth	r3, r0
 8012348:	4632      	mov	r2, r6
 801234a:	2101      	movs	r1, #1
 801234c:	2002      	movs	r0, #2
 801234e:	f00c ff23 	bl	801f198 <traceIF_itmPrint>
 8012352:	4630      	mov	r0, r6
 8012354:	f00c fedd 	bl	801f112 <crs_strlen>
 8012358:	b283      	uxth	r3, r0
 801235a:	4632      	mov	r2, r6
 801235c:	2101      	movs	r1, #1
 801235e:	2002      	movs	r0, #2
 8012360:	f00c ff3c 	bl	801f1dc <traceIF_uartPrint>
 8012364:	e69d      	b.n	80120a2 <fRspAnalyze_CGREG+0x4a6>
 8012366:	bf00      	nop
 8012368:	200048dc 	.word	0x200048dc
 801236c:	0802fb74 	.word	0x0802fb74
 8012370:	0802fb9c 	.word	0x0802fb9c
 8012374:	0802fbc8 	.word	0x0802fbc8
 8012378:	0802fbf4 	.word	0x0802fbf4

0801237c <fRspAnalyze_CEREG>:

at_action_rsp_t fRspAnalyze_CEREG(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 801237c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012380:	4607      	mov	r7, r0
 8012382:	4689      	mov	r9, r1
 8012384:	4690      	mov	r8, r2
 8012386:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEREG()")
 8012388:	4cc6      	ldr	r4, [pc, #792]	; (80126a4 <fRspAnalyze_CEREG+0x328>)
 801238a:	4dc7      	ldr	r5, [pc, #796]	; (80126a8 <fRspAnalyze_CEREG+0x32c>)
 801238c:	f104 0e20 	add.w	lr, r4, #32
 8012390:	46a4      	mov	ip, r4
 8012392:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012396:	6028      	str	r0, [r5, #0]
 8012398:	6069      	str	r1, [r5, #4]
 801239a:	60aa      	str	r2, [r5, #8]
 801239c:	60eb      	str	r3, [r5, #12]
 801239e:	4664      	mov	r4, ip
 80123a0:	3510      	adds	r5, #16
 80123a2:	45f4      	cmp	ip, lr
 80123a4:	d1f4      	bne.n	8012390 <fRspAnalyze_CEREG+0x14>
 80123a6:	cc03      	ldmia	r4!, {r0, r1}
 80123a8:	6028      	str	r0, [r5, #0]
 80123aa:	6069      	str	r1, [r5, #4]
 80123ac:	7823      	ldrb	r3, [r4, #0]
 80123ae:	722b      	strb	r3, [r5, #8]
 80123b0:	4cbd      	ldr	r4, [pc, #756]	; (80126a8 <fRspAnalyze_CEREG+0x32c>)
 80123b2:	4620      	mov	r0, r4
 80123b4:	f00c fead 	bl	801f112 <crs_strlen>
 80123b8:	b283      	uxth	r3, r0
 80123ba:	4622      	mov	r2, r4
 80123bc:	2104      	movs	r1, #4
 80123be:	2002      	movs	r0, #2
 80123c0:	f00c feea 	bl	801f198 <traceIF_itmPrint>
 80123c4:	4620      	mov	r0, r4
 80123c6:	f00c fea4 	bl	801f112 <crs_strlen>
 80123ca:	b283      	uxth	r3, r0
 80123cc:	4622      	mov	r2, r4
 80123ce:	2104      	movs	r1, #4
 80123d0:	2002      	movs	r0, #2
 80123d2:	f00c ff03 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("current cmd = %ld", p_atp_ctxt->current_atcmd.id)
 80123d6:	69fa      	ldr	r2, [r7, #28]
 80123d8:	49b4      	ldr	r1, [pc, #720]	; (80126ac <fRspAnalyze_CEREG+0x330>)
 80123da:	4620      	mov	r0, r4
 80123dc:	f013 fc48 	bl	8025c70 <sprintf>
 80123e0:	4620      	mov	r0, r4
 80123e2:	f00c fe96 	bl	801f112 <crs_strlen>
 80123e6:	b283      	uxth	r3, r0
 80123e8:	4622      	mov	r2, r4
 80123ea:	2102      	movs	r1, #2
 80123ec:	4608      	mov	r0, r1
 80123ee:	f00c fed3 	bl	801f198 <traceIF_itmPrint>
 80123f2:	4620      	mov	r0, r4
 80123f4:	f00c fe8d 	bl	801f112 <crs_strlen>
 80123f8:	b283      	uxth	r3, r0
 80123fa:	4622      	mov	r2, r4
 80123fc:	2102      	movs	r1, #2
 80123fe:	4608      	mov	r0, r1
 8012400:	f00c feec 	bl	801f1dc <traceIF_uartPrint>
  *  2/ answer to CEREG test command
  *    +CEREG: (list of supported <n>s)
  *  3/ URC:
  *    +CEREG: <stat>[,[<tac>],[<ci>],[<AcT>]]
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CEREG)
 8012404:	69fb      	ldr	r3, [r7, #28]
 8012406:	2b19      	cmp	r3, #25
 8012408:	f040 81ea 	bne.w	80127e0 <fRspAnalyze_CEREG+0x464>
  {
    /* analyze parameters for +CEREG */
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 801240c:	8b3b      	ldrh	r3, [r7, #24]
 801240e:	2b02      	cmp	r3, #2
 8012410:	d005      	beq.n	801241e <fRspAnalyze_CEREG+0xa2>
      else
      { /* unexpecetd n value, ignore it */}
      END_PARAM_LOOP()
    }
    /* analyze parameters for +CEREG */
    else if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8012412:	2b01      	cmp	r3, #1
 8012414:	f000 81ba 	beq.w	801278c <fRspAnalyze_CEREG+0x410>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8012418:	2010      	movs	r0, #16
 801241a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      START_PARAM_LOOP()
 801241e:	2400      	movs	r4, #0
      uint32_t n_val = 0U;
 8012420:	4625      	mov	r5, r4
      START_PARAM_LOOP()
 8012422:	4632      	mov	r2, r6
 8012424:	4641      	mov	r1, r8
 8012426:	4638      	mov	r0, r7
 8012428:	f7fa f80e 	bl	800c448 <atcc_extractElement>
 801242c:	2801      	cmp	r0, #1
 801242e:	d000      	beq.n	8012432 <fRspAnalyze_CEREG+0xb6>
 8012430:	2401      	movs	r4, #1
 8012432:	89f1      	ldrh	r1, [r6, #14]
 8012434:	b1d1      	cbz	r1, 801246c <fRspAnalyze_CEREG+0xf0>
      if (element_infos->param_rank == 2U)
 8012436:	8933      	ldrh	r3, [r6, #8]
 8012438:	2b02      	cmp	r3, #2
 801243a:	d01a      	beq.n	8012472 <fRspAnalyze_CEREG+0xf6>
      if (element_infos->param_rank == 3U)
 801243c:	8933      	ldrh	r3, [r6, #8]
 801243e:	2b03      	cmp	r3, #3
 8012440:	d036      	beq.n	80124b0 <fRspAnalyze_CEREG+0x134>
      if (element_infos->param_rank == 4U)
 8012442:	8933      	ldrh	r3, [r6, #8]
 8012444:	2b04      	cmp	r3, #4
 8012446:	d058      	beq.n	80124fa <fRspAnalyze_CEREG+0x17e>
      if (element_infos->param_rank == 5U)
 8012448:	8933      	ldrh	r3, [r6, #8]
 801244a:	2b05      	cmp	r3, #5
 801244c:	d078      	beq.n	8012540 <fRspAnalyze_CEREG+0x1c4>
      if (element_infos->param_rank == 6U)
 801244e:	8933      	ldrh	r3, [r6, #8]
 8012450:	2b06      	cmp	r3, #6
 8012452:	f000 8098 	beq.w	8012586 <fRspAnalyze_CEREG+0x20a>
      if (n_val <= 3U)
 8012456:	2d03      	cmp	r5, #3
 8012458:	f200 80f2 	bhi.w	8012640 <fRspAnalyze_CEREG+0x2c4>
        if (element_infos->param_rank == 7U)
 801245c:	8933      	ldrh	r3, [r6, #8]
 801245e:	2b07      	cmp	r3, #7
 8012460:	f000 80b0 	beq.w	80125c4 <fRspAnalyze_CEREG+0x248>
        if (element_infos->param_rank == 8U)
 8012464:	8933      	ldrh	r3, [r6, #8]
 8012466:	2b08      	cmp	r3, #8
 8012468:	f000 80cb 	beq.w	8012602 <fRspAnalyze_CEREG+0x286>
      END_PARAM_LOOP()
 801246c:	2c00      	cmp	r4, #0
 801246e:	d1d3      	bne.n	8012418 <fRspAnalyze_CEREG+0x9c>
 8012470:	e7d7      	b.n	8012422 <fRspAnalyze_CEREG+0xa6>
        n_val = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 8012472:	8970      	ldrh	r0, [r6, #10]
 8012474:	4440      	add	r0, r8
 8012476:	f002 fc5d 	bl	8014d34 <ATutil_convertStringToInt>
 801247a:	4605      	mov	r5, r0
        PRINT_DBG("+CEREG: n=%ld", n_val)
 801247c:	f8df a228 	ldr.w	sl, [pc, #552]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012480:	4602      	mov	r2, r0
 8012482:	498b      	ldr	r1, [pc, #556]	; (80126b0 <fRspAnalyze_CEREG+0x334>)
 8012484:	4650      	mov	r0, sl
 8012486:	f013 fbf3 	bl	8025c70 <sprintf>
 801248a:	4650      	mov	r0, sl
 801248c:	f00c fe41 	bl	801f112 <crs_strlen>
 8012490:	b283      	uxth	r3, r0
 8012492:	4652      	mov	r2, sl
 8012494:	2102      	movs	r1, #2
 8012496:	4608      	mov	r0, r1
 8012498:	f00c fe7e 	bl	801f198 <traceIF_itmPrint>
 801249c:	4650      	mov	r0, sl
 801249e:	f00c fe38 	bl	801f112 <crs_strlen>
 80124a2:	b283      	uxth	r3, r0
 80124a4:	4652      	mov	r2, sl
 80124a6:	2102      	movs	r1, #2
 80124a8:	4608      	mov	r0, r1
 80124aa:	f00c fe97 	bl	801f1dc <traceIF_uartPrint>
 80124ae:	e7c5      	b.n	801243c <fRspAnalyze_CEREG+0xc0>
        uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80124b0:	8970      	ldrh	r0, [r6, #10]
 80124b2:	89f1      	ldrh	r1, [r6, #14]
 80124b4:	4440      	add	r0, r8
 80124b6:	f002 fc3d 	bl	8014d34 <ATutil_convertStringToInt>
 80124ba:	4683      	mov	fp, r0
        p_modem_ctxt->persist.eps_network_state = convert_NetworkState(stat, EPS_NETWORK_TYPE);
 80124bc:	2103      	movs	r1, #3
 80124be:	f7fc f9fb 	bl	800e8b8 <convert_NetworkState>
 80124c2:	f8a9 0030 	strh.w	r0, [r9, #48]	; 0x30
        PRINT_DBG("+CEREG: stat=%ld", stat)
 80124c6:	f8df a1e0 	ldr.w	sl, [pc, #480]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 80124ca:	465a      	mov	r2, fp
 80124cc:	4979      	ldr	r1, [pc, #484]	; (80126b4 <fRspAnalyze_CEREG+0x338>)
 80124ce:	4650      	mov	r0, sl
 80124d0:	f013 fbce 	bl	8025c70 <sprintf>
 80124d4:	4650      	mov	r0, sl
 80124d6:	f00c fe1c 	bl	801f112 <crs_strlen>
 80124da:	b283      	uxth	r3, r0
 80124dc:	4652      	mov	r2, sl
 80124de:	2102      	movs	r1, #2
 80124e0:	4608      	mov	r0, r1
 80124e2:	f00c fe59 	bl	801f198 <traceIF_itmPrint>
 80124e6:	4650      	mov	r0, sl
 80124e8:	f00c fe13 	bl	801f112 <crs_strlen>
 80124ec:	b283      	uxth	r3, r0
 80124ee:	4652      	mov	r2, sl
 80124f0:	2102      	movs	r1, #2
 80124f2:	4608      	mov	r0, r1
 80124f4:	f00c fe72 	bl	801f1dc <traceIF_uartPrint>
 80124f8:	e7a3      	b.n	8012442 <fRspAnalyze_CEREG+0xc6>
        uint32_t tac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 80124fa:	8970      	ldrh	r0, [r6, #10]
 80124fc:	2204      	movs	r2, #4
 80124fe:	89f1      	ldrh	r1, [r6, #14]
 8012500:	4440      	add	r0, r8
 8012502:	f7fc fb77 	bl	800ebf4 <extract_hex_value_from_quotes>
 8012506:	4602      	mov	r2, r0
        p_modem_ctxt->persist.eps_location_info.lac = (uint16_t)tac;
 8012508:	f8a9 002c 	strh.w	r0, [r9, #44]	; 0x2c
        PRINT_INFO("+CEREG: tac=%ld =0x%lx", tac, tac)
 801250c:	f8df a198 	ldr.w	sl, [pc, #408]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012510:	4603      	mov	r3, r0
 8012512:	4969      	ldr	r1, [pc, #420]	; (80126b8 <fRspAnalyze_CEREG+0x33c>)
 8012514:	4650      	mov	r0, sl
 8012516:	f013 fbab 	bl	8025c70 <sprintf>
 801251a:	4650      	mov	r0, sl
 801251c:	f00c fdf9 	bl	801f112 <crs_strlen>
 8012520:	b283      	uxth	r3, r0
 8012522:	4652      	mov	r2, sl
 8012524:	2101      	movs	r1, #1
 8012526:	2002      	movs	r0, #2
 8012528:	f00c fe36 	bl	801f198 <traceIF_itmPrint>
 801252c:	4650      	mov	r0, sl
 801252e:	f00c fdf0 	bl	801f112 <crs_strlen>
 8012532:	b283      	uxth	r3, r0
 8012534:	4652      	mov	r2, sl
 8012536:	2101      	movs	r1, #1
 8012538:	2002      	movs	r0, #2
 801253a:	f00c fe4f 	bl	801f1dc <traceIF_uartPrint>
 801253e:	e783      	b.n	8012448 <fRspAnalyze_CEREG+0xcc>
        uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8012540:	8970      	ldrh	r0, [r6, #10]
 8012542:	2208      	movs	r2, #8
 8012544:	89f1      	ldrh	r1, [r6, #14]
 8012546:	4440      	add	r0, r8
 8012548:	f7fc fb54 	bl	800ebf4 <extract_hex_value_from_quotes>
 801254c:	4602      	mov	r2, r0
        p_modem_ctxt->persist.eps_location_info.ci = (uint32_t)ci;
 801254e:	f8c9 0028 	str.w	r0, [r9, #40]	; 0x28
        PRINT_INFO("+CEREG: ci=%ld =0x%lx", ci, ci)
 8012552:	f8df a154 	ldr.w	sl, [pc, #340]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012556:	4603      	mov	r3, r0
 8012558:	4958      	ldr	r1, [pc, #352]	; (80126bc <fRspAnalyze_CEREG+0x340>)
 801255a:	4650      	mov	r0, sl
 801255c:	f013 fb88 	bl	8025c70 <sprintf>
 8012560:	4650      	mov	r0, sl
 8012562:	f00c fdd6 	bl	801f112 <crs_strlen>
 8012566:	b283      	uxth	r3, r0
 8012568:	4652      	mov	r2, sl
 801256a:	2101      	movs	r1, #1
 801256c:	2002      	movs	r0, #2
 801256e:	f00c fe13 	bl	801f198 <traceIF_itmPrint>
 8012572:	4650      	mov	r0, sl
 8012574:	f00c fdcd 	bl	801f112 <crs_strlen>
 8012578:	b283      	uxth	r3, r0
 801257a:	4652      	mov	r2, sl
 801257c:	2101      	movs	r1, #1
 801257e:	2002      	movs	r0, #2
 8012580:	f00c fe2c 	bl	801f1dc <traceIF_uartPrint>
 8012584:	e763      	b.n	801244e <fRspAnalyze_CEREG+0xd2>
        PRINT_INFO("+CEREG: act=%ld",
 8012586:	8970      	ldrh	r0, [r6, #10]
 8012588:	89f1      	ldrh	r1, [r6, #14]
 801258a:	4440      	add	r0, r8
 801258c:	f002 fbd2 	bl	8014d34 <ATutil_convertStringToInt>
 8012590:	4602      	mov	r2, r0
 8012592:	f8df a114 	ldr.w	sl, [pc, #276]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012596:	494a      	ldr	r1, [pc, #296]	; (80126c0 <fRspAnalyze_CEREG+0x344>)
 8012598:	4650      	mov	r0, sl
 801259a:	f013 fb69 	bl	8025c70 <sprintf>
 801259e:	4650      	mov	r0, sl
 80125a0:	f00c fdb7 	bl	801f112 <crs_strlen>
 80125a4:	b283      	uxth	r3, r0
 80125a6:	4652      	mov	r2, sl
 80125a8:	2101      	movs	r1, #1
 80125aa:	2002      	movs	r0, #2
 80125ac:	f00c fdf4 	bl	801f198 <traceIF_itmPrint>
 80125b0:	4650      	mov	r0, sl
 80125b2:	f00c fdae 	bl	801f112 <crs_strlen>
 80125b6:	b283      	uxth	r3, r0
 80125b8:	4652      	mov	r2, sl
 80125ba:	2101      	movs	r1, #1
 80125bc:	2002      	movs	r0, #2
 80125be:	f00c fe0d 	bl	801f1dc <traceIF_uartPrint>
 80125c2:	e748      	b.n	8012456 <fRspAnalyze_CEREG+0xda>
          PRINT_DBG("+CEREG: cause_type=%ld",
 80125c4:	8970      	ldrh	r0, [r6, #10]
 80125c6:	89f1      	ldrh	r1, [r6, #14]
 80125c8:	4440      	add	r0, r8
 80125ca:	f002 fbb3 	bl	8014d34 <ATutil_convertStringToInt>
 80125ce:	4602      	mov	r2, r0
 80125d0:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 80125d4:	493b      	ldr	r1, [pc, #236]	; (80126c4 <fRspAnalyze_CEREG+0x348>)
 80125d6:	4650      	mov	r0, sl
 80125d8:	f013 fb4a 	bl	8025c70 <sprintf>
 80125dc:	4650      	mov	r0, sl
 80125de:	f00c fd98 	bl	801f112 <crs_strlen>
 80125e2:	b283      	uxth	r3, r0
 80125e4:	4652      	mov	r2, sl
 80125e6:	2102      	movs	r1, #2
 80125e8:	4608      	mov	r0, r1
 80125ea:	f00c fdd5 	bl	801f198 <traceIF_itmPrint>
 80125ee:	4650      	mov	r0, sl
 80125f0:	f00c fd8f 	bl	801f112 <crs_strlen>
 80125f4:	b283      	uxth	r3, r0
 80125f6:	4652      	mov	r2, sl
 80125f8:	2102      	movs	r1, #2
 80125fa:	4608      	mov	r0, r1
 80125fc:	f00c fdee 	bl	801f1dc <traceIF_uartPrint>
 8012600:	e730      	b.n	8012464 <fRspAnalyze_CEREG+0xe8>
          PRINT_DBG("+CEREG: reject_cause=%ld",
 8012602:	8970      	ldrh	r0, [r6, #10]
 8012604:	89f1      	ldrh	r1, [r6, #14]
 8012606:	4440      	add	r0, r8
 8012608:	f002 fb94 	bl	8014d34 <ATutil_convertStringToInt>
 801260c:	4602      	mov	r2, r0
 801260e:	f8df a098 	ldr.w	sl, [pc, #152]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012612:	492d      	ldr	r1, [pc, #180]	; (80126c8 <fRspAnalyze_CEREG+0x34c>)
 8012614:	4650      	mov	r0, sl
 8012616:	f013 fb2b 	bl	8025c70 <sprintf>
 801261a:	4650      	mov	r0, sl
 801261c:	f00c fd79 	bl	801f112 <crs_strlen>
 8012620:	b283      	uxth	r3, r0
 8012622:	4652      	mov	r2, sl
 8012624:	2102      	movs	r1, #2
 8012626:	4608      	mov	r0, r1
 8012628:	f00c fdb6 	bl	801f198 <traceIF_itmPrint>
 801262c:	4650      	mov	r0, sl
 801262e:	f00c fd70 	bl	801f112 <crs_strlen>
 8012632:	b283      	uxth	r3, r0
 8012634:	4652      	mov	r2, sl
 8012636:	2102      	movs	r1, #2
 8012638:	4608      	mov	r0, r1
 801263a:	f00c fdcf 	bl	801f1dc <traceIF_uartPrint>
 801263e:	e715      	b.n	801246c <fRspAnalyze_CEREG+0xf0>
      else if ((n_val == 4U) || (n_val == 5U))
 8012640:	1f2b      	subs	r3, r5, #4
 8012642:	2b01      	cmp	r3, #1
 8012644:	f63f af12 	bhi.w	801246c <fRspAnalyze_CEREG+0xf0>
        if (element_infos->param_rank == 7U)
 8012648:	8933      	ldrh	r3, [r6, #8]
 801264a:	2b07      	cmp	r3, #7
 801264c:	d040      	beq.n	80126d0 <fRspAnalyze_CEREG+0x354>
        if (element_infos->param_rank == 8U)
 801264e:	8933      	ldrh	r3, [r6, #8]
 8012650:	2b08      	cmp	r3, #8
 8012652:	d05c      	beq.n	801270e <fRspAnalyze_CEREG+0x392>
        if (element_infos->param_rank == 9U)
 8012654:	8933      	ldrh	r3, [r6, #8]
 8012656:	2b09      	cmp	r3, #9
 8012658:	d078      	beq.n	801274c <fRspAnalyze_CEREG+0x3d0>
        if (element_infos->param_rank == 10U)
 801265a:	8933      	ldrh	r3, [r6, #8]
 801265c:	2b0a      	cmp	r3, #10
 801265e:	f47f af05 	bne.w	801246c <fRspAnalyze_CEREG+0xf0>
          PRINT_INFO("+CEREG: periodic_tau= 0x%lx",
 8012662:	8970      	ldrh	r0, [r6, #10]
 8012664:	2208      	movs	r2, #8
 8012666:	89f1      	ldrh	r1, [r6, #14]
 8012668:	4440      	add	r0, r8
 801266a:	f7fc fad2 	bl	800ec12 <extract_bin_value_from_quotes>
 801266e:	4602      	mov	r2, r0
 8012670:	f8df a034 	ldr.w	sl, [pc, #52]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012674:	4915      	ldr	r1, [pc, #84]	; (80126cc <fRspAnalyze_CEREG+0x350>)
 8012676:	4650      	mov	r0, sl
 8012678:	f013 fafa 	bl	8025c70 <sprintf>
 801267c:	4650      	mov	r0, sl
 801267e:	f00c fd48 	bl	801f112 <crs_strlen>
 8012682:	b283      	uxth	r3, r0
 8012684:	4652      	mov	r2, sl
 8012686:	2101      	movs	r1, #1
 8012688:	2002      	movs	r0, #2
 801268a:	f00c fd85 	bl	801f198 <traceIF_itmPrint>
 801268e:	4650      	mov	r0, sl
 8012690:	f00c fd3f 	bl	801f112 <crs_strlen>
 8012694:	b283      	uxth	r3, r0
 8012696:	4652      	mov	r2, sl
 8012698:	2101      	movs	r1, #1
 801269a:	2002      	movs	r0, #2
 801269c:	f00c fd9e 	bl	801f1dc <traceIF_uartPrint>
 80126a0:	e6e4      	b.n	801246c <fRspAnalyze_CEREG+0xf0>
 80126a2:	bf00      	nop
 80126a4:	0802fc24 	.word	0x0802fc24
 80126a8:	200048dc 	.word	0x200048dc
 80126ac:	0802f754 	.word	0x0802f754
 80126b0:	0802fc50 	.word	0x0802fc50
 80126b4:	0802fc6c 	.word	0x0802fc6c
 80126b8:	0802fc88 	.word	0x0802fc88
 80126bc:	0802fcac 	.word	0x0802fcac
 80126c0:	0802fcd0 	.word	0x0802fcd0
 80126c4:	0802fcec 	.word	0x0802fcec
 80126c8:	0802fd10 	.word	0x0802fd10
 80126cc:	0802fd5c 	.word	0x0802fd5c
          PRINT_DBG("+CEREG: cause_type=%ld",
 80126d0:	8970      	ldrh	r0, [r6, #10]
 80126d2:	89f1      	ldrh	r1, [r6, #14]
 80126d4:	4440      	add	r0, r8
 80126d6:	f002 fb2d 	bl	8014d34 <ATutil_convertStringToInt>
 80126da:	4602      	mov	r2, r0
 80126dc:	f8df a300 	ldr.w	sl, [pc, #768]	; 80129e0 <fRspAnalyze_CEREG+0x664>
 80126e0:	49bb      	ldr	r1, [pc, #748]	; (80129d0 <fRspAnalyze_CEREG+0x654>)
 80126e2:	4650      	mov	r0, sl
 80126e4:	f013 fac4 	bl	8025c70 <sprintf>
 80126e8:	4650      	mov	r0, sl
 80126ea:	f00c fd12 	bl	801f112 <crs_strlen>
 80126ee:	b283      	uxth	r3, r0
 80126f0:	4652      	mov	r2, sl
 80126f2:	2102      	movs	r1, #2
 80126f4:	4608      	mov	r0, r1
 80126f6:	f00c fd4f 	bl	801f198 <traceIF_itmPrint>
 80126fa:	4650      	mov	r0, sl
 80126fc:	f00c fd09 	bl	801f112 <crs_strlen>
 8012700:	b283      	uxth	r3, r0
 8012702:	4652      	mov	r2, sl
 8012704:	2102      	movs	r1, #2
 8012706:	4608      	mov	r0, r1
 8012708:	f00c fd68 	bl	801f1dc <traceIF_uartPrint>
 801270c:	e79f      	b.n	801264e <fRspAnalyze_CEREG+0x2d2>
          PRINT_DBG("+CEREG: reject_cause=%ld",
 801270e:	8970      	ldrh	r0, [r6, #10]
 8012710:	89f1      	ldrh	r1, [r6, #14]
 8012712:	4440      	add	r0, r8
 8012714:	f002 fb0e 	bl	8014d34 <ATutil_convertStringToInt>
 8012718:	4602      	mov	r2, r0
 801271a:	f8df a2c4 	ldr.w	sl, [pc, #708]	; 80129e0 <fRspAnalyze_CEREG+0x664>
 801271e:	49ad      	ldr	r1, [pc, #692]	; (80129d4 <fRspAnalyze_CEREG+0x658>)
 8012720:	4650      	mov	r0, sl
 8012722:	f013 faa5 	bl	8025c70 <sprintf>
 8012726:	4650      	mov	r0, sl
 8012728:	f00c fcf3 	bl	801f112 <crs_strlen>
 801272c:	b283      	uxth	r3, r0
 801272e:	4652      	mov	r2, sl
 8012730:	2102      	movs	r1, #2
 8012732:	4608      	mov	r0, r1
 8012734:	f00c fd30 	bl	801f198 <traceIF_itmPrint>
 8012738:	4650      	mov	r0, sl
 801273a:	f00c fcea 	bl	801f112 <crs_strlen>
 801273e:	b283      	uxth	r3, r0
 8012740:	4652      	mov	r2, sl
 8012742:	2102      	movs	r1, #2
 8012744:	4608      	mov	r0, r1
 8012746:	f00c fd49 	bl	801f1dc <traceIF_uartPrint>
 801274a:	e783      	b.n	8012654 <fRspAnalyze_CEREG+0x2d8>
          PRINT_INFO("+CEREG: active_time= 0x%lx",
 801274c:	8970      	ldrh	r0, [r6, #10]
 801274e:	2208      	movs	r2, #8
 8012750:	89f1      	ldrh	r1, [r6, #14]
 8012752:	4440      	add	r0, r8
 8012754:	f7fc fa5d 	bl	800ec12 <extract_bin_value_from_quotes>
 8012758:	4602      	mov	r2, r0
 801275a:	f8df a284 	ldr.w	sl, [pc, #644]	; 80129e0 <fRspAnalyze_CEREG+0x664>
 801275e:	499e      	ldr	r1, [pc, #632]	; (80129d8 <fRspAnalyze_CEREG+0x65c>)
 8012760:	4650      	mov	r0, sl
 8012762:	f013 fa85 	bl	8025c70 <sprintf>
 8012766:	4650      	mov	r0, sl
 8012768:	f00c fcd3 	bl	801f112 <crs_strlen>
 801276c:	b283      	uxth	r3, r0
 801276e:	4652      	mov	r2, sl
 8012770:	2101      	movs	r1, #1
 8012772:	2002      	movs	r0, #2
 8012774:	f00c fd10 	bl	801f198 <traceIF_itmPrint>
 8012778:	4650      	mov	r0, sl
 801277a:	f00c fcca 	bl	801f112 <crs_strlen>
 801277e:	b283      	uxth	r3, r0
 8012780:	4652      	mov	r2, sl
 8012782:	2101      	movs	r1, #1
 8012784:	2002      	movs	r0, #2
 8012786:	f00c fd29 	bl	801f1dc <traceIF_uartPrint>
 801278a:	e766      	b.n	801265a <fRspAnalyze_CEREG+0x2de>
      PRINT_DBG("+CEREG for test cmd NOT IMPLEMENTED")
 801278c:	4d93      	ldr	r5, [pc, #588]	; (80129dc <fRspAnalyze_CEREG+0x660>)
 801278e:	4c94      	ldr	r4, [pc, #592]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 8012790:	f105 0720 	add.w	r7, r5, #32
 8012794:	462e      	mov	r6, r5
 8012796:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8012798:	6020      	str	r0, [r4, #0]
 801279a:	6061      	str	r1, [r4, #4]
 801279c:	60a2      	str	r2, [r4, #8]
 801279e:	60e3      	str	r3, [r4, #12]
 80127a0:	4635      	mov	r5, r6
 80127a2:	3410      	adds	r4, #16
 80127a4:	42be      	cmp	r6, r7
 80127a6:	d1f5      	bne.n	8012794 <fRspAnalyze_CEREG+0x418>
 80127a8:	cd07      	ldmia	r5!, {r0, r1, r2}
 80127aa:	6020      	str	r0, [r4, #0]
 80127ac:	6061      	str	r1, [r4, #4]
 80127ae:	60a2      	str	r2, [r4, #8]
 80127b0:	882a      	ldrh	r2, [r5, #0]
 80127b2:	78ab      	ldrb	r3, [r5, #2]
 80127b4:	81a2      	strh	r2, [r4, #12]
 80127b6:	73a3      	strb	r3, [r4, #14]
 80127b8:	4c89      	ldr	r4, [pc, #548]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80127ba:	4620      	mov	r0, r4
 80127bc:	f00c fca9 	bl	801f112 <crs_strlen>
 80127c0:	b283      	uxth	r3, r0
 80127c2:	4622      	mov	r2, r4
 80127c4:	2102      	movs	r1, #2
 80127c6:	4608      	mov	r0, r1
 80127c8:	f00c fce6 	bl	801f198 <traceIF_itmPrint>
 80127cc:	4620      	mov	r0, r4
 80127ce:	f00c fca0 	bl	801f112 <crs_strlen>
 80127d2:	b283      	uxth	r3, r0
 80127d4:	4622      	mov	r2, r4
 80127d6:	2102      	movs	r1, #2
 80127d8:	4608      	mov	r0, r1
 80127da:	f00c fcff 	bl	801f1dc <traceIF_uartPrint>
 80127de:	e61b      	b.n	8012418 <fRspAnalyze_CEREG+0x9c>
    START_PARAM_LOOP()
 80127e0:	2400      	movs	r4, #0
 80127e2:	4632      	mov	r2, r6
 80127e4:	4641      	mov	r1, r8
 80127e6:	4638      	mov	r0, r7
 80127e8:	f7f9 fe2e 	bl	800c448 <atcc_extractElement>
 80127ec:	2801      	cmp	r0, #1
 80127ee:	d000      	beq.n	80127f2 <fRspAnalyze_CEREG+0x476>
 80127f0:	2401      	movs	r4, #1
 80127f2:	89f1      	ldrh	r1, [r6, #14]
 80127f4:	b1e1      	cbz	r1, 8012830 <fRspAnalyze_CEREG+0x4b4>
    if (element_infos->param_rank == 2U)
 80127f6:	8933      	ldrh	r3, [r6, #8]
 80127f8:	2b02      	cmp	r3, #2
 80127fa:	d01d      	beq.n	8012838 <fRspAnalyze_CEREG+0x4bc>
    if (element_infos->param_rank == 3U)
 80127fc:	8933      	ldrh	r3, [r6, #8]
 80127fe:	2b03      	cmp	r3, #3
 8012800:	d040      	beq.n	8012884 <fRspAnalyze_CEREG+0x508>
    if (element_infos->param_rank == 4U)
 8012802:	8933      	ldrh	r3, [r6, #8]
 8012804:	2b04      	cmp	r3, #4
 8012806:	d063      	beq.n	80128d0 <fRspAnalyze_CEREG+0x554>
    if (element_infos->param_rank == 5U)
 8012808:	8933      	ldrh	r3, [r6, #8]
 801280a:	2b05      	cmp	r3, #5
 801280c:	f000 8086 	beq.w	801291c <fRspAnalyze_CEREG+0x5a0>
    if (element_infos->param_rank == 6U)
 8012810:	8933      	ldrh	r3, [r6, #8]
 8012812:	2b06      	cmp	r3, #6
 8012814:	f000 80a0 	beq.w	8012958 <fRspAnalyze_CEREG+0x5dc>
    if (element_infos->param_rank == 7U)
 8012818:	8933      	ldrh	r3, [r6, #8]
 801281a:	2b07      	cmp	r3, #7
 801281c:	f000 80ba 	beq.w	8012994 <fRspAnalyze_CEREG+0x618>
    if (element_infos->param_rank == 8U)
 8012820:	8933      	ldrh	r3, [r6, #8]
 8012822:	2b08      	cmp	r3, #8
 8012824:	f000 80ea 	beq.w	80129fc <fRspAnalyze_CEREG+0x680>
    if (element_infos->param_rank == 9U)
 8012828:	8933      	ldrh	r3, [r6, #8]
 801282a:	2b09      	cmp	r3, #9
 801282c:	f000 8105 	beq.w	8012a3a <fRspAnalyze_CEREG+0x6be>
    END_PARAM_LOOP()
 8012830:	2c00      	cmp	r4, #0
 8012832:	f47f adf1 	bne.w	8012418 <fRspAnalyze_CEREG+0x9c>
 8012836:	e7d4      	b.n	80127e2 <fRspAnalyze_CEREG+0x466>
      uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8012838:	8970      	ldrh	r0, [r6, #10]
 801283a:	4440      	add	r0, r8
 801283c:	f002 fa7a 	bl	8014d34 <ATutil_convertStringToInt>
 8012840:	4682      	mov	sl, r0
      p_modem_ctxt->persist.urc_avail_eps_network_registration = AT_TRUE;
 8012842:	2301      	movs	r3, #1
 8012844:	f889 3014 	strb.w	r3, [r9, #20]
      p_modem_ctxt->persist.eps_network_state = convert_NetworkState(stat, EPS_NETWORK_TYPE);
 8012848:	2103      	movs	r1, #3
 801284a:	f7fc f835 	bl	800e8b8 <convert_NetworkState>
 801284e:	f8a9 0030 	strh.w	r0, [r9, #48]	; 0x30
      PRINT_DBG("+CEREG URC: stat=%ld", stat)
 8012852:	4d63      	ldr	r5, [pc, #396]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 8012854:	4652      	mov	r2, sl
 8012856:	4963      	ldr	r1, [pc, #396]	; (80129e4 <fRspAnalyze_CEREG+0x668>)
 8012858:	4628      	mov	r0, r5
 801285a:	f013 fa09 	bl	8025c70 <sprintf>
 801285e:	4628      	mov	r0, r5
 8012860:	f00c fc57 	bl	801f112 <crs_strlen>
 8012864:	b283      	uxth	r3, r0
 8012866:	462a      	mov	r2, r5
 8012868:	2102      	movs	r1, #2
 801286a:	4608      	mov	r0, r1
 801286c:	f00c fc94 	bl	801f198 <traceIF_itmPrint>
 8012870:	4628      	mov	r0, r5
 8012872:	f00c fc4e 	bl	801f112 <crs_strlen>
 8012876:	b283      	uxth	r3, r0
 8012878:	462a      	mov	r2, r5
 801287a:	2102      	movs	r1, #2
 801287c:	4608      	mov	r0, r1
 801287e:	f00c fcad 	bl	801f1dc <traceIF_uartPrint>
 8012882:	e7bb      	b.n	80127fc <fRspAnalyze_CEREG+0x480>
      uint32_t tac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8012884:	8970      	ldrh	r0, [r6, #10]
 8012886:	2204      	movs	r2, #4
 8012888:	89f1      	ldrh	r1, [r6, #14]
 801288a:	4440      	add	r0, r8
 801288c:	f7fc f9b2 	bl	800ebf4 <extract_hex_value_from_quotes>
 8012890:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_eps_location_info_tac = AT_TRUE;
 8012892:	f04f 0a01 	mov.w	sl, #1
 8012896:	f889 a015 	strb.w	sl, [r9, #21]
      p_modem_ctxt->persist.eps_location_info.lac = (uint16_t)tac;
 801289a:	f8a9 002c 	strh.w	r0, [r9, #44]	; 0x2c
      PRINT_INFO("+CEREG URC: tac=%ld =0x%lx", tac, tac)
 801289e:	4d50      	ldr	r5, [pc, #320]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80128a0:	4603      	mov	r3, r0
 80128a2:	4951      	ldr	r1, [pc, #324]	; (80129e8 <fRspAnalyze_CEREG+0x66c>)
 80128a4:	4628      	mov	r0, r5
 80128a6:	f013 f9e3 	bl	8025c70 <sprintf>
 80128aa:	4628      	mov	r0, r5
 80128ac:	f00c fc31 	bl	801f112 <crs_strlen>
 80128b0:	b283      	uxth	r3, r0
 80128b2:	462a      	mov	r2, r5
 80128b4:	4651      	mov	r1, sl
 80128b6:	2002      	movs	r0, #2
 80128b8:	f00c fc6e 	bl	801f198 <traceIF_itmPrint>
 80128bc:	4628      	mov	r0, r5
 80128be:	f00c fc28 	bl	801f112 <crs_strlen>
 80128c2:	b283      	uxth	r3, r0
 80128c4:	462a      	mov	r2, r5
 80128c6:	4651      	mov	r1, sl
 80128c8:	2002      	movs	r0, #2
 80128ca:	f00c fc87 	bl	801f1dc <traceIF_uartPrint>
 80128ce:	e798      	b.n	8012802 <fRspAnalyze_CEREG+0x486>
      uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 80128d0:	8970      	ldrh	r0, [r6, #10]
 80128d2:	2208      	movs	r2, #8
 80128d4:	89f1      	ldrh	r1, [r6, #14]
 80128d6:	4440      	add	r0, r8
 80128d8:	f7fc f98c 	bl	800ebf4 <extract_hex_value_from_quotes>
 80128dc:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_eps_location_info_ci = AT_TRUE;
 80128de:	f04f 0a01 	mov.w	sl, #1
 80128e2:	f889 a016 	strb.w	sl, [r9, #22]
      p_modem_ctxt->persist.eps_location_info.ci = (uint32_t)ci;
 80128e6:	f8c9 0028 	str.w	r0, [r9, #40]	; 0x28
      PRINT_INFO("+CEREG URC: ci=%ld =0x%lx", ci, ci)
 80128ea:	4d3d      	ldr	r5, [pc, #244]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80128ec:	4603      	mov	r3, r0
 80128ee:	493f      	ldr	r1, [pc, #252]	; (80129ec <fRspAnalyze_CEREG+0x670>)
 80128f0:	4628      	mov	r0, r5
 80128f2:	f013 f9bd 	bl	8025c70 <sprintf>
 80128f6:	4628      	mov	r0, r5
 80128f8:	f00c fc0b 	bl	801f112 <crs_strlen>
 80128fc:	b283      	uxth	r3, r0
 80128fe:	462a      	mov	r2, r5
 8012900:	4651      	mov	r1, sl
 8012902:	2002      	movs	r0, #2
 8012904:	f00c fc48 	bl	801f198 <traceIF_itmPrint>
 8012908:	4628      	mov	r0, r5
 801290a:	f00c fc02 	bl	801f112 <crs_strlen>
 801290e:	b283      	uxth	r3, r0
 8012910:	462a      	mov	r2, r5
 8012912:	4651      	mov	r1, sl
 8012914:	2002      	movs	r0, #2
 8012916:	f00c fc61 	bl	801f1dc <traceIF_uartPrint>
 801291a:	e775      	b.n	8012808 <fRspAnalyze_CEREG+0x48c>
      PRINT_DBG("+CEREG URC: act=%ld",
 801291c:	8970      	ldrh	r0, [r6, #10]
 801291e:	89f1      	ldrh	r1, [r6, #14]
 8012920:	4440      	add	r0, r8
 8012922:	f002 fa07 	bl	8014d34 <ATutil_convertStringToInt>
 8012926:	4602      	mov	r2, r0
 8012928:	4d2d      	ldr	r5, [pc, #180]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 801292a:	4931      	ldr	r1, [pc, #196]	; (80129f0 <fRspAnalyze_CEREG+0x674>)
 801292c:	4628      	mov	r0, r5
 801292e:	f013 f99f 	bl	8025c70 <sprintf>
 8012932:	4628      	mov	r0, r5
 8012934:	f00c fbed 	bl	801f112 <crs_strlen>
 8012938:	b283      	uxth	r3, r0
 801293a:	462a      	mov	r2, r5
 801293c:	2102      	movs	r1, #2
 801293e:	4608      	mov	r0, r1
 8012940:	f00c fc2a 	bl	801f198 <traceIF_itmPrint>
 8012944:	4628      	mov	r0, r5
 8012946:	f00c fbe4 	bl	801f112 <crs_strlen>
 801294a:	b283      	uxth	r3, r0
 801294c:	462a      	mov	r2, r5
 801294e:	2102      	movs	r1, #2
 8012950:	4608      	mov	r0, r1
 8012952:	f00c fc43 	bl	801f1dc <traceIF_uartPrint>
 8012956:	e75b      	b.n	8012810 <fRspAnalyze_CEREG+0x494>
      PRINT_DBG("+CEREG URC: cause_type=%ld",
 8012958:	8970      	ldrh	r0, [r6, #10]
 801295a:	89f1      	ldrh	r1, [r6, #14]
 801295c:	4440      	add	r0, r8
 801295e:	f002 f9e9 	bl	8014d34 <ATutil_convertStringToInt>
 8012962:	4602      	mov	r2, r0
 8012964:	4d1e      	ldr	r5, [pc, #120]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 8012966:	4923      	ldr	r1, [pc, #140]	; (80129f4 <fRspAnalyze_CEREG+0x678>)
 8012968:	4628      	mov	r0, r5
 801296a:	f013 f981 	bl	8025c70 <sprintf>
 801296e:	4628      	mov	r0, r5
 8012970:	f00c fbcf 	bl	801f112 <crs_strlen>
 8012974:	b283      	uxth	r3, r0
 8012976:	462a      	mov	r2, r5
 8012978:	2102      	movs	r1, #2
 801297a:	4608      	mov	r0, r1
 801297c:	f00c fc0c 	bl	801f198 <traceIF_itmPrint>
 8012980:	4628      	mov	r0, r5
 8012982:	f00c fbc6 	bl	801f112 <crs_strlen>
 8012986:	b283      	uxth	r3, r0
 8012988:	462a      	mov	r2, r5
 801298a:	2102      	movs	r1, #2
 801298c:	4608      	mov	r0, r1
 801298e:	f00c fc25 	bl	801f1dc <traceIF_uartPrint>
 8012992:	e741      	b.n	8012818 <fRspAnalyze_CEREG+0x49c>
      PRINT_DBG("+CEREG URC: reject_cause=%ld",
 8012994:	8970      	ldrh	r0, [r6, #10]
 8012996:	89f1      	ldrh	r1, [r6, #14]
 8012998:	4440      	add	r0, r8
 801299a:	f002 f9cb 	bl	8014d34 <ATutil_convertStringToInt>
 801299e:	4602      	mov	r2, r0
 80129a0:	4d0f      	ldr	r5, [pc, #60]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80129a2:	4915      	ldr	r1, [pc, #84]	; (80129f8 <fRspAnalyze_CEREG+0x67c>)
 80129a4:	4628      	mov	r0, r5
 80129a6:	f013 f963 	bl	8025c70 <sprintf>
 80129aa:	4628      	mov	r0, r5
 80129ac:	f00c fbb1 	bl	801f112 <crs_strlen>
 80129b0:	b283      	uxth	r3, r0
 80129b2:	462a      	mov	r2, r5
 80129b4:	2102      	movs	r1, #2
 80129b6:	4608      	mov	r0, r1
 80129b8:	f00c fbee 	bl	801f198 <traceIF_itmPrint>
 80129bc:	4628      	mov	r0, r5
 80129be:	f00c fba8 	bl	801f112 <crs_strlen>
 80129c2:	b283      	uxth	r3, r0
 80129c4:	462a      	mov	r2, r5
 80129c6:	2102      	movs	r1, #2
 80129c8:	4608      	mov	r0, r1
 80129ca:	f00c fc07 	bl	801f1dc <traceIF_uartPrint>
 80129ce:	e727      	b.n	8012820 <fRspAnalyze_CEREG+0x4a4>
 80129d0:	0802fcec 	.word	0x0802fcec
 80129d4:	0802fd10 	.word	0x0802fd10
 80129d8:	0802fd34 	.word	0x0802fd34
 80129dc:	0802fd84 	.word	0x0802fd84
 80129e0:	200048dc 	.word	0x200048dc
 80129e4:	0802fdb4 	.word	0x0802fdb4
 80129e8:	0802fdd4 	.word	0x0802fdd4
 80129ec:	0802fdfc 	.word	0x0802fdfc
 80129f0:	0802fe24 	.word	0x0802fe24
 80129f4:	0802fe44 	.word	0x0802fe44
 80129f8:	0802fe6c 	.word	0x0802fe6c
      PRINT_INFO("+CEREG URC: active_time= 0x%lx",
 80129fc:	8970      	ldrh	r0, [r6, #10]
 80129fe:	2208      	movs	r2, #8
 8012a00:	89f1      	ldrh	r1, [r6, #14]
 8012a02:	4440      	add	r0, r8
 8012a04:	f7fc f905 	bl	800ec12 <extract_bin_value_from_quotes>
 8012a08:	4602      	mov	r2, r0
 8012a0a:	4d1b      	ldr	r5, [pc, #108]	; (8012a78 <fRspAnalyze_CEREG+0x6fc>)
 8012a0c:	491b      	ldr	r1, [pc, #108]	; (8012a7c <fRspAnalyze_CEREG+0x700>)
 8012a0e:	4628      	mov	r0, r5
 8012a10:	f013 f92e 	bl	8025c70 <sprintf>
 8012a14:	4628      	mov	r0, r5
 8012a16:	f00c fb7c 	bl	801f112 <crs_strlen>
 8012a1a:	b283      	uxth	r3, r0
 8012a1c:	462a      	mov	r2, r5
 8012a1e:	2101      	movs	r1, #1
 8012a20:	2002      	movs	r0, #2
 8012a22:	f00c fbb9 	bl	801f198 <traceIF_itmPrint>
 8012a26:	4628      	mov	r0, r5
 8012a28:	f00c fb73 	bl	801f112 <crs_strlen>
 8012a2c:	b283      	uxth	r3, r0
 8012a2e:	462a      	mov	r2, r5
 8012a30:	2101      	movs	r1, #1
 8012a32:	2002      	movs	r0, #2
 8012a34:	f00c fbd2 	bl	801f1dc <traceIF_uartPrint>
 8012a38:	e6f6      	b.n	8012828 <fRspAnalyze_CEREG+0x4ac>
      PRINT_INFO("+CEREG URC: periodic_tau= 0x%lx",
 8012a3a:	8970      	ldrh	r0, [r6, #10]
 8012a3c:	2208      	movs	r2, #8
 8012a3e:	89f1      	ldrh	r1, [r6, #14]
 8012a40:	4440      	add	r0, r8
 8012a42:	f7fc f8e6 	bl	800ec12 <extract_bin_value_from_quotes>
 8012a46:	4602      	mov	r2, r0
 8012a48:	4d0b      	ldr	r5, [pc, #44]	; (8012a78 <fRspAnalyze_CEREG+0x6fc>)
 8012a4a:	490d      	ldr	r1, [pc, #52]	; (8012a80 <fRspAnalyze_CEREG+0x704>)
 8012a4c:	4628      	mov	r0, r5
 8012a4e:	f013 f90f 	bl	8025c70 <sprintf>
 8012a52:	4628      	mov	r0, r5
 8012a54:	f00c fb5d 	bl	801f112 <crs_strlen>
 8012a58:	b283      	uxth	r3, r0
 8012a5a:	462a      	mov	r2, r5
 8012a5c:	2101      	movs	r1, #1
 8012a5e:	2002      	movs	r0, #2
 8012a60:	f00c fb9a 	bl	801f198 <traceIF_itmPrint>
 8012a64:	4628      	mov	r0, r5
 8012a66:	f00c fb54 	bl	801f112 <crs_strlen>
 8012a6a:	b283      	uxth	r3, r0
 8012a6c:	462a      	mov	r2, r5
 8012a6e:	2101      	movs	r1, #1
 8012a70:	2002      	movs	r0, #2
 8012a72:	f00c fbb3 	bl	801f1dc <traceIF_uartPrint>
 8012a76:	e6db      	b.n	8012830 <fRspAnalyze_CEREG+0x4b4>
 8012a78:	200048dc 	.word	0x200048dc
 8012a7c:	0802fe94 	.word	0x0802fe94
 8012a80:	0802fec0 	.word	0x0802fec0

08012a84 <fRspAnalyze_CGEV>:

at_action_rsp_t fRspAnalyze_CGEV(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8012a84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012a88:	b095      	sub	sp, #84	; 0x54
 8012a8a:	4680      	mov	r8, r0
 8012a8c:	460e      	mov	r6, r1
 8012a8e:	4617      	mov	r7, r2
 8012a90:	461d      	mov	r5, r3
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGEV()")
 8012a92:	4cc9      	ldr	r4, [pc, #804]	; (8012db8 <fRspAnalyze_CGEV+0x334>)
 8012a94:	f8df c324 	ldr.w	ip, [pc, #804]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012a98:	f104 0920 	add.w	r9, r4, #32
 8012a9c:	46a6      	mov	lr, r4
 8012a9e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8012aa2:	f8cc 0000 	str.w	r0, [ip]
 8012aa6:	f8cc 1004 	str.w	r1, [ip, #4]
 8012aaa:	f8cc 2008 	str.w	r2, [ip, #8]
 8012aae:	f8cc 300c 	str.w	r3, [ip, #12]
 8012ab2:	4674      	mov	r4, lr
 8012ab4:	f10c 0c10 	add.w	ip, ip, #16
 8012ab8:	45ce      	cmp	lr, r9
 8012aba:	d1ef      	bne.n	8012a9c <fRspAnalyze_CGEV+0x18>
 8012abc:	cc03      	ldmia	r4!, {r0, r1}
 8012abe:	f8cc 0000 	str.w	r0, [ip]
 8012ac2:	f8cc 1004 	str.w	r1, [ip, #4]
 8012ac6:	4cbd      	ldr	r4, [pc, #756]	; (8012dbc <fRspAnalyze_CGEV+0x338>)
 8012ac8:	4620      	mov	r0, r4
 8012aca:	f00c fb22 	bl	801f112 <crs_strlen>
 8012ace:	b283      	uxth	r3, r0
 8012ad0:	4622      	mov	r2, r4
 8012ad2:	2104      	movs	r1, #4
 8012ad4:	2002      	movs	r0, #2
 8012ad6:	f00c fb5f 	bl	801f198 <traceIF_itmPrint>
 8012ada:	4620      	mov	r0, r4
 8012adc:	f00c fb19 	bl	801f112 <crs_strlen>
 8012ae0:	b283      	uxth	r3, r0
 8012ae2:	4622      	mov	r2, r4
 8012ae4:	2104      	movs	r1, #4
 8012ae6:	2002      	movs	r0, #2
 8012ae8:	f00c fb78 	bl	801f1dc <traceIF_uartPrint>

  /* cf 3GPP TS 27.007 */
  /* this is an URC */
  START_PARAM_LOOP()
 8012aec:	f04f 0900 	mov.w	r9, #0
 8012af0:	462a      	mov	r2, r5
 8012af2:	4639      	mov	r1, r7
 8012af4:	4640      	mov	r0, r8
 8012af6:	f7f9 fca7 	bl	800c448 <atcc_extractElement>
 8012afa:	2801      	cmp	r0, #1
 8012afc:	d001      	beq.n	8012b02 <fRspAnalyze_CGEV+0x7e>
 8012afe:	f04f 0901 	mov.w	r9, #1
 8012b02:	89eb      	ldrh	r3, [r5, #14]
 8012b04:	2b00      	cmp	r3, #0
 8012b06:	f000 8370 	beq.w	80131ea <fRspAnalyze_CGEV+0x766>
  if (element_infos->param_rank == 2U)
 8012b0a:	892a      	ldrh	r2, [r5, #8]
 8012b0c:	2a02      	cmp	r2, #2
 8012b0e:	d024      	beq.n	8012b5a <fRspAnalyze_CGEV+0xd6>
      PRINT_ERR("an +CGEV URC still not reported, ignore this one")
      retval = ATACTION_RSP_ERROR;
    }

  }
  else if (element_infos->param_rank == 3U)
 8012b10:	2a03      	cmp	r2, #3
 8012b12:	f000 8308 	beq.w	8013126 <fRspAnalyze_CGEV+0x6a2>
    else
    {
      PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
    }
  }
  else if (element_infos->param_rank == 4U)
 8012b16:	2a04      	cmp	r2, #4
 8012b18:	f040 8350 	bne.w	80131bc <fRspAnalyze_CGEV+0x738>
  {
    if ((p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8012b1c:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8012b1e:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8012b22:	49a7      	ldr	r1, [pc, #668]	; (8012dc0 <fRspAnalyze_CGEV+0x33c>)
 8012b24:	428b      	cmp	r3, r1
 8012b26:	f000 8360 	beq.w	80131ea <fRspAnalyze_CGEV+0x766>
      */
      /* CID not used: we could use it if problem with <PDP_addr> occured */
    }
    else
    {
      PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
 8012b2a:	4ca4      	ldr	r4, [pc, #656]	; (8012dbc <fRspAnalyze_CGEV+0x338>)
 8012b2c:	49a5      	ldr	r1, [pc, #660]	; (8012dc4 <fRspAnalyze_CGEV+0x340>)
 8012b2e:	4620      	mov	r0, r4
 8012b30:	f013 f89e 	bl	8025c70 <sprintf>
 8012b34:	4620      	mov	r0, r4
 8012b36:	f00c faec 	bl	801f112 <crs_strlen>
 8012b3a:	b283      	uxth	r3, r0
 8012b3c:	4622      	mov	r2, r4
 8012b3e:	2102      	movs	r1, #2
 8012b40:	4608      	mov	r0, r1
 8012b42:	f00c fb29 	bl	801f198 <traceIF_itmPrint>
 8012b46:	4620      	mov	r0, r4
 8012b48:	f00c fae3 	bl	801f112 <crs_strlen>
 8012b4c:	b283      	uxth	r3, r0
 8012b4e:	4622      	mov	r2, r4
 8012b50:	2102      	movs	r1, #2
 8012b52:	4608      	mov	r0, r1
 8012b54:	f00c fb42 	bl	801f1dc <traceIF_uartPrint>
 8012b58:	e347      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
    if (p_modem_ctxt->persist.urc_avail_pdn_event != AT_TRUE)
 8012b5a:	f896 3020 	ldrb.w	r3, [r6, #32]
 8012b5e:	2b00      	cmp	r3, #0
 8012b60:	f040 82c7 	bne.w	80130f2 <fRspAnalyze_CGEV+0x66e>
      reset_pdn_event(&p_modem_ctxt->persist);
 8012b64:	f106 0a0c 	add.w	sl, r6, #12
 8012b68:	4650      	mov	r0, sl
 8012b6a:	f7fa ffdf 	bl	800db2c <reset_pdn_event>
      uint8_t copy_params[MAX_CGEV_PARAM_SIZE] = {0};
 8012b6e:	2300      	movs	r3, #0
 8012b70:	9303      	str	r3, [sp, #12]
 8012b72:	9304      	str	r3, [sp, #16]
 8012b74:	9305      	str	r3, [sp, #20]
 8012b76:	9306      	str	r3, [sp, #24]
 8012b78:	9307      	str	r3, [sp, #28]
 8012b7a:	9308      	str	r3, [sp, #32]
 8012b7c:	9309      	str	r3, [sp, #36]	; 0x24
 8012b7e:	930a      	str	r3, [sp, #40]	; 0x28
      size_t size_mini = ATC_GET_MINIMUM_SIZE(element_infos->str_size, MAX_CGEV_PARAM_SIZE);
 8012b80:	89ea      	ldrh	r2, [r5, #14]
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8012b82:	8969      	ldrh	r1, [r5, #10]
      (void) memcpy((void *)copy_params,
 8012b84:	2a20      	cmp	r2, #32
 8012b86:	bf28      	it	cs
 8012b88:	2220      	movcs	r2, #32
 8012b8a:	4439      	add	r1, r7
 8012b8c:	a803      	add	r0, sp, #12
 8012b8e:	f013 f9bf 	bl	8025f10 <memcpy>
      found = (AT_CHAR_t *)strtok((CRC_CHAR_t *)copy_params, " ");
 8012b92:	498d      	ldr	r1, [pc, #564]	; (8012dc8 <fRspAnalyze_CGEV+0x344>)
 8012b94:	a803      	add	r0, sp, #12
 8012b96:	f013 f8f9 	bl	8025d8c <strtok>
 8012b9a:	4604      	mov	r4, r0
      while (found  != NULL)
 8012b9c:	e044      	b.n	8012c28 <fRspAnalyze_CGEV+0x1a4>
          PRINT_DBG("<NW>")
 8012b9e:	f8df b21c 	ldr.w	fp, [pc, #540]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012ba2:	f8df c254 	ldr.w	ip, [pc, #596]	; 8012df8 <fRspAnalyze_CGEV+0x374>
 8012ba6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012baa:	f8cb 0000 	str.w	r0, [fp]
 8012bae:	f8cb 1004 	str.w	r1, [fp, #4]
 8012bb2:	f8cb 2008 	str.w	r2, [fp, #8]
 8012bb6:	f8cb 300c 	str.w	r3, [fp, #12]
 8012bba:	4658      	mov	r0, fp
 8012bbc:	f00c faa9 	bl	801f112 <crs_strlen>
 8012bc0:	b283      	uxth	r3, r0
 8012bc2:	465a      	mov	r2, fp
 8012bc4:	2102      	movs	r1, #2
 8012bc6:	4608      	mov	r0, r1
 8012bc8:	f00c fae6 	bl	801f198 <traceIF_itmPrint>
 8012bcc:	4658      	mov	r0, fp
 8012bce:	f00c faa0 	bl	801f112 <crs_strlen>
 8012bd2:	b283      	uxth	r3, r0
 8012bd4:	465a      	mov	r2, fp
 8012bd6:	2102      	movs	r1, #2
 8012bd8:	4608      	mov	r0, r1
 8012bda:	f00c faff 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_origine = CGEV_EVENT_ORIGINE_NW;
 8012bde:	2301      	movs	r3, #1
 8012be0:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
        PRINT_DBG("(%d) ---> %s", strlen((CRC_CHAR_t *)found), (uint8_t *) found)
 8012be4:	4620      	mov	r0, r4
 8012be6:	f7ed fb05 	bl	80001f4 <strlen>
 8012bea:	4602      	mov	r2, r0
 8012bec:	f8df b1cc 	ldr.w	fp, [pc, #460]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012bf0:	4623      	mov	r3, r4
 8012bf2:	4976      	ldr	r1, [pc, #472]	; (8012dcc <fRspAnalyze_CGEV+0x348>)
 8012bf4:	4658      	mov	r0, fp
 8012bf6:	f013 f83b 	bl	8025c70 <sprintf>
 8012bfa:	4658      	mov	r0, fp
 8012bfc:	f00c fa89 	bl	801f112 <crs_strlen>
 8012c00:	b283      	uxth	r3, r0
 8012c02:	465a      	mov	r2, fp
 8012c04:	2102      	movs	r1, #2
 8012c06:	4608      	mov	r0, r1
 8012c08:	f00c fac6 	bl	801f198 <traceIF_itmPrint>
 8012c0c:	4658      	mov	r0, fp
 8012c0e:	f00c fa80 	bl	801f112 <crs_strlen>
 8012c12:	b283      	uxth	r3, r0
 8012c14:	465a      	mov	r2, fp
 8012c16:	2102      	movs	r1, #2
 8012c18:	4608      	mov	r0, r1
 8012c1a:	f00c fadf 	bl	801f1dc <traceIF_uartPrint>
        found = (AT_CHAR_t *)strtok(NULL, " ");
 8012c1e:	496a      	ldr	r1, [pc, #424]	; (8012dc8 <fRspAnalyze_CGEV+0x344>)
 8012c20:	2000      	movs	r0, #0
 8012c22:	f013 f8b3 	bl	8025d8c <strtok>
 8012c26:	4604      	mov	r4, r0
      while (found  != NULL)
 8012c28:	2c00      	cmp	r4, #0
 8012c2a:	f000 825e 	beq.w	80130ea <fRspAnalyze_CGEV+0x666>
        if (0 == strcmp((CRC_CHAR_t *)found, "NW"))
 8012c2e:	4968      	ldr	r1, [pc, #416]	; (8012dd0 <fRspAnalyze_CGEV+0x34c>)
 8012c30:	4620      	mov	r0, r4
 8012c32:	f7ed fad5 	bl	80001e0 <strcmp>
 8012c36:	2800      	cmp	r0, #0
 8012c38:	d0b1      	beq.n	8012b9e <fRspAnalyze_CGEV+0x11a>
        else if (0 == strcmp((CRC_CHAR_t *)found, "ME"))
 8012c3a:	4966      	ldr	r1, [pc, #408]	; (8012dd4 <fRspAnalyze_CGEV+0x350>)
 8012c3c:	4620      	mov	r0, r4
 8012c3e:	f7ed facf 	bl	80001e0 <strcmp>
 8012c42:	2800      	cmp	r0, #0
 8012c44:	d06b      	beq.n	8012d1e <fRspAnalyze_CGEV+0x29a>
        else if (0 == strcmp((CRC_CHAR_t *)found, "PDN"))
 8012c46:	4964      	ldr	r1, [pc, #400]	; (8012dd8 <fRspAnalyze_CGEV+0x354>)
 8012c48:	4620      	mov	r0, r4
 8012c4a:	f7ed fac9 	bl	80001e0 <strcmp>
 8012c4e:	2800      	cmp	r0, #0
 8012c50:	f000 8089 	beq.w	8012d66 <fRspAnalyze_CGEV+0x2e2>
        else if (0 == strcmp((CRC_CHAR_t *)found, "ACT"))
 8012c54:	4961      	ldr	r1, [pc, #388]	; (8012ddc <fRspAnalyze_CGEV+0x358>)
 8012c56:	4620      	mov	r0, r4
 8012c58:	f7ed fac2 	bl	80001e0 <strcmp>
 8012c5c:	2800      	cmp	r0, #0
 8012c5e:	f000 80d1 	beq.w	8012e04 <fRspAnalyze_CGEV+0x380>
        else if (0 == strcmp((CRC_CHAR_t *)found, "DEACT"))
 8012c62:	495f      	ldr	r1, [pc, #380]	; (8012de0 <fRspAnalyze_CGEV+0x35c>)
 8012c64:	4620      	mov	r0, r4
 8012c66:	f7ed fabb 	bl	80001e0 <strcmp>
 8012c6a:	2800      	cmp	r0, #0
 8012c6c:	f000 80f2 	beq.w	8012e54 <fRspAnalyze_CGEV+0x3d0>
        else if (0 == strcmp((CRC_CHAR_t *)found, "REJECT"))
 8012c70:	495c      	ldr	r1, [pc, #368]	; (8012de4 <fRspAnalyze_CGEV+0x360>)
 8012c72:	4620      	mov	r0, r4
 8012c74:	f7ed fab4 	bl	80001e0 <strcmp>
 8012c78:	2800      	cmp	r0, #0
 8012c7a:	f000 8117 	beq.w	8012eac <fRspAnalyze_CGEV+0x428>
        else if (0 == strcmp((CRC_CHAR_t *)found, "DETACH"))
 8012c7e:	495a      	ldr	r1, [pc, #360]	; (8012de8 <fRspAnalyze_CGEV+0x364>)
 8012c80:	4620      	mov	r0, r4
 8012c82:	f7ed faad 	bl	80001e0 <strcmp>
 8012c86:	2800      	cmp	r0, #0
 8012c88:	f000 8138 	beq.w	8012efc <fRspAnalyze_CGEV+0x478>
        else if (0 == strcmp((CRC_CHAR_t *)found, "CLASS"))
 8012c8c:	4957      	ldr	r1, [pc, #348]	; (8012dec <fRspAnalyze_CGEV+0x368>)
 8012c8e:	4620      	mov	r0, r4
 8012c90:	f7ed faa6 	bl	80001e0 <strcmp>
 8012c94:	2800      	cmp	r0, #0
 8012c96:	f000 815c 	beq.w	8012f52 <fRspAnalyze_CGEV+0x4ce>
        else if (0 == strcmp((CRC_CHAR_t *)found, "MODIFY"))
 8012c9a:	4955      	ldr	r1, [pc, #340]	; (8012df0 <fRspAnalyze_CGEV+0x36c>)
 8012c9c:	4620      	mov	r0, r4
 8012c9e:	f7ed fa9f 	bl	80001e0 <strcmp>
 8012ca2:	2800      	cmp	r0, #0
 8012ca4:	f000 8181 	beq.w	8012faa <fRspAnalyze_CGEV+0x526>
          if (p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW)
 8012ca8:	f896 304c 	ldrb.w	r3, [r6, #76]	; 0x4c
 8012cac:	2b01      	cmp	r3, #1
 8012cae:	f040 81ef 	bne.w	8013090 <fRspAnalyze_CGEV+0x60c>
            if (p_modem_ctxt->persist.pdn_event.event_type == CGEV_EVENT_TYPE_DETACH)
 8012cb2:	f896 204e 	ldrb.w	r2, [r6, #78]	; 0x4e
 8012cb6:	2a0f      	cmp	r2, #15
 8012cb8:	f000 819f 	beq.w	8012ffa <fRspAnalyze_CGEV+0x576>
            else if (p_modem_ctxt->persist.pdn_event.event_type == CGEV_EVENT_TYPE_DEACTIVATION)
 8012cbc:	2a0d      	cmp	r2, #13
 8012cbe:	f040 81ce 	bne.w	801305e <fRspAnalyze_CGEV+0x5da>
              if (p_modem_ctxt->persist.pdn_event.event_scope == CGEV_EVENT_SCOPE_PDN)
 8012cc2:	f896 304d 	ldrb.w	r3, [r6, #77]	; 0x4d
 8012cc6:	2b0a      	cmp	r3, #10
 8012cc8:	d18c      	bne.n	8012be4 <fRspAnalyze_CGEV+0x160>
                                                              (uint16_t)strlen((CRC_CHAR_t *)found));
 8012cca:	4620      	mov	r0, r4
 8012ccc:	f7ed fa92 	bl	80001f4 <strlen>
                uint32_t cgev_cid = ATutil_convertStringToInt((uint8_t *)found,
 8012cd0:	b281      	uxth	r1, r0
 8012cd2:	4620      	mov	r0, r4
 8012cd4:	f002 f82e 	bl	8014d34 <ATutil_convertStringToInt>
                p_modem_ctxt->persist.pdn_event.conf_id = atcm_get_configID_for_modem_cid(&p_modem_ctxt->persist,
 8012cd8:	9001      	str	r0, [sp, #4]
 8012cda:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8012cde:	4650      	mov	r0, sl
 8012ce0:	f7fa feae 	bl	800da40 <atcm_get_configID_for_modem_cid>
 8012ce4:	4603      	mov	r3, r0
 8012ce6:	f886 004f 	strb.w	r0, [r6, #79]	; 0x4f
                PRINT_DBG("+CGEV modem cid=%ld (user conf Id =%d)", cgev_cid, p_modem_ctxt->persist.pdn_event.conf_id)
 8012cea:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012cee:	9a01      	ldr	r2, [sp, #4]
 8012cf0:	4940      	ldr	r1, [pc, #256]	; (8012df4 <fRspAnalyze_CGEV+0x370>)
 8012cf2:	4658      	mov	r0, fp
 8012cf4:	f012 ffbc 	bl	8025c70 <sprintf>
 8012cf8:	4658      	mov	r0, fp
 8012cfa:	f00c fa0a 	bl	801f112 <crs_strlen>
 8012cfe:	b283      	uxth	r3, r0
 8012d00:	465a      	mov	r2, fp
 8012d02:	2102      	movs	r1, #2
 8012d04:	4608      	mov	r0, r1
 8012d06:	f00c fa47 	bl	801f198 <traceIF_itmPrint>
 8012d0a:	4658      	mov	r0, fp
 8012d0c:	f00c fa01 	bl	801f112 <crs_strlen>
 8012d10:	b283      	uxth	r3, r0
 8012d12:	465a      	mov	r2, fp
 8012d14:	2102      	movs	r1, #2
 8012d16:	4608      	mov	r0, r1
 8012d18:	f00c fa60 	bl	801f1dc <traceIF_uartPrint>
 8012d1c:	e762      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<ME>")
 8012d1e:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012d22:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 8012dfc <fRspAnalyze_CGEV+0x378>
 8012d26:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012d2a:	f8cb 0000 	str.w	r0, [fp]
 8012d2e:	f8cb 1004 	str.w	r1, [fp, #4]
 8012d32:	f8cb 2008 	str.w	r2, [fp, #8]
 8012d36:	f8cb 300c 	str.w	r3, [fp, #12]
 8012d3a:	4658      	mov	r0, fp
 8012d3c:	f00c f9e9 	bl	801f112 <crs_strlen>
 8012d40:	b283      	uxth	r3, r0
 8012d42:	465a      	mov	r2, fp
 8012d44:	2102      	movs	r1, #2
 8012d46:	4608      	mov	r0, r1
 8012d48:	f00c fa26 	bl	801f198 <traceIF_itmPrint>
 8012d4c:	4658      	mov	r0, fp
 8012d4e:	f00c f9e0 	bl	801f112 <crs_strlen>
 8012d52:	b283      	uxth	r3, r0
 8012d54:	465a      	mov	r2, fp
 8012d56:	2102      	movs	r1, #2
 8012d58:	4608      	mov	r0, r1
 8012d5a:	f00c fa3f 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_origine = CGEV_EVENT_ORIGINE_ME;
 8012d5e:	2302      	movs	r3, #2
 8012d60:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
 8012d64:	e73e      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<PDN>")
 8012d66:	f8df b054 	ldr.w	fp, [pc, #84]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012d6a:	f8df c094 	ldr.w	ip, [pc, #148]	; 8012e00 <fRspAnalyze_CGEV+0x37c>
 8012d6e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012d72:	f8cb 0000 	str.w	r0, [fp]
 8012d76:	f8cb 1004 	str.w	r1, [fp, #4]
 8012d7a:	f8cb 2008 	str.w	r2, [fp, #8]
 8012d7e:	f8cb 300c 	str.w	r3, [fp, #12]
 8012d82:	f89c 3000 	ldrb.w	r3, [ip]
 8012d86:	f88b 3010 	strb.w	r3, [fp, #16]
 8012d8a:	4658      	mov	r0, fp
 8012d8c:	f00c f9c1 	bl	801f112 <crs_strlen>
 8012d90:	b283      	uxth	r3, r0
 8012d92:	465a      	mov	r2, fp
 8012d94:	2102      	movs	r1, #2
 8012d96:	4608      	mov	r0, r1
 8012d98:	f00c f9fe 	bl	801f198 <traceIF_itmPrint>
 8012d9c:	4658      	mov	r0, fp
 8012d9e:	f00c f9b8 	bl	801f112 <crs_strlen>
 8012da2:	b283      	uxth	r3, r0
 8012da4:	465a      	mov	r2, fp
 8012da6:	2102      	movs	r1, #2
 8012da8:	4608      	mov	r0, r1
 8012daa:	f00c fa17 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_scope = CGEV_EVENT_SCOPE_PDN;
 8012dae:	230a      	movs	r3, #10
 8012db0:	f886 304d 	strb.w	r3, [r6, #77]	; 0x4d
 8012db4:	e716      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
 8012db6:	bf00      	nop
 8012db8:	0802feec 	.word	0x0802feec
 8012dbc:	200048dc 	.word	0x200048dc
 8012dc0:	000d0001 	.word	0x000d0001
 8012dc4:	08030128 	.word	0x08030128
 8012dc8:	0802ff14 	.word	0x0802ff14
 8012dcc:	080300b0 	.word	0x080300b0
 8012dd0:	0802ff18 	.word	0x0802ff18
 8012dd4:	0802ff2c 	.word	0x0802ff2c
 8012dd8:	0802ff40 	.word	0x0802ff40
 8012ddc:	0802ff58 	.word	0x0802ff58
 8012de0:	0802ff70 	.word	0x0802ff70
 8012de4:	0802ff8c 	.word	0x0802ff8c
 8012de8:	0802ffa8 	.word	0x0802ffa8
 8012dec:	0802ffc4 	.word	0x0802ffc4
 8012df0:	0802ffe0 	.word	0x0802ffe0
 8012df4:	08030034 	.word	0x08030034
 8012df8:	0802ff1c 	.word	0x0802ff1c
 8012dfc:	0802ff30 	.word	0x0802ff30
 8012e00:	0802ff44 	.word	0x0802ff44
          PRINT_DBG("<ACT>")
 8012e04:	f8df b3fc 	ldr.w	fp, [pc, #1020]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012e08:	f8df c40c 	ldr.w	ip, [pc, #1036]	; 8013218 <fRspAnalyze_CGEV+0x794>
 8012e0c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012e10:	f8cb 0000 	str.w	r0, [fp]
 8012e14:	f8cb 1004 	str.w	r1, [fp, #4]
 8012e18:	f8cb 2008 	str.w	r2, [fp, #8]
 8012e1c:	f8cb 300c 	str.w	r3, [fp, #12]
 8012e20:	f89c 3000 	ldrb.w	r3, [ip]
 8012e24:	f88b 3010 	strb.w	r3, [fp, #16]
 8012e28:	4658      	mov	r0, fp
 8012e2a:	f00c f972 	bl	801f112 <crs_strlen>
 8012e2e:	b283      	uxth	r3, r0
 8012e30:	465a      	mov	r2, fp
 8012e32:	2102      	movs	r1, #2
 8012e34:	4608      	mov	r0, r1
 8012e36:	f00c f9af 	bl	801f198 <traceIF_itmPrint>
 8012e3a:	4658      	mov	r0, fp
 8012e3c:	f00c f969 	bl	801f112 <crs_strlen>
 8012e40:	b283      	uxth	r3, r0
 8012e42:	465a      	mov	r2, fp
 8012e44:	2102      	movs	r1, #2
 8012e46:	4608      	mov	r0, r1
 8012e48:	f00c f9c8 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_ACTIVATION;
 8012e4c:	230c      	movs	r3, #12
 8012e4e:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012e52:	e6c7      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<DEACT>")
 8012e54:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012e58:	f8df c3c0 	ldr.w	ip, [pc, #960]	; 801321c <fRspAnalyze_CGEV+0x798>
 8012e5c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012e60:	f8cb 0000 	str.w	r0, [fp]
 8012e64:	f8cb 1004 	str.w	r1, [fp, #4]
 8012e68:	f8cb 2008 	str.w	r2, [fp, #8]
 8012e6c:	f8cb 300c 	str.w	r3, [fp, #12]
 8012e70:	f8bc 2000 	ldrh.w	r2, [ip]
 8012e74:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8012e78:	f8ab 2010 	strh.w	r2, [fp, #16]
 8012e7c:	f88b 3012 	strb.w	r3, [fp, #18]
 8012e80:	4658      	mov	r0, fp
 8012e82:	f00c f946 	bl	801f112 <crs_strlen>
 8012e86:	b283      	uxth	r3, r0
 8012e88:	465a      	mov	r2, fp
 8012e8a:	2102      	movs	r1, #2
 8012e8c:	4608      	mov	r0, r1
 8012e8e:	f00c f983 	bl	801f198 <traceIF_itmPrint>
 8012e92:	4658      	mov	r0, fp
 8012e94:	f00c f93d 	bl	801f112 <crs_strlen>
 8012e98:	b283      	uxth	r3, r0
 8012e9a:	465a      	mov	r2, fp
 8012e9c:	2102      	movs	r1, #2
 8012e9e:	4608      	mov	r0, r1
 8012ea0:	f00c f99c 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_DEACTIVATION;
 8012ea4:	230d      	movs	r3, #13
 8012ea6:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012eaa:	e69b      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<REJECT>")
 8012eac:	f8df b354 	ldr.w	fp, [pc, #852]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012eb0:	f8df c36c 	ldr.w	ip, [pc, #876]	; 8013220 <fRspAnalyze_CGEV+0x79c>
 8012eb4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012eb8:	f8cb 0000 	str.w	r0, [fp]
 8012ebc:	f8cb 1004 	str.w	r1, [fp, #4]
 8012ec0:	f8cb 2008 	str.w	r2, [fp, #8]
 8012ec4:	f8cb 300c 	str.w	r3, [fp, #12]
 8012ec8:	f8dc 0000 	ldr.w	r0, [ip]
 8012ecc:	f8cb 0010 	str.w	r0, [fp, #16]
 8012ed0:	4658      	mov	r0, fp
 8012ed2:	f00c f91e 	bl	801f112 <crs_strlen>
 8012ed6:	b283      	uxth	r3, r0
 8012ed8:	465a      	mov	r2, fp
 8012eda:	2102      	movs	r1, #2
 8012edc:	4608      	mov	r0, r1
 8012ede:	f00c f95b 	bl	801f198 <traceIF_itmPrint>
 8012ee2:	4658      	mov	r0, fp
 8012ee4:	f00c f915 	bl	801f112 <crs_strlen>
 8012ee8:	b283      	uxth	r3, r0
 8012eea:	465a      	mov	r2, fp
 8012eec:	2102      	movs	r1, #2
 8012eee:	4608      	mov	r0, r1
 8012ef0:	f00c f974 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_REJECT;
 8012ef4:	230e      	movs	r3, #14
 8012ef6:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012efa:	e673      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<DETACH>")
 8012efc:	f8df b304 	ldr.w	fp, [pc, #772]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012f00:	f8df c320 	ldr.w	ip, [pc, #800]	; 8013224 <fRspAnalyze_CGEV+0x7a0>
 8012f04:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012f08:	f8cb 0000 	str.w	r0, [fp]
 8012f0c:	f8cb 1004 	str.w	r1, [fp, #4]
 8012f10:	f8cb 2008 	str.w	r2, [fp, #8]
 8012f14:	f8cb 300c 	str.w	r3, [fp, #12]
 8012f18:	f8dc 0000 	ldr.w	r0, [ip]
 8012f1c:	f8cb 0010 	str.w	r0, [fp, #16]
 8012f20:	4658      	mov	r0, fp
 8012f22:	f00c f8f6 	bl	801f112 <crs_strlen>
 8012f26:	b283      	uxth	r3, r0
 8012f28:	465a      	mov	r2, fp
 8012f2a:	2102      	movs	r1, #2
 8012f2c:	4608      	mov	r0, r1
 8012f2e:	f00c f933 	bl	801f198 <traceIF_itmPrint>
 8012f32:	4658      	mov	r0, fp
 8012f34:	f00c f8ed 	bl	801f112 <crs_strlen>
 8012f38:	b283      	uxth	r3, r0
 8012f3a:	465a      	mov	r2, fp
 8012f3c:	2102      	movs	r1, #2
 8012f3e:	4608      	mov	r0, r1
 8012f40:	f00c f94c 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_DETACH;
 8012f44:	230f      	movs	r3, #15
 8012f46:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
          p_modem_ctxt->persist.pdn_event.conf_id = CS_PDN_ALL;
 8012f4a:	230d      	movs	r3, #13
 8012f4c:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
 8012f50:	e648      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<CLASS>")
 8012f52:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012f56:	f8df c2d0 	ldr.w	ip, [pc, #720]	; 8013228 <fRspAnalyze_CGEV+0x7a4>
 8012f5a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012f5e:	f8cb 0000 	str.w	r0, [fp]
 8012f62:	f8cb 1004 	str.w	r1, [fp, #4]
 8012f66:	f8cb 2008 	str.w	r2, [fp, #8]
 8012f6a:	f8cb 300c 	str.w	r3, [fp, #12]
 8012f6e:	f8bc 2000 	ldrh.w	r2, [ip]
 8012f72:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8012f76:	f8ab 2010 	strh.w	r2, [fp, #16]
 8012f7a:	f88b 3012 	strb.w	r3, [fp, #18]
 8012f7e:	4658      	mov	r0, fp
 8012f80:	f00c f8c7 	bl	801f112 <crs_strlen>
 8012f84:	b283      	uxth	r3, r0
 8012f86:	465a      	mov	r2, fp
 8012f88:	2102      	movs	r1, #2
 8012f8a:	4608      	mov	r0, r1
 8012f8c:	f00c f904 	bl	801f198 <traceIF_itmPrint>
 8012f90:	4658      	mov	r0, fp
 8012f92:	f00c f8be 	bl	801f112 <crs_strlen>
 8012f96:	b283      	uxth	r3, r0
 8012f98:	465a      	mov	r2, fp
 8012f9a:	2102      	movs	r1, #2
 8012f9c:	4608      	mov	r0, r1
 8012f9e:	f00c f91d 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_CLASS;
 8012fa2:	2310      	movs	r3, #16
 8012fa4:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012fa8:	e61c      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<MODIFY>")
 8012faa:	f8df b258 	ldr.w	fp, [pc, #600]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012fae:	f8df c27c 	ldr.w	ip, [pc, #636]	; 801322c <fRspAnalyze_CGEV+0x7a8>
 8012fb2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012fb6:	f8cb 0000 	str.w	r0, [fp]
 8012fba:	f8cb 1004 	str.w	r1, [fp, #4]
 8012fbe:	f8cb 2008 	str.w	r2, [fp, #8]
 8012fc2:	f8cb 300c 	str.w	r3, [fp, #12]
 8012fc6:	f8dc 0000 	ldr.w	r0, [ip]
 8012fca:	f8cb 0010 	str.w	r0, [fp, #16]
 8012fce:	4658      	mov	r0, fp
 8012fd0:	f00c f89f 	bl	801f112 <crs_strlen>
 8012fd4:	b283      	uxth	r3, r0
 8012fd6:	465a      	mov	r2, fp
 8012fd8:	2102      	movs	r1, #2
 8012fda:	4608      	mov	r0, r1
 8012fdc:	f00c f8dc 	bl	801f198 <traceIF_itmPrint>
 8012fe0:	4658      	mov	r0, fp
 8012fe2:	f00c f896 	bl	801f112 <crs_strlen>
 8012fe6:	b283      	uxth	r3, r0
 8012fe8:	465a      	mov	r2, fp
 8012fea:	2102      	movs	r1, #2
 8012fec:	4608      	mov	r0, r1
 8012fee:	f00c f8f5 	bl	801f1dc <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_MODIFY;
 8012ff2:	2311      	movs	r3, #17
 8012ff4:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012ff8:	e5f4      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
              PRINT_ERR("No parameter expected for  NW DETACH")
 8012ffa:	f8df e234 	ldr.w	lr, [pc, #564]	; 8013230 <fRspAnalyze_CGEV+0x7ac>
 8012ffe:	f8df b204 	ldr.w	fp, [pc, #516]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013002:	46f4      	mov	ip, lr
 8013004:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013008:	f8cb 0000 	str.w	r0, [fp]
 801300c:	f8cb 1004 	str.w	r1, [fp, #4]
 8013010:	f8cb 2008 	str.w	r2, [fp, #8]
 8013014:	f8cb 300c 	str.w	r3, [fp, #12]
 8013018:	46e6      	mov	lr, ip
 801301a:	f10b 0b10 	add.w	fp, fp, #16
 801301e:	4b77      	ldr	r3, [pc, #476]	; (80131fc <fRspAnalyze_CGEV+0x778>)
 8013020:	459c      	cmp	ip, r3
 8013022:	d1ee      	bne.n	8013002 <fRspAnalyze_CGEV+0x57e>
 8013024:	f8dc 0000 	ldr.w	r0, [ip]
 8013028:	f8cb 0000 	str.w	r0, [fp]
 801302c:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8013030:	f8ab 3004 	strh.w	r3, [fp, #4]
 8013034:	f8df b1cc 	ldr.w	fp, [pc, #460]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013038:	4658      	mov	r0, fp
 801303a:	f00c f86a 	bl	801f112 <crs_strlen>
 801303e:	b283      	uxth	r3, r0
 8013040:	465a      	mov	r2, fp
 8013042:	2110      	movs	r1, #16
 8013044:	2002      	movs	r0, #2
 8013046:	f00c f8a7 	bl	801f198 <traceIF_itmPrint>
 801304a:	4658      	mov	r0, fp
 801304c:	f00c f861 	bl	801f112 <crs_strlen>
 8013050:	b283      	uxth	r3, r0
 8013052:	465a      	mov	r2, fp
 8013054:	2110      	movs	r1, #16
 8013056:	2002      	movs	r0, #2
 8013058:	f00c f8c0 	bl	801f1dc <traceIF_uartPrint>
 801305c:	e5c2      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
              PRINT_DBG("event type (= %d) ignored", p_modem_ctxt->persist.pdn_event.event_type)
 801305e:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013062:	4967      	ldr	r1, [pc, #412]	; (8013200 <fRspAnalyze_CGEV+0x77c>)
 8013064:	4658      	mov	r0, fp
 8013066:	f012 fe03 	bl	8025c70 <sprintf>
 801306a:	4658      	mov	r0, fp
 801306c:	f00c f851 	bl	801f112 <crs_strlen>
 8013070:	b283      	uxth	r3, r0
 8013072:	465a      	mov	r2, fp
 8013074:	2102      	movs	r1, #2
 8013076:	4608      	mov	r0, r1
 8013078:	f00c f88e 	bl	801f198 <traceIF_itmPrint>
 801307c:	4658      	mov	r0, fp
 801307e:	f00c f848 	bl	801f112 <crs_strlen>
 8013082:	b283      	uxth	r3, r0
 8013084:	465a      	mov	r2, fp
 8013086:	2102      	movs	r1, #2
 8013088:	4608      	mov	r0, r1
 801308a:	f00c f8a7 	bl	801f1dc <traceIF_uartPrint>
 801308e:	e5a9      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
            PRINT_DBG("ME events ignored")
 8013090:	f8df b170 	ldr.w	fp, [pc, #368]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013094:	f8df c19c 	ldr.w	ip, [pc, #412]	; 8013234 <fRspAnalyze_CGEV+0x7b0>
 8013098:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801309c:	f8cb 0000 	str.w	r0, [fp]
 80130a0:	f8cb 1004 	str.w	r1, [fp, #4]
 80130a4:	f8cb 2008 	str.w	r2, [fp, #8]
 80130a8:	f8cb 300c 	str.w	r3, [fp, #12]
 80130ac:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80130b0:	f8cb 0010 	str.w	r0, [fp, #16]
 80130b4:	f8cb 1014 	str.w	r1, [fp, #20]
 80130b8:	f8cb 2018 	str.w	r2, [fp, #24]
 80130bc:	f89c 3000 	ldrb.w	r3, [ip]
 80130c0:	f88b 301c 	strb.w	r3, [fp, #28]
 80130c4:	4658      	mov	r0, fp
 80130c6:	f00c f824 	bl	801f112 <crs_strlen>
 80130ca:	b283      	uxth	r3, r0
 80130cc:	465a      	mov	r2, fp
 80130ce:	2102      	movs	r1, #2
 80130d0:	4608      	mov	r0, r1
 80130d2:	f00c f861 	bl	801f198 <traceIF_itmPrint>
 80130d6:	4658      	mov	r0, fp
 80130d8:	f00c f81b 	bl	801f112 <crs_strlen>
 80130dc:	b283      	uxth	r3, r0
 80130de:	465a      	mov	r2, fp
 80130e0:	2102      	movs	r1, #2
 80130e2:	4608      	mov	r0, r1
 80130e4:	f00c f87a 	bl	801f1dc <traceIF_uartPrint>
 80130e8:	e57c      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
      p_modem_ctxt->persist.urc_avail_pdn_event = AT_TRUE;
 80130ea:	2301      	movs	r3, #1
 80130ec:	f886 3020 	strb.w	r3, [r6, #32]
 80130f0:	e07b      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
      PRINT_ERR("an +CGEV URC still not reported, ignore this one")
 80130f2:	4c44      	ldr	r4, [pc, #272]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 80130f4:	2242      	movs	r2, #66	; 0x42
 80130f6:	4944      	ldr	r1, [pc, #272]	; (8013208 <fRspAnalyze_CGEV+0x784>)
 80130f8:	4620      	mov	r0, r4
 80130fa:	f012 ff09 	bl	8025f10 <memcpy>
 80130fe:	4620      	mov	r0, r4
 8013100:	f00c f807 	bl	801f112 <crs_strlen>
 8013104:	b283      	uxth	r3, r0
 8013106:	4622      	mov	r2, r4
 8013108:	2110      	movs	r1, #16
 801310a:	2002      	movs	r0, #2
 801310c:	f00c f844 	bl	801f198 <traceIF_itmPrint>
 8013110:	4620      	mov	r0, r4
 8013112:	f00b fffe 	bl	801f112 <crs_strlen>
 8013116:	b283      	uxth	r3, r0
 8013118:	4622      	mov	r2, r4
 801311a:	2110      	movs	r1, #16
 801311c:	2002      	movs	r0, #2
 801311e:	f00c f85d 	bl	801f1dc <traceIF_uartPrint>
      retval = ATACTION_RSP_ERROR;
 8013122:	2004      	movs	r0, #4
 8013124:	e066      	b.n	80131f4 <fRspAnalyze_CGEV+0x770>
    if ((p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8013126:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8013128:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 801312c:	4937      	ldr	r1, [pc, #220]	; (801320c <fRspAnalyze_CGEV+0x788>)
 801312e:	428b      	cmp	r3, r1
 8013130:	d017      	beq.n	8013162 <fRspAnalyze_CGEV+0x6de>
      PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
 8013132:	4c34      	ldr	r4, [pc, #208]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 8013134:	4936      	ldr	r1, [pc, #216]	; (8013210 <fRspAnalyze_CGEV+0x78c>)
 8013136:	4620      	mov	r0, r4
 8013138:	f012 fd9a 	bl	8025c70 <sprintf>
 801313c:	4620      	mov	r0, r4
 801313e:	f00b ffe8 	bl	801f112 <crs_strlen>
 8013142:	b283      	uxth	r3, r0
 8013144:	4622      	mov	r2, r4
 8013146:	2102      	movs	r1, #2
 8013148:	4608      	mov	r0, r1
 801314a:	f00c f825 	bl	801f198 <traceIF_itmPrint>
 801314e:	4620      	mov	r0, r4
 8013150:	f00b ffdf 	bl	801f112 <crs_strlen>
 8013154:	b283      	uxth	r3, r0
 8013156:	4622      	mov	r2, r4
 8013158:	2102      	movs	r1, #2
 801315a:	4608      	mov	r0, r1
 801315c:	f00c f83e 	bl	801f1dc <traceIF_uartPrint>
 8013160:	e043      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 8013162:	2241      	movs	r2, #65	; 0x41
 8013164:	2100      	movs	r1, #0
 8013166:	a803      	add	r0, sp, #12
 8013168:	f012 fdf5 	bl	8025d56 <memset>
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 801316c:	8969      	ldrh	r1, [r5, #10]
      (void) memcpy((void *) & (ip_addr_info.ip_addr_value),
 801316e:	89ea      	ldrh	r2, [r5, #14]
 8013170:	4439      	add	r1, r7
 8013172:	f10d 000d 	add.w	r0, sp, #13
 8013176:	f012 fecb 	bl	8025f10 <memcpy>
      PRINT_DBG("<PDP_addr>=%s", (AT_CHAR_t *)&ip_addr_info.ip_addr_value)
 801317a:	4c22      	ldr	r4, [pc, #136]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 801317c:	f10d 020d 	add.w	r2, sp, #13
 8013180:	4924      	ldr	r1, [pc, #144]	; (8013214 <fRspAnalyze_CGEV+0x790>)
 8013182:	4620      	mov	r0, r4
 8013184:	f012 fd74 	bl	8025c70 <sprintf>
 8013188:	4620      	mov	r0, r4
 801318a:	f00b ffc2 	bl	801f112 <crs_strlen>
 801318e:	b283      	uxth	r3, r0
 8013190:	4622      	mov	r2, r4
 8013192:	2102      	movs	r1, #2
 8013194:	4608      	mov	r0, r1
 8013196:	f00b ffff 	bl	801f198 <traceIF_itmPrint>
 801319a:	4620      	mov	r0, r4
 801319c:	f00b ffb9 	bl	801f112 <crs_strlen>
 80131a0:	b283      	uxth	r3, r0
 80131a2:	4622      	mov	r2, r4
 80131a4:	2102      	movs	r1, #2
 80131a6:	4608      	mov	r0, r1
 80131a8:	f00c f818 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->persist.pdn_event.conf_id = find_user_cid_with_matching_ip_addr(&p_modem_ctxt->persist,
 80131ac:	a903      	add	r1, sp, #12
 80131ae:	f106 000c 	add.w	r0, r6, #12
 80131b2:	f7fb fd3d 	bl	800ec30 <find_user_cid_with_matching_ip_addr>
 80131b6:	f886 004f 	strb.w	r0, [r6, #79]	; 0x4f
 80131ba:	e016      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
    }
  }
  else
  {
    PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
 80131bc:	4c11      	ldr	r4, [pc, #68]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 80131be:	4914      	ldr	r1, [pc, #80]	; (8013210 <fRspAnalyze_CGEV+0x78c>)
 80131c0:	4620      	mov	r0, r4
 80131c2:	f012 fd55 	bl	8025c70 <sprintf>
 80131c6:	4620      	mov	r0, r4
 80131c8:	f00b ffa3 	bl	801f112 <crs_strlen>
 80131cc:	b283      	uxth	r3, r0
 80131ce:	4622      	mov	r2, r4
 80131d0:	2102      	movs	r1, #2
 80131d2:	4608      	mov	r0, r1
 80131d4:	f00b ffe0 	bl	801f198 <traceIF_itmPrint>
 80131d8:	4620      	mov	r0, r4
 80131da:	f00b ff9a 	bl	801f112 <crs_strlen>
 80131de:	b283      	uxth	r3, r0
 80131e0:	4622      	mov	r2, r4
 80131e2:	2102      	movs	r1, #2
 80131e4:	4608      	mov	r0, r1
 80131e6:	f00b fff9 	bl	801f1dc <traceIF_uartPrint>
  }
  END_PARAM_LOOP()
 80131ea:	f1b9 0f00 	cmp.w	r9, #0
 80131ee:	f43f ac7f 	beq.w	8012af0 <fRspAnalyze_CGEV+0x6c>
 80131f2:	2010      	movs	r0, #16

  return (retval);
}
 80131f4:	b015      	add	sp, #84	; 0x54
 80131f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80131fa:	bf00      	nop
 80131fc:	0803002c 	.word	0x0803002c
 8013200:	08030068 	.word	0x08030068
 8013204:	200048dc 	.word	0x200048dc
 8013208:	080300c8 	.word	0x080300c8
 801320c:	000d0001 	.word	0x000d0001
 8013210:	08030128 	.word	0x08030128
 8013214:	0803010c 	.word	0x0803010c
 8013218:	0802ff5c 	.word	0x0802ff5c
 801321c:	0802ff78 	.word	0x0802ff78
 8013220:	0802ff94 	.word	0x0802ff94
 8013224:	0802ffb0 	.word	0x0802ffb0
 8013228:	0802ffcc 	.word	0x0802ffcc
 801322c:	0802ffe8 	.word	0x0802ffe8
 8013230:	0802fffc 	.word	0x0802fffc
 8013234:	08030090 	.word	0x08030090

08013238 <fRspAnalyze_CSQ>:

at_action_rsp_t fRspAnalyze_CSQ(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801323c:	4607      	mov	r7, r0
 801323e:	4689      	mov	r9, r1
 8013240:	4690      	mov	r8, r2
 8013242:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CSQ()")
 8013244:	4d44      	ldr	r5, [pc, #272]	; (8013358 <fRspAnalyze_CSQ+0x120>)
 8013246:	4c45      	ldr	r4, [pc, #276]	; (801335c <fRspAnalyze_CSQ+0x124>)
 8013248:	f105 0e20 	add.w	lr, r5, #32
 801324c:	46ac      	mov	ip, r5
 801324e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013252:	6020      	str	r0, [r4, #0]
 8013254:	6061      	str	r1, [r4, #4]
 8013256:	60a2      	str	r2, [r4, #8]
 8013258:	60e3      	str	r3, [r4, #12]
 801325a:	4665      	mov	r5, ip
 801325c:	3410      	adds	r4, #16
 801325e:	45f4      	cmp	ip, lr
 8013260:	d1f4      	bne.n	801324c <fRspAnalyze_CSQ+0x14>
 8013262:	f8dc 0000 	ldr.w	r0, [ip]
 8013266:	6020      	str	r0, [r4, #0]
 8013268:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 801326c:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013270:	80a2      	strh	r2, [r4, #4]
 8013272:	71a3      	strb	r3, [r4, #6]
 8013274:	4c39      	ldr	r4, [pc, #228]	; (801335c <fRspAnalyze_CSQ+0x124>)
 8013276:	4620      	mov	r0, r4
 8013278:	f00b ff4b 	bl	801f112 <crs_strlen>
 801327c:	b283      	uxth	r3, r0
 801327e:	4622      	mov	r2, r4
 8013280:	2104      	movs	r1, #4
 8013282:	2002      	movs	r0, #2
 8013284:	f00b ff88 	bl	801f198 <traceIF_itmPrint>
 8013288:	4620      	mov	r0, r4
 801328a:	f00b ff42 	bl	801f112 <crs_strlen>
 801328e:	b283      	uxth	r3, r0
 8013290:	4622      	mov	r2, r4
 8013292:	2104      	movs	r1, #4
 8013294:	2002      	movs	r0, #2
 8013296:	f00b ffa1 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for CSQ */
  /* for EXECUTION COMMAND only  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 801329a:	8b3b      	ldrh	r3, [r7, #24]
 801329c:	2b04      	cmp	r3, #4
 801329e:	d002      	beq.n	80132a6 <fRspAnalyze_CSQ+0x6e>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 80132a0:	2010      	movs	r0, #16
 80132a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    START_PARAM_LOOP()
 80132a6:	2400      	movs	r4, #0
 80132a8:	4632      	mov	r2, r6
 80132aa:	4641      	mov	r1, r8
 80132ac:	4638      	mov	r0, r7
 80132ae:	f7f9 f8cb 	bl	800c448 <atcc_extractElement>
 80132b2:	2801      	cmp	r0, #1
 80132b4:	d000      	beq.n	80132b8 <fRspAnalyze_CSQ+0x80>
 80132b6:	2401      	movs	r4, #1
 80132b8:	89f1      	ldrh	r1, [r6, #14]
 80132ba:	b129      	cbz	r1, 80132c8 <fRspAnalyze_CSQ+0x90>
    if (element_infos->param_rank == 2U)
 80132bc:	8933      	ldrh	r3, [r6, #8]
 80132be:	2b02      	cmp	r3, #2
 80132c0:	d005      	beq.n	80132ce <fRspAnalyze_CSQ+0x96>
    if (element_infos->param_rank == 3U)
 80132c2:	8933      	ldrh	r3, [r6, #8]
 80132c4:	2b03      	cmp	r3, #3
 80132c6:	d024      	beq.n	8013312 <fRspAnalyze_CSQ+0xda>
    END_PARAM_LOOP()
 80132c8:	2c00      	cmp	r4, #0
 80132ca:	d1e9      	bne.n	80132a0 <fRspAnalyze_CSQ+0x68>
 80132cc:	e7ec      	b.n	80132a8 <fRspAnalyze_CSQ+0x70>
      uint32_t rssi = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80132ce:	8970      	ldrh	r0, [r6, #10]
 80132d0:	4440      	add	r0, r8
 80132d2:	f001 fd2f 	bl	8014d34 <ATutil_convertStringToInt>
 80132d6:	4682      	mov	sl, r0
      PRINT_DBG("+CSQ rssi=%ld", rssi)
 80132d8:	4d20      	ldr	r5, [pc, #128]	; (801335c <fRspAnalyze_CSQ+0x124>)
 80132da:	4602      	mov	r2, r0
 80132dc:	4920      	ldr	r1, [pc, #128]	; (8013360 <fRspAnalyze_CSQ+0x128>)
 80132de:	4628      	mov	r0, r5
 80132e0:	f012 fcc6 	bl	8025c70 <sprintf>
 80132e4:	4628      	mov	r0, r5
 80132e6:	f00b ff14 	bl	801f112 <crs_strlen>
 80132ea:	b283      	uxth	r3, r0
 80132ec:	462a      	mov	r2, r5
 80132ee:	2102      	movs	r1, #2
 80132f0:	4608      	mov	r0, r1
 80132f2:	f00b ff51 	bl	801f198 <traceIF_itmPrint>
 80132f6:	4628      	mov	r0, r5
 80132f8:	f00b ff0b 	bl	801f112 <crs_strlen>
 80132fc:	b283      	uxth	r3, r0
 80132fe:	462a      	mov	r2, r5
 8013300:	2102      	movs	r1, #2
 8013302:	4608      	mov	r0, r1
 8013304:	f00b ff6a 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->SID_ctxt.signal_quality->rssi = (uint8_t)rssi;
 8013308:	f8d9 3660 	ldr.w	r3, [r9, #1632]	; 0x660
 801330c:	f883 a000 	strb.w	sl, [r3]
 8013310:	e7d7      	b.n	80132c2 <fRspAnalyze_CSQ+0x8a>
      uint32_t ber = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013312:	8970      	ldrh	r0, [r6, #10]
 8013314:	89f1      	ldrh	r1, [r6, #14]
 8013316:	4440      	add	r0, r8
 8013318:	f001 fd0c 	bl	8014d34 <ATutil_convertStringToInt>
 801331c:	4682      	mov	sl, r0
      PRINT_DBG("+CSQ ber=%ld", ber)
 801331e:	4d0f      	ldr	r5, [pc, #60]	; (801335c <fRspAnalyze_CSQ+0x124>)
 8013320:	4602      	mov	r2, r0
 8013322:	4910      	ldr	r1, [pc, #64]	; (8013364 <fRspAnalyze_CSQ+0x12c>)
 8013324:	4628      	mov	r0, r5
 8013326:	f012 fca3 	bl	8025c70 <sprintf>
 801332a:	4628      	mov	r0, r5
 801332c:	f00b fef1 	bl	801f112 <crs_strlen>
 8013330:	b283      	uxth	r3, r0
 8013332:	462a      	mov	r2, r5
 8013334:	2102      	movs	r1, #2
 8013336:	4608      	mov	r0, r1
 8013338:	f00b ff2e 	bl	801f198 <traceIF_itmPrint>
 801333c:	4628      	mov	r0, r5
 801333e:	f00b fee8 	bl	801f112 <crs_strlen>
 8013342:	b283      	uxth	r3, r0
 8013344:	462a      	mov	r2, r5
 8013346:	2102      	movs	r1, #2
 8013348:	4608      	mov	r0, r1
 801334a:	f00b ff47 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->SID_ctxt.signal_quality->ber = (uint8_t)ber;
 801334e:	f8d9 3660 	ldr.w	r3, [r9, #1632]	; 0x660
 8013352:	f883 a001 	strb.w	sl, [r3, #1]
 8013356:	e7b7      	b.n	80132c8 <fRspAnalyze_CSQ+0x90>
 8013358:	08030154 	.word	0x08030154
 801335c:	200048dc 	.word	0x200048dc
 8013360:	0803017c 	.word	0x0803017c
 8013364:	08030198 	.word	0x08030198

08013368 <fRspAnalyze_CGPADDR>:

at_action_rsp_t fRspAnalyze_CGPADDR(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                    const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013368:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801336c:	b092      	sub	sp, #72	; 0x48
 801336e:	4606      	mov	r6, r0
 8013370:	4689      	mov	r9, r1
 8013372:	4690      	mov	r8, r2
 8013374:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGPADDR()")
 8013376:	4c59      	ldr	r4, [pc, #356]	; (80134dc <fRspAnalyze_CGPADDR+0x174>)
 8013378:	4d59      	ldr	r5, [pc, #356]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 801337a:	f104 0e20 	add.w	lr, r4, #32
 801337e:	46a4      	mov	ip, r4
 8013380:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013384:	6028      	str	r0, [r5, #0]
 8013386:	6069      	str	r1, [r5, #4]
 8013388:	60aa      	str	r2, [r5, #8]
 801338a:	60eb      	str	r3, [r5, #12]
 801338c:	4664      	mov	r4, ip
 801338e:	3510      	adds	r5, #16
 8013390:	45f4      	cmp	ip, lr
 8013392:	d1f4      	bne.n	801337e <fRspAnalyze_CGPADDR+0x16>
 8013394:	cc03      	ldmia	r4!, {r0, r1}
 8013396:	6028      	str	r0, [r5, #0]
 8013398:	6069      	str	r1, [r5, #4]
 801339a:	8822      	ldrh	r2, [r4, #0]
 801339c:	78a3      	ldrb	r3, [r4, #2]
 801339e:	812a      	strh	r2, [r5, #8]
 80133a0:	72ab      	strb	r3, [r5, #10]
 80133a2:	4c4f      	ldr	r4, [pc, #316]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 80133a4:	4620      	mov	r0, r4
 80133a6:	f00b feb4 	bl	801f112 <crs_strlen>
 80133aa:	b283      	uxth	r3, r0
 80133ac:	4622      	mov	r2, r4
 80133ae:	2104      	movs	r1, #4
 80133b0:	2002      	movs	r0, #2
 80133b2:	f00b fef1 	bl	801f198 <traceIF_itmPrint>
 80133b6:	4620      	mov	r0, r4
 80133b8:	f00b feab 	bl	801f112 <crs_strlen>
 80133bc:	b283      	uxth	r3, r0
 80133be:	4622      	mov	r2, r4
 80133c0:	2104      	movs	r1, #4
 80133c2:	2002      	movs	r0, #2
 80133c4:	f00b ff0a 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for CGPADDR */
  /* for WRITE COMMAND only  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80133c8:	8b33      	ldrh	r3, [r6, #24]
 80133ca:	2b03      	cmp	r3, #3
 80133cc:	d003      	beq.n	80133d6 <fRspAnalyze_CGPADDR+0x6e>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 80133ce:	2010      	movs	r0, #16
 80133d0:	b012      	add	sp, #72	; 0x48
 80133d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    START_PARAM_LOOP()
 80133d6:	2400      	movs	r4, #0
 80133d8:	463a      	mov	r2, r7
 80133da:	4641      	mov	r1, r8
 80133dc:	4630      	mov	r0, r6
 80133de:	f7f9 f833 	bl	800c448 <atcc_extractElement>
 80133e2:	2801      	cmp	r0, #1
 80133e4:	d000      	beq.n	80133e8 <fRspAnalyze_CGPADDR+0x80>
 80133e6:	2401      	movs	r4, #1
 80133e8:	89fb      	ldrh	r3, [r7, #14]
 80133ea:	b913      	cbnz	r3, 80133f2 <fRspAnalyze_CGPADDR+0x8a>
    END_PARAM_LOOP()
 80133ec:	2c00      	cmp	r4, #0
 80133ee:	d1ee      	bne.n	80133ce <fRspAnalyze_CGPADDR+0x66>
 80133f0:	e7f2      	b.n	80133d8 <fRspAnalyze_CGPADDR+0x70>
    PRINT_DBG("+CGPADDR param_rank = %d", element_infos->param_rank)
 80133f2:	4d3b      	ldr	r5, [pc, #236]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 80133f4:	893a      	ldrh	r2, [r7, #8]
 80133f6:	493b      	ldr	r1, [pc, #236]	; (80134e4 <fRspAnalyze_CGPADDR+0x17c>)
 80133f8:	4628      	mov	r0, r5
 80133fa:	f012 fc39 	bl	8025c70 <sprintf>
 80133fe:	4628      	mov	r0, r5
 8013400:	f00b fe87 	bl	801f112 <crs_strlen>
 8013404:	b283      	uxth	r3, r0
 8013406:	462a      	mov	r2, r5
 8013408:	2102      	movs	r1, #2
 801340a:	4608      	mov	r0, r1
 801340c:	f00b fec4 	bl	801f198 <traceIF_itmPrint>
 8013410:	4628      	mov	r0, r5
 8013412:	f00b fe7e 	bl	801f112 <crs_strlen>
 8013416:	b283      	uxth	r3, r0
 8013418:	462a      	mov	r2, r5
 801341a:	2102      	movs	r1, #2
 801341c:	4608      	mov	r0, r1
 801341e:	f00b fedd 	bl	801f1dc <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 8013422:	893b      	ldrh	r3, [r7, #8]
 8013424:	2b02      	cmp	r3, #2
 8013426:	d039      	beq.n	801349c <fRspAnalyze_CGPADDR+0x134>
    else if ((element_infos->param_rank == 3U) || (element_infos->param_rank == 4U))
 8013428:	3b03      	subs	r3, #3
 801342a:	b29b      	uxth	r3, r3
 801342c:	2b01      	cmp	r3, #1
 801342e:	d8dd      	bhi.n	80133ec <fRspAnalyze_CGPADDR+0x84>
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 8013430:	2241      	movs	r2, #65	; 0x41
 8013432:	2100      	movs	r1, #0
 8013434:	a801      	add	r0, sp, #4
 8013436:	f012 fc8e 	bl	8025d56 <memset>
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 801343a:	8979      	ldrh	r1, [r7, #10]
      (void) memcpy((void *) & (ip_addr_info.ip_addr_value),
 801343c:	89fa      	ldrh	r2, [r7, #14]
 801343e:	4441      	add	r1, r8
 8013440:	f10d 0005 	add.w	r0, sp, #5
 8013444:	f012 fd64 	bl	8025f10 <memcpy>
      PRINT_DBG("+CGPADDR addr=%s", (AT_CHAR_t *)&ip_addr_info.ip_addr_value)
 8013448:	4d25      	ldr	r5, [pc, #148]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 801344a:	f10d 0205 	add.w	r2, sp, #5
 801344e:	4926      	ldr	r1, [pc, #152]	; (80134e8 <fRspAnalyze_CGPADDR+0x180>)
 8013450:	4628      	mov	r0, r5
 8013452:	f012 fc0d 	bl	8025c70 <sprintf>
 8013456:	4628      	mov	r0, r5
 8013458:	f00b fe5b 	bl	801f112 <crs_strlen>
 801345c:	b283      	uxth	r3, r0
 801345e:	462a      	mov	r2, r5
 8013460:	2102      	movs	r1, #2
 8013462:	4608      	mov	r0, r1
 8013464:	f00b fe98 	bl	801f198 <traceIF_itmPrint>
 8013468:	4628      	mov	r0, r5
 801346a:	f00b fe52 	bl	801f112 <crs_strlen>
 801346e:	b283      	uxth	r3, r0
 8013470:	462a      	mov	r2, r5
 8013472:	2102      	movs	r1, #2
 8013474:	4608      	mov	r0, r1
 8013476:	f00b feb1 	bl	801f1dc <traceIF_uartPrint>
      ip_addr_info.ip_addr_type = atcm_get_ip_address_type((AT_CHAR_t *)&ip_addr_info.ip_addr_value);
 801347a:	f10d 0005 	add.w	r0, sp, #5
 801347e:	f7f9 f9cb 	bl	800c818 <atcm_get_ip_address_type>
 8013482:	f88d 0004 	strb.w	r0, [sp, #4]
      if (element_infos->param_rank == 3U)
 8013486:	893b      	ldrh	r3, [r7, #8]
 8013488:	2b03      	cmp	r3, #3
 801348a:	d1af      	bne.n	80133ec <fRspAnalyze_CGPADDR+0x84>
        atcm_put_IP_address_infos(&p_modem_ctxt->persist, (uint8_t)p_modem_ctxt->CMD_ctxt.modem_cid, &ip_addr_info);
 801348c:	aa01      	add	r2, sp, #4
 801348e:	f899 1734 	ldrb.w	r1, [r9, #1844]	; 0x734
 8013492:	f109 000c 	add.w	r0, r9, #12
 8013496:	f7f9 f97d 	bl	800c794 <atcm_put_IP_address_infos>
 801349a:	e7a7      	b.n	80133ec <fRspAnalyze_CGPADDR+0x84>
      uint32_t modem_cid = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 801349c:	8978      	ldrh	r0, [r7, #10]
 801349e:	89f9      	ldrh	r1, [r7, #14]
 80134a0:	4440      	add	r0, r8
 80134a2:	f001 fc47 	bl	8014d34 <ATutil_convertStringToInt>
 80134a6:	4682      	mov	sl, r0
      PRINT_DBG("+CGPADDR cid=%ld", modem_cid)
 80134a8:	4602      	mov	r2, r0
 80134aa:	4910      	ldr	r1, [pc, #64]	; (80134ec <fRspAnalyze_CGPADDR+0x184>)
 80134ac:	4628      	mov	r0, r5
 80134ae:	f012 fbdf 	bl	8025c70 <sprintf>
 80134b2:	4628      	mov	r0, r5
 80134b4:	f00b fe2d 	bl	801f112 <crs_strlen>
 80134b8:	b283      	uxth	r3, r0
 80134ba:	462a      	mov	r2, r5
 80134bc:	2102      	movs	r1, #2
 80134be:	4608      	mov	r0, r1
 80134c0:	f00b fe6a 	bl	801f198 <traceIF_itmPrint>
 80134c4:	4628      	mov	r0, r5
 80134c6:	f00b fe24 	bl	801f112 <crs_strlen>
 80134ca:	b283      	uxth	r3, r0
 80134cc:	462a      	mov	r2, r5
 80134ce:	2102      	movs	r1, #2
 80134d0:	4608      	mov	r0, r1
 80134d2:	f00b fe83 	bl	801f1dc <traceIF_uartPrint>
      p_modem_ctxt->CMD_ctxt.modem_cid = modem_cid;
 80134d6:	f8c9 a734 	str.w	sl, [r9, #1844]	; 0x734
 80134da:	e787      	b.n	80133ec <fRspAnalyze_CGPADDR+0x84>
 80134dc:	080301b0 	.word	0x080301b0
 80134e0:	200048dc 	.word	0x200048dc
 80134e4:	080301dc 	.word	0x080301dc
 80134e8:	0803021c 	.word	0x0803021c
 80134ec:	08030200 	.word	0x08030200

080134f0 <fRspAnalyze_CPSMS>:

at_action_rsp_t fRspAnalyze_CPSMS(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80134f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80134f4:	4607      	mov	r7, r0
 80134f6:	4690      	mov	r8, r2
 80134f8:	461e      	mov	r6, r3
  UNUSED(p_modem_ctxt);
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CPSMS()")
 80134fa:	4c7b      	ldr	r4, [pc, #492]	; (80136e8 <fRspAnalyze_CPSMS+0x1f8>)
 80134fc:	4d7b      	ldr	r5, [pc, #492]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 80134fe:	f104 0e20 	add.w	lr, r4, #32
 8013502:	46a4      	mov	ip, r4
 8013504:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013508:	6028      	str	r0, [r5, #0]
 801350a:	6069      	str	r1, [r5, #4]
 801350c:	60aa      	str	r2, [r5, #8]
 801350e:	60eb      	str	r3, [r5, #12]
 8013510:	4664      	mov	r4, ip
 8013512:	3510      	adds	r5, #16
 8013514:	45f4      	cmp	ip, lr
 8013516:	d1f4      	bne.n	8013502 <fRspAnalyze_CPSMS+0x12>
 8013518:	cc03      	ldmia	r4!, {r0, r1}
 801351a:	6028      	str	r0, [r5, #0]
 801351c:	6069      	str	r1, [r5, #4]
 801351e:	7823      	ldrb	r3, [r4, #0]
 8013520:	722b      	strb	r3, [r5, #8]
 8013522:	4c72      	ldr	r4, [pc, #456]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 8013524:	4620      	mov	r0, r4
 8013526:	f00b fdf4 	bl	801f112 <crs_strlen>
 801352a:	b283      	uxth	r3, r0
 801352c:	4622      	mov	r2, r4
 801352e:	2104      	movs	r1, #4
 8013530:	2002      	movs	r0, #2
 8013532:	f00b fe31 	bl	801f198 <traceIF_itmPrint>
 8013536:	4620      	mov	r0, r4
 8013538:	f00b fdeb 	bl	801f112 <crs_strlen>
 801353c:	b283      	uxth	r3, r0
 801353e:	4622      	mov	r2, r4
 8013540:	2104      	movs	r1, #4
 8013542:	2002      	movs	r0, #2
 8013544:	f00b fe4a 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for CPSMS */
  /* for READ COMMAND only  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8013548:	8b3b      	ldrh	r3, [r7, #24]
 801354a:	2b02      	cmp	r3, #2
 801354c:	d002      	beq.n	8013554 <fRspAnalyze_CPSMS+0x64>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 801354e:	2010      	movs	r0, #16
 8013550:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    START_PARAM_LOOP()
 8013554:	2400      	movs	r4, #0
 8013556:	4632      	mov	r2, r6
 8013558:	4641      	mov	r1, r8
 801355a:	4638      	mov	r0, r7
 801355c:	f7f8 ff74 	bl	800c448 <atcc_extractElement>
 8013560:	2801      	cmp	r0, #1
 8013562:	d000      	beq.n	8013566 <fRspAnalyze_CPSMS+0x76>
 8013564:	2401      	movs	r4, #1
 8013566:	89f3      	ldrh	r3, [r6, #14]
 8013568:	b913      	cbnz	r3, 8013570 <fRspAnalyze_CPSMS+0x80>
    END_PARAM_LOOP()
 801356a:	2c00      	cmp	r4, #0
 801356c:	d1ef      	bne.n	801354e <fRspAnalyze_CPSMS+0x5e>
 801356e:	e7f2      	b.n	8013556 <fRspAnalyze_CPSMS+0x66>
    PRINT_DBG("+CPSMS param_rank = %d", element_infos->param_rank)
 8013570:	4d5e      	ldr	r5, [pc, #376]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 8013572:	8932      	ldrh	r2, [r6, #8]
 8013574:	495e      	ldr	r1, [pc, #376]	; (80136f0 <fRspAnalyze_CPSMS+0x200>)
 8013576:	4628      	mov	r0, r5
 8013578:	f012 fb7a 	bl	8025c70 <sprintf>
 801357c:	4628      	mov	r0, r5
 801357e:	f00b fdc8 	bl	801f112 <crs_strlen>
 8013582:	b283      	uxth	r3, r0
 8013584:	462a      	mov	r2, r5
 8013586:	2102      	movs	r1, #2
 8013588:	4608      	mov	r0, r1
 801358a:	f00b fe05 	bl	801f198 <traceIF_itmPrint>
 801358e:	4628      	mov	r0, r5
 8013590:	f00b fdbf 	bl	801f112 <crs_strlen>
 8013594:	b283      	uxth	r3, r0
 8013596:	462a      	mov	r2, r5
 8013598:	2102      	movs	r1, #2
 801359a:	4608      	mov	r0, r1
 801359c:	f00b fe1e 	bl	801f1dc <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 80135a0:	8933      	ldrh	r3, [r6, #8]
 80135a2:	2b02      	cmp	r3, #2
 80135a4:	d006      	beq.n	80135b4 <fRspAnalyze_CPSMS+0xc4>
    else if (element_infos->param_rank == 3U)
 80135a6:	3b03      	subs	r3, #3
 80135a8:	2b03      	cmp	r3, #3
 80135aa:	d8de      	bhi.n	801356a <fRspAnalyze_CPSMS+0x7a>
 80135ac:	e8df f003 	tbb	[pc, r3]
 80135b0:	7c5d3e1f 	.word	0x7c5d3e1f
      PRINT_INFO("+CPSMS: mode= %ld",
 80135b4:	8970      	ldrh	r0, [r6, #10]
 80135b6:	89f1      	ldrh	r1, [r6, #14]
 80135b8:	4440      	add	r0, r8
 80135ba:	f001 fbbb 	bl	8014d34 <ATutil_convertStringToInt>
 80135be:	4602      	mov	r2, r0
 80135c0:	494c      	ldr	r1, [pc, #304]	; (80136f4 <fRspAnalyze_CPSMS+0x204>)
 80135c2:	4628      	mov	r0, r5
 80135c4:	f012 fb54 	bl	8025c70 <sprintf>
 80135c8:	4628      	mov	r0, r5
 80135ca:	f00b fda2 	bl	801f112 <crs_strlen>
 80135ce:	b283      	uxth	r3, r0
 80135d0:	462a      	mov	r2, r5
 80135d2:	2101      	movs	r1, #1
 80135d4:	2002      	movs	r0, #2
 80135d6:	f00b fddf 	bl	801f198 <traceIF_itmPrint>
 80135da:	4628      	mov	r0, r5
 80135dc:	f00b fd99 	bl	801f112 <crs_strlen>
 80135e0:	b283      	uxth	r3, r0
 80135e2:	462a      	mov	r2, r5
 80135e4:	2101      	movs	r1, #1
 80135e6:	2002      	movs	r0, #2
 80135e8:	f00b fdf8 	bl	801f1dc <traceIF_uartPrint>
 80135ec:	e7bd      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_periodic_rau= 0x%lx",
 80135ee:	8970      	ldrh	r0, [r6, #10]
 80135f0:	2208      	movs	r2, #8
 80135f2:	89f1      	ldrh	r1, [r6, #14]
 80135f4:	4440      	add	r0, r8
 80135f6:	f7fb fb0c 	bl	800ec12 <extract_bin_value_from_quotes>
 80135fa:	4602      	mov	r2, r0
 80135fc:	4d3b      	ldr	r5, [pc, #236]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 80135fe:	493e      	ldr	r1, [pc, #248]	; (80136f8 <fRspAnalyze_CPSMS+0x208>)
 8013600:	4628      	mov	r0, r5
 8013602:	f012 fb35 	bl	8025c70 <sprintf>
 8013606:	4628      	mov	r0, r5
 8013608:	f00b fd83 	bl	801f112 <crs_strlen>
 801360c:	b283      	uxth	r3, r0
 801360e:	462a      	mov	r2, r5
 8013610:	2101      	movs	r1, #1
 8013612:	2002      	movs	r0, #2
 8013614:	f00b fdc0 	bl	801f198 <traceIF_itmPrint>
 8013618:	4628      	mov	r0, r5
 801361a:	f00b fd7a 	bl	801f112 <crs_strlen>
 801361e:	b283      	uxth	r3, r0
 8013620:	462a      	mov	r2, r5
 8013622:	2101      	movs	r1, #1
 8013624:	2002      	movs	r0, #2
 8013626:	f00b fdd9 	bl	801f1dc <traceIF_uartPrint>
 801362a:	e79e      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_gprs_ready_timer= 0x%lx",
 801362c:	8970      	ldrh	r0, [r6, #10]
 801362e:	2208      	movs	r2, #8
 8013630:	89f1      	ldrh	r1, [r6, #14]
 8013632:	4440      	add	r0, r8
 8013634:	f7fb faed 	bl	800ec12 <extract_bin_value_from_quotes>
 8013638:	4602      	mov	r2, r0
 801363a:	4d2c      	ldr	r5, [pc, #176]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 801363c:	492f      	ldr	r1, [pc, #188]	; (80136fc <fRspAnalyze_CPSMS+0x20c>)
 801363e:	4628      	mov	r0, r5
 8013640:	f012 fb16 	bl	8025c70 <sprintf>
 8013644:	4628      	mov	r0, r5
 8013646:	f00b fd64 	bl	801f112 <crs_strlen>
 801364a:	b283      	uxth	r3, r0
 801364c:	462a      	mov	r2, r5
 801364e:	2101      	movs	r1, #1
 8013650:	2002      	movs	r0, #2
 8013652:	f00b fda1 	bl	801f198 <traceIF_itmPrint>
 8013656:	4628      	mov	r0, r5
 8013658:	f00b fd5b 	bl	801f112 <crs_strlen>
 801365c:	b283      	uxth	r3, r0
 801365e:	462a      	mov	r2, r5
 8013660:	2101      	movs	r1, #1
 8013662:	2002      	movs	r0, #2
 8013664:	f00b fdba 	bl	801f1dc <traceIF_uartPrint>
 8013668:	e77f      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_periodic_tau= 0x%lx",
 801366a:	8970      	ldrh	r0, [r6, #10]
 801366c:	2208      	movs	r2, #8
 801366e:	89f1      	ldrh	r1, [r6, #14]
 8013670:	4440      	add	r0, r8
 8013672:	f7fb face 	bl	800ec12 <extract_bin_value_from_quotes>
 8013676:	4602      	mov	r2, r0
 8013678:	4d1c      	ldr	r5, [pc, #112]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 801367a:	4921      	ldr	r1, [pc, #132]	; (8013700 <fRspAnalyze_CPSMS+0x210>)
 801367c:	4628      	mov	r0, r5
 801367e:	f012 faf7 	bl	8025c70 <sprintf>
 8013682:	4628      	mov	r0, r5
 8013684:	f00b fd45 	bl	801f112 <crs_strlen>
 8013688:	b283      	uxth	r3, r0
 801368a:	462a      	mov	r2, r5
 801368c:	2101      	movs	r1, #1
 801368e:	2002      	movs	r0, #2
 8013690:	f00b fd82 	bl	801f198 <traceIF_itmPrint>
 8013694:	4628      	mov	r0, r5
 8013696:	f00b fd3c 	bl	801f112 <crs_strlen>
 801369a:	b283      	uxth	r3, r0
 801369c:	462a      	mov	r2, r5
 801369e:	2101      	movs	r1, #1
 80136a0:	2002      	movs	r0, #2
 80136a2:	f00b fd9b 	bl	801f1dc <traceIF_uartPrint>
 80136a6:	e760      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_active_time= 0x%lx",
 80136a8:	8970      	ldrh	r0, [r6, #10]
 80136aa:	2208      	movs	r2, #8
 80136ac:	89f1      	ldrh	r1, [r6, #14]
 80136ae:	4440      	add	r0, r8
 80136b0:	f7fb faaf 	bl	800ec12 <extract_bin_value_from_quotes>
 80136b4:	4602      	mov	r2, r0
 80136b6:	4d0d      	ldr	r5, [pc, #52]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 80136b8:	4912      	ldr	r1, [pc, #72]	; (8013704 <fRspAnalyze_CPSMS+0x214>)
 80136ba:	4628      	mov	r0, r5
 80136bc:	f012 fad8 	bl	8025c70 <sprintf>
 80136c0:	4628      	mov	r0, r5
 80136c2:	f00b fd26 	bl	801f112 <crs_strlen>
 80136c6:	b283      	uxth	r3, r0
 80136c8:	462a      	mov	r2, r5
 80136ca:	2101      	movs	r1, #1
 80136cc:	2002      	movs	r0, #2
 80136ce:	f00b fd63 	bl	801f198 <traceIF_itmPrint>
 80136d2:	4628      	mov	r0, r5
 80136d4:	f00b fd1d 	bl	801f112 <crs_strlen>
 80136d8:	b283      	uxth	r3, r0
 80136da:	462a      	mov	r2, r5
 80136dc:	2101      	movs	r1, #1
 80136de:	2002      	movs	r0, #2
 80136e0:	f00b fd7c 	bl	801f1dc <traceIF_uartPrint>
 80136e4:	e741      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
 80136e6:	bf00      	nop
 80136e8:	08030238 	.word	0x08030238
 80136ec:	200048dc 	.word	0x200048dc
 80136f0:	08030264 	.word	0x08030264
 80136f4:	08030288 	.word	0x08030288
 80136f8:	080302a8 	.word	0x080302a8
 80136fc:	080302d4 	.word	0x080302d4
 8013700:	08030304 	.word	0x08030304
 8013704:	08030330 	.word	0x08030330

08013708 <fRspAnalyze_CEDRXS>:

at_action_rsp_t fRspAnalyze_CEDRXS(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013708:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801370c:	4606      	mov	r6, r0
 801370e:	4690      	mov	r8, r2
 8013710:	461f      	mov	r7, r3
  UNUSED(p_modem_ctxt);
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEDRXS()")
 8013712:	4c4b      	ldr	r4, [pc, #300]	; (8013840 <fRspAnalyze_CEDRXS+0x138>)
 8013714:	4d4b      	ldr	r5, [pc, #300]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 8013716:	f104 0e20 	add.w	lr, r4, #32
 801371a:	46a4      	mov	ip, r4
 801371c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013720:	6028      	str	r0, [r5, #0]
 8013722:	6069      	str	r1, [r5, #4]
 8013724:	60aa      	str	r2, [r5, #8]
 8013726:	60eb      	str	r3, [r5, #12]
 8013728:	4664      	mov	r4, ip
 801372a:	3510      	adds	r5, #16
 801372c:	45f4      	cmp	ip, lr
 801372e:	d1f4      	bne.n	801371a <fRspAnalyze_CEDRXS+0x12>
 8013730:	cc03      	ldmia	r4!, {r0, r1}
 8013732:	6028      	str	r0, [r5, #0]
 8013734:	6069      	str	r1, [r5, #4]
 8013736:	8823      	ldrh	r3, [r4, #0]
 8013738:	812b      	strh	r3, [r5, #8]
 801373a:	4c42      	ldr	r4, [pc, #264]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 801373c:	4620      	mov	r0, r4
 801373e:	f00b fce8 	bl	801f112 <crs_strlen>
 8013742:	b283      	uxth	r3, r0
 8013744:	4622      	mov	r2, r4
 8013746:	2104      	movs	r1, #4
 8013748:	2002      	movs	r0, #2
 801374a:	f00b fd25 	bl	801f198 <traceIF_itmPrint>
 801374e:	4620      	mov	r0, r4
 8013750:	f00b fcdf 	bl	801f112 <crs_strlen>
 8013754:	b283      	uxth	r3, r0
 8013756:	4622      	mov	r2, r4
 8013758:	2104      	movs	r1, #4
 801375a:	2002      	movs	r0, #2
 801375c:	f00b fd3e 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for CEDRXS */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CEDRXS)
 8013760:	69f3      	ldr	r3, [r6, #28]
 8013762:	2b23      	cmp	r3, #35	; 0x23
 8013764:	d002      	beq.n	801376c <fRspAnalyze_CEDRXS+0x64>
      END_PARAM_LOOP()
    }
  }

  return (retval);
}
 8013766:	2010      	movs	r0, #16
 8013768:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 801376c:	8b33      	ldrh	r3, [r6, #24]
 801376e:	2b02      	cmp	r3, #2
 8013770:	d1f9      	bne.n	8013766 <fRspAnalyze_CEDRXS+0x5e>
      START_PARAM_LOOP()
 8013772:	2400      	movs	r4, #0
 8013774:	463a      	mov	r2, r7
 8013776:	4641      	mov	r1, r8
 8013778:	4630      	mov	r0, r6
 801377a:	f7f8 fe65 	bl	800c448 <atcc_extractElement>
 801377e:	2801      	cmp	r0, #1
 8013780:	d000      	beq.n	8013784 <fRspAnalyze_CEDRXS+0x7c>
 8013782:	2401      	movs	r4, #1
 8013784:	89fb      	ldrh	r3, [r7, #14]
 8013786:	b913      	cbnz	r3, 801378e <fRspAnalyze_CEDRXS+0x86>
      END_PARAM_LOOP()
 8013788:	2c00      	cmp	r4, #0
 801378a:	d1ec      	bne.n	8013766 <fRspAnalyze_CEDRXS+0x5e>
 801378c:	e7f2      	b.n	8013774 <fRspAnalyze_CEDRXS+0x6c>
      PRINT_DBG("+CEDRXS param_rank = %d", element_infos->param_rank)
 801378e:	4d2d      	ldr	r5, [pc, #180]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 8013790:	893a      	ldrh	r2, [r7, #8]
 8013792:	492d      	ldr	r1, [pc, #180]	; (8013848 <fRspAnalyze_CEDRXS+0x140>)
 8013794:	4628      	mov	r0, r5
 8013796:	f012 fa6b 	bl	8025c70 <sprintf>
 801379a:	4628      	mov	r0, r5
 801379c:	f00b fcb9 	bl	801f112 <crs_strlen>
 80137a0:	b283      	uxth	r3, r0
 80137a2:	462a      	mov	r2, r5
 80137a4:	2102      	movs	r1, #2
 80137a6:	4608      	mov	r0, r1
 80137a8:	f00b fcf6 	bl	801f198 <traceIF_itmPrint>
 80137ac:	4628      	mov	r0, r5
 80137ae:	f00b fcb0 	bl	801f112 <crs_strlen>
 80137b2:	b283      	uxth	r3, r0
 80137b4:	462a      	mov	r2, r5
 80137b6:	2102      	movs	r1, #2
 80137b8:	4608      	mov	r0, r1
 80137ba:	f00b fd0f 	bl	801f1dc <traceIF_uartPrint>
      if (element_infos->param_rank == 2U)
 80137be:	893b      	ldrh	r3, [r7, #8]
 80137c0:	2b02      	cmp	r3, #2
 80137c2:	d020      	beq.n	8013806 <fRspAnalyze_CEDRXS+0xfe>
      else if (element_infos->param_rank == 3U)
 80137c4:	2b03      	cmp	r3, #3
 80137c6:	d1df      	bne.n	8013788 <fRspAnalyze_CEDRXS+0x80>
        PRINT_INFO("+CEDRXS: req_edrx_value= 0x%lx",
 80137c8:	8978      	ldrh	r0, [r7, #10]
 80137ca:	2204      	movs	r2, #4
 80137cc:	89f9      	ldrh	r1, [r7, #14]
 80137ce:	4440      	add	r0, r8
 80137d0:	f7fb fa1f 	bl	800ec12 <extract_bin_value_from_quotes>
 80137d4:	4602      	mov	r2, r0
 80137d6:	4d1b      	ldr	r5, [pc, #108]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 80137d8:	491c      	ldr	r1, [pc, #112]	; (801384c <fRspAnalyze_CEDRXS+0x144>)
 80137da:	4628      	mov	r0, r5
 80137dc:	f012 fa48 	bl	8025c70 <sprintf>
 80137e0:	4628      	mov	r0, r5
 80137e2:	f00b fc96 	bl	801f112 <crs_strlen>
 80137e6:	b283      	uxth	r3, r0
 80137e8:	462a      	mov	r2, r5
 80137ea:	2101      	movs	r1, #1
 80137ec:	2002      	movs	r0, #2
 80137ee:	f00b fcd3 	bl	801f198 <traceIF_itmPrint>
 80137f2:	4628      	mov	r0, r5
 80137f4:	f00b fc8d 	bl	801f112 <crs_strlen>
 80137f8:	b283      	uxth	r3, r0
 80137fa:	462a      	mov	r2, r5
 80137fc:	2101      	movs	r1, #1
 80137fe:	2002      	movs	r0, #2
 8013800:	f00b fcec 	bl	801f1dc <traceIF_uartPrint>
 8013804:	e7c0      	b.n	8013788 <fRspAnalyze_CEDRXS+0x80>
        PRINT_DBG("+CEDRXS: act_type= %ld",
 8013806:	8978      	ldrh	r0, [r7, #10]
 8013808:	89f9      	ldrh	r1, [r7, #14]
 801380a:	4440      	add	r0, r8
 801380c:	f001 fa92 	bl	8014d34 <ATutil_convertStringToInt>
 8013810:	4602      	mov	r2, r0
 8013812:	490f      	ldr	r1, [pc, #60]	; (8013850 <fRspAnalyze_CEDRXS+0x148>)
 8013814:	4628      	mov	r0, r5
 8013816:	f012 fa2b 	bl	8025c70 <sprintf>
 801381a:	4628      	mov	r0, r5
 801381c:	f00b fc79 	bl	801f112 <crs_strlen>
 8013820:	b283      	uxth	r3, r0
 8013822:	462a      	mov	r2, r5
 8013824:	2102      	movs	r1, #2
 8013826:	4608      	mov	r0, r1
 8013828:	f00b fcb6 	bl	801f198 <traceIF_itmPrint>
 801382c:	4628      	mov	r0, r5
 801382e:	f00b fc70 	bl	801f112 <crs_strlen>
 8013832:	b283      	uxth	r3, r0
 8013834:	462a      	mov	r2, r5
 8013836:	2102      	movs	r1, #2
 8013838:	4608      	mov	r0, r1
 801383a:	f00b fccf 	bl	801f1dc <traceIF_uartPrint>
 801383e:	e7a3      	b.n	8013788 <fRspAnalyze_CEDRXS+0x80>
 8013840:	0803035c 	.word	0x0803035c
 8013844:	200048dc 	.word	0x200048dc
 8013848:	08030388 	.word	0x08030388
 801384c:	080303d0 	.word	0x080303d0
 8013850:	080303ac 	.word	0x080303ac

08013854 <fRspAnalyze_CEDRXP>:

at_action_rsp_t fRspAnalyze_CEDRXP(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013854:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013858:	4680      	mov	r8, r0
 801385a:	4617      	mov	r7, r2
 801385c:	461e      	mov	r6, r3
  UNUSED(p_modem_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEDRXP()")
 801385e:	4c69      	ldr	r4, [pc, #420]	; (8013a04 <fRspAnalyze_CEDRXP+0x1b0>)
 8013860:	4d69      	ldr	r5, [pc, #420]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 8013862:	f104 0e20 	add.w	lr, r4, #32
 8013866:	46a4      	mov	ip, r4
 8013868:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801386c:	6028      	str	r0, [r5, #0]
 801386e:	6069      	str	r1, [r5, #4]
 8013870:	60aa      	str	r2, [r5, #8]
 8013872:	60eb      	str	r3, [r5, #12]
 8013874:	4664      	mov	r4, ip
 8013876:	3510      	adds	r5, #16
 8013878:	45f4      	cmp	ip, lr
 801387a:	d1f4      	bne.n	8013866 <fRspAnalyze_CEDRXP+0x12>
 801387c:	cc03      	ldmia	r4!, {r0, r1}
 801387e:	6028      	str	r0, [r5, #0]
 8013880:	6069      	str	r1, [r5, #4]
 8013882:	8823      	ldrh	r3, [r4, #0]
 8013884:	812b      	strh	r3, [r5, #8]
 8013886:	4c60      	ldr	r4, [pc, #384]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 8013888:	4620      	mov	r0, r4
 801388a:	f00b fc42 	bl	801f112 <crs_strlen>
 801388e:	b283      	uxth	r3, r0
 8013890:	4622      	mov	r2, r4
 8013892:	2104      	movs	r1, #4
 8013894:	2002      	movs	r0, #2
 8013896:	f00b fc7f 	bl	801f198 <traceIF_itmPrint>
 801389a:	4620      	mov	r0, r4
 801389c:	f00b fc39 	bl	801f112 <crs_strlen>
 80138a0:	b283      	uxth	r3, r0
 80138a2:	4622      	mov	r2, r4
 80138a4:	2104      	movs	r1, #4
 80138a6:	2002      	movs	r0, #2
 80138a8:	f00b fc98 	bl	801f1dc <traceIF_uartPrint>
  /* 3GP TS27.007
  *  format: +CEDRXP: <AcT-type>[,<Requested_eDRX_value>[,<NW-provided_eDRX_value>[,<Paging_time_window>]]]
  *
  */

  START_PARAM_LOOP()
 80138ac:	2400      	movs	r4, #0
 80138ae:	4632      	mov	r2, r6
 80138b0:	4639      	mov	r1, r7
 80138b2:	4640      	mov	r0, r8
 80138b4:	f7f8 fdc8 	bl	800c448 <atcc_extractElement>
 80138b8:	2801      	cmp	r0, #1
 80138ba:	d000      	beq.n	80138be <fRspAnalyze_CEDRXP+0x6a>
 80138bc:	2401      	movs	r4, #1
 80138be:	89f3      	ldrh	r3, [r6, #14]
 80138c0:	b923      	cbnz	r3, 80138cc <fRspAnalyze_CEDRXP+0x78>
  }
  else
  {
    /* parameters ignored */
  }
  END_PARAM_LOOP()
 80138c2:	2c00      	cmp	r4, #0
 80138c4:	d0f3      	beq.n	80138ae <fRspAnalyze_CEDRXP+0x5a>


  return (retval);
}
 80138c6:	2010      	movs	r0, #16
 80138c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  PRINT_DBG("+CEDRXS param_rank = %d", element_infos->param_rank)
 80138cc:	4d4e      	ldr	r5, [pc, #312]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 80138ce:	8932      	ldrh	r2, [r6, #8]
 80138d0:	494e      	ldr	r1, [pc, #312]	; (8013a0c <fRspAnalyze_CEDRXP+0x1b8>)
 80138d2:	4628      	mov	r0, r5
 80138d4:	f012 f9cc 	bl	8025c70 <sprintf>
 80138d8:	4628      	mov	r0, r5
 80138da:	f00b fc1a 	bl	801f112 <crs_strlen>
 80138de:	b283      	uxth	r3, r0
 80138e0:	462a      	mov	r2, r5
 80138e2:	2102      	movs	r1, #2
 80138e4:	4608      	mov	r0, r1
 80138e6:	f00b fc57 	bl	801f198 <traceIF_itmPrint>
 80138ea:	4628      	mov	r0, r5
 80138ec:	f00b fc11 	bl	801f112 <crs_strlen>
 80138f0:	b283      	uxth	r3, r0
 80138f2:	462a      	mov	r2, r5
 80138f4:	2102      	movs	r1, #2
 80138f6:	4608      	mov	r0, r1
 80138f8:	f00b fc70 	bl	801f1dc <traceIF_uartPrint>
  if (element_infos->param_rank == 2U)
 80138fc:	8933      	ldrh	r3, [r6, #8]
 80138fe:	2b02      	cmp	r3, #2
 8013900:	d024      	beq.n	801394c <fRspAnalyze_CEDRXP+0xf8>
  else if (element_infos->param_rank == 3U)
 8013902:	2b03      	cmp	r3, #3
 8013904:	d03f      	beq.n	8013986 <fRspAnalyze_CEDRXP+0x132>
  else if (element_infos->param_rank == 4U)
 8013906:	2b04      	cmp	r3, #4
 8013908:	d05c      	beq.n	80139c4 <fRspAnalyze_CEDRXP+0x170>
  else if (element_infos->param_rank == 5U)
 801390a:	2b05      	cmp	r3, #5
 801390c:	d1d9      	bne.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_INFO("+CEDRXP URC: paging_time_window= 0x%lx",
 801390e:	8970      	ldrh	r0, [r6, #10]
 8013910:	2204      	movs	r2, #4
 8013912:	89f1      	ldrh	r1, [r6, #14]
 8013914:	4438      	add	r0, r7
 8013916:	f7fb f97c 	bl	800ec12 <extract_bin_value_from_quotes>
 801391a:	4602      	mov	r2, r0
 801391c:	4d3a      	ldr	r5, [pc, #232]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 801391e:	493c      	ldr	r1, [pc, #240]	; (8013a10 <fRspAnalyze_CEDRXP+0x1bc>)
 8013920:	4628      	mov	r0, r5
 8013922:	f012 f9a5 	bl	8025c70 <sprintf>
 8013926:	4628      	mov	r0, r5
 8013928:	f00b fbf3 	bl	801f112 <crs_strlen>
 801392c:	b283      	uxth	r3, r0
 801392e:	462a      	mov	r2, r5
 8013930:	2101      	movs	r1, #1
 8013932:	2002      	movs	r0, #2
 8013934:	f00b fc30 	bl	801f198 <traceIF_itmPrint>
 8013938:	4628      	mov	r0, r5
 801393a:	f00b fbea 	bl	801f112 <crs_strlen>
 801393e:	b283      	uxth	r3, r0
 8013940:	462a      	mov	r2, r5
 8013942:	2101      	movs	r1, #1
 8013944:	2002      	movs	r0, #2
 8013946:	f00b fc49 	bl	801f1dc <traceIF_uartPrint>
 801394a:	e7ba      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_DBG("+CEDRXP URC: act_type= %ld",
 801394c:	8970      	ldrh	r0, [r6, #10]
 801394e:	89f1      	ldrh	r1, [r6, #14]
 8013950:	4438      	add	r0, r7
 8013952:	f001 f9ef 	bl	8014d34 <ATutil_convertStringToInt>
 8013956:	4602      	mov	r2, r0
 8013958:	492e      	ldr	r1, [pc, #184]	; (8013a14 <fRspAnalyze_CEDRXP+0x1c0>)
 801395a:	4628      	mov	r0, r5
 801395c:	f012 f988 	bl	8025c70 <sprintf>
 8013960:	4628      	mov	r0, r5
 8013962:	f00b fbd6 	bl	801f112 <crs_strlen>
 8013966:	b283      	uxth	r3, r0
 8013968:	462a      	mov	r2, r5
 801396a:	2102      	movs	r1, #2
 801396c:	4608      	mov	r0, r1
 801396e:	f00b fc13 	bl	801f198 <traceIF_itmPrint>
 8013972:	4628      	mov	r0, r5
 8013974:	f00b fbcd 	bl	801f112 <crs_strlen>
 8013978:	b283      	uxth	r3, r0
 801397a:	462a      	mov	r2, r5
 801397c:	2102      	movs	r1, #2
 801397e:	4608      	mov	r0, r1
 8013980:	f00b fc2c 	bl	801f1dc <traceIF_uartPrint>
 8013984:	e79d      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_INFO("+CEDRXP URC: req_edrx_value= 0x%lx",
 8013986:	8970      	ldrh	r0, [r6, #10]
 8013988:	2204      	movs	r2, #4
 801398a:	89f1      	ldrh	r1, [r6, #14]
 801398c:	4438      	add	r0, r7
 801398e:	f7fb f940 	bl	800ec12 <extract_bin_value_from_quotes>
 8013992:	4602      	mov	r2, r0
 8013994:	4d1c      	ldr	r5, [pc, #112]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 8013996:	4920      	ldr	r1, [pc, #128]	; (8013a18 <fRspAnalyze_CEDRXP+0x1c4>)
 8013998:	4628      	mov	r0, r5
 801399a:	f012 f969 	bl	8025c70 <sprintf>
 801399e:	4628      	mov	r0, r5
 80139a0:	f00b fbb7 	bl	801f112 <crs_strlen>
 80139a4:	b283      	uxth	r3, r0
 80139a6:	462a      	mov	r2, r5
 80139a8:	2101      	movs	r1, #1
 80139aa:	2002      	movs	r0, #2
 80139ac:	f00b fbf4 	bl	801f198 <traceIF_itmPrint>
 80139b0:	4628      	mov	r0, r5
 80139b2:	f00b fbae 	bl	801f112 <crs_strlen>
 80139b6:	b283      	uxth	r3, r0
 80139b8:	462a      	mov	r2, r5
 80139ba:	2101      	movs	r1, #1
 80139bc:	2002      	movs	r0, #2
 80139be:	f00b fc0d 	bl	801f1dc <traceIF_uartPrint>
 80139c2:	e77e      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_INFO("+CEDRXP URC: nw_provided_edrx_value= 0x%lx",
 80139c4:	8970      	ldrh	r0, [r6, #10]
 80139c6:	2204      	movs	r2, #4
 80139c8:	89f1      	ldrh	r1, [r6, #14]
 80139ca:	4438      	add	r0, r7
 80139cc:	f7fb f921 	bl	800ec12 <extract_bin_value_from_quotes>
 80139d0:	4602      	mov	r2, r0
 80139d2:	4d0d      	ldr	r5, [pc, #52]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 80139d4:	4911      	ldr	r1, [pc, #68]	; (8013a1c <fRspAnalyze_CEDRXP+0x1c8>)
 80139d6:	4628      	mov	r0, r5
 80139d8:	f012 f94a 	bl	8025c70 <sprintf>
 80139dc:	4628      	mov	r0, r5
 80139de:	f00b fb98 	bl	801f112 <crs_strlen>
 80139e2:	b283      	uxth	r3, r0
 80139e4:	462a      	mov	r2, r5
 80139e6:	2101      	movs	r1, #1
 80139e8:	2002      	movs	r0, #2
 80139ea:	f00b fbd5 	bl	801f198 <traceIF_itmPrint>
 80139ee:	4628      	mov	r0, r5
 80139f0:	f00b fb8f 	bl	801f112 <crs_strlen>
 80139f4:	b283      	uxth	r3, r0
 80139f6:	462a      	mov	r2, r5
 80139f8:	2101      	movs	r1, #1
 80139fa:	2002      	movs	r0, #2
 80139fc:	f00b fbee 	bl	801f1dc <traceIF_uartPrint>
 8013a00:	e75f      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
 8013a02:	bf00      	nop
 8013a04:	080303fc 	.word	0x080303fc
 8013a08:	200048dc 	.word	0x200048dc
 8013a0c:	08030388 	.word	0x08030388
 8013a10:	080304b8 	.word	0x080304b8
 8013a14:	08030428 	.word	0x08030428
 8013a18:	08030450 	.word	0x08030450
 8013a1c:	08030480 	.word	0x08030480

08013a20 <fRspAnalyze_CEDRXRDP>:

at_action_rsp_t fRspAnalyze_CEDRXRDP(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                     const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013a20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013a24:	4680      	mov	r8, r0
 8013a26:	4617      	mov	r7, r2
 8013a28:	461e      	mov	r6, r3
  UNUSED(p_modem_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEDRXRDP()")
 8013a2a:	4c68      	ldr	r4, [pc, #416]	; (8013bcc <fRspAnalyze_CEDRXRDP+0x1ac>)
 8013a2c:	4d68      	ldr	r5, [pc, #416]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013a2e:	f104 0e20 	add.w	lr, r4, #32
 8013a32:	46a4      	mov	ip, r4
 8013a34:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013a38:	6028      	str	r0, [r5, #0]
 8013a3a:	6069      	str	r1, [r5, #4]
 8013a3c:	60aa      	str	r2, [r5, #8]
 8013a3e:	60eb      	str	r3, [r5, #12]
 8013a40:	4664      	mov	r4, ip
 8013a42:	3510      	adds	r5, #16
 8013a44:	45f4      	cmp	ip, lr
 8013a46:	d1f4      	bne.n	8013a32 <fRspAnalyze_CEDRXRDP+0x12>
 8013a48:	cc07      	ldmia	r4!, {r0, r1, r2}
 8013a4a:	6028      	str	r0, [r5, #0]
 8013a4c:	6069      	str	r1, [r5, #4]
 8013a4e:	60aa      	str	r2, [r5, #8]
 8013a50:	4c5f      	ldr	r4, [pc, #380]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013a52:	4620      	mov	r0, r4
 8013a54:	f00b fb5d 	bl	801f112 <crs_strlen>
 8013a58:	b283      	uxth	r3, r0
 8013a5a:	4622      	mov	r2, r4
 8013a5c:	2104      	movs	r1, #4
 8013a5e:	2002      	movs	r0, #2
 8013a60:	f00b fb9a 	bl	801f198 <traceIF_itmPrint>
 8013a64:	4620      	mov	r0, r4
 8013a66:	f00b fb54 	bl	801f112 <crs_strlen>
 8013a6a:	b283      	uxth	r3, r0
 8013a6c:	4622      	mov	r2, r4
 8013a6e:	2104      	movs	r1, #4
 8013a70:	2002      	movs	r0, #2
 8013a72:	f00b fbb3 	bl	801f1dc <traceIF_uartPrint>
  *
  *  format: +CEDRXRDP: <AcT-type>[,<Requested_eDRX_value>[,<NW-provided_eDRX_value>[,<Paging_time_window>]]]
  *
  */

  START_PARAM_LOOP()
 8013a76:	2400      	movs	r4, #0
 8013a78:	4632      	mov	r2, r6
 8013a7a:	4639      	mov	r1, r7
 8013a7c:	4640      	mov	r0, r8
 8013a7e:	f7f8 fce3 	bl	800c448 <atcc_extractElement>
 8013a82:	2801      	cmp	r0, #1
 8013a84:	d000      	beq.n	8013a88 <fRspAnalyze_CEDRXRDP+0x68>
 8013a86:	2401      	movs	r4, #1
 8013a88:	89f3      	ldrh	r3, [r6, #14]
 8013a8a:	b923      	cbnz	r3, 8013a96 <fRspAnalyze_CEDRXRDP+0x76>
  }
  else
  {
    /* parameters ignored */
  }
  END_PARAM_LOOP()
 8013a8c:	2c00      	cmp	r4, #0
 8013a8e:	d0f3      	beq.n	8013a78 <fRspAnalyze_CEDRXRDP+0x58>


  return (retval);
}
 8013a90:	2010      	movs	r0, #16
 8013a92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  PRINT_DBG("+CEDRXDP param_rank = %d", element_infos->param_rank)
 8013a96:	4d4e      	ldr	r5, [pc, #312]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013a98:	8932      	ldrh	r2, [r6, #8]
 8013a9a:	494e      	ldr	r1, [pc, #312]	; (8013bd4 <fRspAnalyze_CEDRXRDP+0x1b4>)
 8013a9c:	4628      	mov	r0, r5
 8013a9e:	f012 f8e7 	bl	8025c70 <sprintf>
 8013aa2:	4628      	mov	r0, r5
 8013aa4:	f00b fb35 	bl	801f112 <crs_strlen>
 8013aa8:	b283      	uxth	r3, r0
 8013aaa:	462a      	mov	r2, r5
 8013aac:	2102      	movs	r1, #2
 8013aae:	4608      	mov	r0, r1
 8013ab0:	f00b fb72 	bl	801f198 <traceIF_itmPrint>
 8013ab4:	4628      	mov	r0, r5
 8013ab6:	f00b fb2c 	bl	801f112 <crs_strlen>
 8013aba:	b283      	uxth	r3, r0
 8013abc:	462a      	mov	r2, r5
 8013abe:	2102      	movs	r1, #2
 8013ac0:	4608      	mov	r0, r1
 8013ac2:	f00b fb8b 	bl	801f1dc <traceIF_uartPrint>
  if (element_infos->param_rank == 2U)
 8013ac6:	8933      	ldrh	r3, [r6, #8]
 8013ac8:	2b02      	cmp	r3, #2
 8013aca:	d024      	beq.n	8013b16 <fRspAnalyze_CEDRXRDP+0xf6>
  else if (element_infos->param_rank == 3U)
 8013acc:	2b03      	cmp	r3, #3
 8013ace:	d03f      	beq.n	8013b50 <fRspAnalyze_CEDRXRDP+0x130>
  else if (element_infos->param_rank == 4U)
 8013ad0:	2b04      	cmp	r3, #4
 8013ad2:	d05c      	beq.n	8013b8e <fRspAnalyze_CEDRXRDP+0x16e>
  else if (element_infos->param_rank == 5U)
 8013ad4:	2b05      	cmp	r3, #5
 8013ad6:	d1d9      	bne.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_INFO("+CEDRXRDP: paging_time_window= 0x%lx",
 8013ad8:	8970      	ldrh	r0, [r6, #10]
 8013ada:	2204      	movs	r2, #4
 8013adc:	89f1      	ldrh	r1, [r6, #14]
 8013ade:	4438      	add	r0, r7
 8013ae0:	f7fb f897 	bl	800ec12 <extract_bin_value_from_quotes>
 8013ae4:	4602      	mov	r2, r0
 8013ae6:	4d3a      	ldr	r5, [pc, #232]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013ae8:	493b      	ldr	r1, [pc, #236]	; (8013bd8 <fRspAnalyze_CEDRXRDP+0x1b8>)
 8013aea:	4628      	mov	r0, r5
 8013aec:	f012 f8c0 	bl	8025c70 <sprintf>
 8013af0:	4628      	mov	r0, r5
 8013af2:	f00b fb0e 	bl	801f112 <crs_strlen>
 8013af6:	b283      	uxth	r3, r0
 8013af8:	462a      	mov	r2, r5
 8013afa:	2101      	movs	r1, #1
 8013afc:	2002      	movs	r0, #2
 8013afe:	f00b fb4b 	bl	801f198 <traceIF_itmPrint>
 8013b02:	4628      	mov	r0, r5
 8013b04:	f00b fb05 	bl	801f112 <crs_strlen>
 8013b08:	b283      	uxth	r3, r0
 8013b0a:	462a      	mov	r2, r5
 8013b0c:	2101      	movs	r1, #1
 8013b0e:	2002      	movs	r0, #2
 8013b10:	f00b fb64 	bl	801f1dc <traceIF_uartPrint>
 8013b14:	e7ba      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_DBG("+CEDRXRDP: act_type= %ld",
 8013b16:	8970      	ldrh	r0, [r6, #10]
 8013b18:	89f1      	ldrh	r1, [r6, #14]
 8013b1a:	4438      	add	r0, r7
 8013b1c:	f001 f90a 	bl	8014d34 <ATutil_convertStringToInt>
 8013b20:	4602      	mov	r2, r0
 8013b22:	492e      	ldr	r1, [pc, #184]	; (8013bdc <fRspAnalyze_CEDRXRDP+0x1bc>)
 8013b24:	4628      	mov	r0, r5
 8013b26:	f012 f8a3 	bl	8025c70 <sprintf>
 8013b2a:	4628      	mov	r0, r5
 8013b2c:	f00b faf1 	bl	801f112 <crs_strlen>
 8013b30:	b283      	uxth	r3, r0
 8013b32:	462a      	mov	r2, r5
 8013b34:	2102      	movs	r1, #2
 8013b36:	4608      	mov	r0, r1
 8013b38:	f00b fb2e 	bl	801f198 <traceIF_itmPrint>
 8013b3c:	4628      	mov	r0, r5
 8013b3e:	f00b fae8 	bl	801f112 <crs_strlen>
 8013b42:	b283      	uxth	r3, r0
 8013b44:	462a      	mov	r2, r5
 8013b46:	2102      	movs	r1, #2
 8013b48:	4608      	mov	r0, r1
 8013b4a:	f00b fb47 	bl	801f1dc <traceIF_uartPrint>
 8013b4e:	e79d      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_INFO("+CEDRXRDP: req_edrx_value= 0x%lx",
 8013b50:	8970      	ldrh	r0, [r6, #10]
 8013b52:	2204      	movs	r2, #4
 8013b54:	89f1      	ldrh	r1, [r6, #14]
 8013b56:	4438      	add	r0, r7
 8013b58:	f7fb f85b 	bl	800ec12 <extract_bin_value_from_quotes>
 8013b5c:	4602      	mov	r2, r0
 8013b5e:	4d1c      	ldr	r5, [pc, #112]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013b60:	491f      	ldr	r1, [pc, #124]	; (8013be0 <fRspAnalyze_CEDRXRDP+0x1c0>)
 8013b62:	4628      	mov	r0, r5
 8013b64:	f012 f884 	bl	8025c70 <sprintf>
 8013b68:	4628      	mov	r0, r5
 8013b6a:	f00b fad2 	bl	801f112 <crs_strlen>
 8013b6e:	b283      	uxth	r3, r0
 8013b70:	462a      	mov	r2, r5
 8013b72:	2101      	movs	r1, #1
 8013b74:	2002      	movs	r0, #2
 8013b76:	f00b fb0f 	bl	801f198 <traceIF_itmPrint>
 8013b7a:	4628      	mov	r0, r5
 8013b7c:	f00b fac9 	bl	801f112 <crs_strlen>
 8013b80:	b283      	uxth	r3, r0
 8013b82:	462a      	mov	r2, r5
 8013b84:	2101      	movs	r1, #1
 8013b86:	2002      	movs	r0, #2
 8013b88:	f00b fb28 	bl	801f1dc <traceIF_uartPrint>
 8013b8c:	e77e      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_INFO("+CEDRXRDP: nw_provided_edrx_value= 0x%lx",
 8013b8e:	8970      	ldrh	r0, [r6, #10]
 8013b90:	2204      	movs	r2, #4
 8013b92:	89f1      	ldrh	r1, [r6, #14]
 8013b94:	4438      	add	r0, r7
 8013b96:	f7fb f83c 	bl	800ec12 <extract_bin_value_from_quotes>
 8013b9a:	4602      	mov	r2, r0
 8013b9c:	4d0c      	ldr	r5, [pc, #48]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013b9e:	4911      	ldr	r1, [pc, #68]	; (8013be4 <fRspAnalyze_CEDRXRDP+0x1c4>)
 8013ba0:	4628      	mov	r0, r5
 8013ba2:	f012 f865 	bl	8025c70 <sprintf>
 8013ba6:	4628      	mov	r0, r5
 8013ba8:	f00b fab3 	bl	801f112 <crs_strlen>
 8013bac:	b283      	uxth	r3, r0
 8013bae:	462a      	mov	r2, r5
 8013bb0:	2101      	movs	r1, #1
 8013bb2:	2002      	movs	r0, #2
 8013bb4:	f00b faf0 	bl	801f198 <traceIF_itmPrint>
 8013bb8:	4628      	mov	r0, r5
 8013bba:	f00b faaa 	bl	801f112 <crs_strlen>
 8013bbe:	b283      	uxth	r3, r0
 8013bc0:	462a      	mov	r2, r5
 8013bc2:	2101      	movs	r1, #1
 8013bc4:	2002      	movs	r0, #2
 8013bc6:	f00b fb09 	bl	801f1dc <traceIF_uartPrint>
 8013bca:	e75f      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
 8013bcc:	080304ec 	.word	0x080304ec
 8013bd0:	200048dc 	.word	0x200048dc
 8013bd4:	08030518 	.word	0x08030518
 8013bd8:	080305c0 	.word	0x080305c0
 8013bdc:	0803053c 	.word	0x0803053c
 8013be0:	08030560 	.word	0x08030560
 8013be4:	0803058c 	.word	0x0803058c

08013be8 <fRspAnalyze_CSIM>:

at_action_rsp_t fRspAnalyze_CSIM(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013be8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013bec:	4606      	mov	r6, r0
 8013bee:	4689      	mov	r9, r1
 8013bf0:	4690      	mov	r8, r2
 8013bf2:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CSIM()")
 8013bf4:	4c42      	ldr	r4, [pc, #264]	; (8013d00 <fRspAnalyze_CSIM+0x118>)
 8013bf6:	4d43      	ldr	r5, [pc, #268]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013bf8:	f104 0e20 	add.w	lr, r4, #32
 8013bfc:	46a4      	mov	ip, r4
 8013bfe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013c02:	6028      	str	r0, [r5, #0]
 8013c04:	6069      	str	r1, [r5, #4]
 8013c06:	60aa      	str	r2, [r5, #8]
 8013c08:	60eb      	str	r3, [r5, #12]
 8013c0a:	4664      	mov	r4, ip
 8013c0c:	3510      	adds	r5, #16
 8013c0e:	45f4      	cmp	ip, lr
 8013c10:	d1f4      	bne.n	8013bfc <fRspAnalyze_CSIM+0x14>
 8013c12:	cc03      	ldmia	r4!, {r0, r1}
 8013c14:	6028      	str	r0, [r5, #0]
 8013c16:	6069      	str	r1, [r5, #4]
 8013c18:	4c3a      	ldr	r4, [pc, #232]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013c1a:	4620      	mov	r0, r4
 8013c1c:	f00b fa79 	bl	801f112 <crs_strlen>
 8013c20:	b283      	uxth	r3, r0
 8013c22:	4622      	mov	r2, r4
 8013c24:	2104      	movs	r1, #4
 8013c26:	2002      	movs	r0, #2
 8013c28:	f00b fab6 	bl	801f198 <traceIF_itmPrint>
 8013c2c:	4620      	mov	r0, r4
 8013c2e:	f00b fa70 	bl	801f112 <crs_strlen>
 8013c32:	b283      	uxth	r3, r0
 8013c34:	4622      	mov	r2, r4
 8013c36:	2104      	movs	r1, #4
 8013c38:	2002      	movs	r0, #2
 8013c3a:	f00b facf 	bl	801f1dc <traceIF_uartPrint>
  /* analyze parameters for +CSIM
   *  answer to CSIM write command
   *     +CSIM: <length>,<response>
   */

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8013c3e:	8b33      	ldrh	r3, [r6, #24]
 8013c40:	2b03      	cmp	r3, #3
 8013c42:	d005      	beq.n	8013c50 <fRspAnalyze_CSIM+0x68>
    }

    END_PARAM_LOOP()
  }

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8013c44:	8b33      	ldrh	r3, [r6, #24]
 8013c46:	2b01      	cmp	r3, #1
 8013c48:	d032      	beq.n	8013cb0 <fRspAnalyze_CSIM+0xc8>
  {
    PRINT_DBG("+CSIM for test cmd NOT IMPLEMENTED")
  }

  return (retval);
}
 8013c4a:	2010      	movs	r0, #16
 8013c4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8013c50:	2400      	movs	r4, #0
 8013c52:	463a      	mov	r2, r7
 8013c54:	4641      	mov	r1, r8
 8013c56:	4630      	mov	r0, r6
 8013c58:	f7f8 fbf6 	bl	800c448 <atcc_extractElement>
 8013c5c:	2801      	cmp	r0, #1
 8013c5e:	d000      	beq.n	8013c62 <fRspAnalyze_CSIM+0x7a>
 8013c60:	2401      	movs	r4, #1
 8013c62:	89f9      	ldrh	r1, [r7, #14]
 8013c64:	b121      	cbz	r1, 8013c70 <fRspAnalyze_CSIM+0x88>
    if (element_infos->param_rank == 2U)
 8013c66:	893b      	ldrh	r3, [r7, #8]
 8013c68:	2b02      	cmp	r3, #2
 8013c6a:	d004      	beq.n	8013c76 <fRspAnalyze_CSIM+0x8e>
    else if (element_infos->param_rank == 3U)
 8013c6c:	2b03      	cmp	r3, #3
 8013c6e:	d009      	beq.n	8013c84 <fRspAnalyze_CSIM+0x9c>
    END_PARAM_LOOP()
 8013c70:	2c00      	cmp	r4, #0
 8013c72:	d1e7      	bne.n	8013c44 <fRspAnalyze_CSIM+0x5c>
 8013c74:	e7ed      	b.n	8013c52 <fRspAnalyze_CSIM+0x6a>
      uint32_t rsp_length = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013c76:	8978      	ldrh	r0, [r7, #10]
 8013c78:	4440      	add	r0, r8
 8013c7a:	f001 f85b 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->SID_ctxt.sim_generic_access.bytes_received = rsp_length;
 8013c7e:	f8c9 066c 	str.w	r0, [r9, #1644]	; 0x66c
 8013c82:	e7f5      	b.n	8013c70 <fRspAnalyze_CSIM+0x88>
      length_to_copy = ATC_GET_MINIMUM_SIZE(p_modem_ctxt->SID_ctxt.sim_generic_access.bytes_received,
 8013c84:	f8d9 3668 	ldr.w	r3, [r9, #1640]	; 0x668
 8013c88:	68dd      	ldr	r5, [r3, #12]
 8013c8a:	3d01      	subs	r5, #1
 8013c8c:	f8d9 266c 	ldr.w	r2, [r9, #1644]	; 0x66c
 8013c90:	4295      	cmp	r5, r2
 8013c92:	bf28      	it	cs
 8013c94:	4615      	movcs	r5, r2
                   (const CS_CHAR_t *)&p_msg_in->buffer[element_infos->str_start_idx + 1U],  /* skip '"' */
 8013c96:	8979      	ldrh	r1, [r7, #10]
 8013c98:	3101      	adds	r1, #1
      (void)memcpy((CRC_CHAR_t *)p_modem_ctxt->SID_ctxt.sim_generic_access.data->p_rsp_str,
 8013c9a:	462a      	mov	r2, r5
 8013c9c:	4441      	add	r1, r8
 8013c9e:	6858      	ldr	r0, [r3, #4]
 8013ca0:	f012 f936 	bl	8025f10 <memcpy>
      p_end = (uint8_t *)&p_modem_ctxt->SID_ctxt.sim_generic_access.data->p_rsp_str[length_to_copy];
 8013ca4:	f8d9 3668 	ldr.w	r3, [r9, #1640]	; 0x668
 8013ca8:	685b      	ldr	r3, [r3, #4]
      *p_end = (uint8_t)'\0';
 8013caa:	2200      	movs	r2, #0
 8013cac:	555a      	strb	r2, [r3, r5]
 8013cae:	e7df      	b.n	8013c70 <fRspAnalyze_CSIM+0x88>
    PRINT_DBG("+CSIM for test cmd NOT IMPLEMENTED")
 8013cb0:	4d15      	ldr	r5, [pc, #84]	; (8013d08 <fRspAnalyze_CSIM+0x120>)
 8013cb2:	4c14      	ldr	r4, [pc, #80]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013cb4:	f105 0720 	add.w	r7, r5, #32
 8013cb8:	462e      	mov	r6, r5
 8013cba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8013cbc:	6020      	str	r0, [r4, #0]
 8013cbe:	6061      	str	r1, [r4, #4]
 8013cc0:	60a2      	str	r2, [r4, #8]
 8013cc2:	60e3      	str	r3, [r4, #12]
 8013cc4:	4635      	mov	r5, r6
 8013cc6:	3410      	adds	r4, #16
 8013cc8:	42be      	cmp	r6, r7
 8013cca:	d1f5      	bne.n	8013cb8 <fRspAnalyze_CSIM+0xd0>
 8013ccc:	cd07      	ldmia	r5!, {r0, r1, r2}
 8013cce:	6020      	str	r0, [r4, #0]
 8013cd0:	6061      	str	r1, [r4, #4]
 8013cd2:	60a2      	str	r2, [r4, #8]
 8013cd4:	882b      	ldrh	r3, [r5, #0]
 8013cd6:	81a3      	strh	r3, [r4, #12]
 8013cd8:	4c0a      	ldr	r4, [pc, #40]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013cda:	4620      	mov	r0, r4
 8013cdc:	f00b fa19 	bl	801f112 <crs_strlen>
 8013ce0:	b283      	uxth	r3, r0
 8013ce2:	4622      	mov	r2, r4
 8013ce4:	2102      	movs	r1, #2
 8013ce6:	4608      	mov	r0, r1
 8013ce8:	f00b fa56 	bl	801f198 <traceIF_itmPrint>
 8013cec:	4620      	mov	r0, r4
 8013cee:	f00b fa10 	bl	801f112 <crs_strlen>
 8013cf2:	b283      	uxth	r3, r0
 8013cf4:	4622      	mov	r2, r4
 8013cf6:	2102      	movs	r1, #2
 8013cf8:	4608      	mov	r0, r1
 8013cfa:	f00b fa6f 	bl	801f1dc <traceIF_uartPrint>
 8013cfe:	e7a4      	b.n	8013c4a <fRspAnalyze_CSIM+0x62>
 8013d00:	080305f0 	.word	0x080305f0
 8013d04:	200048dc 	.word	0x200048dc
 8013d08:	08030618 	.word	0x08030618

08013d0c <fRspAnalyze_GSN>:
/* ==========================  Analyze V.25ter commands ========================== */
at_action_rsp_t fRspAnalyze_GSN(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013d0c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013d10:	4606      	mov	r6, r0
 8013d12:	4689      	mov	r9, r1
 8013d14:	4690      	mov	r8, r2
 8013d16:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_GSN()")
 8013d18:	4d2d      	ldr	r5, [pc, #180]	; (8013dd0 <fRspAnalyze_GSN+0xc4>)
 8013d1a:	4c2e      	ldr	r4, [pc, #184]	; (8013dd4 <fRspAnalyze_GSN+0xc8>)
 8013d1c:	f105 0e20 	add.w	lr, r5, #32
 8013d20:	46ac      	mov	ip, r5
 8013d22:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013d26:	6020      	str	r0, [r4, #0]
 8013d28:	6061      	str	r1, [r4, #4]
 8013d2a:	60a2      	str	r2, [r4, #8]
 8013d2c:	60e3      	str	r3, [r4, #12]
 8013d2e:	4665      	mov	r5, ip
 8013d30:	3410      	adds	r4, #16
 8013d32:	45f4      	cmp	ip, lr
 8013d34:	d1f4      	bne.n	8013d20 <fRspAnalyze_GSN+0x14>
 8013d36:	f8dc 0000 	ldr.w	r0, [ip]
 8013d3a:	6020      	str	r0, [r4, #0]
 8013d3c:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8013d40:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013d44:	80a2      	strh	r2, [r4, #4]
 8013d46:	71a3      	strb	r3, [r4, #6]
 8013d48:	4c22      	ldr	r4, [pc, #136]	; (8013dd4 <fRspAnalyze_GSN+0xc8>)
 8013d4a:	4620      	mov	r0, r4
 8013d4c:	f00b f9e1 	bl	801f112 <crs_strlen>
 8013d50:	b283      	uxth	r3, r0
 8013d52:	4622      	mov	r2, r4
 8013d54:	2104      	movs	r1, #4
 8013d56:	2002      	movs	r0, #2
 8013d58:	f00b fa1e 	bl	801f198 <traceIF_itmPrint>
 8013d5c:	4620      	mov	r0, r4
 8013d5e:	f00b f9d8 	bl	801f112 <crs_strlen>
 8013d62:	b283      	uxth	r3, r0
 8013d64:	4622      	mov	r2, r4
 8013d66:	2104      	movs	r1, #4
 8013d68:	2002      	movs	r0, #2
 8013d6a:	f00b fa37 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +GSN */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8013d6e:	8b33      	ldrh	r3, [r6, #24]
 8013d70:	2b04      	cmp	r3, #4
 8013d72:	d002      	beq.n	8013d7a <fRspAnalyze_GSN+0x6e>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t) element_infos->str_size);
  }

  return (retval);
}
 8013d74:	2010      	movs	r0, #16
 8013d76:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("IMEI:")
 8013d7a:	4d17      	ldr	r5, [pc, #92]	; (8013dd8 <fRspAnalyze_GSN+0xcc>)
 8013d7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013d7e:	6020      	str	r0, [r4, #0]
 8013d80:	6061      	str	r1, [r4, #4]
 8013d82:	60a2      	str	r2, [r4, #8]
 8013d84:	60e3      	str	r3, [r4, #12]
 8013d86:	782b      	ldrb	r3, [r5, #0]
 8013d88:	7423      	strb	r3, [r4, #16]
 8013d8a:	4620      	mov	r0, r4
 8013d8c:	f00b f9c1 	bl	801f112 <crs_strlen>
 8013d90:	b283      	uxth	r3, r0
 8013d92:	4622      	mov	r2, r4
 8013d94:	2102      	movs	r1, #2
 8013d96:	4608      	mov	r0, r1
 8013d98:	f00b f9fe 	bl	801f198 <traceIF_itmPrint>
 8013d9c:	4620      	mov	r0, r4
 8013d9e:	f00b f9b8 	bl	801f112 <crs_strlen>
 8013da2:	b283      	uxth	r3, r0
 8013da4:	4622      	mov	r2, r4
 8013da6:	2102      	movs	r1, #2
 8013da8:	4608      	mov	r0, r1
 8013daa:	f00b fa17 	bl	801f1dc <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8013dae:	897a      	ldrh	r2, [r7, #10]
 8013db0:	89fb      	ldrh	r3, [r7, #14]
 8013db2:	4442      	add	r2, r8
 8013db4:	2102      	movs	r1, #2
 8013db6:	4608      	mov	r0, r1
 8013db8:	f00b fcdc 	bl	801f774 <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei),
 8013dbc:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8013dc0:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei),
 8013dc2:	89fa      	ldrh	r2, [r7, #14]
 8013dc4:	4441      	add	r1, r8
 8013dc6:	3002      	adds	r0, #2
 8013dc8:	f012 f8a2 	bl	8025f10 <memcpy>
 8013dcc:	e7d2      	b.n	8013d74 <fRspAnalyze_GSN+0x68>
 8013dce:	bf00      	nop
 8013dd0:	08030648 	.word	0x08030648
 8013dd4:	200048dc 	.word	0x200048dc
 8013dd8:	0802f294 	.word	0x0802f294

08013ddc <fRspAnalyze_IPR>:

at_action_rsp_t fRspAnalyze_IPR(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013ddc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013de0:	4606      	mov	r6, r0
 8013de2:	4690      	mov	r8, r2
 8013de4:	461f      	mov	r7, r3
  UNUSED(p_msg_in); /* for MISRA-2012 */
#endif /* USE_TRACE_ATCUSTOM_MODEM */

  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_IPR()")
 8013de6:	4d3f      	ldr	r5, [pc, #252]	; (8013ee4 <fRspAnalyze_IPR+0x108>)
 8013de8:	4c3f      	ldr	r4, [pc, #252]	; (8013ee8 <fRspAnalyze_IPR+0x10c>)
 8013dea:	f105 0e20 	add.w	lr, r5, #32
 8013dee:	46ac      	mov	ip, r5
 8013df0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013df4:	6020      	str	r0, [r4, #0]
 8013df6:	6061      	str	r1, [r4, #4]
 8013df8:	60a2      	str	r2, [r4, #8]
 8013dfa:	60e3      	str	r3, [r4, #12]
 8013dfc:	4665      	mov	r5, ip
 8013dfe:	3410      	adds	r4, #16
 8013e00:	45f4      	cmp	ip, lr
 8013e02:	d1f4      	bne.n	8013dee <fRspAnalyze_IPR+0x12>
 8013e04:	f8dc 0000 	ldr.w	r0, [ip]
 8013e08:	6020      	str	r0, [r4, #0]
 8013e0a:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8013e0e:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013e12:	80a2      	strh	r2, [r4, #4]
 8013e14:	71a3      	strb	r3, [r4, #6]
 8013e16:	4c34      	ldr	r4, [pc, #208]	; (8013ee8 <fRspAnalyze_IPR+0x10c>)
 8013e18:	4620      	mov	r0, r4
 8013e1a:	f00b f97a 	bl	801f112 <crs_strlen>
 8013e1e:	b283      	uxth	r3, r0
 8013e20:	4622      	mov	r2, r4
 8013e22:	2104      	movs	r1, #4
 8013e24:	2002      	movs	r0, #2
 8013e26:	f00b f9b7 	bl	801f198 <traceIF_itmPrint>
 8013e2a:	4620      	mov	r0, r4
 8013e2c:	f00b f971 	bl	801f112 <crs_strlen>
 8013e30:	b283      	uxth	r3, r0
 8013e32:	4622      	mov	r2, r4
 8013e34:	2104      	movs	r1, #4
 8013e36:	2002      	movs	r0, #2
 8013e38:	f00b f9d0 	bl	801f1dc <traceIF_uartPrint>

  /* analyze parameters for +IPR */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8013e3c:	8b33      	ldrh	r3, [r6, #24]
 8013e3e:	2b02      	cmp	r3, #2
 8013e40:	d002      	beq.n	8013e48 <fRspAnalyze_IPR+0x6c>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8013e42:	2010      	movs	r0, #16
 8013e44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8013e48:	f04f 0900 	mov.w	r9, #0
 8013e4c:	463a      	mov	r2, r7
 8013e4e:	4641      	mov	r1, r8
 8013e50:	4630      	mov	r0, r6
 8013e52:	f7f8 faf9 	bl	800c448 <atcc_extractElement>
 8013e56:	2801      	cmp	r0, #1
 8013e58:	d001      	beq.n	8013e5e <fRspAnalyze_IPR+0x82>
 8013e5a:	f04f 0901 	mov.w	r9, #1
 8013e5e:	89fb      	ldrh	r3, [r7, #14]
 8013e60:	b91b      	cbnz	r3, 8013e6a <fRspAnalyze_IPR+0x8e>
    END_PARAM_LOOP()
 8013e62:	f1b9 0f00 	cmp.w	r9, #0
 8013e66:	d1ec      	bne.n	8013e42 <fRspAnalyze_IPR+0x66>
 8013e68:	e7f0      	b.n	8013e4c <fRspAnalyze_IPR+0x70>
    PRINT_DBG("BAUD RATE:")
 8013e6a:	4c1f      	ldr	r4, [pc, #124]	; (8013ee8 <fRspAnalyze_IPR+0x10c>)
 8013e6c:	4d1f      	ldr	r5, [pc, #124]	; (8013eec <fRspAnalyze_IPR+0x110>)
 8013e6e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013e70:	6020      	str	r0, [r4, #0]
 8013e72:	6061      	str	r1, [r4, #4]
 8013e74:	60a2      	str	r2, [r4, #8]
 8013e76:	60e3      	str	r3, [r4, #12]
 8013e78:	6828      	ldr	r0, [r5, #0]
 8013e7a:	6120      	str	r0, [r4, #16]
 8013e7c:	88ab      	ldrh	r3, [r5, #4]
 8013e7e:	82a3      	strh	r3, [r4, #20]
 8013e80:	4620      	mov	r0, r4
 8013e82:	f00b f946 	bl	801f112 <crs_strlen>
 8013e86:	b283      	uxth	r3, r0
 8013e88:	4622      	mov	r2, r4
 8013e8a:	2102      	movs	r1, #2
 8013e8c:	4608      	mov	r0, r1
 8013e8e:	f00b f983 	bl	801f198 <traceIF_itmPrint>
 8013e92:	4620      	mov	r0, r4
 8013e94:	f00b f93d 	bl	801f112 <crs_strlen>
 8013e98:	b283      	uxth	r3, r0
 8013e9a:	4622      	mov	r2, r4
 8013e9c:	2102      	movs	r1, #2
 8013e9e:	4608      	mov	r0, r1
 8013ea0:	f00b f99c 	bl	801f1dc <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 8013ea4:	893b      	ldrh	r3, [r7, #8]
 8013ea6:	2b02      	cmp	r3, #2
 8013ea8:	d1db      	bne.n	8013e62 <fRspAnalyze_IPR+0x86>
      PRINT_INFO("+IPR baud rate=%ld",
 8013eaa:	8978      	ldrh	r0, [r7, #10]
 8013eac:	89f9      	ldrh	r1, [r7, #14]
 8013eae:	4440      	add	r0, r8
 8013eb0:	f000 ff40 	bl	8014d34 <ATutil_convertStringToInt>
 8013eb4:	4602      	mov	r2, r0
 8013eb6:	490e      	ldr	r1, [pc, #56]	; (8013ef0 <fRspAnalyze_IPR+0x114>)
 8013eb8:	4620      	mov	r0, r4
 8013eba:	f011 fed9 	bl	8025c70 <sprintf>
 8013ebe:	4620      	mov	r0, r4
 8013ec0:	f00b f927 	bl	801f112 <crs_strlen>
 8013ec4:	b283      	uxth	r3, r0
 8013ec6:	4622      	mov	r2, r4
 8013ec8:	2101      	movs	r1, #1
 8013eca:	2002      	movs	r0, #2
 8013ecc:	f00b f964 	bl	801f198 <traceIF_itmPrint>
 8013ed0:	4620      	mov	r0, r4
 8013ed2:	f00b f91e 	bl	801f112 <crs_strlen>
 8013ed6:	b283      	uxth	r3, r0
 8013ed8:	4622      	mov	r2, r4
 8013eda:	2101      	movs	r1, #1
 8013edc:	2002      	movs	r0, #2
 8013ede:	f00b f97d 	bl	801f1dc <traceIF_uartPrint>
 8013ee2:	e7be      	b.n	8013e62 <fRspAnalyze_IPR+0x86>
 8013ee4:	08030670 	.word	0x08030670
 8013ee8:	200048dc 	.word	0x200048dc
 8013eec:	08030698 	.word	0x08030698
 8013ef0:	080306b0 	.word	0x080306b0

08013ef4 <fRspAnalyze_IFC>:

at_action_rsp_t fRspAnalyze_IFC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013ef4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8013ef8:	4680      	mov	r8, r0
 8013efa:	460e      	mov	r6, r1
 8013efc:	4691      	mov	r9, r2
 8013efe:	461f      	mov	r7, r3
  UNUSED(p_msg_in); /* for MISRA-2012 */
#endif /* USE_TRACE_ATCUSTOM_MODEM */

  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_IFC()")
 8013f00:	4d50      	ldr	r5, [pc, #320]	; (8014044 <fRspAnalyze_IFC+0x150>)
 8013f02:	4c51      	ldr	r4, [pc, #324]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013f04:	f105 0e20 	add.w	lr, r5, #32
 8013f08:	46ac      	mov	ip, r5
 8013f0a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013f0e:	6020      	str	r0, [r4, #0]
 8013f10:	6061      	str	r1, [r4, #4]
 8013f12:	60a2      	str	r2, [r4, #8]
 8013f14:	60e3      	str	r3, [r4, #12]
 8013f16:	4665      	mov	r5, ip
 8013f18:	3410      	adds	r4, #16
 8013f1a:	45f4      	cmp	ip, lr
 8013f1c:	d1f4      	bne.n	8013f08 <fRspAnalyze_IFC+0x14>
 8013f1e:	f8dc 0000 	ldr.w	r0, [ip]
 8013f22:	6020      	str	r0, [r4, #0]
 8013f24:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8013f28:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013f2c:	80a2      	strh	r2, [r4, #4]
 8013f2e:	71a3      	strb	r3, [r4, #6]
 8013f30:	4c45      	ldr	r4, [pc, #276]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013f32:	4620      	mov	r0, r4
 8013f34:	f00b f8ed 	bl	801f112 <crs_strlen>
 8013f38:	b283      	uxth	r3, r0
 8013f3a:	4622      	mov	r2, r4
 8013f3c:	2104      	movs	r1, #4
 8013f3e:	2002      	movs	r0, #2
 8013f40:	f00b f92a 	bl	801f198 <traceIF_itmPrint>
 8013f44:	4620      	mov	r0, r4
 8013f46:	f00b f8e4 	bl	801f112 <crs_strlen>
 8013f4a:	b283      	uxth	r3, r0
 8013f4c:	4622      	mov	r2, r4
 8013f4e:	2104      	movs	r1, #4
 8013f50:	2002      	movs	r0, #2
 8013f52:	f00b f943 	bl	801f1dc <traceIF_uartPrint>

  /* initialize RTS and CTS with invalid values */
  p_modem_ctxt->persist.flowCtrl_RTS = 0xFF;
 8013f56:	23ff      	movs	r3, #255	; 0xff
 8013f58:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
  p_modem_ctxt->persist.flowCtrl_CTS = 0xFF;
 8013f5c:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515

  /* analyze parameters for +IFC */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8013f60:	f8b8 3018 	ldrh.w	r3, [r8, #24]
 8013f64:	2b02      	cmp	r3, #2
 8013f66:	d002      	beq.n	8013f6e <fRspAnalyze_IFC+0x7a>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8013f68:	2010      	movs	r0, #16
 8013f6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    START_PARAM_LOOP()
 8013f6e:	2400      	movs	r4, #0
 8013f70:	463a      	mov	r2, r7
 8013f72:	4649      	mov	r1, r9
 8013f74:	4640      	mov	r0, r8
 8013f76:	f7f8 fa67 	bl	800c448 <atcc_extractElement>
 8013f7a:	2801      	cmp	r0, #1
 8013f7c:	d000      	beq.n	8013f80 <fRspAnalyze_IFC+0x8c>
 8013f7e:	2401      	movs	r4, #1
 8013f80:	89f9      	ldrh	r1, [r7, #14]
 8013f82:	b129      	cbz	r1, 8013f90 <fRspAnalyze_IFC+0x9c>
    if (element_infos->param_rank == 2U)
 8013f84:	893b      	ldrh	r3, [r7, #8]
 8013f86:	2b02      	cmp	r3, #2
 8013f88:	d005      	beq.n	8013f96 <fRspAnalyze_IFC+0xa2>
    if (element_infos->param_rank == 3U)
 8013f8a:	893b      	ldrh	r3, [r7, #8]
 8013f8c:	2b03      	cmp	r3, #3
 8013f8e:	d02d      	beq.n	8013fec <fRspAnalyze_IFC+0xf8>
    END_PARAM_LOOP()
 8013f90:	2c00      	cmp	r4, #0
 8013f92:	d1e9      	bne.n	8013f68 <fRspAnalyze_IFC+0x74>
 8013f94:	e7ec      	b.n	8013f70 <fRspAnalyze_IFC+0x7c>
      uint32_t rts_fc = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013f96:	8978      	ldrh	r0, [r7, #10]
 8013f98:	4448      	add	r0, r9
 8013f9a:	f000 fecb 	bl	8014d34 <ATutil_convertStringToInt>
 8013f9e:	4682      	mov	sl, r0
      PRINT_DBG("+IFC: RTS flow control=%ld", rts_fc)
 8013fa0:	4d29      	ldr	r5, [pc, #164]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013fa2:	4602      	mov	r2, r0
 8013fa4:	4929      	ldr	r1, [pc, #164]	; (801404c <fRspAnalyze_IFC+0x158>)
 8013fa6:	4628      	mov	r0, r5
 8013fa8:	f011 fe62 	bl	8025c70 <sprintf>
 8013fac:	4628      	mov	r0, r5
 8013fae:	f00b f8b0 	bl	801f112 <crs_strlen>
 8013fb2:	b283      	uxth	r3, r0
 8013fb4:	462a      	mov	r2, r5
 8013fb6:	2102      	movs	r1, #2
 8013fb8:	4608      	mov	r0, r1
 8013fba:	f00b f8ed 	bl	801f198 <traceIF_itmPrint>
 8013fbe:	4628      	mov	r0, r5
 8013fc0:	f00b f8a7 	bl	801f112 <crs_strlen>
 8013fc4:	b283      	uxth	r3, r0
 8013fc6:	462a      	mov	r2, r5
 8013fc8:	2102      	movs	r1, #2
 8013fca:	4608      	mov	r0, r1
 8013fcc:	f00b f906 	bl	801f1dc <traceIF_uartPrint>
      if (rts_fc == 2U)
 8013fd0:	f1ba 0f02 	cmp.w	sl, #2
 8013fd4:	d006      	beq.n	8013fe4 <fRspAnalyze_IFC+0xf0>
      else if (rts_fc == 0U)
 8013fd6:	f1ba 0f00 	cmp.w	sl, #0
 8013fda:	d1d6      	bne.n	8013f8a <fRspAnalyze_IFC+0x96>
        p_modem_ctxt->persist.flowCtrl_RTS = 0U;
 8013fdc:	2300      	movs	r3, #0
 8013fde:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
 8013fe2:	e7d2      	b.n	8013f8a <fRspAnalyze_IFC+0x96>
        p_modem_ctxt->persist.flowCtrl_RTS = 2U;
 8013fe4:	2302      	movs	r3, #2
 8013fe6:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
 8013fea:	e7ce      	b.n	8013f8a <fRspAnalyze_IFC+0x96>
      uint32_t cts_fc = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013fec:	8978      	ldrh	r0, [r7, #10]
 8013fee:	89f9      	ldrh	r1, [r7, #14]
 8013ff0:	4448      	add	r0, r9
 8013ff2:	f000 fe9f 	bl	8014d34 <ATutil_convertStringToInt>
 8013ff6:	4682      	mov	sl, r0
      PRINT_DBG("+IFC: CTS flow control=%ld", cts_fc)
 8013ff8:	4d13      	ldr	r5, [pc, #76]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013ffa:	4602      	mov	r2, r0
 8013ffc:	4914      	ldr	r1, [pc, #80]	; (8014050 <fRspAnalyze_IFC+0x15c>)
 8013ffe:	4628      	mov	r0, r5
 8014000:	f011 fe36 	bl	8025c70 <sprintf>
 8014004:	4628      	mov	r0, r5
 8014006:	f00b f884 	bl	801f112 <crs_strlen>
 801400a:	b283      	uxth	r3, r0
 801400c:	462a      	mov	r2, r5
 801400e:	2102      	movs	r1, #2
 8014010:	4608      	mov	r0, r1
 8014012:	f00b f8c1 	bl	801f198 <traceIF_itmPrint>
 8014016:	4628      	mov	r0, r5
 8014018:	f00b f87b 	bl	801f112 <crs_strlen>
 801401c:	b283      	uxth	r3, r0
 801401e:	462a      	mov	r2, r5
 8014020:	2102      	movs	r1, #2
 8014022:	4608      	mov	r0, r1
 8014024:	f00b f8da 	bl	801f1dc <traceIF_uartPrint>
      if (cts_fc == 2U)
 8014028:	f1ba 0f02 	cmp.w	sl, #2
 801402c:	d006      	beq.n	801403c <fRspAnalyze_IFC+0x148>
      else if (cts_fc == 0U)
 801402e:	f1ba 0f00 	cmp.w	sl, #0
 8014032:	d1ad      	bne.n	8013f90 <fRspAnalyze_IFC+0x9c>
        p_modem_ctxt->persist.flowCtrl_CTS = 0U;
 8014034:	2300      	movs	r3, #0
 8014036:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 801403a:	e7a9      	b.n	8013f90 <fRspAnalyze_IFC+0x9c>
        p_modem_ctxt->persist.flowCtrl_CTS = 2U;
 801403c:	2302      	movs	r3, #2
 801403e:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 8014042:	e7a5      	b.n	8013f90 <fRspAnalyze_IFC+0x9c>
 8014044:	080306d0 	.word	0x080306d0
 8014048:	200048dc 	.word	0x200048dc
 801404c:	080306f8 	.word	0x080306f8
 8014050:	08030720 	.word	0x08030720

08014054 <fRspAnalyze_DIRECT_CMD>:

at_action_rsp_t fRspAnalyze_DIRECT_CMD(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                       const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8014054:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_at_ctxt);
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_DIRECT_CMD()")
 8014056:	4c15      	ldr	r4, [pc, #84]	; (80140ac <fRspAnalyze_DIRECT_CMD+0x58>)
 8014058:	4d15      	ldr	r5, [pc, #84]	; (80140b0 <fRspAnalyze_DIRECT_CMD+0x5c>)
 801405a:	f104 0e20 	add.w	lr, r4, #32
 801405e:	46a4      	mov	ip, r4
 8014060:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014064:	6028      	str	r0, [r5, #0]
 8014066:	6069      	str	r1, [r5, #4]
 8014068:	60aa      	str	r2, [r5, #8]
 801406a:	60eb      	str	r3, [r5, #12]
 801406c:	4664      	mov	r4, ip
 801406e:	3510      	adds	r5, #16
 8014070:	45f4      	cmp	ip, lr
 8014072:	d1f4      	bne.n	801405e <fRspAnalyze_DIRECT_CMD+0xa>
 8014074:	cc07      	ldmia	r4!, {r0, r1, r2}
 8014076:	6028      	str	r0, [r5, #0]
 8014078:	6069      	str	r1, [r5, #4]
 801407a:	60aa      	str	r2, [r5, #8]
 801407c:	8823      	ldrh	r3, [r4, #0]
 801407e:	81ab      	strh	r3, [r5, #12]
 8014080:	4c0b      	ldr	r4, [pc, #44]	; (80140b0 <fRspAnalyze_DIRECT_CMD+0x5c>)
 8014082:	4620      	mov	r0, r4
 8014084:	f00b f845 	bl	801f112 <crs_strlen>
 8014088:	b283      	uxth	r3, r0
 801408a:	4622      	mov	r2, r4
 801408c:	2104      	movs	r1, #4
 801408e:	2002      	movs	r0, #2
 8014090:	f00b f882 	bl	801f198 <traceIF_itmPrint>
 8014094:	4620      	mov	r0, r4
 8014096:	f00b f83c 	bl	801f112 <crs_strlen>
 801409a:	b283      	uxth	r3, r0
 801409c:	4622      	mov	r2, r4
 801409e:	2104      	movs	r1, #4
 80140a0:	2002      	movs	r0, #2
 80140a2:	f00b f89b 	bl	801f1dc <traceIF_uartPrint>

  /* NOT IMPLEMENTED YET */

  return (retval);
}
 80140a6:	2010      	movs	r0, #16
 80140a8:	bd38      	pop	{r3, r4, r5, pc}
 80140aa:	bf00      	nop
 80140ac:	08030748 	.word	0x08030748
 80140b0:	200048dc 	.word	0x200048dc

080140b4 <atcm_socket_release_modem_cid>:
/**
  * @brief  This function release a modem connection Id (ID shared between at-custom and the modem)
  *         to a socket handle (ID shared between upper layers and at-custom)
  */
at_status_t atcm_socket_release_modem_cid(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 80140b4:	b570      	push	{r4, r5, r6, lr}
 80140b6:	b082      	sub	sp, #8
 80140b8:	460c      	mov	r4, r1
  at_status_t retval;

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 80140ba:	f1b1 3fff 	cmp.w	r1, #4294967295
 80140be:	d034      	beq.n	801412a <atcm_socket_release_modem_cid+0x76>
 80140c0:	4605      	mov	r5, r0
    PRINT_INFO("socket handle %ld not valid", sockHandle)
    retval = ATSTATUS_ERROR;
  }
  else
  {
    if ((p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc == AT_TRUE) ||
 80140c2:	f501 739e 	add.w	r3, r1, #316	; 0x13c
 80140c6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80140ca:	79db      	ldrb	r3, [r3, #7]
 80140cc:	b92b      	cbnz	r3, 80140da <atcm_socket_release_modem_cid+0x26>
        (p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc == AT_TRUE))
 80140ce:	f501 729e 	add.w	r2, r1, #316	; 0x13c
 80140d2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80140d6:	7a12      	ldrb	r2, [r2, #8]
    if ((p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc == AT_TRUE) ||
 80140d8:	b1ea      	cbz	r2, 8014116 <atcm_socket_release_modem_cid+0x62>
    {
      /* Trace only */
      PRINT_INFO("Warning, there was pending URC for socket handle %ld: (%d)data pending urc,(%d) closed by remote urc",
 80140da:	f504 729e 	add.w	r2, r4, #316	; 0x13c
 80140de:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 80140e2:	7a12      	ldrb	r2, [r2, #8]
 80140e4:	4e1e      	ldr	r6, [pc, #120]	; (8014160 <atcm_socket_release_modem_cid+0xac>)
 80140e6:	9200      	str	r2, [sp, #0]
 80140e8:	4622      	mov	r2, r4
 80140ea:	491e      	ldr	r1, [pc, #120]	; (8014164 <atcm_socket_release_modem_cid+0xb0>)
 80140ec:	4630      	mov	r0, r6
 80140ee:	f011 fdbf 	bl	8025c70 <sprintf>
 80140f2:	4630      	mov	r0, r6
 80140f4:	f00b f80d 	bl	801f112 <crs_strlen>
 80140f8:	b283      	uxth	r3, r0
 80140fa:	4632      	mov	r2, r6
 80140fc:	2101      	movs	r1, #1
 80140fe:	2002      	movs	r0, #2
 8014100:	f00b f84a 	bl	801f198 <traceIF_itmPrint>
 8014104:	4630      	mov	r0, r6
 8014106:	f00b f804 	bl	801f112 <crs_strlen>
 801410a:	b283      	uxth	r3, r0
 801410c:	4632      	mov	r2, r6
 801410e:	2101      	movs	r1, #1
 8014110:	2002      	movs	r0, #2
 8014112:	f00b f863 	bl	801f1dc <traceIF_uartPrint>
                 sockHandle,
                 p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc,
                 p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc)
    }

    p_modem_ctxt->persist.socket[sockHandle].socket_connected = AT_FALSE;
 8014116:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 801411a:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 801411e:	2000      	movs	r0, #0
 8014120:	71a8      	strb	r0, [r5, #6]
    p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc = AT_FALSE;
 8014122:	71e8      	strb	r0, [r5, #7]
    p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc = AT_FALSE;
 8014124:	7228      	strb	r0, [r5, #8]
    retval = ATSTATUS_OK;
  }

  return (retval);
}
 8014126:	b002      	add	sp, #8
 8014128:	bd70      	pop	{r4, r5, r6, pc}
    PRINT_INFO("socket handle %ld not valid", sockHandle)
 801412a:	4d0d      	ldr	r5, [pc, #52]	; (8014160 <atcm_socket_release_modem_cid+0xac>)
 801412c:	460a      	mov	r2, r1
 801412e:	490e      	ldr	r1, [pc, #56]	; (8014168 <atcm_socket_release_modem_cid+0xb4>)
 8014130:	4628      	mov	r0, r5
 8014132:	f011 fd9d 	bl	8025c70 <sprintf>
 8014136:	4628      	mov	r0, r5
 8014138:	f00a ffeb 	bl	801f112 <crs_strlen>
 801413c:	b283      	uxth	r3, r0
 801413e:	462a      	mov	r2, r5
 8014140:	2101      	movs	r1, #1
 8014142:	2002      	movs	r0, #2
 8014144:	f00b f828 	bl	801f198 <traceIF_itmPrint>
 8014148:	4628      	mov	r0, r5
 801414a:	f00a ffe2 	bl	801f112 <crs_strlen>
 801414e:	b283      	uxth	r3, r0
 8014150:	462a      	mov	r2, r5
 8014152:	2101      	movs	r1, #1
 8014154:	2002      	movs	r0, #2
 8014156:	f00b f841 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 801415a:	2001      	movs	r0, #1
 801415c:	e7e3      	b.n	8014126 <atcm_socket_release_modem_cid+0x72>
 801415e:	bf00      	nop
 8014160:	200048dc 	.word	0x200048dc
 8014164:	080307e0 	.word	0x080307e0
 8014168:	080307b8 	.word	0x080307b8

0801416c <atcm_socket_get_modem_cid>:
  */
uint32_t atcm_socket_get_modem_cid(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
  uint32_t cid;

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 801416c:	f1b1 3fff 	cmp.w	r1, #4294967295
 8014170:	d005      	beq.n	801417e <atcm_socket_get_modem_cid+0x12>
    cid = 0U;
  }
  else
  {
    /* find  connectid corresponding to this socket_handle */
    cid = (uint32_t)(p_modem_ctxt->persist.socket[sockHandle].socket_connId_value);
 8014172:	f501 719e 	add.w	r1, r1, #316	; 0x13c
 8014176:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 801417a:	7940      	ldrb	r0, [r0, #5]
  }

  return (cid);
}
 801417c:	4770      	bx	lr
{
 801417e:	b510      	push	{r4, lr}
    PRINT_INFO("socket handle %ld not valid", sockHandle)
 8014180:	4c0c      	ldr	r4, [pc, #48]	; (80141b4 <atcm_socket_get_modem_cid+0x48>)
 8014182:	460a      	mov	r2, r1
 8014184:	490c      	ldr	r1, [pc, #48]	; (80141b8 <atcm_socket_get_modem_cid+0x4c>)
 8014186:	4620      	mov	r0, r4
 8014188:	f011 fd72 	bl	8025c70 <sprintf>
 801418c:	4620      	mov	r0, r4
 801418e:	f00a ffc0 	bl	801f112 <crs_strlen>
 8014192:	b283      	uxth	r3, r0
 8014194:	4622      	mov	r2, r4
 8014196:	2101      	movs	r1, #1
 8014198:	2002      	movs	r0, #2
 801419a:	f00a fffd 	bl	801f198 <traceIF_itmPrint>
 801419e:	4620      	mov	r0, r4
 80141a0:	f00a ffb7 	bl	801f112 <crs_strlen>
 80141a4:	b283      	uxth	r3, r0
 80141a6:	4622      	mov	r2, r4
 80141a8:	2101      	movs	r1, #1
 80141aa:	2002      	movs	r0, #2
 80141ac:	f00b f816 	bl	801f1dc <traceIF_uartPrint>
    cid = 0U;
 80141b0:	2000      	movs	r0, #0
}
 80141b2:	bd10      	pop	{r4, pc}
 80141b4:	200048dc 	.word	0x200048dc
 80141b8:	080307b8 	.word	0x080307b8

080141bc <atcm_socket_set_modem_cid>:
at_status_t atcm_socket_set_modem_cid(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle,
                                      uint32_t modemcid)
{
  at_status_t retval;

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 80141bc:	f1b1 3fff 	cmp.w	r1, #4294967295
 80141c0:	d006      	beq.n	80141d0 <atcm_socket_set_modem_cid+0x14>
    PRINT_INFO("socket handle %ld not valid", sockHandle)
    retval = ATSTATUS_ERROR;
  }
  else
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_connId_value = (uint8_t) modemcid;
 80141c2:	f501 719e 	add.w	r1, r1, #316	; 0x13c
 80141c6:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 80141ca:	7142      	strb	r2, [r0, #5]
    retval = ATSTATUS_OK;
 80141cc:	2000      	movs	r0, #0
  }

  return (retval);
}
 80141ce:	4770      	bx	lr
{
 80141d0:	b510      	push	{r4, lr}
    PRINT_INFO("socket handle %ld not valid", sockHandle)
 80141d2:	4c0d      	ldr	r4, [pc, #52]	; (8014208 <atcm_socket_set_modem_cid+0x4c>)
 80141d4:	460a      	mov	r2, r1
 80141d6:	490d      	ldr	r1, [pc, #52]	; (801420c <atcm_socket_set_modem_cid+0x50>)
 80141d8:	4620      	mov	r0, r4
 80141da:	f011 fd49 	bl	8025c70 <sprintf>
 80141de:	4620      	mov	r0, r4
 80141e0:	f00a ff97 	bl	801f112 <crs_strlen>
 80141e4:	b283      	uxth	r3, r0
 80141e6:	4622      	mov	r2, r4
 80141e8:	2101      	movs	r1, #1
 80141ea:	2002      	movs	r0, #2
 80141ec:	f00a ffd4 	bl	801f198 <traceIF_itmPrint>
 80141f0:	4620      	mov	r0, r4
 80141f2:	f00a ff8e 	bl	801f112 <crs_strlen>
 80141f6:	b283      	uxth	r3, r0
 80141f8:	4622      	mov	r2, r4
 80141fa:	2101      	movs	r1, #1
 80141fc:	2002      	movs	r0, #2
 80141fe:	f00a ffed 	bl	801f1dc <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 8014202:	2001      	movs	r0, #1
}
 8014204:	bd10      	pop	{r4, pc}
 8014206:	bf00      	nop
 8014208:	200048dc 	.word	0x200048dc
 801420c:	080307b8 	.word	0x080307b8

08014210 <atcm_socket_get_socket_handle>:
/**
  * @brief  This function returns the socket handle (ID shared between upper layers and at-custom)
  *         corresponding to modem connection Id (ID shared between at-custom and the modem)
  */
socket_handle_t atcm_socket_get_socket_handle(const atcustom_modem_context_t *p_modem_ctxt, uint32_t modemCID)
{
 8014210:	b538      	push	{r3, r4, r5, lr}
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8014212:	2300      	movs	r3, #0
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;
 8014214:	f04f 34ff 	mov.w	r4, #4294967295
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8014218:	e001      	b.n	801421e <atcm_socket_get_socket_handle+0xe>
 801421a:	3301      	adds	r3, #1
 801421c:	b2db      	uxtb	r3, r3
 801421e:	2b05      	cmp	r3, #5
 8014220:	d809      	bhi.n	8014236 <atcm_socket_get_socket_handle+0x26>
  {
    const atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
    if (p_tmp->socket_connId_value == modemCID)
 8014222:	f503 7c9e 	add.w	ip, r3, #316	; 0x13c
 8014226:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 801422a:	f89c c005 	ldrb.w	ip, [ip, #5]
 801422e:	458c      	cmp	ip, r1
 8014230:	d1f3      	bne.n	801421a <atcm_socket_get_socket_handle+0xa>
    {
      sockHandle = (socket_handle_t)i;
 8014232:	461c      	mov	r4, r3
 8014234:	e7f1      	b.n	801421a <atcm_socket_get_socket_handle+0xa>
    }
  }

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 8014236:	f1b4 3fff 	cmp.w	r4, #4294967295
 801423a:	d001      	beq.n	8014240 <atcm_socket_get_socket_handle+0x30>
    /* Trace only */
    PRINT_INFO("Can not find valid socket handle for modem CID=%ld", modemCID)
  }

  return (sockHandle);
}
 801423c:	4620      	mov	r0, r4
 801423e:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_INFO("Can not find valid socket handle for modem CID=%ld", modemCID)
 8014240:	4d0c      	ldr	r5, [pc, #48]	; (8014274 <atcm_socket_get_socket_handle+0x64>)
 8014242:	460a      	mov	r2, r1
 8014244:	490c      	ldr	r1, [pc, #48]	; (8014278 <atcm_socket_get_socket_handle+0x68>)
 8014246:	4628      	mov	r0, r5
 8014248:	f011 fd12 	bl	8025c70 <sprintf>
 801424c:	4628      	mov	r0, r5
 801424e:	f00a ff60 	bl	801f112 <crs_strlen>
 8014252:	b283      	uxth	r3, r0
 8014254:	462a      	mov	r2, r5
 8014256:	2101      	movs	r1, #1
 8014258:	2002      	movs	r0, #2
 801425a:	f00a ff9d 	bl	801f198 <traceIF_itmPrint>
 801425e:	4628      	mov	r0, r5
 8014260:	f00a ff57 	bl	801f112 <crs_strlen>
 8014264:	b283      	uxth	r3, r0
 8014266:	462a      	mov	r2, r5
 8014268:	2101      	movs	r1, #1
 801426a:	2002      	movs	r0, #2
 801426c:	f00a ffb6 	bl	801f1dc <traceIF_uartPrint>
  return (sockHandle);
 8014270:	e7e4      	b.n	801423c <atcm_socket_get_socket_handle+0x2c>
 8014272:	bf00      	nop
 8014274:	200048dc 	.word	0x200048dc
 8014278:	08030850 	.word	0x08030850

0801427c <atcm_socket_set_urc_data_pending>:
/**
  * @brief  This function set the "socket data received" URC for a
  *         socket handle (ID shared between upper layers and at-custom)
  */
at_status_t atcm_socket_set_urc_data_pending(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 801427c:	b570      	push	{r4, r5, r6, lr}
 801427e:	4606      	mov	r6, r0
 8014280:	460c      	mov	r4, r1
  at_status_t retval = ATSTATUS_OK;

  PRINT_API("enter atcm_socket_set_urc_data_pending sockHandle=%ld", sockHandle)
 8014282:	4d13      	ldr	r5, [pc, #76]	; (80142d0 <atcm_socket_set_urc_data_pending+0x54>)
 8014284:	460a      	mov	r2, r1
 8014286:	4913      	ldr	r1, [pc, #76]	; (80142d4 <atcm_socket_set_urc_data_pending+0x58>)
 8014288:	4628      	mov	r0, r5
 801428a:	f011 fcf1 	bl	8025c70 <sprintf>
 801428e:	4628      	mov	r0, r5
 8014290:	f00a ff3f 	bl	801f112 <crs_strlen>
 8014294:	b283      	uxth	r3, r0
 8014296:	462a      	mov	r2, r5
 8014298:	2104      	movs	r1, #4
 801429a:	2002      	movs	r0, #2
 801429c:	f00a ff7c 	bl	801f198 <traceIF_itmPrint>
 80142a0:	4628      	mov	r0, r5
 80142a2:	f00a ff36 	bl	801f112 <crs_strlen>
 80142a6:	b283      	uxth	r3, r0
 80142a8:	462a      	mov	r2, r5
 80142aa:	2104      	movs	r1, #4
 80142ac:	2002      	movs	r0, #2
 80142ae:	f00a ff95 	bl	801f1dc <traceIF_uartPrint>

  if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 80142b2:	f1b4 3fff 	cmp.w	r4, #4294967295
 80142b6:	d008      	beq.n	80142ca <atcm_socket_set_urc_data_pending+0x4e>
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc = AT_TRUE;
 80142b8:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 80142bc:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 80142c0:	2301      	movs	r3, #1
 80142c2:	71e3      	strb	r3, [r4, #7]
    p_modem_ctxt->persist.urc_avail_socket_data_pending = AT_TRUE;
 80142c4:	77b3      	strb	r3, [r6, #30]
  at_status_t retval = ATSTATUS_OK;
 80142c6:	2000      	movs	r0, #0
  {
    retval = ATSTATUS_ERROR;
  }

  return (retval);
}
 80142c8:	bd70      	pop	{r4, r5, r6, pc}
    retval = ATSTATUS_ERROR;
 80142ca:	2001      	movs	r0, #1
 80142cc:	e7fc      	b.n	80142c8 <atcm_socket_set_urc_data_pending+0x4c>
 80142ce:	bf00      	nop
 80142d0:	200048dc 	.word	0x200048dc
 80142d4:	08030890 	.word	0x08030890

080142d8 <atcm_socket_set_urc_closed_by_remote>:
/**
  * @brief  This function set the "socket closed by remote" URC for a
  *         socket handle (ID shared between upper layers and at-custom)
  */
at_status_t atcm_socket_set_urc_closed_by_remote(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 80142d8:	b570      	push	{r4, r5, r6, lr}
 80142da:	4606      	mov	r6, r0
 80142dc:	460c      	mov	r4, r1
  at_status_t retval = ATSTATUS_OK;

  PRINT_API("enter atcm_socket_set_urc_closed_by_remote sockHandle=%ld", sockHandle)
 80142de:	4d13      	ldr	r5, [pc, #76]	; (801432c <atcm_socket_set_urc_closed_by_remote+0x54>)
 80142e0:	460a      	mov	r2, r1
 80142e2:	4913      	ldr	r1, [pc, #76]	; (8014330 <atcm_socket_set_urc_closed_by_remote+0x58>)
 80142e4:	4628      	mov	r0, r5
 80142e6:	f011 fcc3 	bl	8025c70 <sprintf>
 80142ea:	4628      	mov	r0, r5
 80142ec:	f00a ff11 	bl	801f112 <crs_strlen>
 80142f0:	b283      	uxth	r3, r0
 80142f2:	462a      	mov	r2, r5
 80142f4:	2104      	movs	r1, #4
 80142f6:	2002      	movs	r0, #2
 80142f8:	f00a ff4e 	bl	801f198 <traceIF_itmPrint>
 80142fc:	4628      	mov	r0, r5
 80142fe:	f00a ff08 	bl	801f112 <crs_strlen>
 8014302:	b283      	uxth	r3, r0
 8014304:	462a      	mov	r2, r5
 8014306:	2104      	movs	r1, #4
 8014308:	2002      	movs	r0, #2
 801430a:	f00a ff67 	bl	801f1dc <traceIF_uartPrint>

  if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 801430e:	f1b4 3fff 	cmp.w	r4, #4294967295
 8014312:	d008      	beq.n	8014326 <atcm_socket_set_urc_closed_by_remote+0x4e>
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc = AT_TRUE;
 8014314:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 8014318:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 801431c:	2301      	movs	r3, #1
 801431e:	7223      	strb	r3, [r4, #8]
    p_modem_ctxt->persist.urc_avail_socket_closed_by_remote = AT_TRUE;
 8014320:	77f3      	strb	r3, [r6, #31]
  at_status_t retval = ATSTATUS_OK;
 8014322:	2000      	movs	r0, #0
  {
    retval = ATSTATUS_ERROR;
  }

  return (retval);
}
 8014324:	bd70      	pop	{r4, r5, r6, pc}
    retval = ATSTATUS_ERROR;
 8014326:	2001      	movs	r0, #1
 8014328:	e7fc      	b.n	8014324 <atcm_socket_set_urc_closed_by_remote+0x4c>
 801432a:	bf00      	nop
 801432c:	200048dc 	.word	0x200048dc
 8014330:	080308d8 	.word	0x080308d8

08014334 <atcm_socket_get_hdle_urc_data_pending>:
/**
  * @brief  This function returns the socket handle of "socket data received" URC
  *         and clears it
  */
socket_handle_t atcm_socket_get_hdle_urc_data_pending(atcustom_modem_context_t *p_modem_ctxt)
{
 8014334:	b570      	push	{r4, r5, r6, lr}
 8014336:	4606      	mov	r6, r0
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;

  PRINT_API("enter atcm_socket_get_hdle_urc_data_pending")
 8014338:	4d1f      	ldr	r5, [pc, #124]	; (80143b8 <atcm_socket_get_hdle_urc_data_pending+0x84>)
 801433a:	4c20      	ldr	r4, [pc, #128]	; (80143bc <atcm_socket_get_hdle_urc_data_pending+0x88>)
 801433c:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8014340:	46ac      	mov	ip, r5
 8014342:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014346:	6020      	str	r0, [r4, #0]
 8014348:	6061      	str	r1, [r4, #4]
 801434a:	60a2      	str	r2, [r4, #8]
 801434c:	60e3      	str	r3, [r4, #12]
 801434e:	4665      	mov	r5, ip
 8014350:	3410      	adds	r4, #16
 8014352:	45f4      	cmp	ip, lr
 8014354:	d1f4      	bne.n	8014340 <atcm_socket_get_hdle_urc_data_pending+0xc>
 8014356:	cd03      	ldmia	r5!, {r0, r1}
 8014358:	6020      	str	r0, [r4, #0]
 801435a:	6061      	str	r1, [r4, #4]
 801435c:	882a      	ldrh	r2, [r5, #0]
 801435e:	78ab      	ldrb	r3, [r5, #2]
 8014360:	8122      	strh	r2, [r4, #8]
 8014362:	72a3      	strb	r3, [r4, #10]
 8014364:	4c15      	ldr	r4, [pc, #84]	; (80143bc <atcm_socket_get_hdle_urc_data_pending+0x88>)
 8014366:	4620      	mov	r0, r4
 8014368:	f00a fed3 	bl	801f112 <crs_strlen>
 801436c:	b283      	uxth	r3, r0
 801436e:	4622      	mov	r2, r4
 8014370:	2104      	movs	r1, #4
 8014372:	2002      	movs	r0, #2
 8014374:	f00a ff10 	bl	801f198 <traceIF_itmPrint>
 8014378:	4620      	mov	r0, r4
 801437a:	f00a feca 	bl	801f112 <crs_strlen>
 801437e:	b283      	uxth	r3, r0
 8014380:	4622      	mov	r2, r4
 8014382:	2104      	movs	r1, #4
 8014384:	2002      	movs	r0, #2
 8014386:	f00a ff29 	bl	801f1dc <traceIF_uartPrint>

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801438a:	2300      	movs	r3, #0
 801438c:	2b05      	cmp	r3, #5
 801438e:	d810      	bhi.n	80143b2 <atcm_socket_get_hdle_urc_data_pending+0x7e>
  {
    atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
 8014390:	4618      	mov	r0, r3
    if (p_tmp->socket_data_pending_urc == AT_TRUE)
 8014392:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8014396:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 801439a:	79d2      	ldrb	r2, [r2, #7]
 801439c:	b912      	cbnz	r2, 80143a4 <atcm_socket_get_hdle_urc_data_pending+0x70>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801439e:	3301      	adds	r3, #1
 80143a0:	b2db      	uxtb	r3, r3
 80143a2:	e7f3      	b.n	801438c <atcm_socket_get_hdle_urc_data_pending+0x58>
    {
      sockHandle = (socket_handle_t)i;
      /* clear this URC */
      p_tmp->socket_data_pending_urc = AT_FALSE;
 80143a4:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80143a8:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 80143ac:	2300      	movs	r3, #0
 80143ae:	71f3      	strb	r3, [r6, #7]
      break;
 80143b0:	e001      	b.n	80143b6 <atcm_socket_get_hdle_urc_data_pending+0x82>
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;
 80143b2:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (sockHandle);
}
 80143b6:	bd70      	pop	{r4, r5, r6, pc}
 80143b8:	08030924 	.word	0x08030924
 80143bc:	200048dc 	.word	0x200048dc

080143c0 <atcm_socket_get_hdlr_urc_closed_by_remote>:
/**
  * @brief  This function returns the socket handle of "socket closed by remote" URC
  *         and clears it
  */
socket_handle_t atcm_socket_get_hdlr_urc_closed_by_remote(atcustom_modem_context_t *p_modem_ctxt)
{
 80143c0:	b570      	push	{r4, r5, r6, lr}
 80143c2:	4606      	mov	r6, r0
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;

  PRINT_API("enter atcm_socket_get_hdlr_urc_closed_by_remote")
 80143c4:	4d20      	ldr	r5, [pc, #128]	; (8014448 <atcm_socket_get_hdlr_urc_closed_by_remote+0x88>)
 80143c6:	4c21      	ldr	r4, [pc, #132]	; (801444c <atcm_socket_get_hdlr_urc_closed_by_remote+0x8c>)
 80143c8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80143cc:	46ac      	mov	ip, r5
 80143ce:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80143d2:	6020      	str	r0, [r4, #0]
 80143d4:	6061      	str	r1, [r4, #4]
 80143d6:	60a2      	str	r2, [r4, #8]
 80143d8:	60e3      	str	r3, [r4, #12]
 80143da:	4665      	mov	r5, ip
 80143dc:	3410      	adds	r4, #16
 80143de:	45f4      	cmp	ip, lr
 80143e0:	d1f4      	bne.n	80143cc <atcm_socket_get_hdlr_urc_closed_by_remote+0xc>
 80143e2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80143e4:	6020      	str	r0, [r4, #0]
 80143e6:	6061      	str	r1, [r4, #4]
 80143e8:	60a2      	str	r2, [r4, #8]
 80143ea:	882a      	ldrh	r2, [r5, #0]
 80143ec:	78ab      	ldrb	r3, [r5, #2]
 80143ee:	81a2      	strh	r2, [r4, #12]
 80143f0:	73a3      	strb	r3, [r4, #14]
 80143f2:	4c16      	ldr	r4, [pc, #88]	; (801444c <atcm_socket_get_hdlr_urc_closed_by_remote+0x8c>)
 80143f4:	4620      	mov	r0, r4
 80143f6:	f00a fe8c 	bl	801f112 <crs_strlen>
 80143fa:	b283      	uxth	r3, r0
 80143fc:	4622      	mov	r2, r4
 80143fe:	2104      	movs	r1, #4
 8014400:	2002      	movs	r0, #2
 8014402:	f00a fec9 	bl	801f198 <traceIF_itmPrint>
 8014406:	4620      	mov	r0, r4
 8014408:	f00a fe83 	bl	801f112 <crs_strlen>
 801440c:	b283      	uxth	r3, r0
 801440e:	4622      	mov	r2, r4
 8014410:	2104      	movs	r1, #4
 8014412:	2002      	movs	r0, #2
 8014414:	f00a fee2 	bl	801f1dc <traceIF_uartPrint>

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8014418:	2300      	movs	r3, #0
 801441a:	2b05      	cmp	r3, #5
 801441c:	d810      	bhi.n	8014440 <atcm_socket_get_hdlr_urc_closed_by_remote+0x80>
  {
    atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
 801441e:	4618      	mov	r0, r3
    if (p_tmp->socket_closed_pending_urc == AT_TRUE)
 8014420:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8014424:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8014428:	7a12      	ldrb	r2, [r2, #8]
 801442a:	b912      	cbnz	r2, 8014432 <atcm_socket_get_hdlr_urc_closed_by_remote+0x72>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801442c:	3301      	adds	r3, #1
 801442e:	b2db      	uxtb	r3, r3
 8014430:	e7f3      	b.n	801441a <atcm_socket_get_hdlr_urc_closed_by_remote+0x5a>
    {
      sockHandle = (socket_handle_t)i;
      /* clear this URC */
      p_tmp->socket_closed_pending_urc = AT_FALSE;
 8014432:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8014436:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 801443a:	2300      	movs	r3, #0
 801443c:	7233      	strb	r3, [r6, #8]
      break;
 801443e:	e001      	b.n	8014444 <atcm_socket_get_hdlr_urc_closed_by_remote+0x84>
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;
 8014440:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (sockHandle);
}
 8014444:	bd70      	pop	{r4, r5, r6, pc}
 8014446:	bf00      	nop
 8014448:	08030960 	.word	0x08030960
 801444c:	200048dc 	.word	0x200048dc

08014450 <atcm_socket_remaining_urc_data_pending>:

/**
  * @brief  This function returns if there are pending "socket data received" URC
  */
at_bool_t atcm_socket_remaining_urc_data_pending(const atcustom_modem_context_t *p_modem_ctxt)
{
 8014450:	b570      	push	{r4, r5, r6, lr}
 8014452:	4606      	mov	r6, r0
  PRINT_API("enter atcm_socket_remaining_urc_data_pending")
 8014454:	4d19      	ldr	r5, [pc, #100]	; (80144bc <atcm_socket_remaining_urc_data_pending+0x6c>)
 8014456:	4c1a      	ldr	r4, [pc, #104]	; (80144c0 <atcm_socket_remaining_urc_data_pending+0x70>)
 8014458:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801445c:	46ac      	mov	ip, r5
 801445e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014462:	6020      	str	r0, [r4, #0]
 8014464:	6061      	str	r1, [r4, #4]
 8014466:	60a2      	str	r2, [r4, #8]
 8014468:	60e3      	str	r3, [r4, #12]
 801446a:	4665      	mov	r5, ip
 801446c:	3410      	adds	r4, #16
 801446e:	45f4      	cmp	ip, lr
 8014470:	d1f4      	bne.n	801445c <atcm_socket_remaining_urc_data_pending+0xc>
 8014472:	cd07      	ldmia	r5!, {r0, r1, r2}
 8014474:	6020      	str	r0, [r4, #0]
 8014476:	6061      	str	r1, [r4, #4]
 8014478:	60a2      	str	r2, [r4, #8]
 801447a:	4c11      	ldr	r4, [pc, #68]	; (80144c0 <atcm_socket_remaining_urc_data_pending+0x70>)
 801447c:	4620      	mov	r0, r4
 801447e:	f00a fe48 	bl	801f112 <crs_strlen>
 8014482:	b283      	uxth	r3, r0
 8014484:	4622      	mov	r2, r4
 8014486:	2104      	movs	r1, #4
 8014488:	2002      	movs	r0, #2
 801448a:	f00a fe85 	bl	801f198 <traceIF_itmPrint>
 801448e:	4620      	mov	r0, r4
 8014490:	f00a fe3f 	bl	801f112 <crs_strlen>
 8014494:	b283      	uxth	r3, r0
 8014496:	4622      	mov	r2, r4
 8014498:	2104      	movs	r1, #4
 801449a:	2002      	movs	r0, #2
 801449c:	f00a fe9e 	bl	801f1dc <traceIF_uartPrint>
  at_bool_t remain = AT_FALSE;

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 80144a0:	2300      	movs	r3, #0
 80144a2:	2b05      	cmp	r3, #5
 80144a4:	d808      	bhi.n	80144b8 <atcm_socket_remaining_urc_data_pending+0x68>
  {
    const atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
    if (p_tmp->socket_data_pending_urc == AT_TRUE)
 80144a6:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 80144aa:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 80144ae:	79d0      	ldrb	r0, [r2, #7]
 80144b0:	b918      	cbnz	r0, 80144ba <atcm_socket_remaining_urc_data_pending+0x6a>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 80144b2:	3301      	adds	r3, #1
 80144b4:	b2db      	uxtb	r3, r3
 80144b6:	e7f4      	b.n	80144a2 <atcm_socket_remaining_urc_data_pending+0x52>
  at_bool_t remain = AT_FALSE;
 80144b8:	2000      	movs	r0, #0
      break;
    }
  }

  return (remain);
}
 80144ba:	bd70      	pop	{r4, r5, r6, pc}
 80144bc:	080309a0 	.word	0x080309a0
 80144c0:	200048dc 	.word	0x200048dc

080144c4 <atcm_socket_remaining_urc_closed_by_remote>:

/**
  * @brief  This function returns if there are pending "socket closed by remote" URC
  */
at_bool_t atcm_socket_remaining_urc_closed_by_remote(const atcustom_modem_context_t *p_modem_ctxt)
{
 80144c4:	b570      	push	{r4, r5, r6, lr}
 80144c6:	4606      	mov	r6, r0
  PRINT_API("enter atcm_socket_remaining_urc_closed_by_remote")
 80144c8:	4d17      	ldr	r5, [pc, #92]	; (8014528 <atcm_socket_remaining_urc_closed_by_remote+0x64>)
 80144ca:	4c18      	ldr	r4, [pc, #96]	; (801452c <atcm_socket_remaining_urc_closed_by_remote+0x68>)
 80144cc:	f105 0e40 	add.w	lr, r5, #64	; 0x40
 80144d0:	46ac      	mov	ip, r5
 80144d2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80144d6:	6020      	str	r0, [r4, #0]
 80144d8:	6061      	str	r1, [r4, #4]
 80144da:	60a2      	str	r2, [r4, #8]
 80144dc:	60e3      	str	r3, [r4, #12]
 80144de:	4665      	mov	r5, ip
 80144e0:	3410      	adds	r4, #16
 80144e2:	45f4      	cmp	ip, lr
 80144e4:	d1f4      	bne.n	80144d0 <atcm_socket_remaining_urc_closed_by_remote+0xc>
 80144e6:	4c11      	ldr	r4, [pc, #68]	; (801452c <atcm_socket_remaining_urc_closed_by_remote+0x68>)
 80144e8:	4620      	mov	r0, r4
 80144ea:	f00a fe12 	bl	801f112 <crs_strlen>
 80144ee:	b283      	uxth	r3, r0
 80144f0:	4622      	mov	r2, r4
 80144f2:	2104      	movs	r1, #4
 80144f4:	2002      	movs	r0, #2
 80144f6:	f00a fe4f 	bl	801f198 <traceIF_itmPrint>
 80144fa:	4620      	mov	r0, r4
 80144fc:	f00a fe09 	bl	801f112 <crs_strlen>
 8014500:	b283      	uxth	r3, r0
 8014502:	4622      	mov	r2, r4
 8014504:	2104      	movs	r1, #4
 8014506:	2002      	movs	r0, #2
 8014508:	f00a fe68 	bl	801f1dc <traceIF_uartPrint>

  at_bool_t remain = AT_FALSE;

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801450c:	2300      	movs	r3, #0
 801450e:	2b05      	cmp	r3, #5
 8014510:	d808      	bhi.n	8014524 <atcm_socket_remaining_urc_closed_by_remote+0x60>
  {
    const atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
    if (p_tmp->socket_closed_pending_urc == AT_TRUE)
 8014512:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8014516:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 801451a:	7a10      	ldrb	r0, [r2, #8]
 801451c:	b918      	cbnz	r0, 8014526 <atcm_socket_remaining_urc_closed_by_remote+0x62>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801451e:	3301      	adds	r3, #1
 8014520:	b2db      	uxtb	r3, r3
 8014522:	e7f4      	b.n	801450e <atcm_socket_remaining_urc_closed_by_remote+0x4a>
  at_bool_t remain = AT_FALSE;
 8014524:	2000      	movs	r0, #0
      break;
    }
  }

  return (remain);
}
 8014526:	bd70      	pop	{r4, r5, r6, pc}
 8014528:	080309dc 	.word	0x080309dc
 801452c:	200048dc 	.word	0x200048dc

08014530 <atcm_socket_set_connected>:

  return (retval);
}

at_status_t atcm_socket_set_connected(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 8014530:	b570      	push	{r4, r5, r6, lr}
 8014532:	4606      	mov	r6, r0
 8014534:	460c      	mov	r4, r1
  at_status_t retval = ATSTATUS_OK;

  PRINT_API("enter atcm_socket_set_connected sockHandle=%ld", sockHandle)
 8014536:	4d11      	ldr	r5, [pc, #68]	; (801457c <atcm_socket_set_connected+0x4c>)
 8014538:	460a      	mov	r2, r1
 801453a:	4911      	ldr	r1, [pc, #68]	; (8014580 <atcm_socket_set_connected+0x50>)
 801453c:	4628      	mov	r0, r5
 801453e:	f011 fb97 	bl	8025c70 <sprintf>
 8014542:	4628      	mov	r0, r5
 8014544:	f00a fde5 	bl	801f112 <crs_strlen>
 8014548:	b283      	uxth	r3, r0
 801454a:	462a      	mov	r2, r5
 801454c:	2104      	movs	r1, #4
 801454e:	2002      	movs	r0, #2
 8014550:	f00a fe22 	bl	801f198 <traceIF_itmPrint>
 8014554:	4628      	mov	r0, r5
 8014556:	f00a fddc 	bl	801f112 <crs_strlen>
 801455a:	b283      	uxth	r3, r0
 801455c:	462a      	mov	r2, r5
 801455e:	2104      	movs	r1, #4
 8014560:	2002      	movs	r0, #2
 8014562:	f00a fe3b 	bl	801f1dc <traceIF_uartPrint>

  if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 8014566:	f1b4 3fff 	cmp.w	r4, #4294967295
 801456a:	d005      	beq.n	8014578 <atcm_socket_set_connected+0x48>
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_connected = AT_TRUE;
 801456c:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 8014570:	eb06 0084 	add.w	r0, r6, r4, lsl #2
 8014574:	2301      	movs	r3, #1
 8014576:	7183      	strb	r3, [r0, #6]
  }

  return (retval);
}
 8014578:	2000      	movs	r0, #0
 801457a:	bd70      	pop	{r4, r5, r6, pc}
 801457c:	200048dc 	.word	0x200048dc
 8014580:	08030a1c 	.word	0x08030a1c

08014584 <reset_current_command>:

  p_atp_ctxt->p_cmd_input = NULL;
}

static void reset_current_command(atparser_context_t *p_atp_ctxt)
{
 8014584:	b538      	push	{r3, r4, r5, lr}
 8014586:	4604      	mov	r4, r0
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 8014588:	f04f 33ff 	mov.w	r3, #4294967295
 801458c:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->current_atcmd.type = ATTYPE_UNKNOWN_CMD;
 801458e:	2500      	movs	r5, #0
 8014590:	8105      	strh	r5, [r0, #8]
  (void) memset((void *)&p_atp_ctxt->current_atcmd.name[0], 0, sizeof(uint8_t) * (ATCMD_MAX_NAME_SIZE));
 8014592:	2220      	movs	r2, #32
 8014594:	4629      	mov	r1, r5
 8014596:	3010      	adds	r0, #16
 8014598:	f011 fbdd 	bl	8025d56 <memset>
  (void) memset((void *)&p_atp_ctxt->current_atcmd.params[0], 0, sizeof(uint8_t) * (ATCMD_MAX_CMD_SIZE));
 801459c:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 80145a0:	4629      	mov	r1, r5
 80145a2:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80145a6:	f011 fbd6 	bl	8025d56 <memset>
  p_atp_ctxt->current_atcmd.raw_cmd_size = 0U;
 80145aa:	f8c4 5670 	str.w	r5, [r4, #1648]	; 0x670
}
 80145ae:	bd38      	pop	{r3, r4, r5, pc}

080145b0 <reset_parser_context>:
{
 80145b0:	b538      	push	{r3, r4, r5, lr}
 80145b2:	4604      	mov	r4, r0
  p_atp_ctxt->current_SID = SID_INVALID;
 80145b4:	2500      	movs	r5, #0
 80145b6:	8005      	strh	r5, [r0, #0]
  p_atp_ctxt->step = 0U;
 80145b8:	7085      	strb	r5, [r0, #2]
  p_atp_ctxt->answer_expected = CMD_MANDATORY_ANSWER_EXPECTED;
 80145ba:	70c5      	strb	r5, [r0, #3]
  p_atp_ctxt->is_final_cmd = 1U;
 80145bc:	2301      	movs	r3, #1
 80145be:	7103      	strb	r3, [r0, #4]
  p_atp_ctxt->cmd_timeout = 0U;
 80145c0:	f8c0 5678 	str.w	r5, [r0, #1656]	; 0x678
  reset_current_command(p_atp_ctxt);
 80145c4:	f7ff ffde 	bl	8014584 <reset_current_command>
  p_atp_ctxt->p_cmd_input = NULL;
 80145c8:	f8c4 567c 	str.w	r5, [r4, #1660]	; 0x67c
}
 80145cc:	bd38      	pop	{r3, r4, r5, pc}

080145ce <write_data2buffer>:
  if ((str_size > 0U) && (str_size < *p_remaining_size))
 80145ce:	b1b2      	cbz	r2, 80145fe <write_data2buffer+0x30>
{
 80145d0:	b538      	push	{r3, r4, r5, lr}
 80145d2:	461c      	mov	r4, r3
 80145d4:	4615      	mov	r5, r2
  if ((str_size > 0U) && (str_size < *p_remaining_size))
 80145d6:	9b04      	ldr	r3, [sp, #16]
 80145d8:	881b      	ldrh	r3, [r3, #0]
 80145da:	4293      	cmp	r3, r2
 80145dc:	d801      	bhi.n	80145e2 <write_data2buffer+0x14>
    retval = false;
 80145de:	2000      	movs	r0, #0
}
 80145e0:	bd38      	pop	{r3, r4, r5, pc}
    (void) memcpy((void *) &p_ATcmdBuf[*p_cmd_total_length],
 80145e2:	8823      	ldrh	r3, [r4, #0]
 80145e4:	4418      	add	r0, r3
 80145e6:	f011 fc93 	bl	8025f10 <memcpy>
    *p_cmd_total_length += str_size;
 80145ea:	8823      	ldrh	r3, [r4, #0]
 80145ec:	442b      	add	r3, r5
 80145ee:	8023      	strh	r3, [r4, #0]
    *p_remaining_size -= str_size;
 80145f0:	9b04      	ldr	r3, [sp, #16]
 80145f2:	881b      	ldrh	r3, [r3, #0]
 80145f4:	1b5b      	subs	r3, r3, r5
 80145f6:	9a04      	ldr	r2, [sp, #16]
 80145f8:	8013      	strh	r3, [r2, #0]
    retval = true;
 80145fa:	2001      	movs	r0, #1
 80145fc:	e7f0      	b.n	80145e0 <write_data2buffer+0x12>
    retval = false;
 80145fe:	2000      	movs	r0, #0
}
 8014600:	4770      	bx	lr
	...

08014604 <build_command>:
{
 8014604:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014608:	b084      	sub	sp, #16
 801460a:	4604      	mov	r4, r0
 801460c:	460e      	mov	r6, r1
  at_type_t cmd_type = p_at_ctxt->parser.current_atcmd.type;
 801460e:	8b05      	ldrh	r5, [r0, #24]
      (cmd_type == ATTYPE_WRITE_CMD) ||
 8014610:	1e6b      	subs	r3, r5, #1
 8014612:	b29b      	uxth	r3, r3
  if ((cmd_type == ATTYPE_TEST_CMD) ||
 8014614:	2b03      	cmp	r3, #3
 8014616:	d931      	bls.n	801467c <build_command+0x78>
  else if (cmd_type == ATTYPE_RAW_CMD)
 8014618:	2d06      	cmp	r5, #6
 801461a:	f000 8081 	beq.w	8014720 <build_command+0x11c>
  else if (cmd_type == ATTYPE_NO_CMD)
 801461e:	2d05      	cmp	r5, #5
 8014620:	f000 80aa 	beq.w	8014778 <build_command+0x174>
    cmd_total_length = 0U;
 8014624:	2300      	movs	r3, #0
 8014626:	f8ad 300e 	strh.w	r3, [sp, #14]
    PRINT_ERR("invalid command type")
 801462a:	4d65      	ldr	r5, [pc, #404]	; (80147c0 <build_command+0x1bc>)
 801462c:	4c65      	ldr	r4, [pc, #404]	; (80147c4 <build_command+0x1c0>)
 801462e:	f105 0620 	add.w	r6, r5, #32
 8014632:	46ac      	mov	ip, r5
 8014634:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014638:	6020      	str	r0, [r4, #0]
 801463a:	6061      	str	r1, [r4, #4]
 801463c:	60a2      	str	r2, [r4, #8]
 801463e:	60e3      	str	r3, [r4, #12]
 8014640:	4665      	mov	r5, ip
 8014642:	3410      	adds	r4, #16
 8014644:	45b4      	cmp	ip, r6
 8014646:	d1f4      	bne.n	8014632 <build_command+0x2e>
 8014648:	f8dc 0000 	ldr.w	r0, [ip]
 801464c:	6020      	str	r0, [r4, #0]
 801464e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8014652:	80a3      	strh	r3, [r4, #4]
 8014654:	4c5b      	ldr	r4, [pc, #364]	; (80147c4 <build_command+0x1c0>)
 8014656:	4620      	mov	r0, r4
 8014658:	f00a fd5b 	bl	801f112 <crs_strlen>
 801465c:	b283      	uxth	r3, r0
 801465e:	4622      	mov	r2, r4
 8014660:	2110      	movs	r1, #16
 8014662:	2002      	movs	r0, #2
 8014664:	f00a fd98 	bl	801f198 <traceIF_itmPrint>
 8014668:	4620      	mov	r0, r4
 801466a:	f00a fd52 	bl	801f112 <crs_strlen>
 801466e:	b283      	uxth	r3, r0
 8014670:	4622      	mov	r2, r4
 8014672:	2110      	movs	r1, #16
 8014674:	2002      	movs	r0, #2
 8014676:	f00a fdb1 	bl	801f1dc <traceIF_uartPrint>
 801467a:	e04c      	b.n	8014716 <build_command+0x112>
    cmd_total_length = 0;
 801467c:	2300      	movs	r3, #0
 801467e:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint16_t remaining_size = ATcmdBuf_maxSize;
 8014682:	f8ad 200c 	strh.w	r2, [sp, #12]
    p_str = CMD_FORMAT[cmd_type].cmd_prefix;
 8014686:	f8df 8148 	ldr.w	r8, [pc, #328]	; 80147d0 <build_command+0x1cc>
 801468a:	ea4f 0985 	mov.w	r9, r5, lsl #2
 801468e:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8014692:	eb08 0181 	add.w	r1, r8, r1, lsl #2
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 8014696:	af03      	add	r7, sp, #12
 8014698:	9700      	str	r7, [sp, #0]
 801469a:	f10d 030e 	add.w	r3, sp, #14
 801469e:	890a      	ldrh	r2, [r1, #8]
 80146a0:	4630      	mov	r0, r6
 80146a2:	f7ff ff94 	bl	80145ce <write_data2buffer>
    p_str = p_at_ctxt->parser.current_atcmd.name;
 80146a6:	f104 0a20 	add.w	sl, r4, #32
    str_size = (uint16_t) strlen((CRC_CHAR_t *) &p_at_ctxt->parser.current_atcmd.name);
 80146aa:	4650      	mov	r0, sl
 80146ac:	f7eb fda2 	bl	80001f4 <strlen>
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 80146b0:	9700      	str	r7, [sp, #0]
 80146b2:	f10d 030e 	add.w	r3, sp, #14
 80146b6:	b282      	uxth	r2, r0
 80146b8:	4651      	mov	r1, sl
 80146ba:	4630      	mov	r0, r6
 80146bc:	f7ff ff87 	bl	80145ce <write_data2buffer>
    p_str = &CMD_FORMAT[cmd_type].cmd_separator[0];
 80146c0:	eb09 0105 	add.w	r1, r9, r5
 80146c4:	0089      	lsls	r1, r1, #2
 80146c6:	3108      	adds	r1, #8
 80146c8:	4441      	add	r1, r8
    str_size = CMD_FORMAT[cmd_type].cmd_separator_size;
 80146ca:	44a9      	add	r9, r5
 80146cc:	eb08 0889 	add.w	r8, r8, r9, lsl #2
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 80146d0:	9700      	str	r7, [sp, #0]
 80146d2:	f10d 030e 	add.w	r3, sp, #14
 80146d6:	f8b8 2012 	ldrh.w	r2, [r8, #18]
 80146da:	3102      	adds	r1, #2
 80146dc:	4630      	mov	r0, r6
 80146de:	f7ff ff76 	bl	80145ce <write_data2buffer>
    p_str = p_at_ctxt->parser.current_atcmd.params;
 80146e2:	f104 0540 	add.w	r5, r4, #64	; 0x40
    str_size = (uint16_t) strlen((CRC_CHAR_t *) &p_at_ctxt->parser.current_atcmd.params);
 80146e6:	4628      	mov	r0, r5
 80146e8:	f7eb fd84 	bl	80001f4 <strlen>
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 80146ec:	9700      	str	r7, [sp, #0]
 80146ee:	f10d 030e 	add.w	r3, sp, #14
 80146f2:	b282      	uxth	r2, r0
 80146f4:	4629      	mov	r1, r5
 80146f6:	4630      	mov	r0, r6
 80146f8:	f7ff ff69 	bl	80145ce <write_data2buffer>
    p_str = p_at_ctxt->parser.endstr;
 80146fc:	f204 6484 	addw	r4, r4, #1668	; 0x684
    str_size = (uint16_t) strlen((CRC_CHAR_t *) &p_at_ctxt->parser.endstr);
 8014700:	4620      	mov	r0, r4
 8014702:	f7eb fd77 	bl	80001f4 <strlen>
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 8014706:	9700      	str	r7, [sp, #0]
 8014708:	f10d 030e 	add.w	r3, sp, #14
 801470c:	b282      	uxth	r2, r0
 801470e:	4621      	mov	r1, r4
 8014710:	4630      	mov	r0, r6
 8014712:	f7ff ff5c 	bl	80145ce <write_data2buffer>
}
 8014716:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 801471a:	b004      	add	sp, #16
 801471c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((p_at_ctxt->parser.current_atcmd.raw_cmd_size != 0U)
 8014720:	f8d0 3680 	ldr.w	r3, [r0, #1664]	; 0x680
 8014724:	b10b      	cbz	r3, 801472a <build_command+0x126>
        && (p_at_ctxt->parser.current_atcmd.raw_cmd_size <= ATcmdBuf_maxSize))
 8014726:	4293      	cmp	r3, r2
 8014728:	d91b      	bls.n	8014762 <build_command+0x15e>
      PRINT_ERR("Error with RAW command size = %ld", p_at_ctxt->parser.current_atcmd.raw_cmd_size)
 801472a:	4c26      	ldr	r4, [pc, #152]	; (80147c4 <build_command+0x1c0>)
 801472c:	461a      	mov	r2, r3
 801472e:	4926      	ldr	r1, [pc, #152]	; (80147c8 <build_command+0x1c4>)
 8014730:	4620      	mov	r0, r4
 8014732:	f011 fa9d 	bl	8025c70 <sprintf>
 8014736:	4620      	mov	r0, r4
 8014738:	f00a fceb 	bl	801f112 <crs_strlen>
 801473c:	b283      	uxth	r3, r0
 801473e:	4622      	mov	r2, r4
 8014740:	2110      	movs	r1, #16
 8014742:	2002      	movs	r0, #2
 8014744:	f00a fd28 	bl	801f198 <traceIF_itmPrint>
 8014748:	4620      	mov	r0, r4
 801474a:	f00a fce2 	bl	801f112 <crs_strlen>
 801474e:	b283      	uxth	r3, r0
 8014750:	4622      	mov	r2, r4
 8014752:	2110      	movs	r1, #16
 8014754:	2002      	movs	r0, #2
 8014756:	f00a fd41 	bl	801f1dc <traceIF_uartPrint>
      cmd_total_length = 0U;
 801475a:	2300      	movs	r3, #0
 801475c:	f8ad 300e 	strh.w	r3, [sp, #14]
 8014760:	e7d9      	b.n	8014716 <build_command+0x112>
      (void) memcpy((void *)p_ATcmdBuf,
 8014762:	461a      	mov	r2, r3
 8014764:	f100 0140 	add.w	r1, r0, #64	; 0x40
 8014768:	4630      	mov	r0, r6
 801476a:	f011 fbd1 	bl	8025f10 <memcpy>
      cmd_total_length = (uint16_t)p_at_ctxt->parser.current_atcmd.raw_cmd_size;
 801476e:	f8b4 3680 	ldrh.w	r3, [r4, #1664]	; 0x680
 8014772:	f8ad 300e 	strh.w	r3, [sp, #14]
 8014776:	e7ce      	b.n	8014716 <build_command+0x112>
    cmd_total_length = 0U;
 8014778:	2300      	movs	r3, #0
 801477a:	f8ad 300e 	strh.w	r3, [sp, #14]
    PRINT_DBG("no command to send")
 801477e:	4c11      	ldr	r4, [pc, #68]	; (80147c4 <build_command+0x1c0>)
 8014780:	4d12      	ldr	r5, [pc, #72]	; (80147cc <build_command+0x1c8>)
 8014782:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8014784:	6020      	str	r0, [r4, #0]
 8014786:	6061      	str	r1, [r4, #4]
 8014788:	60a2      	str	r2, [r4, #8]
 801478a:	60e3      	str	r3, [r4, #12]
 801478c:	cd07      	ldmia	r5!, {r0, r1, r2}
 801478e:	6120      	str	r0, [r4, #16]
 8014790:	6161      	str	r1, [r4, #20]
 8014792:	61a2      	str	r2, [r4, #24]
 8014794:	882b      	ldrh	r3, [r5, #0]
 8014796:	83a3      	strh	r3, [r4, #28]
 8014798:	4620      	mov	r0, r4
 801479a:	f00a fcba 	bl	801f112 <crs_strlen>
 801479e:	b283      	uxth	r3, r0
 80147a0:	4622      	mov	r2, r4
 80147a2:	2102      	movs	r1, #2
 80147a4:	4608      	mov	r0, r1
 80147a6:	f00a fcf7 	bl	801f198 <traceIF_itmPrint>
 80147aa:	4620      	mov	r0, r4
 80147ac:	f00a fcb1 	bl	801f112 <crs_strlen>
 80147b0:	b283      	uxth	r3, r0
 80147b2:	4622      	mov	r2, r4
 80147b4:	2102      	movs	r1, #2
 80147b6:	4608      	mov	r0, r1
 80147b8:	f00a fd10 	bl	801f1dc <traceIF_uartPrint>
 80147bc:	e7ab      	b.n	8014716 <build_command+0x112>
 80147be:	bf00      	nop
 80147c0:	08030ab0 	.word	0x08030ab0
 80147c4:	200048dc 	.word	0x200048dc
 80147c8:	08030a5c 	.word	0x08030a5c
 80147cc:	08030a90 	.word	0x08030a90
 80147d0:	08030c94 	.word	0x08030c94

080147d4 <display_buffer>:

static void display_buffer(const at_context_t *p_at_ctxt, const uint8_t *p_buf, uint16_t buf_size, uint8_t is_TX_buf)
{
 80147d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80147d8:	4680      	mov	r8, r0
 80147da:	460f      	mov	r7, r1
 80147dc:	4616      	mov	r6, r2
 80147de:	461d      	mov	r5, r3
#if (USE_TRACE_ATPARSER == 0U)
  UNUSED(p_buf); /* for MISRA-2012 */
#endif /* USE_TRACE_ATPARSER */

  /* print header */
  PRINT_INDENT()
 80147e0:	4c3e      	ldr	r4, [pc, #248]	; (80148dc <display_buffer+0x108>)
 80147e2:	4b3f      	ldr	r3, [pc, #252]	; (80148e0 <display_buffer+0x10c>)
 80147e4:	6818      	ldr	r0, [r3, #0]
 80147e6:	6020      	str	r0, [r4, #0]
 80147e8:	791b      	ldrb	r3, [r3, #4]
 80147ea:	7123      	strb	r3, [r4, #4]
 80147ec:	4620      	mov	r0, r4
 80147ee:	f00a fc90 	bl	801f112 <crs_strlen>
 80147f2:	b283      	uxth	r3, r0
 80147f4:	4622      	mov	r2, r4
 80147f6:	2101      	movs	r1, #1
 80147f8:	2002      	movs	r0, #2
 80147fa:	f00a fccd 	bl	801f198 <traceIF_itmPrint>
 80147fe:	4620      	mov	r0, r4
 8014800:	f00a fc87 	bl	801f112 <crs_strlen>
 8014804:	b283      	uxth	r3, r0
 8014806:	4622      	mov	r2, r4
 8014808:	2101      	movs	r1, #1
 801480a:	2002      	movs	r0, #2
 801480c:	f00a fce6 	bl	801f1dc <traceIF_uartPrint>
  if (is_TX_buf == 1U)
 8014810:	2d01      	cmp	r5, #1
 8014812:	d00d      	beq.n	8014830 <display_buffer+0x5c>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 8014814:	2500      	movs	r5, #0
      }
    }
  }
  /* PRINT_INDENT() */

  if (buf_size != 0U)
 8014816:	b14e      	cbz	r6, 801482c <display_buffer+0x58>
  {
#if (FILTER_SOCKET_TRACES == 1U)
    if (buf_size > FILTER_DEFAULT_LENGH)
 8014818:	2e50      	cmp	r6, #80	; 0x50
 801481a:	d82f      	bhi.n	801487c <display_buffer+0xa8>
    {
      PRINT_INFO(" Big frame (display deactivated) ")
    }
    else
    {
      if (print_in_hexa == 1U)
 801481c:	2d01      	cmp	r5, #1
 801481e:	d055      	beq.n	80148cc <display_buffer+0xf8>
      {
        PRINT_BUF_HEXA((const uint8_t *)p_buf, buf_size)
      }
      else
      {
        PRINT_BUF((const uint8_t *)p_buf, buf_size)
 8014820:	4633      	mov	r3, r6
 8014822:	463a      	mov	r2, r7
 8014824:	2101      	movs	r1, #1
 8014826:	2002      	movs	r0, #2
 8014828:	f00a ffa4 	bl	801f774 <traceIF_BufCharPrint>
    {
      PRINT_BUF((const CRC_CHAR_t *)p_buf, buf_size)
    }
#endif /* FILTER_SOCKET_TRACES */
  }
}
 801482c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (buf_size > 0U)
 8014830:	b90e      	cbnz	r6, 8014836 <display_buffer+0x62>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 8014832:	2500      	movs	r5, #0
 8014834:	e7ef      	b.n	8014816 <display_buffer+0x42>
      PRINT_INFO("*** SEND (size=%d) ***", buf_size)
 8014836:	4632      	mov	r2, r6
 8014838:	492a      	ldr	r1, [pc, #168]	; (80148e4 <display_buffer+0x110>)
 801483a:	4620      	mov	r0, r4
 801483c:	f011 fa18 	bl	8025c70 <sprintf>
 8014840:	4620      	mov	r0, r4
 8014842:	f00a fc66 	bl	801f112 <crs_strlen>
 8014846:	b283      	uxth	r3, r0
 8014848:	4622      	mov	r2, r4
 801484a:	2101      	movs	r1, #1
 801484c:	2002      	movs	r0, #2
 801484e:	f00a fca3 	bl	801f198 <traceIF_itmPrint>
 8014852:	4620      	mov	r0, r4
 8014854:	f00a fc5d 	bl	801f112 <crs_strlen>
 8014858:	b283      	uxth	r3, r0
 801485a:	4622      	mov	r2, r4
 801485c:	2101      	movs	r1, #1
 801485e:	2002      	movs	r0, #2
 8014860:	f00a fcbc 	bl	801f1dc <traceIF_uartPrint>
      if ((p_at_ctxt->parser.current_atcmd.type == ATTYPE_RAW_CMD) &&
 8014864:	f8b8 3018 	ldrh.w	r3, [r8, #24]
 8014868:	2b06      	cmp	r3, #6
 801486a:	d001      	beq.n	8014870 <display_buffer+0x9c>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 801486c:	2500      	movs	r5, #0
 801486e:	e7d2      	b.n	8014816 <display_buffer+0x42>
          (p_at_ctxt->parser.current_atcmd.id != (CMD_ID_t) CMD_AT_DIRECT_CMD))
 8014870:	f8d8 301c 	ldr.w	r3, [r8, #28]
      if ((p_at_ctxt->parser.current_atcmd.type == ATTYPE_RAW_CMD) &&
 8014874:	2b34      	cmp	r3, #52	; 0x34
 8014876:	d1ce      	bne.n	8014816 <display_buffer+0x42>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 8014878:	2500      	movs	r5, #0
 801487a:	e7cc      	b.n	8014816 <display_buffer+0x42>
      PRINT_INFO(" Big frame (display deactivated) ")
 801487c:	4d1a      	ldr	r5, [pc, #104]	; (80148e8 <display_buffer+0x114>)
 801487e:	4c17      	ldr	r4, [pc, #92]	; (80148dc <display_buffer+0x108>)
 8014880:	f105 0720 	add.w	r7, r5, #32
 8014884:	462e      	mov	r6, r5
 8014886:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8014888:	6020      	str	r0, [r4, #0]
 801488a:	6061      	str	r1, [r4, #4]
 801488c:	60a2      	str	r2, [r4, #8]
 801488e:	60e3      	str	r3, [r4, #12]
 8014890:	4635      	mov	r5, r6
 8014892:	3410      	adds	r4, #16
 8014894:	42be      	cmp	r6, r7
 8014896:	d1f5      	bne.n	8014884 <display_buffer+0xb0>
 8014898:	cd07      	ldmia	r5!, {r0, r1, r2}
 801489a:	6020      	str	r0, [r4, #0]
 801489c:	6061      	str	r1, [r4, #4]
 801489e:	60a2      	str	r2, [r4, #8]
 80148a0:	782b      	ldrb	r3, [r5, #0]
 80148a2:	7323      	strb	r3, [r4, #12]
 80148a4:	4c0d      	ldr	r4, [pc, #52]	; (80148dc <display_buffer+0x108>)
 80148a6:	4620      	mov	r0, r4
 80148a8:	f00a fc33 	bl	801f112 <crs_strlen>
 80148ac:	b283      	uxth	r3, r0
 80148ae:	4622      	mov	r2, r4
 80148b0:	2101      	movs	r1, #1
 80148b2:	2002      	movs	r0, #2
 80148b4:	f00a fc70 	bl	801f198 <traceIF_itmPrint>
 80148b8:	4620      	mov	r0, r4
 80148ba:	f00a fc2a 	bl	801f112 <crs_strlen>
 80148be:	b283      	uxth	r3, r0
 80148c0:	4622      	mov	r2, r4
 80148c2:	2101      	movs	r1, #1
 80148c4:	2002      	movs	r0, #2
 80148c6:	f00a fc89 	bl	801f1dc <traceIF_uartPrint>
 80148ca:	e7af      	b.n	801482c <display_buffer+0x58>
        PRINT_BUF_HEXA((const uint8_t *)p_buf, buf_size)
 80148cc:	4633      	mov	r3, r6
 80148ce:	463a      	mov	r2, r7
 80148d0:	2101      	movs	r1, #1
 80148d2:	2002      	movs	r0, #2
 80148d4:	f00b f842 	bl	801f95c <traceIF_BufHexPrint>
 80148d8:	e7a8      	b.n	801482c <display_buffer+0x58>
 80148da:	bf00      	nop
 80148dc:	200048dc 	.word	0x200048dc
 80148e0:	08030ad8 	.word	0x08030ad8
 80148e4:	08030ae0 	.word	0x08030ae0
 80148e8:	08030b04 	.word	0x08030b04

080148ec <ATParser_initParsers>:
{
 80148ec:	b508      	push	{r3, lr}
  return (atcc_initParsers(device_type));
 80148ee:	f7f7 fd33 	bl	800c358 <atcc_initParsers>
}
 80148f2:	bd08      	pop	{r3, pc}

080148f4 <ATParser_init>:
{
 80148f4:	b538      	push	{r3, r4, r5, lr}
 80148f6:	4604      	mov	r4, r0
 80148f8:	460d      	mov	r5, r1
  reset_parser_context(&p_at_ctxt->parser);
 80148fa:	3010      	adds	r0, #16
 80148fc:	f7ff fe58 	bl	80145b0 <reset_parser_context>
  *p_checkEndOfMsgCallback = atcc_checkEndOfMsgCallback(p_at_ctxt);
 8014900:	4620      	mov	r0, r4
 8014902:	f7f7 fd6d 	bl	800c3e0 <atcc_checkEndOfMsgCallback>
 8014906:	6028      	str	r0, [r5, #0]
  (void) memset((AT_CHAR_t *)p_at_ctxt->parser.endstr, 0, AT_CMD_MAX_END_STR_SIZE);
 8014908:	2300      	movs	r3, #0
 801490a:	f8a4 3684 	strh.w	r3, [r4, #1668]	; 0x684
 801490e:	f884 3686 	strb.w	r3, [r4, #1670]	; 0x686
  (void) sprintf((CRC_CHAR_t *)p_at_ctxt->parser.endstr, "\r");
 8014912:	4b04      	ldr	r3, [pc, #16]	; (8014924 <ATParser_init+0x30>)
 8014914:	881b      	ldrh	r3, [r3, #0]
 8014916:	f8a4 3684 	strh.w	r3, [r4, #1668]	; 0x684
  atcc_init(p_at_ctxt);
 801491a:	4620      	mov	r0, r4
 801491c:	f7f7 fd52 	bl	800c3c4 <atcc_init>
}
 8014920:	bd38      	pop	{r3, r4, r5, pc}
 8014922:	bf00      	nop
 8014924:	08032b40 	.word	0x08032b40

08014928 <ATParser_process_request>:
{
 8014928:	b570      	push	{r4, r5, r6, lr}
 801492a:	4604      	mov	r4, r0
 801492c:	460d      	mov	r5, r1
 801492e:	4616      	mov	r6, r2
  reset_parser_context(&p_at_ctxt->parser);
 8014930:	3010      	adds	r0, #16
 8014932:	f7ff fe3d 	bl	80145b0 <reset_parser_context>
  p_at_ctxt->parser.p_cmd_input = p_cmd_buf;
 8014936:	f8c4 668c 	str.w	r6, [r4, #1676]	; 0x68c
  p_at_ctxt->parser.current_SID = msg_id;
 801493a:	8225      	strh	r5, [r4, #16]
}
 801493c:	bd70      	pop	{r4, r5, r6, pc}
	...

08014940 <ATParser_get_ATcmd>:
{
 8014940:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014944:	4604      	mov	r4, r0
 8014946:	4688      	mov	r8, r1
 8014948:	4615      	mov	r5, r2
 801494a:	461f      	mov	r7, r3
  *p_ATcmdSize = 0U;
 801494c:	2300      	movs	r3, #0
 801494e:	803b      	strh	r3, [r7, #0]
  reset_current_command(&p_at_ctxt->parser);
 8014950:	3010      	adds	r0, #16
 8014952:	f7ff fe17 	bl	8014584 <reset_current_command>
  if (atcc_getCmd(p_at_ctxt, p_ATcmdTimeout) != ATSTATUS_OK)
 8014956:	9906      	ldr	r1, [sp, #24]
 8014958:	4620      	mov	r0, r4
 801495a:	f7f7 fd4b 	bl	800c3f4 <atcc_getCmd>
 801495e:	b958      	cbnz	r0, 8014978 <ATParser_get_ATcmd+0x38>
    if (p_at_ctxt->parser.current_atcmd.id != CMD_AT_INVALID)
 8014960:	69e3      	ldr	r3, [r4, #28]
 8014962:	f1b3 3fff 	cmp.w	r3, #4294967295
 8014966:	d153      	bne.n	8014a10 <ATParser_get_ATcmd+0xd0>
    if (p_at_ctxt->parser.answer_expected == CMD_MANDATORY_ANSWER_EXPECTED)
 8014968:	7ce3      	ldrb	r3, [r4, #19]
 801496a:	2b00      	cmp	r3, #0
 801496c:	f000 8082 	beq.w	8014a74 <ATParser_get_ATcmd+0x134>
    else if (p_at_ctxt->parser.answer_expected == CMD_OPTIONAL_ANSWER_EXPECTED)
 8014970:	2b01      	cmp	r3, #1
 8014972:	d154      	bne.n	8014a1e <ATParser_get_ATcmd+0xde>
      action |= ATACTION_SEND_TEMPO;
 8014974:	2502      	movs	r5, #2
 8014976:	e025      	b.n	80149c4 <ATParser_get_ATcmd+0x84>
    PRINT_DBG("parser f_getCmd error")
 8014978:	4e41      	ldr	r6, [pc, #260]	; (8014a80 <ATParser_get_ATcmd+0x140>)
 801497a:	4d42      	ldr	r5, [pc, #264]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 801497c:	f106 0e20 	add.w	lr, r6, #32
 8014980:	46b4      	mov	ip, r6
 8014982:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014986:	6028      	str	r0, [r5, #0]
 8014988:	6069      	str	r1, [r5, #4]
 801498a:	60aa      	str	r2, [r5, #8]
 801498c:	60eb      	str	r3, [r5, #12]
 801498e:	4666      	mov	r6, ip
 8014990:	3510      	adds	r5, #16
 8014992:	45f4      	cmp	ip, lr
 8014994:	d1f4      	bne.n	8014980 <ATParser_get_ATcmd+0x40>
 8014996:	f89c 3000 	ldrb.w	r3, [ip]
 801499a:	702b      	strb	r3, [r5, #0]
 801499c:	4d39      	ldr	r5, [pc, #228]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 801499e:	4628      	mov	r0, r5
 80149a0:	f00a fbb7 	bl	801f112 <crs_strlen>
 80149a4:	b283      	uxth	r3, r0
 80149a6:	462a      	mov	r2, r5
 80149a8:	2102      	movs	r1, #2
 80149aa:	4608      	mov	r0, r1
 80149ac:	f00a fbf4 	bl	801f198 <traceIF_itmPrint>
 80149b0:	4628      	mov	r0, r5
 80149b2:	f00a fbae 	bl	801f112 <crs_strlen>
 80149b6:	b283      	uxth	r3, r0
 80149b8:	462a      	mov	r2, r5
 80149ba:	2102      	movs	r1, #2
 80149bc:	4608      	mov	r0, r1
 80149be:	f00a fc0d 	bl	801f1dc <traceIF_uartPrint>
    action = ATACTION_SEND_ERROR;
 80149c2:	2504      	movs	r5, #4
  if (action != ATACTION_SEND_ERROR)
 80149c4:	2d04      	cmp	r5, #4
 80149c6:	d008      	beq.n	80149da <ATParser_get_ATcmd+0x9a>
    if (p_at_ctxt->parser.is_final_cmd == 1U)
 80149c8:	7d23      	ldrb	r3, [r4, #20]
 80149ca:	2b01      	cmp	r3, #1
 80149cc:	d054      	beq.n	8014a78 <ATParser_get_ATcmd+0x138>
    display_buffer(p_at_ctxt,
 80149ce:	2301      	movs	r3, #1
 80149d0:	883a      	ldrh	r2, [r7, #0]
 80149d2:	4641      	mov	r1, r8
 80149d4:	4620      	mov	r0, r4
 80149d6:	f7ff fefd 	bl	80147d4 <display_buffer>
  PRINT_DBG("ATParser_get_ATcmd returned action = 0x%x", action)
 80149da:	4c2a      	ldr	r4, [pc, #168]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 80149dc:	462a      	mov	r2, r5
 80149de:	492a      	ldr	r1, [pc, #168]	; (8014a88 <ATParser_get_ATcmd+0x148>)
 80149e0:	4620      	mov	r0, r4
 80149e2:	f011 f945 	bl	8025c70 <sprintf>
 80149e6:	4620      	mov	r0, r4
 80149e8:	f00a fb93 	bl	801f112 <crs_strlen>
 80149ec:	b283      	uxth	r3, r0
 80149ee:	4622      	mov	r2, r4
 80149f0:	2102      	movs	r1, #2
 80149f2:	4608      	mov	r0, r1
 80149f4:	f00a fbd0 	bl	801f198 <traceIF_itmPrint>
 80149f8:	4620      	mov	r0, r4
 80149fa:	f00a fb8a 	bl	801f112 <crs_strlen>
 80149fe:	b283      	uxth	r3, r0
 8014a00:	4622      	mov	r2, r4
 8014a02:	2102      	movs	r1, #2
 8014a04:	4608      	mov	r0, r1
 8014a06:	f00a fbe9 	bl	801f1dc <traceIF_uartPrint>
}
 8014a0a:	4628      	mov	r0, r5
 8014a0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *p_ATcmdSize = build_command(p_at_ctxt, p_ATcmdBuf, ATcmdBuf_maxSize);
 8014a10:	462a      	mov	r2, r5
 8014a12:	4641      	mov	r1, r8
 8014a14:	4620      	mov	r0, r4
 8014a16:	f7ff fdf5 	bl	8014604 <build_command>
 8014a1a:	8038      	strh	r0, [r7, #0]
 8014a1c:	e7a4      	b.n	8014968 <ATParser_get_ATcmd+0x28>
      PRINT_ERR("Invalid answer_expected value")
 8014a1e:	4d1b      	ldr	r5, [pc, #108]	; (8014a8c <ATParser_get_ATcmd+0x14c>)
 8014a20:	4c18      	ldr	r4, [pc, #96]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 8014a22:	f105 0720 	add.w	r7, r5, #32
 8014a26:	462e      	mov	r6, r5
 8014a28:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8014a2a:	6020      	str	r0, [r4, #0]
 8014a2c:	6061      	str	r1, [r4, #4]
 8014a2e:	60a2      	str	r2, [r4, #8]
 8014a30:	60e3      	str	r3, [r4, #12]
 8014a32:	4635      	mov	r5, r6
 8014a34:	3410      	adds	r4, #16
 8014a36:	42be      	cmp	r6, r7
 8014a38:	d1f5      	bne.n	8014a26 <ATParser_get_ATcmd+0xe6>
 8014a3a:	cd07      	ldmia	r5!, {r0, r1, r2}
 8014a3c:	6020      	str	r0, [r4, #0]
 8014a3e:	6061      	str	r1, [r4, #4]
 8014a40:	60a2      	str	r2, [r4, #8]
 8014a42:	882a      	ldrh	r2, [r5, #0]
 8014a44:	78ab      	ldrb	r3, [r5, #2]
 8014a46:	81a2      	strh	r2, [r4, #12]
 8014a48:	73a3      	strb	r3, [r4, #14]
 8014a4a:	4c0e      	ldr	r4, [pc, #56]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 8014a4c:	4620      	mov	r0, r4
 8014a4e:	f00a fb60 	bl	801f112 <crs_strlen>
 8014a52:	b283      	uxth	r3, r0
 8014a54:	4622      	mov	r2, r4
 8014a56:	2110      	movs	r1, #16
 8014a58:	2002      	movs	r0, #2
 8014a5a:	f00a fb9d 	bl	801f198 <traceIF_itmPrint>
 8014a5e:	4620      	mov	r0, r4
 8014a60:	f00a fb57 	bl	801f112 <crs_strlen>
 8014a64:	b283      	uxth	r3, r0
 8014a66:	4622      	mov	r2, r4
 8014a68:	2110      	movs	r1, #16
 8014a6a:	2002      	movs	r0, #2
 8014a6c:	f00a fbb6 	bl	801f1dc <traceIF_uartPrint>
      action = ATACTION_SEND_ERROR;
 8014a70:	2504      	movs	r5, #4
 8014a72:	e7b2      	b.n	80149da <ATParser_get_ATcmd+0x9a>
      action |= ATACTION_SEND_WAIT_MANDATORY_RSP;
 8014a74:	2501      	movs	r5, #1
 8014a76:	e7a5      	b.n	80149c4 <ATParser_get_ATcmd+0x84>
      action |= ATACTION_SEND_FLAG_LAST_CMD;
 8014a78:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
 8014a7c:	e7a7      	b.n	80149ce <ATParser_get_ATcmd+0x8e>
 8014a7e:	bf00      	nop
 8014a80:	08030b34 	.word	0x08030b34
 8014a84:	200048dc 	.word	0x200048dc
 8014a88:	08030b88 	.word	0x08030b88
 8014a8c:	08030b58 	.word	0x08030b58

08014a90 <ATParser_parse_rsp>:
{
 8014a90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014a94:	b086      	sub	sp, #24
 8014a96:	4607      	mov	r7, r0
 8014a98:	460d      	mov	r5, r1
  at_element_info_t element_infos = { .current_parse_idx = 0, .cmd_id_received = CMD_AT_INVALID, .param_rank = 0U,
 8014a9a:	2300      	movs	r3, #0
 8014a9c:	f8ad 3008 	strh.w	r3, [sp, #8]
 8014aa0:	f04f 32ff 	mov.w	r2, #4294967295
 8014aa4:	9203      	str	r2, [sp, #12]
 8014aa6:	f8ad 3010 	strh.w	r3, [sp, #16]
 8014aaa:	f8ad 3012 	strh.w	r3, [sp, #18]
 8014aae:	f8ad 3014 	strh.w	r3, [sp, #20]
 8014ab2:	f8ad 3016 	strh.w	r3, [sp, #22]
  display_buffer(p_at_ctxt,
 8014ab6:	f8b1 27d0 	ldrh.w	r2, [r1, #2000]	; 0x7d0
 8014aba:	f7ff fe8b 	bl	80147d4 <display_buffer>
  msg_end = atcc_extractElement(p_at_ctxt, p_message, &element_infos);
 8014abe:	aa02      	add	r2, sp, #8
 8014ac0:	4629      	mov	r1, r5
 8014ac2:	4638      	mov	r0, r7
 8014ac4:	f7f7 fcc0 	bl	800c448 <atcc_extractElement>
 8014ac8:	4681      	mov	r9, r0
  cmd_retval = atcc_analyzeCmd(p_at_ctxt, p_message, &element_infos);
 8014aca:	aa02      	add	r2, sp, #8
 8014acc:	4629      	mov	r1, r5
 8014ace:	4638      	mov	r0, r7
 8014ad0:	f7f7 fd08 	bl	800c4e4 <atcc_analyzeCmd>
 8014ad4:	4680      	mov	r8, r0
  clean_retval = (at_action_rsp_t)(cmd_retval & ~(at_action_rsp_t)ATACTION_RSP_FLAG_DATA_MODE);
 8014ad6:	f3c0 040e 	ubfx	r4, r0, #0, #15
  data_mode = (((uint16_t)cmd_retval & (uint16_t)ATACTION_RSP_FLAG_DATA_MODE) != 0U) ? (uint16_t)1U : (uint16_t)0U;
 8014ada:	f3c0 3acf 	ubfx	sl, r0, #15, #16
  PRINT_DBG("analyzeCmd retval = %d (DATA mode=%d) msg_end = %d", clean_retval, data_mode, (msg_end == ATENDMSG_YES))
 8014ade:	4e4f      	ldr	r6, [pc, #316]	; (8014c1c <ATParser_parse_rsp+0x18c>)
 8014ae0:	fab9 f389 	clz	r3, r9
 8014ae4:	095b      	lsrs	r3, r3, #5
 8014ae6:	9300      	str	r3, [sp, #0]
 8014ae8:	4653      	mov	r3, sl
 8014aea:	4622      	mov	r2, r4
 8014aec:	494c      	ldr	r1, [pc, #304]	; (8014c20 <ATParser_parse_rsp+0x190>)
 8014aee:	4630      	mov	r0, r6
 8014af0:	f011 f8be 	bl	8025c70 <sprintf>
 8014af4:	4630      	mov	r0, r6
 8014af6:	f00a fb0c 	bl	801f112 <crs_strlen>
 8014afa:	b283      	uxth	r3, r0
 8014afc:	4632      	mov	r2, r6
 8014afe:	2102      	movs	r1, #2
 8014b00:	4608      	mov	r0, r1
 8014b02:	f00a fb49 	bl	801f198 <traceIF_itmPrint>
 8014b06:	4630      	mov	r0, r6
 8014b08:	f00a fb03 	bl	801f112 <crs_strlen>
 8014b0c:	b283      	uxth	r3, r0
 8014b0e:	4632      	mov	r2, r6
 8014b10:	2102      	movs	r1, #2
 8014b12:	4608      	mov	r0, r1
 8014b14:	f00a fb62 	bl	801f1dc <traceIF_uartPrint>
  if ((msg_end != ATENDMSG_YES) && (cmd_retval != ATACTION_RSP_ERROR))
 8014b18:	f1b9 0f00 	cmp.w	r9, #0
 8014b1c:	d002      	beq.n	8014b24 <ATParser_parse_rsp+0x94>
 8014b1e:	f1b8 0f04 	cmp.w	r8, #4
 8014b22:	d120      	bne.n	8014b66 <ATParser_parse_rsp+0xd6>
  if (clean_retval == ATACTION_RSP_FRC_END)
 8014b24:	2c01      	cmp	r4, #1
 8014b26:	d062      	beq.n	8014bee <ATParser_parse_rsp+0x15e>
  if (data_mode == 1U)
 8014b28:	f1ba 0f01 	cmp.w	sl, #1
 8014b2c:	d06f      	beq.n	8014c0e <ATParser_parse_rsp+0x17e>
  PRINT_DBG("ATParser_parse_rsp returned action = 0x%x", cmd_retval)
 8014b2e:	4d3b      	ldr	r5, [pc, #236]	; (8014c1c <ATParser_parse_rsp+0x18c>)
 8014b30:	4622      	mov	r2, r4
 8014b32:	493c      	ldr	r1, [pc, #240]	; (8014c24 <ATParser_parse_rsp+0x194>)
 8014b34:	4628      	mov	r0, r5
 8014b36:	f011 f89b 	bl	8025c70 <sprintf>
 8014b3a:	4628      	mov	r0, r5
 8014b3c:	f00a fae9 	bl	801f112 <crs_strlen>
 8014b40:	b283      	uxth	r3, r0
 8014b42:	462a      	mov	r2, r5
 8014b44:	2102      	movs	r1, #2
 8014b46:	4608      	mov	r0, r1
 8014b48:	f00a fb26 	bl	801f198 <traceIF_itmPrint>
 8014b4c:	4628      	mov	r0, r5
 8014b4e:	f00a fae0 	bl	801f112 <crs_strlen>
 8014b52:	b283      	uxth	r3, r0
 8014b54:	462a      	mov	r2, r5
 8014b56:	2102      	movs	r1, #2
 8014b58:	4608      	mov	r0, r1
 8014b5a:	f00a fb3f 	bl	801f1dc <traceIF_uartPrint>
}
 8014b5e:	4620      	mov	r0, r4
 8014b60:	b006      	add	sp, #24
 8014b62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    PRINT_DBG("proceed to params")
 8014b66:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 8014c2c <ATParser_parse_rsp+0x19c>
 8014b6a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014b6e:	6030      	str	r0, [r6, #0]
 8014b70:	6071      	str	r1, [r6, #4]
 8014b72:	60b2      	str	r2, [r6, #8]
 8014b74:	60f3      	str	r3, [r6, #12]
 8014b76:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8014b7a:	6130      	str	r0, [r6, #16]
 8014b7c:	6171      	str	r1, [r6, #20]
 8014b7e:	61b2      	str	r2, [r6, #24]
 8014b80:	f89c 3000 	ldrb.w	r3, [ip]
 8014b84:	7733      	strb	r3, [r6, #28]
 8014b86:	4630      	mov	r0, r6
 8014b88:	f00a fac3 	bl	801f112 <crs_strlen>
 8014b8c:	b283      	uxth	r3, r0
 8014b8e:	4632      	mov	r2, r6
 8014b90:	2102      	movs	r1, #2
 8014b92:	4608      	mov	r0, r1
 8014b94:	f00a fb00 	bl	801f198 <traceIF_itmPrint>
 8014b98:	4630      	mov	r0, r6
 8014b9a:	f00a faba 	bl	801f112 <crs_strlen>
 8014b9e:	b283      	uxth	r3, r0
 8014ba0:	4632      	mov	r2, r6
 8014ba2:	2102      	movs	r1, #2
 8014ba4:	4608      	mov	r0, r1
 8014ba6:	f00a fb19 	bl	801f1dc <traceIF_uartPrint>
    param_retval = atcc_analyzeParam(p_at_ctxt, p_message, &element_infos);
 8014baa:	aa02      	add	r2, sp, #8
 8014bac:	4629      	mov	r1, r5
 8014bae:	4638      	mov	r0, r7
 8014bb0:	f7f7 fcc2 	bl	800c538 <atcc_analyzeParam>
 8014bb4:	4605      	mov	r5, r0
    if (param_retval != ATACTION_RSP_IGNORED)
 8014bb6:	2810      	cmp	r0, #16
 8014bb8:	d0b4      	beq.n	8014b24 <ATParser_parse_rsp+0x94>
      PRINT_DBG("action modified by analysis of params: %d to %d", cmd_retval, param_retval)
 8014bba:	4603      	mov	r3, r0
 8014bbc:	4642      	mov	r2, r8
 8014bbe:	491a      	ldr	r1, [pc, #104]	; (8014c28 <ATParser_parse_rsp+0x198>)
 8014bc0:	4630      	mov	r0, r6
 8014bc2:	f011 f855 	bl	8025c70 <sprintf>
 8014bc6:	4630      	mov	r0, r6
 8014bc8:	f00a faa3 	bl	801f112 <crs_strlen>
 8014bcc:	b283      	uxth	r3, r0
 8014bce:	4632      	mov	r2, r6
 8014bd0:	2102      	movs	r1, #2
 8014bd2:	4608      	mov	r0, r1
 8014bd4:	f00a fae0 	bl	801f198 <traceIF_itmPrint>
 8014bd8:	4630      	mov	r0, r6
 8014bda:	f00a fa9a 	bl	801f112 <crs_strlen>
 8014bde:	b283      	uxth	r3, r0
 8014be0:	4632      	mov	r2, r6
 8014be2:	2102      	movs	r1, #2
 8014be4:	4608      	mov	r0, r1
 8014be6:	f00a faf9 	bl	801f1dc <traceIF_uartPrint>
      clean_retval = param_retval;
 8014bea:	462c      	mov	r4, r5
 8014bec:	e79a      	b.n	8014b24 <ATParser_parse_rsp+0x94>
    final_retval = atcc_terminateCmd(p_at_ctxt, &element_infos);
 8014bee:	a902      	add	r1, sp, #8
 8014bf0:	4638      	mov	r0, r7
 8014bf2:	f7f7 fccb 	bl	800c58c <atcc_terminateCmd>
    if (final_retval == ATACTION_RSP_ERROR)
 8014bf6:	2804      	cmp	r0, #4
 8014bf8:	d003      	beq.n	8014c02 <ATParser_parse_rsp+0x172>
    else if (p_at_ctxt->parser.is_final_cmd == 0U)
 8014bfa:	7d3b      	ldrb	r3, [r7, #20]
 8014bfc:	b913      	cbnz	r3, 8014c04 <ATParser_parse_rsp+0x174>
      clean_retval = ATACTION_RSP_FRC_CONTINUE;
 8014bfe:	2402      	movs	r4, #2
 8014c00:	e000      	b.n	8014c04 <ATParser_parse_rsp+0x174>
      clean_retval = ATACTION_RSP_ERROR;
 8014c02:	4604      	mov	r4, r0
    reset_current_command(&p_at_ctxt->parser);
 8014c04:	f107 0010 	add.w	r0, r7, #16
 8014c08:	f7ff fcbc 	bl	8014584 <reset_current_command>
 8014c0c:	e78c      	b.n	8014b28 <ATParser_parse_rsp+0x98>
    cmd_retval = (at_action_rsp_t)(clean_retval | ATACTION_RSP_FLAG_DATA_MODE);
 8014c0e:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 8014c12:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8014c16:	b2a4      	uxth	r4, r4
 8014c18:	e789      	b.n	8014b2e <ATParser_parse_rsp+0x9e>
 8014c1a:	bf00      	nop
 8014c1c:	200048dc 	.word	0x200048dc
 8014c20:	08030bc0 	.word	0x08030bc0
 8014c24:	08030c5c 	.word	0x08030c5c
 8014c28:	08030c20 	.word	0x08030c20
 8014c2c:	08030c00 	.word	0x08030c00

08014c30 <ATParser_get_rsp>:
{
 8014c30:	b538      	push	{r3, r4, r5, lr}
 8014c32:	4605      	mov	r5, r0
  retval = atcc_get_rsp(p_at_ctxt, p_rsp_buf);
 8014c34:	f7f7 fcd6 	bl	800c5e4 <atcc_get_rsp>
 8014c38:	4604      	mov	r4, r0
  reset_parser_context(&p_at_ctxt->parser);
 8014c3a:	f105 0010 	add.w	r0, r5, #16
 8014c3e:	f7ff fcb7 	bl	80145b0 <reset_parser_context>
}
 8014c42:	4620      	mov	r0, r4
 8014c44:	bd38      	pop	{r3, r4, r5, pc}

08014c46 <ATParser_get_urc>:
{
 8014c46:	b508      	push	{r3, lr}
  retval = atcc_get_urc(p_at_ctxt, p_rsp_buf);
 8014c48:	f7f7 fcf8 	bl	800c63c <atcc_get_urc>
}
 8014c4c:	bd08      	pop	{r3, pc}

08014c4e <ATParser_get_error>:
{
 8014c4e:	b508      	push	{r3, lr}
  retval = atcc_get_error(p_at_ctxt, p_rsp_buf);
 8014c50:	f7f7 fd20 	bl	800c694 <atcc_get_error>
}
 8014c54:	bd08      	pop	{r3, pc}

08014c56 <ATParser_abort_request>:
{
 8014c56:	b508      	push	{r3, lr}
  reset_parser_context(&p_at_ctxt->parser);
 8014c58:	3010      	adds	r0, #16
 8014c5a:	f7ff fca9 	bl	80145b0 <reset_parser_context>
}
 8014c5e:	bd08      	pop	{r3, pc}

08014c60 <ATutil_ipow>:
/* Global variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/

/* Functions Definition ------------------------------------------------------*/
uint32_t ATutil_ipow(uint32_t base, uint16_t exp)
{
 8014c60:	4603      	mov	r3, r0
  uint16_t local_exp = exp;
  uint32_t local_base = base;

  /* implementation of power function */
  uint32_t result = 1U;
 8014c62:	2001      	movs	r0, #1
  while (local_exp != 0U)
 8014c64:	e002      	b.n	8014c6c <ATutil_ipow+0xc>
  {
    if ((local_exp & 1U) != 0U)
    {
      result *= local_base;
    }
    local_exp >>= 1;
 8014c66:	0849      	lsrs	r1, r1, #1
    local_base *= local_base;
 8014c68:	fb03 f303 	mul.w	r3, r3, r3
  while (local_exp != 0U)
 8014c6c:	b129      	cbz	r1, 8014c7a <ATutil_ipow+0x1a>
    if ((local_exp & 1U) != 0U)
 8014c6e:	f011 0f01 	tst.w	r1, #1
 8014c72:	d0f8      	beq.n	8014c66 <ATutil_ipow+0x6>
      result *= local_base;
 8014c74:	fb03 f000 	mul.w	r0, r3, r0
 8014c78:	e7f5      	b.n	8014c66 <ATutil_ipow+0x6>
  }

  return result;
}
 8014c7a:	4770      	bx	lr

08014c7c <ATutil_convertHexaStringToInt32>:

  return (conv_nbr);
}

uint32_t ATutil_convertHexaStringToInt32(const uint8_t *p_string, uint16_t size)
{
 8014c7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014c80:	4681      	mov	r9, r0
 8014c82:	460e      	mov	r6, r1
   * implicit input string format from "W" to "WWWWXXXX"
   * where X,Y,W and Z are characters from '0' to 'F'
   */

  /* auto-detect if 0x is present */
  if ((size > 2U) && (p_string[1] == 120U)) /* ASCII value 120 = 'x' */
 8014c84:	2902      	cmp	r1, #2
 8014c86:	d904      	bls.n	8014c92 <ATutil_convertHexaStringToInt32+0x16>
 8014c88:	7843      	ldrb	r3, [r0, #1]
 8014c8a:	2b78      	cmp	r3, #120	; 0x78
 8014c8c:	d00b      	beq.n	8014ca6 <ATutil_convertHexaStringToInt32+0x2a>
    nb_digit_ignored = 2U;
  }
  else
  {
    /* 0x is not present */
    nb_digit_ignored = 0U;
 8014c8e:	2400      	movs	r4, #0
 8014c90:	e000      	b.n	8014c94 <ATutil_convertHexaStringToInt32+0x18>
 8014c92:	2400      	movs	r4, #0
  }

  /* if 0x is present, we can skip it */
  str_size_to_convert = size - nb_digit_ignored;
 8014c94:	1b33      	subs	r3, r6, r4
 8014c96:	b29b      	uxth	r3, r3

  /* check maximum string size */
  if (str_size_to_convert <= MAX_32BITS_STRING_SIZE)
 8014c98:	2b08      	cmp	r3, #8
 8014c9a:	d947      	bls.n	8014d2c <ATutil_convertHexaStringToInt32+0xb0>
  uint32_t conv_nbr = 0U; /* returned value = converted numder (0 if an error occurs) */
 8014c9c:	f04f 0800 	mov.w	r8, #0
      }
    }
  }

  return (conv_nbr);
}
 8014ca0:	4640      	mov	r0, r8
 8014ca2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    nb_digit_ignored = 2U;
 8014ca6:	2402      	movs	r4, #2
 8014ca8:	e7f4      	b.n	8014c94 <ATutil_convertHexaStringToInt32+0x18>
        loop++;
 8014caa:	3501      	adds	r5, #1
 8014cac:	b2ad      	uxth	r5, r5
                   (((uint32_t)p_string[idx] - 48U) * ATutil_ipow(16U, (size - loop - nb_digit_ignored)));
 8014cae:	f1a2 0a30 	sub.w	sl, r2, #48	; 0x30
 8014cb2:	1b71      	subs	r1, r6, r5
 8014cb4:	b289      	uxth	r1, r1
 8014cb6:	1bc9      	subs	r1, r1, r7
 8014cb8:	b289      	uxth	r1, r1
 8014cba:	2010      	movs	r0, #16
 8014cbc:	f7ff ffd0 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014cc0:	fb00 880a 	mla	r8, r0, sl, r8
    for (idx = nb_digit_ignored; idx < size; idx++)
 8014cc4:	3401      	adds	r4, #1
 8014cc6:	b2a4      	uxth	r4, r4
 8014cc8:	42b4      	cmp	r4, r6
 8014cca:	d2e9      	bcs.n	8014ca0 <ATutil_convertHexaStringToInt32+0x24>
      if ((p_string[idx] >= 48U) && (p_string[idx] <= 57U))
 8014ccc:	f819 2004 	ldrb.w	r2, [r9, r4]
 8014cd0:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8014cd4:	b2db      	uxtb	r3, r3
 8014cd6:	2b09      	cmp	r3, #9
 8014cd8:	d9e7      	bls.n	8014caa <ATutil_convertHexaStringToInt32+0x2e>
      else if ((p_string[idx] >= 97U) && (p_string[idx] <= 102U))
 8014cda:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 8014cde:	b2db      	uxtb	r3, r3
 8014ce0:	2b05      	cmp	r3, #5
 8014ce2:	d907      	bls.n	8014cf4 <ATutil_convertHexaStringToInt32+0x78>
      else if ((p_string[idx] >= 65U) && (p_string[idx] <= 70U))
 8014ce4:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 8014ce8:	b2db      	uxtb	r3, r3
 8014cea:	2b05      	cmp	r3, #5
 8014cec:	d910      	bls.n	8014d10 <ATutil_convertHexaStringToInt32+0x94>
        nb_digit_ignored++;
 8014cee:	3701      	adds	r7, #1
 8014cf0:	b2bf      	uxth	r7, r7
 8014cf2:	e7e7      	b.n	8014cc4 <ATutil_convertHexaStringToInt32+0x48>
        loop++;
 8014cf4:	3501      	adds	r5, #1
 8014cf6:	b2ad      	uxth	r5, r5
                   (((uint32_t)p_string[idx] - 97U + 10U) * ATutil_ipow(16U, (size - loop - nb_digit_ignored)));
 8014cf8:	f1a2 0a57 	sub.w	sl, r2, #87	; 0x57
 8014cfc:	1b71      	subs	r1, r6, r5
 8014cfe:	b289      	uxth	r1, r1
 8014d00:	1bc9      	subs	r1, r1, r7
 8014d02:	b289      	uxth	r1, r1
 8014d04:	2010      	movs	r0, #16
 8014d06:	f7ff ffab 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014d0a:	fb00 880a 	mla	r8, r0, sl, r8
 8014d0e:	e7d9      	b.n	8014cc4 <ATutil_convertHexaStringToInt32+0x48>
        loop++;
 8014d10:	3501      	adds	r5, #1
 8014d12:	b2ad      	uxth	r5, r5
                   (((uint32_t)p_string[idx] - 65U + 10U) * ATutil_ipow(16U, (size - loop - nb_digit_ignored)));
 8014d14:	f1a2 0a37 	sub.w	sl, r2, #55	; 0x37
 8014d18:	1b71      	subs	r1, r6, r5
 8014d1a:	b289      	uxth	r1, r1
 8014d1c:	1bc9      	subs	r1, r1, r7
 8014d1e:	b289      	uxth	r1, r1
 8014d20:	2010      	movs	r0, #16
 8014d22:	f7ff ff9d 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014d26:	fb00 880a 	mla	r8, r0, sl, r8
 8014d2a:	e7cb      	b.n	8014cc4 <ATutil_convertHexaStringToInt32+0x48>
 8014d2c:	4627      	mov	r7, r4
  uint16_t loop = 0U;
 8014d2e:	2500      	movs	r5, #0
  uint32_t conv_nbr = 0U; /* returned value = converted numder (0 if an error occurs) */
 8014d30:	46a8      	mov	r8, r5
 8014d32:	e7c9      	b.n	8014cc8 <ATutil_convertHexaStringToInt32+0x4c>

08014d34 <ATutil_convertStringToInt>:
{
 8014d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014d38:	4680      	mov	r8, r0
 8014d3a:	460f      	mov	r7, r1
  if ((size > 2U) && (p_string[1] == 120U)) /* ASCII value 120 = 'x' */
 8014d3c:	2902      	cmp	r1, #2
 8014d3e:	d804      	bhi.n	8014d4a <ATutil_convertStringToInt+0x16>
 8014d40:	2600      	movs	r6, #0
 8014d42:	4635      	mov	r5, r6
 8014d44:	4634      	mov	r4, r6
 8014d46:	46b1      	mov	r9, r6
 8014d48:	e011      	b.n	8014d6e <ATutil_convertStringToInt+0x3a>
 8014d4a:	7843      	ldrb	r3, [r0, #1]
 8014d4c:	2b78      	cmp	r3, #120	; 0x78
 8014d4e:	d004      	beq.n	8014d5a <ATutil_convertStringToInt+0x26>
 8014d50:	2600      	movs	r6, #0
 8014d52:	4635      	mov	r5, r6
 8014d54:	4634      	mov	r4, r6
 8014d56:	46b1      	mov	r9, r6
 8014d58:	e009      	b.n	8014d6e <ATutil_convertStringToInt+0x3a>
    conv_nbr = ATutil_convertHexaStringToInt32(p_string, size);
 8014d5a:	f7ff ff8f 	bl	8014c7c <ATutil_convertHexaStringToInt32>
 8014d5e:	4681      	mov	r9, r0
}
 8014d60:	4648      	mov	r0, r9
 8014d62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nb_digit_ignored++;
 8014d66:	3501      	adds	r5, #1
 8014d68:	b2ad      	uxth	r5, r5
    for (idx = 0U; idx < size; idx++)
 8014d6a:	3401      	adds	r4, #1
 8014d6c:	b2a4      	uxth	r4, r4
 8014d6e:	42bc      	cmp	r4, r7
 8014d70:	d2f6      	bcs.n	8014d60 <ATutil_convertStringToInt+0x2c>
      if ((p_string[idx] >= 48U) && (p_string[idx] <= 57U))
 8014d72:	f818 2004 	ldrb.w	r2, [r8, r4]
 8014d76:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8014d7a:	b2db      	uxtb	r3, r3
 8014d7c:	2b09      	cmp	r3, #9
 8014d7e:	d8f2      	bhi.n	8014d66 <ATutil_convertStringToInt+0x32>
        loop++;
 8014d80:	3601      	adds	r6, #1
 8014d82:	b2b6      	uxth	r6, r6
                   (((uint32_t) p_string[idx] - 48U) * ATutil_ipow(10U, (size - loop - nb_digit_ignored)));
 8014d84:	f1a2 0a30 	sub.w	sl, r2, #48	; 0x30
 8014d88:	1bb9      	subs	r1, r7, r6
 8014d8a:	b289      	uxth	r1, r1
 8014d8c:	1b49      	subs	r1, r1, r5
 8014d8e:	b289      	uxth	r1, r1
 8014d90:	200a      	movs	r0, #10
 8014d92:	f7ff ff65 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014d96:	fb00 990a 	mla	r9, r0, sl, r9
 8014d9a:	e7e6      	b.n	8014d6a <ATutil_convertStringToInt+0x36>

08014d9c <ATutil_convertHexaStringToInt64>:

uint8_t ATutil_convertHexaStringToInt64(const uint8_t *p_string, uint16_t size, uint32_t *high_part_value,
                                        uint32_t *low_part_value)
{
 8014d9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014da0:	4606      	mov	r6, r0
 8014da2:	4617      	mov	r7, r2
 8014da4:	461d      	mov	r5, r3
   * implicit input string format from "W" to "WWWWXXXXYYYYZZZZ"
   * where X,Y,W and Z are characters from '0' to 'F'
   */

  /* init decoded values */
  *high_part_value = 0U;
 8014da6:	2300      	movs	r3, #0
 8014da8:	6013      	str	r3, [r2, #0]
  *low_part_value = 0U;
 8014daa:	602b      	str	r3, [r5, #0]

  /* auto-detect if 0x is present */
  if ((size > 2U) && (p_string[1] == 120U)) /* ASCII value 120 = 'x' */
 8014dac:	2902      	cmp	r1, #2
 8014dae:	d905      	bls.n	8014dbc <ATutil_convertHexaStringToInt64+0x20>
 8014db0:	7843      	ldrb	r3, [r0, #1]
 8014db2:	2b78      	cmp	r3, #120	; 0x78
 8014db4:	d019      	beq.n	8014dea <ATutil_convertHexaStringToInt64+0x4e>
    nb_digit_ignored = 2U;
  }
  else
  {
    /* 0x is not present */
    nb_digit_ignored = 0U;
 8014db6:	f04f 0800 	mov.w	r8, #0
 8014dba:	e001      	b.n	8014dc0 <ATutil_convertHexaStringToInt64+0x24>
 8014dbc:	f04f 0800 	mov.w	r8, #0
  }

  /* if 0x is present, we can skip it */
  str_size_to_convert = size - nb_digit_ignored;
 8014dc0:	eba1 0108 	sub.w	r1, r1, r8
 8014dc4:	b28c      	uxth	r4, r1

  /* check maximum string size */
  if (str_size_to_convert > MAX_64BITS_STRING_SIZE)
 8014dc6:	2c10      	cmp	r4, #16
 8014dc8:	d81d      	bhi.n	8014e06 <ATutil_convertHexaStringToInt64+0x6a>
    /* conversion error */
    retval = 0U;
  }
  else
  {
    if (str_size_to_convert > 8U)
 8014dca:	2c08      	cmp	r4, #8
 8014dcc:	d810      	bhi.n	8014df0 <ATutil_convertHexaStringToInt64+0x54>
      *high_part_value = ATutil_convertHexaStringToInt32((const uint8_t *)(p_string + nb_digit_ignored),
                                                         high_part_size);
    }
    else
    {
      high_part_size = 0U;
 8014dce:	f04f 0900 	mov.w	r9, #0
    }

    /* convert lower part */
    low_part_size = str_size_to_convert - high_part_size;
 8014dd2:	eba4 0109 	sub.w	r1, r4, r9
    *low_part_value =  ATutil_convertHexaStringToInt32((const uint8_t *)(p_string + nb_digit_ignored + high_part_size),
 8014dd6:	eb08 0009 	add.w	r0, r8, r9
 8014dda:	b289      	uxth	r1, r1
 8014ddc:	4430      	add	r0, r6
 8014dde:	f7ff ff4d 	bl	8014c7c <ATutil_convertHexaStringToInt32>
 8014de2:	6028      	str	r0, [r5, #0]
                                                       low_part_size);

    /* string successfully converted */
    retval = 1U;
 8014de4:	2001      	movs	r0, #1
  }

  return (retval);
}
 8014de6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nb_digit_ignored = 2U;
 8014dea:	f04f 0802 	mov.w	r8, #2
 8014dee:	e7e7      	b.n	8014dc0 <ATutil_convertHexaStringToInt64+0x24>
      high_part_size = str_size_to_convert - 8U;
 8014df0:	f1a4 0908 	sub.w	r9, r4, #8
 8014df4:	fa1f f989 	uxth.w	r9, r9
      *high_part_value = ATutil_convertHexaStringToInt32((const uint8_t *)(p_string + nb_digit_ignored),
 8014df8:	4649      	mov	r1, r9
 8014dfa:	eb06 0008 	add.w	r0, r6, r8
 8014dfe:	f7ff ff3d 	bl	8014c7c <ATutil_convertHexaStringToInt32>
 8014e02:	6038      	str	r0, [r7, #0]
 8014e04:	e7e5      	b.n	8014dd2 <ATutil_convertHexaStringToInt64+0x36>
    retval = 0U;
 8014e06:	2000      	movs	r0, #0
 8014e08:	e7ed      	b.n	8014de6 <ATutil_convertHexaStringToInt64+0x4a>

08014e0a <ATutil_convertBinStringToInt32>:

uint32_t ATutil_convertBinStringToInt32(const uint8_t *p_string, uint16_t size)
{
 8014e0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014e0e:	4607      	mov	r7, r0
 8014e10:	460d      	mov	r5, r1
  uint32_t conv_nbr = 0U; /* returned value = converted numder (returns 0 if an error occurs) */

  for (uint16_t i = 0; i < size; i++)
 8014e12:	2400      	movs	r4, #0
  uint32_t conv_nbr = 0U; /* returned value = converted numder (returns 0 if an error occurs) */
 8014e14:	4626      	mov	r6, r4
  for (uint16_t i = 0; i < size; i++)
 8014e16:	e009      	b.n	8014e2c <ATutil_convertBinStringToInt32+0x22>
  {
    /* convert ASCII character to its value (0x31 for 1, 0x30 for 0) */
    uint32_t bit = (p_string[size - i - 1U] == 0x31U) ? 1U : 0U;
 8014e18:	f04f 0801 	mov.w	r8, #1
    /* bit weight */
    uint32_t weight = ATutil_ipow(2U, i);
 8014e1c:	4621      	mov	r1, r4
 8014e1e:	2002      	movs	r0, #2
 8014e20:	f7ff ff1e 	bl	8014c60 <ATutil_ipow>
    conv_nbr += bit * weight;
 8014e24:	fb00 6608 	mla	r6, r0, r8, r6
  for (uint16_t i = 0; i < size; i++)
 8014e28:	3401      	adds	r4, #1
 8014e2a:	b2a4      	uxth	r4, r4
 8014e2c:	42ac      	cmp	r4, r5
 8014e2e:	d208      	bcs.n	8014e42 <ATutil_convertBinStringToInt32+0x38>
    uint32_t bit = (p_string[size - i - 1U] == 0x31U) ? 1U : 0U;
 8014e30:	1b2b      	subs	r3, r5, r4
 8014e32:	443b      	add	r3, r7
 8014e34:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8014e38:	2b31      	cmp	r3, #49	; 0x31
 8014e3a:	d0ed      	beq.n	8014e18 <ATutil_convertBinStringToInt32+0xe>
 8014e3c:	f04f 0800 	mov.w	r8, #0
 8014e40:	e7ec      	b.n	8014e1c <ATutil_convertBinStringToInt32+0x12>
  }

  return (conv_nbr);
}
 8014e42:	4630      	mov	r0, r6
 8014e44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08014e48 <ATutil_convertStringToUpperCase>:
  }
  return (isneg);
}

void ATutil_convertStringToUpperCase(uint8_t *p_string, uint16_t size)
{
 8014e48:	b500      	push	{lr}
  uint16_t idx = 0U;
 8014e4a:	2300      	movs	r3, #0
  while ((p_string[idx] != 0U) && (idx < size))
 8014e4c:	e001      	b.n	8014e52 <ATutil_convertStringToUpperCase+0xa>
    if ((p_string[idx] >= 97U) && (p_string[idx] <= 122U))
    {
      /* ...convert it to uppercase character */
      p_string[idx] -= 32U;
    }
    idx++;
 8014e4e:	3301      	adds	r3, #1
 8014e50:	b29b      	uxth	r3, r3
  while ((p_string[idx] != 0U) && (idx < size))
 8014e52:	eb00 0e03 	add.w	lr, r0, r3
 8014e56:	5cc2      	ldrb	r2, [r0, r3]
 8014e58:	b162      	cbz	r2, 8014e74 <ATutil_convertStringToUpperCase+0x2c>
 8014e5a:	428b      	cmp	r3, r1
 8014e5c:	d20a      	bcs.n	8014e74 <ATutil_convertStringToUpperCase+0x2c>
    if ((p_string[idx] >= 97U) && (p_string[idx] <= 122U))
 8014e5e:	f1a2 0c61 	sub.w	ip, r2, #97	; 0x61
 8014e62:	fa5f fc8c 	uxtb.w	ip, ip
 8014e66:	f1bc 0f19 	cmp.w	ip, #25
 8014e6a:	d8f0      	bhi.n	8014e4e <ATutil_convertStringToUpperCase+0x6>
      p_string[idx] -= 32U;
 8014e6c:	3a20      	subs	r2, #32
 8014e6e:	f88e 2000 	strb.w	r2, [lr]
 8014e72:	e7ec      	b.n	8014e4e <ATutil_convertStringToUpperCase+0x6>
  }
}
 8014e74:	f85d fb04 	ldr.w	pc, [sp], #4

08014e78 <ATutil_convert_uint8_to_binary_string>:
uint8_t ATutil_convert_uint8_to_binary_string(uint32_t value, uint8_t nbBits, uint8_t sizeStr, uint8_t *binStr)
{
  uint8_t retval;

  /* String need to be at least one character more than the number of bits */
  if (sizeStr > nbBits)
 8014e78:	428a      	cmp	r2, r1
 8014e7a:	d81a      	bhi.n	8014eb2 <ATutil_convert_uint8_to_binary_string+0x3a>
    binStr[nbBits] = 0U;
    retval = 0U;
  }
  else
  {
    retval = 1U;
 8014e7c:	2001      	movs	r0, #1
 8014e7e:	4770      	bx	lr
      binStr[nbBits - i - 1U] = (((value >> i) % 2U) == 0U) ? 0x30U : 0x31U;
 8014e80:	f04f 0e31 	mov.w	lr, #49	; 0x31
 8014e84:	eba1 0c0c 	sub.w	ip, r1, ip
 8014e88:	f10c 3cff 	add.w	ip, ip, #4294967295
 8014e8c:	f803 e00c 	strb.w	lr, [r3, ip]
    for (uint8_t i = 0U; i < nbBits; i++)
 8014e90:	3201      	adds	r2, #1
 8014e92:	b2d2      	uxtb	r2, r2
 8014e94:	428a      	cmp	r2, r1
 8014e96:	d208      	bcs.n	8014eaa <ATutil_convert_uint8_to_binary_string+0x32>
      binStr[nbBits - i - 1U] = (((value >> i) % 2U) == 0U) ? 0x30U : 0x31U;
 8014e98:	4694      	mov	ip, r2
 8014e9a:	fa20 fe02 	lsr.w	lr, r0, r2
 8014e9e:	f01e 0f01 	tst.w	lr, #1
 8014ea2:	d1ed      	bne.n	8014e80 <ATutil_convert_uint8_to_binary_string+0x8>
 8014ea4:	f04f 0e30 	mov.w	lr, #48	; 0x30
 8014ea8:	e7ec      	b.n	8014e84 <ATutil_convert_uint8_to_binary_string+0xc>
    binStr[nbBits] = 0U;
 8014eaa:	2000      	movs	r0, #0
 8014eac:	5458      	strb	r0, [r3, r1]
  }

  return (retval);
}
 8014eae:	f85d fb04 	ldr.w	pc, [sp], #4
    for (uint8_t i = 0U; i < nbBits; i++)
 8014eb2:	2200      	movs	r2, #0
 8014eb4:	428a      	cmp	r2, r1
 8014eb6:	d201      	bcs.n	8014ebc <ATutil_convert_uint8_to_binary_string+0x44>
{
 8014eb8:	b500      	push	{lr}
 8014eba:	e7ed      	b.n	8014e98 <ATutil_convert_uint8_to_binary_string+0x20>
    binStr[nbBits] = 0U;
 8014ebc:	2000      	movs	r0, #0
 8014ebe:	5458      	strb	r0, [r3, r1]
}
 8014ec0:	4770      	bx	lr

08014ec2 <ATutil_remove_quotes>:
  * @param  p_Dst ptr to Destination Buffer (string without quotes)
  * @param  dstSize of p_Dst buffer
  * @retval size of destination string (util part).
  */
uint16_t ATutil_remove_quotes(const uint8_t *p_Src, uint16_t srcSize, uint8_t *p_Dst, uint16_t dstSize)
{
 8014ec2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014ec4:	4606      	mov	r6, r0
 8014ec6:	460d      	mov	r5, r1
 8014ec8:	4617      	mov	r7, r2
 8014eca:	461c      	mov	r4, r3
  uint16_t src_idx;
  uint16_t dest_idx = 0U;

  /* reset p_Dst buffer */
  (void) memset((void *)p_Dst, 0, dstSize);
 8014ecc:	461a      	mov	r2, r3
 8014ece:	2100      	movs	r1, #0
 8014ed0:	4638      	mov	r0, r7
 8014ed2:	f010 ff40 	bl	8025d56 <memset>
  uint16_t dest_idx = 0U;
 8014ed6:	2000      	movs	r0, #0

  /* parse p_Src */
  for (src_idx = 0; ((src_idx < srcSize) && (dest_idx < dstSize)); src_idx++)
 8014ed8:	4684      	mov	ip, r0
 8014eda:	e003      	b.n	8014ee4 <ATutil_remove_quotes+0x22>
 8014edc:	f10c 0c01 	add.w	ip, ip, #1
 8014ee0:	fa1f fc8c 	uxth.w	ip, ip
 8014ee4:	45ac      	cmp	ip, r5
 8014ee6:	d209      	bcs.n	8014efc <ATutil_remove_quotes+0x3a>
 8014ee8:	42a0      	cmp	r0, r4
 8014eea:	d207      	bcs.n	8014efc <ATutil_remove_quotes+0x3a>
  {
    /* remove quotes from the string */
    if (p_Src[src_idx] != 0x22U)
 8014eec:	f816 300c 	ldrb.w	r3, [r6, ip]
 8014ef0:	2b22      	cmp	r3, #34	; 0x22
 8014ef2:	d0f3      	beq.n	8014edc <ATutil_remove_quotes+0x1a>
    {
      /* write to p_Dst*/
      p_Dst[dest_idx] = p_Src[src_idx];
 8014ef4:	543b      	strb	r3, [r7, r0]
      dest_idx++;
 8014ef6:	3001      	adds	r0, #1
 8014ef8:	b280      	uxth	r0, r0
 8014efa:	e7ef      	b.n	8014edc <ATutil_remove_quotes+0x1a>
    }
  }

  return (dest_idx);
}
 8014efc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08014f00 <SysCtrl_getDeviceDescriptor>:
sysctrl_status_t SysCtrl_getDeviceDescriptor(sysctrl_device_type_t device_type, sysctrl_info_t *p_devices_list)
{
  sysctrl_status_t retval;

  /* check input parameters validity */
  if (p_devices_list == NULL)
 8014f00:	b1b9      	cbz	r1, 8014f32 <SysCtrl_getDeviceDescriptor+0x32>
{
 8014f02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014f04:	4604      	mov	r4, r0
 8014f06:	460d      	mov	r5, r1
    retval = SCSTATUS_ERROR;
  }
  else
  {
    /* check if device is already initialized */
    if (sysctrl_custom_func[device_type].initialized == 0U)
 8014f08:	0143      	lsls	r3, r0, #5
 8014f0a:	4a0b      	ldr	r2, [pc, #44]	; (8014f38 <SysCtrl_getDeviceDescriptor+0x38>)
 8014f0c:	5cd3      	ldrb	r3, [r2, r3]
 8014f0e:	b13b      	cbz	r3, 8014f20 <SysCtrl_getDeviceDescriptor+0x20>
      (void) atcma_init_sysctrl_func_ptrs(&sysctrl_custom_func[device_type]);

      /* device is initialized now */
      sysctrl_custom_func[device_type].initialized = 1U;
    }
    retval = (*sysctrl_custom_func[device_type].f_getDeviceDescriptor)(device_type, p_devices_list);
 8014f10:	4b09      	ldr	r3, [pc, #36]	; (8014f38 <SysCtrl_getDeviceDescriptor+0x38>)
 8014f12:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8014f16:	685b      	ldr	r3, [r3, #4]
 8014f18:	4629      	mov	r1, r5
 8014f1a:	4620      	mov	r0, r4
 8014f1c:	4798      	blx	r3
  }

  return (retval);
}
 8014f1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void) atcma_init_sysctrl_func_ptrs(&sysctrl_custom_func[device_type]);
 8014f20:	4617      	mov	r7, r2
 8014f22:	0146      	lsls	r6, r0, #5
 8014f24:	eb02 1040 	add.w	r0, r2, r0, lsl #5
 8014f28:	f7ed f98e 	bl	8002248 <atcma_init_sysctrl_func_ptrs>
      sysctrl_custom_func[device_type].initialized = 1U;
 8014f2c:	2301      	movs	r3, #1
 8014f2e:	55bb      	strb	r3, [r7, r6]
 8014f30:	e7ee      	b.n	8014f10 <SysCtrl_getDeviceDescriptor+0x10>
    retval = SCSTATUS_ERROR;
 8014f32:	2001      	movs	r0, #1
}
 8014f34:	4770      	bx	lr
 8014f36:	bf00      	nop
 8014f38:	200035fc 	.word	0x200035fc

08014f3c <SysCtrl_open_channel>:
  * @brief  SysCtrl_open_channel
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_open_channel(sysctrl_device_type_t device_type)
{
 8014f3c:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8014f3e:	0143      	lsls	r3, r0, #5
 8014f40:	4a11      	ldr	r2, [pc, #68]	; (8014f88 <SysCtrl_open_channel+0x4c>)
 8014f42:	5cd3      	ldrb	r3, [r2, r3]
 8014f44:	2b01      	cmp	r3, #1
 8014f46:	d104      	bne.n	8014f52 <SysCtrl_open_channel+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_open_channel)(device_type);
 8014f48:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8014f4c:	689b      	ldr	r3, [r3, #8]
 8014f4e:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8014f50:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 8014f52:	4c0e      	ldr	r4, [pc, #56]	; (8014f8c <SysCtrl_open_channel+0x50>)
 8014f54:	4602      	mov	r2, r0
 8014f56:	490e      	ldr	r1, [pc, #56]	; (8014f90 <SysCtrl_open_channel+0x54>)
 8014f58:	4620      	mov	r0, r4
 8014f5a:	f010 fe89 	bl	8025c70 <sprintf>
 8014f5e:	4620      	mov	r0, r4
 8014f60:	f00a f8d7 	bl	801f112 <crs_strlen>
 8014f64:	b283      	uxth	r3, r0
 8014f66:	4622      	mov	r2, r4
 8014f68:	2110      	movs	r1, #16
 8014f6a:	2002      	movs	r0, #2
 8014f6c:	f00a f914 	bl	801f198 <traceIF_itmPrint>
 8014f70:	4620      	mov	r0, r4
 8014f72:	f00a f8ce 	bl	801f112 <crs_strlen>
 8014f76:	b283      	uxth	r3, r0
 8014f78:	4622      	mov	r2, r4
 8014f7a:	2110      	movs	r1, #16
 8014f7c:	2002      	movs	r0, #2
 8014f7e:	f00a f92d 	bl	801f1dc <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 8014f82:	2001      	movs	r0, #1
 8014f84:	e7e4      	b.n	8014f50 <SysCtrl_open_channel+0x14>
 8014f86:	bf00      	nop
 8014f88:	200035fc 	.word	0x200035fc
 8014f8c:	200048dc 	.word	0x200048dc
 8014f90:	08030d20 	.word	0x08030d20

08014f94 <SysCtrl_close_channel>:
  * @brief  SysCtrl_close_channel
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_close_channel(sysctrl_device_type_t device_type)
{
 8014f94:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8014f96:	0143      	lsls	r3, r0, #5
 8014f98:	4a11      	ldr	r2, [pc, #68]	; (8014fe0 <SysCtrl_close_channel+0x4c>)
 8014f9a:	5cd3      	ldrb	r3, [r2, r3]
 8014f9c:	2b01      	cmp	r3, #1
 8014f9e:	d104      	bne.n	8014faa <SysCtrl_close_channel+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_close_channel)(device_type);
 8014fa0:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8014fa4:	68db      	ldr	r3, [r3, #12]
 8014fa6:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8014fa8:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 8014faa:	4c0e      	ldr	r4, [pc, #56]	; (8014fe4 <SysCtrl_close_channel+0x50>)
 8014fac:	4602      	mov	r2, r0
 8014fae:	490e      	ldr	r1, [pc, #56]	; (8014fe8 <SysCtrl_close_channel+0x54>)
 8014fb0:	4620      	mov	r0, r4
 8014fb2:	f010 fe5d 	bl	8025c70 <sprintf>
 8014fb6:	4620      	mov	r0, r4
 8014fb8:	f00a f8ab 	bl	801f112 <crs_strlen>
 8014fbc:	b283      	uxth	r3, r0
 8014fbe:	4622      	mov	r2, r4
 8014fc0:	2110      	movs	r1, #16
 8014fc2:	2002      	movs	r0, #2
 8014fc4:	f00a f8e8 	bl	801f198 <traceIF_itmPrint>
 8014fc8:	4620      	mov	r0, r4
 8014fca:	f00a f8a2 	bl	801f112 <crs_strlen>
 8014fce:	b283      	uxth	r3, r0
 8014fd0:	4622      	mov	r2, r4
 8014fd2:	2110      	movs	r1, #16
 8014fd4:	2002      	movs	r0, #2
 8014fd6:	f00a f901 	bl	801f1dc <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 8014fda:	2001      	movs	r0, #1
 8014fdc:	e7e4      	b.n	8014fa8 <SysCtrl_close_channel+0x14>
 8014fde:	bf00      	nop
 8014fe0:	200035fc 	.word	0x200035fc
 8014fe4:	200048dc 	.word	0x200048dc
 8014fe8:	08030d20 	.word	0x08030d20

08014fec <SysCtrl_power_on>:
  * @brief  SysCtrl_power_on
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_power_on(sysctrl_device_type_t device_type)
{
 8014fec:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8014fee:	0143      	lsls	r3, r0, #5
 8014ff0:	4a11      	ldr	r2, [pc, #68]	; (8015038 <SysCtrl_power_on+0x4c>)
 8014ff2:	5cd3      	ldrb	r3, [r2, r3]
 8014ff4:	2b01      	cmp	r3, #1
 8014ff6:	d104      	bne.n	8015002 <SysCtrl_power_on+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_power_on)(device_type);
 8014ff8:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8014ffc:	691b      	ldr	r3, [r3, #16]
 8014ffe:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8015000:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 8015002:	4c0e      	ldr	r4, [pc, #56]	; (801503c <SysCtrl_power_on+0x50>)
 8015004:	4602      	mov	r2, r0
 8015006:	490e      	ldr	r1, [pc, #56]	; (8015040 <SysCtrl_power_on+0x54>)
 8015008:	4620      	mov	r0, r4
 801500a:	f010 fe31 	bl	8025c70 <sprintf>
 801500e:	4620      	mov	r0, r4
 8015010:	f00a f87f 	bl	801f112 <crs_strlen>
 8015014:	b283      	uxth	r3, r0
 8015016:	4622      	mov	r2, r4
 8015018:	2110      	movs	r1, #16
 801501a:	2002      	movs	r0, #2
 801501c:	f00a f8bc 	bl	801f198 <traceIF_itmPrint>
 8015020:	4620      	mov	r0, r4
 8015022:	f00a f876 	bl	801f112 <crs_strlen>
 8015026:	b283      	uxth	r3, r0
 8015028:	4622      	mov	r2, r4
 801502a:	2110      	movs	r1, #16
 801502c:	2002      	movs	r0, #2
 801502e:	f00a f8d5 	bl	801f1dc <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 8015032:	2001      	movs	r0, #1
 8015034:	e7e4      	b.n	8015000 <SysCtrl_power_on+0x14>
 8015036:	bf00      	nop
 8015038:	200035fc 	.word	0x200035fc
 801503c:	200048dc 	.word	0x200048dc
 8015040:	08030d20 	.word	0x08030d20

08015044 <SysCtrl_power_off>:
  * @brief  SysCtrl_power_off
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_power_off(sysctrl_device_type_t device_type)
{
 8015044:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8015046:	0143      	lsls	r3, r0, #5
 8015048:	4a11      	ldr	r2, [pc, #68]	; (8015090 <SysCtrl_power_off+0x4c>)
 801504a:	5cd3      	ldrb	r3, [r2, r3]
 801504c:	2b01      	cmp	r3, #1
 801504e:	d104      	bne.n	801505a <SysCtrl_power_off+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_power_off)(device_type);
 8015050:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8015054:	695b      	ldr	r3, [r3, #20]
 8015056:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8015058:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 801505a:	4c0e      	ldr	r4, [pc, #56]	; (8015094 <SysCtrl_power_off+0x50>)
 801505c:	4602      	mov	r2, r0
 801505e:	490e      	ldr	r1, [pc, #56]	; (8015098 <SysCtrl_power_off+0x54>)
 8015060:	4620      	mov	r0, r4
 8015062:	f010 fe05 	bl	8025c70 <sprintf>
 8015066:	4620      	mov	r0, r4
 8015068:	f00a f853 	bl	801f112 <crs_strlen>
 801506c:	b283      	uxth	r3, r0
 801506e:	4622      	mov	r2, r4
 8015070:	2110      	movs	r1, #16
 8015072:	2002      	movs	r0, #2
 8015074:	f00a f890 	bl	801f198 <traceIF_itmPrint>
 8015078:	4620      	mov	r0, r4
 801507a:	f00a f84a 	bl	801f112 <crs_strlen>
 801507e:	b283      	uxth	r3, r0
 8015080:	4622      	mov	r2, r4
 8015082:	2110      	movs	r1, #16
 8015084:	2002      	movs	r0, #2
 8015086:	f00a f8a9 	bl	801f1dc <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 801508a:	2001      	movs	r0, #1
 801508c:	e7e4      	b.n	8015058 <SysCtrl_power_off+0x14>
 801508e:	bf00      	nop
 8015090:	200035fc 	.word	0x200035fc
 8015094:	200048dc 	.word	0x200048dc
 8015098:	08030d20 	.word	0x08030d20

0801509c <SysCtrl_delay>:
  * @param  timeMs
  * @retval none
  */
void SysCtrl_delay(uint32_t timeMs)
{
  if (timeMs != 0U)
 801509c:	b900      	cbnz	r0, 80150a0 <SysCtrl_delay+0x4>
 801509e:	4770      	bx	lr
{
 80150a0:	b508      	push	{r3, lr}
  {
#if (RTOS_USED == 1)
    (void) rtosalDelay(timeMs);
 80150a2:	f009 ff8e 	bl	801efc2 <rtosalDelay>
#else
    HAL_Delay(timeMs);
#endif /* RTOS_USED */
  }
}
 80150a6:	bd08      	pop	{r3, pc}

080150a8 <CELLULAR_reset_context>:
}

static void CELLULAR_reset_context(void)
{
  /* init cs_ctxt_urc_subscription */
  cs_ctxt_urc_subscription.eps_network_registration = CELLULAR_FALSE;
 80150a8:	4a10      	ldr	r2, [pc, #64]	; (80150ec <CELLULAR_reset_context+0x44>)
 80150aa:	2300      	movs	r3, #0
 80150ac:	7013      	strb	r3, [r2, #0]
  cs_ctxt_urc_subscription.gprs_network_registration = CELLULAR_FALSE;
 80150ae:	7053      	strb	r3, [r2, #1]
  cs_ctxt_urc_subscription.cs_network_registration = CELLULAR_FALSE;
 80150b0:	7093      	strb	r3, [r2, #2]
  cs_ctxt_urc_subscription.eps_location_info = CELLULAR_FALSE;
 80150b2:	70d3      	strb	r3, [r2, #3]
  cs_ctxt_urc_subscription.gprs_location_info = CELLULAR_FALSE;
 80150b4:	7113      	strb	r3, [r2, #4]
  cs_ctxt_urc_subscription.cs_location_info = CELLULAR_FALSE;
 80150b6:	7153      	strb	r3, [r2, #5]
  cs_ctxt_urc_subscription.signal_quality = CELLULAR_FALSE;
 80150b8:	7193      	strb	r3, [r2, #6]
  cs_ctxt_urc_subscription.packet_domain_event = CELLULAR_FALSE;
 80150ba:	71d3      	strb	r3, [r2, #7]
  cs_ctxt_urc_subscription.ping_rsp = CELLULAR_FALSE;
 80150bc:	7213      	strb	r3, [r2, #8]

  /* init cs_ctxt_eps_location_info */
  cs_ctxt_eps_location_info.ci = 0U;
 80150be:	4a0c      	ldr	r2, [pc, #48]	; (80150f0 <CELLULAR_reset_context+0x48>)
 80150c0:	6013      	str	r3, [r2, #0]
  cs_ctxt_eps_location_info.lac = 0U;
 80150c2:	8093      	strh	r3, [r2, #4]
  cs_ctxt_eps_location_info.ci_updated = CELLULAR_FALSE;
 80150c4:	7193      	strb	r3, [r2, #6]
  cs_ctxt_eps_location_info.lac_updated = CELLULAR_FALSE;
 80150c6:	71d3      	strb	r3, [r2, #7]

  /* init cs_ctxt_gprs_location_info */
  cs_ctxt_gprs_location_info.ci = 0U;
 80150c8:	4a0a      	ldr	r2, [pc, #40]	; (80150f4 <CELLULAR_reset_context+0x4c>)
 80150ca:	6013      	str	r3, [r2, #0]
  cs_ctxt_gprs_location_info.lac = 0U;
 80150cc:	8093      	strh	r3, [r2, #4]
  cs_ctxt_gprs_location_info.ci_updated = CELLULAR_FALSE;
 80150ce:	7193      	strb	r3, [r2, #6]
  cs_ctxt_gprs_location_info.lac_updated = CELLULAR_FALSE;
 80150d0:	71d3      	strb	r3, [r2, #7]

  /* init cs_ctxt_cs_location_info */
  cs_ctxt_cs_location_info.ci = 0U;
 80150d2:	4a09      	ldr	r2, [pc, #36]	; (80150f8 <CELLULAR_reset_context+0x50>)
 80150d4:	6013      	str	r3, [r2, #0]
  cs_ctxt_cs_location_info.lac = 0U;
 80150d6:	8093      	strh	r3, [r2, #4]
  cs_ctxt_cs_location_info.ci_updated = CELLULAR_FALSE;
 80150d8:	7193      	strb	r3, [r2, #6]
  cs_ctxt_cs_location_info.lac_updated = CELLULAR_FALSE;
 80150da:	71d3      	strb	r3, [r2, #7]

  /* init network states */
  cs_ctxt_eps_network_reg_state = CS_NRS_UNKNOWN;
 80150dc:	2304      	movs	r3, #4
 80150de:	4a07      	ldr	r2, [pc, #28]	; (80150fc <CELLULAR_reset_context+0x54>)
 80150e0:	8013      	strh	r3, [r2, #0]
  cs_ctxt_gprs_network_reg_state = CS_NRS_UNKNOWN;
 80150e2:	4a07      	ldr	r2, [pc, #28]	; (8015100 <CELLULAR_reset_context+0x58>)
 80150e4:	8013      	strh	r3, [r2, #0]
  cs_ctxt_cs_network_reg_state = CS_NRS_UNKNOWN;
 80150e6:	4a07      	ldr	r2, [pc, #28]	; (8015104 <CELLULAR_reset_context+0x5c>)
 80150e8:	8013      	strh	r3, [r2, #0]
}
 80150ea:	4770      	bx	lr
 80150ec:	20003804 	.word	0x20003804
 80150f0:	200037ac 	.word	0x200037ac
 80150f4:	200037b4 	.word	0x200037b4
 80150f8:	200036a0 	.word	0x200036a0
 80150fc:	20000042 	.word	0x20000042
 8015100:	20000044 	.word	0x20000044
 8015104:	20000040 	.word	0x20000040

08015108 <CELLULAR_idle_event_notif>:
  {
    /* inform client that an event has been received */
    (* register_event_callback)(eventReceived);
  }
#endif /* RTOS_USED */
}
 8015108:	4770      	bx	lr

0801510a <convert_SIM_error>:
static CS_Status_t convert_SIM_error(const csint_error_report_t *p_error_report)
{
  CS_Status_t retval;

  /* convert SIM state to Cellular Service error returned to the client */
  switch (p_error_report->sim_state)
 801510a:	7840      	ldrb	r0, [r0, #1]
 801510c:	1e83      	subs	r3, r0, #2
 801510e:	2b08      	cmp	r3, #8
 8015110:	d80e      	bhi.n	8015130 <convert_SIM_error+0x26>
 8015112:	e8df f003 	tbb	[pc, r3]
 8015116:	0e05      	.short	0x0e05
 8015118:	09090707 	.word	0x09090707
 801511c:	0909      	.short	0x0909
 801511e:	0b          	.byte	0x0b
 801511f:	00          	.byte	0x00
 8015120:	2004      	movs	r0, #4
 8015122:	4770      	bx	lr
    case CS_SIMSTATE_SIM_BUSY:
      retval = CELLULAR_SIM_BUSY;
      break;
    case CS_SIMSTATE_SIM_WRONG:
    case CS_SIMSTATE_SIM_FAILURE:
      retval = CELLULAR_SIM_ERROR;
 8015124:	2007      	movs	r0, #7
      break;
 8015126:	4770      	bx	lr
    case CS_SIMSTATE_SIM_PIN_REQUIRED:
    case CS_SIMSTATE_SIM_PIN2_REQUIRED:
    case CS_SIMSTATE_SIM_PUK_REQUIRED:
    case CS_SIMSTATE_SIM_PUK2_REQUIRED:
      retval = CELLULAR_SIM_PIN_OR_PUK_LOCKED;
 8015128:	2005      	movs	r0, #5
      break;
 801512a:	4770      	bx	lr
    case CS_SIMSTATE_INCORRECT_PASSWORD:
      retval = CELLULAR_SIM_INCORRECT_PASSWORD;
 801512c:	2006      	movs	r0, #6
      break;
 801512e:	4770      	bx	lr
    default:
      retval = CELLULAR_SIM_ERROR;
 8015130:	2007      	movs	r0, #7
      break;
  }
  return (retval);
}
 8015132:	4770      	bx	lr

08015134 <convert_to_PDN_event>:

static CS_PDN_event_t convert_to_PDN_event(csint_PDN_event_desc_t event_desc)
{
 8015134:	b082      	sub	sp, #8
 8015136:	9001      	str	r0, [sp, #4]
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;

  if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015138:	f89d 0004 	ldrb.w	r0, [sp, #4]
 801513c:	2801      	cmp	r0, #1
 801513e:	d006      	beq.n	801514e <convert_to_PDN_event+0x1a>
      (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
      (event_desc.event_type == CGEV_EVENT_TYPE_DETACH))
  {
    ret = CS_PDN_EVENT_NW_DETACH;
  }
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015140:	2801      	cmp	r0, #1
 8015142:	d00d      	beq.n	8015160 <convert_to_PDN_event+0x2c>
           (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
           (event_desc.event_type == CGEV_EVENT_TYPE_DEACTIVATION))
  {
    ret = CS_PDN_EVENT_NW_DEACT;
  }
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015144:	2801      	cmp	r0, #1
 8015146:	d015      	beq.n	8015174 <convert_to_PDN_event+0x40>
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;
 8015148:	2000      	movs	r0, #0
  {
    /* ignored */
  }

  return (ret);
}
 801514a:	b002      	add	sp, #8
 801514c:	4770      	bx	lr
      (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 801514e:	f89d 3005 	ldrb.w	r3, [sp, #5]
  if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015152:	2b0b      	cmp	r3, #11
 8015154:	d1f4      	bne.n	8015140 <convert_to_PDN_event+0xc>
      (event_desc.event_type == CGEV_EVENT_TYPE_DETACH))
 8015156:	f89d 3006 	ldrb.w	r3, [sp, #6]
      (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 801515a:	2b0f      	cmp	r3, #15
 801515c:	d1f0      	bne.n	8015140 <convert_to_PDN_event+0xc>
 801515e:	e7f4      	b.n	801514a <convert_to_PDN_event+0x16>
           (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 8015160:	f89d 3005 	ldrb.w	r3, [sp, #5]
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015164:	2b0b      	cmp	r3, #11
 8015166:	d1ed      	bne.n	8015144 <convert_to_PDN_event+0x10>
           (event_desc.event_type == CGEV_EVENT_TYPE_DEACTIVATION))
 8015168:	f89d 3006 	ldrb.w	r3, [sp, #6]
           (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 801516c:	2b0d      	cmp	r3, #13
 801516e:	d1e9      	bne.n	8015144 <convert_to_PDN_event+0x10>
    ret = CS_PDN_EVENT_NW_DEACT;
 8015170:	2002      	movs	r0, #2
 8015172:	e7ea      	b.n	801514a <convert_to_PDN_event+0x16>
           (event_desc.event_scope == CGEV_EVENT_SCOPE_PDN) &&
 8015174:	f89d 3005 	ldrb.w	r3, [sp, #5]
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015178:	2b0a      	cmp	r3, #10
 801517a:	d001      	beq.n	8015180 <convert_to_PDN_event+0x4c>
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;
 801517c:	2000      	movs	r0, #0
 801517e:	e7e4      	b.n	801514a <convert_to_PDN_event+0x16>
           (event_desc.event_type == CGEV_EVENT_TYPE_DEACTIVATION))
 8015180:	f89d 3006 	ldrb.w	r3, [sp, #6]
           (event_desc.event_scope == CGEV_EVENT_SCOPE_PDN) &&
 8015184:	2b0d      	cmp	r3, #13
 8015186:	d001      	beq.n	801518c <convert_to_PDN_event+0x58>
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;
 8015188:	2000      	movs	r0, #0
 801518a:	e7de      	b.n	801514a <convert_to_PDN_event+0x16>
    ret = CS_PDN_EVENT_NW_PDN_DEACT;
 801518c:	2003      	movs	r0, #3
 801518e:	e7dc      	b.n	801514a <convert_to_PDN_event+0x16>

08015190 <convert_index_to_PDN_conf>:

static CS_PDN_conf_id_t convert_index_to_PDN_conf(uint8_t index)
{
  CS_PDN_conf_id_t PDNconf;
  switch (index)
 8015190:	2805      	cmp	r0, #5
 8015192:	d804      	bhi.n	801519e <convert_index_to_PDN_conf+0xe>
 8015194:	e8df f000 	tbb	[pc, r0]
 8015198:	04040404 	.word	0x04040404
 801519c:	0404      	.short	0x0404
      break;
    case 5:
      PDNconf = CS_PDN_USER_CONFIG_5;
      break;
    default:
      PDNconf = CS_PDN_NOT_DEFINED;
 801519e:	200c      	movs	r0, #12
      break;
  }
  return (PDNconf);
}
 80151a0:	4770      	bx	lr
	...

080151a4 <CELLULAR_urc_notif>:
{
 80151a4:	b570      	push	{r4, r5, r6, lr}
 80151a6:	b0a4      	sub	sp, #144	; 0x90
 80151a8:	4606      	mov	r6, r0
  PRINT_API("<Cellular_Service> CELLULAR_urc_notif")
 80151aa:	4cbf      	ldr	r4, [pc, #764]	; (80154a8 <CELLULAR_urc_notif+0x304>)
 80151ac:	4dbf      	ldr	r5, [pc, #764]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80151ae:	f104 0e20 	add.w	lr, r4, #32
 80151b2:	46a4      	mov	ip, r4
 80151b4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80151b8:	6028      	str	r0, [r5, #0]
 80151ba:	6069      	str	r1, [r5, #4]
 80151bc:	60aa      	str	r2, [r5, #8]
 80151be:	60eb      	str	r3, [r5, #12]
 80151c0:	4664      	mov	r4, ip
 80151c2:	3510      	adds	r5, #16
 80151c4:	45f4      	cmp	ip, lr
 80151c6:	d1f4      	bne.n	80151b2 <CELLULAR_urc_notif+0xe>
 80151c8:	4663      	mov	r3, ip
 80151ca:	cb07      	ldmia	r3!, {r0, r1, r2}
 80151cc:	6028      	str	r0, [r5, #0]
 80151ce:	6069      	str	r1, [r5, #4]
 80151d0:	60aa      	str	r2, [r5, #8]
 80151d2:	881a      	ldrh	r2, [r3, #0]
 80151d4:	789b      	ldrb	r3, [r3, #2]
 80151d6:	81aa      	strh	r2, [r5, #12]
 80151d8:	73ab      	strb	r3, [r5, #14]
 80151da:	4cb4      	ldr	r4, [pc, #720]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80151dc:	4620      	mov	r0, r4
 80151de:	f009 ff98 	bl	801f112 <crs_strlen>
 80151e2:	b283      	uxth	r3, r0
 80151e4:	4622      	mov	r2, r4
 80151e6:	2104      	movs	r1, #4
 80151e8:	2001      	movs	r0, #1
 80151ea:	f009 ffd5 	bl	801f198 <traceIF_itmPrint>
 80151ee:	4620      	mov	r0, r4
 80151f0:	f009 ff8f 	bl	801f112 <crs_strlen>
 80151f4:	b283      	uxth	r3, r0
 80151f6:	4622      	mov	r2, r4
 80151f8:	2104      	movs	r1, #4
 80151fa:	2001      	movs	r0, #1
 80151fc:	f009 ffee 	bl	801f1dc <traceIF_uartPrint>
  msgtype = DATAPACK_readMsgType(p_rsp_buf);
 8015200:	4630      	mov	r0, r6
 8015202:	f7f6 ffc5 	bl	800c190 <DATAPACK_readMsgType>
  if ((msgtype == (uint16_t) CSMT_URC_EPS_NETWORK_REGISTRATION_STATUS) &&
 8015206:	2805      	cmp	r0, #5
 8015208:	d03a      	beq.n	8015280 <CELLULAR_urc_notif+0xdc>
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_NETWORK_REGISTRATION_STATUS) &&
 801520a:	2807      	cmp	r0, #7
 801520c:	f000 8093 	beq.w	8015336 <CELLULAR_urc_notif+0x192>
  else if ((msgtype == (uint16_t) CSMT_URC_CS_NETWORK_REGISTRATION_STATUS) &&
 8015210:	2809      	cmp	r0, #9
 8015212:	f000 80eb 	beq.w	80153ec <CELLULAR_urc_notif+0x248>
  else if ((msgtype == (uint16_t) CSMT_URC_EPS_LOCATION_INFO) &&
 8015216:	2806      	cmp	r0, #6
 8015218:	f000 8166 	beq.w	80154e8 <CELLULAR_urc_notif+0x344>
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_LOCATION_INFO) &&
 801521c:	2808      	cmp	r0, #8
 801521e:	f000 81ea 	beq.w	80155f6 <CELLULAR_urc_notif+0x452>
  else if ((msgtype == (uint16_t) CSMT_URC_CS_LOCATION_INFO) &&
 8015222:	280a      	cmp	r0, #10
 8015224:	f000 826b 	beq.w	80156fe <CELLULAR_urc_notif+0x55a>
  else if ((msgtype == (uint16_t) CSMT_URC_SIGNAL_QUALITY) &&
 8015228:	280b      	cmp	r0, #11
 801522a:	f000 8307 	beq.w	801583c <CELLULAR_urc_notif+0x698>
  else if (msgtype == (uint16_t) CSMT_URC_SOCKET_DATA_PENDING)
 801522e:	280d      	cmp	r0, #13
 8015230:	f000 8336 	beq.w	80158a0 <CELLULAR_urc_notif+0x6fc>
  else if (msgtype == (uint16_t) CSMT_URC_SOCKET_CLOSED)
 8015234:	280e      	cmp	r0, #14
 8015236:	f000 834b 	beq.w	80158d0 <CELLULAR_urc_notif+0x72c>
  else if ((msgtype == (uint16_t) CSMT_URC_PACKET_DOMAIN_EVENT) &&
 801523a:	280c      	cmp	r0, #12
 801523c:	f000 8360 	beq.w	8015900 <CELLULAR_urc_notif+0x75c>
  else if (msgtype == (uint16_t) CSMT_URC_PING_RSP)
 8015240:	2810      	cmp	r0, #16
 8015242:	f000 83d2 	beq.w	80159ea <CELLULAR_urc_notif+0x846>
  else if (msgtype == (uint16_t) CSMT_URC_MODEM_EVENT)
 8015246:	280f      	cmp	r0, #15
 8015248:	f000 8412 	beq.w	8015a70 <CELLULAR_urc_notif+0x8cc>
    PRINT_DBG("ignore received URC (type=%d)", msgtype)
 801524c:	4c97      	ldr	r4, [pc, #604]	; (80154ac <CELLULAR_urc_notif+0x308>)
 801524e:	4602      	mov	r2, r0
 8015250:	4997      	ldr	r1, [pc, #604]	; (80154b0 <CELLULAR_urc_notif+0x30c>)
 8015252:	4620      	mov	r0, r4
 8015254:	f010 fd0c 	bl	8025c70 <sprintf>
 8015258:	4620      	mov	r0, r4
 801525a:	f009 ff5a 	bl	801f112 <crs_strlen>
 801525e:	b283      	uxth	r3, r0
 8015260:	4622      	mov	r2, r4
 8015262:	2102      	movs	r1, #2
 8015264:	2001      	movs	r0, #1
 8015266:	f009 ff97 	bl	801f198 <traceIF_itmPrint>
 801526a:	4620      	mov	r0, r4
 801526c:	f009 ff51 	bl	801f112 <crs_strlen>
 8015270:	b283      	uxth	r3, r0
 8015272:	4622      	mov	r2, r4
 8015274:	2102      	movs	r1, #2
 8015276:	2001      	movs	r0, #1
 8015278:	f009 ffb0 	bl	801f1dc <traceIF_uartPrint>
}
 801527c:	b024      	add	sp, #144	; 0x90
 801527e:	bd70      	pop	{r4, r5, r6, pc}
      (cs_ctxt_urc_subscription.eps_network_registration == CELLULAR_TRUE))
 8015280:	4b8c      	ldr	r3, [pc, #560]	; (80154b4 <CELLULAR_urc_notif+0x310>)
 8015282:	781b      	ldrb	r3, [r3, #0]
  if ((msgtype == (uint16_t) CSMT_URC_EPS_NETWORK_REGISTRATION_STATUS) &&
 8015284:	2b01      	cmp	r3, #1
 8015286:	d1c0      	bne.n	801520a <CELLULAR_urc_notif+0x66>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015288:	ab10      	add	r3, sp, #64	; 0x40
 801528a:	2202      	movs	r2, #2
 801528c:	2105      	movs	r1, #5
 801528e:	4630      	mov	r0, r6
 8015290:	f7f7 f830 	bl	800c2f4 <DATAPACK_readStruct>
 8015294:	2800      	cmp	r0, #0
 8015296:	d1f1      	bne.n	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_state != cs_ctxt_eps_network_reg_state)
 8015298:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 801529c:	4b86      	ldr	r3, [pc, #536]	; (80154b8 <CELLULAR_urc_notif+0x314>)
 801529e:	881b      	ldrh	r3, [r3, #0]
 80152a0:	429a      	cmp	r2, r3
 80152a2:	d01f      	beq.n	80152e4 <CELLULAR_urc_notif+0x140>
        PRINT_DBG("<Cellular_Service> EPS network registration updated: %d", rx_state)
 80152a4:	4985      	ldr	r1, [pc, #532]	; (80154bc <CELLULAR_urc_notif+0x318>)
 80152a6:	4620      	mov	r0, r4
 80152a8:	f010 fce2 	bl	8025c70 <sprintf>
 80152ac:	4620      	mov	r0, r4
 80152ae:	f009 ff30 	bl	801f112 <crs_strlen>
 80152b2:	b283      	uxth	r3, r0
 80152b4:	4622      	mov	r2, r4
 80152b6:	2102      	movs	r1, #2
 80152b8:	2001      	movs	r0, #1
 80152ba:	f009 ff6d 	bl	801f198 <traceIF_itmPrint>
 80152be:	4620      	mov	r0, r4
 80152c0:	f009 ff27 	bl	801f112 <crs_strlen>
 80152c4:	b283      	uxth	r3, r0
 80152c6:	4622      	mov	r2, r4
 80152c8:	2102      	movs	r1, #2
 80152ca:	2001      	movs	r0, #1
 80152cc:	f009 ff86 	bl	801f1dc <traceIF_uartPrint>
        cs_ctxt_eps_network_reg_state = rx_state;
 80152d0:	4b79      	ldr	r3, [pc, #484]	; (80154b8 <CELLULAR_urc_notif+0x314>)
 80152d2:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 80152d6:	801a      	strh	r2, [r3, #0]
        if (urc_eps_network_registration_callback != NULL)
 80152d8:	4b79      	ldr	r3, [pc, #484]	; (80154c0 <CELLULAR_urc_notif+0x31c>)
 80152da:	681b      	ldr	r3, [r3, #0]
 80152dc:	2b00      	cmp	r3, #0
 80152de:	d0cd      	beq.n	801527c <CELLULAR_urc_notif+0xd8>
          (* urc_eps_network_registration_callback)();
 80152e0:	4798      	blx	r3
 80152e2:	e7cb      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_DBG("<Cellular_Service> EPS network registration unchanged")
 80152e4:	4d77      	ldr	r5, [pc, #476]	; (80154c4 <CELLULAR_urc_notif+0x320>)
 80152e6:	4c71      	ldr	r4, [pc, #452]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80152e8:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80152ec:	462e      	mov	r6, r5
 80152ee:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80152f0:	6020      	str	r0, [r4, #0]
 80152f2:	6061      	str	r1, [r4, #4]
 80152f4:	60a2      	str	r2, [r4, #8]
 80152f6:	60e3      	str	r3, [r4, #12]
 80152f8:	4635      	mov	r5, r6
 80152fa:	3410      	adds	r4, #16
 80152fc:	4566      	cmp	r6, ip
 80152fe:	d1f5      	bne.n	80152ec <CELLULAR_urc_notif+0x148>
 8015300:	cd03      	ldmia	r5!, {r0, r1}
 8015302:	6020      	str	r0, [r4, #0]
 8015304:	6061      	str	r1, [r4, #4]
 8015306:	882a      	ldrh	r2, [r5, #0]
 8015308:	78ab      	ldrb	r3, [r5, #2]
 801530a:	8122      	strh	r2, [r4, #8]
 801530c:	72a3      	strb	r3, [r4, #10]
 801530e:	4c67      	ldr	r4, [pc, #412]	; (80154ac <CELLULAR_urc_notif+0x308>)
 8015310:	4620      	mov	r0, r4
 8015312:	f009 fefe 	bl	801f112 <crs_strlen>
 8015316:	b283      	uxth	r3, r0
 8015318:	4622      	mov	r2, r4
 801531a:	2102      	movs	r1, #2
 801531c:	2001      	movs	r0, #1
 801531e:	f009 ff3b 	bl	801f198 <traceIF_itmPrint>
 8015322:	4620      	mov	r0, r4
 8015324:	f009 fef5 	bl	801f112 <crs_strlen>
 8015328:	b283      	uxth	r3, r0
 801532a:	4622      	mov	r2, r4
 801532c:	2102      	movs	r1, #2
 801532e:	2001      	movs	r0, #1
 8015330:	f009 ff54 	bl	801f1dc <traceIF_uartPrint>
  {
 8015334:	e7a2      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.gprs_network_registration == CELLULAR_TRUE))
 8015336:	4b5f      	ldr	r3, [pc, #380]	; (80154b4 <CELLULAR_urc_notif+0x310>)
 8015338:	785b      	ldrb	r3, [r3, #1]
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_NETWORK_REGISTRATION_STATUS) &&
 801533a:	2b01      	cmp	r3, #1
 801533c:	f47f af68 	bne.w	8015210 <CELLULAR_urc_notif+0x6c>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015340:	ab10      	add	r3, sp, #64	; 0x40
 8015342:	2202      	movs	r2, #2
 8015344:	2107      	movs	r1, #7
 8015346:	4630      	mov	r0, r6
 8015348:	f7f6 ffd4 	bl	800c2f4 <DATAPACK_readStruct>
 801534c:	2800      	cmp	r0, #0
 801534e:	d195      	bne.n	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_state != cs_ctxt_gprs_network_reg_state)
 8015350:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015354:	4b5c      	ldr	r3, [pc, #368]	; (80154c8 <CELLULAR_urc_notif+0x324>)
 8015356:	881b      	ldrh	r3, [r3, #0]
 8015358:	429a      	cmp	r2, r3
 801535a:	d021      	beq.n	80153a0 <CELLULAR_urc_notif+0x1fc>
        PRINT_DBG("<Cellular_Service> GPRS network registration updated: %d", rx_state)
 801535c:	4c53      	ldr	r4, [pc, #332]	; (80154ac <CELLULAR_urc_notif+0x308>)
 801535e:	495b      	ldr	r1, [pc, #364]	; (80154cc <CELLULAR_urc_notif+0x328>)
 8015360:	4620      	mov	r0, r4
 8015362:	f010 fc85 	bl	8025c70 <sprintf>
 8015366:	4620      	mov	r0, r4
 8015368:	f009 fed3 	bl	801f112 <crs_strlen>
 801536c:	b283      	uxth	r3, r0
 801536e:	4622      	mov	r2, r4
 8015370:	2102      	movs	r1, #2
 8015372:	2001      	movs	r0, #1
 8015374:	f009 ff10 	bl	801f198 <traceIF_itmPrint>
 8015378:	4620      	mov	r0, r4
 801537a:	f009 feca 	bl	801f112 <crs_strlen>
 801537e:	b283      	uxth	r3, r0
 8015380:	4622      	mov	r2, r4
 8015382:	2102      	movs	r1, #2
 8015384:	2001      	movs	r0, #1
 8015386:	f009 ff29 	bl	801f1dc <traceIF_uartPrint>
        cs_ctxt_gprs_network_reg_state = rx_state;
 801538a:	4b4f      	ldr	r3, [pc, #316]	; (80154c8 <CELLULAR_urc_notif+0x324>)
 801538c:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015390:	801a      	strh	r2, [r3, #0]
        if (urc_gprs_network_registration_callback != NULL)
 8015392:	4b4f      	ldr	r3, [pc, #316]	; (80154d0 <CELLULAR_urc_notif+0x32c>)
 8015394:	681b      	ldr	r3, [r3, #0]
 8015396:	2b00      	cmp	r3, #0
 8015398:	f43f af70 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* urc_gprs_network_registration_callback)();
 801539c:	4798      	blx	r3
 801539e:	e76d      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_DBG("<Cellular_Service> GPRS network registration unchanged")
 80153a0:	4d4c      	ldr	r5, [pc, #304]	; (80154d4 <CELLULAR_urc_notif+0x330>)
 80153a2:	4c42      	ldr	r4, [pc, #264]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80153a4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80153a8:	462e      	mov	r6, r5
 80153aa:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80153ac:	6020      	str	r0, [r4, #0]
 80153ae:	6061      	str	r1, [r4, #4]
 80153b0:	60a2      	str	r2, [r4, #8]
 80153b2:	60e3      	str	r3, [r4, #12]
 80153b4:	4635      	mov	r5, r6
 80153b6:	3410      	adds	r4, #16
 80153b8:	4566      	cmp	r6, ip
 80153ba:	d1f5      	bne.n	80153a8 <CELLULAR_urc_notif+0x204>
 80153bc:	cd07      	ldmia	r5!, {r0, r1, r2}
 80153be:	6020      	str	r0, [r4, #0]
 80153c0:	6061      	str	r1, [r4, #4]
 80153c2:	60a2      	str	r2, [r4, #8]
 80153c4:	4c39      	ldr	r4, [pc, #228]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80153c6:	4620      	mov	r0, r4
 80153c8:	f009 fea3 	bl	801f112 <crs_strlen>
 80153cc:	b283      	uxth	r3, r0
 80153ce:	4622      	mov	r2, r4
 80153d0:	2102      	movs	r1, #2
 80153d2:	2001      	movs	r0, #1
 80153d4:	f009 fee0 	bl	801f198 <traceIF_itmPrint>
 80153d8:	4620      	mov	r0, r4
 80153da:	f009 fe9a 	bl	801f112 <crs_strlen>
 80153de:	b283      	uxth	r3, r0
 80153e0:	4622      	mov	r2, r4
 80153e2:	2102      	movs	r1, #2
 80153e4:	2001      	movs	r0, #1
 80153e6:	f009 fef9 	bl	801f1dc <traceIF_uartPrint>
  {
 80153ea:	e747      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.cs_network_registration == CELLULAR_TRUE))
 80153ec:	4b31      	ldr	r3, [pc, #196]	; (80154b4 <CELLULAR_urc_notif+0x310>)
 80153ee:	789b      	ldrb	r3, [r3, #2]
  else if ((msgtype == (uint16_t) CSMT_URC_CS_NETWORK_REGISTRATION_STATUS) &&
 80153f0:	2b01      	cmp	r3, #1
 80153f2:	f47f af10 	bne.w	8015216 <CELLULAR_urc_notif+0x72>
    if (DATAPACK_readStruct(p_rsp_buf,
 80153f6:	ab10      	add	r3, sp, #64	; 0x40
 80153f8:	2202      	movs	r2, #2
 80153fa:	2109      	movs	r1, #9
 80153fc:	4630      	mov	r0, r6
 80153fe:	f7f6 ff79 	bl	800c2f4 <DATAPACK_readStruct>
 8015402:	2800      	cmp	r0, #0
 8015404:	f47f af3a 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_state != cs_ctxt_cs_network_reg_state)
 8015408:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 801540c:	4b32      	ldr	r3, [pc, #200]	; (80154d8 <CELLULAR_urc_notif+0x334>)
 801540e:	881b      	ldrh	r3, [r3, #0]
 8015410:	429a      	cmp	r2, r3
 8015412:	d021      	beq.n	8015458 <CELLULAR_urc_notif+0x2b4>
        PRINT_DBG("<Cellular_Service> CS network registration updated: %d", rx_state)
 8015414:	4c25      	ldr	r4, [pc, #148]	; (80154ac <CELLULAR_urc_notif+0x308>)
 8015416:	4931      	ldr	r1, [pc, #196]	; (80154dc <CELLULAR_urc_notif+0x338>)
 8015418:	4620      	mov	r0, r4
 801541a:	f010 fc29 	bl	8025c70 <sprintf>
 801541e:	4620      	mov	r0, r4
 8015420:	f009 fe77 	bl	801f112 <crs_strlen>
 8015424:	b283      	uxth	r3, r0
 8015426:	4622      	mov	r2, r4
 8015428:	2102      	movs	r1, #2
 801542a:	2001      	movs	r0, #1
 801542c:	f009 feb4 	bl	801f198 <traceIF_itmPrint>
 8015430:	4620      	mov	r0, r4
 8015432:	f009 fe6e 	bl	801f112 <crs_strlen>
 8015436:	b283      	uxth	r3, r0
 8015438:	4622      	mov	r2, r4
 801543a:	2102      	movs	r1, #2
 801543c:	2001      	movs	r0, #1
 801543e:	f009 fecd 	bl	801f1dc <traceIF_uartPrint>
        cs_ctxt_cs_network_reg_state = rx_state;
 8015442:	4b25      	ldr	r3, [pc, #148]	; (80154d8 <CELLULAR_urc_notif+0x334>)
 8015444:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015448:	801a      	strh	r2, [r3, #0]
        if (urc_cs_network_registration_callback != NULL)
 801544a:	4b25      	ldr	r3, [pc, #148]	; (80154e0 <CELLULAR_urc_notif+0x33c>)
 801544c:	681b      	ldr	r3, [r3, #0]
 801544e:	2b00      	cmp	r3, #0
 8015450:	f43f af14 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* urc_cs_network_registration_callback)();
 8015454:	4798      	blx	r3
 8015456:	e711      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_DBG("<Cellular_Service> CS network registration unchanged")
 8015458:	4d22      	ldr	r5, [pc, #136]	; (80154e4 <CELLULAR_urc_notif+0x340>)
 801545a:	4c14      	ldr	r4, [pc, #80]	; (80154ac <CELLULAR_urc_notif+0x308>)
 801545c:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8015460:	462e      	mov	r6, r5
 8015462:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015464:	6020      	str	r0, [r4, #0]
 8015466:	6061      	str	r1, [r4, #4]
 8015468:	60a2      	str	r2, [r4, #8]
 801546a:	60e3      	str	r3, [r4, #12]
 801546c:	4635      	mov	r5, r6
 801546e:	3410      	adds	r4, #16
 8015470:	4566      	cmp	r6, ip
 8015472:	d1f5      	bne.n	8015460 <CELLULAR_urc_notif+0x2bc>
 8015474:	cd03      	ldmia	r5!, {r0, r1}
 8015476:	6020      	str	r0, [r4, #0]
 8015478:	6061      	str	r1, [r4, #4]
 801547a:	882b      	ldrh	r3, [r5, #0]
 801547c:	8123      	strh	r3, [r4, #8]
 801547e:	4c0b      	ldr	r4, [pc, #44]	; (80154ac <CELLULAR_urc_notif+0x308>)
 8015480:	4620      	mov	r0, r4
 8015482:	f009 fe46 	bl	801f112 <crs_strlen>
 8015486:	b283      	uxth	r3, r0
 8015488:	4622      	mov	r2, r4
 801548a:	2102      	movs	r1, #2
 801548c:	2001      	movs	r0, #1
 801548e:	f009 fe83 	bl	801f198 <traceIF_itmPrint>
 8015492:	4620      	mov	r0, r4
 8015494:	f009 fe3d 	bl	801f112 <crs_strlen>
 8015498:	b283      	uxth	r3, r0
 801549a:	4622      	mov	r2, r4
 801549c:	2102      	movs	r1, #2
 801549e:	2001      	movs	r0, #1
 80154a0:	f009 fe9c 	bl	801f1dc <traceIF_uartPrint>
  {
 80154a4:	e6ea      	b.n	801527c <CELLULAR_urc_notif+0xd8>
 80154a6:	bf00      	nop
 80154a8:	08030d54 	.word	0x08030d54
 80154ac:	200047dc 	.word	0x200047dc
 80154b0:	0803117c 	.word	0x0803117c
 80154b4:	20003804 	.word	0x20003804
 80154b8:	20000042 	.word	0x20000042
 80154bc:	08030d84 	.word	0x08030d84
 80154c0:	200038a0 	.word	0x200038a0
 80154c4:	08030dc4 	.word	0x08030dc4
 80154c8:	20000044 	.word	0x20000044
 80154cc:	08030e00 	.word	0x08030e00
 80154d0:	200038a8 	.word	0x200038a8
 80154d4:	08030e40 	.word	0x08030e40
 80154d8:	20000040 	.word	0x20000040
 80154dc:	08030e7c 	.word	0x08030e7c
 80154e0:	20003898 	.word	0x20003898
 80154e4:	08030eb8 	.word	0x08030eb8
           (cs_ctxt_urc_subscription.eps_location_info == CELLULAR_TRUE))
 80154e8:	4bab      	ldr	r3, [pc, #684]	; (8015798 <CELLULAR_urc_notif+0x5f4>)
 80154ea:	78db      	ldrb	r3, [r3, #3]
  else if ((msgtype == (uint16_t) CSMT_URC_EPS_LOCATION_INFO) &&
 80154ec:	2b01      	cmp	r3, #1
 80154ee:	f47f ae95 	bne.w	801521c <CELLULAR_urc_notif+0x78>
    if (DATAPACK_readStruct(p_rsp_buf,
 80154f2:	ab10      	add	r3, sp, #64	; 0x40
 80154f4:	2208      	movs	r2, #8
 80154f6:	2106      	movs	r1, #6
 80154f8:	4630      	mov	r0, r6
 80154fa:	f7f6 fefb 	bl	800c2f4 <DATAPACK_readStruct>
 80154fe:	4603      	mov	r3, r0
 8015500:	2800      	cmp	r0, #0
 8015502:	f47f aebb 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_loc.ci_updated == CELLULAR_TRUE)
 8015506:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
 801550a:	2a01      	cmp	r2, #1
 801550c:	d028      	beq.n	8015560 <CELLULAR_urc_notif+0x3bc>
      if (rx_loc.lac_updated == CELLULAR_TRUE)
 801550e:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 8015512:	2a01      	cmp	r2, #1
 8015514:	d035      	beq.n	8015582 <CELLULAR_urc_notif+0x3de>
      if (loc_update == CELLULAR_TRUE)
 8015516:	2b01      	cmp	r3, #1
 8015518:	d144      	bne.n	80155a4 <CELLULAR_urc_notif+0x400>
        if (urc_eps_location_info_callback != NULL)
 801551a:	4ba0      	ldr	r3, [pc, #640]	; (801579c <CELLULAR_urc_notif+0x5f8>)
 801551c:	681b      	ldr	r3, [r3, #0]
 801551e:	2b00      	cmp	r3, #0
 8015520:	f43f aeac 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          PRINT_DBG("<Cellular_Service> EPS location information info updated: lac=%d, ci=%ld", rx_loc.lac, rx_loc.ci)
 8015524:	4c9e      	ldr	r4, [pc, #632]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 8015526:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8015528:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 801552c:	499d      	ldr	r1, [pc, #628]	; (80157a4 <CELLULAR_urc_notif+0x600>)
 801552e:	4620      	mov	r0, r4
 8015530:	f010 fb9e 	bl	8025c70 <sprintf>
 8015534:	4620      	mov	r0, r4
 8015536:	f009 fdec 	bl	801f112 <crs_strlen>
 801553a:	b283      	uxth	r3, r0
 801553c:	4622      	mov	r2, r4
 801553e:	2102      	movs	r1, #2
 8015540:	2001      	movs	r0, #1
 8015542:	f009 fe29 	bl	801f198 <traceIF_itmPrint>
 8015546:	4620      	mov	r0, r4
 8015548:	f009 fde3 	bl	801f112 <crs_strlen>
 801554c:	b283      	uxth	r3, r0
 801554e:	4622      	mov	r2, r4
 8015550:	2102      	movs	r1, #2
 8015552:	2001      	movs	r0, #1
 8015554:	f009 fe42 	bl	801f1dc <traceIF_uartPrint>
          (* urc_eps_location_info_callback)();
 8015558:	4b90      	ldr	r3, [pc, #576]	; (801579c <CELLULAR_urc_notif+0x5f8>)
 801555a:	681b      	ldr	r3, [r3, #0]
 801555c:	4798      	blx	r3
 801555e:	e68d      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        if (rx_loc.ci != cs_ctxt_eps_location_info.ci)
 8015560:	9910      	ldr	r1, [sp, #64]	; 0x40
 8015562:	4891      	ldr	r0, [pc, #580]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015564:	6800      	ldr	r0, [r0, #0]
 8015566:	4281      	cmp	r1, r0
 8015568:	d002      	beq.n	8015570 <CELLULAR_urc_notif+0x3cc>
          cs_ctxt_eps_location_info.ci = rx_loc.ci;
 801556a:	4b8f      	ldr	r3, [pc, #572]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 801556c:	6019      	str	r1, [r3, #0]
          loc_update = CELLULAR_TRUE;
 801556e:	4613      	mov	r3, r2
        if (cs_ctxt_eps_location_info.ci_updated == CELLULAR_FALSE)
 8015570:	498d      	ldr	r1, [pc, #564]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015572:	7989      	ldrb	r1, [r1, #6]
 8015574:	2900      	cmp	r1, #0
 8015576:	d1ca      	bne.n	801550e <CELLULAR_urc_notif+0x36a>
          cs_ctxt_eps_location_info.ci_updated = CELLULAR_TRUE;
 8015578:	4b8b      	ldr	r3, [pc, #556]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 801557a:	2101      	movs	r1, #1
 801557c:	7199      	strb	r1, [r3, #6]
          loc_update = CELLULAR_TRUE;
 801557e:	4613      	mov	r3, r2
 8015580:	e7c5      	b.n	801550e <CELLULAR_urc_notif+0x36a>
        if (rx_loc.lac != cs_ctxt_eps_location_info.lac)
 8015582:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
 8015586:	4888      	ldr	r0, [pc, #544]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015588:	8880      	ldrh	r0, [r0, #4]
 801558a:	4281      	cmp	r1, r0
 801558c:	d002      	beq.n	8015594 <CELLULAR_urc_notif+0x3f0>
          cs_ctxt_eps_location_info.lac = rx_loc.lac;
 801558e:	4b86      	ldr	r3, [pc, #536]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015590:	8099      	strh	r1, [r3, #4]
          loc_update = CELLULAR_TRUE;
 8015592:	4613      	mov	r3, r2
        if (cs_ctxt_eps_location_info.lac_updated == CELLULAR_FALSE)
 8015594:	4a84      	ldr	r2, [pc, #528]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015596:	79d2      	ldrb	r2, [r2, #7]
 8015598:	2a00      	cmp	r2, #0
 801559a:	d1bc      	bne.n	8015516 <CELLULAR_urc_notif+0x372>
          cs_ctxt_eps_location_info.lac_updated = CELLULAR_TRUE;
 801559c:	4b82      	ldr	r3, [pc, #520]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 801559e:	2201      	movs	r2, #1
 80155a0:	71da      	strb	r2, [r3, #7]
      if (loc_update == CELLULAR_TRUE)
 80155a2:	e7ba      	b.n	801551a <CELLULAR_urc_notif+0x376>
        PRINT_DBG("<Cellular_Service> EPS location information unchanged")
 80155a4:	4d81      	ldr	r5, [pc, #516]	; (80157ac <CELLULAR_urc_notif+0x608>)
 80155a6:	4c7e      	ldr	r4, [pc, #504]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80155a8:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80155ac:	462e      	mov	r6, r5
 80155ae:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80155b0:	6020      	str	r0, [r4, #0]
 80155b2:	6061      	str	r1, [r4, #4]
 80155b4:	60a2      	str	r2, [r4, #8]
 80155b6:	60e3      	str	r3, [r4, #12]
 80155b8:	4635      	mov	r5, r6
 80155ba:	3410      	adds	r4, #16
 80155bc:	4566      	cmp	r6, ip
 80155be:	d1f5      	bne.n	80155ac <CELLULAR_urc_notif+0x408>
 80155c0:	cd03      	ldmia	r5!, {r0, r1}
 80155c2:	6020      	str	r0, [r4, #0]
 80155c4:	6061      	str	r1, [r4, #4]
 80155c6:	882a      	ldrh	r2, [r5, #0]
 80155c8:	78ab      	ldrb	r3, [r5, #2]
 80155ca:	8122      	strh	r2, [r4, #8]
 80155cc:	72a3      	strb	r3, [r4, #10]
 80155ce:	4c74      	ldr	r4, [pc, #464]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80155d0:	4620      	mov	r0, r4
 80155d2:	f009 fd9e 	bl	801f112 <crs_strlen>
 80155d6:	b283      	uxth	r3, r0
 80155d8:	4622      	mov	r2, r4
 80155da:	2102      	movs	r1, #2
 80155dc:	2001      	movs	r0, #1
 80155de:	f009 fddb 	bl	801f198 <traceIF_itmPrint>
 80155e2:	4620      	mov	r0, r4
 80155e4:	f009 fd95 	bl	801f112 <crs_strlen>
 80155e8:	b283      	uxth	r3, r0
 80155ea:	4622      	mov	r2, r4
 80155ec:	2102      	movs	r1, #2
 80155ee:	2001      	movs	r0, #1
 80155f0:	f009 fdf4 	bl	801f1dc <traceIF_uartPrint>
  {
 80155f4:	e642      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.gprs_location_info == CELLULAR_TRUE))
 80155f6:	4b68      	ldr	r3, [pc, #416]	; (8015798 <CELLULAR_urc_notif+0x5f4>)
 80155f8:	791b      	ldrb	r3, [r3, #4]
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_LOCATION_INFO) &&
 80155fa:	2b01      	cmp	r3, #1
 80155fc:	f47f ae11 	bne.w	8015222 <CELLULAR_urc_notif+0x7e>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015600:	ab10      	add	r3, sp, #64	; 0x40
 8015602:	2208      	movs	r2, #8
 8015604:	4611      	mov	r1, r2
 8015606:	4630      	mov	r0, r6
 8015608:	f7f6 fe74 	bl	800c2f4 <DATAPACK_readStruct>
 801560c:	4603      	mov	r3, r0
 801560e:	2800      	cmp	r0, #0
 8015610:	f47f ae34 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_loc.ci_updated == CELLULAR_TRUE)
 8015614:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
 8015618:	2a01      	cmp	r2, #1
 801561a:	d028      	beq.n	801566e <CELLULAR_urc_notif+0x4ca>
      if (rx_loc.lac_updated == CELLULAR_TRUE)
 801561c:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 8015620:	2a01      	cmp	r2, #1
 8015622:	d035      	beq.n	8015690 <CELLULAR_urc_notif+0x4ec>
      if (loc_update == CELLULAR_TRUE)
 8015624:	2b01      	cmp	r3, #1
 8015626:	d144      	bne.n	80156b2 <CELLULAR_urc_notif+0x50e>
        if (urc_gprs_location_info_callback != NULL)
 8015628:	4b61      	ldr	r3, [pc, #388]	; (80157b0 <CELLULAR_urc_notif+0x60c>)
 801562a:	681b      	ldr	r3, [r3, #0]
 801562c:	2b00      	cmp	r3, #0
 801562e:	f43f ae25 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          PRINT_DBG("<Cellular_Service> GPRS location information info updated: lac=%d, ci=%ld", rx_loc.lac, rx_loc.ci)
 8015632:	4c5b      	ldr	r4, [pc, #364]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 8015634:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8015636:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 801563a:	495e      	ldr	r1, [pc, #376]	; (80157b4 <CELLULAR_urc_notif+0x610>)
 801563c:	4620      	mov	r0, r4
 801563e:	f010 fb17 	bl	8025c70 <sprintf>
 8015642:	4620      	mov	r0, r4
 8015644:	f009 fd65 	bl	801f112 <crs_strlen>
 8015648:	b283      	uxth	r3, r0
 801564a:	4622      	mov	r2, r4
 801564c:	2102      	movs	r1, #2
 801564e:	2001      	movs	r0, #1
 8015650:	f009 fda2 	bl	801f198 <traceIF_itmPrint>
 8015654:	4620      	mov	r0, r4
 8015656:	f009 fd5c 	bl	801f112 <crs_strlen>
 801565a:	b283      	uxth	r3, r0
 801565c:	4622      	mov	r2, r4
 801565e:	2102      	movs	r1, #2
 8015660:	2001      	movs	r0, #1
 8015662:	f009 fdbb 	bl	801f1dc <traceIF_uartPrint>
          (* urc_gprs_location_info_callback)();
 8015666:	4b52      	ldr	r3, [pc, #328]	; (80157b0 <CELLULAR_urc_notif+0x60c>)
 8015668:	681b      	ldr	r3, [r3, #0]
 801566a:	4798      	blx	r3
 801566c:	e606      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        if (rx_loc.ci != cs_ctxt_gprs_location_info.ci)
 801566e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8015670:	4851      	ldr	r0, [pc, #324]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015672:	6800      	ldr	r0, [r0, #0]
 8015674:	4281      	cmp	r1, r0
 8015676:	d002      	beq.n	801567e <CELLULAR_urc_notif+0x4da>
          cs_ctxt_gprs_location_info.ci = rx_loc.ci;
 8015678:	4b4f      	ldr	r3, [pc, #316]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 801567a:	6019      	str	r1, [r3, #0]
          loc_update = CELLULAR_TRUE;
 801567c:	4613      	mov	r3, r2
        if (cs_ctxt_gprs_location_info.ci_updated == CELLULAR_FALSE)
 801567e:	494e      	ldr	r1, [pc, #312]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015680:	7989      	ldrb	r1, [r1, #6]
 8015682:	2900      	cmp	r1, #0
 8015684:	d1ca      	bne.n	801561c <CELLULAR_urc_notif+0x478>
          cs_ctxt_gprs_location_info.ci_updated = CELLULAR_TRUE;
 8015686:	4b4c      	ldr	r3, [pc, #304]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015688:	2101      	movs	r1, #1
 801568a:	7199      	strb	r1, [r3, #6]
          loc_update = CELLULAR_TRUE;
 801568c:	4613      	mov	r3, r2
 801568e:	e7c5      	b.n	801561c <CELLULAR_urc_notif+0x478>
        if (rx_loc.lac != cs_ctxt_gprs_location_info.lac)
 8015690:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
 8015694:	4848      	ldr	r0, [pc, #288]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015696:	8880      	ldrh	r0, [r0, #4]
 8015698:	4281      	cmp	r1, r0
 801569a:	d002      	beq.n	80156a2 <CELLULAR_urc_notif+0x4fe>
          cs_ctxt_gprs_location_info.lac = rx_loc.lac;
 801569c:	4b46      	ldr	r3, [pc, #280]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 801569e:	8099      	strh	r1, [r3, #4]
          loc_update = CELLULAR_TRUE;
 80156a0:	4613      	mov	r3, r2
        if (cs_ctxt_gprs_location_info.lac_updated == CELLULAR_FALSE)
 80156a2:	4a45      	ldr	r2, [pc, #276]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 80156a4:	79d2      	ldrb	r2, [r2, #7]
 80156a6:	2a00      	cmp	r2, #0
 80156a8:	d1bc      	bne.n	8015624 <CELLULAR_urc_notif+0x480>
          cs_ctxt_gprs_location_info.lac_updated = CELLULAR_TRUE;
 80156aa:	4b43      	ldr	r3, [pc, #268]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 80156ac:	2201      	movs	r2, #1
 80156ae:	71da      	strb	r2, [r3, #7]
      if (loc_update == CELLULAR_TRUE)
 80156b0:	e7ba      	b.n	8015628 <CELLULAR_urc_notif+0x484>
        PRINT_DBG("<Cellular_Service> GPRS location information unchanged")
 80156b2:	4e42      	ldr	r6, [pc, #264]	; (80157bc <CELLULAR_urc_notif+0x618>)
 80156b4:	4c3a      	ldr	r4, [pc, #232]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80156b6:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80156ba:	4635      	mov	r5, r6
 80156bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80156be:	6020      	str	r0, [r4, #0]
 80156c0:	6061      	str	r1, [r4, #4]
 80156c2:	60a2      	str	r2, [r4, #8]
 80156c4:	60e3      	str	r3, [r4, #12]
 80156c6:	462e      	mov	r6, r5
 80156c8:	3410      	adds	r4, #16
 80156ca:	4565      	cmp	r5, ip
 80156cc:	d1f5      	bne.n	80156ba <CELLULAR_urc_notif+0x516>
 80156ce:	ce07      	ldmia	r6!, {r0, r1, r2}
 80156d0:	6020      	str	r0, [r4, #0]
 80156d2:	6061      	str	r1, [r4, #4]
 80156d4:	60a2      	str	r2, [r4, #8]
 80156d6:	4c32      	ldr	r4, [pc, #200]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80156d8:	4620      	mov	r0, r4
 80156da:	f009 fd1a 	bl	801f112 <crs_strlen>
 80156de:	b283      	uxth	r3, r0
 80156e0:	4622      	mov	r2, r4
 80156e2:	2102      	movs	r1, #2
 80156e4:	2001      	movs	r0, #1
 80156e6:	f009 fd57 	bl	801f198 <traceIF_itmPrint>
 80156ea:	4620      	mov	r0, r4
 80156ec:	f009 fd11 	bl	801f112 <crs_strlen>
 80156f0:	b283      	uxth	r3, r0
 80156f2:	4622      	mov	r2, r4
 80156f4:	2102      	movs	r1, #2
 80156f6:	2001      	movs	r0, #1
 80156f8:	f009 fd70 	bl	801f1dc <traceIF_uartPrint>
  {
 80156fc:	e5be      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.cs_location_info == CELLULAR_TRUE))
 80156fe:	4b26      	ldr	r3, [pc, #152]	; (8015798 <CELLULAR_urc_notif+0x5f4>)
 8015700:	795b      	ldrb	r3, [r3, #5]
  else if ((msgtype == (uint16_t) CSMT_URC_CS_LOCATION_INFO) &&
 8015702:	2b01      	cmp	r3, #1
 8015704:	f47f ad90 	bne.w	8015228 <CELLULAR_urc_notif+0x84>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015708:	ab10      	add	r3, sp, #64	; 0x40
 801570a:	2208      	movs	r2, #8
 801570c:	210a      	movs	r1, #10
 801570e:	4630      	mov	r0, r6
 8015710:	f7f6 fdf0 	bl	800c2f4 <DATAPACK_readStruct>
 8015714:	4603      	mov	r3, r0
 8015716:	2800      	cmp	r0, #0
 8015718:	f47f adb0 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_loc.ci_updated == CELLULAR_TRUE)
 801571c:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
 8015720:	2a01      	cmp	r2, #1
 8015722:	d028      	beq.n	8015776 <CELLULAR_urc_notif+0x5d2>
      if (rx_loc.lac_updated == CELLULAR_TRUE)
 8015724:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 8015728:	2a01      	cmp	r2, #1
 801572a:	d04f      	beq.n	80157cc <CELLULAR_urc_notif+0x628>
      if (loc_update == CELLULAR_TRUE)
 801572c:	2b01      	cmp	r3, #1
 801572e:	d15e      	bne.n	80157ee <CELLULAR_urc_notif+0x64a>
        if (urc_cs_location_info_callback != NULL)
 8015730:	4b23      	ldr	r3, [pc, #140]	; (80157c0 <CELLULAR_urc_notif+0x61c>)
 8015732:	681b      	ldr	r3, [r3, #0]
 8015734:	2b00      	cmp	r3, #0
 8015736:	f43f ada1 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          PRINT_DBG("<Cellular_Service> CS location information info updated: lac=%d, ci=%ld", rx_loc.lac, rx_loc.ci)
 801573a:	4c19      	ldr	r4, [pc, #100]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 801573c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801573e:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 8015742:	4920      	ldr	r1, [pc, #128]	; (80157c4 <CELLULAR_urc_notif+0x620>)
 8015744:	4620      	mov	r0, r4
 8015746:	f010 fa93 	bl	8025c70 <sprintf>
 801574a:	4620      	mov	r0, r4
 801574c:	f009 fce1 	bl	801f112 <crs_strlen>
 8015750:	b283      	uxth	r3, r0
 8015752:	4622      	mov	r2, r4
 8015754:	2102      	movs	r1, #2
 8015756:	2001      	movs	r0, #1
 8015758:	f009 fd1e 	bl	801f198 <traceIF_itmPrint>
 801575c:	4620      	mov	r0, r4
 801575e:	f009 fcd8 	bl	801f112 <crs_strlen>
 8015762:	b283      	uxth	r3, r0
 8015764:	4622      	mov	r2, r4
 8015766:	2102      	movs	r1, #2
 8015768:	2001      	movs	r0, #1
 801576a:	f009 fd37 	bl	801f1dc <traceIF_uartPrint>
          (* urc_cs_location_info_callback)();
 801576e:	4b14      	ldr	r3, [pc, #80]	; (80157c0 <CELLULAR_urc_notif+0x61c>)
 8015770:	681b      	ldr	r3, [r3, #0]
 8015772:	4798      	blx	r3
 8015774:	e582      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        if (rx_loc.ci != cs_ctxt_cs_location_info.ci)
 8015776:	9910      	ldr	r1, [sp, #64]	; 0x40
 8015778:	4813      	ldr	r0, [pc, #76]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 801577a:	6800      	ldr	r0, [r0, #0]
 801577c:	4281      	cmp	r1, r0
 801577e:	d002      	beq.n	8015786 <CELLULAR_urc_notif+0x5e2>
          cs_ctxt_cs_location_info.ci = rx_loc.ci;
 8015780:	4b11      	ldr	r3, [pc, #68]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 8015782:	6019      	str	r1, [r3, #0]
          loc_update = CELLULAR_TRUE;
 8015784:	4613      	mov	r3, r2
        if (cs_ctxt_cs_location_info.ci_updated == CELLULAR_FALSE)
 8015786:	4910      	ldr	r1, [pc, #64]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 8015788:	7989      	ldrb	r1, [r1, #6]
 801578a:	2900      	cmp	r1, #0
 801578c:	d1ca      	bne.n	8015724 <CELLULAR_urc_notif+0x580>
          cs_ctxt_cs_location_info.ci_updated = CELLULAR_TRUE;
 801578e:	4b0e      	ldr	r3, [pc, #56]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 8015790:	2101      	movs	r1, #1
 8015792:	7199      	strb	r1, [r3, #6]
          loc_update = CELLULAR_TRUE;
 8015794:	4613      	mov	r3, r2
 8015796:	e7c5      	b.n	8015724 <CELLULAR_urc_notif+0x580>
 8015798:	20003804 	.word	0x20003804
 801579c:	2000389c 	.word	0x2000389c
 80157a0:	200047dc 	.word	0x200047dc
 80157a4:	08030ef4 	.word	0x08030ef4
 80157a8:	200037ac 	.word	0x200037ac
 80157ac:	08030f44 	.word	0x08030f44
 80157b0:	200038a4 	.word	0x200038a4
 80157b4:	08030f80 	.word	0x08030f80
 80157b8:	200037b4 	.word	0x200037b4
 80157bc:	08030fd0 	.word	0x08030fd0
 80157c0:	20003894 	.word	0x20003894
 80157c4:	0803100c 	.word	0x0803100c
 80157c8:	200036a0 	.word	0x200036a0
        if (rx_loc.lac != cs_ctxt_cs_location_info.lac)
 80157cc:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
 80157d0:	48bd      	ldr	r0, [pc, #756]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157d2:	8880      	ldrh	r0, [r0, #4]
 80157d4:	4281      	cmp	r1, r0
 80157d6:	d002      	beq.n	80157de <CELLULAR_urc_notif+0x63a>
          cs_ctxt_cs_location_info.lac = rx_loc.lac;
 80157d8:	4bbb      	ldr	r3, [pc, #748]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157da:	8099      	strh	r1, [r3, #4]
          loc_update = CELLULAR_TRUE;
 80157dc:	4613      	mov	r3, r2
        if (cs_ctxt_cs_location_info.lac_updated == CELLULAR_FALSE)
 80157de:	4aba      	ldr	r2, [pc, #744]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157e0:	79d2      	ldrb	r2, [r2, #7]
 80157e2:	2a00      	cmp	r2, #0
 80157e4:	d1a2      	bne.n	801572c <CELLULAR_urc_notif+0x588>
          cs_ctxt_cs_location_info.lac_updated = CELLULAR_TRUE;
 80157e6:	4bb8      	ldr	r3, [pc, #736]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157e8:	2201      	movs	r2, #1
 80157ea:	71da      	strb	r2, [r3, #7]
      if (loc_update == CELLULAR_TRUE)
 80157ec:	e7a0      	b.n	8015730 <CELLULAR_urc_notif+0x58c>
        PRINT_DBG("<Cellular_Service> CS location information unchanged")
 80157ee:	4db7      	ldr	r5, [pc, #732]	; (8015acc <CELLULAR_urc_notif+0x928>)
 80157f0:	4cb7      	ldr	r4, [pc, #732]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 80157f2:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80157f6:	462e      	mov	r6, r5
 80157f8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80157fa:	6020      	str	r0, [r4, #0]
 80157fc:	6061      	str	r1, [r4, #4]
 80157fe:	60a2      	str	r2, [r4, #8]
 8015800:	60e3      	str	r3, [r4, #12]
 8015802:	4635      	mov	r5, r6
 8015804:	3410      	adds	r4, #16
 8015806:	4566      	cmp	r6, ip
 8015808:	d1f5      	bne.n	80157f6 <CELLULAR_urc_notif+0x652>
 801580a:	cd03      	ldmia	r5!, {r0, r1}
 801580c:	6020      	str	r0, [r4, #0]
 801580e:	6061      	str	r1, [r4, #4]
 8015810:	882b      	ldrh	r3, [r5, #0]
 8015812:	8123      	strh	r3, [r4, #8]
 8015814:	4cae      	ldr	r4, [pc, #696]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015816:	4620      	mov	r0, r4
 8015818:	f009 fc7b 	bl	801f112 <crs_strlen>
 801581c:	b283      	uxth	r3, r0
 801581e:	4622      	mov	r2, r4
 8015820:	2102      	movs	r1, #2
 8015822:	2001      	movs	r0, #1
 8015824:	f009 fcb8 	bl	801f198 <traceIF_itmPrint>
 8015828:	4620      	mov	r0, r4
 801582a:	f009 fc72 	bl	801f112 <crs_strlen>
 801582e:	b283      	uxth	r3, r0
 8015830:	4622      	mov	r2, r4
 8015832:	2102      	movs	r1, #2
 8015834:	2001      	movs	r0, #1
 8015836:	f009 fcd1 	bl	801f1dc <traceIF_uartPrint>
  {
 801583a:	e51f      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.signal_quality == CELLULAR_TRUE))
 801583c:	4ba5      	ldr	r3, [pc, #660]	; (8015ad4 <CELLULAR_urc_notif+0x930>)
 801583e:	799b      	ldrb	r3, [r3, #6]
  else if ((msgtype == (uint16_t) CSMT_URC_SIGNAL_QUALITY) &&
 8015840:	2b01      	cmp	r3, #1
 8015842:	f47f acf4 	bne.w	801522e <CELLULAR_urc_notif+0x8a>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015846:	ab10      	add	r3, sp, #64	; 0x40
 8015848:	2202      	movs	r2, #2
 801584a:	210b      	movs	r1, #11
 801584c:	4630      	mov	r0, r6
 801584e:	f7f6 fd51 	bl	800c2f4 <DATAPACK_readStruct>
 8015852:	2800      	cmp	r0, #0
 8015854:	f47f ad12 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (urc_signal_quality_callback != NULL)
 8015858:	4b9f      	ldr	r3, [pc, #636]	; (8015ad8 <CELLULAR_urc_notif+0x934>)
 801585a:	681b      	ldr	r3, [r3, #0]
 801585c:	2b00      	cmp	r3, #0
 801585e:	f43f ad0d 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_INFO("<Cellular_Service> CS signal quality info updated: rssi=%d, ber=%d", local_sig_qual.rssi,
 8015862:	4c9b      	ldr	r4, [pc, #620]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015864:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 8015868:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 801586c:	499b      	ldr	r1, [pc, #620]	; (8015adc <CELLULAR_urc_notif+0x938>)
 801586e:	4620      	mov	r0, r4
 8015870:	f010 f9fe 	bl	8025c70 <sprintf>
 8015874:	4620      	mov	r0, r4
 8015876:	f009 fc4c 	bl	801f112 <crs_strlen>
 801587a:	b283      	uxth	r3, r0
 801587c:	4622      	mov	r2, r4
 801587e:	2101      	movs	r1, #1
 8015880:	4608      	mov	r0, r1
 8015882:	f009 fc89 	bl	801f198 <traceIF_itmPrint>
 8015886:	4620      	mov	r0, r4
 8015888:	f009 fc43 	bl	801f112 <crs_strlen>
 801588c:	b283      	uxth	r3, r0
 801588e:	4622      	mov	r2, r4
 8015890:	2101      	movs	r1, #1
 8015892:	4608      	mov	r0, r1
 8015894:	f009 fca2 	bl	801f1dc <traceIF_uartPrint>
        (* urc_signal_quality_callback)();
 8015898:	4b8f      	ldr	r3, [pc, #572]	; (8015ad8 <CELLULAR_urc_notif+0x934>)
 801589a:	681b      	ldr	r3, [r3, #0]
 801589c:	4798      	blx	r3
  {
 801589e:	e4ed      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 80158a0:	ab10      	add	r3, sp, #64	; 0x40
 80158a2:	2204      	movs	r2, #4
 80158a4:	210d      	movs	r1, #13
 80158a6:	4630      	mov	r0, r6
 80158a8:	f7f6 fd24 	bl	800c2f4 <DATAPACK_readStruct>
 80158ac:	2800      	cmp	r0, #0
 80158ae:	f47f ace5 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 80158b2:	9810      	ldr	r0, [sp, #64]	; 0x40
 80158b4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80158b8:	f43f ace0 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        if (cs_ctxt_sockets_info[sockHandle].socket_data_ready_callback != NULL)
 80158bc:	4b88      	ldr	r3, [pc, #544]	; (8015ae0 <CELLULAR_urc_notif+0x93c>)
 80158be:	226c      	movs	r2, #108	; 0x6c
 80158c0:	fb02 3300 	mla	r3, r2, r0, r3
 80158c4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80158c6:	2b00      	cmp	r3, #0
 80158c8:	f43f acd8 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* cs_ctxt_sockets_info[sockHandle].socket_data_ready_callback)(sockHandle);
 80158cc:	4798      	blx	r3
 80158ce:	e4d5      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 80158d0:	ab10      	add	r3, sp, #64	; 0x40
 80158d2:	2204      	movs	r2, #4
 80158d4:	210e      	movs	r1, #14
 80158d6:	4630      	mov	r0, r6
 80158d8:	f7f6 fd0c 	bl	800c2f4 <DATAPACK_readStruct>
 80158dc:	2800      	cmp	r0, #0
 80158de:	f47f accd 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 80158e2:	9810      	ldr	r0, [sp, #64]	; 0x40
 80158e4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80158e8:	f43f acc8 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        if (cs_ctxt_sockets_info[sockHandle].socket_remote_close_callback != NULL)
 80158ec:	4b7c      	ldr	r3, [pc, #496]	; (8015ae0 <CELLULAR_urc_notif+0x93c>)
 80158ee:	226c      	movs	r2, #108	; 0x6c
 80158f0:	fb02 3300 	mla	r3, r2, r0, r3
 80158f4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80158f6:	2b00      	cmp	r3, #0
 80158f8:	f43f acc0 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* cs_ctxt_sockets_info[sockHandle].socket_remote_close_callback)(sockHandle);
 80158fc:	4798      	blx	r3
 80158fe:	e4bd      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.packet_domain_event == CELLULAR_TRUE))
 8015900:	4b74      	ldr	r3, [pc, #464]	; (8015ad4 <CELLULAR_urc_notif+0x930>)
 8015902:	79db      	ldrb	r3, [r3, #7]
  else if ((msgtype == (uint16_t) CSMT_URC_PACKET_DOMAIN_EVENT) &&
 8015904:	2b01      	cmp	r3, #1
 8015906:	f47f ac9b 	bne.w	8015240 <CELLULAR_urc_notif+0x9c>
    if (DATAPACK_readStruct(p_rsp_buf,
 801590a:	ab10      	add	r3, sp, #64	; 0x40
 801590c:	2204      	movs	r2, #4
 801590e:	210c      	movs	r1, #12
 8015910:	4630      	mov	r0, r6
 8015912:	f7f6 fcef 	bl	800c2f4 <DATAPACK_readStruct>
 8015916:	4604      	mov	r4, r0
 8015918:	2800      	cmp	r0, #0
 801591a:	f47f acaf 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      PRINT_DBG("PDN event: origine=%d scope=%d type=%d (user cid=%d) ",
 801591e:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 8015922:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
 8015926:	4d6a      	ldr	r5, [pc, #424]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015928:	9201      	str	r2, [sp, #4]
 801592a:	9300      	str	r3, [sp, #0]
 801592c:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 8015930:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 8015934:	496b      	ldr	r1, [pc, #428]	; (8015ae4 <CELLULAR_urc_notif+0x940>)
 8015936:	4628      	mov	r0, r5
 8015938:	f010 f99a 	bl	8025c70 <sprintf>
 801593c:	4628      	mov	r0, r5
 801593e:	f009 fbe8 	bl	801f112 <crs_strlen>
 8015942:	b283      	uxth	r3, r0
 8015944:	462a      	mov	r2, r5
 8015946:	2102      	movs	r1, #2
 8015948:	2001      	movs	r0, #1
 801594a:	f009 fc25 	bl	801f198 <traceIF_itmPrint>
 801594e:	4628      	mov	r0, r5
 8015950:	f009 fbdf 	bl	801f112 <crs_strlen>
 8015954:	b283      	uxth	r3, r0
 8015956:	462a      	mov	r2, r5
 8015958:	2102      	movs	r1, #2
 801595a:	2001      	movs	r0, #1
 801595c:	f009 fc3e 	bl	801f1dc <traceIF_uartPrint>
      if ((pdn_event.conf_id == CS_PDN_USER_CONFIG_1) ||
 8015960:	f89d 5043 	ldrb.w	r5, [sp, #67]	; 0x43
 8015964:	2d05      	cmp	r5, #5
 8015966:	d80c      	bhi.n	8015982 <CELLULAR_urc_notif+0x7de>
        if (urc_packet_domain_event_callback[pdn_event.conf_id] != NULL)
 8015968:	4b5f      	ldr	r3, [pc, #380]	; (8015ae8 <CELLULAR_urc_notif+0x944>)
 801596a:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
 801596e:	2c00      	cmp	r4, #0
 8015970:	f43f ac84 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          CS_PDN_event_t conv_pdn_event = convert_to_PDN_event(pdn_event);
 8015974:	9810      	ldr	r0, [sp, #64]	; 0x40
 8015976:	f7ff fbdd 	bl	8015134 <convert_to_PDN_event>
 801597a:	4601      	mov	r1, r0
          (* urc_packet_domain_event_callback[pdn_event.conf_id])(pdn_event.conf_id, conv_pdn_event);
 801597c:	4628      	mov	r0, r5
 801597e:	47a0      	blx	r4
 8015980:	e47c      	b.n	801527c <CELLULAR_urc_notif+0xd8>
      else if (pdn_event.conf_id == CS_PDN_ALL)
 8015982:	2d0d      	cmp	r5, #13
 8015984:	d114      	bne.n	80159b0 <CELLULAR_urc_notif+0x80c>
        CS_PDN_event_t conv_pdn_event = convert_to_PDN_event(pdn_event);
 8015986:	9810      	ldr	r0, [sp, #64]	; 0x40
 8015988:	f7ff fbd4 	bl	8015134 <convert_to_PDN_event>
 801598c:	4606      	mov	r6, r0
        for (uint8_t loop = 0U; loop < CS_MAX_NB_PDP_CTXT; loop++)
 801598e:	e001      	b.n	8015994 <CELLULAR_urc_notif+0x7f0>
 8015990:	3401      	adds	r4, #1
 8015992:	b2e4      	uxtb	r4, r4
 8015994:	2c05      	cmp	r4, #5
 8015996:	f63f ac71 	bhi.w	801527c <CELLULAR_urc_notif+0xd8>
          if (urc_packet_domain_event_callback[loop] != NULL)
 801599a:	4b53      	ldr	r3, [pc, #332]	; (8015ae8 <CELLULAR_urc_notif+0x944>)
 801599c:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
 80159a0:	2d00      	cmp	r5, #0
 80159a2:	d0f5      	beq.n	8015990 <CELLULAR_urc_notif+0x7ec>
            CS_PDN_conf_id_t pdn_cid = convert_index_to_PDN_conf(loop);
 80159a4:	4620      	mov	r0, r4
 80159a6:	f7ff fbf3 	bl	8015190 <convert_index_to_PDN_conf>
            (* urc_packet_domain_event_callback[loop])(pdn_cid, conv_pdn_event);
 80159aa:	4631      	mov	r1, r6
 80159ac:	47a8      	blx	r5
 80159ae:	e7ef      	b.n	8015990 <CELLULAR_urc_notif+0x7ec>
        PRINT_INFO("PDN not identified")
 80159b0:	4c47      	ldr	r4, [pc, #284]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 80159b2:	4d4e      	ldr	r5, [pc, #312]	; (8015aec <CELLULAR_urc_notif+0x948>)
 80159b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80159b6:	6020      	str	r0, [r4, #0]
 80159b8:	6061      	str	r1, [r4, #4]
 80159ba:	60a2      	str	r2, [r4, #8]
 80159bc:	60e3      	str	r3, [r4, #12]
 80159be:	cd03      	ldmia	r5!, {r0, r1}
 80159c0:	6120      	str	r0, [r4, #16]
 80159c2:	6161      	str	r1, [r4, #20]
 80159c4:	4620      	mov	r0, r4
 80159c6:	f009 fba4 	bl	801f112 <crs_strlen>
 80159ca:	b283      	uxth	r3, r0
 80159cc:	4622      	mov	r2, r4
 80159ce:	2101      	movs	r1, #1
 80159d0:	4608      	mov	r0, r1
 80159d2:	f009 fbe1 	bl	801f198 <traceIF_itmPrint>
 80159d6:	4620      	mov	r0, r4
 80159d8:	f009 fb9b 	bl	801f112 <crs_strlen>
 80159dc:	b283      	uxth	r3, r0
 80159de:	4622      	mov	r2, r4
 80159e0:	2101      	movs	r1, #1
 80159e2:	4608      	mov	r0, r1
 80159e4:	f009 fbfa 	bl	801f1dc <traceIF_uartPrint>
  {
 80159e8:	e448      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 80159ea:	ab10      	add	r3, sp, #64	; 0x40
 80159ec:	2250      	movs	r2, #80	; 0x50
 80159ee:	2110      	movs	r1, #16
 80159f0:	4630      	mov	r0, r6
 80159f2:	f7f6 fc7f 	bl	800c2f4 <DATAPACK_readStruct>
 80159f6:	2800      	cmp	r0, #0
 80159f8:	f47f ac40 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      PRINT_INFO("ping URC received at CS level")
 80159fc:	4e3c      	ldr	r6, [pc, #240]	; (8015af0 <CELLULAR_urc_notif+0x94c>)
 80159fe:	4c34      	ldr	r4, [pc, #208]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015a00:	f106 0c20 	add.w	ip, r6, #32
 8015a04:	4635      	mov	r5, r6
 8015a06:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a08:	6020      	str	r0, [r4, #0]
 8015a0a:	6061      	str	r1, [r4, #4]
 8015a0c:	60a2      	str	r2, [r4, #8]
 8015a0e:	60e3      	str	r3, [r4, #12]
 8015a10:	462e      	mov	r6, r5
 8015a12:	3410      	adds	r4, #16
 8015a14:	4565      	cmp	r5, ip
 8015a16:	d1f5      	bne.n	8015a04 <CELLULAR_urc_notif+0x860>
 8015a18:	882a      	ldrh	r2, [r5, #0]
 8015a1a:	78ab      	ldrb	r3, [r5, #2]
 8015a1c:	8022      	strh	r2, [r4, #0]
 8015a1e:	70a3      	strb	r3, [r4, #2]
 8015a20:	4c2b      	ldr	r4, [pc, #172]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015a22:	4620      	mov	r0, r4
 8015a24:	f009 fb75 	bl	801f112 <crs_strlen>
 8015a28:	b283      	uxth	r3, r0
 8015a2a:	4622      	mov	r2, r4
 8015a2c:	2101      	movs	r1, #1
 8015a2e:	4608      	mov	r0, r1
 8015a30:	f009 fbb2 	bl	801f198 <traceIF_itmPrint>
 8015a34:	4620      	mov	r0, r4
 8015a36:	f009 fb6c 	bl	801f112 <crs_strlen>
 8015a3a:	b283      	uxth	r3, r0
 8015a3c:	4622      	mov	r2, r4
 8015a3e:	2101      	movs	r1, #1
 8015a40:	4608      	mov	r0, r1
 8015a42:	f009 fbcb 	bl	801f1dc <traceIF_uartPrint>
      if (urc_ping_rsp_callback != NULL)
 8015a46:	4b2b      	ldr	r3, [pc, #172]	; (8015af4 <CELLULAR_urc_notif+0x950>)
 8015a48:	681e      	ldr	r6, [r3, #0]
 8015a4a:	2e00      	cmp	r6, #0
 8015a4c:	f43f ac16 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        (* urc_ping_rsp_callback)(ping_rsp);
 8015a50:	466c      	mov	r4, sp
 8015a52:	ad14      	add	r5, sp, #80	; 0x50
 8015a54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a56:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015a58:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a5a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015a5c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a5e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015a60:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8015a64:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8015a68:	ab10      	add	r3, sp, #64	; 0x40
 8015a6a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8015a6c:	47b0      	blx	r6
 8015a6e:	e405      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015a70:	ab10      	add	r3, sp, #64	; 0x40
 8015a72:	2202      	movs	r2, #2
 8015a74:	210f      	movs	r1, #15
 8015a76:	4630      	mov	r0, r6
 8015a78:	f7f6 fc3c 	bl	800c2f4 <DATAPACK_readStruct>
 8015a7c:	2800      	cmp	r0, #0
 8015a7e:	f47f abfd 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      PRINT_DBG("MODEM events received= 0x%x", modem_events)
 8015a82:	4c13      	ldr	r4, [pc, #76]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015a84:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015a88:	491b      	ldr	r1, [pc, #108]	; (8015af8 <CELLULAR_urc_notif+0x954>)
 8015a8a:	4620      	mov	r0, r4
 8015a8c:	f010 f8f0 	bl	8025c70 <sprintf>
 8015a90:	4620      	mov	r0, r4
 8015a92:	f009 fb3e 	bl	801f112 <crs_strlen>
 8015a96:	b283      	uxth	r3, r0
 8015a98:	4622      	mov	r2, r4
 8015a9a:	2102      	movs	r1, #2
 8015a9c:	2001      	movs	r0, #1
 8015a9e:	f009 fb7b 	bl	801f198 <traceIF_itmPrint>
 8015aa2:	4620      	mov	r0, r4
 8015aa4:	f009 fb35 	bl	801f112 <crs_strlen>
 8015aa8:	b283      	uxth	r3, r0
 8015aaa:	4622      	mov	r2, r4
 8015aac:	2102      	movs	r1, #2
 8015aae:	2001      	movs	r0, #1
 8015ab0:	f009 fb94 	bl	801f1dc <traceIF_uartPrint>
      if (urc_modem_event_callback != NULL)
 8015ab4:	4b11      	ldr	r3, [pc, #68]	; (8015afc <CELLULAR_urc_notif+0x958>)
 8015ab6:	681b      	ldr	r3, [r3, #0]
 8015ab8:	2b00      	cmp	r3, #0
 8015aba:	f43f abdf 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        (* urc_modem_event_callback)(modem_events);
 8015abe:	f8bd 0040 	ldrh.w	r0, [sp, #64]	; 0x40
 8015ac2:	4798      	blx	r3
 8015ac4:	f7ff bbda 	b.w	801527c <CELLULAR_urc_notif+0xd8>
 8015ac8:	200036a0 	.word	0x200036a0
 8015acc:	0803105c 	.word	0x0803105c
 8015ad0:	200047dc 	.word	0x200047dc
 8015ad4:	20003804 	.word	0x20003804
 8015ad8:	200038cc 	.word	0x200038cc
 8015adc:	08031098 	.word	0x08031098
 8015ae0:	20003d18 	.word	0x20003d18
 8015ae4:	080310e0 	.word	0x080310e0
 8015ae8:	200038b0 	.word	0x200038b0
 8015aec:	0803111c 	.word	0x0803111c
 8015af0:	08031134 	.word	0x08031134
 8015af4:	200038c8 	.word	0x200038c8
 8015af8:	08031158 	.word	0x08031158
 8015afc:	200038ac 	.word	0x200038ac

08015b00 <CELLULAR_analyze_error_report>:
{
 8015b00:	b570      	push	{r4, r5, r6, lr}
 8015b02:	b082      	sub	sp, #8
 8015b04:	4606      	mov	r6, r0
  PRINT_API("<Cellular_Service> CELLULAR_analyze_error_report")
 8015b06:	4c2e      	ldr	r4, [pc, #184]	; (8015bc0 <CELLULAR_analyze_error_report+0xc0>)
 8015b08:	4d2e      	ldr	r5, [pc, #184]	; (8015bc4 <CELLULAR_analyze_error_report+0xc4>)
 8015b0a:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8015b0e:	46a4      	mov	ip, r4
 8015b10:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015b14:	6028      	str	r0, [r5, #0]
 8015b16:	6069      	str	r1, [r5, #4]
 8015b18:	60aa      	str	r2, [r5, #8]
 8015b1a:	60eb      	str	r3, [r5, #12]
 8015b1c:	4664      	mov	r4, ip
 8015b1e:	3510      	adds	r5, #16
 8015b20:	45f4      	cmp	ip, lr
 8015b22:	d1f4      	bne.n	8015b0e <CELLULAR_analyze_error_report+0xe>
 8015b24:	cc03      	ldmia	r4!, {r0, r1}
 8015b26:	6028      	str	r0, [r5, #0]
 8015b28:	6069      	str	r1, [r5, #4]
 8015b2a:	8823      	ldrh	r3, [r4, #0]
 8015b2c:	812b      	strh	r3, [r5, #8]
 8015b2e:	4c25      	ldr	r4, [pc, #148]	; (8015bc4 <CELLULAR_analyze_error_report+0xc4>)
 8015b30:	4620      	mov	r0, r4
 8015b32:	f009 faee 	bl	801f112 <crs_strlen>
 8015b36:	b283      	uxth	r3, r0
 8015b38:	4622      	mov	r2, r4
 8015b3a:	2104      	movs	r1, #4
 8015b3c:	2001      	movs	r0, #1
 8015b3e:	f009 fb2b 	bl	801f198 <traceIF_itmPrint>
 8015b42:	4620      	mov	r0, r4
 8015b44:	f009 fae5 	bl	801f112 <crs_strlen>
 8015b48:	b283      	uxth	r3, r0
 8015b4a:	4622      	mov	r2, r4
 8015b4c:	2104      	movs	r1, #4
 8015b4e:	2001      	movs	r0, #1
 8015b50:	f009 fb44 	bl	801f1dc <traceIF_uartPrint>
  msgtype = DATAPACK_readMsgType(p_rsp_buf);
 8015b54:	4630      	mov	r0, r6
 8015b56:	f7f6 fb1b 	bl	800c190 <DATAPACK_readMsgType>
  if (msgtype == (uint16_t) CSMT_ERROR_REPORT)
 8015b5a:	282a      	cmp	r0, #42	; 0x2a
 8015b5c:	d01b      	beq.n	8015b96 <CELLULAR_analyze_error_report+0x96>
  retval = CELLULAR_ERROR;
 8015b5e:	2501      	movs	r5, #1
  PRINT_DBG("CS returned modified value after error report analysis = %d", retval)
 8015b60:	4c18      	ldr	r4, [pc, #96]	; (8015bc4 <CELLULAR_analyze_error_report+0xc4>)
 8015b62:	462a      	mov	r2, r5
 8015b64:	4918      	ldr	r1, [pc, #96]	; (8015bc8 <CELLULAR_analyze_error_report+0xc8>)
 8015b66:	4620      	mov	r0, r4
 8015b68:	f010 f882 	bl	8025c70 <sprintf>
 8015b6c:	4620      	mov	r0, r4
 8015b6e:	f009 fad0 	bl	801f112 <crs_strlen>
 8015b72:	b283      	uxth	r3, r0
 8015b74:	4622      	mov	r2, r4
 8015b76:	2102      	movs	r1, #2
 8015b78:	2001      	movs	r0, #1
 8015b7a:	f009 fb0d 	bl	801f198 <traceIF_itmPrint>
 8015b7e:	4620      	mov	r0, r4
 8015b80:	f009 fac7 	bl	801f112 <crs_strlen>
 8015b84:	b283      	uxth	r3, r0
 8015b86:	4622      	mov	r2, r4
 8015b88:	2102      	movs	r1, #2
 8015b8a:	2001      	movs	r0, #1
 8015b8c:	f009 fb26 	bl	801f1dc <traceIF_uartPrint>
}
 8015b90:	4628      	mov	r0, r5
 8015b92:	b002      	add	sp, #8
 8015b94:	bd70      	pop	{r4, r5, r6, pc}
    if (DATAPACK_readStruct(p_rsp_buf,
 8015b96:	ab01      	add	r3, sp, #4
 8015b98:	2202      	movs	r2, #2
 8015b9a:	212a      	movs	r1, #42	; 0x2a
 8015b9c:	4630      	mov	r0, r6
 8015b9e:	f7f6 fba9 	bl	800c2f4 <DATAPACK_readStruct>
 8015ba2:	b950      	cbnz	r0, 8015bba <CELLULAR_analyze_error_report+0xba>
      if (error_report.error_type == CSERR_SIM)
 8015ba4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8015ba8:	2b01      	cmp	r3, #1
 8015baa:	d001      	beq.n	8015bb0 <CELLULAR_analyze_error_report+0xb0>
  retval = CELLULAR_ERROR;
 8015bac:	2501      	movs	r5, #1
 8015bae:	e7d7      	b.n	8015b60 <CELLULAR_analyze_error_report+0x60>
        retval = convert_SIM_error(&error_report);
 8015bb0:	a801      	add	r0, sp, #4
 8015bb2:	f7ff faaa 	bl	801510a <convert_SIM_error>
 8015bb6:	4605      	mov	r5, r0
 8015bb8:	e7d2      	b.n	8015b60 <CELLULAR_analyze_error_report+0x60>
  retval = CELLULAR_ERROR;
 8015bba:	2501      	movs	r5, #1
 8015bbc:	e7d0      	b.n	8015b60 <CELLULAR_analyze_error_report+0x60>
 8015bbe:	bf00      	nop
 8015bc0:	080311a0 	.word	0x080311a0
 8015bc4:	200047dc 	.word	0x200047dc
 8015bc8:	080311dc 	.word	0x080311dc

08015bcc <CELLULAR_reset_socket_context>:
{
 8015bcc:	b538      	push	{r3, r4, r5, lr}
  PRINT_DBG("CELLULAR_reset_socket_context")
 8015bce:	4d19      	ldr	r5, [pc, #100]	; (8015c34 <CELLULAR_reset_socket_context+0x68>)
 8015bd0:	4c19      	ldr	r4, [pc, #100]	; (8015c38 <CELLULAR_reset_socket_context+0x6c>)
 8015bd2:	f105 0e20 	add.w	lr, r5, #32
 8015bd6:	46ac      	mov	ip, r5
 8015bd8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015bdc:	6020      	str	r0, [r4, #0]
 8015bde:	6061      	str	r1, [r4, #4]
 8015be0:	60a2      	str	r2, [r4, #8]
 8015be2:	60e3      	str	r3, [r4, #12]
 8015be4:	4665      	mov	r5, ip
 8015be6:	3410      	adds	r4, #16
 8015be8:	45f4      	cmp	ip, lr
 8015bea:	d1f4      	bne.n	8015bd6 <CELLULAR_reset_socket_context+0xa>
 8015bec:	f8bc 2000 	ldrh.w	r2, [ip]
 8015bf0:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8015bf4:	8022      	strh	r2, [r4, #0]
 8015bf6:	70a3      	strb	r3, [r4, #2]
 8015bf8:	4c0f      	ldr	r4, [pc, #60]	; (8015c38 <CELLULAR_reset_socket_context+0x6c>)
 8015bfa:	4620      	mov	r0, r4
 8015bfc:	f009 fa89 	bl	801f112 <crs_strlen>
 8015c00:	b283      	uxth	r3, r0
 8015c02:	4622      	mov	r2, r4
 8015c04:	2102      	movs	r1, #2
 8015c06:	2001      	movs	r0, #1
 8015c08:	f009 fac6 	bl	801f198 <traceIF_itmPrint>
 8015c0c:	4620      	mov	r0, r4
 8015c0e:	f009 fa80 	bl	801f112 <crs_strlen>
 8015c12:	b283      	uxth	r3, r0
 8015c14:	4622      	mov	r2, r4
 8015c16:	2102      	movs	r1, #2
 8015c18:	2001      	movs	r0, #1
 8015c1a:	f009 fadf 	bl	801f1dc <traceIF_uartPrint>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt ++)
 8015c1e:	2400      	movs	r4, #0
 8015c20:	e004      	b.n	8015c2c <CELLULAR_reset_socket_context+0x60>
    csint_socket_init((socket_handle_t)cpt);
 8015c22:	4620      	mov	r0, r4
 8015c24:	f004 fbce 	bl	801a3c4 <csint_socket_init>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt ++)
 8015c28:	3401      	adds	r4, #1
 8015c2a:	b2e4      	uxtb	r4, r4
 8015c2c:	2c05      	cmp	r4, #5
 8015c2e:	d9f8      	bls.n	8015c22 <CELLULAR_reset_socket_context+0x56>
}
 8015c30:	bd38      	pop	{r3, r4, r5, pc}
 8015c32:	bf00      	nop
 8015c34:	08031220 	.word	0x08031220
 8015c38:	200047dc 	.word	0x200047dc

08015c3c <CELLULAR_init>:
{
 8015c3c:	b510      	push	{r4, lr}
  if (SysCtrl_getDeviceDescriptor(DEVTYPE_MODEM_CELLULAR, &modem_device_infos) == SCSTATUS_OK)
 8015c3e:	490e      	ldr	r1, [pc, #56]	; (8015c78 <CELLULAR_init+0x3c>)
 8015c40:	2000      	movs	r0, #0
 8015c42:	f7ff f95d 	bl	8014f00 <SysCtrl_getDeviceDescriptor>
 8015c46:	b110      	cbz	r0, 8015c4e <CELLULAR_init+0x12>
  CS_Status_t retval = CELLULAR_ERROR;
 8015c48:	2401      	movs	r4, #1
}
 8015c4a:	4620      	mov	r0, r4
 8015c4c:	bd10      	pop	{r4, pc}
 8015c4e:	4604      	mov	r4, r0
    (void) AT_init();
 8015c50:	f7f5 fe06 	bl	800b860 <AT_init>
    _Adapter_Handle = AT_open(&modem_device_infos, CELLULAR_idle_event_notif, CELLULAR_urc_notif);
 8015c54:	4a09      	ldr	r2, [pc, #36]	; (8015c7c <CELLULAR_init+0x40>)
 8015c56:	490a      	ldr	r1, [pc, #40]	; (8015c80 <CELLULAR_init+0x44>)
 8015c58:	4807      	ldr	r0, [pc, #28]	; (8015c78 <CELLULAR_init+0x3c>)
 8015c5a:	f7f5 fe3f 	bl	800b8dc <AT_open>
 8015c5e:	4b09      	ldr	r3, [pc, #36]	; (8015c84 <CELLULAR_init+0x48>)
 8015c60:	8018      	strh	r0, [r3, #0]
    if (_Adapter_Handle != AT_HANDLE_INVALID)
 8015c62:	f1b0 3fff 	cmp.w	r0, #4294967295
 8015c66:	d101      	bne.n	8015c6c <CELLULAR_init+0x30>
  CS_Status_t retval = CELLULAR_ERROR;
 8015c68:	2401      	movs	r4, #1
 8015c6a:	e7ee      	b.n	8015c4a <CELLULAR_init+0xe>
      CELLULAR_reset_context();
 8015c6c:	f7ff fa1c 	bl	80150a8 <CELLULAR_reset_context>
      CELLULAR_reset_socket_context();
 8015c70:	f7ff ffac 	bl	8015bcc <CELLULAR_reset_socket_context>
      retval = CELLULAR_OK;
 8015c74:	e7e9      	b.n	8015c4a <CELLULAR_init+0xe>
 8015c76:	bf00      	nop
 8015c78:	20003810 	.word	0x20003810
 8015c7c:	080151a5 	.word	0x080151a5
 8015c80:	08015109 	.word	0x08015109
 8015c84:	2000361c 	.word	0x2000361c

08015c88 <CS_init>:
{
 8015c88:	b538      	push	{r3, r4, r5, lr}
  PRINT_API("CS_init")
 8015c8a:	4c0f      	ldr	r4, [pc, #60]	; (8015cc8 <CS_init+0x40>)
 8015c8c:	4d0f      	ldr	r5, [pc, #60]	; (8015ccc <CS_init+0x44>)
 8015c8e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015c90:	6020      	str	r0, [r4, #0]
 8015c92:	6061      	str	r1, [r4, #4]
 8015c94:	60a2      	str	r2, [r4, #8]
 8015c96:	60e3      	str	r3, [r4, #12]
 8015c98:	782b      	ldrb	r3, [r5, #0]
 8015c9a:	7423      	strb	r3, [r4, #16]
 8015c9c:	4620      	mov	r0, r4
 8015c9e:	f009 fa38 	bl	801f112 <crs_strlen>
 8015ca2:	b283      	uxth	r3, r0
 8015ca4:	4622      	mov	r2, r4
 8015ca6:	2104      	movs	r1, #4
 8015ca8:	2001      	movs	r0, #1
 8015caa:	f009 fa75 	bl	801f198 <traceIF_itmPrint>
 8015cae:	4620      	mov	r0, r4
 8015cb0:	f009 fa2f 	bl	801f112 <crs_strlen>
 8015cb4:	b283      	uxth	r3, r0
 8015cb6:	4622      	mov	r2, r4
 8015cb8:	2104      	movs	r1, #4
 8015cba:	2001      	movs	r0, #1
 8015cbc:	f009 fa8e 	bl	801f1dc <traceIF_uartPrint>
  retval = CELLULAR_init();
 8015cc0:	f7ff ffbc 	bl	8015c3c <CELLULAR_init>
}
 8015cc4:	bd38      	pop	{r3, r4, r5, pc}
 8015cc6:	bf00      	nop
 8015cc8:	200047dc 	.word	0x200047dc
 8015ccc:	08031244 	.word	0x08031244

08015cd0 <CS_power_on>:
{
 8015cd0:	b570      	push	{r4, r5, r6, lr}
  PRINT_API("CS_power_on")
 8015cd2:	4c43      	ldr	r4, [pc, #268]	; (8015de0 <CS_power_on+0x110>)
 8015cd4:	4d43      	ldr	r5, [pc, #268]	; (8015de4 <CS_power_on+0x114>)
 8015cd6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015cd8:	6020      	str	r0, [r4, #0]
 8015cda:	6061      	str	r1, [r4, #4]
 8015cdc:	60a2      	str	r2, [r4, #8]
 8015cde:	60e3      	str	r3, [r4, #12]
 8015ce0:	6828      	ldr	r0, [r5, #0]
 8015ce2:	6120      	str	r0, [r4, #16]
 8015ce4:	792b      	ldrb	r3, [r5, #4]
 8015ce6:	7523      	strb	r3, [r4, #20]
 8015ce8:	4620      	mov	r0, r4
 8015cea:	f009 fa12 	bl	801f112 <crs_strlen>
 8015cee:	b283      	uxth	r3, r0
 8015cf0:	4622      	mov	r2, r4
 8015cf2:	2104      	movs	r1, #4
 8015cf4:	2001      	movs	r0, #1
 8015cf6:	f009 fa4f 	bl	801f198 <traceIF_itmPrint>
 8015cfa:	4620      	mov	r0, r4
 8015cfc:	f009 fa09 	bl	801f112 <crs_strlen>
 8015d00:	b283      	uxth	r3, r0
 8015d02:	4622      	mov	r2, r4
 8015d04:	2104      	movs	r1, #4
 8015d06:	2001      	movs	r0, #1
 8015d08:	f009 fa68 	bl	801f1dc <traceIF_uartPrint>
  if (SysCtrl_power_on(DEVTYPE_MODEM_CELLULAR) == SCSTATUS_OK)
 8015d0c:	2000      	movs	r0, #0
 8015d0e:	f7ff f96d 	bl	8014fec <SysCtrl_power_on>
 8015d12:	b910      	cbnz	r0, 8015d1a <CS_power_on+0x4a>
    if (SysCtrl_open_channel(DEVTYPE_MODEM_CELLULAR) == SCSTATUS_OK)
 8015d14:	f7ff f912 	bl	8014f3c <SysCtrl_open_channel>
 8015d18:	b348      	cbz	r0, 8015d6e <CS_power_on+0x9e>
    PRINT_ERR("<Cellular_Service> error when power on process")
 8015d1a:	4c33      	ldr	r4, [pc, #204]	; (8015de8 <CS_power_on+0x118>)
 8015d1c:	4d30      	ldr	r5, [pc, #192]	; (8015de0 <CS_power_on+0x110>)
 8015d1e:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8015d22:	46a4      	mov	ip, r4
 8015d24:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015d28:	6028      	str	r0, [r5, #0]
 8015d2a:	6069      	str	r1, [r5, #4]
 8015d2c:	60aa      	str	r2, [r5, #8]
 8015d2e:	60eb      	str	r3, [r5, #12]
 8015d30:	4664      	mov	r4, ip
 8015d32:	3510      	adds	r5, #16
 8015d34:	45f4      	cmp	ip, lr
 8015d36:	d1f4      	bne.n	8015d22 <CS_power_on+0x52>
 8015d38:	cc03      	ldmia	r4!, {r0, r1}
 8015d3a:	6028      	str	r0, [r5, #0]
 8015d3c:	6069      	str	r1, [r5, #4]
 8015d3e:	8823      	ldrh	r3, [r4, #0]
 8015d40:	812b      	strh	r3, [r5, #8]
 8015d42:	4c27      	ldr	r4, [pc, #156]	; (8015de0 <CS_power_on+0x110>)
 8015d44:	4620      	mov	r0, r4
 8015d46:	f009 f9e4 	bl	801f112 <crs_strlen>
 8015d4a:	b283      	uxth	r3, r0
 8015d4c:	4622      	mov	r2, r4
 8015d4e:	2110      	movs	r1, #16
 8015d50:	2001      	movs	r0, #1
 8015d52:	f009 fa21 	bl	801f198 <traceIF_itmPrint>
 8015d56:	4620      	mov	r0, r4
 8015d58:	f009 f9db 	bl	801f112 <crs_strlen>
 8015d5c:	b283      	uxth	r3, r0
 8015d5e:	4622      	mov	r2, r4
 8015d60:	2110      	movs	r1, #16
 8015d62:	2001      	movs	r0, #1
 8015d64:	f009 fa3a 	bl	801f1dc <traceIF_uartPrint>
 8015d68:	2401      	movs	r4, #1
}
 8015d6a:	4620      	mov	r0, r4
 8015d6c:	bd70      	pop	{r4, r5, r6, pc}
      if (AT_open_channel(_Adapter_Handle) == ATSTATUS_OK)
 8015d6e:	4b1f      	ldr	r3, [pc, #124]	; (8015dec <CS_power_on+0x11c>)
 8015d70:	f9b3 0000 	ldrsh.w	r0, [r3]
 8015d74:	f7f5 fe34 	bl	800b9e0 <AT_open_channel>
 8015d78:	2800      	cmp	r0, #0
 8015d7a:	d1ce      	bne.n	8015d1a <CS_power_on+0x4a>
        if (DATAPACK_writeStruct(&cmd_buf[0],
 8015d7c:	2300      	movs	r3, #0
 8015d7e:	461a      	mov	r2, r3
 8015d80:	2104      	movs	r1, #4
 8015d82:	481b      	ldr	r0, [pc, #108]	; (8015df0 <CS_power_on+0x120>)
 8015d84:	f7f6 f996 	bl	800c0b4 <DATAPACK_writeStruct>
 8015d88:	2800      	cmp	r0, #0
 8015d8a:	d1c6      	bne.n	8015d1a <CS_power_on+0x4a>
          err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_POWER_ON, &cmd_buf[0], &rsp_buf[0]);
 8015d8c:	4b19      	ldr	r3, [pc, #100]	; (8015df4 <CS_power_on+0x124>)
 8015d8e:	4a18      	ldr	r2, [pc, #96]	; (8015df0 <CS_power_on+0x120>)
 8015d90:	2165      	movs	r1, #101	; 0x65
 8015d92:	4816      	ldr	r0, [pc, #88]	; (8015dec <CS_power_on+0x11c>)
 8015d94:	f9b0 0000 	ldrsh.w	r0, [r0]
 8015d98:	f7f5 ff24 	bl	800bbe4 <AT_sendcmd>
          if (err == ATSTATUS_OK)
 8015d9c:	4604      	mov	r4, r0
 8015d9e:	2800      	cmp	r0, #0
 8015da0:	d1bb      	bne.n	8015d1a <CS_power_on+0x4a>
            PRINT_DBG("Cellular started and ready")
 8015da2:	4d0f      	ldr	r5, [pc, #60]	; (8015de0 <CS_power_on+0x110>)
 8015da4:	4e14      	ldr	r6, [pc, #80]	; (8015df8 <CS_power_on+0x128>)
 8015da6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015da8:	6028      	str	r0, [r5, #0]
 8015daa:	6069      	str	r1, [r5, #4]
 8015dac:	60aa      	str	r2, [r5, #8]
 8015dae:	60eb      	str	r3, [r5, #12]
 8015db0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015db2:	6128      	str	r0, [r5, #16]
 8015db4:	6169      	str	r1, [r5, #20]
 8015db6:	61aa      	str	r2, [r5, #24]
 8015db8:	61eb      	str	r3, [r5, #28]
 8015dba:	4628      	mov	r0, r5
 8015dbc:	f009 f9a9 	bl	801f112 <crs_strlen>
 8015dc0:	b283      	uxth	r3, r0
 8015dc2:	462a      	mov	r2, r5
 8015dc4:	2102      	movs	r1, #2
 8015dc6:	2001      	movs	r0, #1
 8015dc8:	f009 f9e6 	bl	801f198 <traceIF_itmPrint>
 8015dcc:	4628      	mov	r0, r5
 8015dce:	f009 f9a0 	bl	801f112 <crs_strlen>
 8015dd2:	b283      	uxth	r3, r0
 8015dd4:	462a      	mov	r2, r5
 8015dd6:	2102      	movs	r1, #2
 8015dd8:	2001      	movs	r0, #1
 8015dda:	f009 f9ff 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8015dde:	e7c4      	b.n	8015d6a <CS_power_on+0x9a>
 8015de0:	200047dc 	.word	0x200047dc
 8015de4:	08031258 	.word	0x08031258
 8015de8:	08031290 	.word	0x08031290
 8015dec:	2000361c 	.word	0x2000361c
 8015df0:	20003620 	.word	0x20003620
 8015df4:	20003814 	.word	0x20003814
 8015df8:	08031270 	.word	0x08031270

08015dfc <CS_power_off>:
{
 8015dfc:	b570      	push	{r4, r5, r6, lr}
  PRINT_API("CS_power_off")
 8015dfe:	4c43      	ldr	r4, [pc, #268]	; (8015f0c <CS_power_off+0x110>)
 8015e00:	4d43      	ldr	r5, [pc, #268]	; (8015f10 <CS_power_off+0x114>)
 8015e02:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015e04:	6020      	str	r0, [r4, #0]
 8015e06:	6061      	str	r1, [r4, #4]
 8015e08:	60a2      	str	r2, [r4, #8]
 8015e0a:	60e3      	str	r3, [r4, #12]
 8015e0c:	6828      	ldr	r0, [r5, #0]
 8015e0e:	6120      	str	r0, [r4, #16]
 8015e10:	88ab      	ldrh	r3, [r5, #4]
 8015e12:	82a3      	strh	r3, [r4, #20]
 8015e14:	4620      	mov	r0, r4
 8015e16:	f009 f97c 	bl	801f112 <crs_strlen>
 8015e1a:	b283      	uxth	r3, r0
 8015e1c:	4622      	mov	r2, r4
 8015e1e:	2104      	movs	r1, #4
 8015e20:	2001      	movs	r0, #1
 8015e22:	f009 f9b9 	bl	801f198 <traceIF_itmPrint>
 8015e26:	4620      	mov	r0, r4
 8015e28:	f009 f973 	bl	801f112 <crs_strlen>
 8015e2c:	b283      	uxth	r3, r0
 8015e2e:	4622      	mov	r2, r4
 8015e30:	2104      	movs	r1, #4
 8015e32:	2001      	movs	r0, #1
 8015e34:	f009 f9d2 	bl	801f1dc <traceIF_uartPrint>
  CELLULAR_reset_context();
 8015e38:	f7ff f936 	bl	80150a8 <CELLULAR_reset_context>
  csint_modem_reset_update_socket_state();
 8015e3c:	f004 fa78 	bl	801a330 <csint_modem_reset_update_socket_state>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8015e40:	2300      	movs	r3, #0
 8015e42:	461a      	mov	r2, r3
 8015e44:	2104      	movs	r1, #4
 8015e46:	4833      	ldr	r0, [pc, #204]	; (8015f14 <CS_power_off+0x118>)
 8015e48:	f7f6 f934 	bl	800c0b4 <DATAPACK_writeStruct>
 8015e4c:	b998      	cbnz	r0, 8015e76 <CS_power_off+0x7a>
    (void) AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_POWER_OFF, &cmd_buf[0], &rsp_buf[0]);
 8015e4e:	4c32      	ldr	r4, [pc, #200]	; (8015f18 <CS_power_off+0x11c>)
 8015e50:	4b32      	ldr	r3, [pc, #200]	; (8015f1c <CS_power_off+0x120>)
 8015e52:	4a30      	ldr	r2, [pc, #192]	; (8015f14 <CS_power_off+0x118>)
 8015e54:	2166      	movs	r1, #102	; 0x66
 8015e56:	f9b4 0000 	ldrsh.w	r0, [r4]
 8015e5a:	f7f5 fec3 	bl	800bbe4 <AT_sendcmd>
    (void) AT_close_channel(_Adapter_Handle);
 8015e5e:	f9b4 0000 	ldrsh.w	r0, [r4]
 8015e62:	f7f5 fe5f 	bl	800bb24 <AT_close_channel>
    (void) SysCtrl_close_channel(DEVTYPE_MODEM_CELLULAR);
 8015e66:	2000      	movs	r0, #0
 8015e68:	f7ff f894 	bl	8014f94 <SysCtrl_close_channel>
    if (SysCtrl_power_off(DEVTYPE_MODEM_CELLULAR) == SCSTATUS_OK)
 8015e6c:	2000      	movs	r0, #0
 8015e6e:	f7ff f8e9 	bl	8015044 <SysCtrl_power_off>
 8015e72:	4604      	mov	r4, r0
 8015e74:	b350      	cbz	r0, 8015ecc <CS_power_off+0xd0>
    PRINT_ERR("<Cellular_Service> error during power off process")
 8015e76:	4c2a      	ldr	r4, [pc, #168]	; (8015f20 <CS_power_off+0x124>)
 8015e78:	4d24      	ldr	r5, [pc, #144]	; (8015f0c <CS_power_off+0x110>)
 8015e7a:	f104 0630 	add.w	r6, r4, #48	; 0x30
 8015e7e:	46a4      	mov	ip, r4
 8015e80:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015e84:	6028      	str	r0, [r5, #0]
 8015e86:	6069      	str	r1, [r5, #4]
 8015e88:	60aa      	str	r2, [r5, #8]
 8015e8a:	60eb      	str	r3, [r5, #12]
 8015e8c:	4664      	mov	r4, ip
 8015e8e:	3510      	adds	r5, #16
 8015e90:	45b4      	cmp	ip, r6
 8015e92:	d1f4      	bne.n	8015e7e <CS_power_off+0x82>
 8015e94:	cc07      	ldmia	r4!, {r0, r1, r2}
 8015e96:	6028      	str	r0, [r5, #0]
 8015e98:	6069      	str	r1, [r5, #4]
 8015e9a:	60aa      	str	r2, [r5, #8]
 8015e9c:	7823      	ldrb	r3, [r4, #0]
 8015e9e:	732b      	strb	r3, [r5, #12]
 8015ea0:	4c1a      	ldr	r4, [pc, #104]	; (8015f0c <CS_power_off+0x110>)
 8015ea2:	4620      	mov	r0, r4
 8015ea4:	f009 f935 	bl	801f112 <crs_strlen>
 8015ea8:	b283      	uxth	r3, r0
 8015eaa:	4622      	mov	r2, r4
 8015eac:	2110      	movs	r1, #16
 8015eae:	2001      	movs	r0, #1
 8015eb0:	f009 f972 	bl	801f198 <traceIF_itmPrint>
 8015eb4:	4620      	mov	r0, r4
 8015eb6:	f009 f92c 	bl	801f112 <crs_strlen>
 8015eba:	b283      	uxth	r3, r0
 8015ebc:	4622      	mov	r2, r4
 8015ebe:	2110      	movs	r1, #16
 8015ec0:	2001      	movs	r0, #1
 8015ec2:	f009 f98b 	bl	801f1dc <traceIF_uartPrint>
 8015ec6:	2401      	movs	r4, #1
}
 8015ec8:	4620      	mov	r0, r4
 8015eca:	bd70      	pop	{r4, r5, r6, pc}
      PRINT_DBG("<Cellular_Service> Stopped")
 8015ecc:	4d0f      	ldr	r5, [pc, #60]	; (8015f0c <CS_power_off+0x110>)
 8015ece:	4e15      	ldr	r6, [pc, #84]	; (8015f24 <CS_power_off+0x128>)
 8015ed0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015ed2:	6028      	str	r0, [r5, #0]
 8015ed4:	6069      	str	r1, [r5, #4]
 8015ed6:	60aa      	str	r2, [r5, #8]
 8015ed8:	60eb      	str	r3, [r5, #12]
 8015eda:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015edc:	6128      	str	r0, [r5, #16]
 8015ede:	6169      	str	r1, [r5, #20]
 8015ee0:	61aa      	str	r2, [r5, #24]
 8015ee2:	61eb      	str	r3, [r5, #28]
 8015ee4:	4628      	mov	r0, r5
 8015ee6:	f009 f914 	bl	801f112 <crs_strlen>
 8015eea:	b283      	uxth	r3, r0
 8015eec:	462a      	mov	r2, r5
 8015eee:	2102      	movs	r1, #2
 8015ef0:	2001      	movs	r0, #1
 8015ef2:	f009 f951 	bl	801f198 <traceIF_itmPrint>
 8015ef6:	4628      	mov	r0, r5
 8015ef8:	f009 f90b 	bl	801f112 <crs_strlen>
 8015efc:	b283      	uxth	r3, r0
 8015efe:	462a      	mov	r2, r5
 8015f00:	2102      	movs	r1, #2
 8015f02:	2001      	movs	r0, #1
 8015f04:	f009 f96a 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8015f08:	e7de      	b.n	8015ec8 <CS_power_off+0xcc>
 8015f0a:	bf00      	nop
 8015f0c:	200047dc 	.word	0x200047dc
 8015f10:	080312cc 	.word	0x080312cc
 8015f14:	20003620 	.word	0x20003620
 8015f18:	2000361c 	.word	0x2000361c
 8015f1c:	20003814 	.word	0x20003814
 8015f20:	08031304 	.word	0x08031304
 8015f24:	080312e4 	.word	0x080312e4

08015f28 <CS_sim_select>:
{
 8015f28:	b530      	push	{r4, r5, lr}
 8015f2a:	b083      	sub	sp, #12
 8015f2c:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_sim_select")
 8015f30:	4c3c      	ldr	r4, [pc, #240]	; (8016024 <CS_sim_select+0xfc>)
 8015f32:	4d3d      	ldr	r5, [pc, #244]	; (8016028 <CS_sim_select+0x100>)
 8015f34:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015f36:	6020      	str	r0, [r4, #0]
 8015f38:	6061      	str	r1, [r4, #4]
 8015f3a:	60a2      	str	r2, [r4, #8]
 8015f3c:	60e3      	str	r3, [r4, #12]
 8015f3e:	6828      	ldr	r0, [r5, #0]
 8015f40:	6120      	str	r0, [r4, #16]
 8015f42:	88aa      	ldrh	r2, [r5, #4]
 8015f44:	79ab      	ldrb	r3, [r5, #6]
 8015f46:	82a2      	strh	r2, [r4, #20]
 8015f48:	75a3      	strb	r3, [r4, #22]
 8015f4a:	4620      	mov	r0, r4
 8015f4c:	f009 f8e1 	bl	801f112 <crs_strlen>
 8015f50:	b283      	uxth	r3, r0
 8015f52:	4622      	mov	r2, r4
 8015f54:	2104      	movs	r1, #4
 8015f56:	2001      	movs	r0, #1
 8015f58:	f009 f91e 	bl	801f198 <traceIF_itmPrint>
 8015f5c:	4620      	mov	r0, r4
 8015f5e:	f009 f8d8 	bl	801f112 <crs_strlen>
 8015f62:	b283      	uxth	r3, r0
 8015f64:	4622      	mov	r2, r4
 8015f66:	2104      	movs	r1, #4
 8015f68:	2001      	movs	r0, #1
 8015f6a:	f009 f937 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8015f6e:	f10d 0307 	add.w	r3, sp, #7
 8015f72:	2201      	movs	r2, #1
 8015f74:	212c      	movs	r1, #44	; 0x2c
 8015f76:	482d      	ldr	r0, [pc, #180]	; (801602c <CS_sim_select+0x104>)
 8015f78:	f7f6 f89c 	bl	800c0b4 <DATAPACK_writeStruct>
 8015f7c:	b948      	cbnz	r0, 8015f92 <CS_sim_select+0x6a>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SIM_SELECT, &cmd_buf[0], &rsp_buf[0]);
 8015f7e:	4b2c      	ldr	r3, [pc, #176]	; (8016030 <CS_sim_select+0x108>)
 8015f80:	4a2a      	ldr	r2, [pc, #168]	; (801602c <CS_sim_select+0x104>)
 8015f82:	2187      	movs	r1, #135	; 0x87
 8015f84:	482b      	ldr	r0, [pc, #172]	; (8016034 <CS_sim_select+0x10c>)
 8015f86:	f9b0 0000 	ldrsh.w	r0, [r0]
 8015f8a:	f7f5 fe2b 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8015f8e:	4604      	mov	r4, r0
 8015f90:	b370      	cbz	r0, 8015ff0 <CS_sim_select+0xc8>
    PRINT_ERR("<Cellular_Service> error with sim selection")
 8015f92:	4d29      	ldr	r5, [pc, #164]	; (8016038 <CS_sim_select+0x110>)
 8015f94:	4c23      	ldr	r4, [pc, #140]	; (8016024 <CS_sim_select+0xfc>)
 8015f96:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8015f9a:	46ac      	mov	ip, r5
 8015f9c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015fa0:	6020      	str	r0, [r4, #0]
 8015fa2:	6061      	str	r1, [r4, #4]
 8015fa4:	60a2      	str	r2, [r4, #8]
 8015fa6:	60e3      	str	r3, [r4, #12]
 8015fa8:	4665      	mov	r5, ip
 8015faa:	3410      	adds	r4, #16
 8015fac:	45f4      	cmp	ip, lr
 8015fae:	d1f4      	bne.n	8015f9a <CS_sim_select+0x72>
 8015fb0:	f8dc 0000 	ldr.w	r0, [ip]
 8015fb4:	6020      	str	r0, [r4, #0]
 8015fb6:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8015fba:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8015fbe:	80a2      	strh	r2, [r4, #4]
 8015fc0:	71a3      	strb	r3, [r4, #6]
 8015fc2:	4c18      	ldr	r4, [pc, #96]	; (8016024 <CS_sim_select+0xfc>)
 8015fc4:	4620      	mov	r0, r4
 8015fc6:	f009 f8a4 	bl	801f112 <crs_strlen>
 8015fca:	b283      	uxth	r3, r0
 8015fcc:	4622      	mov	r2, r4
 8015fce:	2110      	movs	r1, #16
 8015fd0:	2001      	movs	r0, #1
 8015fd2:	f009 f8e1 	bl	801f198 <traceIF_itmPrint>
 8015fd6:	4620      	mov	r0, r4
 8015fd8:	f009 f89b 	bl	801f112 <crs_strlen>
 8015fdc:	b283      	uxth	r3, r0
 8015fde:	4622      	mov	r2, r4
 8015fe0:	2110      	movs	r1, #16
 8015fe2:	2001      	movs	r0, #1
 8015fe4:	f009 f8fa 	bl	801f1dc <traceIF_uartPrint>
 8015fe8:	2401      	movs	r4, #1
}
 8015fea:	4620      	mov	r0, r4
 8015fec:	b003      	add	sp, #12
 8015fee:	bd30      	pop	{r4, r5, pc}
      PRINT_DBG("<Cellular_Service> SIM %d selected", simSelected)
 8015ff0:	4d0c      	ldr	r5, [pc, #48]	; (8016024 <CS_sim_select+0xfc>)
 8015ff2:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8015ff6:	4911      	ldr	r1, [pc, #68]	; (801603c <CS_sim_select+0x114>)
 8015ff8:	4628      	mov	r0, r5
 8015ffa:	f00f fe39 	bl	8025c70 <sprintf>
 8015ffe:	4628      	mov	r0, r5
 8016000:	f009 f887 	bl	801f112 <crs_strlen>
 8016004:	b283      	uxth	r3, r0
 8016006:	462a      	mov	r2, r5
 8016008:	2102      	movs	r1, #2
 801600a:	2001      	movs	r0, #1
 801600c:	f009 f8c4 	bl	801f198 <traceIF_itmPrint>
 8016010:	4628      	mov	r0, r5
 8016012:	f009 f87e 	bl	801f112 <crs_strlen>
 8016016:	b283      	uxth	r3, r0
 8016018:	462a      	mov	r2, r5
 801601a:	2102      	movs	r1, #2
 801601c:	2001      	movs	r0, #1
 801601e:	f009 f8dd 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016022:	e7e2      	b.n	8015fea <CS_sim_select+0xc2>
 8016024:	200047dc 	.word	0x200047dc
 8016028:	08031344 	.word	0x08031344
 801602c:	20003620 	.word	0x20003620
 8016030:	20003814 	.word	0x20003814
 8016034:	2000361c 	.word	0x2000361c
 8016038:	08031384 	.word	0x08031384
 801603c:	0803135c 	.word	0x0803135c

08016040 <CS_init_modem>:
{
 8016040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016044:	b086      	sub	sp, #24
 8016046:	4680      	mov	r8, r0
 8016048:	460f      	mov	r7, r1
 801604a:	4616      	mov	r6, r2
  PRINT_API("CS_init_modem")
 801604c:	4c4d      	ldr	r4, [pc, #308]	; (8016184 <CS_init_modem+0x144>)
 801604e:	4d4e      	ldr	r5, [pc, #312]	; (8016188 <CS_init_modem+0x148>)
 8016050:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016052:	6020      	str	r0, [r4, #0]
 8016054:	6061      	str	r1, [r4, #4]
 8016056:	60a2      	str	r2, [r4, #8]
 8016058:	60e3      	str	r3, [r4, #12]
 801605a:	6828      	ldr	r0, [r5, #0]
 801605c:	6120      	str	r0, [r4, #16]
 801605e:	88aa      	ldrh	r2, [r5, #4]
 8016060:	79ab      	ldrb	r3, [r5, #6]
 8016062:	82a2      	strh	r2, [r4, #20]
 8016064:	75a3      	strb	r3, [r4, #22]
 8016066:	4620      	mov	r0, r4
 8016068:	f009 f853 	bl	801f112 <crs_strlen>
 801606c:	b283      	uxth	r3, r0
 801606e:	4622      	mov	r2, r4
 8016070:	2104      	movs	r1, #4
 8016072:	2001      	movs	r0, #1
 8016074:	f009 f890 	bl	801f198 <traceIF_itmPrint>
 8016078:	4620      	mov	r0, r4
 801607a:	f009 f84a 	bl	801f112 <crs_strlen>
 801607e:	b283      	uxth	r3, r0
 8016080:	4622      	mov	r2, r4
 8016082:	2104      	movs	r1, #4
 8016084:	2001      	movs	r0, #1
 8016086:	f009 f8a9 	bl	801f1dc <traceIF_uartPrint>
  (void) memset((void *)&modemInit_struct, 0, sizeof(modemInit_struct));
 801608a:	2300      	movs	r3, #0
 801608c:	9301      	str	r3, [sp, #4]
 801608e:	9302      	str	r3, [sp, #8]
 8016090:	9303      	str	r3, [sp, #12]
 8016092:	9304      	str	r3, [sp, #16]
 8016094:	f8ad 3014 	strh.w	r3, [sp, #20]
  modemInit_struct.init = init;
 8016098:	f88d 8004 	strb.w	r8, [sp, #4]
  modemInit_struct.reset = reset;
 801609c:	f88d 7005 	strb.w	r7, [sp, #5]
  (void) memcpy((void *)&modemInit_struct.pincode.pincode[0],
 80160a0:	4630      	mov	r0, r6
 80160a2:	f7ea f8a7 	bl	80001f4 <strlen>
 80160a6:	4602      	mov	r2, r0
 80160a8:	4631      	mov	r1, r6
 80160aa:	f10d 0006 	add.w	r0, sp, #6
 80160ae:	f00f ff2f 	bl	8025f10 <memcpy>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 80160b2:	ab01      	add	r3, sp, #4
 80160b4:	2212      	movs	r2, #18
 80160b6:	4611      	mov	r1, r2
 80160b8:	4834      	ldr	r0, [pc, #208]	; (801618c <CS_init_modem+0x14c>)
 80160ba:	f7f5 fffb 	bl	800c0b4 <DATAPACK_writeStruct>
 80160be:	2800      	cmp	r0, #0
 80160c0:	d13a      	bne.n	8016138 <CS_init_modem+0xf8>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_INIT_MODEM, &cmd_buf[0], &rsp_buf[0]);
 80160c2:	4b33      	ldr	r3, [pc, #204]	; (8016190 <CS_init_modem+0x150>)
 80160c4:	4a31      	ldr	r2, [pc, #196]	; (801618c <CS_init_modem+0x14c>)
 80160c6:	2167      	movs	r1, #103	; 0x67
 80160c8:	4832      	ldr	r0, [pc, #200]	; (8016194 <CS_init_modem+0x154>)
 80160ca:	f9b0 0000 	ldrsh.w	r0, [r0]
 80160ce:	f7f5 fd89 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 80160d2:	4607      	mov	r7, r0
 80160d4:	bb48      	cbnz	r0, 801612a <CS_init_modem+0xea>
      PRINT_DBG("<Cellular_Service> Init done successfully")
 80160d6:	4d30      	ldr	r5, [pc, #192]	; (8016198 <CS_init_modem+0x158>)
 80160d8:	f105 0620 	add.w	r6, r5, #32
 80160dc:	46ac      	mov	ip, r5
 80160de:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80160e2:	6020      	str	r0, [r4, #0]
 80160e4:	6061      	str	r1, [r4, #4]
 80160e6:	60a2      	str	r2, [r4, #8]
 80160e8:	60e3      	str	r3, [r4, #12]
 80160ea:	4665      	mov	r5, ip
 80160ec:	3410      	adds	r4, #16
 80160ee:	45b4      	cmp	ip, r6
 80160f0:	d1f4      	bne.n	80160dc <CS_init_modem+0x9c>
 80160f2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80160f4:	6020      	str	r0, [r4, #0]
 80160f6:	6061      	str	r1, [r4, #4]
 80160f8:	60a2      	str	r2, [r4, #8]
 80160fa:	882a      	ldrh	r2, [r5, #0]
 80160fc:	78ab      	ldrb	r3, [r5, #2]
 80160fe:	81a2      	strh	r2, [r4, #12]
 8016100:	73a3      	strb	r3, [r4, #14]
 8016102:	4c20      	ldr	r4, [pc, #128]	; (8016184 <CS_init_modem+0x144>)
 8016104:	4620      	mov	r0, r4
 8016106:	f009 f804 	bl	801f112 <crs_strlen>
 801610a:	b283      	uxth	r3, r0
 801610c:	4622      	mov	r2, r4
 801610e:	2102      	movs	r1, #2
 8016110:	2001      	movs	r0, #1
 8016112:	f009 f841 	bl	801f198 <traceIF_itmPrint>
 8016116:	4620      	mov	r0, r4
 8016118:	f008 fffb 	bl	801f112 <crs_strlen>
 801611c:	b283      	uxth	r3, r0
 801611e:	4622      	mov	r2, r4
 8016120:	2102      	movs	r1, #2
 8016122:	2001      	movs	r0, #1
 8016124:	f009 f85a 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016128:	e028      	b.n	801617c <CS_init_modem+0x13c>
      retval = CELLULAR_analyze_error_report(&rsp_buf[0]);
 801612a:	4819      	ldr	r0, [pc, #100]	; (8016190 <CS_init_modem+0x150>)
 801612c:	f7ff fce8 	bl	8015b00 <CELLULAR_analyze_error_report>
 8016130:	4607      	mov	r7, r0
  if (retval == CELLULAR_ERROR)
 8016132:	2801      	cmp	r0, #1
 8016134:	d122      	bne.n	801617c <CS_init_modem+0x13c>
 8016136:	e000      	b.n	801613a <CS_init_modem+0xfa>
  CS_Status_t retval = CELLULAR_ERROR;
 8016138:	2701      	movs	r7, #1
    PRINT_ERR("<Cellular_Service> error during init")
 801613a:	4e18      	ldr	r6, [pc, #96]	; (801619c <CS_init_modem+0x15c>)
 801613c:	4d11      	ldr	r5, [pc, #68]	; (8016184 <CS_init_modem+0x144>)
 801613e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8016142:	4634      	mov	r4, r6
 8016144:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8016146:	6028      	str	r0, [r5, #0]
 8016148:	6069      	str	r1, [r5, #4]
 801614a:	60aa      	str	r2, [r5, #8]
 801614c:	60eb      	str	r3, [r5, #12]
 801614e:	4626      	mov	r6, r4
 8016150:	3510      	adds	r5, #16
 8016152:	4564      	cmp	r4, ip
 8016154:	d1f5      	bne.n	8016142 <CS_init_modem+0x102>
 8016156:	4c0b      	ldr	r4, [pc, #44]	; (8016184 <CS_init_modem+0x144>)
 8016158:	4620      	mov	r0, r4
 801615a:	f008 ffda 	bl	801f112 <crs_strlen>
 801615e:	b283      	uxth	r3, r0
 8016160:	4622      	mov	r2, r4
 8016162:	2110      	movs	r1, #16
 8016164:	2001      	movs	r0, #1
 8016166:	f009 f817 	bl	801f198 <traceIF_itmPrint>
 801616a:	4620      	mov	r0, r4
 801616c:	f008 ffd1 	bl	801f112 <crs_strlen>
 8016170:	b283      	uxth	r3, r0
 8016172:	4622      	mov	r2, r4
 8016174:	2110      	movs	r1, #16
 8016176:	2001      	movs	r0, #1
 8016178:	f009 f830 	bl	801f1dc <traceIF_uartPrint>
}
 801617c:	4638      	mov	r0, r7
 801617e:	b006      	add	sp, #24
 8016180:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8016184:	200047dc 	.word	0x200047dc
 8016188:	080313bc 	.word	0x080313bc
 801618c:	20003620 	.word	0x20003620
 8016190:	20003814 	.word	0x20003814
 8016194:	2000361c 	.word	0x2000361c
 8016198:	080313d4 	.word	0x080313d4
 801619c:	08031404 	.word	0x08031404

080161a0 <CS_get_device_info>:
{
 80161a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80161a2:	4607      	mov	r7, r0
  PRINT_API("CS_get_device_info")
 80161a4:	4c4b      	ldr	r4, [pc, #300]	; (80162d4 <CS_get_device_info+0x134>)
 80161a6:	4d4c      	ldr	r5, [pc, #304]	; (80162d8 <CS_get_device_info+0x138>)
 80161a8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80161aa:	6020      	str	r0, [r4, #0]
 80161ac:	6061      	str	r1, [r4, #4]
 80161ae:	60a2      	str	r2, [r4, #8]
 80161b0:	60e3      	str	r3, [r4, #12]
 80161b2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80161b4:	6120      	str	r0, [r4, #16]
 80161b6:	6161      	str	r1, [r4, #20]
 80161b8:	61a2      	str	r2, [r4, #24]
 80161ba:	4620      	mov	r0, r4
 80161bc:	f008 ffa9 	bl	801f112 <crs_strlen>
 80161c0:	b283      	uxth	r3, r0
 80161c2:	4622      	mov	r2, r4
 80161c4:	2104      	movs	r1, #4
 80161c6:	2001      	movs	r0, #1
 80161c8:	f008 ffe6 	bl	801f198 <traceIF_itmPrint>
 80161cc:	4620      	mov	r0, r4
 80161ce:	f008 ffa0 	bl	801f112 <crs_strlen>
 80161d2:	b283      	uxth	r3, r0
 80161d4:	4622      	mov	r2, r4
 80161d6:	2104      	movs	r1, #4
 80161d8:	2001      	movs	r0, #1
 80161da:	f008 ffff 	bl	801f1dc <traceIF_uartPrint>
  (void) memset((void *)&cs_ctxt_device_info, 0, sizeof(cs_ctxt_device_info));
 80161de:	4c3f      	ldr	r4, [pc, #252]	; (80162dc <CS_get_device_info+0x13c>)
 80161e0:	f44f 7281 	mov.w	r2, #258	; 0x102
 80161e4:	2100      	movs	r1, #0
 80161e6:	4620      	mov	r0, r4
 80161e8:	f00f fdb5 	bl	8025d56 <memset>
  cs_ctxt_device_info. field_requested = p_devinfo->field_requested;
 80161ec:	883b      	ldrh	r3, [r7, #0]
 80161ee:	8023      	strh	r3, [r4, #0]
  if (DATAPACK_writePtr(&cmd_buf[0],
 80161f0:	4622      	mov	r2, r4
 80161f2:	2117      	movs	r1, #23
 80161f4:	483a      	ldr	r0, [pc, #232]	; (80162e0 <CS_get_device_info+0x140>)
 80161f6:	f7f5 ff2d 	bl	800c054 <DATAPACK_writePtr>
 80161fa:	2800      	cmp	r0, #0
 80161fc:	d13f      	bne.n	801627e <CS_get_device_info+0xde>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_DEVICE_INFO, &cmd_buf[0], &rsp_buf[0]);
 80161fe:	4b39      	ldr	r3, [pc, #228]	; (80162e4 <CS_get_device_info+0x144>)
 8016200:	4a37      	ldr	r2, [pc, #220]	; (80162e0 <CS_get_device_info+0x140>)
 8016202:	2168      	movs	r1, #104	; 0x68
 8016204:	4838      	ldr	r0, [pc, #224]	; (80162e8 <CS_get_device_info+0x148>)
 8016206:	f9b0 0000 	ldrsh.w	r0, [r0]
 801620a:	f7f5 fceb 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 801620e:	4606      	mov	r6, r0
 8016210:	bb70      	cbnz	r0, 8016270 <CS_get_device_info+0xd0>
      PRINT_DBG("<Cellular_Service> Device infos received")
 8016212:	4d36      	ldr	r5, [pc, #216]	; (80162ec <CS_get_device_info+0x14c>)
 8016214:	4c2f      	ldr	r4, [pc, #188]	; (80162d4 <CS_get_device_info+0x134>)
 8016216:	f105 0e20 	add.w	lr, r5, #32
 801621a:	46ac      	mov	ip, r5
 801621c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016220:	6020      	str	r0, [r4, #0]
 8016222:	6061      	str	r1, [r4, #4]
 8016224:	60a2      	str	r2, [r4, #8]
 8016226:	60e3      	str	r3, [r4, #12]
 8016228:	4665      	mov	r5, ip
 801622a:	3410      	adds	r4, #16
 801622c:	45f4      	cmp	ip, lr
 801622e:	d1f4      	bne.n	801621a <CS_get_device_info+0x7a>
 8016230:	cd07      	ldmia	r5!, {r0, r1, r2}
 8016232:	6020      	str	r0, [r4, #0]
 8016234:	6061      	str	r1, [r4, #4]
 8016236:	60a2      	str	r2, [r4, #8]
 8016238:	882b      	ldrh	r3, [r5, #0]
 801623a:	81a3      	strh	r3, [r4, #12]
 801623c:	4c25      	ldr	r4, [pc, #148]	; (80162d4 <CS_get_device_info+0x134>)
 801623e:	4620      	mov	r0, r4
 8016240:	f008 ff67 	bl	801f112 <crs_strlen>
 8016244:	b283      	uxth	r3, r0
 8016246:	4622      	mov	r2, r4
 8016248:	2102      	movs	r1, #2
 801624a:	2001      	movs	r0, #1
 801624c:	f008 ffa4 	bl	801f198 <traceIF_itmPrint>
 8016250:	4620      	mov	r0, r4
 8016252:	f008 ff5e 	bl	801f112 <crs_strlen>
 8016256:	b283      	uxth	r3, r0
 8016258:	4622      	mov	r2, r4
 801625a:	2102      	movs	r1, #2
 801625c:	2001      	movs	r0, #1
 801625e:	f008 ffbd 	bl	801f1dc <traceIF_uartPrint>
      (void) memcpy((void *)p_devinfo, (void *)&cs_ctxt_device_info, sizeof(CS_DeviceInfo_t));
 8016262:	f44f 7281 	mov.w	r2, #258	; 0x102
 8016266:	491d      	ldr	r1, [pc, #116]	; (80162dc <CS_get_device_info+0x13c>)
 8016268:	4638      	mov	r0, r7
 801626a:	f00f fe51 	bl	8025f10 <memcpy>
  if (retval == CELLULAR_ERROR)
 801626e:	e02f      	b.n	80162d0 <CS_get_device_info+0x130>
      retval = CELLULAR_analyze_error_report(&rsp_buf[0]);
 8016270:	481c      	ldr	r0, [pc, #112]	; (80162e4 <CS_get_device_info+0x144>)
 8016272:	f7ff fc45 	bl	8015b00 <CELLULAR_analyze_error_report>
 8016276:	4606      	mov	r6, r0
  if (retval == CELLULAR_ERROR)
 8016278:	2801      	cmp	r0, #1
 801627a:	d129      	bne.n	80162d0 <CS_get_device_info+0x130>
 801627c:	e000      	b.n	8016280 <CS_get_device_info+0xe0>
  CS_Status_t retval = CELLULAR_ERROR;
 801627e:	2601      	movs	r6, #1
    PRINT_ERR("<Cellular_Service> error when getting device infos")
 8016280:	4c1b      	ldr	r4, [pc, #108]	; (80162f0 <CS_get_device_info+0x150>)
 8016282:	4d14      	ldr	r5, [pc, #80]	; (80162d4 <CS_get_device_info+0x134>)
 8016284:	f104 0730 	add.w	r7, r4, #48	; 0x30
 8016288:	46a4      	mov	ip, r4
 801628a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801628e:	6028      	str	r0, [r5, #0]
 8016290:	6069      	str	r1, [r5, #4]
 8016292:	60aa      	str	r2, [r5, #8]
 8016294:	60eb      	str	r3, [r5, #12]
 8016296:	4664      	mov	r4, ip
 8016298:	3510      	adds	r5, #16
 801629a:	45bc      	cmp	ip, r7
 801629c:	d1f4      	bne.n	8016288 <CS_get_device_info+0xe8>
 801629e:	cc07      	ldmia	r4!, {r0, r1, r2}
 80162a0:	6028      	str	r0, [r5, #0]
 80162a2:	6069      	str	r1, [r5, #4]
 80162a4:	60aa      	str	r2, [r5, #8]
 80162a6:	8823      	ldrh	r3, [r4, #0]
 80162a8:	81ab      	strh	r3, [r5, #12]
 80162aa:	4c0a      	ldr	r4, [pc, #40]	; (80162d4 <CS_get_device_info+0x134>)
 80162ac:	4620      	mov	r0, r4
 80162ae:	f008 ff30 	bl	801f112 <crs_strlen>
 80162b2:	b283      	uxth	r3, r0
 80162b4:	4622      	mov	r2, r4
 80162b6:	2110      	movs	r1, #16
 80162b8:	2001      	movs	r0, #1
 80162ba:	f008 ff6d 	bl	801f198 <traceIF_itmPrint>
 80162be:	4620      	mov	r0, r4
 80162c0:	f008 ff27 	bl	801f112 <crs_strlen>
 80162c4:	b283      	uxth	r3, r0
 80162c6:	4622      	mov	r2, r4
 80162c8:	2110      	movs	r1, #16
 80162ca:	2001      	movs	r0, #1
 80162cc:	f008 ff86 	bl	801f1dc <traceIF_uartPrint>
}
 80162d0:	4630      	mov	r0, r6
 80162d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80162d4:	200047dc 	.word	0x200047dc
 80162d8:	08031434 	.word	0x08031434
 80162dc:	200036a8 	.word	0x200036a8
 80162e0:	20003620 	.word	0x20003620
 80162e4:	20003814 	.word	0x20003814
 80162e8:	2000361c 	.word	0x2000361c
 80162ec:	08031450 	.word	0x08031450
 80162f0:	08031480 	.word	0x08031480

080162f4 <CS_register_net>:
{
 80162f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80162f6:	4607      	mov	r7, r0
 80162f8:	460e      	mov	r6, r1
  PRINT_API("CS_register_net")
 80162fa:	4c41      	ldr	r4, [pc, #260]	; (8016400 <CS_register_net+0x10c>)
 80162fc:	4d41      	ldr	r5, [pc, #260]	; (8016404 <CS_register_net+0x110>)
 80162fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016300:	6020      	str	r0, [r4, #0]
 8016302:	6061      	str	r1, [r4, #4]
 8016304:	60a2      	str	r2, [r4, #8]
 8016306:	60e3      	str	r3, [r4, #12]
 8016308:	cd03      	ldmia	r5!, {r0, r1}
 801630a:	6120      	str	r0, [r4, #16]
 801630c:	6161      	str	r1, [r4, #20]
 801630e:	782b      	ldrb	r3, [r5, #0]
 8016310:	7623      	strb	r3, [r4, #24]
 8016312:	4620      	mov	r0, r4
 8016314:	f008 fefd 	bl	801f112 <crs_strlen>
 8016318:	b283      	uxth	r3, r0
 801631a:	4622      	mov	r2, r4
 801631c:	2104      	movs	r1, #4
 801631e:	2001      	movs	r0, #1
 8016320:	f008 ff3a 	bl	801f198 <traceIF_itmPrint>
 8016324:	4620      	mov	r0, r4
 8016326:	f008 fef4 	bl	801f112 <crs_strlen>
 801632a:	b283      	uxth	r3, r0
 801632c:	4622      	mov	r2, r4
 801632e:	2104      	movs	r1, #4
 8016330:	2001      	movs	r0, #1
 8016332:	f008 ff53 	bl	801f1dc <traceIF_uartPrint>
  p_reg_status->optional_fields_presence = CS_RSF_NONE;
 8016336:	2300      	movs	r3, #0
 8016338:	8133      	strh	r3, [r6, #8]
  p_reg_status->CS_NetworkRegState = CS_NRS_UNKNOWN;
 801633a:	2304      	movs	r3, #4
 801633c:	80f3      	strh	r3, [r6, #6]
  p_reg_status->GPRS_NetworkRegState = CS_NRS_UNKNOWN;
 801633e:	80b3      	strh	r3, [r6, #4]
  p_reg_status->EPS_NetworkRegState = CS_NRS_UNKNOWN;
 8016340:	8073      	strh	r3, [r6, #2]
  (void) memcpy((void *)&cs_ctxt_operator, (void *)p_operator, sizeof(CS_OperatorSelector_t));
 8016342:	4d31      	ldr	r5, [pc, #196]	; (8016408 <CS_register_net+0x114>)
 8016344:	2448      	movs	r4, #72	; 0x48
 8016346:	4622      	mov	r2, r4
 8016348:	4639      	mov	r1, r7
 801634a:	4628      	mov	r0, r5
 801634c:	f00f fde0 	bl	8025f10 <memcpy>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016350:	462b      	mov	r3, r5
 8016352:	4622      	mov	r2, r4
 8016354:	2114      	movs	r1, #20
 8016356:	482d      	ldr	r0, [pc, #180]	; (801640c <CS_register_net+0x118>)
 8016358:	f7f5 feac 	bl	800c0b4 <DATAPACK_writeStruct>
 801635c:	b940      	cbnz	r0, 8016370 <CS_register_net+0x7c>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_REGISTER_NET, &cmd_buf[0], &rsp_buf[0]);
 801635e:	4b2c      	ldr	r3, [pc, #176]	; (8016410 <CS_register_net+0x11c>)
 8016360:	4a2a      	ldr	r2, [pc, #168]	; (801640c <CS_register_net+0x118>)
 8016362:	2169      	movs	r1, #105	; 0x69
 8016364:	482b      	ldr	r0, [pc, #172]	; (8016414 <CS_register_net+0x120>)
 8016366:	f9b0 0000 	ldrsh.w	r0, [r0]
 801636a:	f7f5 fc3b 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 801636e:	b1d0      	cbz	r0, 80163a6 <CS_register_net+0xb2>
    PRINT_ERR("<Cellular_Service> error during network registration ")
 8016370:	4c23      	ldr	r4, [pc, #140]	; (8016400 <CS_register_net+0x10c>)
 8016372:	2241      	movs	r2, #65	; 0x41
 8016374:	4928      	ldr	r1, [pc, #160]	; (8016418 <CS_register_net+0x124>)
 8016376:	4620      	mov	r0, r4
 8016378:	f00f fdca 	bl	8025f10 <memcpy>
 801637c:	4620      	mov	r0, r4
 801637e:	f008 fec8 	bl	801f112 <crs_strlen>
 8016382:	b283      	uxth	r3, r0
 8016384:	4622      	mov	r2, r4
 8016386:	2110      	movs	r1, #16
 8016388:	2001      	movs	r0, #1
 801638a:	f008 ff05 	bl	801f198 <traceIF_itmPrint>
 801638e:	4620      	mov	r0, r4
 8016390:	f008 febf 	bl	801f112 <crs_strlen>
 8016394:	b283      	uxth	r3, r0
 8016396:	4622      	mov	r2, r4
 8016398:	2110      	movs	r1, #16
 801639a:	2001      	movs	r0, #1
 801639c:	f008 ff1e 	bl	801f1dc <traceIF_uartPrint>
 80163a0:	2401      	movs	r4, #1
}
 80163a2:	4620      	mov	r0, r4
 80163a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 80163a6:	4633      	mov	r3, r6
 80163a8:	224e      	movs	r2, #78	; 0x4e
 80163aa:	2115      	movs	r1, #21
 80163ac:	4818      	ldr	r0, [pc, #96]	; (8016410 <CS_register_net+0x11c>)
 80163ae:	f7f5 ffa1 	bl	800c2f4 <DATAPACK_readStruct>
 80163b2:	4604      	mov	r4, r0
 80163b4:	2800      	cmp	r0, #0
 80163b6:	d1db      	bne.n	8016370 <CS_register_net+0x7c>
        PRINT_DBG("<Cellular_Service> Network registration done")
 80163b8:	4f18      	ldr	r7, [pc, #96]	; (801641c <CS_register_net+0x128>)
 80163ba:	4e11      	ldr	r6, [pc, #68]	; (8016400 <CS_register_net+0x10c>)
 80163bc:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 80163c0:	463d      	mov	r5, r7
 80163c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80163c4:	6030      	str	r0, [r6, #0]
 80163c6:	6071      	str	r1, [r6, #4]
 80163c8:	60b2      	str	r2, [r6, #8]
 80163ca:	60f3      	str	r3, [r6, #12]
 80163cc:	462f      	mov	r7, r5
 80163ce:	3610      	adds	r6, #16
 80163d0:	4565      	cmp	r5, ip
 80163d2:	d1f5      	bne.n	80163c0 <CS_register_net+0xcc>
 80163d4:	882b      	ldrh	r3, [r5, #0]
 80163d6:	8033      	strh	r3, [r6, #0]
 80163d8:	4d09      	ldr	r5, [pc, #36]	; (8016400 <CS_register_net+0x10c>)
 80163da:	4628      	mov	r0, r5
 80163dc:	f008 fe99 	bl	801f112 <crs_strlen>
 80163e0:	b283      	uxth	r3, r0
 80163e2:	462a      	mov	r2, r5
 80163e4:	2102      	movs	r1, #2
 80163e6:	2001      	movs	r0, #1
 80163e8:	f008 fed6 	bl	801f198 <traceIF_itmPrint>
 80163ec:	4628      	mov	r0, r5
 80163ee:	f008 fe90 	bl	801f112 <crs_strlen>
 80163f2:	b283      	uxth	r3, r0
 80163f4:	462a      	mov	r2, r5
 80163f6:	2102      	movs	r1, #2
 80163f8:	2001      	movs	r0, #1
 80163fa:	f008 feef 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80163fe:	e7d0      	b.n	80163a2 <CS_register_net+0xae>
 8016400:	200047dc 	.word	0x200047dc
 8016404:	080314c0 	.word	0x080314c0
 8016408:	200037bc 	.word	0x200037bc
 801640c:	20003620 	.word	0x20003620
 8016410:	20003814 	.word	0x20003814
 8016414:	2000361c 	.word	0x2000361c
 8016418:	08031510 	.word	0x08031510
 801641c:	080314dc 	.word	0x080314dc

08016420 <CS_subscribe_net_event>:
{
 8016420:	b570      	push	{r4, r5, r6, lr}
 8016422:	b082      	sub	sp, #8
 8016424:	460e      	mov	r6, r1
 8016426:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_subscribe_net_event")
 801642a:	4c5f      	ldr	r4, [pc, #380]	; (80165a8 <CS_subscribe_net_event+0x188>)
 801642c:	4d5f      	ldr	r5, [pc, #380]	; (80165ac <CS_subscribe_net_event+0x18c>)
 801642e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016430:	6020      	str	r0, [r4, #0]
 8016432:	6061      	str	r1, [r4, #4]
 8016434:	60a2      	str	r2, [r4, #8]
 8016436:	60e3      	str	r3, [r4, #12]
 8016438:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801643a:	6120      	str	r0, [r4, #16]
 801643c:	6161      	str	r1, [r4, #20]
 801643e:	61a2      	str	r2, [r4, #24]
 8016440:	61e3      	str	r3, [r4, #28]
 8016442:	4620      	mov	r0, r4
 8016444:	f008 fe65 	bl	801f112 <crs_strlen>
 8016448:	b283      	uxth	r3, r0
 801644a:	4622      	mov	r2, r4
 801644c:	2104      	movs	r1, #4
 801644e:	2001      	movs	r0, #1
 8016450:	f008 fea2 	bl	801f198 <traceIF_itmPrint>
 8016454:	4620      	mov	r0, r4
 8016456:	f008 fe5c 	bl	801f112 <crs_strlen>
 801645a:	b283      	uxth	r3, r0
 801645c:	4622      	mov	r2, r4
 801645e:	2104      	movs	r1, #4
 8016460:	2001      	movs	r0, #1
 8016462:	f008 febb 	bl	801f1dc <traceIF_uartPrint>
  if (event == CS_URCEVENT_EPS_NETWORK_REG_STAT)
 8016466:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801646a:	2b01      	cmp	r3, #1
 801646c:	d007      	beq.n	801647e <CS_subscribe_net_event+0x5e>
  else if (event == CS_URCEVENT_GPRS_NETWORK_REG_STAT)
 801646e:	3b02      	subs	r3, #2
 8016470:	2b05      	cmp	r3, #5
 8016472:	d863      	bhi.n	801653c <CS_subscribe_net_event+0x11c>
 8016474:	e8df f003 	tbb	[pc, r3]
 8016478:	44503e4a 	.word	0x44503e4a
 801647c:	5c56      	.short	0x5c56
    urc_eps_network_registration_callback = urc_callback;
 801647e:	4b4c      	ldr	r3, [pc, #304]	; (80165b0 <CS_subscribe_net_event+0x190>)
 8016480:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.eps_network_registration = CELLULAR_TRUE;
 8016482:	4b4c      	ldr	r3, [pc, #304]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016484:	2201      	movs	r2, #1
 8016486:	701a      	strb	r2, [r3, #0]
    if (DATAPACK_writeStruct(&cmd_buf[0],
 8016488:	f10d 0307 	add.w	r3, sp, #7
 801648c:	2201      	movs	r2, #1
 801648e:	2116      	movs	r1, #22
 8016490:	4849      	ldr	r0, [pc, #292]	; (80165b8 <CS_subscribe_net_event+0x198>)
 8016492:	f7f5 fe0f 	bl	800c0b4 <DATAPACK_writeStruct>
 8016496:	2800      	cmp	r0, #0
 8016498:	d077      	beq.n	801658a <CS_subscribe_net_event+0x16a>
      retval = CELLULAR_ERROR;
 801649a:	2601      	movs	r6, #1
    PRINT_ERR("<Cellular_Service> error when subscribing event")
 801649c:	4c47      	ldr	r4, [pc, #284]	; (80165bc <CS_subscribe_net_event+0x19c>)
 801649e:	4d42      	ldr	r5, [pc, #264]	; (80165a8 <CS_subscribe_net_event+0x188>)
 80164a0:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 80164a4:	46a4      	mov	ip, r4
 80164a6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80164aa:	6028      	str	r0, [r5, #0]
 80164ac:	6069      	str	r1, [r5, #4]
 80164ae:	60aa      	str	r2, [r5, #8]
 80164b0:	60eb      	str	r3, [r5, #12]
 80164b2:	4664      	mov	r4, ip
 80164b4:	3510      	adds	r5, #16
 80164b6:	45f4      	cmp	ip, lr
 80164b8:	d1f4      	bne.n	80164a4 <CS_subscribe_net_event+0x84>
 80164ba:	cc03      	ldmia	r4!, {r0, r1}
 80164bc:	6028      	str	r0, [r5, #0]
 80164be:	6069      	str	r1, [r5, #4]
 80164c0:	8822      	ldrh	r2, [r4, #0]
 80164c2:	78a3      	ldrb	r3, [r4, #2]
 80164c4:	812a      	strh	r2, [r5, #8]
 80164c6:	72ab      	strb	r3, [r5, #10]
 80164c8:	4c37      	ldr	r4, [pc, #220]	; (80165a8 <CS_subscribe_net_event+0x188>)
 80164ca:	4620      	mov	r0, r4
 80164cc:	f008 fe21 	bl	801f112 <crs_strlen>
 80164d0:	b283      	uxth	r3, r0
 80164d2:	4622      	mov	r2, r4
 80164d4:	2110      	movs	r1, #16
 80164d6:	2001      	movs	r0, #1
 80164d8:	f008 fe5e 	bl	801f198 <traceIF_itmPrint>
 80164dc:	4620      	mov	r0, r4
 80164de:	f008 fe18 	bl	801f112 <crs_strlen>
 80164e2:	b283      	uxth	r3, r0
 80164e4:	4622      	mov	r2, r4
 80164e6:	2110      	movs	r1, #16
 80164e8:	2001      	movs	r0, #1
 80164ea:	f008 fe77 	bl	801f1dc <traceIF_uartPrint>
}
 80164ee:	4630      	mov	r0, r6
 80164f0:	b002      	add	sp, #8
 80164f2:	bd70      	pop	{r4, r5, r6, pc}
    urc_gprs_network_registration_callback = urc_callback;
 80164f4:	4b32      	ldr	r3, [pc, #200]	; (80165c0 <CS_subscribe_net_event+0x1a0>)
 80164f6:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.gprs_network_registration = CELLULAR_TRUE;
 80164f8:	4b2e      	ldr	r3, [pc, #184]	; (80165b4 <CS_subscribe_net_event+0x194>)
 80164fa:	2201      	movs	r2, #1
 80164fc:	705a      	strb	r2, [r3, #1]
  if (retval != CELLULAR_ERROR)
 80164fe:	e7c3      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_cs_network_registration_callback = urc_callback;
 8016500:	4b30      	ldr	r3, [pc, #192]	; (80165c4 <CS_subscribe_net_event+0x1a4>)
 8016502:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.cs_network_registration = CELLULAR_TRUE;
 8016504:	4b2b      	ldr	r3, [pc, #172]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016506:	2201      	movs	r2, #1
 8016508:	709a      	strb	r2, [r3, #2]
  if (retval != CELLULAR_ERROR)
 801650a:	e7bd      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_eps_location_info_callback = urc_callback;
 801650c:	4b2e      	ldr	r3, [pc, #184]	; (80165c8 <CS_subscribe_net_event+0x1a8>)
 801650e:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.eps_location_info = CELLULAR_TRUE;
 8016510:	4b28      	ldr	r3, [pc, #160]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016512:	2201      	movs	r2, #1
 8016514:	70da      	strb	r2, [r3, #3]
  if (retval != CELLULAR_ERROR)
 8016516:	e7b7      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_gprs_location_info_callback = urc_callback;
 8016518:	4b2c      	ldr	r3, [pc, #176]	; (80165cc <CS_subscribe_net_event+0x1ac>)
 801651a:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.gprs_location_info = CELLULAR_TRUE;
 801651c:	4b25      	ldr	r3, [pc, #148]	; (80165b4 <CS_subscribe_net_event+0x194>)
 801651e:	2201      	movs	r2, #1
 8016520:	711a      	strb	r2, [r3, #4]
  if (retval != CELLULAR_ERROR)
 8016522:	e7b1      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_cs_location_info_callback = urc_callback;
 8016524:	4b2a      	ldr	r3, [pc, #168]	; (80165d0 <CS_subscribe_net_event+0x1b0>)
 8016526:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.cs_location_info = CELLULAR_TRUE;
 8016528:	4b22      	ldr	r3, [pc, #136]	; (80165b4 <CS_subscribe_net_event+0x194>)
 801652a:	2201      	movs	r2, #1
 801652c:	715a      	strb	r2, [r3, #5]
  if (retval != CELLULAR_ERROR)
 801652e:	e7ab      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_signal_quality_callback = urc_callback;
 8016530:	4b28      	ldr	r3, [pc, #160]	; (80165d4 <CS_subscribe_net_event+0x1b4>)
 8016532:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.signal_quality = CELLULAR_TRUE;
 8016534:	4b1f      	ldr	r3, [pc, #124]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016536:	2201      	movs	r2, #1
 8016538:	719a      	strb	r2, [r3, #6]
  if (retval != CELLULAR_ERROR)
 801653a:	e7a5      	b.n	8016488 <CS_subscribe_net_event+0x68>
    PRINT_ERR("<Cellular_Service> invalid event")
 801653c:	4c26      	ldr	r4, [pc, #152]	; (80165d8 <CS_subscribe_net_event+0x1b8>)
 801653e:	4d1a      	ldr	r5, [pc, #104]	; (80165a8 <CS_subscribe_net_event+0x188>)
 8016540:	f104 0c20 	add.w	ip, r4, #32
 8016544:	4626      	mov	r6, r4
 8016546:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8016548:	6028      	str	r0, [r5, #0]
 801654a:	6069      	str	r1, [r5, #4]
 801654c:	60aa      	str	r2, [r5, #8]
 801654e:	60eb      	str	r3, [r5, #12]
 8016550:	4634      	mov	r4, r6
 8016552:	3510      	adds	r5, #16
 8016554:	4566      	cmp	r6, ip
 8016556:	d1f5      	bne.n	8016544 <CS_subscribe_net_event+0x124>
 8016558:	cc07      	ldmia	r4!, {r0, r1, r2}
 801655a:	6028      	str	r0, [r5, #0]
 801655c:	6069      	str	r1, [r5, #4]
 801655e:	60aa      	str	r2, [r5, #8]
 8016560:	4c11      	ldr	r4, [pc, #68]	; (80165a8 <CS_subscribe_net_event+0x188>)
 8016562:	4620      	mov	r0, r4
 8016564:	f008 fdd5 	bl	801f112 <crs_strlen>
 8016568:	b283      	uxth	r3, r0
 801656a:	4622      	mov	r2, r4
 801656c:	2110      	movs	r1, #16
 801656e:	2001      	movs	r0, #1
 8016570:	f008 fe12 	bl	801f198 <traceIF_itmPrint>
 8016574:	4620      	mov	r0, r4
 8016576:	f008 fdcc 	bl	801f112 <crs_strlen>
 801657a:	b283      	uxth	r3, r0
 801657c:	4622      	mov	r2, r4
 801657e:	2110      	movs	r1, #16
 8016580:	2001      	movs	r0, #1
 8016582:	f008 fe2b 	bl	801f1dc <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 8016586:	2601      	movs	r6, #1
 8016588:	e009      	b.n	801659e <CS_subscribe_net_event+0x17e>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT, &cmd_buf[0], &rsp_buf[0]);
 801658a:	4b14      	ldr	r3, [pc, #80]	; (80165dc <CS_subscribe_net_event+0x1bc>)
 801658c:	4a0a      	ldr	r2, [pc, #40]	; (80165b8 <CS_subscribe_net_event+0x198>)
 801658e:	216a      	movs	r1, #106	; 0x6a
 8016590:	4813      	ldr	r0, [pc, #76]	; (80165e0 <CS_subscribe_net_event+0x1c0>)
 8016592:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016596:	f7f5 fb25 	bl	800bbe4 <AT_sendcmd>
      if (err != ATSTATUS_OK)
 801659a:	4606      	mov	r6, r0
 801659c:	b910      	cbnz	r0, 80165a4 <CS_subscribe_net_event+0x184>
  if (retval == CELLULAR_ERROR)
 801659e:	2e01      	cmp	r6, #1
 80165a0:	d1a5      	bne.n	80164ee <CS_subscribe_net_event+0xce>
 80165a2:	e77b      	b.n	801649c <CS_subscribe_net_event+0x7c>
        retval = CELLULAR_ERROR;
 80165a4:	2601      	movs	r6, #1
 80165a6:	e779      	b.n	801649c <CS_subscribe_net_event+0x7c>
 80165a8:	200047dc 	.word	0x200047dc
 80165ac:	08031554 	.word	0x08031554
 80165b0:	200038a0 	.word	0x200038a0
 80165b4:	20003804 	.word	0x20003804
 80165b8:	20003620 	.word	0x20003620
 80165bc:	080315a0 	.word	0x080315a0
 80165c0:	200038a8 	.word	0x200038a8
 80165c4:	20003898 	.word	0x20003898
 80165c8:	2000389c 	.word	0x2000389c
 80165cc:	200038a4 	.word	0x200038a4
 80165d0:	20003894 	.word	0x20003894
 80165d4:	200038cc 	.word	0x200038cc
 80165d8:	08031574 	.word	0x08031574
 80165dc:	20003814 	.word	0x20003814
 80165e0:	2000361c 	.word	0x2000361c

080165e4 <CS_attach_PS_domain>:
{
 80165e4:	b570      	push	{r4, r5, r6, lr}
  PRINT_API("CS_attach_PS_domain")
 80165e6:	4c41      	ldr	r4, [pc, #260]	; (80166ec <CS_attach_PS_domain+0x108>)
 80165e8:	4d41      	ldr	r5, [pc, #260]	; (80166f0 <CS_attach_PS_domain+0x10c>)
 80165ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80165ec:	6020      	str	r0, [r4, #0]
 80165ee:	6061      	str	r1, [r4, #4]
 80165f0:	60a2      	str	r2, [r4, #8]
 80165f2:	60e3      	str	r3, [r4, #12]
 80165f4:	cd07      	ldmia	r5!, {r0, r1, r2}
 80165f6:	6120      	str	r0, [r4, #16]
 80165f8:	6161      	str	r1, [r4, #20]
 80165fa:	61a2      	str	r2, [r4, #24]
 80165fc:	782b      	ldrb	r3, [r5, #0]
 80165fe:	7723      	strb	r3, [r4, #28]
 8016600:	4620      	mov	r0, r4
 8016602:	f008 fd86 	bl	801f112 <crs_strlen>
 8016606:	b283      	uxth	r3, r0
 8016608:	4622      	mov	r2, r4
 801660a:	2104      	movs	r1, #4
 801660c:	2001      	movs	r0, #1
 801660e:	f008 fdc3 	bl	801f198 <traceIF_itmPrint>
 8016612:	4620      	mov	r0, r4
 8016614:	f008 fd7d 	bl	801f112 <crs_strlen>
 8016618:	b283      	uxth	r3, r0
 801661a:	4622      	mov	r2, r4
 801661c:	2104      	movs	r1, #4
 801661e:	2001      	movs	r0, #1
 8016620:	f008 fddc 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016624:	2300      	movs	r3, #0
 8016626:	461a      	mov	r2, r3
 8016628:	211e      	movs	r1, #30
 801662a:	4832      	ldr	r0, [pc, #200]	; (80166f4 <CS_attach_PS_domain+0x110>)
 801662c:	f7f5 fd42 	bl	800c0b4 <DATAPACK_writeStruct>
 8016630:	b948      	cbnz	r0, 8016646 <CS_attach_PS_domain+0x62>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_ATTACH_PS_DOMAIN, &cmd_buf[0], &rsp_buf[0]);
 8016632:	4b31      	ldr	r3, [pc, #196]	; (80166f8 <CS_attach_PS_domain+0x114>)
 8016634:	4a2f      	ldr	r2, [pc, #188]	; (80166f4 <CS_attach_PS_domain+0x110>)
 8016636:	2170      	movs	r1, #112	; 0x70
 8016638:	4830      	ldr	r0, [pc, #192]	; (80166fc <CS_attach_PS_domain+0x118>)
 801663a:	f9b0 0000 	ldrsh.w	r0, [r0]
 801663e:	f7f5 fad1 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016642:	4606      	mov	r6, r0
 8016644:	b350      	cbz	r0, 801669c <CS_attach_PS_domain+0xb8>
    PRINT_ERR("<Cellular_Service> error when attaching PS domain")
 8016646:	4c2e      	ldr	r4, [pc, #184]	; (8016700 <CS_attach_PS_domain+0x11c>)
 8016648:	4d28      	ldr	r5, [pc, #160]	; (80166ec <CS_attach_PS_domain+0x108>)
 801664a:	f104 0630 	add.w	r6, r4, #48	; 0x30
 801664e:	46a4      	mov	ip, r4
 8016650:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016654:	6028      	str	r0, [r5, #0]
 8016656:	6069      	str	r1, [r5, #4]
 8016658:	60aa      	str	r2, [r5, #8]
 801665a:	60eb      	str	r3, [r5, #12]
 801665c:	4664      	mov	r4, ip
 801665e:	3510      	adds	r5, #16
 8016660:	45b4      	cmp	ip, r6
 8016662:	d1f4      	bne.n	801664e <CS_attach_PS_domain+0x6a>
 8016664:	cc07      	ldmia	r4!, {r0, r1, r2}
 8016666:	6028      	str	r0, [r5, #0]
 8016668:	6069      	str	r1, [r5, #4]
 801666a:	60aa      	str	r2, [r5, #8]
 801666c:	7823      	ldrb	r3, [r4, #0]
 801666e:	732b      	strb	r3, [r5, #12]
 8016670:	4c1e      	ldr	r4, [pc, #120]	; (80166ec <CS_attach_PS_domain+0x108>)
 8016672:	4620      	mov	r0, r4
 8016674:	f008 fd4d 	bl	801f112 <crs_strlen>
 8016678:	b283      	uxth	r3, r0
 801667a:	4622      	mov	r2, r4
 801667c:	2110      	movs	r1, #16
 801667e:	2001      	movs	r0, #1
 8016680:	f008 fd8a 	bl	801f198 <traceIF_itmPrint>
 8016684:	4620      	mov	r0, r4
 8016686:	f008 fd44 	bl	801f112 <crs_strlen>
 801668a:	b283      	uxth	r3, r0
 801668c:	4622      	mov	r2, r4
 801668e:	2110      	movs	r1, #16
 8016690:	2001      	movs	r0, #1
 8016692:	f008 fda3 	bl	801f1dc <traceIF_uartPrint>
 8016696:	2601      	movs	r6, #1
}
 8016698:	4630      	mov	r0, r6
 801669a:	bd70      	pop	{r4, r5, r6, pc}
      PRINT_DBG("<Cellular_Service> attach PS domain done")
 801669c:	4d19      	ldr	r5, [pc, #100]	; (8016704 <CS_attach_PS_domain+0x120>)
 801669e:	f105 0e20 	add.w	lr, r5, #32
 80166a2:	46ac      	mov	ip, r5
 80166a4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80166a8:	6020      	str	r0, [r4, #0]
 80166aa:	6061      	str	r1, [r4, #4]
 80166ac:	60a2      	str	r2, [r4, #8]
 80166ae:	60e3      	str	r3, [r4, #12]
 80166b0:	4665      	mov	r5, ip
 80166b2:	3410      	adds	r4, #16
 80166b4:	45f4      	cmp	ip, lr
 80166b6:	d1f4      	bne.n	80166a2 <CS_attach_PS_domain+0xbe>
 80166b8:	cd07      	ldmia	r5!, {r0, r1, r2}
 80166ba:	6020      	str	r0, [r4, #0]
 80166bc:	6061      	str	r1, [r4, #4]
 80166be:	60a2      	str	r2, [r4, #8]
 80166c0:	882b      	ldrh	r3, [r5, #0]
 80166c2:	81a3      	strh	r3, [r4, #12]
 80166c4:	4c09      	ldr	r4, [pc, #36]	; (80166ec <CS_attach_PS_domain+0x108>)
 80166c6:	4620      	mov	r0, r4
 80166c8:	f008 fd23 	bl	801f112 <crs_strlen>
 80166cc:	b283      	uxth	r3, r0
 80166ce:	4622      	mov	r2, r4
 80166d0:	2102      	movs	r1, #2
 80166d2:	2001      	movs	r0, #1
 80166d4:	f008 fd60 	bl	801f198 <traceIF_itmPrint>
 80166d8:	4620      	mov	r0, r4
 80166da:	f008 fd1a 	bl	801f112 <crs_strlen>
 80166de:	b283      	uxth	r3, r0
 80166e0:	4622      	mov	r2, r4
 80166e2:	2102      	movs	r1, #2
 80166e4:	2001      	movs	r0, #1
 80166e6:	f008 fd79 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80166ea:	e7d5      	b.n	8016698 <CS_attach_PS_domain+0xb4>
 80166ec:	200047dc 	.word	0x200047dc
 80166f0:	080315dc 	.word	0x080315dc
 80166f4:	20003620 	.word	0x20003620
 80166f8:	20003814 	.word	0x20003814
 80166fc:	2000361c 	.word	0x2000361c
 8016700:	0803162c 	.word	0x0803162c
 8016704:	080315fc 	.word	0x080315fc

08016708 <CS_get_attach_status>:
{
 8016708:	b570      	push	{r4, r5, r6, lr}
 801670a:	4606      	mov	r6, r0
  PRINT_API("CS_get_attachstatus")
 801670c:	4c35      	ldr	r4, [pc, #212]	; (80167e4 <CS_get_attach_status+0xdc>)
 801670e:	4d36      	ldr	r5, [pc, #216]	; (80167e8 <CS_get_attach_status+0xe0>)
 8016710:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016712:	6020      	str	r0, [r4, #0]
 8016714:	6061      	str	r1, [r4, #4]
 8016716:	60a2      	str	r2, [r4, #8]
 8016718:	60e3      	str	r3, [r4, #12]
 801671a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801671c:	6120      	str	r0, [r4, #16]
 801671e:	6161      	str	r1, [r4, #20]
 8016720:	61a2      	str	r2, [r4, #24]
 8016722:	782a      	ldrb	r2, [r5, #0]
 8016724:	7722      	strb	r2, [r4, #28]
 8016726:	4620      	mov	r0, r4
 8016728:	f008 fcf3 	bl	801f112 <crs_strlen>
 801672c:	b283      	uxth	r3, r0
 801672e:	4622      	mov	r2, r4
 8016730:	2104      	movs	r1, #4
 8016732:	2001      	movs	r0, #1
 8016734:	f008 fd30 	bl	801f198 <traceIF_itmPrint>
 8016738:	4620      	mov	r0, r4
 801673a:	f008 fcea 	bl	801f112 <crs_strlen>
 801673e:	b283      	uxth	r3, r0
 8016740:	4622      	mov	r2, r4
 8016742:	2104      	movs	r1, #4
 8016744:	2001      	movs	r0, #1
 8016746:	f008 fd49 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 801674a:	2300      	movs	r3, #0
 801674c:	461a      	mov	r2, r3
 801674e:	2104      	movs	r1, #4
 8016750:	4826      	ldr	r0, [pc, #152]	; (80167ec <CS_get_attach_status+0xe4>)
 8016752:	f7f5 fcaf 	bl	800c0b4 <DATAPACK_writeStruct>
 8016756:	b940      	cbnz	r0, 801676a <CS_get_attach_status+0x62>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_ATTACHSTATUS, &cmd_buf[0], &rsp_buf[0]);
 8016758:	4b25      	ldr	r3, [pc, #148]	; (80167f0 <CS_get_attach_status+0xe8>)
 801675a:	4a24      	ldr	r2, [pc, #144]	; (80167ec <CS_get_attach_status+0xe4>)
 801675c:	216d      	movs	r1, #109	; 0x6d
 801675e:	4825      	ldr	r0, [pc, #148]	; (80167f4 <CS_get_attach_status+0xec>)
 8016760:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016764:	f7f5 fa3e 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016768:	b1d0      	cbz	r0, 80167a0 <CS_get_attach_status+0x98>
    PRINT_ERR("<Cellular_Service> error when getting attachment status")
 801676a:	4c1e      	ldr	r4, [pc, #120]	; (80167e4 <CS_get_attach_status+0xdc>)
 801676c:	2243      	movs	r2, #67	; 0x43
 801676e:	4922      	ldr	r1, [pc, #136]	; (80167f8 <CS_get_attach_status+0xf0>)
 8016770:	4620      	mov	r0, r4
 8016772:	f00f fbcd 	bl	8025f10 <memcpy>
 8016776:	4620      	mov	r0, r4
 8016778:	f008 fccb 	bl	801f112 <crs_strlen>
 801677c:	b283      	uxth	r3, r0
 801677e:	4622      	mov	r2, r4
 8016780:	2110      	movs	r1, #16
 8016782:	2001      	movs	r0, #1
 8016784:	f008 fd08 	bl	801f198 <traceIF_itmPrint>
 8016788:	4620      	mov	r0, r4
 801678a:	f008 fcc2 	bl	801f112 <crs_strlen>
 801678e:	b283      	uxth	r3, r0
 8016790:	4622      	mov	r2, r4
 8016792:	2110      	movs	r1, #16
 8016794:	2001      	movs	r0, #1
 8016796:	f008 fd21 	bl	801f1dc <traceIF_uartPrint>
 801679a:	2401      	movs	r4, #1
}
 801679c:	4620      	mov	r0, r4
 801679e:	bd70      	pop	{r4, r5, r6, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 80167a0:	4633      	mov	r3, r6
 80167a2:	2201      	movs	r2, #1
 80167a4:	2113      	movs	r1, #19
 80167a6:	4812      	ldr	r0, [pc, #72]	; (80167f0 <CS_get_attach_status+0xe8>)
 80167a8:	f7f5 fda4 	bl	800c2f4 <DATAPACK_readStruct>
 80167ac:	4604      	mov	r4, r0
 80167ae:	2800      	cmp	r0, #0
 80167b0:	d1db      	bne.n	801676a <CS_get_attach_status+0x62>
        PRINT_DBG("<Cellular_Service> Attachment status received = %d", *p_attach)
 80167b2:	4d0c      	ldr	r5, [pc, #48]	; (80167e4 <CS_get_attach_status+0xdc>)
 80167b4:	7832      	ldrb	r2, [r6, #0]
 80167b6:	4911      	ldr	r1, [pc, #68]	; (80167fc <CS_get_attach_status+0xf4>)
 80167b8:	4628      	mov	r0, r5
 80167ba:	f00f fa59 	bl	8025c70 <sprintf>
 80167be:	4628      	mov	r0, r5
 80167c0:	f008 fca7 	bl	801f112 <crs_strlen>
 80167c4:	b283      	uxth	r3, r0
 80167c6:	462a      	mov	r2, r5
 80167c8:	2102      	movs	r1, #2
 80167ca:	2001      	movs	r0, #1
 80167cc:	f008 fce4 	bl	801f198 <traceIF_itmPrint>
 80167d0:	4628      	mov	r0, r5
 80167d2:	f008 fc9e 	bl	801f112 <crs_strlen>
 80167d6:	b283      	uxth	r3, r0
 80167d8:	462a      	mov	r2, r5
 80167da:	2102      	movs	r1, #2
 80167dc:	2001      	movs	r0, #1
 80167de:	f008 fcfd 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80167e2:	e7db      	b.n	801679c <CS_get_attach_status+0x94>
 80167e4:	200047dc 	.word	0x200047dc
 80167e8:	0803166c 	.word	0x0803166c
 80167ec:	20003620 	.word	0x20003620
 80167f0:	20003814 	.word	0x20003814
 80167f4:	2000361c 	.word	0x2000361c
 80167f8:	080316c4 	.word	0x080316c4
 80167fc:	0803168c 	.word	0x0803168c

08016800 <CS_get_net_status>:
{
 8016800:	b570      	push	{r4, r5, r6, lr}
 8016802:	4606      	mov	r6, r0
  PRINT_API("CS_get_netstatus")
 8016804:	4c44      	ldr	r4, [pc, #272]	; (8016918 <CS_get_net_status+0x118>)
 8016806:	4d45      	ldr	r5, [pc, #276]	; (801691c <CS_get_net_status+0x11c>)
 8016808:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801680a:	6020      	str	r0, [r4, #0]
 801680c:	6061      	str	r1, [r4, #4]
 801680e:	60a2      	str	r2, [r4, #8]
 8016810:	60e3      	str	r3, [r4, #12]
 8016812:	cd03      	ldmia	r5!, {r0, r1}
 8016814:	6120      	str	r0, [r4, #16]
 8016816:	6161      	str	r1, [r4, #20]
 8016818:	882b      	ldrh	r3, [r5, #0]
 801681a:	8323      	strh	r3, [r4, #24]
 801681c:	4620      	mov	r0, r4
 801681e:	f008 fc78 	bl	801f112 <crs_strlen>
 8016822:	b283      	uxth	r3, r0
 8016824:	4622      	mov	r2, r4
 8016826:	2104      	movs	r1, #4
 8016828:	2001      	movs	r0, #1
 801682a:	f008 fcb5 	bl	801f198 <traceIF_itmPrint>
 801682e:	4620      	mov	r0, r4
 8016830:	f008 fc6f 	bl	801f112 <crs_strlen>
 8016834:	b283      	uxth	r3, r0
 8016836:	4622      	mov	r2, r4
 8016838:	2104      	movs	r1, #4
 801683a:	2001      	movs	r0, #1
 801683c:	f008 fcce 	bl	801f1dc <traceIF_uartPrint>
  p_reg_status->optional_fields_presence = CS_RSF_NONE;
 8016840:	2200      	movs	r2, #0
 8016842:	8132      	strh	r2, [r6, #8]
  p_reg_status->CS_NetworkRegState = CS_NRS_UNKNOWN;
 8016844:	2104      	movs	r1, #4
 8016846:	80f1      	strh	r1, [r6, #6]
  p_reg_status->GPRS_NetworkRegState = CS_NRS_UNKNOWN;
 8016848:	80b1      	strh	r1, [r6, #4]
  p_reg_status->EPS_NetworkRegState = CS_NRS_UNKNOWN;
 801684a:	8071      	strh	r1, [r6, #2]
  if (DATAPACK_writeStruct(&cmd_buf[0],
 801684c:	4613      	mov	r3, r2
 801684e:	4834      	ldr	r0, [pc, #208]	; (8016920 <CS_get_net_status+0x120>)
 8016850:	f7f5 fc30 	bl	800c0b4 <DATAPACK_writeStruct>
 8016854:	b940      	cbnz	r0, 8016868 <CS_get_net_status+0x68>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_NETSTATUS, &cmd_buf[0], &rsp_buf[0]);
 8016856:	4b33      	ldr	r3, [pc, #204]	; (8016924 <CS_get_net_status+0x124>)
 8016858:	4a31      	ldr	r2, [pc, #196]	; (8016920 <CS_get_net_status+0x120>)
 801685a:	216c      	movs	r1, #108	; 0x6c
 801685c:	4832      	ldr	r0, [pc, #200]	; (8016928 <CS_get_net_status+0x128>)
 801685e:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016862:	f7f5 f9bf 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016866:	b338      	cbz	r0, 80168b8 <CS_get_net_status+0xb8>
    PRINT_ERR("<Cellular_Service> error when getting net status")
 8016868:	4c30      	ldr	r4, [pc, #192]	; (801692c <CS_get_net_status+0x12c>)
 801686a:	4d2b      	ldr	r5, [pc, #172]	; (8016918 <CS_get_net_status+0x118>)
 801686c:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 8016870:	4626      	mov	r6, r4
 8016872:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8016874:	6028      	str	r0, [r5, #0]
 8016876:	6069      	str	r1, [r5, #4]
 8016878:	60aa      	str	r2, [r5, #8]
 801687a:	60eb      	str	r3, [r5, #12]
 801687c:	4634      	mov	r4, r6
 801687e:	3510      	adds	r5, #16
 8016880:	4566      	cmp	r6, ip
 8016882:	d1f5      	bne.n	8016870 <CS_get_net_status+0x70>
 8016884:	cc07      	ldmia	r4!, {r0, r1, r2}
 8016886:	6028      	str	r0, [r5, #0]
 8016888:	6069      	str	r1, [r5, #4]
 801688a:	60aa      	str	r2, [r5, #8]
 801688c:	4c22      	ldr	r4, [pc, #136]	; (8016918 <CS_get_net_status+0x118>)
 801688e:	4620      	mov	r0, r4
 8016890:	f008 fc3f 	bl	801f112 <crs_strlen>
 8016894:	b283      	uxth	r3, r0
 8016896:	4622      	mov	r2, r4
 8016898:	2110      	movs	r1, #16
 801689a:	2001      	movs	r0, #1
 801689c:	f008 fc7c 	bl	801f198 <traceIF_itmPrint>
 80168a0:	4620      	mov	r0, r4
 80168a2:	f008 fc36 	bl	801f112 <crs_strlen>
 80168a6:	b283      	uxth	r3, r0
 80168a8:	4622      	mov	r2, r4
 80168aa:	2110      	movs	r1, #16
 80168ac:	2001      	movs	r0, #1
 80168ae:	f008 fc95 	bl	801f1dc <traceIF_uartPrint>
 80168b2:	2401      	movs	r4, #1
}
 80168b4:	4620      	mov	r0, r4
 80168b6:	bd70      	pop	{r4, r5, r6, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 80168b8:	4633      	mov	r3, r6
 80168ba:	224e      	movs	r2, #78	; 0x4e
 80168bc:	2115      	movs	r1, #21
 80168be:	4819      	ldr	r0, [pc, #100]	; (8016924 <CS_get_net_status+0x124>)
 80168c0:	f7f5 fd18 	bl	800c2f4 <DATAPACK_readStruct>
 80168c4:	4604      	mov	r4, r0
 80168c6:	2800      	cmp	r0, #0
 80168c8:	d1ce      	bne.n	8016868 <CS_get_net_status+0x68>
        PRINT_DBG("<Cellular_Service> Net status received")
 80168ca:	4e19      	ldr	r6, [pc, #100]	; (8016930 <CS_get_net_status+0x130>)
 80168cc:	4d12      	ldr	r5, [pc, #72]	; (8016918 <CS_get_net_status+0x118>)
 80168ce:	f106 0e20 	add.w	lr, r6, #32
 80168d2:	46b4      	mov	ip, r6
 80168d4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80168d8:	6028      	str	r0, [r5, #0]
 80168da:	6069      	str	r1, [r5, #4]
 80168dc:	60aa      	str	r2, [r5, #8]
 80168de:	60eb      	str	r3, [r5, #12]
 80168e0:	4666      	mov	r6, ip
 80168e2:	3510      	adds	r5, #16
 80168e4:	45f4      	cmp	ip, lr
 80168e6:	d1f4      	bne.n	80168d2 <CS_get_net_status+0xd2>
 80168e8:	ce07      	ldmia	r6!, {r0, r1, r2}
 80168ea:	6028      	str	r0, [r5, #0]
 80168ec:	6069      	str	r1, [r5, #4]
 80168ee:	60aa      	str	r2, [r5, #8]
 80168f0:	4d09      	ldr	r5, [pc, #36]	; (8016918 <CS_get_net_status+0x118>)
 80168f2:	4628      	mov	r0, r5
 80168f4:	f008 fc0d 	bl	801f112 <crs_strlen>
 80168f8:	b283      	uxth	r3, r0
 80168fa:	462a      	mov	r2, r5
 80168fc:	2102      	movs	r1, #2
 80168fe:	2001      	movs	r0, #1
 8016900:	f008 fc4a 	bl	801f198 <traceIF_itmPrint>
 8016904:	4628      	mov	r0, r5
 8016906:	f008 fc04 	bl	801f112 <crs_strlen>
 801690a:	b283      	uxth	r3, r0
 801690c:	462a      	mov	r2, r5
 801690e:	2102      	movs	r1, #2
 8016910:	2001      	movs	r0, #1
 8016912:	f008 fc63 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016916:	e7cd      	b.n	80168b4 <CS_get_net_status+0xb4>
 8016918:	200047dc 	.word	0x200047dc
 801691c:	08031708 	.word	0x08031708
 8016920:	20003620 	.word	0x20003620
 8016924:	20003814 	.word	0x20003814
 8016928:	2000361c 	.word	0x2000361c
 801692c:	08031750 	.word	0x08031750
 8016930:	08031724 	.word	0x08031724

08016934 <CS_get_signal_quality>:
{
 8016934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016938:	b082      	sub	sp, #8
 801693a:	4607      	mov	r7, r0
  PRINT_API("CS_get_signal_quality")
 801693c:	4c41      	ldr	r4, [pc, #260]	; (8016a44 <CS_get_signal_quality+0x110>)
 801693e:	4d42      	ldr	r5, [pc, #264]	; (8016a48 <CS_get_signal_quality+0x114>)
 8016940:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016942:	6020      	str	r0, [r4, #0]
 8016944:	6061      	str	r1, [r4, #4]
 8016946:	60a2      	str	r2, [r4, #8]
 8016948:	60e3      	str	r3, [r4, #12]
 801694a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801694c:	6120      	str	r0, [r4, #16]
 801694e:	6161      	str	r1, [r4, #20]
 8016950:	61a2      	str	r2, [r4, #24]
 8016952:	882a      	ldrh	r2, [r5, #0]
 8016954:	78ab      	ldrb	r3, [r5, #2]
 8016956:	83a2      	strh	r2, [r4, #28]
 8016958:	77a3      	strb	r3, [r4, #30]
 801695a:	4620      	mov	r0, r4
 801695c:	f008 fbd9 	bl	801f112 <crs_strlen>
 8016960:	b283      	uxth	r3, r0
 8016962:	4622      	mov	r2, r4
 8016964:	2104      	movs	r1, #4
 8016966:	2001      	movs	r0, #1
 8016968:	f008 fc16 	bl	801f198 <traceIF_itmPrint>
 801696c:	4620      	mov	r0, r4
 801696e:	f008 fbd0 	bl	801f112 <crs_strlen>
 8016972:	b283      	uxth	r3, r0
 8016974:	4622      	mov	r2, r4
 8016976:	2104      	movs	r1, #4
 8016978:	2001      	movs	r0, #1
 801697a:	f008 fc2f 	bl	801f1dc <traceIF_uartPrint>
  CS_SignalQuality_t local_sig_qual = {0};
 801697e:	2300      	movs	r3, #0
 8016980:	f8ad 3004 	strh.w	r3, [sp, #4]
  if (DATAPACK_writePtr(&cmd_buf[0],
 8016984:	aa01      	add	r2, sp, #4
 8016986:	211d      	movs	r1, #29
 8016988:	4830      	ldr	r0, [pc, #192]	; (8016a4c <CS_get_signal_quality+0x118>)
 801698a:	f7f5 fb63 	bl	800c054 <DATAPACK_writePtr>
 801698e:	b948      	cbnz	r0, 80169a4 <CS_get_signal_quality+0x70>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_SIGNAL_QUALITY, &cmd_buf[0], &rsp_buf[0]);
 8016990:	4b2f      	ldr	r3, [pc, #188]	; (8016a50 <CS_get_signal_quality+0x11c>)
 8016992:	4a2e      	ldr	r2, [pc, #184]	; (8016a4c <CS_get_signal_quality+0x118>)
 8016994:	216e      	movs	r1, #110	; 0x6e
 8016996:	482f      	ldr	r0, [pc, #188]	; (8016a54 <CS_get_signal_quality+0x120>)
 8016998:	f9b0 0000 	ldrsh.w	r0, [r0]
 801699c:	f7f5 f922 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 80169a0:	4680      	mov	r8, r0
 80169a2:	b330      	cbz	r0, 80169f2 <CS_get_signal_quality+0xbe>
    PRINT_ERR("<Cellular_Service> error when getting signal quality")
 80169a4:	4e2c      	ldr	r6, [pc, #176]	; (8016a58 <CS_get_signal_quality+0x124>)
 80169a6:	4d27      	ldr	r5, [pc, #156]	; (8016a44 <CS_get_signal_quality+0x110>)
 80169a8:	f106 0740 	add.w	r7, r6, #64	; 0x40
 80169ac:	4634      	mov	r4, r6
 80169ae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80169b0:	6028      	str	r0, [r5, #0]
 80169b2:	6069      	str	r1, [r5, #4]
 80169b4:	60aa      	str	r2, [r5, #8]
 80169b6:	60eb      	str	r3, [r5, #12]
 80169b8:	4626      	mov	r6, r4
 80169ba:	3510      	adds	r5, #16
 80169bc:	42bc      	cmp	r4, r7
 80169be:	d1f5      	bne.n	80169ac <CS_get_signal_quality+0x78>
 80169c0:	4c20      	ldr	r4, [pc, #128]	; (8016a44 <CS_get_signal_quality+0x110>)
 80169c2:	4620      	mov	r0, r4
 80169c4:	f008 fba5 	bl	801f112 <crs_strlen>
 80169c8:	b283      	uxth	r3, r0
 80169ca:	4622      	mov	r2, r4
 80169cc:	2110      	movs	r1, #16
 80169ce:	2001      	movs	r0, #1
 80169d0:	f008 fbe2 	bl	801f198 <traceIF_itmPrint>
 80169d4:	4620      	mov	r0, r4
 80169d6:	f008 fb9c 	bl	801f112 <crs_strlen>
 80169da:	b283      	uxth	r3, r0
 80169dc:	4622      	mov	r2, r4
 80169de:	2110      	movs	r1, #16
 80169e0:	2001      	movs	r0, #1
 80169e2:	f008 fbfb 	bl	801f1dc <traceIF_uartPrint>
 80169e6:	f04f 0801 	mov.w	r8, #1
}
 80169ea:	4640      	mov	r0, r8
 80169ec:	b002      	add	sp, #8
 80169ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      PRINT_DBG("<Cellular_Service> Signal quality information received")
 80169f2:	4d1a      	ldr	r5, [pc, #104]	; (8016a5c <CS_get_signal_quality+0x128>)
 80169f4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80169f8:	462e      	mov	r6, r5
 80169fa:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80169fc:	6020      	str	r0, [r4, #0]
 80169fe:	6061      	str	r1, [r4, #4]
 8016a00:	60a2      	str	r2, [r4, #8]
 8016a02:	60e3      	str	r3, [r4, #12]
 8016a04:	4635      	mov	r5, r6
 8016a06:	3410      	adds	r4, #16
 8016a08:	4566      	cmp	r6, ip
 8016a0a:	d1f5      	bne.n	80169f8 <CS_get_signal_quality+0xc4>
 8016a0c:	cd07      	ldmia	r5!, {r0, r1, r2}
 8016a0e:	6020      	str	r0, [r4, #0]
 8016a10:	6061      	str	r1, [r4, #4]
 8016a12:	60a2      	str	r2, [r4, #8]
 8016a14:	4c0b      	ldr	r4, [pc, #44]	; (8016a44 <CS_get_signal_quality+0x110>)
 8016a16:	4620      	mov	r0, r4
 8016a18:	f008 fb7b 	bl	801f112 <crs_strlen>
 8016a1c:	b283      	uxth	r3, r0
 8016a1e:	4622      	mov	r2, r4
 8016a20:	2102      	movs	r1, #2
 8016a22:	2001      	movs	r0, #1
 8016a24:	f008 fbb8 	bl	801f198 <traceIF_itmPrint>
 8016a28:	4620      	mov	r0, r4
 8016a2a:	f008 fb72 	bl	801f112 <crs_strlen>
 8016a2e:	b283      	uxth	r3, r0
 8016a30:	4622      	mov	r2, r4
 8016a32:	2102      	movs	r1, #2
 8016a34:	2001      	movs	r0, #1
 8016a36:	f008 fbd1 	bl	801f1dc <traceIF_uartPrint>
      (void) memcpy((void *)p_sig_qual, (void *)&local_sig_qual, sizeof(CS_SignalQuality_t));
 8016a3a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8016a3e:	803b      	strh	r3, [r7, #0]
  if (retval == CELLULAR_ERROR)
 8016a40:	e7d3      	b.n	80169ea <CS_get_signal_quality+0xb6>
 8016a42:	bf00      	nop
 8016a44:	200047dc 	.word	0x200047dc
 8016a48:	0803178c 	.word	0x0803178c
 8016a4c:	20003620 	.word	0x20003620
 8016a50:	20003814 	.word	0x20003814
 8016a54:	2000361c 	.word	0x2000361c
 8016a58:	080317e8 	.word	0x080317e8
 8016a5c:	080317ac 	.word	0x080317ac

08016a60 <CS_activate_pdn>:
{
 8016a60:	b530      	push	{r4, r5, lr}
 8016a62:	b083      	sub	sp, #12
 8016a64:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_activate_pdn for cid=%d", cid)
 8016a68:	4c30      	ldr	r4, [pc, #192]	; (8016b2c <CS_activate_pdn+0xcc>)
 8016a6a:	b2c2      	uxtb	r2, r0
 8016a6c:	4930      	ldr	r1, [pc, #192]	; (8016b30 <CS_activate_pdn+0xd0>)
 8016a6e:	4620      	mov	r0, r4
 8016a70:	f00f f8fe 	bl	8025c70 <sprintf>
 8016a74:	4620      	mov	r0, r4
 8016a76:	f008 fb4c 	bl	801f112 <crs_strlen>
 8016a7a:	b283      	uxth	r3, r0
 8016a7c:	4622      	mov	r2, r4
 8016a7e:	2104      	movs	r1, #4
 8016a80:	2001      	movs	r0, #1
 8016a82:	f008 fb89 	bl	801f198 <traceIF_itmPrint>
 8016a86:	4620      	mov	r0, r4
 8016a88:	f008 fb43 	bl	801f112 <crs_strlen>
 8016a8c:	b283      	uxth	r3, r0
 8016a8e:	4622      	mov	r2, r4
 8016a90:	2104      	movs	r1, #4
 8016a92:	2001      	movs	r0, #1
 8016a94:	f008 fba2 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016a98:	f10d 0307 	add.w	r3, sp, #7
 8016a9c:	2201      	movs	r2, #1
 8016a9e:	2121      	movs	r1, #33	; 0x21
 8016aa0:	4824      	ldr	r0, [pc, #144]	; (8016b34 <CS_activate_pdn+0xd4>)
 8016aa2:	f7f5 fb07 	bl	800c0b4 <DATAPACK_writeStruct>
 8016aa6:	b948      	cbnz	r0, 8016abc <CS_activate_pdn+0x5c>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_ACTIVATE_PDN, &cmd_buf[0], &rsp_buf[0]);
 8016aa8:	4b23      	ldr	r3, [pc, #140]	; (8016b38 <CS_activate_pdn+0xd8>)
 8016aaa:	4a22      	ldr	r2, [pc, #136]	; (8016b34 <CS_activate_pdn+0xd4>)
 8016aac:	216f      	movs	r1, #111	; 0x6f
 8016aae:	4823      	ldr	r0, [pc, #140]	; (8016b3c <CS_activate_pdn+0xdc>)
 8016ab0:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016ab4:	f7f5 f896 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016ab8:	4604      	mov	r4, r0
 8016aba:	b1e0      	cbz	r0, 8016af6 <CS_activate_pdn+0x96>
    PRINT_ERR("<Cellular_Service> error when PDN %cid activation", cid)
 8016abc:	4c1b      	ldr	r4, [pc, #108]	; (8016b2c <CS_activate_pdn+0xcc>)
 8016abe:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016ac2:	491f      	ldr	r1, [pc, #124]	; (8016b40 <CS_activate_pdn+0xe0>)
 8016ac4:	4620      	mov	r0, r4
 8016ac6:	f00f f8d3 	bl	8025c70 <sprintf>
 8016aca:	4620      	mov	r0, r4
 8016acc:	f008 fb21 	bl	801f112 <crs_strlen>
 8016ad0:	b283      	uxth	r3, r0
 8016ad2:	4622      	mov	r2, r4
 8016ad4:	2110      	movs	r1, #16
 8016ad6:	2001      	movs	r0, #1
 8016ad8:	f008 fb5e 	bl	801f198 <traceIF_itmPrint>
 8016adc:	4620      	mov	r0, r4
 8016ade:	f008 fb18 	bl	801f112 <crs_strlen>
 8016ae2:	b283      	uxth	r3, r0
 8016ae4:	4622      	mov	r2, r4
 8016ae6:	2110      	movs	r1, #16
 8016ae8:	2001      	movs	r0, #1
 8016aea:	f008 fb77 	bl	801f1dc <traceIF_uartPrint>
 8016aee:	2401      	movs	r4, #1
}
 8016af0:	4620      	mov	r0, r4
 8016af2:	b003      	add	sp, #12
 8016af4:	bd30      	pop	{r4, r5, pc}
      PRINT_DBG("<Cellular_Service> PDN %d connected", cid)
 8016af6:	4d0d      	ldr	r5, [pc, #52]	; (8016b2c <CS_activate_pdn+0xcc>)
 8016af8:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016afc:	4911      	ldr	r1, [pc, #68]	; (8016b44 <CS_activate_pdn+0xe4>)
 8016afe:	4628      	mov	r0, r5
 8016b00:	f00f f8b6 	bl	8025c70 <sprintf>
 8016b04:	4628      	mov	r0, r5
 8016b06:	f008 fb04 	bl	801f112 <crs_strlen>
 8016b0a:	b283      	uxth	r3, r0
 8016b0c:	462a      	mov	r2, r5
 8016b0e:	2102      	movs	r1, #2
 8016b10:	2001      	movs	r0, #1
 8016b12:	f008 fb41 	bl	801f198 <traceIF_itmPrint>
 8016b16:	4628      	mov	r0, r5
 8016b18:	f008 fafb 	bl	801f112 <crs_strlen>
 8016b1c:	b283      	uxth	r3, r0
 8016b1e:	462a      	mov	r2, r5
 8016b20:	2102      	movs	r1, #2
 8016b22:	2001      	movs	r0, #1
 8016b24:	f008 fb5a 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016b28:	e7e2      	b.n	8016af0 <CS_activate_pdn+0x90>
 8016b2a:	bf00      	nop
 8016b2c:	200047dc 	.word	0x200047dc
 8016b30:	08031828 	.word	0x08031828
 8016b34:	20003620 	.word	0x20003620
 8016b38:	20003814 	.word	0x20003814
 8016b3c:	2000361c 	.word	0x2000361c
 8016b40:	08031878 	.word	0x08031878
 8016b44:	0803184c 	.word	0x0803184c

08016b48 <CS_define_pdn>:
{
 8016b48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016b4a:	b0a3      	sub	sp, #140	; 0x8c
 8016b4c:	4604      	mov	r4, r0
 8016b4e:	460e      	mov	r6, r1
 8016b50:	4617      	mov	r7, r2
  PRINT_API("CS_define_pdn for cid=%d", cid)
 8016b52:	4d4e      	ldr	r5, [pc, #312]	; (8016c8c <CS_define_pdn+0x144>)
 8016b54:	4602      	mov	r2, r0
 8016b56:	494e      	ldr	r1, [pc, #312]	; (8016c90 <CS_define_pdn+0x148>)
 8016b58:	4628      	mov	r0, r5
 8016b5a:	f00f f889 	bl	8025c70 <sprintf>
 8016b5e:	4628      	mov	r0, r5
 8016b60:	f008 fad7 	bl	801f112 <crs_strlen>
 8016b64:	b283      	uxth	r3, r0
 8016b66:	462a      	mov	r2, r5
 8016b68:	2104      	movs	r1, #4
 8016b6a:	2001      	movs	r0, #1
 8016b6c:	f008 fb14 	bl	801f198 <traceIF_itmPrint>
 8016b70:	4628      	mov	r0, r5
 8016b72:	f008 face 	bl	801f112 <crs_strlen>
 8016b76:	b283      	uxth	r3, r0
 8016b78:	462a      	mov	r2, r5
 8016b7a:	2104      	movs	r1, #4
 8016b7c:	2001      	movs	r0, #1
 8016b7e:	f008 fb2d 	bl	801f1dc <traceIF_uartPrint>
  if ((cid < CS_PDN_USER_CONFIG_1) || (cid > CS_PDN_USER_CONFIG_5))
 8016b82:	1e63      	subs	r3, r4, #1
 8016b84:	b2db      	uxtb	r3, r3
 8016b86:	2b04      	cmp	r3, #4
 8016b88:	d827      	bhi.n	8016bda <CS_define_pdn+0x92>
  else if (apn == NULL)
 8016b8a:	2e00      	cmp	r6, #0
 8016b8c:	d057      	beq.n	8016c3e <CS_define_pdn+0xf6>
    (void) memset((void *)&pdn_infos, 0, sizeof(csint_pdn_infos_t));
 8016b8e:	2282      	movs	r2, #130	; 0x82
 8016b90:	2100      	movs	r1, #0
 8016b92:	a801      	add	r0, sp, #4
 8016b94:	f00f f8df 	bl	8025d56 <memset>
    pdn_infos.conf_id = cid;
 8016b98:	f88d 4004 	strb.w	r4, [sp, #4]
    (void) memcpy((void *)&pdn_infos.apn[0],
 8016b9c:	4630      	mov	r0, r6
 8016b9e:	f7e9 fb29 	bl	80001f4 <strlen>
 8016ba2:	4602      	mov	r2, r0
 8016ba4:	4631      	mov	r1, r6
 8016ba6:	f10d 0005 	add.w	r0, sp, #5
 8016baa:	f00f f9b1 	bl	8025f10 <memcpy>
    (void) memcpy((void *)&pdn_infos.pdn_conf, (void *)pdn_conf, sizeof(CS_PDN_configuration_t));
 8016bae:	2241      	movs	r2, #65	; 0x41
 8016bb0:	4639      	mov	r1, r7
 8016bb2:	f10d 0045 	add.w	r0, sp, #69	; 0x45
 8016bb6:	f00f f9ab 	bl	8025f10 <memcpy>
    if (DATAPACK_writePtr(&cmd_buf[0],
 8016bba:	aa01      	add	r2, sp, #4
 8016bbc:	2123      	movs	r1, #35	; 0x23
 8016bbe:	4835      	ldr	r0, [pc, #212]	; (8016c94 <CS_define_pdn+0x14c>)
 8016bc0:	f7f5 fa48 	bl	800c054 <DATAPACK_writePtr>
 8016bc4:	bb00      	cbnz	r0, 8016c08 <CS_define_pdn+0xc0>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_DEFINE_PDN, &cmd_buf[0], &rsp_buf[0]);
 8016bc6:	4b34      	ldr	r3, [pc, #208]	; (8016c98 <CS_define_pdn+0x150>)
 8016bc8:	4a32      	ldr	r2, [pc, #200]	; (8016c94 <CS_define_pdn+0x14c>)
 8016bca:	2176      	movs	r1, #118	; 0x76
 8016bcc:	4833      	ldr	r0, [pc, #204]	; (8016c9c <CS_define_pdn+0x154>)
 8016bce:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016bd2:	f7f5 f807 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8016bd6:	b380      	cbz	r0, 8016c3a <CS_define_pdn+0xf2>
 8016bd8:	e016      	b.n	8016c08 <CS_define_pdn+0xc0>
    PRINT_ERR("<Cellular_Service> selected configuration id %d can not be set by user", cid)
 8016bda:	4622      	mov	r2, r4
 8016bdc:	4930      	ldr	r1, [pc, #192]	; (8016ca0 <CS_define_pdn+0x158>)
 8016bde:	4628      	mov	r0, r5
 8016be0:	f00f f846 	bl	8025c70 <sprintf>
 8016be4:	4628      	mov	r0, r5
 8016be6:	f008 fa94 	bl	801f112 <crs_strlen>
 8016bea:	b283      	uxth	r3, r0
 8016bec:	462a      	mov	r2, r5
 8016bee:	2110      	movs	r1, #16
 8016bf0:	2001      	movs	r0, #1
 8016bf2:	f008 fad1 	bl	801f198 <traceIF_itmPrint>
 8016bf6:	4628      	mov	r0, r5
 8016bf8:	f008 fa8b 	bl	801f112 <crs_strlen>
 8016bfc:	b283      	uxth	r3, r0
 8016bfe:	462a      	mov	r2, r5
 8016c00:	2110      	movs	r1, #16
 8016c02:	2001      	movs	r0, #1
 8016c04:	f008 faea 	bl	801f1dc <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when defining PDN %d", cid)
 8016c08:	4d20      	ldr	r5, [pc, #128]	; (8016c8c <CS_define_pdn+0x144>)
 8016c0a:	4622      	mov	r2, r4
 8016c0c:	4925      	ldr	r1, [pc, #148]	; (8016ca4 <CS_define_pdn+0x15c>)
 8016c0e:	4628      	mov	r0, r5
 8016c10:	f00f f82e 	bl	8025c70 <sprintf>
 8016c14:	4628      	mov	r0, r5
 8016c16:	f008 fa7c 	bl	801f112 <crs_strlen>
 8016c1a:	b283      	uxth	r3, r0
 8016c1c:	462a      	mov	r2, r5
 8016c1e:	2110      	movs	r1, #16
 8016c20:	2001      	movs	r0, #1
 8016c22:	f008 fab9 	bl	801f198 <traceIF_itmPrint>
 8016c26:	4628      	mov	r0, r5
 8016c28:	f008 fa73 	bl	801f112 <crs_strlen>
 8016c2c:	b283      	uxth	r3, r0
 8016c2e:	462a      	mov	r2, r5
 8016c30:	2110      	movs	r1, #16
 8016c32:	2001      	movs	r0, #1
 8016c34:	f008 fad2 	bl	801f1dc <traceIF_uartPrint>
 8016c38:	2001      	movs	r0, #1
}
 8016c3a:	b023      	add	sp, #140	; 0x8c
 8016c3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINT_ERR("<Cellular_Service> apn must be non NULL")
 8016c3e:	4f1a      	ldr	r7, [pc, #104]	; (8016ca8 <CS_define_pdn+0x160>)
 8016c40:	4d12      	ldr	r5, [pc, #72]	; (8016c8c <CS_define_pdn+0x144>)
 8016c42:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8016c46:	463e      	mov	r6, r7
 8016c48:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8016c4a:	6028      	str	r0, [r5, #0]
 8016c4c:	6069      	str	r1, [r5, #4]
 8016c4e:	60aa      	str	r2, [r5, #8]
 8016c50:	60eb      	str	r3, [r5, #12]
 8016c52:	4637      	mov	r7, r6
 8016c54:	3510      	adds	r5, #16
 8016c56:	4566      	cmp	r6, ip
 8016c58:	d1f5      	bne.n	8016c46 <CS_define_pdn+0xfe>
 8016c5a:	8832      	ldrh	r2, [r6, #0]
 8016c5c:	78b3      	ldrb	r3, [r6, #2]
 8016c5e:	802a      	strh	r2, [r5, #0]
 8016c60:	70ab      	strb	r3, [r5, #2]
 8016c62:	4d0a      	ldr	r5, [pc, #40]	; (8016c8c <CS_define_pdn+0x144>)
 8016c64:	4628      	mov	r0, r5
 8016c66:	f008 fa54 	bl	801f112 <crs_strlen>
 8016c6a:	b283      	uxth	r3, r0
 8016c6c:	462a      	mov	r2, r5
 8016c6e:	2110      	movs	r1, #16
 8016c70:	2001      	movs	r0, #1
 8016c72:	f008 fa91 	bl	801f198 <traceIF_itmPrint>
 8016c76:	4628      	mov	r0, r5
 8016c78:	f008 fa4b 	bl	801f112 <crs_strlen>
 8016c7c:	b283      	uxth	r3, r0
 8016c7e:	462a      	mov	r2, r5
 8016c80:	2110      	movs	r1, #16
 8016c82:	2001      	movs	r0, #1
 8016c84:	f008 faaa 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016c88:	e7be      	b.n	8016c08 <CS_define_pdn+0xc0>
 8016c8a:	bf00      	nop
 8016c8c:	200047dc 	.word	0x200047dc
 8016c90:	080318b8 	.word	0x080318b8
 8016c94:	20003620 	.word	0x20003620
 8016c98:	20003814 	.word	0x20003814
 8016c9c:	2000361c 	.word	0x2000361c
 8016ca0:	080318dc 	.word	0x080318dc
 8016ca4:	08031964 	.word	0x08031964
 8016ca8:	08031930 	.word	0x08031930

08016cac <CS_set_default_pdn>:
{
 8016cac:	b530      	push	{r4, r5, lr}
 8016cae:	b083      	sub	sp, #12
 8016cb0:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_set_default_pdn (conf_id=%d)", cid)
 8016cb4:	4c30      	ldr	r4, [pc, #192]	; (8016d78 <CS_set_default_pdn+0xcc>)
 8016cb6:	b2c2      	uxtb	r2, r0
 8016cb8:	4930      	ldr	r1, [pc, #192]	; (8016d7c <CS_set_default_pdn+0xd0>)
 8016cba:	4620      	mov	r0, r4
 8016cbc:	f00e ffd8 	bl	8025c70 <sprintf>
 8016cc0:	4620      	mov	r0, r4
 8016cc2:	f008 fa26 	bl	801f112 <crs_strlen>
 8016cc6:	b283      	uxth	r3, r0
 8016cc8:	4622      	mov	r2, r4
 8016cca:	2104      	movs	r1, #4
 8016ccc:	2001      	movs	r0, #1
 8016cce:	f008 fa63 	bl	801f198 <traceIF_itmPrint>
 8016cd2:	4620      	mov	r0, r4
 8016cd4:	f008 fa1d 	bl	801f112 <crs_strlen>
 8016cd8:	b283      	uxth	r3, r0
 8016cda:	4622      	mov	r2, r4
 8016cdc:	2104      	movs	r1, #4
 8016cde:	2001      	movs	r0, #1
 8016ce0:	f008 fa7c 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016ce4:	f10d 0307 	add.w	r3, sp, #7
 8016ce8:	2201      	movs	r2, #1
 8016cea:	2124      	movs	r1, #36	; 0x24
 8016cec:	4824      	ldr	r0, [pc, #144]	; (8016d80 <CS_set_default_pdn+0xd4>)
 8016cee:	f7f5 f9e1 	bl	800c0b4 <DATAPACK_writeStruct>
 8016cf2:	b948      	cbnz	r0, 8016d08 <CS_set_default_pdn+0x5c>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SET_DEFAULT_PDN, &cmd_buf[0], &rsp_buf[0]);
 8016cf4:	4b23      	ldr	r3, [pc, #140]	; (8016d84 <CS_set_default_pdn+0xd8>)
 8016cf6:	4a22      	ldr	r2, [pc, #136]	; (8016d80 <CS_set_default_pdn+0xd4>)
 8016cf8:	2177      	movs	r1, #119	; 0x77
 8016cfa:	4823      	ldr	r0, [pc, #140]	; (8016d88 <CS_set_default_pdn+0xdc>)
 8016cfc:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016d00:	f7f4 ff70 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016d04:	4604      	mov	r4, r0
 8016d06:	b1e0      	cbz	r0, 8016d42 <CS_set_default_pdn+0x96>
    PRINT_ERR("<Cellular_Service> error when setting default PDN %d", cid)
 8016d08:	4c1b      	ldr	r4, [pc, #108]	; (8016d78 <CS_set_default_pdn+0xcc>)
 8016d0a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016d0e:	491f      	ldr	r1, [pc, #124]	; (8016d8c <CS_set_default_pdn+0xe0>)
 8016d10:	4620      	mov	r0, r4
 8016d12:	f00e ffad 	bl	8025c70 <sprintf>
 8016d16:	4620      	mov	r0, r4
 8016d18:	f008 f9fb 	bl	801f112 <crs_strlen>
 8016d1c:	b283      	uxth	r3, r0
 8016d1e:	4622      	mov	r2, r4
 8016d20:	2110      	movs	r1, #16
 8016d22:	2001      	movs	r0, #1
 8016d24:	f008 fa38 	bl	801f198 <traceIF_itmPrint>
 8016d28:	4620      	mov	r0, r4
 8016d2a:	f008 f9f2 	bl	801f112 <crs_strlen>
 8016d2e:	b283      	uxth	r3, r0
 8016d30:	4622      	mov	r2, r4
 8016d32:	2110      	movs	r1, #16
 8016d34:	2001      	movs	r0, #1
 8016d36:	f008 fa51 	bl	801f1dc <traceIF_uartPrint>
 8016d3a:	2401      	movs	r4, #1
}
 8016d3c:	4620      	mov	r0, r4
 8016d3e:	b003      	add	sp, #12
 8016d40:	bd30      	pop	{r4, r5, pc}
      PRINT_DBG("<Cellular_Service> PDN %d set as default", cid)
 8016d42:	4d0d      	ldr	r5, [pc, #52]	; (8016d78 <CS_set_default_pdn+0xcc>)
 8016d44:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016d48:	4911      	ldr	r1, [pc, #68]	; (8016d90 <CS_set_default_pdn+0xe4>)
 8016d4a:	4628      	mov	r0, r5
 8016d4c:	f00e ff90 	bl	8025c70 <sprintf>
 8016d50:	4628      	mov	r0, r5
 8016d52:	f008 f9de 	bl	801f112 <crs_strlen>
 8016d56:	b283      	uxth	r3, r0
 8016d58:	462a      	mov	r2, r5
 8016d5a:	2102      	movs	r1, #2
 8016d5c:	2001      	movs	r0, #1
 8016d5e:	f008 fa1b 	bl	801f198 <traceIF_itmPrint>
 8016d62:	4628      	mov	r0, r5
 8016d64:	f008 f9d5 	bl	801f112 <crs_strlen>
 8016d68:	b283      	uxth	r3, r0
 8016d6a:	462a      	mov	r2, r5
 8016d6c:	2102      	movs	r1, #2
 8016d6e:	2001      	movs	r0, #1
 8016d70:	f008 fa34 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016d74:	e7e2      	b.n	8016d3c <CS_set_default_pdn+0x90>
 8016d76:	bf00      	nop
 8016d78:	200047dc 	.word	0x200047dc
 8016d7c:	080319a0 	.word	0x080319a0
 8016d80:	20003620 	.word	0x20003620
 8016d84:	20003814 	.word	0x20003814
 8016d88:	2000361c 	.word	0x2000361c
 8016d8c:	080319fc 	.word	0x080319fc
 8016d90:	080319cc 	.word	0x080319cc

08016d94 <CS_get_dev_IP_address>:
{
 8016d94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016d98:	b094      	sub	sp, #80	; 0x50
 8016d9a:	460d      	mov	r5, r1
 8016d9c:	4616      	mov	r6, r2
 8016d9e:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_get_dev_IP_address (for conf_id=%d)", cid)
 8016da2:	4c4f      	ldr	r4, [pc, #316]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016da4:	b2c2      	uxtb	r2, r0
 8016da6:	494f      	ldr	r1, [pc, #316]	; (8016ee4 <CS_get_dev_IP_address+0x150>)
 8016da8:	4620      	mov	r0, r4
 8016daa:	f00e ff61 	bl	8025c70 <sprintf>
 8016dae:	4620      	mov	r0, r4
 8016db0:	f008 f9af 	bl	801f112 <crs_strlen>
 8016db4:	b283      	uxth	r3, r0
 8016db6:	4622      	mov	r2, r4
 8016db8:	2104      	movs	r1, #4
 8016dba:	2001      	movs	r0, #1
 8016dbc:	f008 f9ec 	bl	801f198 <traceIF_itmPrint>
 8016dc0:	4620      	mov	r0, r4
 8016dc2:	f008 f9a6 	bl	801f112 <crs_strlen>
 8016dc6:	b283      	uxth	r3, r0
 8016dc8:	4622      	mov	r2, r4
 8016dca:	2104      	movs	r1, #4
 8016dcc:	2001      	movs	r0, #1
 8016dce:	f008 fa05 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016dd2:	f10d 0307 	add.w	r3, sp, #7
 8016dd6:	2201      	movs	r2, #1
 8016dd8:	2125      	movs	r1, #37	; 0x25
 8016dda:	4843      	ldr	r0, [pc, #268]	; (8016ee8 <CS_get_dev_IP_address+0x154>)
 8016ddc:	f7f5 f96a 	bl	800c0b4 <DATAPACK_writeStruct>
 8016de0:	b940      	cbnz	r0, 8016df4 <CS_get_dev_IP_address+0x60>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_IP_ADDRESS, &cmd_buf[0], &rsp_buf[0]);
 8016de2:	4b42      	ldr	r3, [pc, #264]	; (8016eec <CS_get_dev_IP_address+0x158>)
 8016de4:	4a40      	ldr	r2, [pc, #256]	; (8016ee8 <CS_get_dev_IP_address+0x154>)
 8016de6:	2175      	movs	r1, #117	; 0x75
 8016de8:	4841      	ldr	r0, [pc, #260]	; (8016ef0 <CS_get_dev_IP_address+0x15c>)
 8016dea:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016dee:	f7f4 fef9 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016df2:	b1e0      	cbz	r0, 8016e2e <CS_get_dev_IP_address+0x9a>
    PRINT_ERR("<Cellular_Service> error when getting IP address information")
 8016df4:	4c3a      	ldr	r4, [pc, #232]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016df6:	2248      	movs	r2, #72	; 0x48
 8016df8:	493e      	ldr	r1, [pc, #248]	; (8016ef4 <CS_get_dev_IP_address+0x160>)
 8016dfa:	4620      	mov	r0, r4
 8016dfc:	f00f f888 	bl	8025f10 <memcpy>
 8016e00:	4620      	mov	r0, r4
 8016e02:	f008 f986 	bl	801f112 <crs_strlen>
 8016e06:	b283      	uxth	r3, r0
 8016e08:	4622      	mov	r2, r4
 8016e0a:	2110      	movs	r1, #16
 8016e0c:	2001      	movs	r0, #1
 8016e0e:	f008 f9c3 	bl	801f198 <traceIF_itmPrint>
 8016e12:	4620      	mov	r0, r4
 8016e14:	f008 f97d 	bl	801f112 <crs_strlen>
 8016e18:	b283      	uxth	r3, r0
 8016e1a:	4622      	mov	r2, r4
 8016e1c:	2110      	movs	r1, #16
 8016e1e:	2001      	movs	r0, #1
 8016e20:	f008 f9dc 	bl	801f1dc <traceIF_uartPrint>
 8016e24:	2401      	movs	r4, #1
}
 8016e26:	4620      	mov	r0, r4
 8016e28:	b014      	add	sp, #80	; 0x50
 8016e2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 8016e2e:	ab03      	add	r3, sp, #12
 8016e30:	2241      	movs	r2, #65	; 0x41
 8016e32:	2125      	movs	r1, #37	; 0x25
 8016e34:	482d      	ldr	r0, [pc, #180]	; (8016eec <CS_get_dev_IP_address+0x158>)
 8016e36:	f7f5 fa5d 	bl	800c2f4 <DATAPACK_readStruct>
 8016e3a:	4604      	mov	r4, r0
 8016e3c:	2800      	cmp	r0, #0
 8016e3e:	d1d9      	bne.n	8016df4 <CS_get_dev_IP_address+0x60>
        PRINT_DBG("<Cellular_Service> IP address information received")
 8016e40:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 8016efc <CS_get_dev_IP_address+0x168>
 8016e44:	4f26      	ldr	r7, [pc, #152]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016e46:	f10e 0830 	add.w	r8, lr, #48	; 0x30
 8016e4a:	46f4      	mov	ip, lr
 8016e4c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016e50:	6038      	str	r0, [r7, #0]
 8016e52:	6079      	str	r1, [r7, #4]
 8016e54:	60ba      	str	r2, [r7, #8]
 8016e56:	60fb      	str	r3, [r7, #12]
 8016e58:	46e6      	mov	lr, ip
 8016e5a:	3710      	adds	r7, #16
 8016e5c:	45c4      	cmp	ip, r8
 8016e5e:	d1f4      	bne.n	8016e4a <CS_get_dev_IP_address+0xb6>
 8016e60:	e8be 0003 	ldmia.w	lr!, {r0, r1}
 8016e64:	6038      	str	r0, [r7, #0]
 8016e66:	6079      	str	r1, [r7, #4]
 8016e68:	4f1d      	ldr	r7, [pc, #116]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016e6a:	4638      	mov	r0, r7
 8016e6c:	f008 f951 	bl	801f112 <crs_strlen>
 8016e70:	b283      	uxth	r3, r0
 8016e72:	463a      	mov	r2, r7
 8016e74:	2102      	movs	r1, #2
 8016e76:	2001      	movs	r0, #1
 8016e78:	f008 f98e 	bl	801f198 <traceIF_itmPrint>
 8016e7c:	4638      	mov	r0, r7
 8016e7e:	f008 f948 	bl	801f112 <crs_strlen>
 8016e82:	b283      	uxth	r3, r0
 8016e84:	463a      	mov	r2, r7
 8016e86:	2102      	movs	r1, #2
 8016e88:	2001      	movs	r0, #1
 8016e8a:	f008 f9a7 	bl	801f1dc <traceIF_uartPrint>
        *ip_addr_type = ip_addr_info.ip_addr_type;
 8016e8e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016e92:	702b      	strb	r3, [r5, #0]
        (void) memcpy((void *)p_ip_addr_value,
 8016e94:	f10d 000d 	add.w	r0, sp, #13
 8016e98:	f7e9 f9ac 	bl	80001f4 <strlen>
 8016e9c:	4602      	mov	r2, r0
 8016e9e:	f10d 010d 	add.w	r1, sp, #13
 8016ea2:	4630      	mov	r0, r6
 8016ea4:	f00f f834 	bl	8025f10 <memcpy>
        PRINT_DBG("<Cellular_Service> IP address = %s (type = %d)",
 8016ea8:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016eac:	f10d 020d 	add.w	r2, sp, #13
 8016eb0:	4911      	ldr	r1, [pc, #68]	; (8016ef8 <CS_get_dev_IP_address+0x164>)
 8016eb2:	4638      	mov	r0, r7
 8016eb4:	f00e fedc 	bl	8025c70 <sprintf>
 8016eb8:	4638      	mov	r0, r7
 8016eba:	f008 f92a 	bl	801f112 <crs_strlen>
 8016ebe:	b283      	uxth	r3, r0
 8016ec0:	463a      	mov	r2, r7
 8016ec2:	2102      	movs	r1, #2
 8016ec4:	2001      	movs	r0, #1
 8016ec6:	f008 f967 	bl	801f198 <traceIF_itmPrint>
 8016eca:	4638      	mov	r0, r7
 8016ecc:	f008 f921 	bl	801f112 <crs_strlen>
 8016ed0:	b283      	uxth	r3, r0
 8016ed2:	463a      	mov	r2, r7
 8016ed4:	2102      	movs	r1, #2
 8016ed6:	2001      	movs	r0, #1
 8016ed8:	f008 f980 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016edc:	e7a3      	b.n	8016e26 <CS_get_dev_IP_address+0x92>
 8016ede:	bf00      	nop
 8016ee0:	200047dc 	.word	0x200047dc
 8016ee4:	08031a3c 	.word	0x08031a3c
 8016ee8:	20003620 	.word	0x20003620
 8016eec:	20003814 	.word	0x20003814
 8016ef0:	2000361c 	.word	0x2000361c
 8016ef4:	08031ad8 	.word	0x08031ad8
 8016ef8:	08031aa4 	.word	0x08031aa4
 8016efc:	08031a6c 	.word	0x08031a6c

08016f00 <CS_subscribe_modem_event>:
{
 8016f00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016f02:	b083      	sub	sp, #12
 8016f04:	460e      	mov	r6, r1
 8016f06:	f8ad 0006 	strh.w	r0, [sp, #6]
  PRINT_API("CS_subscribe_modem_event")
 8016f0a:	4d3b      	ldr	r5, [pc, #236]	; (8016ff8 <CS_subscribe_modem_event+0xf8>)
 8016f0c:	4c3b      	ldr	r4, [pc, #236]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016f0e:	f105 0720 	add.w	r7, r5, #32
 8016f12:	46ac      	mov	ip, r5
 8016f14:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016f18:	6020      	str	r0, [r4, #0]
 8016f1a:	6061      	str	r1, [r4, #4]
 8016f1c:	60a2      	str	r2, [r4, #8]
 8016f1e:	60e3      	str	r3, [r4, #12]
 8016f20:	4665      	mov	r5, ip
 8016f22:	3410      	adds	r4, #16
 8016f24:	45bc      	cmp	ip, r7
 8016f26:	d1f4      	bne.n	8016f12 <CS_subscribe_modem_event+0x12>
 8016f28:	f8bc 3000 	ldrh.w	r3, [ip]
 8016f2c:	8023      	strh	r3, [r4, #0]
 8016f2e:	4c33      	ldr	r4, [pc, #204]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016f30:	4620      	mov	r0, r4
 8016f32:	f008 f8ee 	bl	801f112 <crs_strlen>
 8016f36:	b283      	uxth	r3, r0
 8016f38:	4622      	mov	r2, r4
 8016f3a:	2104      	movs	r1, #4
 8016f3c:	2001      	movs	r0, #1
 8016f3e:	f008 f92b 	bl	801f198 <traceIF_itmPrint>
 8016f42:	4620      	mov	r0, r4
 8016f44:	f008 f8e5 	bl	801f112 <crs_strlen>
 8016f48:	b283      	uxth	r3, r0
 8016f4a:	4622      	mov	r2, r4
 8016f4c:	2104      	movs	r1, #4
 8016f4e:	2001      	movs	r0, #1
 8016f50:	f008 f944 	bl	801f1dc <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016f54:	f10d 0306 	add.w	r3, sp, #6
 8016f58:	2202      	movs	r2, #2
 8016f5a:	2129      	movs	r1, #41	; 0x29
 8016f5c:	4828      	ldr	r0, [pc, #160]	; (8017000 <CS_subscribe_modem_event+0x100>)
 8016f5e:	f7f5 f8a9 	bl	800c0b4 <DATAPACK_writeStruct>
 8016f62:	b948      	cbnz	r0, 8016f78 <CS_subscribe_modem_event+0x78>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SUSBCRIBE_MODEM_EVENT, &cmd_buf[0], &rsp_buf[0]);
 8016f64:	4b27      	ldr	r3, [pc, #156]	; (8017004 <CS_subscribe_modem_event+0x104>)
 8016f66:	4a26      	ldr	r2, [pc, #152]	; (8017000 <CS_subscribe_modem_event+0x100>)
 8016f68:	2185      	movs	r1, #133	; 0x85
 8016f6a:	4827      	ldr	r0, [pc, #156]	; (8017008 <CS_subscribe_modem_event+0x108>)
 8016f6c:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016f70:	f7f4 fe38 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016f74:	4607      	mov	r7, r0
 8016f76:	b1d8      	cbz	r0, 8016fb0 <CS_subscribe_modem_event+0xb0>
    PRINT_ERR("<Cellular_Service> error when subscribing modem event")
 8016f78:	4c20      	ldr	r4, [pc, #128]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016f7a:	2241      	movs	r2, #65	; 0x41
 8016f7c:	4923      	ldr	r1, [pc, #140]	; (801700c <CS_subscribe_modem_event+0x10c>)
 8016f7e:	4620      	mov	r0, r4
 8016f80:	f00e ffc6 	bl	8025f10 <memcpy>
 8016f84:	4620      	mov	r0, r4
 8016f86:	f008 f8c4 	bl	801f112 <crs_strlen>
 8016f8a:	b283      	uxth	r3, r0
 8016f8c:	4622      	mov	r2, r4
 8016f8e:	2110      	movs	r1, #16
 8016f90:	2001      	movs	r0, #1
 8016f92:	f008 f901 	bl	801f198 <traceIF_itmPrint>
 8016f96:	4620      	mov	r0, r4
 8016f98:	f008 f8bb 	bl	801f112 <crs_strlen>
 8016f9c:	b283      	uxth	r3, r0
 8016f9e:	4622      	mov	r2, r4
 8016fa0:	2110      	movs	r1, #16
 8016fa2:	2001      	movs	r0, #1
 8016fa4:	f008 f91a 	bl	801f1dc <traceIF_uartPrint>
 8016fa8:	2701      	movs	r7, #1
}
 8016faa:	4638      	mov	r0, r7
 8016fac:	b003      	add	sp, #12
 8016fae:	bdf0      	pop	{r4, r5, r6, r7, pc}
      urc_modem_event_callback = modem_evt_cb;
 8016fb0:	4b17      	ldr	r3, [pc, #92]	; (8017010 <CS_subscribe_modem_event+0x110>)
 8016fb2:	601e      	str	r6, [r3, #0]
      PRINT_DBG("<Cellular_Service> modem events subscribed")
 8016fb4:	4e17      	ldr	r6, [pc, #92]	; (8017014 <CS_subscribe_modem_event+0x114>)
 8016fb6:	4625      	mov	r5, r4
 8016fb8:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8016fbc:	4634      	mov	r4, r6
 8016fbe:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8016fc0:	6028      	str	r0, [r5, #0]
 8016fc2:	6069      	str	r1, [r5, #4]
 8016fc4:	60aa      	str	r2, [r5, #8]
 8016fc6:	60eb      	str	r3, [r5, #12]
 8016fc8:	4626      	mov	r6, r4
 8016fca:	3510      	adds	r5, #16
 8016fcc:	4564      	cmp	r4, ip
 8016fce:	d1f5      	bne.n	8016fbc <CS_subscribe_modem_event+0xbc>
 8016fd0:	4c0a      	ldr	r4, [pc, #40]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016fd2:	4620      	mov	r0, r4
 8016fd4:	f008 f89d 	bl	801f112 <crs_strlen>
 8016fd8:	b283      	uxth	r3, r0
 8016fda:	4622      	mov	r2, r4
 8016fdc:	2102      	movs	r1, #2
 8016fde:	2001      	movs	r0, #1
 8016fe0:	f008 f8da 	bl	801f198 <traceIF_itmPrint>
 8016fe4:	4620      	mov	r0, r4
 8016fe6:	f008 f894 	bl	801f112 <crs_strlen>
 8016fea:	b283      	uxth	r3, r0
 8016fec:	4622      	mov	r2, r4
 8016fee:	2102      	movs	r1, #2
 8016ff0:	2001      	movs	r0, #1
 8016ff2:	f008 f8f3 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016ff6:	e7d8      	b.n	8016faa <CS_subscribe_modem_event+0xaa>
 8016ff8:	08031b20 	.word	0x08031b20
 8016ffc:	200047dc 	.word	0x200047dc
 8017000:	20003620 	.word	0x20003620
 8017004:	20003814 	.word	0x20003814
 8017008:	2000361c 	.word	0x2000361c
 801700c:	08031b74 	.word	0x08031b74
 8017010:	200038ac 	.word	0x200038ac
 8017014:	08031b44 	.word	0x08031b44

08017018 <CS_register_pdn_event>:
{
 8017018:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801701c:	4606      	mov	r6, r0
 801701e:	460f      	mov	r7, r1
  PRINT_API("CS_register_pdn_event")
 8017020:	4c57      	ldr	r4, [pc, #348]	; (8017180 <CS_register_pdn_event+0x168>)
 8017022:	4d58      	ldr	r5, [pc, #352]	; (8017184 <CS_register_pdn_event+0x16c>)
 8017024:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017026:	6020      	str	r0, [r4, #0]
 8017028:	6061      	str	r1, [r4, #4]
 801702a:	60a2      	str	r2, [r4, #8]
 801702c:	60e3      	str	r3, [r4, #12]
 801702e:	cd07      	ldmia	r5!, {r0, r1, r2}
 8017030:	6120      	str	r0, [r4, #16]
 8017032:	6161      	str	r1, [r4, #20]
 8017034:	61a2      	str	r2, [r4, #24]
 8017036:	882a      	ldrh	r2, [r5, #0]
 8017038:	78ab      	ldrb	r3, [r5, #2]
 801703a:	83a2      	strh	r2, [r4, #28]
 801703c:	77a3      	strb	r3, [r4, #30]
 801703e:	4620      	mov	r0, r4
 8017040:	f008 f867 	bl	801f112 <crs_strlen>
 8017044:	b283      	uxth	r3, r0
 8017046:	4622      	mov	r2, r4
 8017048:	2104      	movs	r1, #4
 801704a:	2001      	movs	r0, #1
 801704c:	f008 f8a4 	bl	801f198 <traceIF_itmPrint>
 8017050:	4620      	mov	r0, r4
 8017052:	f008 f85e 	bl	801f112 <crs_strlen>
 8017056:	b283      	uxth	r3, r0
 8017058:	4622      	mov	r2, r4
 801705a:	2104      	movs	r1, #4
 801705c:	2001      	movs	r0, #1
 801705e:	f008 f8bd 	bl	801f1dc <traceIF_uartPrint>
  if (cid > CS_PDN_USER_CONFIG_5)
 8017062:	2e05      	cmp	r6, #5
 8017064:	d945      	bls.n	80170f2 <CS_register_pdn_event+0xda>
    PRINT_ERR("<Cellular_Service> only explicit PDN user config is supported (cid=%d)", cid)
 8017066:	4632      	mov	r2, r6
 8017068:	4947      	ldr	r1, [pc, #284]	; (8017188 <CS_register_pdn_event+0x170>)
 801706a:	4620      	mov	r0, r4
 801706c:	f00e fe00 	bl	8025c70 <sprintf>
 8017070:	4620      	mov	r0, r4
 8017072:	f008 f84e 	bl	801f112 <crs_strlen>
 8017076:	b283      	uxth	r3, r0
 8017078:	4622      	mov	r2, r4
 801707a:	2110      	movs	r1, #16
 801707c:	2001      	movs	r0, #1
 801707e:	f008 f88b 	bl	801f198 <traceIF_itmPrint>
 8017082:	4620      	mov	r0, r4
 8017084:	f008 f845 	bl	801f112 <crs_strlen>
 8017088:	b283      	uxth	r3, r0
 801708a:	4622      	mov	r2, r4
 801708c:	2110      	movs	r1, #16
 801708e:	2001      	movs	r0, #1
 8017090:	f008 f8a4 	bl	801f1dc <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service>error when registering PDN events")
 8017094:	4c3d      	ldr	r4, [pc, #244]	; (801718c <CS_register_pdn_event+0x174>)
 8017096:	4d3a      	ldr	r5, [pc, #232]	; (8017180 <CS_register_pdn_event+0x168>)
 8017098:	f104 0630 	add.w	r6, r4, #48	; 0x30
 801709c:	46a4      	mov	ip, r4
 801709e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80170a2:	6028      	str	r0, [r5, #0]
 80170a4:	6069      	str	r1, [r5, #4]
 80170a6:	60aa      	str	r2, [r5, #8]
 80170a8:	60eb      	str	r3, [r5, #12]
 80170aa:	4664      	mov	r4, ip
 80170ac:	3510      	adds	r5, #16
 80170ae:	45b4      	cmp	ip, r6
 80170b0:	d1f4      	bne.n	801709c <CS_register_pdn_event+0x84>
 80170b2:	4663      	mov	r3, ip
 80170b4:	cb07      	ldmia	r3!, {r0, r1, r2}
 80170b6:	6028      	str	r0, [r5, #0]
 80170b8:	6069      	str	r1, [r5, #4]
 80170ba:	60aa      	str	r2, [r5, #8]
 80170bc:	881a      	ldrh	r2, [r3, #0]
 80170be:	789b      	ldrb	r3, [r3, #2]
 80170c0:	81aa      	strh	r2, [r5, #12]
 80170c2:	73ab      	strb	r3, [r5, #14]
 80170c4:	4c2e      	ldr	r4, [pc, #184]	; (8017180 <CS_register_pdn_event+0x168>)
 80170c6:	4620      	mov	r0, r4
 80170c8:	f008 f823 	bl	801f112 <crs_strlen>
 80170cc:	b283      	uxth	r3, r0
 80170ce:	4622      	mov	r2, r4
 80170d0:	2110      	movs	r1, #16
 80170d2:	2001      	movs	r0, #1
 80170d4:	f008 f860 	bl	801f198 <traceIF_itmPrint>
 80170d8:	4620      	mov	r0, r4
 80170da:	f008 f81a 	bl	801f112 <crs_strlen>
 80170de:	b283      	uxth	r3, r0
 80170e0:	4622      	mov	r2, r4
 80170e2:	2110      	movs	r1, #16
 80170e4:	2001      	movs	r0, #1
 80170e6:	f008 f879 	bl	801f1dc <traceIF_uartPrint>
 80170ea:	2401      	movs	r4, #1
}
 80170ec:	4620      	mov	r0, r4
 80170ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (DATAPACK_writeStruct(&cmd_buf[0],
 80170f2:	2300      	movs	r3, #0
 80170f4:	461a      	mov	r2, r3
 80170f6:	2104      	movs	r1, #4
 80170f8:	4825      	ldr	r0, [pc, #148]	; (8017190 <CS_register_pdn_event+0x178>)
 80170fa:	f7f4 ffdb 	bl	800c0b4 <DATAPACK_writeStruct>
 80170fe:	2800      	cmp	r0, #0
 8017100:	d1c8      	bne.n	8017094 <CS_register_pdn_event+0x7c>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_REGISTER_PDN_EVENT, &cmd_buf[0], &rsp_buf[0]);
 8017102:	4b24      	ldr	r3, [pc, #144]	; (8017194 <CS_register_pdn_event+0x17c>)
 8017104:	4a22      	ldr	r2, [pc, #136]	; (8017190 <CS_register_pdn_event+0x178>)
 8017106:	2173      	movs	r1, #115	; 0x73
 8017108:	4823      	ldr	r0, [pc, #140]	; (8017198 <CS_register_pdn_event+0x180>)
 801710a:	f9b0 0000 	ldrsh.w	r0, [r0]
 801710e:	f7f4 fd69 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017112:	4604      	mov	r4, r0
 8017114:	2800      	cmp	r0, #0
 8017116:	d1bd      	bne.n	8017094 <CS_register_pdn_event+0x7c>
        PRINT_DBG("<Cellular_Service> PDN events registered successfully")
 8017118:	f8df c088 	ldr.w	ip, [pc, #136]	; 80171a4 <CS_register_pdn_event+0x18c>
 801711c:	4d18      	ldr	r5, [pc, #96]	; (8017180 <CS_register_pdn_event+0x168>)
 801711e:	f10c 0830 	add.w	r8, ip, #48	; 0x30
 8017122:	46e6      	mov	lr, ip
 8017124:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8017128:	6028      	str	r0, [r5, #0]
 801712a:	6069      	str	r1, [r5, #4]
 801712c:	60aa      	str	r2, [r5, #8]
 801712e:	60eb      	str	r3, [r5, #12]
 8017130:	46f4      	mov	ip, lr
 8017132:	3510      	adds	r5, #16
 8017134:	45c6      	cmp	lr, r8
 8017136:	d1f4      	bne.n	8017122 <CS_register_pdn_event+0x10a>
 8017138:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 801713c:	6028      	str	r0, [r5, #0]
 801713e:	6069      	str	r1, [r5, #4]
 8017140:	f8bc 2000 	ldrh.w	r2, [ip]
 8017144:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8017148:	812a      	strh	r2, [r5, #8]
 801714a:	72ab      	strb	r3, [r5, #10]
 801714c:	4d0c      	ldr	r5, [pc, #48]	; (8017180 <CS_register_pdn_event+0x168>)
 801714e:	4628      	mov	r0, r5
 8017150:	f007 ffdf 	bl	801f112 <crs_strlen>
 8017154:	b283      	uxth	r3, r0
 8017156:	462a      	mov	r2, r5
 8017158:	2102      	movs	r1, #2
 801715a:	2001      	movs	r0, #1
 801715c:	f008 f81c 	bl	801f198 <traceIF_itmPrint>
 8017160:	4628      	mov	r0, r5
 8017162:	f007 ffd6 	bl	801f112 <crs_strlen>
 8017166:	b283      	uxth	r3, r0
 8017168:	462a      	mov	r2, r5
 801716a:	2102      	movs	r1, #2
 801716c:	2001      	movs	r0, #1
 801716e:	f008 f835 	bl	801f1dc <traceIF_uartPrint>
        urc_packet_domain_event_callback[cid] = pdn_event_callback;
 8017172:	4b0a      	ldr	r3, [pc, #40]	; (801719c <CS_register_pdn_event+0x184>)
 8017174:	f843 7026 	str.w	r7, [r3, r6, lsl #2]
        cs_ctxt_urc_subscription.packet_domain_event = CELLULAR_TRUE;
 8017178:	4b09      	ldr	r3, [pc, #36]	; (80171a0 <CS_register_pdn_event+0x188>)
 801717a:	2201      	movs	r2, #1
 801717c:	71da      	strb	r2, [r3, #7]
  if (retval == CELLULAR_ERROR)
 801717e:	e7b5      	b.n	80170ec <CS_register_pdn_event+0xd4>
 8017180:	200047dc 	.word	0x200047dc
 8017184:	08031bb8 	.word	0x08031bb8
 8017188:	08031bd8 	.word	0x08031bd8
 801718c:	08031c68 	.word	0x08031c68
 8017190:	20003620 	.word	0x20003620
 8017194:	20003814 	.word	0x20003814
 8017198:	2000361c 	.word	0x2000361c
 801719c:	200038b0 	.word	0x200038b0
 80171a0:	20003804 	.word	0x20003804
 80171a4:	08031c2c 	.word	0x08031c2c

080171a8 <CDS_socket_create>:
{
 80171a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80171ac:	b083      	sub	sp, #12
 80171ae:	4607      	mov	r7, r0
 80171b0:	4688      	mov	r8, r1
 80171b2:	4691      	mov	r9, r2
  PRINT_API("CDS_socket_create")
 80171b4:	4c4b      	ldr	r4, [pc, #300]	; (80172e4 <CDS_socket_create+0x13c>)
 80171b6:	4d4c      	ldr	r5, [pc, #304]	; (80172e8 <CDS_socket_create+0x140>)
 80171b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80171ba:	6020      	str	r0, [r4, #0]
 80171bc:	6061      	str	r1, [r4, #4]
 80171be:	60a2      	str	r2, [r4, #8]
 80171c0:	60e3      	str	r3, [r4, #12]
 80171c2:	cd03      	ldmia	r5!, {r0, r1}
 80171c4:	6120      	str	r0, [r4, #16]
 80171c6:	6161      	str	r1, [r4, #20]
 80171c8:	882a      	ldrh	r2, [r5, #0]
 80171ca:	78ab      	ldrb	r3, [r5, #2]
 80171cc:	8322      	strh	r2, [r4, #24]
 80171ce:	76a3      	strb	r3, [r4, #26]
 80171d0:	4620      	mov	r0, r4
 80171d2:	f007 ff9e 	bl	801f112 <crs_strlen>
 80171d6:	b283      	uxth	r3, r0
 80171d8:	4622      	mov	r2, r4
 80171da:	2104      	movs	r1, #4
 80171dc:	2001      	movs	r0, #1
 80171de:	f007 ffdb 	bl	801f198 <traceIF_itmPrint>
 80171e2:	4620      	mov	r0, r4
 80171e4:	f007 ff95 	bl	801f112 <crs_strlen>
 80171e8:	b283      	uxth	r3, r0
 80171ea:	4622      	mov	r2, r4
 80171ec:	2104      	movs	r1, #4
 80171ee:	2001      	movs	r0, #1
 80171f0:	f007 fff4 	bl	801f1dc <traceIF_uartPrint>
  socket_handle_t sockhandle = csint_socket_allocateHandle();
 80171f4:	f003 f930 	bl	801a458 <csint_socket_allocateHandle>
 80171f8:	4606      	mov	r6, r0
  if (sockhandle == CS_INVALID_SOCKET_HANDLE)
 80171fa:	f1b0 3fff 	cmp.w	r0, #4294967295
 80171fe:	d024      	beq.n	801724a <CDS_socket_create+0xa2>
  else if (csint_socket_create(sockhandle, addr_type, protocol, /* default local_port = 0 */ 0U, cid) != CELLULAR_OK)
 8017200:	f8cd 9000 	str.w	r9, [sp]
 8017204:	2300      	movs	r3, #0
 8017206:	4642      	mov	r2, r8
 8017208:	4639      	mov	r1, r7
 801720a:	f003 f959 	bl	801a4c0 <csint_socket_create>
 801720e:	2800      	cmp	r0, #0
 8017210:	d13f      	bne.n	8017292 <CDS_socket_create+0xea>
    PRINT_INFO("allocated socket handle=%ld (local)", sockhandle)
 8017212:	4c34      	ldr	r4, [pc, #208]	; (80172e4 <CDS_socket_create+0x13c>)
 8017214:	4632      	mov	r2, r6
 8017216:	4935      	ldr	r1, [pc, #212]	; (80172ec <CDS_socket_create+0x144>)
 8017218:	4620      	mov	r0, r4
 801721a:	f00e fd29 	bl	8025c70 <sprintf>
 801721e:	4620      	mov	r0, r4
 8017220:	f007 ff77 	bl	801f112 <crs_strlen>
 8017224:	b283      	uxth	r3, r0
 8017226:	4622      	mov	r2, r4
 8017228:	2101      	movs	r1, #1
 801722a:	4608      	mov	r0, r1
 801722c:	f007 ffb4 	bl	801f198 <traceIF_itmPrint>
 8017230:	4620      	mov	r0, r4
 8017232:	f007 ff6e 	bl	801f112 <crs_strlen>
 8017236:	b283      	uxth	r3, r0
 8017238:	4622      	mov	r2, r4
 801723a:	2101      	movs	r1, #1
 801723c:	4608      	mov	r0, r1
 801723e:	f007 ffcd 	bl	801f1dc <traceIF_uartPrint>
}
 8017242:	4630      	mov	r0, r6
 8017244:	b003      	add	sp, #12
 8017246:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("no free socket handle")
 801724a:	4f29      	ldr	r7, [pc, #164]	; (80172f0 <CDS_socket_create+0x148>)
 801724c:	4625      	mov	r5, r4
 801724e:	f107 0c20 	add.w	ip, r7, #32
 8017252:	463c      	mov	r4, r7
 8017254:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8017256:	6028      	str	r0, [r5, #0]
 8017258:	6069      	str	r1, [r5, #4]
 801725a:	60aa      	str	r2, [r5, #8]
 801725c:	60eb      	str	r3, [r5, #12]
 801725e:	4627      	mov	r7, r4
 8017260:	3510      	adds	r5, #16
 8017262:	4564      	cmp	r4, ip
 8017264:	d1f5      	bne.n	8017252 <CDS_socket_create+0xaa>
 8017266:	7823      	ldrb	r3, [r4, #0]
 8017268:	702b      	strb	r3, [r5, #0]
 801726a:	4c1e      	ldr	r4, [pc, #120]	; (80172e4 <CDS_socket_create+0x13c>)
 801726c:	4620      	mov	r0, r4
 801726e:	f007 ff50 	bl	801f112 <crs_strlen>
 8017272:	b283      	uxth	r3, r0
 8017274:	4622      	mov	r2, r4
 8017276:	2110      	movs	r1, #16
 8017278:	2001      	movs	r0, #1
 801727a:	f007 ff8d 	bl	801f198 <traceIF_itmPrint>
 801727e:	4620      	mov	r0, r4
 8017280:	f007 ff47 	bl	801f112 <crs_strlen>
 8017284:	b283      	uxth	r3, r0
 8017286:	4622      	mov	r2, r4
 8017288:	2110      	movs	r1, #16
 801728a:	2001      	movs	r0, #1
 801728c:	f007 ffa6 	bl	801f1dc <traceIF_uartPrint>
 8017290:	e7d7      	b.n	8017242 <CDS_socket_create+0x9a>
    PRINT_ERR("socket creation failed")
 8017292:	4f18      	ldr	r7, [pc, #96]	; (80172f4 <CDS_socket_create+0x14c>)
 8017294:	4d13      	ldr	r5, [pc, #76]	; (80172e4 <CDS_socket_create+0x13c>)
 8017296:	f107 0c20 	add.w	ip, r7, #32
 801729a:	463c      	mov	r4, r7
 801729c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801729e:	6028      	str	r0, [r5, #0]
 80172a0:	6069      	str	r1, [r5, #4]
 80172a2:	60aa      	str	r2, [r5, #8]
 80172a4:	60eb      	str	r3, [r5, #12]
 80172a6:	4627      	mov	r7, r4
 80172a8:	3510      	adds	r5, #16
 80172aa:	4564      	cmp	r4, ip
 80172ac:	d1f5      	bne.n	801729a <CDS_socket_create+0xf2>
 80172ae:	8823      	ldrh	r3, [r4, #0]
 80172b0:	802b      	strh	r3, [r5, #0]
 80172b2:	4c0c      	ldr	r4, [pc, #48]	; (80172e4 <CDS_socket_create+0x13c>)
 80172b4:	4620      	mov	r0, r4
 80172b6:	f007 ff2c 	bl	801f112 <crs_strlen>
 80172ba:	b283      	uxth	r3, r0
 80172bc:	4622      	mov	r2, r4
 80172be:	2110      	movs	r1, #16
 80172c0:	2001      	movs	r0, #1
 80172c2:	f007 ff69 	bl	801f198 <traceIF_itmPrint>
 80172c6:	4620      	mov	r0, r4
 80172c8:	f007 ff23 	bl	801f112 <crs_strlen>
 80172cc:	b283      	uxth	r3, r0
 80172ce:	4622      	mov	r2, r4
 80172d0:	2110      	movs	r1, #16
 80172d2:	2001      	movs	r0, #1
 80172d4:	f007 ff82 	bl	801f1dc <traceIF_uartPrint>
    csint_socket_deallocateHandle(sockhandle);
 80172d8:	4630      	mov	r0, r6
 80172da:	f003 f8cf 	bl	801a47c <csint_socket_deallocateHandle>
    sockhandle = CS_INVALID_SOCKET_HANDLE;
 80172de:	f04f 36ff 	mov.w	r6, #4294967295
 80172e2:	e7ae      	b.n	8017242 <CDS_socket_create+0x9a>
 80172e4:	200047dc 	.word	0x200047dc
 80172e8:	08031ca8 	.word	0x08031ca8
 80172ec:	08031d0c 	.word	0x08031d0c
 80172f0:	08031cc4 	.word	0x08031cc4
 80172f4:	08031ce8 	.word	0x08031ce8

080172f8 <CDS_socket_bind>:
{
 80172f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80172fa:	4606      	mov	r6, r0
 80172fc:	460f      	mov	r7, r1
  PRINT_API("CDS_socket_bind")
 80172fe:	4c33      	ldr	r4, [pc, #204]	; (80173cc <CDS_socket_bind+0xd4>)
 8017300:	4d33      	ldr	r5, [pc, #204]	; (80173d0 <CDS_socket_bind+0xd8>)
 8017302:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017304:	6020      	str	r0, [r4, #0]
 8017306:	6061      	str	r1, [r4, #4]
 8017308:	60a2      	str	r2, [r4, #8]
 801730a:	60e3      	str	r3, [r4, #12]
 801730c:	cd03      	ldmia	r5!, {r0, r1}
 801730e:	6120      	str	r0, [r4, #16]
 8017310:	6161      	str	r1, [r4, #20]
 8017312:	782b      	ldrb	r3, [r5, #0]
 8017314:	7623      	strb	r3, [r4, #24]
 8017316:	4620      	mov	r0, r4
 8017318:	f007 fefb 	bl	801f112 <crs_strlen>
 801731c:	b283      	uxth	r3, r0
 801731e:	4622      	mov	r2, r4
 8017320:	2104      	movs	r1, #4
 8017322:	2001      	movs	r0, #1
 8017324:	f007 ff38 	bl	801f198 <traceIF_itmPrint>
 8017328:	4620      	mov	r0, r4
 801732a:	f007 fef2 	bl	801f112 <crs_strlen>
 801732e:	b283      	uxth	r3, r0
 8017330:	4622      	mov	r2, r4
 8017332:	2104      	movs	r1, #4
 8017334:	2001      	movs	r0, #1
 8017336:	f007 ff51 	bl	801f1dc <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CREATED)
 801733a:	4b26      	ldr	r3, [pc, #152]	; (80173d4 <CDS_socket_bind+0xdc>)
 801733c:	226c      	movs	r2, #108	; 0x6c
 801733e:	fb02 3306 	mla	r3, r2, r6, r3
 8017342:	791c      	ldrb	r4, [r3, #4]
 8017344:	2c01      	cmp	r4, #1
 8017346:	d019      	beq.n	801737c <CDS_socket_bind+0x84>
    PRINT_ERR("<Cellular_Service> socket bind allowed only after create/before connect %ld ", sockHandle)
 8017348:	4c20      	ldr	r4, [pc, #128]	; (80173cc <CDS_socket_bind+0xd4>)
 801734a:	4632      	mov	r2, r6
 801734c:	4922      	ldr	r1, [pc, #136]	; (80173d8 <CDS_socket_bind+0xe0>)
 801734e:	4620      	mov	r0, r4
 8017350:	f00e fc8e 	bl	8025c70 <sprintf>
 8017354:	4620      	mov	r0, r4
 8017356:	f007 fedc 	bl	801f112 <crs_strlen>
 801735a:	b283      	uxth	r3, r0
 801735c:	4622      	mov	r2, r4
 801735e:	2110      	movs	r1, #16
 8017360:	2001      	movs	r0, #1
 8017362:	f007 ff19 	bl	801f198 <traceIF_itmPrint>
 8017366:	4620      	mov	r0, r4
 8017368:	f007 fed3 	bl	801f112 <crs_strlen>
 801736c:	b283      	uxth	r3, r0
 801736e:	4622      	mov	r2, r4
 8017370:	2110      	movs	r1, #16
 8017372:	2001      	movs	r0, #1
 8017374:	f007 ff32 	bl	801f1dc <traceIF_uartPrint>
    res = CELLULAR_ERROR;
 8017378:	2001      	movs	r0, #1
}
 801737a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (csint_socket_bind(sockHandle, local_port) != CELLULAR_OK)
 801737c:	4639      	mov	r1, r7
 801737e:	4630      	mov	r0, r6
 8017380:	f003 f8d6 	bl	801a530 <csint_socket_bind>
 8017384:	2800      	cmp	r0, #0
 8017386:	d0f8      	beq.n	801737a <CDS_socket_bind+0x82>
    PRINT_ERR("Socket Bind error")
 8017388:	4d10      	ldr	r5, [pc, #64]	; (80173cc <CDS_socket_bind+0xd4>)
 801738a:	4e14      	ldr	r6, [pc, #80]	; (80173dc <CDS_socket_bind+0xe4>)
 801738c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801738e:	6028      	str	r0, [r5, #0]
 8017390:	6069      	str	r1, [r5, #4]
 8017392:	60aa      	str	r2, [r5, #8]
 8017394:	60eb      	str	r3, [r5, #12]
 8017396:	ce07      	ldmia	r6!, {r0, r1, r2}
 8017398:	6128      	str	r0, [r5, #16]
 801739a:	6169      	str	r1, [r5, #20]
 801739c:	61aa      	str	r2, [r5, #24]
 801739e:	7833      	ldrb	r3, [r6, #0]
 80173a0:	772b      	strb	r3, [r5, #28]
 80173a2:	4628      	mov	r0, r5
 80173a4:	f007 feb5 	bl	801f112 <crs_strlen>
 80173a8:	b283      	uxth	r3, r0
 80173aa:	462a      	mov	r2, r5
 80173ac:	2110      	movs	r1, #16
 80173ae:	2001      	movs	r0, #1
 80173b0:	f007 fef2 	bl	801f198 <traceIF_itmPrint>
 80173b4:	4628      	mov	r0, r5
 80173b6:	f007 feac 	bl	801f112 <crs_strlen>
 80173ba:	b283      	uxth	r3, r0
 80173bc:	462a      	mov	r2, r5
 80173be:	2110      	movs	r1, #16
 80173c0:	2001      	movs	r0, #1
 80173c2:	f007 ff0b 	bl	801f1dc <traceIF_uartPrint>
    res = CELLULAR_ERROR;
 80173c6:	4620      	mov	r0, r4
 80173c8:	e7d7      	b.n	801737a <CDS_socket_bind+0x82>
 80173ca:	bf00      	nop
 80173cc:	200047dc 	.word	0x200047dc
 80173d0:	08031d38 	.word	0x08031d38
 80173d4:	20003d18 	.word	0x20003d18
 80173d8:	08031d54 	.word	0x08031d54
 80173dc:	08031dac 	.word	0x08031dac

080173e0 <CDS_socket_set_callbacks>:
{
 80173e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80173e4:	4606      	mov	r6, r0
 80173e6:	460f      	mov	r7, r1
 80173e8:	4691      	mov	r9, r2
 80173ea:	4698      	mov	r8, r3
  PRINT_API("CDS_socket_set_callbacks")
 80173ec:	4d66      	ldr	r5, [pc, #408]	; (8017588 <CDS_socket_set_callbacks+0x1a8>)
 80173ee:	4c67      	ldr	r4, [pc, #412]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 80173f0:	f105 0e20 	add.w	lr, r5, #32
 80173f4:	46ac      	mov	ip, r5
 80173f6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80173fa:	6020      	str	r0, [r4, #0]
 80173fc:	6061      	str	r1, [r4, #4]
 80173fe:	60a2      	str	r2, [r4, #8]
 8017400:	60e3      	str	r3, [r4, #12]
 8017402:	4665      	mov	r5, ip
 8017404:	3410      	adds	r4, #16
 8017406:	45f4      	cmp	ip, lr
 8017408:	d1f4      	bne.n	80173f4 <CDS_socket_set_callbacks+0x14>
 801740a:	f8bc 3000 	ldrh.w	r3, [ip]
 801740e:	8023      	strh	r3, [r4, #0]
 8017410:	4c5e      	ldr	r4, [pc, #376]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017412:	4620      	mov	r0, r4
 8017414:	f007 fe7d 	bl	801f112 <crs_strlen>
 8017418:	b283      	uxth	r3, r0
 801741a:	4622      	mov	r2, r4
 801741c:	2104      	movs	r1, #4
 801741e:	2001      	movs	r0, #1
 8017420:	f007 feba 	bl	801f198 <traceIF_itmPrint>
 8017424:	4620      	mov	r0, r4
 8017426:	f007 fe74 	bl	801f112 <crs_strlen>
 801742a:	b283      	uxth	r3, r0
 801742c:	4622      	mov	r2, r4
 801742e:	2104      	movs	r1, #4
 8017430:	2001      	movs	r0, #1
 8017432:	f007 fed3 	bl	801f1dc <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_NOT_ALLOC)
 8017436:	4b56      	ldr	r3, [pc, #344]	; (8017590 <CDS_socket_set_callbacks+0x1b0>)
 8017438:	226c      	movs	r2, #108	; 0x6c
 801743a:	fb02 3306 	mla	r3, r2, r6, r3
 801743e:	791b      	ldrb	r3, [r3, #4]
 8017440:	2b00      	cmp	r3, #0
 8017442:	d03a      	beq.n	80174ba <CDS_socket_set_callbacks+0xda>
  else if (data_ready_cb == NULL)
 8017444:	2f00      	cmp	r7, #0
 8017446:	d051      	beq.n	80174ec <CDS_socket_set_callbacks+0x10c>
  else if (remote_close_cb == NULL)
 8017448:	f1b8 0f00 	cmp.w	r8, #0
 801744c:	d075      	beq.n	801753a <CDS_socket_set_callbacks+0x15a>
    cs_ctxt_sockets_info[sockHandle].socket_data_ready_callback = data_ready_cb;
 801744e:	4b50      	ldr	r3, [pc, #320]	; (8017590 <CDS_socket_set_callbacks+0x1b0>)
 8017450:	226c      	movs	r2, #108	; 0x6c
 8017452:	fb02 3306 	mla	r3, r2, r6, r3
 8017456:	661f      	str	r7, [r3, #96]	; 0x60
    cs_ctxt_sockets_info[sockHandle].socket_remote_close_callback = remote_close_cb;
 8017458:	f8c3 8068 	str.w	r8, [r3, #104]	; 0x68
    retval = CELLULAR_OK;
 801745c:	2600      	movs	r6, #0
  if (data_sent_cb != NULL)
 801745e:	f1b9 0f00 	cmp.w	r9, #0
 8017462:	d027      	beq.n	80174b4 <CDS_socket_set_callbacks+0xd4>
    PRINT_ERR("DATA sent callback not supported (only synch mode)")
 8017464:	4c4b      	ldr	r4, [pc, #300]	; (8017594 <CDS_socket_set_callbacks+0x1b4>)
 8017466:	4d49      	ldr	r5, [pc, #292]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017468:	f104 0730 	add.w	r7, r4, #48	; 0x30
 801746c:	46a4      	mov	ip, r4
 801746e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017472:	6028      	str	r0, [r5, #0]
 8017474:	6069      	str	r1, [r5, #4]
 8017476:	60aa      	str	r2, [r5, #8]
 8017478:	60eb      	str	r3, [r5, #12]
 801747a:	4664      	mov	r4, ip
 801747c:	3510      	adds	r5, #16
 801747e:	45bc      	cmp	ip, r7
 8017480:	d1f4      	bne.n	801746c <CDS_socket_set_callbacks+0x8c>
 8017482:	cc07      	ldmia	r4!, {r0, r1, r2}
 8017484:	6028      	str	r0, [r5, #0]
 8017486:	6069      	str	r1, [r5, #4]
 8017488:	60aa      	str	r2, [r5, #8]
 801748a:	8823      	ldrh	r3, [r4, #0]
 801748c:	81ab      	strh	r3, [r5, #12]
 801748e:	4c3f      	ldr	r4, [pc, #252]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017490:	4620      	mov	r0, r4
 8017492:	f007 fe3e 	bl	801f112 <crs_strlen>
 8017496:	b283      	uxth	r3, r0
 8017498:	4622      	mov	r2, r4
 801749a:	2110      	movs	r1, #16
 801749c:	2001      	movs	r0, #1
 801749e:	f007 fe7b 	bl	801f198 <traceIF_itmPrint>
 80174a2:	4620      	mov	r0, r4
 80174a4:	f007 fe35 	bl	801f112 <crs_strlen>
 80174a8:	b283      	uxth	r3, r0
 80174aa:	4622      	mov	r2, r4
 80174ac:	2110      	movs	r1, #16
 80174ae:	2001      	movs	r0, #1
 80174b0:	f007 fe94 	bl	801f1dc <traceIF_uartPrint>
}
 80174b4:	4630      	mov	r0, r6
 80174b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (set cb)", sockHandle)
 80174ba:	4632      	mov	r2, r6
 80174bc:	4936      	ldr	r1, [pc, #216]	; (8017598 <CDS_socket_set_callbacks+0x1b8>)
 80174be:	4620      	mov	r0, r4
 80174c0:	f00e fbd6 	bl	8025c70 <sprintf>
 80174c4:	4620      	mov	r0, r4
 80174c6:	f007 fe24 	bl	801f112 <crs_strlen>
 80174ca:	b283      	uxth	r3, r0
 80174cc:	4622      	mov	r2, r4
 80174ce:	2110      	movs	r1, #16
 80174d0:	2001      	movs	r0, #1
 80174d2:	f007 fe61 	bl	801f198 <traceIF_itmPrint>
 80174d6:	4620      	mov	r0, r4
 80174d8:	f007 fe1b 	bl	801f112 <crs_strlen>
 80174dc:	b283      	uxth	r3, r0
 80174de:	4622      	mov	r2, r4
 80174e0:	2110      	movs	r1, #16
 80174e2:	2001      	movs	r0, #1
 80174e4:	f007 fe7a 	bl	801f1dc <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 80174e8:	2601      	movs	r6, #1
 80174ea:	e7b8      	b.n	801745e <CDS_socket_set_callbacks+0x7e>
    PRINT_ERR("data_ready_cb is mandatory")
 80174ec:	4e2b      	ldr	r6, [pc, #172]	; (801759c <CDS_socket_set_callbacks+0x1bc>)
 80174ee:	4c27      	ldr	r4, [pc, #156]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 80174f0:	f106 0720 	add.w	r7, r6, #32
 80174f4:	4635      	mov	r5, r6
 80174f6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80174f8:	6020      	str	r0, [r4, #0]
 80174fa:	6061      	str	r1, [r4, #4]
 80174fc:	60a2      	str	r2, [r4, #8]
 80174fe:	60e3      	str	r3, [r4, #12]
 8017500:	462e      	mov	r6, r5
 8017502:	3410      	adds	r4, #16
 8017504:	42bd      	cmp	r5, r7
 8017506:	d1f5      	bne.n	80174f4 <CDS_socket_set_callbacks+0x114>
 8017508:	6828      	ldr	r0, [r5, #0]
 801750a:	6020      	str	r0, [r4, #0]
 801750c:	88ab      	ldrh	r3, [r5, #4]
 801750e:	80a3      	strh	r3, [r4, #4]
 8017510:	4c1e      	ldr	r4, [pc, #120]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017512:	4620      	mov	r0, r4
 8017514:	f007 fdfd 	bl	801f112 <crs_strlen>
 8017518:	b283      	uxth	r3, r0
 801751a:	4622      	mov	r2, r4
 801751c:	2110      	movs	r1, #16
 801751e:	2001      	movs	r0, #1
 8017520:	f007 fe3a 	bl	801f198 <traceIF_itmPrint>
 8017524:	4620      	mov	r0, r4
 8017526:	f007 fdf4 	bl	801f112 <crs_strlen>
 801752a:	b283      	uxth	r3, r0
 801752c:	4622      	mov	r2, r4
 801752e:	2110      	movs	r1, #16
 8017530:	2001      	movs	r0, #1
 8017532:	f007 fe53 	bl	801f1dc <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 8017536:	2601      	movs	r6, #1
 8017538:	e791      	b.n	801745e <CDS_socket_set_callbacks+0x7e>
    PRINT_ERR("remote_close_cb is mandatory")
 801753a:	4e19      	ldr	r6, [pc, #100]	; (80175a0 <CDS_socket_set_callbacks+0x1c0>)
 801753c:	4c13      	ldr	r4, [pc, #76]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 801753e:	f106 0720 	add.w	r7, r6, #32
 8017542:	4635      	mov	r5, r6
 8017544:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017546:	6020      	str	r0, [r4, #0]
 8017548:	6061      	str	r1, [r4, #4]
 801754a:	60a2      	str	r2, [r4, #8]
 801754c:	60e3      	str	r3, [r4, #12]
 801754e:	462e      	mov	r6, r5
 8017550:	3410      	adds	r4, #16
 8017552:	42bd      	cmp	r5, r7
 8017554:	d1f5      	bne.n	8017542 <CDS_socket_set_callbacks+0x162>
 8017556:	ce03      	ldmia	r6!, {r0, r1}
 8017558:	6020      	str	r0, [r4, #0]
 801755a:	6061      	str	r1, [r4, #4]
 801755c:	4c0b      	ldr	r4, [pc, #44]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 801755e:	4620      	mov	r0, r4
 8017560:	f007 fdd7 	bl	801f112 <crs_strlen>
 8017564:	b283      	uxth	r3, r0
 8017566:	4622      	mov	r2, r4
 8017568:	2110      	movs	r1, #16
 801756a:	2001      	movs	r0, #1
 801756c:	f007 fe14 	bl	801f198 <traceIF_itmPrint>
 8017570:	4620      	mov	r0, r4
 8017572:	f007 fdce 	bl	801f112 <crs_strlen>
 8017576:	b283      	uxth	r3, r0
 8017578:	4622      	mov	r2, r4
 801757a:	2110      	movs	r1, #16
 801757c:	2001      	movs	r0, #1
 801757e:	f007 fe2d 	bl	801f1dc <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 8017582:	2601      	movs	r6, #1
 8017584:	e76b      	b.n	801745e <CDS_socket_set_callbacks+0x7e>
 8017586:	bf00      	nop
 8017588:	08031dcc 	.word	0x08031dcc
 801758c:	200047dc 	.word	0x200047dc
 8017590:	20003d18 	.word	0x20003d18
 8017594:	08031e84 	.word	0x08031e84
 8017598:	08031df0 	.word	0x08031df0
 801759c:	08031e34 	.word	0x08031e34
 80175a0:	08031e5c 	.word	0x08031e5c

080175a4 <CDS_socket_connect>:
{
 80175a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80175a8:	4606      	mov	r6, r0
 80175aa:	460f      	mov	r7, r1
 80175ac:	4690      	mov	r8, r2
 80175ae:	4699      	mov	r9, r3
  PRINT_API("CDS_socket_connect")
 80175b0:	4c39      	ldr	r4, [pc, #228]	; (8017698 <CDS_socket_connect+0xf4>)
 80175b2:	4d3a      	ldr	r5, [pc, #232]	; (801769c <CDS_socket_connect+0xf8>)
 80175b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80175b6:	6020      	str	r0, [r4, #0]
 80175b8:	6061      	str	r1, [r4, #4]
 80175ba:	60a2      	str	r2, [r4, #8]
 80175bc:	60e3      	str	r3, [r4, #12]
 80175be:	cd07      	ldmia	r5!, {r0, r1, r2}
 80175c0:	6120      	str	r0, [r4, #16]
 80175c2:	6161      	str	r1, [r4, #20]
 80175c4:	61a2      	str	r2, [r4, #24]
 80175c6:	4620      	mov	r0, r4
 80175c8:	f007 fda3 	bl	801f112 <crs_strlen>
 80175cc:	b283      	uxth	r3, r0
 80175ce:	4622      	mov	r2, r4
 80175d0:	2104      	movs	r1, #4
 80175d2:	2001      	movs	r0, #1
 80175d4:	f007 fde0 	bl	801f198 <traceIF_itmPrint>
 80175d8:	4620      	mov	r0, r4
 80175da:	f007 fd9a 	bl	801f112 <crs_strlen>
 80175de:	b283      	uxth	r3, r0
 80175e0:	4622      	mov	r2, r4
 80175e2:	2104      	movs	r1, #4
 80175e4:	2001      	movs	r0, #1
 80175e6:	f007 fdf9 	bl	801f1dc <traceIF_uartPrint>
  retval = csint_socket_configure_remote(sockHandle, ip_addr_type, p_ip_addr_value, remote_port);
 80175ea:	464b      	mov	r3, r9
 80175ec:	4642      	mov	r2, r8
 80175ee:	4639      	mov	r1, r7
 80175f0:	4630      	mov	r0, r6
 80175f2:	f002 ffcb 	bl	801a58c <csint_socket_configure_remote>
  if (retval == CELLULAR_OK)
 80175f6:	b108      	cbz	r0, 80175fc <CDS_socket_connect+0x58>
}
 80175f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (DATAPACK_writePtr(&cmd_buf[0],
 80175fc:	226c      	movs	r2, #108	; 0x6c
 80175fe:	4b28      	ldr	r3, [pc, #160]	; (80176a0 <CDS_socket_connect+0xfc>)
 8017600:	fb02 3206 	mla	r2, r2, r6, r3
 8017604:	2118      	movs	r1, #24
 8017606:	4827      	ldr	r0, [pc, #156]	; (80176a4 <CDS_socket_connect+0x100>)
 8017608:	f7f4 fd24 	bl	800c054 <DATAPACK_writePtr>
 801760c:	2800      	cmp	r0, #0
 801760e:	d140      	bne.n	8017692 <CDS_socket_connect+0xee>
      if (socket_infos->trp_connect_mode == CS_CM_COMMAND_MODE)
 8017610:	4b23      	ldr	r3, [pc, #140]	; (80176a0 <CDS_socket_connect+0xfc>)
 8017612:	226c      	movs	r2, #108	; 0x6c
 8017614:	fb02 3306 	mla	r3, r2, r6, r3
 8017618:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801761c:	b97b      	cbnz	r3, 801763e <CDS_socket_connect+0x9a>
        err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_DIAL_COMMAND, &cmd_buf[0], &rsp_buf[0]);
 801761e:	4b22      	ldr	r3, [pc, #136]	; (80176a8 <CDS_socket_connect+0x104>)
 8017620:	4a20      	ldr	r2, [pc, #128]	; (80176a4 <CDS_socket_connect+0x100>)
 8017622:	2179      	movs	r1, #121	; 0x79
 8017624:	4821      	ldr	r0, [pc, #132]	; (80176ac <CDS_socket_connect+0x108>)
 8017626:	f9b0 0000 	ldrsh.w	r0, [r0]
 801762a:	f7f4 fadb 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 801762e:	b930      	cbnz	r0, 801763e <CDS_socket_connect+0x9a>
        cs_ctxt_sockets_info[sockHandle].state = SOCKETSTATE_CONNECTED;
 8017630:	4b1b      	ldr	r3, [pc, #108]	; (80176a0 <CDS_socket_connect+0xfc>)
 8017632:	226c      	movs	r2, #108	; 0x6c
 8017634:	fb02 3306 	mla	r3, r2, r6, r3
 8017638:	2202      	movs	r2, #2
 801763a:	711a      	strb	r2, [r3, #4]
        retval = CELLULAR_OK;
 801763c:	e7dc      	b.n	80175f8 <CDS_socket_connect+0x54>
        PRINT_ERR("<Cellular_Service> error when socket connection")
 801763e:	4d1c      	ldr	r5, [pc, #112]	; (80176b0 <CDS_socket_connect+0x10c>)
 8017640:	4c15      	ldr	r4, [pc, #84]	; (8017698 <CDS_socket_connect+0xf4>)
 8017642:	f105 0730 	add.w	r7, r5, #48	; 0x30
 8017646:	462e      	mov	r6, r5
 8017648:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801764a:	6020      	str	r0, [r4, #0]
 801764c:	6061      	str	r1, [r4, #4]
 801764e:	60a2      	str	r2, [r4, #8]
 8017650:	60e3      	str	r3, [r4, #12]
 8017652:	4635      	mov	r5, r6
 8017654:	3410      	adds	r4, #16
 8017656:	42be      	cmp	r6, r7
 8017658:	d1f5      	bne.n	8017646 <CDS_socket_connect+0xa2>
 801765a:	cd03      	ldmia	r5!, {r0, r1}
 801765c:	6020      	str	r0, [r4, #0]
 801765e:	6061      	str	r1, [r4, #4]
 8017660:	882a      	ldrh	r2, [r5, #0]
 8017662:	78ab      	ldrb	r3, [r5, #2]
 8017664:	8122      	strh	r2, [r4, #8]
 8017666:	72a3      	strb	r3, [r4, #10]
 8017668:	4c0b      	ldr	r4, [pc, #44]	; (8017698 <CDS_socket_connect+0xf4>)
 801766a:	4620      	mov	r0, r4
 801766c:	f007 fd51 	bl	801f112 <crs_strlen>
 8017670:	b283      	uxth	r3, r0
 8017672:	4622      	mov	r2, r4
 8017674:	2110      	movs	r1, #16
 8017676:	2001      	movs	r0, #1
 8017678:	f007 fd8e 	bl	801f198 <traceIF_itmPrint>
 801767c:	4620      	mov	r0, r4
 801767e:	f007 fd48 	bl	801f112 <crs_strlen>
 8017682:	b283      	uxth	r3, r0
 8017684:	4622      	mov	r2, r4
 8017686:	2110      	movs	r1, #16
 8017688:	2001      	movs	r0, #1
 801768a:	f007 fda7 	bl	801f1dc <traceIF_uartPrint>
        retval = CELLULAR_ERROR;
 801768e:	2001      	movs	r0, #1
 8017690:	e7b2      	b.n	80175f8 <CDS_socket_connect+0x54>
      retval = CELLULAR_ERROR;
 8017692:	2001      	movs	r0, #1
 8017694:	e7b0      	b.n	80175f8 <CDS_socket_connect+0x54>
 8017696:	bf00      	nop
 8017698:	200047dc 	.word	0x200047dc
 801769c:	08031ec4 	.word	0x08031ec4
 80176a0:	20003d18 	.word	0x20003d18
 80176a4:	20003620 	.word	0x20003620
 80176a8:	20003814 	.word	0x20003814
 80176ac:	2000361c 	.word	0x2000361c
 80176b0:	08031ee0 	.word	0x08031ee0

080176b4 <CDS_socket_send>:
{
 80176b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80176b6:	b097      	sub	sp, #92	; 0x5c
 80176b8:	4606      	mov	r6, r0
 80176ba:	460f      	mov	r7, r1
 80176bc:	4615      	mov	r5, r2
  PRINT_API("CDS_socket_send (buf@=%p - buflength = %ld)", p_buf, length)
 80176be:	4c5f      	ldr	r4, [pc, #380]	; (801783c <CDS_socket_send+0x188>)
 80176c0:	4613      	mov	r3, r2
 80176c2:	460a      	mov	r2, r1
 80176c4:	495e      	ldr	r1, [pc, #376]	; (8017840 <CDS_socket_send+0x18c>)
 80176c6:	4620      	mov	r0, r4
 80176c8:	f00e fad2 	bl	8025c70 <sprintf>
 80176cc:	4620      	mov	r0, r4
 80176ce:	f007 fd20 	bl	801f112 <crs_strlen>
 80176d2:	b283      	uxth	r3, r0
 80176d4:	4622      	mov	r2, r4
 80176d6:	2104      	movs	r1, #4
 80176d8:	2001      	movs	r0, #1
 80176da:	f007 fd5d 	bl	801f198 <traceIF_itmPrint>
 80176de:	4620      	mov	r0, r4
 80176e0:	f007 fd17 	bl	801f112 <crs_strlen>
 80176e4:	b283      	uxth	r3, r0
 80176e6:	4622      	mov	r2, r4
 80176e8:	2104      	movs	r1, #4
 80176ea:	2001      	movs	r0, #1
 80176ec:	f007 fd76 	bl	801f1dc <traceIF_uartPrint>
  if (length > DEFAULT_IP_MAX_PACKET_SIZE)
 80176f0:	f240 53dc 	movw	r3, #1500	; 0x5dc
 80176f4:	429d      	cmp	r5, r3
 80176f6:	d844      	bhi.n	8017782 <CDS_socket_send+0xce>
  else if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CONNECTED)
 80176f8:	4b52      	ldr	r3, [pc, #328]	; (8017844 <CDS_socket_send+0x190>)
 80176fa:	226c      	movs	r2, #108	; 0x6c
 80176fc:	fb02 3306 	mla	r3, r2, r6, r3
 8017700:	791a      	ldrb	r2, [r3, #4]
 8017702:	2a02      	cmp	r2, #2
 8017704:	d055      	beq.n	80177b2 <CDS_socket_send+0xfe>
    PRINT_ERR("<Cellular_Service> socket not connected (state=%d) for handle %ld (send)",
 8017706:	4c4d      	ldr	r4, [pc, #308]	; (801783c <CDS_socket_send+0x188>)
 8017708:	4633      	mov	r3, r6
 801770a:	494f      	ldr	r1, [pc, #316]	; (8017848 <CDS_socket_send+0x194>)
 801770c:	4620      	mov	r0, r4
 801770e:	f00e faaf 	bl	8025c70 <sprintf>
 8017712:	4620      	mov	r0, r4
 8017714:	f007 fcfd 	bl	801f112 <crs_strlen>
 8017718:	b283      	uxth	r3, r0
 801771a:	4622      	mov	r2, r4
 801771c:	2110      	movs	r1, #16
 801771e:	2001      	movs	r0, #1
 8017720:	f007 fd3a 	bl	801f198 <traceIF_itmPrint>
 8017724:	4620      	mov	r0, r4
 8017726:	f007 fcf4 	bl	801f112 <crs_strlen>
 801772a:	b283      	uxth	r3, r0
 801772c:	4622      	mov	r2, r4
 801772e:	2110      	movs	r1, #16
 8017730:	2001      	movs	r0, #1
 8017732:	f007 fd53 	bl	801f1dc <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when sending data to socket")
 8017736:	4d45      	ldr	r5, [pc, #276]	; (801784c <CDS_socket_send+0x198>)
 8017738:	4c40      	ldr	r4, [pc, #256]	; (801783c <CDS_socket_send+0x188>)
 801773a:	f105 0640 	add.w	r6, r5, #64	; 0x40
 801773e:	46ac      	mov	ip, r5
 8017740:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017744:	6020      	str	r0, [r4, #0]
 8017746:	6061      	str	r1, [r4, #4]
 8017748:	60a2      	str	r2, [r4, #8]
 801774a:	60e3      	str	r3, [r4, #12]
 801774c:	4665      	mov	r5, ip
 801774e:	3410      	adds	r4, #16
 8017750:	45b4      	cmp	ip, r6
 8017752:	d1f4      	bne.n	801773e <CDS_socket_send+0x8a>
 8017754:	4c39      	ldr	r4, [pc, #228]	; (801783c <CDS_socket_send+0x188>)
 8017756:	4620      	mov	r0, r4
 8017758:	f007 fcdb 	bl	801f112 <crs_strlen>
 801775c:	b283      	uxth	r3, r0
 801775e:	4622      	mov	r2, r4
 8017760:	2110      	movs	r1, #16
 8017762:	2001      	movs	r0, #1
 8017764:	f007 fd18 	bl	801f198 <traceIF_itmPrint>
 8017768:	4620      	mov	r0, r4
 801776a:	f007 fcd2 	bl	801f112 <crs_strlen>
 801776e:	b283      	uxth	r3, r0
 8017770:	4622      	mov	r2, r4
 8017772:	2110      	movs	r1, #16
 8017774:	2001      	movs	r0, #1
 8017776:	f007 fd31 	bl	801f1dc <traceIF_uartPrint>
 801777a:	2401      	movs	r4, #1
}
 801777c:	4620      	mov	r0, r4
 801777e:	b017      	add	sp, #92	; 0x5c
 8017780:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINT_ERR("<Cellular_Service> buffer size %ld exceed maximum value %d",
 8017782:	462a      	mov	r2, r5
 8017784:	4932      	ldr	r1, [pc, #200]	; (8017850 <CDS_socket_send+0x19c>)
 8017786:	4620      	mov	r0, r4
 8017788:	f00e fa72 	bl	8025c70 <sprintf>
 801778c:	4620      	mov	r0, r4
 801778e:	f007 fcc0 	bl	801f112 <crs_strlen>
 8017792:	b283      	uxth	r3, r0
 8017794:	4622      	mov	r2, r4
 8017796:	2110      	movs	r1, #16
 8017798:	2001      	movs	r0, #1
 801779a:	f007 fcfd 	bl	801f198 <traceIF_itmPrint>
 801779e:	4620      	mov	r0, r4
 80177a0:	f007 fcb7 	bl	801f112 <crs_strlen>
 80177a4:	b283      	uxth	r3, r0
 80177a6:	4622      	mov	r2, r4
 80177a8:	2110      	movs	r1, #16
 80177aa:	2001      	movs	r0, #1
 80177ac:	f007 fd16 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80177b0:	e7c1      	b.n	8017736 <CDS_socket_send+0x82>
    (void) memset((void *)&send_data_struct, 0, sizeof(csint_socket_data_buffer_t));
 80177b2:	2458      	movs	r4, #88	; 0x58
 80177b4:	4622      	mov	r2, r4
 80177b6:	2100      	movs	r1, #0
 80177b8:	4668      	mov	r0, sp
 80177ba:	f00e facc 	bl	8025d56 <memset>
    send_data_struct.socket_handle = sockHandle;
 80177be:	9600      	str	r6, [sp, #0]
    send_data_struct.p_buffer_addr_send = p_buf;
 80177c0:	9701      	str	r7, [sp, #4]
    send_data_struct.buffer_size = length;
 80177c2:	9503      	str	r5, [sp, #12]
    send_data_struct.max_buffer_size = length;
 80177c4:	9504      	str	r5, [sp, #16]
    if (DATAPACK_writeStruct(&cmd_buf[0],
 80177c6:	466b      	mov	r3, sp
 80177c8:	4622      	mov	r2, r4
 80177ca:	2119      	movs	r1, #25
 80177cc:	4821      	ldr	r0, [pc, #132]	; (8017854 <CDS_socket_send+0x1a0>)
 80177ce:	f7f4 fc71 	bl	800c0b4 <DATAPACK_writeStruct>
 80177d2:	2800      	cmp	r0, #0
 80177d4:	d1af      	bne.n	8017736 <CDS_socket_send+0x82>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SEND_DATA, &cmd_buf[0], &rsp_buf[0]);
 80177d6:	4b20      	ldr	r3, [pc, #128]	; (8017858 <CDS_socket_send+0x1a4>)
 80177d8:	4a1e      	ldr	r2, [pc, #120]	; (8017854 <CDS_socket_send+0x1a0>)
 80177da:	217a      	movs	r1, #122	; 0x7a
 80177dc:	481f      	ldr	r0, [pc, #124]	; (801785c <CDS_socket_send+0x1a8>)
 80177de:	f9b0 0000 	ldrsh.w	r0, [r0]
 80177e2:	f7f4 f9ff 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 80177e6:	4604      	mov	r4, r0
 80177e8:	2800      	cmp	r0, #0
 80177ea:	d1a4      	bne.n	8017736 <CDS_socket_send+0x82>
        PRINT_DBG("<Cellular_Service> socket data sent")
 80177ec:	4e1c      	ldr	r6, [pc, #112]	; (8017860 <CDS_socket_send+0x1ac>)
 80177ee:	4d13      	ldr	r5, [pc, #76]	; (801783c <CDS_socket_send+0x188>)
 80177f0:	f106 0c20 	add.w	ip, r6, #32
 80177f4:	4637      	mov	r7, r6
 80177f6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80177f8:	6028      	str	r0, [r5, #0]
 80177fa:	6069      	str	r1, [r5, #4]
 80177fc:	60aa      	str	r2, [r5, #8]
 80177fe:	60eb      	str	r3, [r5, #12]
 8017800:	463e      	mov	r6, r7
 8017802:	3510      	adds	r5, #16
 8017804:	4567      	cmp	r7, ip
 8017806:	d1f5      	bne.n	80177f4 <CDS_socket_send+0x140>
 8017808:	ce03      	ldmia	r6!, {r0, r1}
 801780a:	6028      	str	r0, [r5, #0]
 801780c:	6069      	str	r1, [r5, #4]
 801780e:	7833      	ldrb	r3, [r6, #0]
 8017810:	722b      	strb	r3, [r5, #8]
 8017812:	4d0a      	ldr	r5, [pc, #40]	; (801783c <CDS_socket_send+0x188>)
 8017814:	4628      	mov	r0, r5
 8017816:	f007 fc7c 	bl	801f112 <crs_strlen>
 801781a:	b283      	uxth	r3, r0
 801781c:	462a      	mov	r2, r5
 801781e:	2102      	movs	r1, #2
 8017820:	2001      	movs	r0, #1
 8017822:	f007 fcb9 	bl	801f198 <traceIF_itmPrint>
 8017826:	4628      	mov	r0, r5
 8017828:	f007 fc73 	bl	801f112 <crs_strlen>
 801782c:	b283      	uxth	r3, r0
 801782e:	462a      	mov	r2, r5
 8017830:	2102      	movs	r1, #2
 8017832:	2001      	movs	r0, #1
 8017834:	f007 fcd2 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017838:	e7a0      	b.n	801777c <CDS_socket_send+0xc8>
 801783a:	bf00      	nop
 801783c:	200047dc 	.word	0x200047dc
 8017840:	08031f1c 	.word	0x08031f1c
 8017844:	20003d18 	.word	0x20003d18
 8017848:	08031f9c 	.word	0x08031f9c
 801784c:	0803201c 	.word	0x0803201c
 8017850:	08031f54 	.word	0x08031f54
 8017854:	20003620 	.word	0x20003620
 8017858:	20003814 	.word	0x20003814
 801785c:	2000361c 	.word	0x2000361c
 8017860:	08031ff0 	.word	0x08031ff0

08017864 <CDS_socket_sendto>:
{
 8017864:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8017868:	b097      	sub	sp, #92	; 0x5c
 801786a:	4606      	mov	r6, r0
 801786c:	460f      	mov	r7, r1
 801786e:	4615      	mov	r5, r2
 8017870:	4698      	mov	r8, r3
  PRINT_API("CDS_socket_send (buf@=%p - buflength = %ld)", p_buf, length)
 8017872:	4c8b      	ldr	r4, [pc, #556]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017874:	4613      	mov	r3, r2
 8017876:	460a      	mov	r2, r1
 8017878:	498a      	ldr	r1, [pc, #552]	; (8017aa4 <CDS_socket_sendto+0x240>)
 801787a:	4620      	mov	r0, r4
 801787c:	f00e f9f8 	bl	8025c70 <sprintf>
 8017880:	4620      	mov	r0, r4
 8017882:	f007 fc46 	bl	801f112 <crs_strlen>
 8017886:	b283      	uxth	r3, r0
 8017888:	4622      	mov	r2, r4
 801788a:	2104      	movs	r1, #4
 801788c:	2001      	movs	r0, #1
 801788e:	f007 fc83 	bl	801f198 <traceIF_itmPrint>
 8017892:	4620      	mov	r0, r4
 8017894:	f007 fc3d 	bl	801f112 <crs_strlen>
 8017898:	b283      	uxth	r3, r0
 801789a:	4622      	mov	r2, r4
 801789c:	2104      	movs	r1, #4
 801789e:	2001      	movs	r0, #1
 80178a0:	f007 fc9c 	bl	801f1dc <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CONNECTED)
 80178a4:	4a80      	ldr	r2, [pc, #512]	; (8017aa8 <CDS_socket_sendto+0x244>)
 80178a6:	236c      	movs	r3, #108	; 0x6c
 80178a8:	fb03 2206 	mla	r2, r3, r6, r2
 80178ac:	7912      	ldrb	r2, [r2, #4]
 80178ae:	2a02      	cmp	r2, #2
 80178b0:	d131      	bne.n	8017916 <CDS_socket_sendto+0xb2>
  else if (length > DEFAULT_IP_MAX_PACKET_SIZE)
 80178b2:	f240 53dc 	movw	r3, #1500	; 0x5dc
 80178b6:	429d      	cmp	r5, r3
 80178b8:	d861      	bhi.n	801797e <CDS_socket_sendto+0x11a>
  else if (p_ip_addr_value == NULL)
 80178ba:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80178bc:	2b00      	cmp	r3, #0
 80178be:	d077      	beq.n	80179b0 <CDS_socket_sendto+0x14c>
    ip_addr_length = strlen((const CRC_CHAR_t *)p_ip_addr_value);
 80178c0:	981e      	ldr	r0, [sp, #120]	; 0x78
 80178c2:	f7e8 fc97 	bl	80001f4 <strlen>
 80178c6:	4604      	mov	r4, r0
    if (ip_addr_length > MAX_IP_ADDR_SIZE)
 80178c8:	2840      	cmp	r0, #64	; 0x40
 80178ca:	f240 8099 	bls.w	8017a00 <CDS_socket_sendto+0x19c>
      PRINT_ERR("<Cellular_Service> IP address too long")
 80178ce:	4e77      	ldr	r6, [pc, #476]	; (8017aac <CDS_socket_sendto+0x248>)
 80178d0:	4d73      	ldr	r5, [pc, #460]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80178d2:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80178d6:	4634      	mov	r4, r6
 80178d8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80178da:	6028      	str	r0, [r5, #0]
 80178dc:	6069      	str	r1, [r5, #4]
 80178de:	60aa      	str	r2, [r5, #8]
 80178e0:	60eb      	str	r3, [r5, #12]
 80178e2:	4626      	mov	r6, r4
 80178e4:	3510      	adds	r5, #16
 80178e6:	42bc      	cmp	r4, r7
 80178e8:	d1f5      	bne.n	80178d6 <CDS_socket_sendto+0x72>
 80178ea:	8823      	ldrh	r3, [r4, #0]
 80178ec:	802b      	strh	r3, [r5, #0]
 80178ee:	4c6c      	ldr	r4, [pc, #432]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80178f0:	4620      	mov	r0, r4
 80178f2:	f007 fc0e 	bl	801f112 <crs_strlen>
 80178f6:	b283      	uxth	r3, r0
 80178f8:	4622      	mov	r2, r4
 80178fa:	2110      	movs	r1, #16
 80178fc:	2001      	movs	r0, #1
 80178fe:	f007 fc4b 	bl	801f198 <traceIF_itmPrint>
 8017902:	4620      	mov	r0, r4
 8017904:	f007 fc05 	bl	801f112 <crs_strlen>
 8017908:	b283      	uxth	r3, r0
 801790a:	4622      	mov	r2, r4
 801790c:	2110      	movs	r1, #16
 801790e:	2001      	movs	r0, #1
 8017910:	f007 fc64 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017914:	e016      	b.n	8017944 <CDS_socket_sendto+0xe0>
    PRINT_ERR("<Cellular_Service> socket not connected (state=%d) for handle %ld (send)",
 8017916:	4633      	mov	r3, r6
 8017918:	4965      	ldr	r1, [pc, #404]	; (8017ab0 <CDS_socket_sendto+0x24c>)
 801791a:	4620      	mov	r0, r4
 801791c:	f00e f9a8 	bl	8025c70 <sprintf>
 8017920:	4620      	mov	r0, r4
 8017922:	f007 fbf6 	bl	801f112 <crs_strlen>
 8017926:	b283      	uxth	r3, r0
 8017928:	4622      	mov	r2, r4
 801792a:	2110      	movs	r1, #16
 801792c:	2001      	movs	r0, #1
 801792e:	f007 fc33 	bl	801f198 <traceIF_itmPrint>
 8017932:	4620      	mov	r0, r4
 8017934:	f007 fbed 	bl	801f112 <crs_strlen>
 8017938:	b283      	uxth	r3, r0
 801793a:	4622      	mov	r2, r4
 801793c:	2110      	movs	r1, #16
 801793e:	2001      	movs	r0, #1
 8017940:	f007 fc4c 	bl	801f1dc <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when sending data to socket (sendto)")
 8017944:	4c56      	ldr	r4, [pc, #344]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017946:	2249      	movs	r2, #73	; 0x49
 8017948:	495a      	ldr	r1, [pc, #360]	; (8017ab4 <CDS_socket_sendto+0x250>)
 801794a:	4620      	mov	r0, r4
 801794c:	f00e fae0 	bl	8025f10 <memcpy>
 8017950:	4620      	mov	r0, r4
 8017952:	f007 fbde 	bl	801f112 <crs_strlen>
 8017956:	b283      	uxth	r3, r0
 8017958:	4622      	mov	r2, r4
 801795a:	2110      	movs	r1, #16
 801795c:	2001      	movs	r0, #1
 801795e:	f007 fc1b 	bl	801f198 <traceIF_itmPrint>
 8017962:	4620      	mov	r0, r4
 8017964:	f007 fbd5 	bl	801f112 <crs_strlen>
 8017968:	b283      	uxth	r3, r0
 801796a:	4622      	mov	r2, r4
 801796c:	2110      	movs	r1, #16
 801796e:	2001      	movs	r0, #1
 8017970:	f007 fc34 	bl	801f1dc <traceIF_uartPrint>
 8017974:	2401      	movs	r4, #1
}
 8017976:	4620      	mov	r0, r4
 8017978:	b017      	add	sp, #92	; 0x5c
 801797a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("<Cellular_Service> buffer size %ld exceed maximum value %d",
 801797e:	4c48      	ldr	r4, [pc, #288]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017980:	462a      	mov	r2, r5
 8017982:	494d      	ldr	r1, [pc, #308]	; (8017ab8 <CDS_socket_sendto+0x254>)
 8017984:	4620      	mov	r0, r4
 8017986:	f00e f973 	bl	8025c70 <sprintf>
 801798a:	4620      	mov	r0, r4
 801798c:	f007 fbc1 	bl	801f112 <crs_strlen>
 8017990:	b283      	uxth	r3, r0
 8017992:	4622      	mov	r2, r4
 8017994:	2110      	movs	r1, #16
 8017996:	2001      	movs	r0, #1
 8017998:	f007 fbfe 	bl	801f198 <traceIF_itmPrint>
 801799c:	4620      	mov	r0, r4
 801799e:	f007 fbb8 	bl	801f112 <crs_strlen>
 80179a2:	b283      	uxth	r3, r0
 80179a4:	4622      	mov	r2, r4
 80179a6:	2110      	movs	r1, #16
 80179a8:	2001      	movs	r0, #1
 80179aa:	f007 fc17 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80179ae:	e7c9      	b.n	8017944 <CDS_socket_sendto+0xe0>
    PRINT_ERR("<Cellular_Service> NULL ptr")
 80179b0:	4e42      	ldr	r6, [pc, #264]	; (8017abc <CDS_socket_sendto+0x258>)
 80179b2:	4c3b      	ldr	r4, [pc, #236]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80179b4:	f106 0720 	add.w	r7, r6, #32
 80179b8:	4635      	mov	r5, r6
 80179ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80179bc:	6020      	str	r0, [r4, #0]
 80179be:	6061      	str	r1, [r4, #4]
 80179c0:	60a2      	str	r2, [r4, #8]
 80179c2:	60e3      	str	r3, [r4, #12]
 80179c4:	462e      	mov	r6, r5
 80179c6:	3410      	adds	r4, #16
 80179c8:	42bd      	cmp	r5, r7
 80179ca:	d1f5      	bne.n	80179b8 <CDS_socket_sendto+0x154>
 80179cc:	6828      	ldr	r0, [r5, #0]
 80179ce:	6020      	str	r0, [r4, #0]
 80179d0:	88aa      	ldrh	r2, [r5, #4]
 80179d2:	79ab      	ldrb	r3, [r5, #6]
 80179d4:	80a2      	strh	r2, [r4, #4]
 80179d6:	71a3      	strb	r3, [r4, #6]
 80179d8:	4c31      	ldr	r4, [pc, #196]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80179da:	4620      	mov	r0, r4
 80179dc:	f007 fb99 	bl	801f112 <crs_strlen>
 80179e0:	b283      	uxth	r3, r0
 80179e2:	4622      	mov	r2, r4
 80179e4:	2110      	movs	r1, #16
 80179e6:	2001      	movs	r0, #1
 80179e8:	f007 fbd6 	bl	801f198 <traceIF_itmPrint>
 80179ec:	4620      	mov	r0, r4
 80179ee:	f007 fb90 	bl	801f112 <crs_strlen>
 80179f2:	b283      	uxth	r3, r0
 80179f4:	4622      	mov	r2, r4
 80179f6:	2110      	movs	r1, #16
 80179f8:	2001      	movs	r0, #1
 80179fa:	f007 fbef 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80179fe:	e7a1      	b.n	8017944 <CDS_socket_sendto+0xe0>
      (void) memset((void *)&send_data_struct, 0, sizeof(csint_socket_data_buffer_t));
 8017a00:	f04f 0958 	mov.w	r9, #88	; 0x58
 8017a04:	464a      	mov	r2, r9
 8017a06:	2100      	movs	r1, #0
 8017a08:	4668      	mov	r0, sp
 8017a0a:	f00e f9a4 	bl	8025d56 <memset>
      send_data_struct.socket_handle = sockHandle;
 8017a0e:	9600      	str	r6, [sp, #0]
      send_data_struct.p_buffer_addr_send = p_buf;
 8017a10:	9701      	str	r7, [sp, #4]
      send_data_struct.buffer_size = length;
 8017a12:	9503      	str	r5, [sp, #12]
      send_data_struct.max_buffer_size = length;
 8017a14:	9504      	str	r5, [sp, #16]
      send_data_struct.ip_addr_type = ip_addr_type;
 8017a16:	f88d 8014 	strb.w	r8, [sp, #20]
      (void) memcpy((void *)send_data_struct.ip_addr_value,
 8017a1a:	4622      	mov	r2, r4
 8017a1c:	991e      	ldr	r1, [sp, #120]	; 0x78
 8017a1e:	f10d 0015 	add.w	r0, sp, #21
 8017a22:	f00e fa75 	bl	8025f10 <memcpy>
      send_data_struct.remote_port = remote_port;
 8017a26:	f8bd 307c 	ldrh.w	r3, [sp, #124]	; 0x7c
 8017a2a:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
      if (DATAPACK_writeStruct(&cmd_buf[0],
 8017a2e:	466b      	mov	r3, sp
 8017a30:	464a      	mov	r2, r9
 8017a32:	2119      	movs	r1, #25
 8017a34:	4822      	ldr	r0, [pc, #136]	; (8017ac0 <CDS_socket_sendto+0x25c>)
 8017a36:	f7f4 fb3d 	bl	800c0b4 <DATAPACK_writeStruct>
 8017a3a:	2800      	cmp	r0, #0
 8017a3c:	d182      	bne.n	8017944 <CDS_socket_sendto+0xe0>
        err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SEND_DATA, &cmd_buf[0], &rsp_buf[0]);
 8017a3e:	4b21      	ldr	r3, [pc, #132]	; (8017ac4 <CDS_socket_sendto+0x260>)
 8017a40:	4a1f      	ldr	r2, [pc, #124]	; (8017ac0 <CDS_socket_sendto+0x25c>)
 8017a42:	217a      	movs	r1, #122	; 0x7a
 8017a44:	4820      	ldr	r0, [pc, #128]	; (8017ac8 <CDS_socket_sendto+0x264>)
 8017a46:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017a4a:	f7f4 f8cb 	bl	800bbe4 <AT_sendcmd>
        if (err == ATSTATUS_OK)
 8017a4e:	4604      	mov	r4, r0
 8017a50:	2800      	cmp	r0, #0
 8017a52:	f47f af77 	bne.w	8017944 <CDS_socket_sendto+0xe0>
          PRINT_DBG("<Cellular_Service> socket data sent (sendto)")
 8017a56:	4f1d      	ldr	r7, [pc, #116]	; (8017acc <CDS_socket_sendto+0x268>)
 8017a58:	4e11      	ldr	r6, [pc, #68]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017a5a:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8017a5e:	463d      	mov	r5, r7
 8017a60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017a62:	6030      	str	r0, [r6, #0]
 8017a64:	6071      	str	r1, [r6, #4]
 8017a66:	60b2      	str	r2, [r6, #8]
 8017a68:	60f3      	str	r3, [r6, #12]
 8017a6a:	462f      	mov	r7, r5
 8017a6c:	3610      	adds	r6, #16
 8017a6e:	4565      	cmp	r5, ip
 8017a70:	d1f5      	bne.n	8017a5e <CDS_socket_sendto+0x1fa>
 8017a72:	882b      	ldrh	r3, [r5, #0]
 8017a74:	8033      	strh	r3, [r6, #0]
 8017a76:	4d0a      	ldr	r5, [pc, #40]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017a78:	4628      	mov	r0, r5
 8017a7a:	f007 fb4a 	bl	801f112 <crs_strlen>
 8017a7e:	b283      	uxth	r3, r0
 8017a80:	462a      	mov	r2, r5
 8017a82:	2102      	movs	r1, #2
 8017a84:	2001      	movs	r0, #1
 8017a86:	f007 fb87 	bl	801f198 <traceIF_itmPrint>
 8017a8a:	4628      	mov	r0, r5
 8017a8c:	f007 fb41 	bl	801f112 <crs_strlen>
 8017a90:	b283      	uxth	r3, r0
 8017a92:	462a      	mov	r2, r5
 8017a94:	2102      	movs	r1, #2
 8017a96:	2001      	movs	r0, #1
 8017a98:	f007 fba0 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017a9c:	e76b      	b.n	8017976 <CDS_socket_sendto+0x112>
 8017a9e:	bf00      	nop
 8017aa0:	200047dc 	.word	0x200047dc
 8017aa4:	08031f1c 	.word	0x08031f1c
 8017aa8:	20003d18 	.word	0x20003d18
 8017aac:	08032084 	.word	0x08032084
 8017ab0:	08031f9c 	.word	0x08031f9c
 8017ab4:	080320ec 	.word	0x080320ec
 8017ab8:	08031f54 	.word	0x08031f54
 8017abc:	0803205c 	.word	0x0803205c
 8017ac0:	20003620 	.word	0x20003620
 8017ac4:	20003814 	.word	0x20003814
 8017ac8:	2000361c 	.word	0x2000361c
 8017acc:	080320b8 	.word	0x080320b8

08017ad0 <CDS_socket_close>:
{
 8017ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017ad2:	4606      	mov	r6, r0
  PRINT_API("CDS_socket_close")
 8017ad4:	4c71      	ldr	r4, [pc, #452]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017ad6:	4d72      	ldr	r5, [pc, #456]	; (8017ca0 <CDS_socket_close+0x1d0>)
 8017ad8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017ada:	6020      	str	r0, [r4, #0]
 8017adc:	6061      	str	r1, [r4, #4]
 8017ade:	60a2      	str	r2, [r4, #8]
 8017ae0:	60e3      	str	r3, [r4, #12]
 8017ae2:	cd03      	ldmia	r5!, {r0, r1}
 8017ae4:	6120      	str	r0, [r4, #16]
 8017ae6:	6161      	str	r1, [r4, #20]
 8017ae8:	882b      	ldrh	r3, [r5, #0]
 8017aea:	8323      	strh	r3, [r4, #24]
 8017aec:	4620      	mov	r0, r4
 8017aee:	f007 fb10 	bl	801f112 <crs_strlen>
 8017af2:	b283      	uxth	r3, r0
 8017af4:	4622      	mov	r2, r4
 8017af6:	2104      	movs	r1, #4
 8017af8:	2001      	movs	r0, #1
 8017afa:	f007 fb4d 	bl	801f198 <traceIF_itmPrint>
 8017afe:	4620      	mov	r0, r4
 8017b00:	f007 fb07 	bl	801f112 <crs_strlen>
 8017b04:	b283      	uxth	r3, r0
 8017b06:	4622      	mov	r2, r4
 8017b08:	2104      	movs	r1, #4
 8017b0a:	2001      	movs	r0, #1
 8017b0c:	f007 fb66 	bl	801f1dc <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_CONNECTED)
 8017b10:	4b64      	ldr	r3, [pc, #400]	; (8017ca4 <CDS_socket_close+0x1d4>)
 8017b12:	226c      	movs	r2, #108	; 0x6c
 8017b14:	fb02 3306 	mla	r3, r2, r6, r3
 8017b18:	791a      	ldrb	r2, [r3, #4]
 8017b1a:	2a02      	cmp	r2, #2
 8017b1c:	d046      	beq.n	8017bac <CDS_socket_close+0xdc>
  else if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_CREATED)
 8017b1e:	2a01      	cmp	r2, #1
 8017b20:	d05d      	beq.n	8017bde <CDS_socket_close+0x10e>
  else if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_NOT_ALLOC)
 8017b22:	2a00      	cmp	r2, #0
 8017b24:	f000 8083 	beq.w	8017c2e <CDS_socket_close+0x15e>
  else if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_ALLOC_BUT_INVALID)
 8017b28:	2a03      	cmp	r2, #3
 8017b2a:	f000 8099 	beq.w	8017c60 <CDS_socket_close+0x190>
    PRINT_ERR("<Cellular_Service> invalid socket state %d (close)", cs_ctxt_sockets_info[sockHandle].state)
 8017b2e:	4c5b      	ldr	r4, [pc, #364]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017b30:	495d      	ldr	r1, [pc, #372]	; (8017ca8 <CDS_socket_close+0x1d8>)
 8017b32:	4620      	mov	r0, r4
 8017b34:	f00e f89c 	bl	8025c70 <sprintf>
 8017b38:	4620      	mov	r0, r4
 8017b3a:	f007 faea 	bl	801f112 <crs_strlen>
 8017b3e:	b283      	uxth	r3, r0
 8017b40:	4622      	mov	r2, r4
 8017b42:	2110      	movs	r1, #16
 8017b44:	2001      	movs	r0, #1
 8017b46:	f007 fb27 	bl	801f198 <traceIF_itmPrint>
 8017b4a:	4620      	mov	r0, r4
 8017b4c:	f007 fae1 	bl	801f112 <crs_strlen>
 8017b50:	b283      	uxth	r3, r0
 8017b52:	4622      	mov	r2, r4
 8017b54:	2110      	movs	r1, #16
 8017b56:	2001      	movs	r0, #1
 8017b58:	f007 fb40 	bl	801f1dc <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when closing socket")
 8017b5c:	4c53      	ldr	r4, [pc, #332]	; (8017cac <CDS_socket_close+0x1dc>)
 8017b5e:	4d4f      	ldr	r5, [pc, #316]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017b60:	f104 0630 	add.w	r6, r4, #48	; 0x30
 8017b64:	46a4      	mov	ip, r4
 8017b66:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017b6a:	6028      	str	r0, [r5, #0]
 8017b6c:	6069      	str	r1, [r5, #4]
 8017b6e:	60aa      	str	r2, [r5, #8]
 8017b70:	60eb      	str	r3, [r5, #12]
 8017b72:	4664      	mov	r4, ip
 8017b74:	3510      	adds	r5, #16
 8017b76:	45b4      	cmp	ip, r6
 8017b78:	d1f4      	bne.n	8017b64 <CDS_socket_close+0x94>
 8017b7a:	cc03      	ldmia	r4!, {r0, r1}
 8017b7c:	6028      	str	r0, [r5, #0]
 8017b7e:	6069      	str	r1, [r5, #4]
 8017b80:	4c46      	ldr	r4, [pc, #280]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017b82:	4620      	mov	r0, r4
 8017b84:	f007 fac5 	bl	801f112 <crs_strlen>
 8017b88:	b283      	uxth	r3, r0
 8017b8a:	4622      	mov	r2, r4
 8017b8c:	2110      	movs	r1, #16
 8017b8e:	2001      	movs	r0, #1
 8017b90:	f007 fb02 	bl	801f198 <traceIF_itmPrint>
 8017b94:	4620      	mov	r0, r4
 8017b96:	f007 fabc 	bl	801f112 <crs_strlen>
 8017b9a:	b283      	uxth	r3, r0
 8017b9c:	4622      	mov	r2, r4
 8017b9e:	2110      	movs	r1, #16
 8017ba0:	2001      	movs	r0, #1
 8017ba2:	f007 fb1b 	bl	801f1dc <traceIF_uartPrint>
 8017ba6:	2401      	movs	r4, #1
}
 8017ba8:	4620      	mov	r0, r4
 8017baa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (DATAPACK_writePtr(&cmd_buf[0],
 8017bac:	226c      	movs	r2, #108	; 0x6c
 8017bae:	4b3d      	ldr	r3, [pc, #244]	; (8017ca4 <CDS_socket_close+0x1d4>)
 8017bb0:	fb02 3206 	mla	r2, r2, r6, r3
 8017bb4:	2118      	movs	r1, #24
 8017bb6:	483e      	ldr	r0, [pc, #248]	; (8017cb0 <CDS_socket_close+0x1e0>)
 8017bb8:	f7f4 fa4c 	bl	800c054 <DATAPACK_writePtr>
 8017bbc:	2800      	cmp	r0, #0
 8017bbe:	d1cd      	bne.n	8017b5c <CDS_socket_close+0x8c>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SOCKET_CLOSE, &cmd_buf[0], &rsp_buf[0]);
 8017bc0:	4b3c      	ldr	r3, [pc, #240]	; (8017cb4 <CDS_socket_close+0x1e4>)
 8017bc2:	4a3b      	ldr	r2, [pc, #236]	; (8017cb0 <CDS_socket_close+0x1e0>)
 8017bc4:	217d      	movs	r1, #125	; 0x7d
 8017bc6:	483c      	ldr	r0, [pc, #240]	; (8017cb8 <CDS_socket_close+0x1e8>)
 8017bc8:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017bcc:	f7f4 f80a 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017bd0:	4604      	mov	r4, r0
 8017bd2:	2800      	cmp	r0, #0
 8017bd4:	d1c2      	bne.n	8017b5c <CDS_socket_close+0x8c>
        csint_socket_deallocateHandle(sockHandle);
 8017bd6:	4630      	mov	r0, r6
 8017bd8:	f002 fc50 	bl	801a47c <csint_socket_deallocateHandle>
  if (retval == CELLULAR_ERROR)
 8017bdc:	e7e4      	b.n	8017ba8 <CDS_socket_close+0xd8>
    PRINT_INFO("<Cellular_Service> socket was not connected ")
 8017bde:	4f37      	ldr	r7, [pc, #220]	; (8017cbc <CDS_socket_close+0x1ec>)
 8017be0:	4d2e      	ldr	r5, [pc, #184]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017be2:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8017be6:	463c      	mov	r4, r7
 8017be8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8017bea:	6028      	str	r0, [r5, #0]
 8017bec:	6069      	str	r1, [r5, #4]
 8017bee:	60aa      	str	r2, [r5, #8]
 8017bf0:	60eb      	str	r3, [r5, #12]
 8017bf2:	4627      	mov	r7, r4
 8017bf4:	3510      	adds	r5, #16
 8017bf6:	4564      	cmp	r4, ip
 8017bf8:	d1f5      	bne.n	8017be6 <CDS_socket_close+0x116>
 8017bfa:	8823      	ldrh	r3, [r4, #0]
 8017bfc:	802b      	strh	r3, [r5, #0]
 8017bfe:	4c27      	ldr	r4, [pc, #156]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017c00:	4620      	mov	r0, r4
 8017c02:	f007 fa86 	bl	801f112 <crs_strlen>
 8017c06:	b283      	uxth	r3, r0
 8017c08:	4622      	mov	r2, r4
 8017c0a:	2101      	movs	r1, #1
 8017c0c:	4608      	mov	r0, r1
 8017c0e:	f007 fac3 	bl	801f198 <traceIF_itmPrint>
 8017c12:	4620      	mov	r0, r4
 8017c14:	f007 fa7d 	bl	801f112 <crs_strlen>
 8017c18:	b283      	uxth	r3, r0
 8017c1a:	4622      	mov	r2, r4
 8017c1c:	2101      	movs	r1, #1
 8017c1e:	4608      	mov	r0, r1
 8017c20:	f007 fadc 	bl	801f1dc <traceIF_uartPrint>
    csint_socket_deallocateHandle(sockHandle);
 8017c24:	4630      	mov	r0, r6
 8017c26:	f002 fc29 	bl	801a47c <csint_socket_deallocateHandle>
    retval = CELLULAR_OK;
 8017c2a:	2400      	movs	r4, #0
 8017c2c:	e7bc      	b.n	8017ba8 <CDS_socket_close+0xd8>
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (close)", sockHandle)
 8017c2e:	4c1b      	ldr	r4, [pc, #108]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017c30:	4632      	mov	r2, r6
 8017c32:	4923      	ldr	r1, [pc, #140]	; (8017cc0 <CDS_socket_close+0x1f0>)
 8017c34:	4620      	mov	r0, r4
 8017c36:	f00e f81b 	bl	8025c70 <sprintf>
 8017c3a:	4620      	mov	r0, r4
 8017c3c:	f007 fa69 	bl	801f112 <crs_strlen>
 8017c40:	b283      	uxth	r3, r0
 8017c42:	4622      	mov	r2, r4
 8017c44:	2110      	movs	r1, #16
 8017c46:	2001      	movs	r0, #1
 8017c48:	f007 faa6 	bl	801f198 <traceIF_itmPrint>
 8017c4c:	4620      	mov	r0, r4
 8017c4e:	f007 fa60 	bl	801f112 <crs_strlen>
 8017c52:	b283      	uxth	r3, r0
 8017c54:	4622      	mov	r2, r4
 8017c56:	2110      	movs	r1, #16
 8017c58:	2001      	movs	r0, #1
 8017c5a:	f007 fabf 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017c5e:	e77d      	b.n	8017b5c <CDS_socket_close+0x8c>
    PRINT_INFO("<Cellular_Service> invalid socket state (after modem reboot) ")
 8017c60:	4c0e      	ldr	r4, [pc, #56]	; (8017c9c <CDS_socket_close+0x1cc>)
 8017c62:	2243      	movs	r2, #67	; 0x43
 8017c64:	4917      	ldr	r1, [pc, #92]	; (8017cc4 <CDS_socket_close+0x1f4>)
 8017c66:	4620      	mov	r0, r4
 8017c68:	f00e f952 	bl	8025f10 <memcpy>
 8017c6c:	4620      	mov	r0, r4
 8017c6e:	f007 fa50 	bl	801f112 <crs_strlen>
 8017c72:	b283      	uxth	r3, r0
 8017c74:	4622      	mov	r2, r4
 8017c76:	2101      	movs	r1, #1
 8017c78:	4608      	mov	r0, r1
 8017c7a:	f007 fa8d 	bl	801f198 <traceIF_itmPrint>
 8017c7e:	4620      	mov	r0, r4
 8017c80:	f007 fa47 	bl	801f112 <crs_strlen>
 8017c84:	b283      	uxth	r3, r0
 8017c86:	4622      	mov	r2, r4
 8017c88:	2101      	movs	r1, #1
 8017c8a:	4608      	mov	r0, r1
 8017c8c:	f007 faa6 	bl	801f1dc <traceIF_uartPrint>
    csint_socket_deallocateHandle(sockHandle);
 8017c90:	4630      	mov	r0, r6
 8017c92:	f002 fbf3 	bl	801a47c <csint_socket_deallocateHandle>
    retval = CELLULAR_OK;
 8017c96:	2400      	movs	r4, #0
 8017c98:	e786      	b.n	8017ba8 <CDS_socket_close+0xd8>
 8017c9a:	bf00      	nop
 8017c9c:	200047dc 	.word	0x200047dc
 8017ca0:	08032138 	.word	0x08032138
 8017ca4:	20003d18 	.word	0x20003d18
 8017ca8:	0803220c 	.word	0x0803220c
 8017cac:	0803224c 	.word	0x0803224c
 8017cb0:	20003620 	.word	0x20003620
 8017cb4:	20003814 	.word	0x20003814
 8017cb8:	2000361c 	.word	0x2000361c
 8017cbc:	08032154 	.word	0x08032154
 8017cc0:	08032188 	.word	0x08032188
 8017cc4:	080321c8 	.word	0x080321c8

08017cc8 <CS_direct_cmd>:
{
 8017cc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017cca:	4606      	mov	r6, r0
  PRINT_API("CS_direct_cmd")
 8017ccc:	4c50      	ldr	r4, [pc, #320]	; (8017e10 <CS_direct_cmd+0x148>)
 8017cce:	4d51      	ldr	r5, [pc, #324]	; (8017e14 <CS_direct_cmd+0x14c>)
 8017cd0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017cd2:	6020      	str	r0, [r4, #0]
 8017cd4:	6061      	str	r1, [r4, #4]
 8017cd6:	60a2      	str	r2, [r4, #8]
 8017cd8:	60e3      	str	r3, [r4, #12]
 8017cda:	6828      	ldr	r0, [r5, #0]
 8017cdc:	6120      	str	r0, [r4, #16]
 8017cde:	88aa      	ldrh	r2, [r5, #4]
 8017ce0:	79ab      	ldrb	r3, [r5, #6]
 8017ce2:	82a2      	strh	r2, [r4, #20]
 8017ce4:	75a3      	strb	r3, [r4, #22]
 8017ce6:	4620      	mov	r0, r4
 8017ce8:	f007 fa13 	bl	801f112 <crs_strlen>
 8017cec:	b283      	uxth	r3, r0
 8017cee:	4622      	mov	r2, r4
 8017cf0:	2104      	movs	r1, #4
 8017cf2:	2001      	movs	r0, #1
 8017cf4:	f007 fa50 	bl	801f198 <traceIF_itmPrint>
 8017cf8:	4620      	mov	r0, r4
 8017cfa:	f007 fa0a 	bl	801f112 <crs_strlen>
 8017cfe:	b283      	uxth	r3, r0
 8017d00:	4622      	mov	r2, r4
 8017d02:	2104      	movs	r1, #4
 8017d04:	2001      	movs	r0, #1
 8017d06:	f007 fa69 	bl	801f1dc <traceIF_uartPrint>
  if (direct_cmd_tx->cmd_size <= MAX_DIRECT_CMD_SIZE)
 8017d0a:	f8b6 3076 	ldrh.w	r3, [r6, #118]	; 0x76
 8017d0e:	2b76      	cmp	r3, #118	; 0x76
 8017d10:	d83d      	bhi.n	8017d8e <CS_direct_cmd+0xc6>
    if (DATAPACK_writePtr(&cmd_buf[0],
 8017d12:	4632      	mov	r2, r6
 8017d14:	212b      	movs	r1, #43	; 0x2b
 8017d16:	4840      	ldr	r0, [pc, #256]	; (8017e18 <CS_direct_cmd+0x150>)
 8017d18:	f7f4 f99c 	bl	800c054 <DATAPACK_writePtr>
 8017d1c:	b108      	cbz	r0, 8017d22 <CS_direct_cmd+0x5a>
  CS_Status_t retval = CELLULAR_ERROR;
 8017d1e:	2601      	movs	r6, #1
 8017d20:	e04e      	b.n	8017dc0 <CS_direct_cmd+0xf8>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_DIRECT_CMD, &cmd_buf[0], &rsp_buf[0]);
 8017d22:	4b3e      	ldr	r3, [pc, #248]	; (8017e1c <CS_direct_cmd+0x154>)
 8017d24:	4a3c      	ldr	r2, [pc, #240]	; (8017e18 <CS_direct_cmd+0x150>)
 8017d26:	2186      	movs	r1, #134	; 0x86
 8017d28:	483d      	ldr	r0, [pc, #244]	; (8017e20 <CS_direct_cmd+0x158>)
 8017d2a:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017d2e:	f7f3 ff59 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017d32:	4606      	mov	r6, r0
 8017d34:	bb20      	cbnz	r0, 8017d80 <CS_direct_cmd+0xb8>
        PRINT_DBG("<Cellular_Service> Direct command infos received")
 8017d36:	4f3b      	ldr	r7, [pc, #236]	; (8017e24 <CS_direct_cmd+0x15c>)
 8017d38:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8017d3c:	463d      	mov	r5, r7
 8017d3e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017d40:	6020      	str	r0, [r4, #0]
 8017d42:	6061      	str	r1, [r4, #4]
 8017d44:	60a2      	str	r2, [r4, #8]
 8017d46:	60e3      	str	r3, [r4, #12]
 8017d48:	462f      	mov	r7, r5
 8017d4a:	3410      	adds	r4, #16
 8017d4c:	4565      	cmp	r5, ip
 8017d4e:	d1f5      	bne.n	8017d3c <CS_direct_cmd+0x74>
 8017d50:	6828      	ldr	r0, [r5, #0]
 8017d52:	6020      	str	r0, [r4, #0]
 8017d54:	88ab      	ldrh	r3, [r5, #4]
 8017d56:	80a3      	strh	r3, [r4, #4]
 8017d58:	4c2d      	ldr	r4, [pc, #180]	; (8017e10 <CS_direct_cmd+0x148>)
 8017d5a:	4620      	mov	r0, r4
 8017d5c:	f007 f9d9 	bl	801f112 <crs_strlen>
 8017d60:	b283      	uxth	r3, r0
 8017d62:	4622      	mov	r2, r4
 8017d64:	2102      	movs	r1, #2
 8017d66:	2001      	movs	r0, #1
 8017d68:	f007 fa16 	bl	801f198 <traceIF_itmPrint>
 8017d6c:	4620      	mov	r0, r4
 8017d6e:	f007 f9d0 	bl	801f112 <crs_strlen>
 8017d72:	b283      	uxth	r3, r0
 8017d74:	4622      	mov	r2, r4
 8017d76:	2102      	movs	r1, #2
 8017d78:	2001      	movs	r0, #1
 8017d7a:	f007 fa2f 	bl	801f1dc <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017d7e:	e045      	b.n	8017e0c <CS_direct_cmd+0x144>
        retval = CELLULAR_analyze_error_report(&rsp_buf[0]);
 8017d80:	4826      	ldr	r0, [pc, #152]	; (8017e1c <CS_direct_cmd+0x154>)
 8017d82:	f7fd febd 	bl	8015b00 <CELLULAR_analyze_error_report>
 8017d86:	4606      	mov	r6, r0
  if (retval == CELLULAR_ERROR)
 8017d88:	2801      	cmp	r0, #1
 8017d8a:	d13f      	bne.n	8017e0c <CS_direct_cmd+0x144>
 8017d8c:	e018      	b.n	8017dc0 <CS_direct_cmd+0xf8>
    PRINT_INFO("<Cellular_Service> Direct command command size to big (limit=%d)", MAX_DIRECT_CMD_SIZE)
 8017d8e:	4c20      	ldr	r4, [pc, #128]	; (8017e10 <CS_direct_cmd+0x148>)
 8017d90:	2276      	movs	r2, #118	; 0x76
 8017d92:	4925      	ldr	r1, [pc, #148]	; (8017e28 <CS_direct_cmd+0x160>)
 8017d94:	4620      	mov	r0, r4
 8017d96:	f00d ff6b 	bl	8025c70 <sprintf>
 8017d9a:	4620      	mov	r0, r4
 8017d9c:	f007 f9b9 	bl	801f112 <crs_strlen>
 8017da0:	b283      	uxth	r3, r0
 8017da2:	4622      	mov	r2, r4
 8017da4:	2101      	movs	r1, #1
 8017da6:	4608      	mov	r0, r1
 8017da8:	f007 f9f6 	bl	801f198 <traceIF_itmPrint>
 8017dac:	4620      	mov	r0, r4
 8017dae:	f007 f9b0 	bl	801f112 <crs_strlen>
 8017db2:	b283      	uxth	r3, r0
 8017db4:	4622      	mov	r2, r4
 8017db6:	2101      	movs	r1, #1
 8017db8:	4608      	mov	r0, r1
 8017dba:	f007 fa0f 	bl	801f1dc <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 8017dbe:	2601      	movs	r6, #1
    PRINT_ERR("<Cellular_Service> error when sending direct cmd")
 8017dc0:	4c1a      	ldr	r4, [pc, #104]	; (8017e2c <CS_direct_cmd+0x164>)
 8017dc2:	4d13      	ldr	r5, [pc, #76]	; (8017e10 <CS_direct_cmd+0x148>)
 8017dc4:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8017dc8:	46a4      	mov	ip, r4
 8017dca:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017dce:	6028      	str	r0, [r5, #0]
 8017dd0:	6069      	str	r1, [r5, #4]
 8017dd2:	60aa      	str	r2, [r5, #8]
 8017dd4:	60eb      	str	r3, [r5, #12]
 8017dd6:	4664      	mov	r4, ip
 8017dd8:	3510      	adds	r5, #16
 8017dda:	45f4      	cmp	ip, lr
 8017ddc:	d1f4      	bne.n	8017dc8 <CS_direct_cmd+0x100>
 8017dde:	cc07      	ldmia	r4!, {r0, r1, r2}
 8017de0:	6028      	str	r0, [r5, #0]
 8017de2:	6069      	str	r1, [r5, #4]
 8017de4:	60aa      	str	r2, [r5, #8]
 8017de6:	4c0a      	ldr	r4, [pc, #40]	; (8017e10 <CS_direct_cmd+0x148>)
 8017de8:	4620      	mov	r0, r4
 8017dea:	f007 f992 	bl	801f112 <crs_strlen>
 8017dee:	b283      	uxth	r3, r0
 8017df0:	4622      	mov	r2, r4
 8017df2:	2110      	movs	r1, #16
 8017df4:	2001      	movs	r0, #1
 8017df6:	f007 f9cf 	bl	801f198 <traceIF_itmPrint>
 8017dfa:	4620      	mov	r0, r4
 8017dfc:	f007 f989 	bl	801f112 <crs_strlen>
 8017e00:	b283      	uxth	r3, r0
 8017e02:	4622      	mov	r2, r4
 8017e04:	2110      	movs	r1, #16
 8017e06:	2001      	movs	r0, #1
 8017e08:	f007 f9e8 	bl	801f1dc <traceIF_uartPrint>
}
 8017e0c:	4630      	mov	r0, r6
 8017e0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017e10:	200047dc 	.word	0x200047dc
 8017e14:	08032284 	.word	0x08032284
 8017e18:	20003620 	.word	0x20003620
 8017e1c:	20003814 	.word	0x20003814
 8017e20:	2000361c 	.word	0x2000361c
 8017e24:	0803229c 	.word	0x0803229c
 8017e28:	080322d4 	.word	0x080322d4
 8017e2c:	0803231c 	.word	0x0803231c

08017e30 <CST_cellular_direct_cmd_callback>:
  * @brief  at processing callback
  * @param  direct_cmd_rx - rx command line
  * @retval -
  */
static void CST_cellular_direct_cmd_callback(CS_direct_cmd_rx_t direct_cmd_rx)
{
 8017e30:	b084      	sub	sp, #16
 8017e32:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
  UNUSED(direct_cmd_rx);
}
 8017e36:	b004      	add	sp, #16
 8017e38:	4770      	bx	lr
	...

08017e3c <CST_CMD_display_bitmap_name_altair>:
{
 8017e3c:	b538      	push	{r3, r4, r5, lr}
  for (i = 0U; i < CST_CMD_band_count  ; i++)
 8017e3e:	2500      	movs	r5, #0
 8017e40:	e018      	b.n	8017e74 <CST_CMD_display_bitmap_name_altair+0x38>
    PRINT_FORCE("B%d", CST_CMD_band_tab[i])
 8017e42:	4c0f      	ldr	r4, [pc, #60]	; (8017e80 <CST_CMD_display_bitmap_name_altair+0x44>)
 8017e44:	4b0f      	ldr	r3, [pc, #60]	; (8017e84 <CST_CMD_display_bitmap_name_altair+0x48>)
 8017e46:	5d5a      	ldrb	r2, [r3, r5]
 8017e48:	490f      	ldr	r1, [pc, #60]	; (8017e88 <CST_CMD_display_bitmap_name_altair+0x4c>)
 8017e4a:	4620      	mov	r0, r4
 8017e4c:	f00d ff10 	bl	8025c70 <sprintf>
 8017e50:	4620      	mov	r0, r4
 8017e52:	f007 f95e 	bl	801f112 <crs_strlen>
 8017e56:	b283      	uxth	r3, r0
 8017e58:	4622      	mov	r2, r4
 8017e5a:	2101      	movs	r1, #1
 8017e5c:	2007      	movs	r0, #7
 8017e5e:	f007 f99b 	bl	801f198 <traceIF_itmPrint>
 8017e62:	4620      	mov	r0, r4
 8017e64:	f007 f955 	bl	801f112 <crs_strlen>
 8017e68:	b282      	uxth	r2, r0
 8017e6a:	4621      	mov	r1, r4
 8017e6c:	2007      	movs	r0, #7
 8017e6e:	f007 f9cd 	bl	801f20c <traceIF_uartPrintForce>
  for (i = 0U; i < CST_CMD_band_count  ; i++)
 8017e72:	3501      	adds	r5, #1
 8017e74:	4b05      	ldr	r3, [pc, #20]	; (8017e8c <CST_CMD_display_bitmap_name_altair+0x50>)
 8017e76:	781b      	ldrb	r3, [r3, #0]
 8017e78:	42ab      	cmp	r3, r5
 8017e7a:	d8e2      	bhi.n	8017e42 <CST_CMD_display_bitmap_name_altair+0x6>
}
 8017e7c:	bd38      	pop	{r3, r4, r5, pc}
 8017e7e:	bf00      	nop
 8017e80:	20004ddc 	.word	0x20004ddc
 8017e84:	20000048 	.word	0x20000048
 8017e88:	08032358 	.word	0x08032358
 8017e8c:	20000046 	.word	0x20000046

08017e90 <CST_ModemHelpCmd>:
{
 8017e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CMD_print_help(CST_cmd_modem_label);
 8017e94:	48d7      	ldr	r0, [pc, #860]	; (80181f4 <CST_ModemHelpCmd+0x364>)
 8017e96:	f00a f9db 	bl	8022250 <CMD_print_help>
  PRINT_FORCE("--------------------------------------")
 8017e9a:	4cd7      	ldr	r4, [pc, #860]	; (80181f8 <CST_ModemHelpCmd+0x368>)
 8017e9c:	4dd7      	ldr	r5, [pc, #860]	; (80181fc <CST_ModemHelpCmd+0x36c>)
 8017e9e:	f104 0620 	add.w	r6, r4, #32
 8017ea2:	46a4      	mov	ip, r4
 8017ea4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017ea8:	6028      	str	r0, [r5, #0]
 8017eaa:	6069      	str	r1, [r5, #4]
 8017eac:	60aa      	str	r2, [r5, #8]
 8017eae:	60eb      	str	r3, [r5, #12]
 8017eb0:	4664      	mov	r4, ip
 8017eb2:	3510      	adds	r5, #16
 8017eb4:	45b4      	cmp	ip, r6
 8017eb6:	d1f4      	bne.n	8017ea2 <CST_ModemHelpCmd+0x12>
 8017eb8:	cc03      	ldmia	r4!, {r0, r1}
 8017eba:	6028      	str	r0, [r5, #0]
 8017ebc:	6069      	str	r1, [r5, #4]
 8017ebe:	7823      	ldrb	r3, [r4, #0]
 8017ec0:	722b      	strb	r3, [r5, #8]
 8017ec2:	4cce      	ldr	r4, [pc, #824]	; (80181fc <CST_ModemHelpCmd+0x36c>)
 8017ec4:	4620      	mov	r0, r4
 8017ec6:	f007 f924 	bl	801f112 <crs_strlen>
 8017eca:	b283      	uxth	r3, r0
 8017ecc:	4622      	mov	r2, r4
 8017ece:	2101      	movs	r1, #1
 8017ed0:	2007      	movs	r0, #7
 8017ed2:	f007 f961 	bl	801f198 <traceIF_itmPrint>
 8017ed6:	4620      	mov	r0, r4
 8017ed8:	f007 f91b 	bl	801f112 <crs_strlen>
 8017edc:	b282      	uxth	r2, r0
 8017ede:	4621      	mov	r1, r4
 8017ee0:	2007      	movs	r0, #7
 8017ee2:	f007 f993 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("1 - Modem band configuration commands")
 8017ee6:	4dc6      	ldr	r5, [pc, #792]	; (8018200 <CST_ModemHelpCmd+0x370>)
 8017ee8:	f105 0620 	add.w	r6, r5, #32
 8017eec:	46ac      	mov	ip, r5
 8017eee:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017ef2:	6020      	str	r0, [r4, #0]
 8017ef4:	6061      	str	r1, [r4, #4]
 8017ef6:	60a2      	str	r2, [r4, #8]
 8017ef8:	60e3      	str	r3, [r4, #12]
 8017efa:	4665      	mov	r5, ip
 8017efc:	3410      	adds	r4, #16
 8017efe:	45b4      	cmp	ip, r6
 8017f00:	d1f4      	bne.n	8017eec <CST_ModemHelpCmd+0x5c>
 8017f02:	cd03      	ldmia	r5!, {r0, r1}
 8017f04:	6020      	str	r0, [r4, #0]
 8017f06:	6061      	str	r1, [r4, #4]
 8017f08:	4cbc      	ldr	r4, [pc, #752]	; (80181fc <CST_ModemHelpCmd+0x36c>)
 8017f0a:	4620      	mov	r0, r4
 8017f0c:	f007 f901 	bl	801f112 <crs_strlen>
 8017f10:	b283      	uxth	r3, r0
 8017f12:	4622      	mov	r2, r4
 8017f14:	2101      	movs	r1, #1
 8017f16:	2007      	movs	r0, #7
 8017f18:	f007 f93e 	bl	801f198 <traceIF_itmPrint>
 8017f1c:	4620      	mov	r0, r4
 8017f1e:	f007 f8f8 	bl	801f112 <crs_strlen>
 8017f22:	b282      	uxth	r2, r0
 8017f24:	4621      	mov	r1, r4
 8017f26:	2007      	movs	r0, #7
 8017f28:	f007 f970 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("--------------------------------------")
 8017f2c:	4db2      	ldr	r5, [pc, #712]	; (80181f8 <CST_ModemHelpCmd+0x368>)
 8017f2e:	f105 0620 	add.w	r6, r5, #32
 8017f32:	46ac      	mov	ip, r5
 8017f34:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017f38:	6020      	str	r0, [r4, #0]
 8017f3a:	6061      	str	r1, [r4, #4]
 8017f3c:	60a2      	str	r2, [r4, #8]
 8017f3e:	60e3      	str	r3, [r4, #12]
 8017f40:	4665      	mov	r5, ip
 8017f42:	3410      	adds	r4, #16
 8017f44:	45b4      	cmp	ip, r6
 8017f46:	d1f4      	bne.n	8017f32 <CST_ModemHelpCmd+0xa2>
 8017f48:	cd03      	ldmia	r5!, {r0, r1}
 8017f4a:	6020      	str	r0, [r4, #0]
 8017f4c:	6061      	str	r1, [r4, #4]
 8017f4e:	782b      	ldrb	r3, [r5, #0]
 8017f50:	7223      	strb	r3, [r4, #8]
 8017f52:	4caa      	ldr	r4, [pc, #680]	; (80181fc <CST_ModemHelpCmd+0x36c>)
 8017f54:	4620      	mov	r0, r4
 8017f56:	f007 f8dc 	bl	801f112 <crs_strlen>
 8017f5a:	b283      	uxth	r3, r0
 8017f5c:	4622      	mov	r2, r4
 8017f5e:	2101      	movs	r1, #1
 8017f60:	2007      	movs	r0, #7
 8017f62:	f007 f919 	bl	801f198 <traceIF_itmPrint>
 8017f66:	4620      	mov	r0, r4
 8017f68:	f007 f8d3 	bl	801f112 <crs_strlen>
 8017f6c:	b282      	uxth	r2, r0
 8017f6e:	4621      	mov	r1, r4
 8017f70:	2007      	movs	r0, #7
 8017f72:	f007 f94b 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("Modem configuration commands are used to modify the modem band configuration.")
 8017f76:	2250      	movs	r2, #80	; 0x50
 8017f78:	49a2      	ldr	r1, [pc, #648]	; (8018204 <CST_ModemHelpCmd+0x374>)
 8017f7a:	4620      	mov	r0, r4
 8017f7c:	f00d ffc8 	bl	8025f10 <memcpy>
 8017f80:	4620      	mov	r0, r4
 8017f82:	f007 f8c6 	bl	801f112 <crs_strlen>
 8017f86:	b283      	uxth	r3, r0
 8017f88:	4622      	mov	r2, r4
 8017f8a:	2101      	movs	r1, #1
 8017f8c:	2007      	movs	r0, #7
 8017f8e:	f007 f903 	bl	801f198 <traceIF_itmPrint>
 8017f92:	4620      	mov	r0, r4
 8017f94:	f007 f8bd 	bl	801f112 <crs_strlen>
 8017f98:	b282      	uxth	r2, r0
 8017f9a:	4621      	mov	r1, r4
 8017f9c:	2007      	movs	r0, #7
 8017f9e:	f007 f935 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("Setting a new configuration is performed in two steps:")
 8017fa2:	4d99      	ldr	r5, [pc, #612]	; (8018208 <CST_ModemHelpCmd+0x378>)
 8017fa4:	f105 0630 	add.w	r6, r5, #48	; 0x30
 8017fa8:	46ac      	mov	ip, r5
 8017faa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017fae:	6020      	str	r0, [r4, #0]
 8017fb0:	6061      	str	r1, [r4, #4]
 8017fb2:	60a2      	str	r2, [r4, #8]
 8017fb4:	60e3      	str	r3, [r4, #12]
 8017fb6:	4665      	mov	r5, ip
 8017fb8:	3410      	adds	r4, #16
 8017fba:	45b4      	cmp	ip, r6
 8017fbc:	d1f4      	bne.n	8017fa8 <CST_ModemHelpCmd+0x118>
 8017fbe:	cd03      	ldmia	r5!, {r0, r1}
 8017fc0:	6020      	str	r0, [r4, #0]
 8017fc2:	6061      	str	r1, [r4, #4]
 8017fc4:	782b      	ldrb	r3, [r5, #0]
 8017fc6:	7223      	strb	r3, [r4, #8]
 8017fc8:	4c8c      	ldr	r4, [pc, #560]	; (80181fc <CST_ModemHelpCmd+0x36c>)
 8017fca:	4620      	mov	r0, r4
 8017fcc:	f007 f8a1 	bl	801f112 <crs_strlen>
 8017fd0:	b283      	uxth	r3, r0
 8017fd2:	4622      	mov	r2, r4
 8017fd4:	2101      	movs	r1, #1
 8017fd6:	2007      	movs	r0, #7
 8017fd8:	f007 f8de 	bl	801f198 <traceIF_itmPrint>
 8017fdc:	4620      	mov	r0, r4
 8017fde:	f007 f898 	bl	801f112 <crs_strlen>
 8017fe2:	b282      	uxth	r2, r0
 8017fe4:	4621      	mov	r1, r4
 8017fe6:	2007      	movs	r0, #7
 8017fe8:	f007 f910 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 8017fec:	4d87      	ldr	r5, [pc, #540]	; (801820c <CST_ModemHelpCmd+0x37c>)
 8017fee:	6828      	ldr	r0, [r5, #0]
 8017ff0:	6020      	str	r0, [r4, #0]
 8017ff2:	792e      	ldrb	r6, [r5, #4]
 8017ff4:	7126      	strb	r6, [r4, #4]
 8017ff6:	4620      	mov	r0, r4
 8017ff8:	f007 f88b 	bl	801f112 <crs_strlen>
 8017ffc:	b283      	uxth	r3, r0
 8017ffe:	4622      	mov	r2, r4
 8018000:	2101      	movs	r1, #1
 8018002:	2007      	movs	r0, #7
 8018004:	f007 f8c8 	bl	801f198 <traceIF_itmPrint>
 8018008:	4620      	mov	r0, r4
 801800a:	f007 f882 	bl	801f112 <crs_strlen>
 801800e:	b282      	uxth	r2, r0
 8018010:	4621      	mov	r1, r4
 8018012:	2007      	movs	r0, #7
 8018014:	f007 f8fa 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("- 1st step: enter the configuration parameters using the following commands:");
 8018018:	224f      	movs	r2, #79	; 0x4f
 801801a:	497d      	ldr	r1, [pc, #500]	; (8018210 <CST_ModemHelpCmd+0x380>)
 801801c:	4620      	mov	r0, r4
 801801e:	f00d ff77 	bl	8025f10 <memcpy>
 8018022:	4620      	mov	r0, r4
 8018024:	f007 f875 	bl	801f112 <crs_strlen>
 8018028:	b283      	uxth	r3, r0
 801802a:	4622      	mov	r2, r4
 801802c:	2101      	movs	r1, #1
 801802e:	2007      	movs	r0, #7
 8018030:	f007 f8b2 	bl	801f198 <traceIF_itmPrint>
 8018034:	4620      	mov	r0, r4
 8018036:	f007 f86c 	bl	801f112 <crs_strlen>
 801803a:	b282      	uxth	r2, r0
 801803c:	4621      	mov	r1, r4
 801803e:	2007      	movs	r0, #7
 8018040:	f007 f8e4 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s config band [B1] [B2] [B3] [B4] [B5] [B8] [B12] [B13] [B14] [B17] [B18] ", CST_cmd_modem_label);
 8018044:	4a6b      	ldr	r2, [pc, #428]	; (80181f4 <CST_ModemHelpCmd+0x364>)
 8018046:	4973      	ldr	r1, [pc, #460]	; (8018214 <CST_ModemHelpCmd+0x384>)
 8018048:	4620      	mov	r0, r4
 801804a:	f00d fe11 	bl	8025c70 <sprintf>
 801804e:	4620      	mov	r0, r4
 8018050:	f007 f85f 	bl	801f112 <crs_strlen>
 8018054:	b283      	uxth	r3, r0
 8018056:	4622      	mov	r2, r4
 8018058:	2101      	movs	r1, #1
 801805a:	2007      	movs	r0, #7
 801805c:	f007 f89c 	bl	801f198 <traceIF_itmPrint>
 8018060:	4620      	mov	r0, r4
 8018062:	f007 f856 	bl	801f112 <crs_strlen>
 8018066:	b282      	uxth	r2, r0
 8018068:	4621      	mov	r1, r4
 801806a:	2007      	movs	r0, #7
 801806c:	f007 f8ce 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("               [B19] [B20] [B26] [B28] [B39] [B66]  (gets/sets the bands to use(12 bands max))");
 8018070:	2261      	movs	r2, #97	; 0x61
 8018072:	4969      	ldr	r1, [pc, #420]	; (8018218 <CST_ModemHelpCmd+0x388>)
 8018074:	4620      	mov	r0, r4
 8018076:	f00d ff4b 	bl	8025f10 <memcpy>
 801807a:	4620      	mov	r0, r4
 801807c:	f007 f849 	bl	801f112 <crs_strlen>
 8018080:	b283      	uxth	r3, r0
 8018082:	4622      	mov	r2, r4
 8018084:	2101      	movs	r1, #1
 8018086:	2007      	movs	r0, #7
 8018088:	f007 f886 	bl	801f198 <traceIF_itmPrint>
 801808c:	4620      	mov	r0, r4
 801808e:	f007 f840 	bl	801f112 <crs_strlen>
 8018092:	b282      	uxth	r2, r0
 8018094:	4621      	mov	r1, r4
 8018096:	2007      	movs	r0, #7
 8018098:	f007 f8b8 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 801809c:	6828      	ldr	r0, [r5, #0]
 801809e:	6020      	str	r0, [r4, #0]
 80180a0:	7126      	strb	r6, [r4, #4]
 80180a2:	4620      	mov	r0, r4
 80180a4:	f007 f835 	bl	801f112 <crs_strlen>
 80180a8:	b283      	uxth	r3, r0
 80180aa:	4622      	mov	r2, r4
 80180ac:	2101      	movs	r1, #1
 80180ae:	2007      	movs	r0, #7
 80180b0:	f007 f872 	bl	801f198 <traceIF_itmPrint>
 80180b4:	4620      	mov	r0, r4
 80180b6:	f007 f82c 	bl	801f112 <crs_strlen>
 80180ba:	b282      	uxth	r2, r0
 80180bc:	4621      	mov	r1, r4
 80180be:	2007      	movs	r0, #7
 80180c0:	f007 f8a4 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("- 2nd step: send the new configuration to the modem");
 80180c4:	4d55      	ldr	r5, [pc, #340]	; (801821c <CST_ModemHelpCmd+0x38c>)
 80180c6:	f105 0630 	add.w	r6, r5, #48	; 0x30
 80180ca:	46ac      	mov	ip, r5
 80180cc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80180d0:	6020      	str	r0, [r4, #0]
 80180d2:	6061      	str	r1, [r4, #4]
 80180d4:	60a2      	str	r2, [r4, #8]
 80180d6:	60e3      	str	r3, [r4, #12]
 80180d8:	4665      	mov	r5, ip
 80180da:	3410      	adds	r4, #16
 80180dc:	45b4      	cmp	ip, r6
 80180de:	d1f4      	bne.n	80180ca <CST_ModemHelpCmd+0x23a>
 80180e0:	f8dc 0000 	ldr.w	r0, [ip]
 80180e4:	6020      	str	r0, [r4, #0]
 80180e6:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80180ea:	80a3      	strh	r3, [r4, #4]
 80180ec:	4c43      	ldr	r4, [pc, #268]	; (80181fc <CST_ModemHelpCmd+0x36c>)
 80180ee:	4620      	mov	r0, r4
 80180f0:	f007 f80f 	bl	801f112 <crs_strlen>
 80180f4:	b283      	uxth	r3, r0
 80180f6:	4622      	mov	r2, r4
 80180f8:	2101      	movs	r1, #1
 80180fa:	2007      	movs	r0, #7
 80180fc:	f007 f84c 	bl	801f198 <traceIF_itmPrint>
 8018100:	4620      	mov	r0, r4
 8018102:	f007 f806 	bl	801f112 <crs_strlen>
 8018106:	b282      	uxth	r2, r0
 8018108:	4621      	mov	r1, r4
 801810a:	2007      	movs	r0, #7
 801810c:	f007 f87e 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s config send", (CRC_CHAR_t *)CST_cmd_modem_label)
 8018110:	4f38      	ldr	r7, [pc, #224]	; (80181f4 <CST_ModemHelpCmd+0x364>)
 8018112:	463a      	mov	r2, r7
 8018114:	4942      	ldr	r1, [pc, #264]	; (8018220 <CST_ModemHelpCmd+0x390>)
 8018116:	4620      	mov	r0, r4
 8018118:	f00d fdaa 	bl	8025c70 <sprintf>
 801811c:	4620      	mov	r0, r4
 801811e:	f006 fff8 	bl	801f112 <crs_strlen>
 8018122:	b283      	uxth	r3, r0
 8018124:	4622      	mov	r2, r4
 8018126:	2101      	movs	r1, #1
 8018128:	2007      	movs	r0, #7
 801812a:	f007 f835 	bl	801f198 <traceIF_itmPrint>
 801812e:	4620      	mov	r0, r4
 8018130:	f006 ffef 	bl	801f112 <crs_strlen>
 8018134:	b282      	uxth	r2, r0
 8018136:	4621      	mov	r1, r4
 8018138:	2007      	movs	r0, #7
 801813a:	f007 f867 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 801813e:	4e33      	ldr	r6, [pc, #204]	; (801820c <CST_ModemHelpCmd+0x37c>)
 8018140:	6830      	ldr	r0, [r6, #0]
 8018142:	6020      	str	r0, [r4, #0]
 8018144:	f896 8004 	ldrb.w	r8, [r6, #4]
 8018148:	f884 8004 	strb.w	r8, [r4, #4]
 801814c:	4620      	mov	r0, r4
 801814e:	f006 ffe0 	bl	801f112 <crs_strlen>
 8018152:	b283      	uxth	r3, r0
 8018154:	4622      	mov	r2, r4
 8018156:	2101      	movs	r1, #1
 8018158:	2007      	movs	r0, #7
 801815a:	f007 f81d 	bl	801f198 <traceIF_itmPrint>
 801815e:	4620      	mov	r0, r4
 8018160:	f006 ffd7 	bl	801f112 <crs_strlen>
 8018164:	b282      	uxth	r2, r0
 8018166:	4621      	mov	r1, r4
 8018168:	2007      	movs	r0, #7
 801816a:	f007 f84f 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("Other commands:");
 801816e:	4d2d      	ldr	r5, [pc, #180]	; (8018224 <CST_ModemHelpCmd+0x394>)
 8018170:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018172:	6020      	str	r0, [r4, #0]
 8018174:	6061      	str	r1, [r4, #4]
 8018176:	60a2      	str	r2, [r4, #8]
 8018178:	60e3      	str	r3, [r4, #12]
 801817a:	882b      	ldrh	r3, [r5, #0]
 801817c:	8223      	strh	r3, [r4, #16]
 801817e:	4620      	mov	r0, r4
 8018180:	f006 ffc7 	bl	801f112 <crs_strlen>
 8018184:	b283      	uxth	r3, r0
 8018186:	4622      	mov	r2, r4
 8018188:	2101      	movs	r1, #1
 801818a:	2007      	movs	r0, #7
 801818c:	f007 f804 	bl	801f198 <traceIF_itmPrint>
 8018190:	4620      	mov	r0, r4
 8018192:	f006 ffbe 	bl	801f112 <crs_strlen>
 8018196:	b282      	uxth	r2, r0
 8018198:	4621      	mov	r1, r4
 801819a:	2007      	movs	r0, #7
 801819c:	f007 f836 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s config get (get current config from modem)", (CRC_CHAR_t *)CST_cmd_modem_label)
 80181a0:	463a      	mov	r2, r7
 80181a2:	4921      	ldr	r1, [pc, #132]	; (8018228 <CST_ModemHelpCmd+0x398>)
 80181a4:	4620      	mov	r0, r4
 80181a6:	f00d fd63 	bl	8025c70 <sprintf>
 80181aa:	4620      	mov	r0, r4
 80181ac:	f006 ffb1 	bl	801f112 <crs_strlen>
 80181b0:	b283      	uxth	r3, r0
 80181b2:	4622      	mov	r2, r4
 80181b4:	2101      	movs	r1, #1
 80181b6:	2007      	movs	r0, #7
 80181b8:	f006 ffee 	bl	801f198 <traceIF_itmPrint>
 80181bc:	4620      	mov	r0, r4
 80181be:	f006 ffa8 	bl	801f112 <crs_strlen>
 80181c2:	b282      	uxth	r2, r0
 80181c4:	4621      	mov	r1, r4
 80181c6:	2007      	movs	r0, #7
 80181c8:	f007 f820 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("    (Note: the result of this command displays trace of modem response)")
 80181cc:	224a      	movs	r2, #74	; 0x4a
 80181ce:	4917      	ldr	r1, [pc, #92]	; (801822c <CST_ModemHelpCmd+0x39c>)
 80181d0:	4620      	mov	r0, r4
 80181d2:	f00d fe9d 	bl	8025f10 <memcpy>
 80181d6:	4620      	mov	r0, r4
 80181d8:	f006 ff9b 	bl	801f112 <crs_strlen>
 80181dc:	b283      	uxth	r3, r0
 80181de:	4622      	mov	r2, r4
 80181e0:	2101      	movs	r1, #1
 80181e2:	2007      	movs	r0, #7
 80181e4:	f006 ffd8 	bl	801f198 <traceIF_itmPrint>
 80181e8:	4620      	mov	r0, r4
 80181ea:	f006 ff92 	bl	801f112 <crs_strlen>
 80181ee:	b282      	uxth	r2, r0
 80181f0:	e01e      	b.n	8018230 <CST_ModemHelpCmd+0x3a0>
 80181f2:	bf00      	nop
 80181f4:	08032360 	.word	0x08032360
 80181f8:	08032368 	.word	0x08032368
 80181fc:	20004ddc 	.word	0x20004ddc
 8018200:	08032394 	.word	0x08032394
 8018204:	080323bc 	.word	0x080323bc
 8018208:	0803240c 	.word	0x0803240c
 801820c:	08032d64 	.word	0x08032d64
 8018210:	08032448 	.word	0x08032448
 8018214:	08032498 	.word	0x08032498
 8018218:	080324e8 	.word	0x080324e8
 801821c:	0803254c 	.word	0x0803254c
 8018220:	08032584 	.word	0x08032584
 8018224:	08032598 	.word	0x08032598
 8018228:	080325ac 	.word	0x080325ac
 801822c:	080325dc 	.word	0x080325dc
 8018230:	4621      	mov	r1, r4
 8018232:	2007      	movs	r0, #7
 8018234:	f006 ffea 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s config (display current config to be sent to modem)", CST_cmd_modem_label)
 8018238:	463a      	mov	r2, r7
 801823a:	49b0      	ldr	r1, [pc, #704]	; (80184fc <CST_ModemHelpCmd+0x66c>)
 801823c:	4620      	mov	r0, r4
 801823e:	f00d fd17 	bl	8025c70 <sprintf>
 8018242:	4620      	mov	r0, r4
 8018244:	f006 ff65 	bl	801f112 <crs_strlen>
 8018248:	b283      	uxth	r3, r0
 801824a:	4622      	mov	r2, r4
 801824c:	2101      	movs	r1, #1
 801824e:	2007      	movs	r0, #7
 8018250:	f006 ffa2 	bl	801f198 <traceIF_itmPrint>
 8018254:	4620      	mov	r0, r4
 8018256:	f006 ff5c 	bl	801f112 <crs_strlen>
 801825a:	b282      	uxth	r2, r0
 801825c:	4621      	mov	r1, r4
 801825e:	2007      	movs	r0, #7
 8018260:	f006 ffd4 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 8018264:	6830      	ldr	r0, [r6, #0]
 8018266:	6020      	str	r0, [r4, #0]
 8018268:	f884 8004 	strb.w	r8, [r4, #4]
 801826c:	4620      	mov	r0, r4
 801826e:	f006 ff50 	bl	801f112 <crs_strlen>
 8018272:	b283      	uxth	r3, r0
 8018274:	4622      	mov	r2, r4
 8018276:	2101      	movs	r1, #1
 8018278:	2007      	movs	r0, #7
 801827a:	f006 ff8d 	bl	801f198 <traceIF_itmPrint>
 801827e:	4620      	mov	r0, r4
 8018280:	f006 ff47 	bl	801f112 <crs_strlen>
 8018284:	b282      	uxth	r2, r0
 8018286:	4621      	mov	r1, r4
 8018288:	2007      	movs	r0, #7
 801828a:	f006 ffbf 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("--------------------------------------")
 801828e:	4d9c      	ldr	r5, [pc, #624]	; (8018500 <CST_ModemHelpCmd+0x670>)
 8018290:	f105 0620 	add.w	r6, r5, #32
 8018294:	46ac      	mov	ip, r5
 8018296:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801829a:	6020      	str	r0, [r4, #0]
 801829c:	6061      	str	r1, [r4, #4]
 801829e:	60a2      	str	r2, [r4, #8]
 80182a0:	60e3      	str	r3, [r4, #12]
 80182a2:	4665      	mov	r5, ip
 80182a4:	3410      	adds	r4, #16
 80182a6:	45b4      	cmp	ip, r6
 80182a8:	d1f4      	bne.n	8018294 <CST_ModemHelpCmd+0x404>
 80182aa:	cd03      	ldmia	r5!, {r0, r1}
 80182ac:	6020      	str	r0, [r4, #0]
 80182ae:	6061      	str	r1, [r4, #4]
 80182b0:	782b      	ldrb	r3, [r5, #0]
 80182b2:	7223      	strb	r3, [r4, #8]
 80182b4:	4c93      	ldr	r4, [pc, #588]	; (8018504 <CST_ModemHelpCmd+0x674>)
 80182b6:	4620      	mov	r0, r4
 80182b8:	f006 ff2b 	bl	801f112 <crs_strlen>
 80182bc:	b283      	uxth	r3, r0
 80182be:	4622      	mov	r2, r4
 80182c0:	2101      	movs	r1, #1
 80182c2:	2007      	movs	r0, #7
 80182c4:	f006 ff68 	bl	801f198 <traceIF_itmPrint>
 80182c8:	4620      	mov	r0, r4
 80182ca:	f006 ff22 	bl	801f112 <crs_strlen>
 80182ce:	b282      	uxth	r2, r0
 80182d0:	4621      	mov	r1, r4
 80182d2:	2007      	movs	r0, #7
 80182d4:	f006 ff9a 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("2 - Modem low power configuration     ")
 80182d8:	4d8b      	ldr	r5, [pc, #556]	; (8018508 <CST_ModemHelpCmd+0x678>)
 80182da:	f105 0620 	add.w	r6, r5, #32
 80182de:	46ac      	mov	ip, r5
 80182e0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80182e4:	6020      	str	r0, [r4, #0]
 80182e6:	6061      	str	r1, [r4, #4]
 80182e8:	60a2      	str	r2, [r4, #8]
 80182ea:	60e3      	str	r3, [r4, #12]
 80182ec:	4665      	mov	r5, ip
 80182ee:	3410      	adds	r4, #16
 80182f0:	45b4      	cmp	ip, r6
 80182f2:	d1f4      	bne.n	80182de <CST_ModemHelpCmd+0x44e>
 80182f4:	cd03      	ldmia	r5!, {r0, r1}
 80182f6:	6020      	str	r0, [r4, #0]
 80182f8:	6061      	str	r1, [r4, #4]
 80182fa:	782b      	ldrb	r3, [r5, #0]
 80182fc:	7223      	strb	r3, [r4, #8]
 80182fe:	4c81      	ldr	r4, [pc, #516]	; (8018504 <CST_ModemHelpCmd+0x674>)
 8018300:	4620      	mov	r0, r4
 8018302:	f006 ff06 	bl	801f112 <crs_strlen>
 8018306:	b283      	uxth	r3, r0
 8018308:	4622      	mov	r2, r4
 801830a:	2101      	movs	r1, #1
 801830c:	2007      	movs	r0, #7
 801830e:	f006 ff43 	bl	801f198 <traceIF_itmPrint>
 8018312:	4620      	mov	r0, r4
 8018314:	f006 fefd 	bl	801f112 <crs_strlen>
 8018318:	b282      	uxth	r2, r0
 801831a:	4621      	mov	r1, r4
 801831c:	2007      	movs	r0, #7
 801831e:	f006 ff75 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("--------------------------------------")
 8018322:	4d77      	ldr	r5, [pc, #476]	; (8018500 <CST_ModemHelpCmd+0x670>)
 8018324:	f105 0620 	add.w	r6, r5, #32
 8018328:	46ac      	mov	ip, r5
 801832a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801832e:	6020      	str	r0, [r4, #0]
 8018330:	6061      	str	r1, [r4, #4]
 8018332:	60a2      	str	r2, [r4, #8]
 8018334:	60e3      	str	r3, [r4, #12]
 8018336:	4665      	mov	r5, ip
 8018338:	3410      	adds	r4, #16
 801833a:	45b4      	cmp	ip, r6
 801833c:	d1f4      	bne.n	8018328 <CST_ModemHelpCmd+0x498>
 801833e:	cd03      	ldmia	r5!, {r0, r1}
 8018340:	6020      	str	r0, [r4, #0]
 8018342:	6061      	str	r1, [r4, #4]
 8018344:	782b      	ldrb	r3, [r5, #0]
 8018346:	7223      	strb	r3, [r4, #8]
 8018348:	4c6e      	ldr	r4, [pc, #440]	; (8018504 <CST_ModemHelpCmd+0x674>)
 801834a:	4620      	mov	r0, r4
 801834c:	f006 fee1 	bl	801f112 <crs_strlen>
 8018350:	b283      	uxth	r3, r0
 8018352:	4622      	mov	r2, r4
 8018354:	2101      	movs	r1, #1
 8018356:	2007      	movs	r0, #7
 8018358:	f006 ff1e 	bl	801f198 <traceIF_itmPrint>
 801835c:	4620      	mov	r0, r4
 801835e:	f006 fed8 	bl	801f112 <crs_strlen>
 8018362:	b282      	uxth	r2, r0
 8018364:	4621      	mov	r1, r4
 8018366:	2007      	movs	r0, #7
 8018368:	f006 ff50 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s config lowpower  (configure modem with lowpower capabilities)", (CRC_CHAR_t *)CST_cmd_modem_label)
 801836c:	4a67      	ldr	r2, [pc, #412]	; (801850c <CST_ModemHelpCmd+0x67c>)
 801836e:	4968      	ldr	r1, [pc, #416]	; (8018510 <CST_ModemHelpCmd+0x680>)
 8018370:	4620      	mov	r0, r4
 8018372:	f00d fc7d 	bl	8025c70 <sprintf>
 8018376:	4620      	mov	r0, r4
 8018378:	f006 fecb 	bl	801f112 <crs_strlen>
 801837c:	b283      	uxth	r3, r0
 801837e:	4622      	mov	r2, r4
 8018380:	2101      	movs	r1, #1
 8018382:	2007      	movs	r0, #7
 8018384:	f006 ff08 	bl	801f198 <traceIF_itmPrint>
 8018388:	4620      	mov	r0, r4
 801838a:	f006 fec2 	bl	801f112 <crs_strlen>
 801838e:	b282      	uxth	r2, r0
 8018390:	4621      	mov	r1, r4
 8018392:	2007      	movs	r0, #7
 8018394:	f006 ff3a 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 8018398:	4b5e      	ldr	r3, [pc, #376]	; (8018514 <CST_ModemHelpCmd+0x684>)
 801839a:	6818      	ldr	r0, [r3, #0]
 801839c:	6020      	str	r0, [r4, #0]
 801839e:	791b      	ldrb	r3, [r3, #4]
 80183a0:	7123      	strb	r3, [r4, #4]
 80183a2:	4620      	mov	r0, r4
 80183a4:	f006 feb5 	bl	801f112 <crs_strlen>
 80183a8:	b283      	uxth	r3, r0
 80183aa:	4622      	mov	r2, r4
 80183ac:	2101      	movs	r1, #1
 80183ae:	2007      	movs	r0, #7
 80183b0:	f006 fef2 	bl	801f198 <traceIF_itmPrint>
 80183b4:	4620      	mov	r0, r4
 80183b6:	f006 feac 	bl	801f112 <crs_strlen>
 80183ba:	b282      	uxth	r2, r0
 80183bc:	4621      	mov	r1, r4
 80183be:	2007      	movs	r0, #7
 80183c0:	f006 ff24 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("------")
 80183c4:	4d54      	ldr	r5, [pc, #336]	; (8018518 <CST_ModemHelpCmd+0x688>)
 80183c6:	462b      	mov	r3, r5
 80183c8:	cb03      	ldmia	r3!, {r0, r1}
 80183ca:	6020      	str	r0, [r4, #0]
 80183cc:	6061      	str	r1, [r4, #4]
 80183ce:	781e      	ldrb	r6, [r3, #0]
 80183d0:	7226      	strb	r6, [r4, #8]
 80183d2:	4620      	mov	r0, r4
 80183d4:	f006 fe9d 	bl	801f112 <crs_strlen>
 80183d8:	b283      	uxth	r3, r0
 80183da:	4622      	mov	r2, r4
 80183dc:	2101      	movs	r1, #1
 80183de:	2007      	movs	r0, #7
 80183e0:	f006 feda 	bl	801f198 <traceIF_itmPrint>
 80183e4:	4620      	mov	r0, r4
 80183e6:	f006 fe94 	bl	801f112 <crs_strlen>
 80183ea:	b282      	uxth	r2, r0
 80183ec:	4621      	mov	r1, r4
 80183ee:	2007      	movs	r0, #7
 80183f0:	f006 ff0c 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("Notes:");
 80183f4:	4b49      	ldr	r3, [pc, #292]	; (801851c <CST_ModemHelpCmd+0x68c>)
 80183f6:	cb03      	ldmia	r3!, {r0, r1}
 80183f8:	6020      	str	r0, [r4, #0]
 80183fa:	6061      	str	r1, [r4, #4]
 80183fc:	781b      	ldrb	r3, [r3, #0]
 80183fe:	7223      	strb	r3, [r4, #8]
 8018400:	4620      	mov	r0, r4
 8018402:	f006 fe86 	bl	801f112 <crs_strlen>
 8018406:	b283      	uxth	r3, r0
 8018408:	4622      	mov	r2, r4
 801840a:	2101      	movs	r1, #1
 801840c:	2007      	movs	r0, #7
 801840e:	f006 fec3 	bl	801f198 <traceIF_itmPrint>
 8018412:	4620      	mov	r0, r4
 8018414:	f006 fe7d 	bl	801f112 <crs_strlen>
 8018418:	b282      	uxth	r2, r0
 801841a:	4621      	mov	r1, r4
 801841c:	2007      	movs	r0, #7
 801841e:	f006 fef5 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("------")
 8018422:	462b      	mov	r3, r5
 8018424:	cb03      	ldmia	r3!, {r0, r1}
 8018426:	6020      	str	r0, [r4, #0]
 8018428:	6061      	str	r1, [r4, #4]
 801842a:	7226      	strb	r6, [r4, #8]
 801842c:	4620      	mov	r0, r4
 801842e:	f006 fe70 	bl	801f112 <crs_strlen>
 8018432:	b283      	uxth	r3, r0
 8018434:	4622      	mov	r2, r4
 8018436:	2101      	movs	r1, #1
 8018438:	2007      	movs	r0, #7
 801843a:	f006 fead 	bl	801f198 <traceIF_itmPrint>
 801843e:	4620      	mov	r0, r4
 8018440:	f006 fe67 	bl	801f112 <crs_strlen>
 8018444:	b282      	uxth	r2, r0
 8018446:	4621      	mov	r1, r4
 8018448:	2007      	movs	r0, #7
 801844a:	f006 fedf 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("- To use these commands, it is advised to start firmware in 'Modem power on' mode");
 801844e:	2254      	movs	r2, #84	; 0x54
 8018450:	4933      	ldr	r1, [pc, #204]	; (8018520 <CST_ModemHelpCmd+0x690>)
 8018452:	4620      	mov	r0, r4
 8018454:	f00d fd5c 	bl	8025f10 <memcpy>
 8018458:	4620      	mov	r0, r4
 801845a:	f006 fe5a 	bl	801f112 <crs_strlen>
 801845e:	b283      	uxth	r3, r0
 8018460:	4622      	mov	r2, r4
 8018462:	2101      	movs	r1, #1
 8018464:	2007      	movs	r0, #7
 8018466:	f006 fe97 	bl	801f198 <traceIF_itmPrint>
 801846a:	4620      	mov	r0, r4
 801846c:	f006 fe51 	bl	801f112 <crs_strlen>
 8018470:	b282      	uxth	r2, r0
 8018472:	4621      	mov	r1, r4
 8018474:	2007      	movs	r0, #7
 8018476:	f006 fec9 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("              (option '2' of the boot menu).");
 801847a:	4d2a      	ldr	r5, [pc, #168]	; (8018524 <CST_ModemHelpCmd+0x694>)
 801847c:	f105 0620 	add.w	r6, r5, #32
 8018480:	46ac      	mov	ip, r5
 8018482:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8018486:	6020      	str	r0, [r4, #0]
 8018488:	6061      	str	r1, [r4, #4]
 801848a:	60a2      	str	r2, [r4, #8]
 801848c:	60e3      	str	r3, [r4, #12]
 801848e:	4665      	mov	r5, ip
 8018490:	3410      	adds	r4, #16
 8018492:	45b4      	cmp	ip, r6
 8018494:	d1f4      	bne.n	8018480 <CST_ModemHelpCmd+0x5f0>
 8018496:	4663      	mov	r3, ip
 8018498:	cb07      	ldmia	r3!, {r0, r1, r2}
 801849a:	6020      	str	r0, [r4, #0]
 801849c:	6061      	str	r1, [r4, #4]
 801849e:	60a2      	str	r2, [r4, #8]
 80184a0:	881a      	ldrh	r2, [r3, #0]
 80184a2:	789b      	ldrb	r3, [r3, #2]
 80184a4:	81a2      	strh	r2, [r4, #12]
 80184a6:	73a3      	strb	r3, [r4, #14]
 80184a8:	4c16      	ldr	r4, [pc, #88]	; (8018504 <CST_ModemHelpCmd+0x674>)
 80184aa:	4620      	mov	r0, r4
 80184ac:	f006 fe31 	bl	801f112 <crs_strlen>
 80184b0:	b283      	uxth	r3, r0
 80184b2:	4622      	mov	r2, r4
 80184b4:	2101      	movs	r1, #1
 80184b6:	2007      	movs	r0, #7
 80184b8:	f006 fe6e 	bl	801f198 <traceIF_itmPrint>
 80184bc:	4620      	mov	r0, r4
 80184be:	f006 fe28 	bl	801f112 <crs_strlen>
 80184c2:	b282      	uxth	r2, r0
 80184c4:	4621      	mov	r1, r4
 80184c6:	2007      	movs	r0, #7
 80184c8:	f006 fea0 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("- The new modem configuration is taken into account only after target reboot.");
 80184cc:	2250      	movs	r2, #80	; 0x50
 80184ce:	4916      	ldr	r1, [pc, #88]	; (8018528 <CST_ModemHelpCmd+0x698>)
 80184d0:	4620      	mov	r0, r4
 80184d2:	f00d fd1d 	bl	8025f10 <memcpy>
 80184d6:	4620      	mov	r0, r4
 80184d8:	f006 fe1b 	bl	801f112 <crs_strlen>
 80184dc:	b283      	uxth	r3, r0
 80184de:	4622      	mov	r2, r4
 80184e0:	2101      	movs	r1, #1
 80184e2:	2007      	movs	r0, #7
 80184e4:	f006 fe58 	bl	801f198 <traceIF_itmPrint>
 80184e8:	4620      	mov	r0, r4
 80184ea:	f006 fe12 	bl	801f112 <crs_strlen>
 80184ee:	b282      	uxth	r2, r0
 80184f0:	4621      	mov	r1, r4
 80184f2:	2007      	movs	r0, #7
 80184f4:	f006 fe8a 	bl	801f20c <traceIF_uartPrintForce>
}
 80184f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80184fc:	08032628 	.word	0x08032628
 8018500:	08032368 	.word	0x08032368
 8018504:	20004ddc 	.word	0x20004ddc
 8018508:	08032664 	.word	0x08032664
 801850c:	08032360 	.word	0x08032360
 8018510:	08032690 	.word	0x08032690
 8018514:	08032d64 	.word	0x08032d64
 8018518:	08032388 	.word	0x08032388
 801851c:	080326d4 	.word	0x080326d4
 8018520:	080326e0 	.word	0x080326e0
 8018524:	08032734 	.word	0x08032734
 8018528:	08032764 	.word	0x08032764

0801852c <cst_at_cmd_help>:
  * @brief  displays help of atcmd commands
  * @param  -
  * @retval -
  */
static void cst_at_cmd_help(void)
{
 801852c:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help(CST_cmd_at_label);
 801852e:	4d1a      	ldr	r5, [pc, #104]	; (8018598 <cst_at_cmd_help+0x6c>)
 8018530:	4628      	mov	r0, r5
 8018532:	f009 fe8d 	bl	8022250 <CMD_print_help>

  PRINT_FORCE("%s timeout [<modem response timeout(ms) (default %d)>]", CST_cmd_at_label, CST_AT_TIMEOUT)
 8018536:	4c19      	ldr	r4, [pc, #100]	; (801859c <cst_at_cmd_help+0x70>)
 8018538:	f241 3388 	movw	r3, #5000	; 0x1388
 801853c:	462a      	mov	r2, r5
 801853e:	4918      	ldr	r1, [pc, #96]	; (80185a0 <cst_at_cmd_help+0x74>)
 8018540:	4620      	mov	r0, r4
 8018542:	f00d fb95 	bl	8025c70 <sprintf>
 8018546:	4620      	mov	r0, r4
 8018548:	f006 fde3 	bl	801f112 <crs_strlen>
 801854c:	b283      	uxth	r3, r0
 801854e:	4622      	mov	r2, r4
 8018550:	2101      	movs	r1, #1
 8018552:	2007      	movs	r0, #7
 8018554:	f006 fe20 	bl	801f198 <traceIF_itmPrint>
 8018558:	4620      	mov	r0, r4
 801855a:	f006 fdda 	bl	801f112 <crs_strlen>
 801855e:	b282      	uxth	r2, r0
 8018560:	4621      	mov	r1, r4
 8018562:	2007      	movs	r0, #7
 8018564:	f006 fe52 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s <at command> (send an AT command to modem ex:atcmd AT+CSQ)", CST_cmd_at_label)
 8018568:	462a      	mov	r2, r5
 801856a:	490e      	ldr	r1, [pc, #56]	; (80185a4 <cst_at_cmd_help+0x78>)
 801856c:	4620      	mov	r0, r4
 801856e:	f00d fb7f 	bl	8025c70 <sprintf>
 8018572:	4620      	mov	r0, r4
 8018574:	f006 fdcd 	bl	801f112 <crs_strlen>
 8018578:	b283      	uxth	r3, r0
 801857a:	4622      	mov	r2, r4
 801857c:	2101      	movs	r1, #1
 801857e:	2007      	movs	r0, #7
 8018580:	f006 fe0a 	bl	801f198 <traceIF_itmPrint>
 8018584:	4620      	mov	r0, r4
 8018586:	f006 fdc4 	bl	801f112 <crs_strlen>
 801858a:	b282      	uxth	r2, r0
 801858c:	4621      	mov	r1, r4
 801858e:	2007      	movs	r0, #7
 8018590:	f006 fe3c 	bl	801f20c <traceIF_uartPrintForce>
}
 8018594:	bd38      	pop	{r3, r4, r5, pc}
 8018596:	bf00      	nop
 8018598:	080327b4 	.word	0x080327b4
 801859c:	20004ddc 	.word	0x20004ddc
 80185a0:	080327bc 	.word	0x080327bc
 80185a4:	080327f8 	.word	0x080327f8

080185a8 <CST_HelpCmd>:
{
 80185a8:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help(CST_cmd_label);
 80185aa:	4d92      	ldr	r5, [pc, #584]	; (80187f4 <CST_HelpCmd+0x24c>)
 80185ac:	4628      	mov	r0, r5
 80185ae:	f009 fe4f 	bl	8022250 <CMD_print_help>
  PRINT_FORCE("%s help", (CRC_CHAR_t *)CST_cmd_label)
 80185b2:	4c91      	ldr	r4, [pc, #580]	; (80187f8 <CST_HelpCmd+0x250>)
 80185b4:	462a      	mov	r2, r5
 80185b6:	4991      	ldr	r1, [pc, #580]	; (80187fc <CST_HelpCmd+0x254>)
 80185b8:	4620      	mov	r0, r4
 80185ba:	f00d fb59 	bl	8025c70 <sprintf>
 80185be:	4620      	mov	r0, r4
 80185c0:	f006 fda7 	bl	801f112 <crs_strlen>
 80185c4:	b283      	uxth	r3, r0
 80185c6:	4622      	mov	r2, r4
 80185c8:	2101      	movs	r1, #1
 80185ca:	2007      	movs	r0, #7
 80185cc:	f006 fde4 	bl	801f198 <traceIF_itmPrint>
 80185d0:	4620      	mov	r0, r4
 80185d2:	f006 fd9e 	bl	801f112 <crs_strlen>
 80185d6:	b282      	uxth	r2, r0
 80185d8:	4621      	mov	r1, r4
 80185da:	2007      	movs	r0, #7
 80185dc:	f006 fe16 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s state   (Displays the cellular and SIM state)", CST_cmd_label)
 80185e0:	462a      	mov	r2, r5
 80185e2:	4987      	ldr	r1, [pc, #540]	; (8018800 <CST_HelpCmd+0x258>)
 80185e4:	4620      	mov	r0, r4
 80185e6:	f00d fb43 	bl	8025c70 <sprintf>
 80185ea:	4620      	mov	r0, r4
 80185ec:	f006 fd91 	bl	801f112 <crs_strlen>
 80185f0:	b283      	uxth	r3, r0
 80185f2:	4622      	mov	r2, r4
 80185f4:	2101      	movs	r1, #1
 80185f6:	2007      	movs	r0, #7
 80185f8:	f006 fdce 	bl	801f198 <traceIF_itmPrint>
 80185fc:	4620      	mov	r0, r4
 80185fe:	f006 fd88 	bl	801f112 <crs_strlen>
 8018602:	b282      	uxth	r2, r0
 8018604:	4621      	mov	r1, r4
 8018606:	2007      	movs	r0, #7
 8018608:	f006 fe00 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s config  (Displays the cellular configuration used)", CST_cmd_label)
 801860c:	462a      	mov	r2, r5
 801860e:	497d      	ldr	r1, [pc, #500]	; (8018804 <CST_HelpCmd+0x25c>)
 8018610:	4620      	mov	r0, r4
 8018612:	f00d fb2d 	bl	8025c70 <sprintf>
 8018616:	4620      	mov	r0, r4
 8018618:	f006 fd7b 	bl	801f112 <crs_strlen>
 801861c:	b283      	uxth	r3, r0
 801861e:	4622      	mov	r2, r4
 8018620:	2101      	movs	r1, #1
 8018622:	2007      	movs	r0, #7
 8018624:	f006 fdb8 	bl	801f198 <traceIF_itmPrint>
 8018628:	4620      	mov	r0, r4
 801862a:	f006 fd72 	bl	801f112 <crs_strlen>
 801862e:	b282      	uxth	r2, r0
 8018630:	4621      	mov	r1, r4
 8018632:	2007      	movs	r0, #7
 8018634:	f006 fdea 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s info    (Displays modem information)", CST_cmd_label)
 8018638:	462a      	mov	r2, r5
 801863a:	4973      	ldr	r1, [pc, #460]	; (8018808 <CST_HelpCmd+0x260>)
 801863c:	4620      	mov	r0, r4
 801863e:	f00d fb17 	bl	8025c70 <sprintf>
 8018642:	4620      	mov	r0, r4
 8018644:	f006 fd65 	bl	801f112 <crs_strlen>
 8018648:	b283      	uxth	r3, r0
 801864a:	4622      	mov	r2, r4
 801864c:	2101      	movs	r1, #1
 801864e:	2007      	movs	r0, #7
 8018650:	f006 fda2 	bl	801f198 <traceIF_itmPrint>
 8018654:	4620      	mov	r0, r4
 8018656:	f006 fd5c 	bl	801f112 <crs_strlen>
 801865a:	b282      	uxth	r2, r0
 801865c:	4621      	mov	r1, r4
 801865e:	2007      	movs	r0, #7
 8018660:	f006 fdd4 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s targetstate [off|sim|full] (set modem state)", CST_cmd_label)
 8018664:	462a      	mov	r2, r5
 8018666:	4969      	ldr	r1, [pc, #420]	; (801880c <CST_HelpCmd+0x264>)
 8018668:	4620      	mov	r0, r4
 801866a:	f00d fb01 	bl	8025c70 <sprintf>
 801866e:	4620      	mov	r0, r4
 8018670:	f006 fd4f 	bl	801f112 <crs_strlen>
 8018674:	b283      	uxth	r3, r0
 8018676:	4622      	mov	r2, r4
 8018678:	2101      	movs	r1, #1
 801867a:	2007      	movs	r0, #7
 801867c:	f006 fd8c 	bl	801f198 <traceIF_itmPrint>
 8018680:	4620      	mov	r0, r4
 8018682:	f006 fd46 	bl	801f112 <crs_strlen>
 8018686:	b282      	uxth	r2, r0
 8018688:	4621      	mov	r1, r4
 801868a:	2007      	movs	r0, #7
 801868c:	f006 fdbe 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s polling [on|off]  (enable/disable periodical modem polling)", CST_cmd_label)
 8018690:	462a      	mov	r2, r5
 8018692:	495f      	ldr	r1, [pc, #380]	; (8018810 <CST_HelpCmd+0x268>)
 8018694:	4620      	mov	r0, r4
 8018696:	f00d faeb 	bl	8025c70 <sprintf>
 801869a:	4620      	mov	r0, r4
 801869c:	f006 fd39 	bl	801f112 <crs_strlen>
 80186a0:	b283      	uxth	r3, r0
 80186a2:	4622      	mov	r2, r4
 80186a4:	2101      	movs	r1, #1
 80186a6:	2007      	movs	r0, #7
 80186a8:	f006 fd76 	bl	801f198 <traceIF_itmPrint>
 80186ac:	4620      	mov	r0, r4
 80186ae:	f006 fd30 	bl	801f112 <crs_strlen>
 80186b2:	b282      	uxth	r2, r0
 80186b4:	4621      	mov	r1, r4
 80186b6:	2007      	movs	r0, #7
 80186b8:	f006 fda8 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s cmd  (switch to command mode)", CST_cmd_label)
 80186bc:	462a      	mov	r2, r5
 80186be:	4955      	ldr	r1, [pc, #340]	; (8018814 <CST_HelpCmd+0x26c>)
 80186c0:	4620      	mov	r0, r4
 80186c2:	f00d fad5 	bl	8025c70 <sprintf>
 80186c6:	4620      	mov	r0, r4
 80186c8:	f006 fd23 	bl	801f112 <crs_strlen>
 80186cc:	b283      	uxth	r3, r0
 80186ce:	4622      	mov	r2, r4
 80186d0:	2101      	movs	r1, #1
 80186d2:	2007      	movs	r0, #7
 80186d4:	f006 fd60 	bl	801f198 <traceIF_itmPrint>
 80186d8:	4620      	mov	r0, r4
 80186da:	f006 fd1a 	bl	801f112 <crs_strlen>
 80186de:	b282      	uxth	r2, r0
 80186e0:	4621      	mov	r1, r4
 80186e2:	2007      	movs	r0, #7
 80186e4:	f006 fd92 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s data  (switch to data mode)", CST_cmd_label)
 80186e8:	462a      	mov	r2, r5
 80186ea:	494b      	ldr	r1, [pc, #300]	; (8018818 <CST_HelpCmd+0x270>)
 80186ec:	4620      	mov	r0, r4
 80186ee:	f00d fabf 	bl	8025c70 <sprintf>
 80186f2:	4620      	mov	r0, r4
 80186f4:	f006 fd0d 	bl	801f112 <crs_strlen>
 80186f8:	b283      	uxth	r3, r0
 80186fa:	4622      	mov	r2, r4
 80186fc:	2101      	movs	r1, #1
 80186fe:	2007      	movs	r0, #7
 8018700:	f006 fd4a 	bl	801f198 <traceIF_itmPrint>
 8018704:	4620      	mov	r0, r4
 8018706:	f006 fd04 	bl	801f112 <crs_strlen>
 801870a:	b282      	uxth	r2, r0
 801870c:	4621      	mov	r1, r4
 801870e:	2007      	movs	r0, #7
 8018710:	f006 fd7c 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s apnconf [<apn> [<cid> [<username> <password>]]]]  (update apn configuration of active sim slot)",
 8018714:	462a      	mov	r2, r5
 8018716:	4941      	ldr	r1, [pc, #260]	; (801881c <CST_HelpCmd+0x274>)
 8018718:	4620      	mov	r0, r4
 801871a:	f00d faa9 	bl	8025c70 <sprintf>
 801871e:	4620      	mov	r0, r4
 8018720:	f006 fcf7 	bl	801f112 <crs_strlen>
 8018724:	b283      	uxth	r3, r0
 8018726:	4622      	mov	r2, r4
 8018728:	2101      	movs	r1, #1
 801872a:	2007      	movs	r0, #7
 801872c:	f006 fd34 	bl	801f198 <traceIF_itmPrint>
 8018730:	4620      	mov	r0, r4
 8018732:	f006 fcee 	bl	801f112 <crs_strlen>
 8018736:	b282      	uxth	r2, r0
 8018738:	4621      	mov	r1, r4
 801873a:	2007      	movs	r0, #7
 801873c:	f006 fd66 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s power [on|off]  (modem switch ON or OFF)", CST_cmd_label)
 8018740:	462a      	mov	r2, r5
 8018742:	4937      	ldr	r1, [pc, #220]	; (8018820 <CST_HelpCmd+0x278>)
 8018744:	4620      	mov	r0, r4
 8018746:	f00d fa93 	bl	8025c70 <sprintf>
 801874a:	4620      	mov	r0, r4
 801874c:	f006 fce1 	bl	801f112 <crs_strlen>
 8018750:	b283      	uxth	r3, r0
 8018752:	4622      	mov	r2, r4
 8018754:	2101      	movs	r1, #1
 8018756:	2007      	movs	r0, #7
 8018758:	f006 fd1e 	bl	801f198 <traceIF_itmPrint>
 801875c:	4620      	mov	r0, r4
 801875e:	f006 fcd8 	bl	801f112 <crs_strlen>
 8018762:	b282      	uxth	r2, r0
 8018764:	4621      	mov	r1, r4
 8018766:	2007      	movs	r0, #7
 8018768:	f006 fd50 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s operator  (operator selection)", CST_cmd_label)
 801876c:	462a      	mov	r2, r5
 801876e:	492d      	ldr	r1, [pc, #180]	; (8018824 <CST_HelpCmd+0x27c>)
 8018770:	4620      	mov	r0, r4
 8018772:	f00d fa7d 	bl	8025c70 <sprintf>
 8018776:	4620      	mov	r0, r4
 8018778:	f006 fccb 	bl	801f112 <crs_strlen>
 801877c:	b283      	uxth	r3, r0
 801877e:	4622      	mov	r2, r4
 8018780:	2101      	movs	r1, #1
 8018782:	2007      	movs	r0, #7
 8018784:	f006 fd08 	bl	801f198 <traceIF_itmPrint>
 8018788:	4620      	mov	r0, r4
 801878a:	f006 fcc2 	bl	801f112 <crs_strlen>
 801878e:	b282      	uxth	r2, r0
 8018790:	4621      	mov	r1, r4
 8018792:	2007      	movs	r0, #7
 8018794:	f006 fd3a 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s techno off", CST_cmd_label)
 8018798:	462a      	mov	r2, r5
 801879a:	4923      	ldr	r1, [pc, #140]	; (8018828 <CST_HelpCmd+0x280>)
 801879c:	4620      	mov	r0, r4
 801879e:	f00d fa67 	bl	8025c70 <sprintf>
 80187a2:	4620      	mov	r0, r4
 80187a4:	f006 fcb5 	bl	801f112 <crs_strlen>
 80187a8:	b283      	uxth	r3, r0
 80187aa:	4622      	mov	r2, r4
 80187ac:	2101      	movs	r1, #1
 80187ae:	2007      	movs	r0, #7
 80187b0:	f006 fcf2 	bl	801f198 <traceIF_itmPrint>
 80187b4:	4620      	mov	r0, r4
 80187b6:	f006 fcac 	bl	801f112 <crs_strlen>
 80187ba:	b282      	uxth	r2, r0
 80187bc:	4621      	mov	r1, r4
 80187be:	2007      	movs	r0, #7
 80187c0:	f006 fd24 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s techno on [0 (GSM)|1 (GSM_COMPACT)|2 (UTRAN)|3(GSM EDGE)|4 (UTRAN HSDPA)|5 (UTRAN HSUPA)|\
 80187c4:	462a      	mov	r2, r5
 80187c6:	4919      	ldr	r1, [pc, #100]	; (801882c <CST_HelpCmd+0x284>)
 80187c8:	4620      	mov	r0, r4
 80187ca:	f00d fa51 	bl	8025c70 <sprintf>
 80187ce:	4620      	mov	r0, r4
 80187d0:	f006 fc9f 	bl	801f112 <crs_strlen>
 80187d4:	b283      	uxth	r3, r0
 80187d6:	4622      	mov	r2, r4
 80187d8:	2101      	movs	r1, #1
 80187da:	2007      	movs	r0, #7
 80187dc:	f006 fcdc 	bl	801f198 <traceIF_itmPrint>
 80187e0:	4620      	mov	r0, r4
 80187e2:	f006 fc96 	bl	801f112 <crs_strlen>
 80187e6:	b282      	uxth	r2, r0
 80187e8:	4621      	mov	r1, r4
 80187ea:	2007      	movs	r0, #7
 80187ec:	f006 fd0e 	bl	801f20c <traceIF_uartPrintForce>
}
 80187f0:	bd38      	pop	{r3, r4, r5, pc}
 80187f2:	bf00      	nop
 80187f4:	08032838 	.word	0x08032838
 80187f8:	20004ddc 	.word	0x20004ddc
 80187fc:	0803283c 	.word	0x0803283c
 8018800:	08032848 	.word	0x08032848
 8018804:	0803287c 	.word	0x0803287c
 8018808:	080328b4 	.word	0x080328b4
 801880c:	080328e0 	.word	0x080328e0
 8018810:	08032914 	.word	0x08032914
 8018814:	08032958 	.word	0x08032958
 8018818:	0803297c 	.word	0x0803297c
 801881c:	080329a0 	.word	0x080329a0
 8018820:	08032a08 	.word	0x08032a08
 8018824:	08032a38 	.word	0x08032a38
 8018828:	08032a5c 	.word	0x08032a5c
 801882c:	08032a6c 	.word	0x08032a6c

08018830 <CST_CMD_get_band_altair>:
{
 8018830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018832:	4607      	mov	r7, r0
  nb_band = argc - 2U;
 8018834:	1e8e      	subs	r6, r1, #2
  CST_CMD_band_count = 0U;
 8018836:	2400      	movs	r4, #0
 8018838:	4b15      	ldr	r3, [pc, #84]	; (8018890 <CST_CMD_get_band_altair+0x60>)
 801883a:	701c      	strb	r4, [r3, #0]
  (void)memset(CST_CMD_band_tab, 0, sizeof(CST_CMD_band_tab));
 801883c:	4b15      	ldr	r3, [pc, #84]	; (8018894 <CST_CMD_get_band_altair+0x64>)
 801883e:	601c      	str	r4, [r3, #0]
 8018840:	605c      	str	r4, [r3, #4]
 8018842:	609c      	str	r4, [r3, #8]
  leave = false;
 8018844:	4625      	mov	r5, r4
  for (j = 0U ; (j < nb_band) && (leave == false) ; j++)
 8018846:	e00a      	b.n	801885e <CST_CMD_get_band_altair+0x2e>
      band_value = (uint8_t)crs_atoi(&argv_p[current_arg][1]);
 8018848:	3001      	adds	r0, #1
 801884a:	f006 fc1d 	bl	801f088 <crs_atoi>
      if (band_value == 0U)
 801884e:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 8018852:	d10f      	bne.n	8018874 <CST_CMD_get_band_altair+0x44>
        CST_CMD_band_count = 0U;
 8018854:	4b0e      	ldr	r3, [pc, #56]	; (8018890 <CST_CMD_get_band_altair+0x60>)
 8018856:	2200      	movs	r2, #0
 8018858:	701a      	strb	r2, [r3, #0]
        leave = true;
 801885a:	2501      	movs	r5, #1
  for (j = 0U ; (j < nb_band) && (leave == false) ; j++)
 801885c:	3401      	adds	r4, #1
 801885e:	42b4      	cmp	r4, r6
 8018860:	d20f      	bcs.n	8018882 <CST_CMD_get_band_altair+0x52>
 8018862:	b975      	cbnz	r5, 8018882 <CST_CMD_get_band_altair+0x52>
    current_arg = j + 2U;
 8018864:	1ca3      	adds	r3, r4, #2
    if (argv_p[current_arg][0] == (uint8_t)'B')
 8018866:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
 801886a:	7802      	ldrb	r2, [r0, #0]
 801886c:	2a42      	cmp	r2, #66	; 0x42
 801886e:	d0eb      	beq.n	8018848 <CST_CMD_get_band_altair+0x18>
      leave = true;
 8018870:	2501      	movs	r5, #1
 8018872:	e7f3      	b.n	801885c <CST_CMD_get_band_altair+0x2c>
        CST_CMD_band_tab[CST_CMD_band_count] = band_value;
 8018874:	4a06      	ldr	r2, [pc, #24]	; (8018890 <CST_CMD_get_band_altair+0x60>)
 8018876:	7813      	ldrb	r3, [r2, #0]
 8018878:	4906      	ldr	r1, [pc, #24]	; (8018894 <CST_CMD_get_band_altair+0x64>)
 801887a:	54c8      	strb	r0, [r1, r3]
        CST_CMD_band_count++;
 801887c:	3301      	adds	r3, #1
 801887e:	7013      	strb	r3, [r2, #0]
 8018880:	e7ec      	b.n	801885c <CST_CMD_get_band_altair+0x2c>
  if (CST_CMD_band_count == 0U)
 8018882:	4b03      	ldr	r3, [pc, #12]	; (8018890 <CST_CMD_get_band_altair+0x60>)
 8018884:	781b      	ldrb	r3, [r3, #0]
 8018886:	b10b      	cbz	r3, 801888c <CST_CMD_get_band_altair+0x5c>
  ret = 0U;
 8018888:	2000      	movs	r0, #0
}
 801888a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret = 1U;
 801888c:	2001      	movs	r0, #1
  return ret;
 801888e:	e7fc      	b.n	801888a <CST_CMD_get_band_altair+0x5a>
 8018890:	20000046 	.word	0x20000046
 8018894:	20000048 	.word	0x20000048

08018898 <cst_at_command_handle>:
  * @brief  AT command line processing
  * @param  cmd_line_p - command line
  * @retval cmd_status_t - command result
  */
static cmd_status_t cst_at_command_handle(uint8_t *cmd_line_p)
{
 8018898:	b538      	push	{r3, r4, r5, lr}
 801889a:	4604      	mov	r4, r0
  CS_Status_t  cs_status ;
  static CS_direct_cmd_tx_t CST_direct_cmd_tx;

  cmd_status = CMD_OK;

  size =  crs_strlen(cmd_line_p) + 1U;
 801889c:	f006 fc39 	bl	801f112 <crs_strlen>
 80188a0:	1c42      	adds	r2, r0, #1
  if (size <= MAX_DIRECT_CMD_SIZE)
 80188a2:	2a76      	cmp	r2, #118	; 0x76
 80188a4:	d90e      	bls.n	80188c4 <cst_at_command_handle+0x2c>
    (void)memcpy(&CST_direct_cmd_tx.cmd_str[0],
                 (CRC_CHAR_t *)cmd_line_p,
                 size);
  }

  CST_direct_cmd_tx.cmd_size    = (uint16_t)crs_strlen(cmd_line_p);
 80188a6:	4620      	mov	r0, r4
 80188a8:	f006 fc33 	bl	801f112 <crs_strlen>
 80188ac:	4b14      	ldr	r3, [pc, #80]	; (8018900 <cst_at_command_handle+0x68>)
 80188ae:	f8a3 0076 	strh.w	r0, [r3, #118]	; 0x76
  CST_direct_cmd_tx.cmd_timeout = cst_at_timeout;
 80188b2:	4a14      	ldr	r2, [pc, #80]	; (8018904 <cst_at_command_handle+0x6c>)
 80188b4:	6812      	ldr	r2, [r2, #0]
 80188b6:	679a      	str	r2, [r3, #120]	; 0x78

  /* send the AT command to the modem */
  cs_status = osCDS_direct_cmd(&CST_direct_cmd_tx, CST_cellular_direct_cmd_callback);
 80188b8:	4913      	ldr	r1, [pc, #76]	; (8018908 <cst_at_command_handle+0x70>)
 80188ba:	4618      	mov	r0, r3
 80188bc:	f002 f98c 	bl	801abd8 <osCDS_direct_cmd>
  if (cs_status != CELLULAR_OK)
 80188c0:	b928      	cbnz	r0, 80188ce <cst_at_command_handle+0x36>
    /* AT command failed */
    PRINT_FORCE("\n\r%s command FAIL\n\r", cmd_line_p)
    cmd_status = CMD_PROCESS_ERROR;
  }
  return cmd_status;
}
 80188c2:	bd38      	pop	{r3, r4, r5, pc}
    (void)memcpy(&CST_direct_cmd_tx.cmd_str[0],
 80188c4:	4621      	mov	r1, r4
 80188c6:	480e      	ldr	r0, [pc, #56]	; (8018900 <cst_at_command_handle+0x68>)
 80188c8:	f00d fb22 	bl	8025f10 <memcpy>
 80188cc:	e7eb      	b.n	80188a6 <cst_at_command_handle+0xe>
    PRINT_FORCE("\n\r%s command FAIL\n\r", cmd_line_p)
 80188ce:	4d0f      	ldr	r5, [pc, #60]	; (801890c <cst_at_command_handle+0x74>)
 80188d0:	4622      	mov	r2, r4
 80188d2:	490f      	ldr	r1, [pc, #60]	; (8018910 <cst_at_command_handle+0x78>)
 80188d4:	4628      	mov	r0, r5
 80188d6:	f00d f9cb 	bl	8025c70 <sprintf>
 80188da:	4628      	mov	r0, r5
 80188dc:	f006 fc19 	bl	801f112 <crs_strlen>
 80188e0:	b283      	uxth	r3, r0
 80188e2:	462a      	mov	r2, r5
 80188e4:	2101      	movs	r1, #1
 80188e6:	2007      	movs	r0, #7
 80188e8:	f006 fc56 	bl	801f198 <traceIF_itmPrint>
 80188ec:	4628      	mov	r0, r5
 80188ee:	f006 fc10 	bl	801f112 <crs_strlen>
 80188f2:	b282      	uxth	r2, r0
 80188f4:	4629      	mov	r1, r5
 80188f6:	2007      	movs	r0, #7
 80188f8:	f006 fc88 	bl	801f20c <traceIF_uartPrintForce>
    cmd_status = CMD_PROCESS_ERROR;
 80188fc:	2002      	movs	r0, #2
 80188fe:	e7e0      	b.n	80188c2 <cst_at_command_handle+0x2a>
 8018900:	20003934 	.word	0x20003934
 8018904:	20000054 	.word	0x20000054
 8018908:	08017e31 	.word	0x08017e31
 801890c:	20004ddc 	.word	0x20004ddc
 8018910:	08032b2c 	.word	0x08032b2c

08018914 <CST_ModemCmd>:
{
 8018914:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018916:	b08f      	sub	sp, #60	; 0x3c
 8018918:	4605      	mov	r5, r0
  PRINT_FORCE("\n\r")
 801891a:	4c95      	ldr	r4, [pc, #596]	; (8018b70 <CST_ModemCmd+0x25c>)
 801891c:	4b95      	ldr	r3, [pc, #596]	; (8018b74 <CST_ModemCmd+0x260>)
 801891e:	6818      	ldr	r0, [r3, #0]
 8018920:	6020      	str	r0, [r4, #0]
 8018922:	791b      	ldrb	r3, [r3, #4]
 8018924:	7123      	strb	r3, [r4, #4]
 8018926:	4620      	mov	r0, r4
 8018928:	f006 fbf3 	bl	801f112 <crs_strlen>
 801892c:	b283      	uxth	r3, r0
 801892e:	4622      	mov	r2, r4
 8018930:	2101      	movs	r1, #1
 8018932:	2007      	movs	r0, #7
 8018934:	f006 fc30 	bl	801f198 <traceIF_itmPrint>
 8018938:	4620      	mov	r0, r4
 801893a:	f006 fbea 	bl	801f112 <crs_strlen>
 801893e:	b282      	uxth	r2, r0
 8018940:	4621      	mov	r1, r4
 8018942:	2007      	movs	r0, #7
 8018944:	f006 fc62 	bl	801f20c <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8018948:	498b      	ldr	r1, [pc, #556]	; (8018b78 <CST_ModemCmd+0x264>)
 801894a:	4628      	mov	r0, r5
 801894c:	f00d fa1e 	bl	8025d8c <strtok>
 8018950:	4605      	mov	r5, r0
             crs_strlen(cmd_p)) == 0)
 8018952:	f006 fbde 	bl	801f112 <crs_strlen>
 8018956:	4602      	mov	r2, r0
  if (memcmp((CRC_CHAR_t *)cmd_p,
 8018958:	4988      	ldr	r1, [pc, #544]	; (8018b7c <CST_ModemCmd+0x268>)
 801895a:	4628      	mov	r0, r5
 801895c:	f00d f9eb 	bl	8025d36 <memcmp>
 8018960:	b1d0      	cbz	r0, 8018998 <CST_ModemCmd+0x84>
  cmd_status = CMD_OK;
 8018962:	2500      	movs	r5, #0
  PRINT_FORCE("")
 8018964:	4c82      	ldr	r4, [pc, #520]	; (8018b70 <CST_ModemCmd+0x25c>)
 8018966:	4b86      	ldr	r3, [pc, #536]	; (8018b80 <CST_ModemCmd+0x26c>)
 8018968:	881a      	ldrh	r2, [r3, #0]
 801896a:	789b      	ldrb	r3, [r3, #2]
 801896c:	8022      	strh	r2, [r4, #0]
 801896e:	70a3      	strb	r3, [r4, #2]
 8018970:	4620      	mov	r0, r4
 8018972:	f006 fbce 	bl	801f112 <crs_strlen>
 8018976:	b283      	uxth	r3, r0
 8018978:	4622      	mov	r2, r4
 801897a:	2101      	movs	r1, #1
 801897c:	2007      	movs	r0, #7
 801897e:	f006 fc0b 	bl	801f198 <traceIF_itmPrint>
 8018982:	4620      	mov	r0, r4
 8018984:	f006 fbc5 	bl	801f112 <crs_strlen>
 8018988:	b282      	uxth	r2, r0
 801898a:	4621      	mov	r1, r4
 801898c:	2007      	movs	r0, #7
 801898e:	f006 fc3d 	bl	801f20c <traceIF_uartPrintForce>
}
 8018992:	4628      	mov	r0, r5
 8018994:	b00f      	add	sp, #60	; 0x3c
 8018996:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (argc = 0U ; argc < CST_CMS_PARAM_MAX ; argc++)
 8018998:	2400      	movs	r4, #0
 801899a:	2c0c      	cmp	r4, #12
 801899c:	d80b      	bhi.n	80189b6 <CST_ModemCmd+0xa2>
      argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 801899e:	4976      	ldr	r1, [pc, #472]	; (8018b78 <CST_ModemCmd+0x264>)
 80189a0:	2000      	movs	r0, #0
 80189a2:	f00d f9f3 	bl	8025d8c <strtok>
 80189a6:	ab0e      	add	r3, sp, #56	; 0x38
 80189a8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80189ac:	f843 0c34 	str.w	r0, [r3, #-52]
      if (argv_p[argc] == NULL)
 80189b0:	b108      	cbz	r0, 80189b6 <CST_ModemCmd+0xa2>
    for (argc = 0U ; argc < CST_CMS_PARAM_MAX ; argc++)
 80189b2:	3401      	adds	r4, #1
 80189b4:	e7f1      	b.n	801899a <CST_ModemCmd+0x86>
    if (argc == 0U)
 80189b6:	b91c      	cbnz	r4, 80189c0 <CST_ModemCmd+0xac>
      CST_ModemHelpCmd();
 80189b8:	f7ff fa6a 	bl	8017e90 <CST_ModemHelpCmd>
  cmd_status = CMD_OK;
 80189bc:	2500      	movs	r5, #0
 80189be:	e7d1      	b.n	8018964 <CST_ModemCmd+0x50>
    else if (memcmp((const CRC_CHAR_t *)argv_p[0], "help", crs_strlen(argv_p[0])) == 0)
 80189c0:	9e01      	ldr	r6, [sp, #4]
 80189c2:	4630      	mov	r0, r6
 80189c4:	f006 fba5 	bl	801f112 <crs_strlen>
 80189c8:	4602      	mov	r2, r0
 80189ca:	496e      	ldr	r1, [pc, #440]	; (8018b84 <CST_ModemCmd+0x270>)
 80189cc:	4630      	mov	r0, r6
 80189ce:	f00d f9b2 	bl	8025d36 <memcmp>
 80189d2:	b918      	cbnz	r0, 80189dc <CST_ModemCmd+0xc8>
      CST_ModemHelpCmd();
 80189d4:	f7ff fa5c 	bl	8017e90 <CST_ModemHelpCmd>
  cmd_status = CMD_OK;
 80189d8:	2500      	movs	r5, #0
 80189da:	e7c3      	b.n	8018964 <CST_ModemCmd+0x50>
    else if (memcmp((const CRC_CHAR_t *)argv_p[0],
 80189dc:	9e01      	ldr	r6, [sp, #4]
                    crs_strlen(argv_p[0]))
 80189de:	4630      	mov	r0, r6
 80189e0:	f006 fb97 	bl	801f112 <crs_strlen>
 80189e4:	4602      	mov	r2, r0
    else if (memcmp((const CRC_CHAR_t *)argv_p[0],
 80189e6:	4968      	ldr	r1, [pc, #416]	; (8018b88 <CST_ModemCmd+0x274>)
 80189e8:	4630      	mov	r0, r6
 80189ea:	f00d f9a4 	bl	8025d36 <memcmp>
 80189ee:	2800      	cmp	r0, #0
 80189f0:	f040 81ca 	bne.w	8018d88 <CST_ModemCmd+0x474>
      if (argc == 1U)
 80189f4:	2c01      	cmp	r4, #1
 80189f6:	d010      	beq.n	8018a1a <CST_ModemCmd+0x106>
      else if (memcmp((const CRC_CHAR_t *)argv_p[1],
 80189f8:	9e02      	ldr	r6, [sp, #8]
                      crs_strlen(argv_p[1]))
 80189fa:	4630      	mov	r0, r6
 80189fc:	f006 fb89 	bl	801f112 <crs_strlen>
 8018a00:	4602      	mov	r2, r0
      else if (memcmp((const CRC_CHAR_t *)argv_p[1],
 8018a02:	4962      	ldr	r1, [pc, #392]	; (8018b8c <CST_ModemCmd+0x278>)
 8018a04:	4630      	mov	r0, r6
 8018a06:	f00d f996 	bl	8025d36 <memcmp>
 8018a0a:	2800      	cmp	r0, #0
 8018a0c:	d16f      	bne.n	8018aee <CST_ModemCmd+0x1da>
        if (argc >= 3U)
 8018a0e:	2c02      	cmp	r4, #2
 8018a10:	d821      	bhi.n	8018a56 <CST_ModemCmd+0x142>
  cmd_status = CMD_OK;
 8018a12:	2500      	movs	r5, #0
        CST_CMD_display_bitmap_name_altair();
 8018a14:	f7ff fa12 	bl	8017e3c <CST_CMD_display_bitmap_name_altair>
 8018a18:	e7a4      	b.n	8018964 <CST_ModemCmd+0x50>
        PRINT_FORCE("bands : ")
 8018a1a:	4c55      	ldr	r4, [pc, #340]	; (8018b70 <CST_ModemCmd+0x25c>)
 8018a1c:	4b5c      	ldr	r3, [pc, #368]	; (8018b90 <CST_ModemCmd+0x27c>)
 8018a1e:	cb03      	ldmia	r3!, {r0, r1}
 8018a20:	6020      	str	r0, [r4, #0]
 8018a22:	6061      	str	r1, [r4, #4]
 8018a24:	881a      	ldrh	r2, [r3, #0]
 8018a26:	789b      	ldrb	r3, [r3, #2]
 8018a28:	8122      	strh	r2, [r4, #8]
 8018a2a:	72a3      	strb	r3, [r4, #10]
 8018a2c:	4620      	mov	r0, r4
 8018a2e:	f006 fb70 	bl	801f112 <crs_strlen>
 8018a32:	b283      	uxth	r3, r0
 8018a34:	4622      	mov	r2, r4
 8018a36:	2101      	movs	r1, #1
 8018a38:	2007      	movs	r0, #7
 8018a3a:	f006 fbad 	bl	801f198 <traceIF_itmPrint>
 8018a3e:	4620      	mov	r0, r4
 8018a40:	f006 fb67 	bl	801f112 <crs_strlen>
 8018a44:	b282      	uxth	r2, r0
 8018a46:	4621      	mov	r1, r4
 8018a48:	2007      	movs	r0, #7
 8018a4a:	f006 fbdf 	bl	801f20c <traceIF_uartPrintForce>
        CST_CMD_display_bitmap_name_altair();
 8018a4e:	f7ff f9f5 	bl	8017e3c <CST_CMD_display_bitmap_name_altair>
  cmd_status = CMD_OK;
 8018a52:	2500      	movs	r5, #0
 8018a54:	e786      	b.n	8018964 <CST_ModemCmd+0x50>
          ret = CST_CMD_get_band_altair(argv_p,  argc);
 8018a56:	4621      	mov	r1, r4
 8018a58:	a801      	add	r0, sp, #4
 8018a5a:	f7ff fee9 	bl	8018830 <CST_CMD_get_band_altair>
          if (ret != 0U)
 8018a5e:	b908      	cbnz	r0, 8018a64 <CST_ModemCmd+0x150>
  cmd_status = CMD_OK;
 8018a60:	2500      	movs	r5, #0
 8018a62:	e7d7      	b.n	8018a14 <CST_ModemCmd+0x100>
            PRINT_FORCE("%s Bad parameter", CST_cmd_modem_label)
 8018a64:	4c42      	ldr	r4, [pc, #264]	; (8018b70 <CST_ModemCmd+0x25c>)
 8018a66:	4a45      	ldr	r2, [pc, #276]	; (8018b7c <CST_ModemCmd+0x268>)
 8018a68:	494a      	ldr	r1, [pc, #296]	; (8018b94 <CST_ModemCmd+0x280>)
 8018a6a:	4620      	mov	r0, r4
 8018a6c:	f00d f900 	bl	8025c70 <sprintf>
 8018a70:	4620      	mov	r0, r4
 8018a72:	f006 fb4e 	bl	801f112 <crs_strlen>
 8018a76:	b283      	uxth	r3, r0
 8018a78:	4622      	mov	r2, r4
 8018a7a:	2101      	movs	r1, #1
 8018a7c:	2007      	movs	r0, #7
 8018a7e:	f006 fb8b 	bl	801f198 <traceIF_itmPrint>
 8018a82:	4620      	mov	r0, r4
 8018a84:	f006 fb45 	bl	801f112 <crs_strlen>
 8018a88:	b282      	uxth	r2, r0
 8018a8a:	4621      	mov	r1, r4
 8018a8c:	2007      	movs	r0, #7
 8018a8e:	f006 fbbd 	bl	801f20c <traceIF_uartPrintForce>
            PRINT_FORCE("Usage: config m1band [B1] [B2] [B3] [B4] [B5] [B8] [B12] [B13] [B14] [B17]");
 8018a92:	224d      	movs	r2, #77	; 0x4d
 8018a94:	4940      	ldr	r1, [pc, #256]	; (8018b98 <CST_ModemCmd+0x284>)
 8018a96:	4620      	mov	r0, r4
 8018a98:	f00d fa3a 	bl	8025f10 <memcpy>
 8018a9c:	4620      	mov	r0, r4
 8018a9e:	f006 fb38 	bl	801f112 <crs_strlen>
 8018aa2:	b283      	uxth	r3, r0
 8018aa4:	4622      	mov	r2, r4
 8018aa6:	2101      	movs	r1, #1
 8018aa8:	2007      	movs	r0, #7
 8018aaa:	f006 fb75 	bl	801f198 <traceIF_itmPrint>
 8018aae:	4620      	mov	r0, r4
 8018ab0:	f006 fb2f 	bl	801f112 <crs_strlen>
 8018ab4:	b282      	uxth	r2, r0
 8018ab6:	4621      	mov	r1, r4
 8018ab8:	2007      	movs	r0, #7
 8018aba:	f006 fba7 	bl	801f20c <traceIF_uartPrintForce>
            PRINT_FORCE("                     [B18] [B19] [B20] [B26] [B28] [B39] [B66]  (12 bands max)");
 8018abe:	2251      	movs	r2, #81	; 0x51
 8018ac0:	4936      	ldr	r1, [pc, #216]	; (8018b9c <CST_ModemCmd+0x288>)
 8018ac2:	4620      	mov	r0, r4
 8018ac4:	f00d fa24 	bl	8025f10 <memcpy>
 8018ac8:	4620      	mov	r0, r4
 8018aca:	f006 fb22 	bl	801f112 <crs_strlen>
 8018ace:	b283      	uxth	r3, r0
 8018ad0:	4622      	mov	r2, r4
 8018ad2:	2101      	movs	r1, #1
 8018ad4:	2007      	movs	r0, #7
 8018ad6:	f006 fb5f 	bl	801f198 <traceIF_itmPrint>
 8018ada:	4620      	mov	r0, r4
 8018adc:	f006 fb19 	bl	801f112 <crs_strlen>
 8018ae0:	b282      	uxth	r2, r0
 8018ae2:	4621      	mov	r1, r4
 8018ae4:	2007      	movs	r0, #7
 8018ae6:	f006 fb91 	bl	801f20c <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 8018aea:	2501      	movs	r5, #1
 8018aec:	e792      	b.n	8018a14 <CST_ModemCmd+0x100>
      else if (memcmp((const CRC_CHAR_t *)argv_p[1], "send", crs_strlen(argv_p[1])) == 0)
 8018aee:	9c02      	ldr	r4, [sp, #8]
 8018af0:	4620      	mov	r0, r4
 8018af2:	f006 fb0e 	bl	801f112 <crs_strlen>
 8018af6:	4602      	mov	r2, r0
 8018af8:	4929      	ldr	r1, [pc, #164]	; (8018ba0 <CST_ModemCmd+0x28c>)
 8018afa:	4620      	mov	r0, r4
 8018afc:	f00d f91b 	bl	8025d36 <memcmp>
 8018b00:	2800      	cmp	r0, #0
 8018b02:	d15b      	bne.n	8018bbc <CST_ModemCmd+0x2a8>
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETCFG=\"BAND\"");
 8018b04:	4927      	ldr	r1, [pc, #156]	; (8018ba4 <CST_ModemCmd+0x290>)
 8018b06:	4828      	ldr	r0, [pc, #160]	; (8018ba8 <CST_ModemCmd+0x294>)
 8018b08:	f00d f8b2 	bl	8025c70 <sprintf>
        for (i = 0; i < CST_CMD_band_count; i++)
 8018b0c:	2400      	movs	r4, #0
 8018b0e:	e008      	b.n	8018b22 <CST_ModemCmd+0x20e>
          (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "%s,\"%d\"", (CRC_CHAR_t *)CST_CMD_Command, CST_CMD_band_tab[i]);
 8018b10:	4825      	ldr	r0, [pc, #148]	; (8018ba8 <CST_ModemCmd+0x294>)
 8018b12:	4b26      	ldr	r3, [pc, #152]	; (8018bac <CST_ModemCmd+0x298>)
 8018b14:	5d1b      	ldrb	r3, [r3, r4]
 8018b16:	4602      	mov	r2, r0
 8018b18:	4925      	ldr	r1, [pc, #148]	; (8018bb0 <CST_ModemCmd+0x29c>)
 8018b1a:	f00d f8a9 	bl	8025c70 <sprintf>
        for (i = 0; i < CST_CMD_band_count; i++)
 8018b1e:	3401      	adds	r4, #1
 8018b20:	b2e4      	uxtb	r4, r4
 8018b22:	4b24      	ldr	r3, [pc, #144]	; (8018bb4 <CST_ModemCmd+0x2a0>)
 8018b24:	781b      	ldrb	r3, [r3, #0]
 8018b26:	42a3      	cmp	r3, r4
 8018b28:	d8f2      	bhi.n	8018b10 <CST_ModemCmd+0x1fc>
        ret = (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018b2a:	481f      	ldr	r0, [pc, #124]	; (8018ba8 <CST_ModemCmd+0x294>)
 8018b2c:	f7ff feb4 	bl	8018898 <cst_at_command_handle>
        if (ret != 0U)
 8018b30:	4605      	mov	r5, r0
 8018b32:	2800      	cmp	r0, #0
 8018b34:	f43f af16 	beq.w	8018964 <CST_ModemCmd+0x50>
          PRINT_FORCE("command fail\n\r")
 8018b38:	4c0d      	ldr	r4, [pc, #52]	; (8018b70 <CST_ModemCmd+0x25c>)
 8018b3a:	4d1f      	ldr	r5, [pc, #124]	; (8018bb8 <CST_ModemCmd+0x2a4>)
 8018b3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018b3e:	6020      	str	r0, [r4, #0]
 8018b40:	6061      	str	r1, [r4, #4]
 8018b42:	60a2      	str	r2, [r4, #8]
 8018b44:	60e3      	str	r3, [r4, #12]
 8018b46:	782b      	ldrb	r3, [r5, #0]
 8018b48:	7423      	strb	r3, [r4, #16]
 8018b4a:	4620      	mov	r0, r4
 8018b4c:	f006 fae1 	bl	801f112 <crs_strlen>
 8018b50:	b283      	uxth	r3, r0
 8018b52:	4622      	mov	r2, r4
 8018b54:	2101      	movs	r1, #1
 8018b56:	2007      	movs	r0, #7
 8018b58:	f006 fb1e 	bl	801f198 <traceIF_itmPrint>
 8018b5c:	4620      	mov	r0, r4
 8018b5e:	f006 fad8 	bl	801f112 <crs_strlen>
 8018b62:	b282      	uxth	r2, r0
 8018b64:	4621      	mov	r1, r4
 8018b66:	2007      	movs	r0, #7
 8018b68:	f006 fb50 	bl	801f20c <traceIF_uartPrintForce>
          cmd_status = CMD_PROCESS_ERROR;
 8018b6c:	2502      	movs	r5, #2
 8018b6e:	e6f9      	b.n	8018964 <CST_ModemCmd+0x50>
 8018b70:	20004ddc 	.word	0x20004ddc
 8018b74:	08032d64 	.word	0x08032d64
 8018b78:	08032b44 	.word	0x08032b44
 8018b7c:	08032360 	.word	0x08032360
 8018b80:	0802deec 	.word	0x0802deec
 8018b84:	08032b48 	.word	0x08032b48
 8018b88:	08032b50 	.word	0x08032b50
 8018b8c:	08032b64 	.word	0x08032b64
 8018b90:	08032b58 	.word	0x08032b58
 8018b94:	08032b6c 	.word	0x08032b6c
 8018b98:	08032b80 	.word	0x08032b80
 8018b9c:	08032bd0 	.word	0x08032bd0
 8018ba0:	08032c24 	.word	0x08032c24
 8018ba4:	08032c2c 	.word	0x08032c2c
 8018ba8:	200038d0 	.word	0x200038d0
 8018bac:	20000048 	.word	0x20000048
 8018bb0:	08032c40 	.word	0x08032c40
 8018bb4:	20000046 	.word	0x20000046
 8018bb8:	08032c48 	.word	0x08032c48
      else if (memcmp((const CRC_CHAR_t *)argv_p[1], "lowpower", crs_strlen(argv_p[1])) == 0)
 8018bbc:	9c02      	ldr	r4, [sp, #8]
 8018bbe:	4620      	mov	r0, r4
 8018bc0:	f006 faa7 	bl	801f112 <crs_strlen>
 8018bc4:	4602      	mov	r2, r0
 8018bc6:	497d      	ldr	r1, [pc, #500]	; (8018dbc <CST_ModemCmd+0x4a8>)
 8018bc8:	4620      	mov	r0, r4
 8018bca:	f00d f8b4 	bl	8025d36 <memcmp>
 8018bce:	2800      	cmp	r0, #0
 8018bd0:	d174      	bne.n	8018cbc <CST_ModemCmd+0x3a8>
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETACFG=\"pm.hifc.mode,A\"");
 8018bd2:	4d7b      	ldr	r5, [pc, #492]	; (8018dc0 <CST_ModemCmd+0x4ac>)
 8018bd4:	497b      	ldr	r1, [pc, #492]	; (8018dc4 <CST_ModemCmd+0x4b0>)
 8018bd6:	4628      	mov	r0, r5
 8018bd8:	f00d f84a 	bl	8025c70 <sprintf>
        ret = (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018bdc:	4628      	mov	r0, r5
 8018bde:	f7ff fe5b 	bl	8018898 <cst_at_command_handle>
 8018be2:	4604      	mov	r4, r0
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETACFG=\"pm.conf.sleep_mode,enable\"");
 8018be4:	4978      	ldr	r1, [pc, #480]	; (8018dc8 <CST_ModemCmd+0x4b4>)
 8018be6:	4628      	mov	r0, r5
 8018be8:	f00d f842 	bl	8025c70 <sprintf>
        ret |= (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018bec:	4628      	mov	r0, r5
 8018bee:	f7ff fe53 	bl	8018898 <cst_at_command_handle>
 8018bf2:	4304      	orrs	r4, r0
 8018bf4:	b2e4      	uxtb	r4, r4
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETACFG=\"pm.conf.max_allowed_pm_mode,dh0\"");
 8018bf6:	4975      	ldr	r1, [pc, #468]	; (8018dcc <CST_ModemCmd+0x4b8>)
 8018bf8:	4628      	mov	r0, r5
 8018bfa:	f00d f839 	bl	8025c70 <sprintf>
        ret |= (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018bfe:	4628      	mov	r0, r5
 8018c00:	f7ff fe4a 	bl	8018898 <cst_at_command_handle>
 8018c04:	ea40 0504 	orr.w	r5, r0, r4
        if (ret != 0U)
 8018c08:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 8018c0c:	d13a      	bne.n	8018c84 <CST_ModemCmd+0x370>
          PRINT_FORCE("\n\r")
 8018c0e:	4c70      	ldr	r4, [pc, #448]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018c10:	4b70      	ldr	r3, [pc, #448]	; (8018dd4 <CST_ModemCmd+0x4c0>)
 8018c12:	6818      	ldr	r0, [r3, #0]
 8018c14:	6020      	str	r0, [r4, #0]
 8018c16:	791b      	ldrb	r3, [r3, #4]
 8018c18:	7123      	strb	r3, [r4, #4]
 8018c1a:	4620      	mov	r0, r4
 8018c1c:	f006 fa79 	bl	801f112 <crs_strlen>
 8018c20:	b283      	uxth	r3, r0
 8018c22:	4622      	mov	r2, r4
 8018c24:	2101      	movs	r1, #1
 8018c26:	2007      	movs	r0, #7
 8018c28:	f006 fab6 	bl	801f198 <traceIF_itmPrint>
 8018c2c:	4620      	mov	r0, r4
 8018c2e:	f006 fa70 	bl	801f112 <crs_strlen>
 8018c32:	b282      	uxth	r2, r0
 8018c34:	4621      	mov	r1, r4
 8018c36:	2007      	movs	r0, #7
 8018c38:	f006 fae8 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("Low power capabilities enabled\n\r")
 8018c3c:	4f66      	ldr	r7, [pc, #408]	; (8018dd8 <CST_ModemCmd+0x4c4>)
 8018c3e:	f107 0e20 	add.w	lr, r7, #32
 8018c42:	463e      	mov	r6, r7
 8018c44:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8018c46:	6020      	str	r0, [r4, #0]
 8018c48:	6061      	str	r1, [r4, #4]
 8018c4a:	60a2      	str	r2, [r4, #8]
 8018c4c:	60e3      	str	r3, [r4, #12]
 8018c4e:	4637      	mov	r7, r6
 8018c50:	3410      	adds	r4, #16
 8018c52:	4576      	cmp	r6, lr
 8018c54:	d1f5      	bne.n	8018c42 <CST_ModemCmd+0x32e>
 8018c56:	8832      	ldrh	r2, [r6, #0]
 8018c58:	78b3      	ldrb	r3, [r6, #2]
 8018c5a:	8022      	strh	r2, [r4, #0]
 8018c5c:	70a3      	strb	r3, [r4, #2]
 8018c5e:	4c5c      	ldr	r4, [pc, #368]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018c60:	4620      	mov	r0, r4
 8018c62:	f006 fa56 	bl	801f112 <crs_strlen>
 8018c66:	b283      	uxth	r3, r0
 8018c68:	4622      	mov	r2, r4
 8018c6a:	2101      	movs	r1, #1
 8018c6c:	2007      	movs	r0, #7
 8018c6e:	f006 fa93 	bl	801f198 <traceIF_itmPrint>
 8018c72:	4620      	mov	r0, r4
 8018c74:	f006 fa4d 	bl	801f112 <crs_strlen>
 8018c78:	b282      	uxth	r2, r0
 8018c7a:	4621      	mov	r1, r4
 8018c7c:	2007      	movs	r0, #7
 8018c7e:	f006 fac5 	bl	801f20c <traceIF_uartPrintForce>
 8018c82:	e66f      	b.n	8018964 <CST_ModemCmd+0x50>
          PRINT_FORCE("command fail\n\r")
 8018c84:	4c52      	ldr	r4, [pc, #328]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018c86:	4d55      	ldr	r5, [pc, #340]	; (8018ddc <CST_ModemCmd+0x4c8>)
 8018c88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018c8a:	6020      	str	r0, [r4, #0]
 8018c8c:	6061      	str	r1, [r4, #4]
 8018c8e:	60a2      	str	r2, [r4, #8]
 8018c90:	60e3      	str	r3, [r4, #12]
 8018c92:	782b      	ldrb	r3, [r5, #0]
 8018c94:	7423      	strb	r3, [r4, #16]
 8018c96:	4620      	mov	r0, r4
 8018c98:	f006 fa3b 	bl	801f112 <crs_strlen>
 8018c9c:	b283      	uxth	r3, r0
 8018c9e:	4622      	mov	r2, r4
 8018ca0:	2101      	movs	r1, #1
 8018ca2:	2007      	movs	r0, #7
 8018ca4:	f006 fa78 	bl	801f198 <traceIF_itmPrint>
 8018ca8:	4620      	mov	r0, r4
 8018caa:	f006 fa32 	bl	801f112 <crs_strlen>
 8018cae:	b282      	uxth	r2, r0
 8018cb0:	4621      	mov	r1, r4
 8018cb2:	2007      	movs	r0, #7
 8018cb4:	f006 faaa 	bl	801f20c <traceIF_uartPrintForce>
          cmd_status = CMD_PROCESS_ERROR;
 8018cb8:	2502      	movs	r5, #2
 8018cba:	e653      	b.n	8018964 <CST_ModemCmd+0x50>
      else if (memcmp((const CRC_CHAR_t *)argv_p[1], "get", crs_strlen(argv_p[1])) == 0)
 8018cbc:	9c02      	ldr	r4, [sp, #8]
 8018cbe:	4620      	mov	r0, r4
 8018cc0:	f006 fa27 	bl	801f112 <crs_strlen>
 8018cc4:	4602      	mov	r2, r0
 8018cc6:	4946      	ldr	r1, [pc, #280]	; (8018de0 <CST_ModemCmd+0x4cc>)
 8018cc8:	4620      	mov	r0, r4
 8018cca:	f00d f834 	bl	8025d36 <memcmp>
 8018cce:	2800      	cmp	r0, #0
 8018cd0:	d140      	bne.n	8018d54 <CST_ModemCmd+0x440>
        PRINT_FORCE("GSM Bands:")
 8018cd2:	4c3f      	ldr	r4, [pc, #252]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018cd4:	4b43      	ldr	r3, [pc, #268]	; (8018de4 <CST_ModemCmd+0x4d0>)
 8018cd6:	cb07      	ldmia	r3!, {r0, r1, r2}
 8018cd8:	6020      	str	r0, [r4, #0]
 8018cda:	6061      	str	r1, [r4, #4]
 8018cdc:	60a2      	str	r2, [r4, #8]
 8018cde:	781b      	ldrb	r3, [r3, #0]
 8018ce0:	7323      	strb	r3, [r4, #12]
 8018ce2:	4620      	mov	r0, r4
 8018ce4:	f006 fa15 	bl	801f112 <crs_strlen>
 8018ce8:	b283      	uxth	r3, r0
 8018cea:	4622      	mov	r2, r4
 8018cec:	2101      	movs	r1, #1
 8018cee:	2007      	movs	r0, #7
 8018cf0:	f006 fa52 	bl	801f198 <traceIF_itmPrint>
 8018cf4:	4620      	mov	r0, r4
 8018cf6:	f006 fa0c 	bl	801f112 <crs_strlen>
 8018cfa:	b282      	uxth	r2, r0
 8018cfc:	4621      	mov	r1, r4
 8018cfe:	2007      	movs	r0, #7
 8018d00:	f006 fa84 	bl	801f20c <traceIF_uartPrintForce>
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%GETCFG=\"BAND\"");
 8018d04:	4c2e      	ldr	r4, [pc, #184]	; (8018dc0 <CST_ModemCmd+0x4ac>)
 8018d06:	4938      	ldr	r1, [pc, #224]	; (8018de8 <CST_ModemCmd+0x4d4>)
 8018d08:	4620      	mov	r0, r4
 8018d0a:	f00c ffb1 	bl	8025c70 <sprintf>
        ret = (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018d0e:	4620      	mov	r0, r4
 8018d10:	f7ff fdc2 	bl	8018898 <cst_at_command_handle>
        if (ret != 0U)
 8018d14:	4605      	mov	r5, r0
 8018d16:	2800      	cmp	r0, #0
 8018d18:	f43f ae24 	beq.w	8018964 <CST_ModemCmd+0x50>
          PRINT_FORCE("command fail\n\r")
 8018d1c:	4c2c      	ldr	r4, [pc, #176]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018d1e:	4d2f      	ldr	r5, [pc, #188]	; (8018ddc <CST_ModemCmd+0x4c8>)
 8018d20:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018d22:	6020      	str	r0, [r4, #0]
 8018d24:	6061      	str	r1, [r4, #4]
 8018d26:	60a2      	str	r2, [r4, #8]
 8018d28:	60e3      	str	r3, [r4, #12]
 8018d2a:	782b      	ldrb	r3, [r5, #0]
 8018d2c:	7423      	strb	r3, [r4, #16]
 8018d2e:	4620      	mov	r0, r4
 8018d30:	f006 f9ef 	bl	801f112 <crs_strlen>
 8018d34:	b283      	uxth	r3, r0
 8018d36:	4622      	mov	r2, r4
 8018d38:	2101      	movs	r1, #1
 8018d3a:	2007      	movs	r0, #7
 8018d3c:	f006 fa2c 	bl	801f198 <traceIF_itmPrint>
 8018d40:	4620      	mov	r0, r4
 8018d42:	f006 f9e6 	bl	801f112 <crs_strlen>
 8018d46:	b282      	uxth	r2, r0
 8018d48:	4621      	mov	r1, r4
 8018d4a:	2007      	movs	r0, #7
 8018d4c:	f006 fa5e 	bl	801f20c <traceIF_uartPrintForce>
          cmd_status = CMD_PROCESS_ERROR;
 8018d50:	2502      	movs	r5, #2
 8018d52:	e607      	b.n	8018964 <CST_ModemCmd+0x50>
        PRINT_FORCE("bad command: %s %s\n\r", cmd_p, argv_p[0])
 8018d54:	4c1e      	ldr	r4, [pc, #120]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018d56:	9b01      	ldr	r3, [sp, #4]
 8018d58:	462a      	mov	r2, r5
 8018d5a:	4924      	ldr	r1, [pc, #144]	; (8018dec <CST_ModemCmd+0x4d8>)
 8018d5c:	4620      	mov	r0, r4
 8018d5e:	f00c ff87 	bl	8025c70 <sprintf>
 8018d62:	4620      	mov	r0, r4
 8018d64:	f006 f9d5 	bl	801f112 <crs_strlen>
 8018d68:	b283      	uxth	r3, r0
 8018d6a:	4622      	mov	r2, r4
 8018d6c:	2101      	movs	r1, #1
 8018d6e:	2007      	movs	r0, #7
 8018d70:	f006 fa12 	bl	801f198 <traceIF_itmPrint>
 8018d74:	4620      	mov	r0, r4
 8018d76:	f006 f9cc 	bl	801f112 <crs_strlen>
 8018d7a:	b282      	uxth	r2, r0
 8018d7c:	4621      	mov	r1, r4
 8018d7e:	2007      	movs	r0, #7
 8018d80:	f006 fa44 	bl	801f20c <traceIF_uartPrintForce>
        cmd_status = CMD_SYNTAX_ERROR;
 8018d84:	2501      	movs	r5, #1
 8018d86:	e5ed      	b.n	8018964 <CST_ModemCmd+0x50>
      PRINT_FORCE("bad command: %s %s\n\r", cmd_p, argv_p[0])
 8018d88:	4c11      	ldr	r4, [pc, #68]	; (8018dd0 <CST_ModemCmd+0x4bc>)
 8018d8a:	9b01      	ldr	r3, [sp, #4]
 8018d8c:	462a      	mov	r2, r5
 8018d8e:	4917      	ldr	r1, [pc, #92]	; (8018dec <CST_ModemCmd+0x4d8>)
 8018d90:	4620      	mov	r0, r4
 8018d92:	f00c ff6d 	bl	8025c70 <sprintf>
 8018d96:	4620      	mov	r0, r4
 8018d98:	f006 f9bb 	bl	801f112 <crs_strlen>
 8018d9c:	b283      	uxth	r3, r0
 8018d9e:	4622      	mov	r2, r4
 8018da0:	2101      	movs	r1, #1
 8018da2:	2007      	movs	r0, #7
 8018da4:	f006 f9f8 	bl	801f198 <traceIF_itmPrint>
 8018da8:	4620      	mov	r0, r4
 8018daa:	f006 f9b2 	bl	801f112 <crs_strlen>
 8018dae:	b282      	uxth	r2, r0
 8018db0:	4621      	mov	r1, r4
 8018db2:	2007      	movs	r0, #7
 8018db4:	f006 fa2a 	bl	801f20c <traceIF_uartPrintForce>
      cmd_status = CMD_SYNTAX_ERROR;
 8018db8:	2501      	movs	r5, #1
 8018dba:	e5d3      	b.n	8018964 <CST_ModemCmd+0x50>
 8018dbc:	08032c5c 	.word	0x08032c5c
 8018dc0:	200038d0 	.word	0x200038d0
 8018dc4:	08032c68 	.word	0x08032c68
 8018dc8:	08032c88 	.word	0x08032c88
 8018dcc:	08032cb0 	.word	0x08032cb0
 8018dd0:	20004ddc 	.word	0x20004ddc
 8018dd4:	08032d64 	.word	0x08032d64
 8018dd8:	08032ce0 	.word	0x08032ce0
 8018ddc:	08032c48 	.word	0x08032c48
 8018de0:	08032d04 	.word	0x08032d04
 8018de4:	08032d08 	.word	0x08032d08
 8018de8:	08032d18 	.word	0x08032d18
 8018dec:	08032d2c 	.word	0x08032d2c

08018df0 <CST_AtCmd>:
  * @brief  AT command line management
  * @param  cmd_line_p - command line
  * @retval cmd_status_t - command result
  */
static cmd_status_t CST_AtCmd(uint8_t *cmd_line_p)
{
 8018df0:	b530      	push	{r4, r5, lr}
 8018df2:	b08f      	sub	sp, #60	; 0x3c
  const uint8_t *cmd_p;

  cmd_status = CMD_OK;

  /* find an AT command */
  if (cmd_line_p != NULL)
 8018df4:	2800      	cmp	r0, #0
 8018df6:	d078      	beq.n	8018eea <CST_AtCmd+0xfa>
 8018df8:	4605      	mov	r5, r0
  {
    cmd_len = crs_strlen(cmd_line_p);
 8018dfa:	f006 f98a 	bl	801f112 <crs_strlen>
    for (i = 0U ; i < cmd_len ; i++)
 8018dfe:	2300      	movs	r3, #0
 8018e00:	4283      	cmp	r3, r0
 8018e02:	d204      	bcs.n	8018e0e <CST_AtCmd+0x1e>
    {
      if (cmd_line_p[i] == (uint8_t)' ')
 8018e04:	5cea      	ldrb	r2, [r5, r3]
 8018e06:	2a20      	cmp	r2, #32
 8018e08:	d001      	beq.n	8018e0e <CST_AtCmd+0x1e>
    for (i = 0U ; i < cmd_len ; i++)
 8018e0a:	3301      	adds	r3, #1
 8018e0c:	e7f8      	b.n	8018e00 <CST_AtCmd+0x10>
      {
        /* first blank found in the command line */
        break;
      }
    }
    i++;
 8018e0e:	3301      	adds	r3, #1

    if (
 8018e10:	4298      	cmp	r0, r3
 8018e12:	d911      	bls.n	8018e38 <CST_AtCmd+0x48>
      (i < cmd_len)
      &&
      (
        (memcmp((const CRC_CHAR_t *)&cmd_line_p[i], (const CRC_CHAR_t *)"at", 2) == 0)
 8018e14:	18ec      	adds	r4, r5, r3
 8018e16:	2202      	movs	r2, #2
 8018e18:	4937      	ldr	r1, [pc, #220]	; (8018ef8 <CST_AtCmd+0x108>)
 8018e1a:	4620      	mov	r0, r4
 8018e1c:	f00c ff8b 	bl	8025d36 <memcmp>
      &&
 8018e20:	b128      	cbz	r0, 8018e2e <CST_AtCmd+0x3e>
        ||
        (memcmp((const CRC_CHAR_t *)&cmd_line_p[i], (const CRC_CHAR_t *)"AT", 2) == 0)
 8018e22:	2202      	movs	r2, #2
 8018e24:	4935      	ldr	r1, [pc, #212]	; (8018efc <CST_AtCmd+0x10c>)
 8018e26:	4620      	mov	r0, r4
 8018e28:	f00c ff85 	bl	8025d36 <memcmp>
        ||
 8018e2c:	b920      	cbnz	r0, 8018e38 <CST_AtCmd+0x48>
      )
    )
    {
      /* AT command to process */
      cmd_status = cst_at_command_handle(&cmd_line_p[i]);
 8018e2e:	4620      	mov	r0, r4
 8018e30:	f7ff fd32 	bl	8018898 <cst_at_command_handle>
  {
    /* wrong command: displays help */
    cst_at_cmd_help();
  }
  return cmd_status;
}
 8018e34:	b00f      	add	sp, #60	; 0x3c
 8018e36:	bd30      	pop	{r4, r5, pc}
      cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8018e38:	4931      	ldr	r1, [pc, #196]	; (8018f00 <CST_AtCmd+0x110>)
 8018e3a:	4628      	mov	r0, r5
 8018e3c:	f00c ffa6 	bl	8025d8c <strtok>
      if (cmd_p != NULL)
 8018e40:	4604      	mov	r4, r0
 8018e42:	2800      	cmp	r0, #0
 8018e44:	d04d      	beq.n	8018ee2 <CST_AtCmd+0xf2>
                   crs_strlen(cmd_p))
 8018e46:	f006 f964 	bl	801f112 <crs_strlen>
 8018e4a:	4602      	mov	r2, r0
        if (memcmp((const CRC_CHAR_t *)cmd_p,
 8018e4c:	492d      	ldr	r1, [pc, #180]	; (8018f04 <CST_AtCmd+0x114>)
 8018e4e:	4620      	mov	r0, r4
 8018e50:	f00c ff71 	bl	8025d36 <memcmp>
 8018e54:	2800      	cmp	r0, #0
 8018e56:	d140      	bne.n	8018eda <CST_AtCmd+0xea>
          argv_p[0] = (uint8_t *)strtok(NULL, " \t");
 8018e58:	4929      	ldr	r1, [pc, #164]	; (8018f00 <CST_AtCmd+0x110>)
 8018e5a:	f00c ff97 	bl	8025d8c <strtok>
 8018e5e:	4604      	mov	r4, r0
 8018e60:	9001      	str	r0, [sp, #4]
          if (argv_p[0] != NULL)
 8018e62:	2800      	cmp	r0, #0
 8018e64:	d045      	beq.n	8018ef2 <CST_AtCmd+0x102>
            if (memcmp((CRC_CHAR_t *)argv_p[0], "help", crs_strlen(argv_p[0])) == 0)
 8018e66:	f006 f954 	bl	801f112 <crs_strlen>
 8018e6a:	4602      	mov	r2, r0
 8018e6c:	4926      	ldr	r1, [pc, #152]	; (8018f08 <CST_AtCmd+0x118>)
 8018e6e:	4620      	mov	r0, r4
 8018e70:	f00c ff61 	bl	8025d36 <memcmp>
 8018e74:	b918      	cbnz	r0, 8018e7e <CST_AtCmd+0x8e>
              cst_at_cmd_help();
 8018e76:	f7ff fb59 	bl	801852c <cst_at_cmd_help>
  cmd_status = CMD_OK;
 8018e7a:	2000      	movs	r0, #0
 8018e7c:	e7da      	b.n	8018e34 <CST_AtCmd+0x44>
                            crs_strlen(argv_p[0]))
 8018e7e:	4620      	mov	r0, r4
 8018e80:	f006 f947 	bl	801f112 <crs_strlen>
 8018e84:	4602      	mov	r2, r0
            else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8018e86:	4921      	ldr	r1, [pc, #132]	; (8018f0c <CST_AtCmd+0x11c>)
 8018e88:	4620      	mov	r0, r4
 8018e8a:	f00c ff54 	bl	8025d36 <memcmp>
 8018e8e:	b108      	cbz	r0, 8018e94 <CST_AtCmd+0xa4>
  cmd_status = CMD_OK;
 8018e90:	2000      	movs	r0, #0
 8018e92:	e7cf      	b.n	8018e34 <CST_AtCmd+0x44>
              argv_p[1] = (uint8_t *)strtok(NULL, " \t");
 8018e94:	491a      	ldr	r1, [pc, #104]	; (8018f00 <CST_AtCmd+0x110>)
 8018e96:	f00c ff79 	bl	8025d8c <strtok>
 8018e9a:	9002      	str	r0, [sp, #8]
              if (argv_p[1] != NULL)
 8018e9c:	b118      	cbz	r0, 8018ea6 <CST_AtCmd+0xb6>
                cst_at_timeout = (uint32_t)crs_atoi(argv_p[1]);
 8018e9e:	f006 f8f3 	bl	801f088 <crs_atoi>
 8018ea2:	4b1b      	ldr	r3, [pc, #108]	; (8018f10 <CST_AtCmd+0x120>)
 8018ea4:	6018      	str	r0, [r3, #0]
              PRINT_FORCE("at timeout : %ld\n\r", cst_at_timeout)
 8018ea6:	4c1b      	ldr	r4, [pc, #108]	; (8018f14 <CST_AtCmd+0x124>)
 8018ea8:	4b19      	ldr	r3, [pc, #100]	; (8018f10 <CST_AtCmd+0x120>)
 8018eaa:	681a      	ldr	r2, [r3, #0]
 8018eac:	491a      	ldr	r1, [pc, #104]	; (8018f18 <CST_AtCmd+0x128>)
 8018eae:	4620      	mov	r0, r4
 8018eb0:	f00c fede 	bl	8025c70 <sprintf>
 8018eb4:	4620      	mov	r0, r4
 8018eb6:	f006 f92c 	bl	801f112 <crs_strlen>
 8018eba:	b283      	uxth	r3, r0
 8018ebc:	4622      	mov	r2, r4
 8018ebe:	2101      	movs	r1, #1
 8018ec0:	2007      	movs	r0, #7
 8018ec2:	f006 f969 	bl	801f198 <traceIF_itmPrint>
 8018ec6:	4620      	mov	r0, r4
 8018ec8:	f006 f923 	bl	801f112 <crs_strlen>
 8018ecc:	b282      	uxth	r2, r0
 8018ece:	4621      	mov	r1, r4
 8018ed0:	2007      	movs	r0, #7
 8018ed2:	f006 f99b 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8018ed6:	2000      	movs	r0, #0
 8018ed8:	e7ac      	b.n	8018e34 <CST_AtCmd+0x44>
          cst_at_cmd_help();
 8018eda:	f7ff fb27 	bl	801852c <cst_at_cmd_help>
  cmd_status = CMD_OK;
 8018ede:	2000      	movs	r0, #0
 8018ee0:	e7a8      	b.n	8018e34 <CST_AtCmd+0x44>
        cst_at_cmd_help();
 8018ee2:	f7ff fb23 	bl	801852c <cst_at_cmd_help>
  cmd_status = CMD_OK;
 8018ee6:	2000      	movs	r0, #0
 8018ee8:	e7a4      	b.n	8018e34 <CST_AtCmd+0x44>
    cst_at_cmd_help();
 8018eea:	f7ff fb1f 	bl	801852c <cst_at_cmd_help>
  cmd_status = CMD_OK;
 8018eee:	2000      	movs	r0, #0
 8018ef0:	e7a0      	b.n	8018e34 <CST_AtCmd+0x44>
 8018ef2:	2000      	movs	r0, #0
 8018ef4:	e79e      	b.n	8018e34 <CST_AtCmd+0x44>
 8018ef6:	bf00      	nop
 8018ef8:	08032d44 	.word	0x08032d44
 8018efc:	08032d48 	.word	0x08032d48
 8018f00:	08032b44 	.word	0x08032b44
 8018f04:	080327b4 	.word	0x080327b4
 8018f08:	08032b48 	.word	0x08032b48
 8018f0c:	08032d4c 	.word	0x08032d4c
 8018f10:	20000054 	.word	0x20000054
 8018f14:	20004ddc 	.word	0x20004ddc
 8018f18:	08032d54 	.word	0x08032d54

08018f1c <CST_cmd>:
{
 8018f1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8018f20:	b08f      	sub	sp, #60	; 0x3c
 8018f22:	4605      	mov	r5, r0
  PRINT_FORCE("\n\r")
 8018f24:	4c88      	ldr	r4, [pc, #544]	; (8019148 <CST_cmd+0x22c>)
 8018f26:	4b89      	ldr	r3, [pc, #548]	; (801914c <CST_cmd+0x230>)
 8018f28:	6818      	ldr	r0, [r3, #0]
 8018f2a:	6020      	str	r0, [r4, #0]
 8018f2c:	791b      	ldrb	r3, [r3, #4]
 8018f2e:	7123      	strb	r3, [r4, #4]
 8018f30:	4620      	mov	r0, r4
 8018f32:	f006 f8ee 	bl	801f112 <crs_strlen>
 8018f36:	b283      	uxth	r3, r0
 8018f38:	4622      	mov	r2, r4
 8018f3a:	2101      	movs	r1, #1
 8018f3c:	2007      	movs	r0, #7
 8018f3e:	f006 f92b 	bl	801f198 <traceIF_itmPrint>
 8018f42:	4620      	mov	r0, r4
 8018f44:	f006 f8e5 	bl	801f112 <crs_strlen>
 8018f48:	b282      	uxth	r2, r0
 8018f4a:	4621      	mov	r1, r4
 8018f4c:	2007      	movs	r0, #7
 8018f4e:	f006 f95d 	bl	801f20c <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8018f52:	497f      	ldr	r1, [pc, #508]	; (8019150 <CST_cmd+0x234>)
 8018f54:	4628      	mov	r0, r5
 8018f56:	f00c ff19 	bl	8025d8c <strtok>
  if (cmd_p != NULL)
 8018f5a:	2800      	cmp	r0, #0
 8018f5c:	f001 80d8 	beq.w	801a110 <CST_cmd+0x11f4>
 8018f60:	4605      	mov	r5, r0
               crs_strlen(cmd_p))
 8018f62:	f006 f8d6 	bl	801f112 <crs_strlen>
 8018f66:	4602      	mov	r2, r0
    if (memcmp((CRC_CHAR_t *)cmd_p,
 8018f68:	497a      	ldr	r1, [pc, #488]	; (8019154 <CST_cmd+0x238>)
 8018f6a:	4628      	mov	r0, r5
 8018f6c:	f00c fee3 	bl	8025d36 <memcmp>
 8018f70:	2800      	cmp	r0, #0
 8018f72:	f041 80ad 	bne.w	801a0d0 <CST_cmd+0x11b4>
      for (argc = 0U ; argc < CST_CMS_PARAM_MAX ; argc++)
 8018f76:	2400      	movs	r4, #0
 8018f78:	e000      	b.n	8018f7c <CST_cmd+0x60>
 8018f7a:	3401      	adds	r4, #1
 8018f7c:	2c0c      	cmp	r4, #12
 8018f7e:	d80a      	bhi.n	8018f96 <CST_cmd+0x7a>
        argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 8018f80:	4973      	ldr	r1, [pc, #460]	; (8019150 <CST_cmd+0x234>)
 8018f82:	2000      	movs	r0, #0
 8018f84:	f00c ff02 	bl	8025d8c <strtok>
 8018f88:	ab0e      	add	r3, sp, #56	; 0x38
 8018f8a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8018f8e:	f843 0c34 	str.w	r0, [r3, #-52]
        if (argv_p[argc] == NULL)
 8018f92:	2800      	cmp	r0, #0
 8018f94:	d1f1      	bne.n	8018f7a <CST_cmd+0x5e>
      if (argc == 0U)
 8018f96:	b924      	cbnz	r4, 8018fa2 <CST_cmd+0x86>
        CST_HelpCmd();
 8018f98:	f7ff fb06 	bl	80185a8 <CST_HelpCmd>
  cmd_status = CMD_OK;
 8018f9c:	2500      	movs	r5, #0
 8018f9e:	f001 b8b8 	b.w	801a112 <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0],  "help",  crs_strlen(argv_p[0])) == 0)
 8018fa2:	9e01      	ldr	r6, [sp, #4]
 8018fa4:	4630      	mov	r0, r6
 8018fa6:	f006 f8b4 	bl	801f112 <crs_strlen>
 8018faa:	4602      	mov	r2, r0
 8018fac:	496a      	ldr	r1, [pc, #424]	; (8019158 <CST_cmd+0x23c>)
 8018fae:	4630      	mov	r0, r6
 8018fb0:	f00c fec1 	bl	8025d36 <memcmp>
 8018fb4:	b920      	cbnz	r0, 8018fc0 <CST_cmd+0xa4>
        CST_HelpCmd();
 8018fb6:	f7ff faf7 	bl	80185a8 <CST_HelpCmd>
  cmd_status = CMD_OK;
 8018fba:	2500      	movs	r5, #0
 8018fbc:	f001 b8a9 	b.w	801a112 <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "polling", crs_strlen(argv_p[0])) == 0)
 8018fc0:	4630      	mov	r0, r6
 8018fc2:	f006 f8a6 	bl	801f112 <crs_strlen>
 8018fc6:	4602      	mov	r2, r0
 8018fc8:	4964      	ldr	r1, [pc, #400]	; (801915c <CST_cmd+0x240>)
 8018fca:	4630      	mov	r0, r6
 8018fcc:	f00c feb3 	bl	8025d36 <memcmp>
 8018fd0:	2800      	cmp	r0, #0
 8018fd2:	d14a      	bne.n	801906a <CST_cmd+0x14e>
        if (argc == 2U)
 8018fd4:	2c02      	cmp	r4, #2
 8018fd6:	d01c      	beq.n	8019012 <CST_cmd+0xf6>
        if (CST_polling_active == 0U)
 8018fd8:	4b61      	ldr	r3, [pc, #388]	; (8019160 <CST_cmd+0x244>)
 8018fda:	781b      	ldrb	r3, [r3, #0]
 8018fdc:	bb5b      	cbnz	r3, 8019036 <CST_cmd+0x11a>
          PRINT_FORCE("%s polling disable", CST_cmd_label)
 8018fde:	4c5a      	ldr	r4, [pc, #360]	; (8019148 <CST_cmd+0x22c>)
 8018fe0:	4a5c      	ldr	r2, [pc, #368]	; (8019154 <CST_cmd+0x238>)
 8018fe2:	4960      	ldr	r1, [pc, #384]	; (8019164 <CST_cmd+0x248>)
 8018fe4:	4620      	mov	r0, r4
 8018fe6:	f00c fe43 	bl	8025c70 <sprintf>
 8018fea:	4620      	mov	r0, r4
 8018fec:	f006 f891 	bl	801f112 <crs_strlen>
 8018ff0:	b283      	uxth	r3, r0
 8018ff2:	4622      	mov	r2, r4
 8018ff4:	2101      	movs	r1, #1
 8018ff6:	2007      	movs	r0, #7
 8018ff8:	f006 f8ce 	bl	801f198 <traceIF_itmPrint>
 8018ffc:	4620      	mov	r0, r4
 8018ffe:	f006 f888 	bl	801f112 <crs_strlen>
 8019002:	b282      	uxth	r2, r0
 8019004:	4621      	mov	r1, r4
 8019006:	2007      	movs	r0, #7
 8019008:	f006 f900 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 801900c:	2500      	movs	r5, #0
 801900e:	f001 b880 	b.w	801a112 <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 8019012:	9c02      	ldr	r4, [sp, #8]
 8019014:	4620      	mov	r0, r4
 8019016:	f006 f87c 	bl	801f112 <crs_strlen>
 801901a:	4602      	mov	r2, r0
 801901c:	4952      	ldr	r1, [pc, #328]	; (8019168 <CST_cmd+0x24c>)
 801901e:	4620      	mov	r0, r4
 8019020:	f00c fe89 	bl	8025d36 <memcmp>
 8019024:	b918      	cbnz	r0, 801902e <CST_cmd+0x112>
            CST_polling_active = false;
 8019026:	4b4e      	ldr	r3, [pc, #312]	; (8019160 <CST_cmd+0x244>)
 8019028:	2200      	movs	r2, #0
 801902a:	701a      	strb	r2, [r3, #0]
 801902c:	e7d4      	b.n	8018fd8 <CST_cmd+0xbc>
            CST_polling_active = true;
 801902e:	4b4c      	ldr	r3, [pc, #304]	; (8019160 <CST_cmd+0x244>)
 8019030:	2201      	movs	r2, #1
 8019032:	701a      	strb	r2, [r3, #0]
 8019034:	e7d0      	b.n	8018fd8 <CST_cmd+0xbc>
          PRINT_FORCE("%s polling enable", CST_cmd_label)
 8019036:	4c44      	ldr	r4, [pc, #272]	; (8019148 <CST_cmd+0x22c>)
 8019038:	4a46      	ldr	r2, [pc, #280]	; (8019154 <CST_cmd+0x238>)
 801903a:	494c      	ldr	r1, [pc, #304]	; (801916c <CST_cmd+0x250>)
 801903c:	4620      	mov	r0, r4
 801903e:	f00c fe17 	bl	8025c70 <sprintf>
 8019042:	4620      	mov	r0, r4
 8019044:	f006 f865 	bl	801f112 <crs_strlen>
 8019048:	b283      	uxth	r3, r0
 801904a:	4622      	mov	r2, r4
 801904c:	2101      	movs	r1, #1
 801904e:	2007      	movs	r0, #7
 8019050:	f006 f8a2 	bl	801f198 <traceIF_itmPrint>
 8019054:	4620      	mov	r0, r4
 8019056:	f006 f85c 	bl	801f112 <crs_strlen>
 801905a:	b282      	uxth	r2, r0
 801905c:	4621      	mov	r1, r4
 801905e:	2007      	movs	r0, #7
 8019060:	f006 f8d4 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8019064:	2500      	movs	r5, #0
 8019066:	f001 b854 	b.w	801a112 <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "targetstate", crs_strlen(argv_p[0])) == 0)
 801906a:	4630      	mov	r0, r6
 801906c:	f006 f851 	bl	801f112 <crs_strlen>
 8019070:	4602      	mov	r2, r0
 8019072:	493f      	ldr	r1, [pc, #252]	; (8019170 <CST_cmd+0x254>)
 8019074:	4630      	mov	r0, r6
 8019076:	f00c fe5e 	bl	8025d36 <memcmp>
 801907a:	2800      	cmp	r0, #0
 801907c:	f040 8088 	bne.w	8019190 <CST_cmd+0x274>
        if (argc == 2U)
 8019080:	2c02      	cmp	r4, #2
 8019082:	d002      	beq.n	801908a <CST_cmd+0x16e>
  cmd_status = CMD_OK;
 8019084:	2500      	movs	r5, #0
 8019086:	f001 b844 	b.w	801a112 <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 801908a:	9c02      	ldr	r4, [sp, #8]
 801908c:	4620      	mov	r0, r4
 801908e:	f006 f840 	bl	801f112 <crs_strlen>
 8019092:	4602      	mov	r2, r0
 8019094:	4934      	ldr	r1, [pc, #208]	; (8019168 <CST_cmd+0x24c>)
 8019096:	4620      	mov	r0, r4
 8019098:	f00c fe4d 	bl	8025d36 <memcmp>
 801909c:	bb40      	cbnz	r0, 80190f0 <CST_cmd+0x1d4>
            target_state.rt_state     = DC_SERVICE_ON;
 801909e:	4a35      	ldr	r2, [pc, #212]	; (8019174 <CST_cmd+0x258>)
 80190a0:	2307      	movs	r3, #7
 80190a2:	7213      	strb	r3, [r2, #8]
            target_state.target_state = DC_TARGET_STATE_OFF;
 80190a4:	2300      	movs	r3, #0
 80190a6:	7253      	strb	r3, [r2, #9]
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&target_state, sizeof(target_state));
 80190a8:	230c      	movs	r3, #12
 80190aa:	4933      	ldr	r1, [pc, #204]	; (8019178 <CST_cmd+0x25c>)
 80190ac:	8809      	ldrh	r1, [r1, #0]
 80190ae:	4833      	ldr	r0, [pc, #204]	; (801917c <CST_cmd+0x260>)
 80190b0:	f008 fc3e 	bl	8021930 <dc_com_write>
          PRINT_FORCE("New modem target state   : %s", CST_TargetStateName_p[target_state.target_state])
 80190b4:	4b2f      	ldr	r3, [pc, #188]	; (8019174 <CST_cmd+0x258>)
 80190b6:	7a5a      	ldrb	r2, [r3, #9]
 80190b8:	4c23      	ldr	r4, [pc, #140]	; (8019148 <CST_cmd+0x22c>)
 80190ba:	4b31      	ldr	r3, [pc, #196]	; (8019180 <CST_cmd+0x264>)
 80190bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80190c0:	4930      	ldr	r1, [pc, #192]	; (8019184 <CST_cmd+0x268>)
 80190c2:	4620      	mov	r0, r4
 80190c4:	f00c fdd4 	bl	8025c70 <sprintf>
 80190c8:	4620      	mov	r0, r4
 80190ca:	f006 f822 	bl	801f112 <crs_strlen>
 80190ce:	b283      	uxth	r3, r0
 80190d0:	4622      	mov	r2, r4
 80190d2:	2101      	movs	r1, #1
 80190d4:	2007      	movs	r0, #7
 80190d6:	f006 f85f 	bl	801f198 <traceIF_itmPrint>
 80190da:	4620      	mov	r0, r4
 80190dc:	f006 f819 	bl	801f112 <crs_strlen>
 80190e0:	b282      	uxth	r2, r0
 80190e2:	4621      	mov	r1, r4
 80190e4:	2007      	movs	r0, #7
 80190e6:	f006 f891 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 80190ea:	2500      	movs	r5, #0
 80190ec:	f001 b811 	b.w	801a112 <CST_cmd+0x11f6>
          else if (memcmp((CRC_CHAR_t *)argv_p[1], "sim", crs_strlen(argv_p[1])) == 0)
 80190f0:	4620      	mov	r0, r4
 80190f2:	f006 f80e 	bl	801f112 <crs_strlen>
 80190f6:	4602      	mov	r2, r0
 80190f8:	4923      	ldr	r1, [pc, #140]	; (8019188 <CST_cmd+0x26c>)
 80190fa:	4620      	mov	r0, r4
 80190fc:	f00c fe1b 	bl	8025d36 <memcmp>
 8019100:	b958      	cbnz	r0, 801911a <CST_cmd+0x1fe>
            target_state.rt_state     = DC_SERVICE_ON;
 8019102:	4a1c      	ldr	r2, [pc, #112]	; (8019174 <CST_cmd+0x258>)
 8019104:	2307      	movs	r3, #7
 8019106:	7213      	strb	r3, [r2, #8]
            target_state.target_state = DC_TARGET_STATE_SIM_ONLY;
 8019108:	2301      	movs	r3, #1
 801910a:	7253      	strb	r3, [r2, #9]
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&target_state, sizeof(target_state));
 801910c:	230c      	movs	r3, #12
 801910e:	491a      	ldr	r1, [pc, #104]	; (8019178 <CST_cmd+0x25c>)
 8019110:	8809      	ldrh	r1, [r1, #0]
 8019112:	481a      	ldr	r0, [pc, #104]	; (801917c <CST_cmd+0x260>)
 8019114:	f008 fc0c 	bl	8021930 <dc_com_write>
 8019118:	e7cc      	b.n	80190b4 <CST_cmd+0x198>
          else if (memcmp((CRC_CHAR_t *)argv_p[1], "full", crs_strlen(argv_p[1])) == 0)
 801911a:	4620      	mov	r0, r4
 801911c:	f005 fff9 	bl	801f112 <crs_strlen>
 8019120:	4602      	mov	r2, r0
 8019122:	491a      	ldr	r1, [pc, #104]	; (801918c <CST_cmd+0x270>)
 8019124:	4620      	mov	r0, r4
 8019126:	f00c fe06 	bl	8025d36 <memcmp>
 801912a:	2800      	cmp	r0, #0
 801912c:	d1c2      	bne.n	80190b4 <CST_cmd+0x198>
            target_state.rt_state     = DC_SERVICE_ON;
 801912e:	4a11      	ldr	r2, [pc, #68]	; (8019174 <CST_cmd+0x258>)
 8019130:	2307      	movs	r3, #7
 8019132:	7213      	strb	r3, [r2, #8]
            target_state.target_state = DC_TARGET_STATE_FULL;
 8019134:	2302      	movs	r3, #2
 8019136:	7253      	strb	r3, [r2, #9]
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&target_state, sizeof(target_state));
 8019138:	230c      	movs	r3, #12
 801913a:	490f      	ldr	r1, [pc, #60]	; (8019178 <CST_cmd+0x25c>)
 801913c:	8809      	ldrh	r1, [r1, #0]
 801913e:	480f      	ldr	r0, [pc, #60]	; (801917c <CST_cmd+0x260>)
 8019140:	f008 fbf6 	bl	8021930 <dc_com_write>
 8019144:	e7b6      	b.n	80190b4 <CST_cmd+0x198>
 8019146:	bf00      	nop
 8019148:	20004ddc 	.word	0x20004ddc
 801914c:	08032d64 	.word	0x08032d64
 8019150:	08032b44 	.word	0x08032b44
 8019154:	08032838 	.word	0x08032838
 8019158:	08032b48 	.word	0x08032b48
 801915c:	08032d80 	.word	0x08032d80
 8019160:	20003fac 	.word	0x20003fac
 8019164:	08032d8c 	.word	0x08032d8c
 8019168:	08032d88 	.word	0x08032d88
 801916c:	08032da4 	.word	0x08032da4
 8019170:	08032db8 	.word	0x08032db8
 8019174:	20003d0c 	.word	0x20003d0c
 8019178:	2000023e 	.word	0x2000023e
 801917c:	200058b0 	.word	0x200058b0
 8019180:	08033548 	.word	0x08033548
 8019184:	08032dd0 	.word	0x08032dd0
 8019188:	08032dc4 	.word	0x08032dc4
 801918c:	08032dc8 	.word	0x08032dc8
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "apnconf", crs_strlen(argv_p[0])) == 0)
 8019190:	4630      	mov	r0, r6
 8019192:	f005 ffbe 	bl	801f112 <crs_strlen>
 8019196:	4602      	mov	r2, r0
 8019198:	49b8      	ldr	r1, [pc, #736]	; (801947c <CST_cmd+0x560>)
 801919a:	4630      	mov	r0, r6
 801919c:	f00c fdcb 	bl	8025d36 <memcmp>
 80191a0:	2800      	cmp	r0, #0
 80191a2:	f040 8195 	bne.w	80194d0 <CST_cmd+0x5b4>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 80191a6:	4db6      	ldr	r5, [pc, #728]	; (8019480 <CST_cmd+0x564>)
 80191a8:	4fb6      	ldr	r7, [pc, #728]	; (8019484 <CST_cmd+0x568>)
 80191aa:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 80191ae:	462a      	mov	r2, r5
 80191b0:	49b5      	ldr	r1, [pc, #724]	; (8019488 <CST_cmd+0x56c>)
 80191b2:	8809      	ldrh	r1, [r1, #0]
 80191b4:	4638      	mov	r0, r7
 80191b6:	f008 fc07 	bl	80219c8 <dc_com_read>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_cmd_sim_info, sizeof(cst_cmd_sim_info));
 80191ba:	4eb4      	ldr	r6, [pc, #720]	; (801948c <CST_cmd+0x570>)
 80191bc:	2330      	movs	r3, #48	; 0x30
 80191be:	4632      	mov	r2, r6
 80191c0:	49b3      	ldr	r1, [pc, #716]	; (8019490 <CST_cmd+0x574>)
 80191c2:	8809      	ldrh	r1, [r1, #0]
 80191c4:	4638      	mov	r0, r7
 80191c6:	f008 fbff 	bl	80219c8 <dc_com_read>
        apn_config.cid             = cst_cmd_cellular_params.sim_slot[cst_cmd_sim_info.index_slot].cid;
 80191ca:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 80191ce:	2262      	movs	r2, #98	; 0x62
 80191d0:	fb02 f303 	mul.w	r3, r2, r3
 80191d4:	18ea      	adds	r2, r5, r3
 80191d6:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
 80191da:	4aae      	ldr	r2, [pc, #696]	; (8019494 <CST_cmd+0x578>)
 80191dc:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
        size =  crs_strlen(cst_cmd_cellular_params.sim_slot[cst_cmd_sim_info.index_slot].apn) + 1U;
 80191e0:	3308      	adds	r3, #8
 80191e2:	18e8      	adds	r0, r5, r3
 80191e4:	3004      	adds	r0, #4
 80191e6:	f005 ff94 	bl	801f112 <crs_strlen>
 80191ea:	1c42      	adds	r2, r0, #1
        if (size <= DC_MAX_SIZE_APN)
 80191ec:	2a20      	cmp	r2, #32
 80191ee:	f200 80a6 	bhi.w	801933e <CST_cmd+0x422>
          (void)memcpy(apn_config.apn, cst_cmd_cellular_params.sim_slot[cst_cmd_sim_info.index_slot].apn, size);
 80191f2:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 80191f6:	2162      	movs	r1, #98	; 0x62
 80191f8:	fb01 f303 	mul.w	r3, r1, r3
 80191fc:	3308      	adds	r3, #8
 80191fe:	4629      	mov	r1, r5
 8019200:	4419      	add	r1, r3
 8019202:	3104      	adds	r1, #4
 8019204:	48a4      	ldr	r0, [pc, #656]	; (8019498 <CST_cmd+0x57c>)
 8019206:	f00c fe83 	bl	8025f10 <memcpy>
  cmd_status = CMD_OK;
 801920a:	2500      	movs	r5, #0
        apn_config.username[0] = 0U;
 801920c:	4ba1      	ldr	r3, [pc, #644]	; (8019494 <CST_cmd+0x578>)
 801920e:	2200      	movs	r2, #0
 8019210:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
        apn_config.password[0] = 0U;
 8019214:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
        if (argc >= 5U)
 8019218:	2c04      	cmp	r4, #4
 801921a:	f200 80ab 	bhi.w	8019374 <CST_cmd+0x458>
        if (argc >= 4U)
 801921e:	2c03      	cmp	r4, #3
 8019220:	f200 80d2 	bhi.w	80193c8 <CST_cmd+0x4ac>
        if (argc >= 3U)
 8019224:	2c02      	cmp	r4, #2
 8019226:	f200 80f9 	bhi.w	801941c <CST_cmd+0x500>
        if (argc >= 2U)
 801922a:	2c01      	cmp	r4, #1
 801922c:	f200 80fd 	bhi.w	801942a <CST_cmd+0x50e>
        if (cmd_status == CMD_OK)
 8019230:	2d00      	cmp	r5, #0
 8019232:	f040 876e 	bne.w	801a112 <CST_cmd+0x11f6>
          apn_config.rt_state = DC_SERVICE_ON;
 8019236:	4f97      	ldr	r7, [pc, #604]	; (8019494 <CST_cmd+0x578>)
 8019238:	2607      	movs	r6, #7
 801923a:	723e      	strb	r6, [r7, #8]
          (void)dc_com_write(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&apn_config, sizeof(apn_config));
 801923c:	236c      	movs	r3, #108	; 0x6c
 801923e:	463a      	mov	r2, r7
 8019240:	4996      	ldr	r1, [pc, #600]	; (801949c <CST_cmd+0x580>)
 8019242:	8809      	ldrh	r1, [r1, #0]
 8019244:	488f      	ldr	r0, [pc, #572]	; (8019484 <CST_cmd+0x568>)
 8019246:	f008 fb73 	bl	8021930 <dc_com_write>
          PRINT_FORCE("APN configuration vualues for the sim slot (%s):",
 801924a:	4b90      	ldr	r3, [pc, #576]	; (801948c <CST_cmd+0x570>)
 801924c:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 8019250:	4c93      	ldr	r4, [pc, #588]	; (80194a0 <CST_cmd+0x584>)
 8019252:	4b94      	ldr	r3, [pc, #592]	; (80194a4 <CST_cmd+0x588>)
 8019254:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019258:	4993      	ldr	r1, [pc, #588]	; (80194a8 <CST_cmd+0x58c>)
 801925a:	4620      	mov	r0, r4
 801925c:	f00c fd08 	bl	8025c70 <sprintf>
 8019260:	4620      	mov	r0, r4
 8019262:	f005 ff56 	bl	801f112 <crs_strlen>
 8019266:	b283      	uxth	r3, r0
 8019268:	4622      	mov	r2, r4
 801926a:	2101      	movs	r1, #1
 801926c:	4630      	mov	r0, r6
 801926e:	f005 ff93 	bl	801f198 <traceIF_itmPrint>
 8019272:	4620      	mov	r0, r4
 8019274:	f005 ff4d 	bl	801f112 <crs_strlen>
 8019278:	b282      	uxth	r2, r0
 801927a:	4621      	mov	r1, r4
 801927c:	4630      	mov	r0, r6
 801927e:	f005 ffc5 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("APN                : %s", apn_config.apn)
 8019282:	f107 0209 	add.w	r2, r7, #9
 8019286:	4989      	ldr	r1, [pc, #548]	; (80194ac <CST_cmd+0x590>)
 8019288:	4620      	mov	r0, r4
 801928a:	f00c fcf1 	bl	8025c70 <sprintf>
 801928e:	4620      	mov	r0, r4
 8019290:	f005 ff3f 	bl	801f112 <crs_strlen>
 8019294:	b283      	uxth	r3, r0
 8019296:	4622      	mov	r2, r4
 8019298:	2101      	movs	r1, #1
 801929a:	4630      	mov	r0, r6
 801929c:	f005 ff7c 	bl	801f198 <traceIF_itmPrint>
 80192a0:	4620      	mov	r0, r4
 80192a2:	f005 ff36 	bl	801f112 <crs_strlen>
 80192a6:	b282      	uxth	r2, r0
 80192a8:	4621      	mov	r1, r4
 80192aa:	4630      	mov	r0, r6
 80192ac:	f005 ffae 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("CID                : %d", apn_config.cid)
 80192b0:	f897 2029 	ldrb.w	r2, [r7, #41]	; 0x29
 80192b4:	497e      	ldr	r1, [pc, #504]	; (80194b0 <CST_cmd+0x594>)
 80192b6:	4620      	mov	r0, r4
 80192b8:	f00c fcda 	bl	8025c70 <sprintf>
 80192bc:	4620      	mov	r0, r4
 80192be:	f005 ff28 	bl	801f112 <crs_strlen>
 80192c2:	b283      	uxth	r3, r0
 80192c4:	4622      	mov	r2, r4
 80192c6:	2101      	movs	r1, #1
 80192c8:	4630      	mov	r0, r6
 80192ca:	f005 ff65 	bl	801f198 <traceIF_itmPrint>
 80192ce:	4620      	mov	r0, r4
 80192d0:	f005 ff1f 	bl	801f112 <crs_strlen>
 80192d4:	b282      	uxth	r2, r0
 80192d6:	4621      	mov	r1, r4
 80192d8:	4630      	mov	r0, r6
 80192da:	f005 ff97 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("username           : %s", apn_config.username)
 80192de:	f107 022a 	add.w	r2, r7, #42	; 0x2a
 80192e2:	4974      	ldr	r1, [pc, #464]	; (80194b4 <CST_cmd+0x598>)
 80192e4:	4620      	mov	r0, r4
 80192e6:	f00c fcc3 	bl	8025c70 <sprintf>
 80192ea:	4620      	mov	r0, r4
 80192ec:	f005 ff11 	bl	801f112 <crs_strlen>
 80192f0:	b283      	uxth	r3, r0
 80192f2:	4622      	mov	r2, r4
 80192f4:	2101      	movs	r1, #1
 80192f6:	4630      	mov	r0, r6
 80192f8:	f005 ff4e 	bl	801f198 <traceIF_itmPrint>
 80192fc:	4620      	mov	r0, r4
 80192fe:	f005 ff08 	bl	801f112 <crs_strlen>
 8019302:	b282      	uxth	r2, r0
 8019304:	4621      	mov	r1, r4
 8019306:	4630      	mov	r0, r6
 8019308:	f005 ff80 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("password           : %s", apn_config.password)
 801930c:	f107 024a 	add.w	r2, r7, #74	; 0x4a
 8019310:	4969      	ldr	r1, [pc, #420]	; (80194b8 <CST_cmd+0x59c>)
 8019312:	4620      	mov	r0, r4
 8019314:	f00c fcac 	bl	8025c70 <sprintf>
 8019318:	4620      	mov	r0, r4
 801931a:	f005 fefa 	bl	801f112 <crs_strlen>
 801931e:	b283      	uxth	r3, r0
 8019320:	4622      	mov	r2, r4
 8019322:	2101      	movs	r1, #1
 8019324:	4630      	mov	r0, r6
 8019326:	f005 ff37 	bl	801f198 <traceIF_itmPrint>
 801932a:	4620      	mov	r0, r4
 801932c:	f005 fef1 	bl	801f112 <crs_strlen>
 8019330:	b282      	uxth	r2, r0
 8019332:	4621      	mov	r1, r4
 8019334:	4630      	mov	r0, r6
 8019336:	f005 ff69 	bl	801f20c <traceIF_uartPrintForce>
 801933a:	f000 beea 	b.w	801a112 <CST_cmd+0x11f6>
          PRINT_FORCE("APN to long")
 801933e:	4d58      	ldr	r5, [pc, #352]	; (80194a0 <CST_cmd+0x584>)
 8019340:	4b5e      	ldr	r3, [pc, #376]	; (80194bc <CST_cmd+0x5a0>)
 8019342:	cb07      	ldmia	r3!, {r0, r1, r2}
 8019344:	6028      	str	r0, [r5, #0]
 8019346:	6069      	str	r1, [r5, #4]
 8019348:	60aa      	str	r2, [r5, #8]
 801934a:	881b      	ldrh	r3, [r3, #0]
 801934c:	81ab      	strh	r3, [r5, #12]
 801934e:	4628      	mov	r0, r5
 8019350:	f005 fedf 	bl	801f112 <crs_strlen>
 8019354:	b283      	uxth	r3, r0
 8019356:	462a      	mov	r2, r5
 8019358:	2101      	movs	r1, #1
 801935a:	2007      	movs	r0, #7
 801935c:	f005 ff1c 	bl	801f198 <traceIF_itmPrint>
 8019360:	4628      	mov	r0, r5
 8019362:	f005 fed6 	bl	801f112 <crs_strlen>
 8019366:	b282      	uxth	r2, r0
 8019368:	4629      	mov	r1, r5
 801936a:	2007      	movs	r0, #7
 801936c:	f005 ff4e 	bl	801f20c <traceIF_uartPrintForce>
          cmd_status = CMD_SYNTAX_ERROR;
 8019370:	2501      	movs	r5, #1
 8019372:	e74b      	b.n	801920c <CST_cmd+0x2f0>
          size =  crs_strlen(argv_p[4]) + 1U;
 8019374:	9e05      	ldr	r6, [sp, #20]
 8019376:	4630      	mov	r0, r6
 8019378:	f005 fecb 	bl	801f112 <crs_strlen>
 801937c:	1c42      	adds	r2, r0, #1
          if (size <= DC_CST_PASSWORD_SIZE)
 801937e:	2a20      	cmp	r2, #32
 8019380:	d804      	bhi.n	801938c <CST_cmd+0x470>
            (void)memcpy(apn_config.password, argv_p[4], size);
 8019382:	4631      	mov	r1, r6
 8019384:	484e      	ldr	r0, [pc, #312]	; (80194c0 <CST_cmd+0x5a4>)
 8019386:	f00c fdc3 	bl	8025f10 <memcpy>
 801938a:	e748      	b.n	801921e <CST_cmd+0x302>
            PRINT_FORCE("password to long")
 801938c:	4d44      	ldr	r5, [pc, #272]	; (80194a0 <CST_cmd+0x584>)
 801938e:	4e4d      	ldr	r6, [pc, #308]	; (80194c4 <CST_cmd+0x5a8>)
 8019390:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8019392:	6028      	str	r0, [r5, #0]
 8019394:	6069      	str	r1, [r5, #4]
 8019396:	60aa      	str	r2, [r5, #8]
 8019398:	60eb      	str	r3, [r5, #12]
 801939a:	8832      	ldrh	r2, [r6, #0]
 801939c:	78b3      	ldrb	r3, [r6, #2]
 801939e:	822a      	strh	r2, [r5, #16]
 80193a0:	74ab      	strb	r3, [r5, #18]
 80193a2:	4628      	mov	r0, r5
 80193a4:	f005 feb5 	bl	801f112 <crs_strlen>
 80193a8:	b283      	uxth	r3, r0
 80193aa:	462a      	mov	r2, r5
 80193ac:	2101      	movs	r1, #1
 80193ae:	2007      	movs	r0, #7
 80193b0:	f005 fef2 	bl	801f198 <traceIF_itmPrint>
 80193b4:	4628      	mov	r0, r5
 80193b6:	f005 feac 	bl	801f112 <crs_strlen>
 80193ba:	b282      	uxth	r2, r0
 80193bc:	4629      	mov	r1, r5
 80193be:	2007      	movs	r0, #7
 80193c0:	f005 ff24 	bl	801f20c <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 80193c4:	2501      	movs	r5, #1
 80193c6:	e72a      	b.n	801921e <CST_cmd+0x302>
          size =  crs_strlen(argv_p[3]) + 1U;
 80193c8:	9e04      	ldr	r6, [sp, #16]
 80193ca:	4630      	mov	r0, r6
 80193cc:	f005 fea1 	bl	801f112 <crs_strlen>
 80193d0:	1c42      	adds	r2, r0, #1
          if (size <= DC_CST_USERNAME_SIZE)
 80193d2:	2a20      	cmp	r2, #32
 80193d4:	d804      	bhi.n	80193e0 <CST_cmd+0x4c4>
            (void)memcpy(apn_config.username, argv_p[3], size);
 80193d6:	4631      	mov	r1, r6
 80193d8:	483b      	ldr	r0, [pc, #236]	; (80194c8 <CST_cmd+0x5ac>)
 80193da:	f00c fd99 	bl	8025f10 <memcpy>
 80193de:	e721      	b.n	8019224 <CST_cmd+0x308>
            PRINT_FORCE("username to long")
 80193e0:	4d2f      	ldr	r5, [pc, #188]	; (80194a0 <CST_cmd+0x584>)
 80193e2:	4e3a      	ldr	r6, [pc, #232]	; (80194cc <CST_cmd+0x5b0>)
 80193e4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80193e6:	6028      	str	r0, [r5, #0]
 80193e8:	6069      	str	r1, [r5, #4]
 80193ea:	60aa      	str	r2, [r5, #8]
 80193ec:	60eb      	str	r3, [r5, #12]
 80193ee:	8832      	ldrh	r2, [r6, #0]
 80193f0:	78b3      	ldrb	r3, [r6, #2]
 80193f2:	822a      	strh	r2, [r5, #16]
 80193f4:	74ab      	strb	r3, [r5, #18]
 80193f6:	4628      	mov	r0, r5
 80193f8:	f005 fe8b 	bl	801f112 <crs_strlen>
 80193fc:	b283      	uxth	r3, r0
 80193fe:	462a      	mov	r2, r5
 8019400:	2101      	movs	r1, #1
 8019402:	2007      	movs	r0, #7
 8019404:	f005 fec8 	bl	801f198 <traceIF_itmPrint>
 8019408:	4628      	mov	r0, r5
 801940a:	f005 fe82 	bl	801f112 <crs_strlen>
 801940e:	b282      	uxth	r2, r0
 8019410:	4629      	mov	r1, r5
 8019412:	2007      	movs	r0, #7
 8019414:	f005 fefa 	bl	801f20c <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 8019418:	2501      	movs	r5, #1
 801941a:	e703      	b.n	8019224 <CST_cmd+0x308>
          apn_config.cid = (uint8_t)crs_atoi(argv_p[2]);
 801941c:	9803      	ldr	r0, [sp, #12]
 801941e:	f005 fe33 	bl	801f088 <crs_atoi>
 8019422:	4b1c      	ldr	r3, [pc, #112]	; (8019494 <CST_cmd+0x578>)
 8019424:	f883 0029 	strb.w	r0, [r3, #41]	; 0x29
 8019428:	e6ff      	b.n	801922a <CST_cmd+0x30e>
          size =  crs_strlen(argv_p[1]) + 1U;
 801942a:	9c02      	ldr	r4, [sp, #8]
 801942c:	4620      	mov	r0, r4
 801942e:	f005 fe70 	bl	801f112 <crs_strlen>
 8019432:	1c42      	adds	r2, r0, #1
          if (size <= DC_MAX_SIZE_APN)
 8019434:	2a20      	cmp	r2, #32
 8019436:	d804      	bhi.n	8019442 <CST_cmd+0x526>
            (void)memcpy(apn_config.apn, argv_p[1], size);
 8019438:	4621      	mov	r1, r4
 801943a:	4817      	ldr	r0, [pc, #92]	; (8019498 <CST_cmd+0x57c>)
 801943c:	f00c fd68 	bl	8025f10 <memcpy>
 8019440:	e6f6      	b.n	8019230 <CST_cmd+0x314>
            PRINT_FORCE("APN to long")
 8019442:	4c17      	ldr	r4, [pc, #92]	; (80194a0 <CST_cmd+0x584>)
 8019444:	4b1d      	ldr	r3, [pc, #116]	; (80194bc <CST_cmd+0x5a0>)
 8019446:	cb07      	ldmia	r3!, {r0, r1, r2}
 8019448:	6020      	str	r0, [r4, #0]
 801944a:	6061      	str	r1, [r4, #4]
 801944c:	60a2      	str	r2, [r4, #8]
 801944e:	881b      	ldrh	r3, [r3, #0]
 8019450:	81a3      	strh	r3, [r4, #12]
 8019452:	4620      	mov	r0, r4
 8019454:	f005 fe5d 	bl	801f112 <crs_strlen>
 8019458:	b283      	uxth	r3, r0
 801945a:	4622      	mov	r2, r4
 801945c:	2101      	movs	r1, #1
 801945e:	2007      	movs	r0, #7
 8019460:	f005 fe9a 	bl	801f198 <traceIF_itmPrint>
 8019464:	4620      	mov	r0, r4
 8019466:	f005 fe54 	bl	801f112 <crs_strlen>
 801946a:	b282      	uxth	r2, r0
 801946c:	4621      	mov	r1, r4
 801946e:	2007      	movs	r0, #7
 8019470:	f005 fecc 	bl	801f20c <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 8019474:	2501      	movs	r5, #1
 8019476:	f000 be4c 	b.w	801a112 <CST_cmd+0x11f6>
 801947a:	bf00      	nop
 801947c:	08032df0 	.word	0x08032df0
 8019480:	20003b10 	.word	0x20003b10
 8019484:	200058b0 	.word	0x200058b0
 8019488:	20000232 	.word	0x20000232
 801948c:	20003cdc 	.word	0x20003cdc
 8019490:	2000023c 	.word	0x2000023c
 8019494:	200039b0 	.word	0x200039b0
 8019498:	200039b9 	.word	0x200039b9
 801949c:	20000230 	.word	0x20000230
 80194a0:	20004ddc 	.word	0x20004ddc
 80194a4:	20000058 	.word	0x20000058
 80194a8:	08032e30 	.word	0x08032e30
 80194ac:	08032e64 	.word	0x08032e64
 80194b0:	08032e80 	.word	0x08032e80
 80194b4:	08032e9c 	.word	0x08032e9c
 80194b8:	08032eb8 	.word	0x08032eb8
 80194bc:	08032df8 	.word	0x08032df8
 80194c0:	200039fa 	.word	0x200039fa
 80194c4:	08032e08 	.word	0x08032e08
 80194c8:	200039da 	.word	0x200039da
 80194cc:	08032e1c 	.word	0x08032e1c
                      crs_strlen(argv_p[0]))
 80194d0:	4630      	mov	r0, r6
 80194d2:	f005 fe1e 	bl	801f112 <crs_strlen>
 80194d6:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 80194d8:	4990      	ldr	r1, [pc, #576]	; (801971c <CST_cmd+0x800>)
 80194da:	4630      	mov	r0, r6
 80194dc:	f00c fc2b 	bl	8025d36 <memcmp>
 80194e0:	2800      	cmp	r0, #0
 80194e2:	f040 80ee 	bne.w	80196c2 <CST_cmd+0x7a6>
        PRINT_FORCE("Cellular Service Task State")
 80194e6:	4c8e      	ldr	r4, [pc, #568]	; (8019720 <CST_cmd+0x804>)
 80194e8:	4d8e      	ldr	r5, [pc, #568]	; (8019724 <CST_cmd+0x808>)
 80194ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80194ec:	6020      	str	r0, [r4, #0]
 80194ee:	6061      	str	r1, [r4, #4]
 80194f0:	60a2      	str	r2, [r4, #8]
 80194f2:	60e3      	str	r3, [r4, #12]
 80194f4:	cd07      	ldmia	r5!, {r0, r1, r2}
 80194f6:	6120      	str	r0, [r4, #16]
 80194f8:	6161      	str	r1, [r4, #20]
 80194fa:	61a2      	str	r2, [r4, #24]
 80194fc:	882b      	ldrh	r3, [r5, #0]
 80194fe:	83a3      	strh	r3, [r4, #28]
 8019500:	4620      	mov	r0, r4
 8019502:	f005 fe06 	bl	801f112 <crs_strlen>
 8019506:	b283      	uxth	r3, r0
 8019508:	4622      	mov	r2, r4
 801950a:	2101      	movs	r1, #1
 801950c:	2007      	movs	r0, #7
 801950e:	f005 fe43 	bl	801f198 <traceIF_itmPrint>
 8019512:	4620      	mov	r0, r4
 8019514:	f005 fdfd 	bl	801f112 <crs_strlen>
 8019518:	b282      	uxth	r2, r0
 801951a:	4621      	mov	r1, r4
 801951c:	2007      	movs	r0, #7
 801951e:	f005 fe75 	bl	801f20c <traceIF_uartPrintForce>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_cmd_sim_info, sizeof(cst_cmd_sim_info));
 8019522:	4e81      	ldr	r6, [pc, #516]	; (8019728 <CST_cmd+0x80c>)
 8019524:	4f81      	ldr	r7, [pc, #516]	; (801972c <CST_cmd+0x810>)
 8019526:	2330      	movs	r3, #48	; 0x30
 8019528:	4632      	mov	r2, r6
 801952a:	4981      	ldr	r1, [pc, #516]	; (8019730 <CST_cmd+0x814>)
 801952c:	8809      	ldrh	r1, [r1, #0]
 801952e:	4638      	mov	r0, r7
 8019530:	f008 fa4a 	bl	80219c8 <dc_com_read>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 8019534:	4d7f      	ldr	r5, [pc, #508]	; (8019734 <CST_cmd+0x818>)
 8019536:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801953a:	462a      	mov	r2, r5
 801953c:	497e      	ldr	r1, [pc, #504]	; (8019738 <CST_cmd+0x81c>)
 801953e:	8809      	ldrh	r1, [r1, #0]
 8019540:	4638      	mov	r0, r7
 8019542:	f008 fa41 	bl	80219c8 <dc_com_read>
        PRINT_FORCE("Current State  : %s", CST_StateName[CST_get_state()])
 8019546:	f002 ffbb 	bl	801c4c0 <CST_get_state>
 801954a:	4b7c      	ldr	r3, [pc, #496]	; (801973c <CST_cmd+0x820>)
 801954c:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8019550:	497b      	ldr	r1, [pc, #492]	; (8019740 <CST_cmd+0x824>)
 8019552:	4620      	mov	r0, r4
 8019554:	f00c fb8c 	bl	8025c70 <sprintf>
 8019558:	4620      	mov	r0, r4
 801955a:	f005 fdda 	bl	801f112 <crs_strlen>
 801955e:	b283      	uxth	r3, r0
 8019560:	4622      	mov	r2, r4
 8019562:	2101      	movs	r1, #1
 8019564:	2007      	movs	r0, #7
 8019566:	f005 fe17 	bl	801f198 <traceIF_itmPrint>
 801956a:	4620      	mov	r0, r4
 801956c:	f005 fdd1 	bl	801f112 <crs_strlen>
 8019570:	b282      	uxth	r2, r0
 8019572:	4621      	mov	r1, r4
 8019574:	2007      	movs	r0, #7
 8019576:	f005 fe49 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Sim Selected   : %s", CST_SimSlotName_p[cst_cmd_sim_info.active_slot])
 801957a:	f896 302a 	ldrb.w	r3, [r6, #42]	; 0x2a
 801957e:	4f71      	ldr	r7, [pc, #452]	; (8019744 <CST_cmd+0x828>)
 8019580:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8019584:	4970      	ldr	r1, [pc, #448]	; (8019748 <CST_cmd+0x82c>)
 8019586:	4620      	mov	r0, r4
 8019588:	f00c fb72 	bl	8025c70 <sprintf>
 801958c:	4620      	mov	r0, r4
 801958e:	f005 fdc0 	bl	801f112 <crs_strlen>
 8019592:	b283      	uxth	r3, r0
 8019594:	4622      	mov	r2, r4
 8019596:	2101      	movs	r1, #1
 8019598:	2007      	movs	r0, #7
 801959a:	f005 fdfd 	bl	801f198 <traceIF_itmPrint>
 801959e:	4620      	mov	r0, r4
 80195a0:	f005 fdb7 	bl	801f112 <crs_strlen>
 80195a4:	b282      	uxth	r2, r0
 80195a6:	4621      	mov	r1, r4
 80195a8:	2007      	movs	r0, #7
 80195aa:	f005 fe2f 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Sim %s         : %s", CST_SimSlotName_p[cst_cmd_cellular_params.sim_slot[0].sim_slot_type],
 80195ae:	7aea      	ldrb	r2, [r5, #11]
 80195b0:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 80195b4:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 8019768 <CST_cmd+0x84c>
 80195b8:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 801976c <CST_cmd+0x850>
 80195bc:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 80195c0:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 80195c4:	4641      	mov	r1, r8
 80195c6:	4620      	mov	r0, r4
 80195c8:	f00c fb52 	bl	8025c70 <sprintf>
 80195cc:	4620      	mov	r0, r4
 80195ce:	f005 fda0 	bl	801f112 <crs_strlen>
 80195d2:	b283      	uxth	r3, r0
 80195d4:	4622      	mov	r2, r4
 80195d6:	2101      	movs	r1, #1
 80195d8:	2007      	movs	r0, #7
 80195da:	f005 fddd 	bl	801f198 <traceIF_itmPrint>
 80195de:	4620      	mov	r0, r4
 80195e0:	f005 fd97 	bl	801f112 <crs_strlen>
 80195e4:	b282      	uxth	r2, r0
 80195e6:	4621      	mov	r1, r4
 80195e8:	2007      	movs	r0, #7
 80195ea:	f005 fe0f 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Sim %s         : %s", CST_SimSlotName_p[cst_cmd_cellular_params.sim_slot[1].sim_slot_type],
 80195ee:	f895 206d 	ldrb.w	r2, [r5, #109]	; 0x6d
 80195f2:	f896 302c 	ldrb.w	r3, [r6, #44]	; 0x2c
 80195f6:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 80195fa:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 80195fe:	4641      	mov	r1, r8
 8019600:	4620      	mov	r0, r4
 8019602:	f00c fb35 	bl	8025c70 <sprintf>
 8019606:	4620      	mov	r0, r4
 8019608:	f005 fd83 	bl	801f112 <crs_strlen>
 801960c:	b283      	uxth	r3, r0
 801960e:	4622      	mov	r2, r4
 8019610:	2101      	movs	r1, #1
 8019612:	2007      	movs	r0, #7
 8019614:	f005 fdc0 	bl	801f198 <traceIF_itmPrint>
 8019618:	4620      	mov	r0, r4
 801961a:	f005 fd7a 	bl	801f112 <crs_strlen>
 801961e:	b282      	uxth	r2, r0
 8019620:	4621      	mov	r1, r4
 8019622:	2007      	movs	r0, #7
 8019624:	f005 fdf2 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Sim %s         : %s", CST_SimSlotName_p[cst_cmd_cellular_params.sim_slot[2].sim_slot_type],
 8019628:	f895 20cf 	ldrb.w	r2, [r5, #207]	; 0xcf
 801962c:	f896 302d 	ldrb.w	r3, [r6, #45]	; 0x2d
 8019630:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 8019634:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 8019638:	4641      	mov	r1, r8
 801963a:	4620      	mov	r0, r4
 801963c:	f00c fb18 	bl	8025c70 <sprintf>
 8019640:	4620      	mov	r0, r4
 8019642:	f005 fd66 	bl	801f112 <crs_strlen>
 8019646:	b283      	uxth	r3, r0
 8019648:	4622      	mov	r2, r4
 801964a:	2101      	movs	r1, #1
 801964c:	2007      	movs	r0, #7
 801964e:	f005 fda3 	bl	801f198 <traceIF_itmPrint>
 8019652:	4620      	mov	r0, r4
 8019654:	f005 fd5d 	bl	801f112 <crs_strlen>
 8019658:	b282      	uxth	r2, r0
 801965a:	4621      	mov	r1, r4
 801965c:	2007      	movs	r0, #7
 801965e:	f005 fdd5 	bl	801f20c <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.nfmc_active != 0U)
 8019662:	f895 517c 	ldrb.w	r5, [r5, #380]	; 0x17c
 8019666:	2d00      	cmp	r5, #0
 8019668:	f000 8553 	beq.w	801a112 <CST_cmd+0x11f6>
          (void)dc_com_read(&dc_com_db, DC_CELLULAR_NFMC_INFO, (void *)&cst_cmd_nfmc_info, sizeof(cst_cmd_nfmc_info));
 801966c:	232c      	movs	r3, #44	; 0x2c
 801966e:	4a37      	ldr	r2, [pc, #220]	; (801974c <CST_cmd+0x830>)
 8019670:	4937      	ldr	r1, [pc, #220]	; (8019750 <CST_cmd+0x834>)
 8019672:	8809      	ldrh	r1, [r1, #0]
 8019674:	482d      	ldr	r0, [pc, #180]	; (801972c <CST_cmd+0x810>)
 8019676:	f008 f9a7 	bl	80219c8 <dc_com_read>
          for (i = 0U; i < DC_NFMC_TEMPO_NB ; i++)
 801967a:	2300      	movs	r3, #0
 801967c:	e01c      	b.n	80196b8 <CST_cmd+0x79c>
            PRINT_FORCE("nfmc tempo %ld   : %ld", i + 1U, cst_cmd_nfmc_info.tempo[i])
 801967e:	1c5d      	adds	r5, r3, #1
 8019680:	3304      	adds	r3, #4
 8019682:	4c27      	ldr	r4, [pc, #156]	; (8019720 <CST_cmd+0x804>)
 8019684:	4a31      	ldr	r2, [pc, #196]	; (801974c <CST_cmd+0x830>)
 8019686:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801968a:	462a      	mov	r2, r5
 801968c:	4931      	ldr	r1, [pc, #196]	; (8019754 <CST_cmd+0x838>)
 801968e:	4620      	mov	r0, r4
 8019690:	f00c faee 	bl	8025c70 <sprintf>
 8019694:	4620      	mov	r0, r4
 8019696:	f005 fd3c 	bl	801f112 <crs_strlen>
 801969a:	b283      	uxth	r3, r0
 801969c:	4622      	mov	r2, r4
 801969e:	2101      	movs	r1, #1
 80196a0:	2007      	movs	r0, #7
 80196a2:	f005 fd79 	bl	801f198 <traceIF_itmPrint>
 80196a6:	4620      	mov	r0, r4
 80196a8:	f005 fd33 	bl	801f112 <crs_strlen>
 80196ac:	b282      	uxth	r2, r0
 80196ae:	4621      	mov	r1, r4
 80196b0:	2007      	movs	r0, #7
 80196b2:	f005 fdab 	bl	801f20c <traceIF_uartPrintForce>
          for (i = 0U; i < DC_NFMC_TEMPO_NB ; i++)
 80196b6:	462b      	mov	r3, r5
 80196b8:	2b06      	cmp	r3, #6
 80196ba:	d9e0      	bls.n	801967e <CST_cmd+0x762>
  cmd_status = CMD_OK;
 80196bc:	2500      	movs	r5, #0
 80196be:	f000 bd28 	b.w	801a112 <CST_cmd+0x11f6>
                      crs_strlen(argv_p[0]))
 80196c2:	4630      	mov	r0, r6
 80196c4:	f005 fd25 	bl	801f112 <crs_strlen>
 80196c8:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 80196ca:	4923      	ldr	r1, [pc, #140]	; (8019758 <CST_cmd+0x83c>)
 80196cc:	4630      	mov	r0, r6
 80196ce:	f00c fb32 	bl	8025d36 <memcmp>
 80196d2:	2800      	cmp	r0, #0
 80196d4:	d14c      	bne.n	8019770 <CST_cmd+0x854>
        if (memcmp((CRC_CHAR_t *)argv_p[1],
 80196d6:	9c02      	ldr	r4, [sp, #8]
                   crs_strlen(argv_p[1]))
 80196d8:	4620      	mov	r0, r4
 80196da:	f005 fd1a 	bl	801f112 <crs_strlen>
 80196de:	4602      	mov	r2, r0
        if (memcmp((CRC_CHAR_t *)argv_p[1],
 80196e0:	491e      	ldr	r1, [pc, #120]	; (801975c <CST_cmd+0x840>)
 80196e2:	4620      	mov	r0, r4
 80196e4:	f00c fb27 	bl	8025d36 <memcmp>
 80196e8:	b110      	cbz	r0, 80196f0 <CST_cmd+0x7d4>
  cmd_status = CMD_OK;
 80196ea:	2500      	movs	r5, #0
 80196ec:	f000 bd11 	b.w	801a112 <CST_cmd+0x11f6>
          TRACE_VALID("@valid@:cst:netstate:%s\n\r", CST_StateName[CST_get_state()])
 80196f0:	f002 fee6 	bl	801c4c0 <CST_get_state>
 80196f4:	4c1a      	ldr	r4, [pc, #104]	; (8019760 <CST_cmd+0x844>)
 80196f6:	4b11      	ldr	r3, [pc, #68]	; (801973c <CST_cmd+0x820>)
 80196f8:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 80196fc:	4919      	ldr	r1, [pc, #100]	; (8019764 <CST_cmd+0x848>)
 80196fe:	4620      	mov	r0, r4
 8019700:	f00c fab6 	bl	8025c70 <sprintf>
 8019704:	4620      	mov	r0, r4
 8019706:	f005 fd04 	bl	801f112 <crs_strlen>
 801970a:	b282      	uxth	r2, r0
 801970c:	4621      	mov	r1, r4
 801970e:	200c      	movs	r0, #12
 8019710:	f005 fd7c 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8019714:	2500      	movs	r5, #0
 8019716:	f000 bcfc 	b.w	801a112 <CST_cmd+0x11f6>
 801971a:	bf00      	nop
 801971c:	08032ed4 	.word	0x08032ed4
 8019720:	20004ddc 	.word	0x20004ddc
 8019724:	08032edc 	.word	0x08032edc
 8019728:	20003cdc 	.word	0x20003cdc
 801972c:	200058b0 	.word	0x200058b0
 8019730:	2000023c 	.word	0x2000023c
 8019734:	20003b10 	.word	0x20003b10
 8019738:	20000232 	.word	0x20000232
 801973c:	20000064 	.word	0x20000064
 8019740:	08032efc 	.word	0x08032efc
 8019744:	20000058 	.word	0x20000058
 8019748:	08032f14 	.word	0x08032f14
 801974c:	20003cb0 	.word	0x20003cb0
 8019750:	20000238 	.word	0x20000238
 8019754:	08032f44 	.word	0x08032f44
 8019758:	08032f60 	.word	0x08032f60
 801975c:	08032f68 	.word	0x08032f68
 8019760:	200052dc 	.word	0x200052dc
 8019764:	08032f74 	.word	0x08032f74
 8019768:	08033524 	.word	0x08033524
 801976c:	08032f2c 	.word	0x08032f2c
                      crs_strlen(argv_p[0])) == 0)
 8019770:	4630      	mov	r0, r6
 8019772:	f005 fcce 	bl	801f112 <crs_strlen>
 8019776:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8019778:	49a6      	ldr	r1, [pc, #664]	; (8019a14 <CST_cmd+0xaf8>)
 801977a:	4630      	mov	r0, r6
 801977c:	f00c fadb 	bl	8025d36 <memcmp>
 8019780:	2800      	cmp	r0, #0
 8019782:	f040 8173 	bne.w	8019a6c <CST_cmd+0xb50>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cmd_cellular_info, sizeof(cst_cmd_cellular_info));
 8019786:	4da4      	ldr	r5, [pc, #656]	; (8019a18 <CST_cmd+0xafc>)
 8019788:	4ca4      	ldr	r4, [pc, #656]	; (8019a1c <CST_cmd+0xb00>)
 801978a:	23f4      	movs	r3, #244	; 0xf4
 801978c:	462a      	mov	r2, r5
 801978e:	49a4      	ldr	r1, [pc, #656]	; (8019a20 <CST_cmd+0xb04>)
 8019790:	8809      	ldrh	r1, [r1, #0]
 8019792:	4620      	mov	r0, r4
 8019794:	f008 f918 	bl	80219c8 <dc_com_read>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_cmd_sim_info, sizeof(cst_cmd_sim_info));
 8019798:	4fa2      	ldr	r7, [pc, #648]	; (8019a24 <CST_cmd+0xb08>)
 801979a:	2330      	movs	r3, #48	; 0x30
 801979c:	463a      	mov	r2, r7
 801979e:	49a2      	ldr	r1, [pc, #648]	; (8019a28 <CST_cmd+0xb0c>)
 80197a0:	8809      	ldrh	r1, [r1, #0]
 80197a2:	4620      	mov	r0, r4
 80197a4:	f008 f910 	bl	80219c8 <dc_com_read>
        PRINT_FORCE("Cellular Service Infos ")
 80197a8:	4ca0      	ldr	r4, [pc, #640]	; (8019a2c <CST_cmd+0xb10>)
 80197aa:	4ea1      	ldr	r6, [pc, #644]	; (8019a30 <CST_cmd+0xb14>)
 80197ac:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80197ae:	6020      	str	r0, [r4, #0]
 80197b0:	6061      	str	r1, [r4, #4]
 80197b2:	60a2      	str	r2, [r4, #8]
 80197b4:	60e3      	str	r3, [r4, #12]
 80197b6:	ce03      	ldmia	r6!, {r0, r1}
 80197b8:	6120      	str	r0, [r4, #16]
 80197ba:	6161      	str	r1, [r4, #20]
 80197bc:	8833      	ldrh	r3, [r6, #0]
 80197be:	8323      	strh	r3, [r4, #24]
 80197c0:	4620      	mov	r0, r4
 80197c2:	f005 fca6 	bl	801f112 <crs_strlen>
 80197c6:	b283      	uxth	r3, r0
 80197c8:	4622      	mov	r2, r4
 80197ca:	2101      	movs	r1, #1
 80197cc:	2007      	movs	r0, #7
 80197ce:	f005 fce3 	bl	801f198 <traceIF_itmPrint>
 80197d2:	4620      	mov	r0, r4
 80197d4:	f005 fc9d 	bl	801f112 <crs_strlen>
 80197d8:	b282      	uxth	r2, r0
 80197da:	4621      	mov	r1, r4
 80197dc:	2007      	movs	r0, #7
 80197de:	f005 fd15 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Modem state          : %d (%s)", cst_cmd_cellular_info.modem_state,
 80197e2:	7a6a      	ldrb	r2, [r5, #9]
 80197e4:	4b93      	ldr	r3, [pc, #588]	; (8019a34 <CST_cmd+0xb18>)
 80197e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80197ea:	4993      	ldr	r1, [pc, #588]	; (8019a38 <CST_cmd+0xb1c>)
 80197ec:	4620      	mov	r0, r4
 80197ee:	f00c fa3f 	bl	8025c70 <sprintf>
 80197f2:	4620      	mov	r0, r4
 80197f4:	f005 fc8d 	bl	801f112 <crs_strlen>
 80197f8:	b283      	uxth	r3, r0
 80197fa:	4622      	mov	r2, r4
 80197fc:	2101      	movs	r1, #1
 80197fe:	2007      	movs	r0, #7
 8019800:	f005 fcca 	bl	801f198 <traceIF_itmPrint>
 8019804:	4620      	mov	r0, r4
 8019806:	f005 fc84 	bl	801f112 <crs_strlen>
 801980a:	b282      	uxth	r2, r0
 801980c:	4621      	mov	r1, r4
 801980e:	2007      	movs	r0, #7
 8019810:	f005 fcfc 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Signal Quality       : %d", cst_cmd_cellular_info.cs_signal_level)
 8019814:	7aaa      	ldrb	r2, [r5, #10]
 8019816:	4989      	ldr	r1, [pc, #548]	; (8019a3c <CST_cmd+0xb20>)
 8019818:	4620      	mov	r0, r4
 801981a:	f00c fa29 	bl	8025c70 <sprintf>
 801981e:	4620      	mov	r0, r4
 8019820:	f005 fc77 	bl	801f112 <crs_strlen>
 8019824:	b283      	uxth	r3, r0
 8019826:	4622      	mov	r2, r4
 8019828:	2101      	movs	r1, #1
 801982a:	2007      	movs	r0, #7
 801982c:	f005 fcb4 	bl	801f198 <traceIF_itmPrint>
 8019830:	4620      	mov	r0, r4
 8019832:	f005 fc6e 	bl	801f112 <crs_strlen>
 8019836:	b282      	uxth	r2, r0
 8019838:	4621      	mov	r1, r4
 801983a:	2007      	movs	r0, #7
 801983c:	f005 fce6 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Signal level(dBm)    : %ld", cst_cmd_cellular_info.cs_signal_level_db)
 8019840:	68ea      	ldr	r2, [r5, #12]
 8019842:	497f      	ldr	r1, [pc, #508]	; (8019a40 <CST_cmd+0xb24>)
 8019844:	4620      	mov	r0, r4
 8019846:	f00c fa13 	bl	8025c70 <sprintf>
 801984a:	4620      	mov	r0, r4
 801984c:	f005 fc61 	bl	801f112 <crs_strlen>
 8019850:	b283      	uxth	r3, r0
 8019852:	4622      	mov	r2, r4
 8019854:	2101      	movs	r1, #1
 8019856:	2007      	movs	r0, #7
 8019858:	f005 fc9e 	bl	801f198 <traceIF_itmPrint>
 801985c:	4620      	mov	r0, r4
 801985e:	f005 fc58 	bl	801f112 <crs_strlen>
 8019862:	b282      	uxth	r2, r0
 8019864:	4621      	mov	r1, r4
 8019866:	2007      	movs	r0, #7
 8019868:	f005 fcd0 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Operator name        : %s", cst_cmd_cellular_info.mno_name)
 801986c:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8019870:	4974      	ldr	r1, [pc, #464]	; (8019a44 <CST_cmd+0xb28>)
 8019872:	4620      	mov	r0, r4
 8019874:	f00c f9fc 	bl	8025c70 <sprintf>
 8019878:	4620      	mov	r0, r4
 801987a:	f005 fc4a 	bl	801f112 <crs_strlen>
 801987e:	b283      	uxth	r3, r0
 8019880:	4622      	mov	r2, r4
 8019882:	2101      	movs	r1, #1
 8019884:	2007      	movs	r0, #7
 8019886:	f005 fc87 	bl	801f198 <traceIF_itmPrint>
 801988a:	4620      	mov	r0, r4
 801988c:	f005 fc41 	bl	801f112 <crs_strlen>
 8019890:	b282      	uxth	r2, r0
 8019892:	4621      	mov	r1, r4
 8019894:	2007      	movs	r0, #7
 8019896:	f005 fcb9 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("IMEI                 : %s", cst_cmd_cellular_info.imei)
 801989a:	f105 0210 	add.w	r2, r5, #16
 801989e:	496a      	ldr	r1, [pc, #424]	; (8019a48 <CST_cmd+0xb2c>)
 80198a0:	4620      	mov	r0, r4
 80198a2:	f00c f9e5 	bl	8025c70 <sprintf>
 80198a6:	4620      	mov	r0, r4
 80198a8:	f005 fc33 	bl	801f112 <crs_strlen>
 80198ac:	b283      	uxth	r3, r0
 80198ae:	4622      	mov	r2, r4
 80198b0:	2101      	movs	r1, #1
 80198b2:	2007      	movs	r0, #7
 80198b4:	f005 fc70 	bl	801f198 <traceIF_itmPrint>
 80198b8:	4620      	mov	r0, r4
 80198ba:	f005 fc2a 	bl	801f112 <crs_strlen>
 80198be:	b282      	uxth	r2, r0
 80198c0:	4621      	mov	r1, r4
 80198c2:	2007      	movs	r0, #7
 80198c4:	f005 fca2 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Manuf name           : %s", cst_cmd_cellular_info.manufacturer_name)
 80198c8:	f105 0250 	add.w	r2, r5, #80	; 0x50
 80198cc:	495f      	ldr	r1, [pc, #380]	; (8019a4c <CST_cmd+0xb30>)
 80198ce:	4620      	mov	r0, r4
 80198d0:	f00c f9ce 	bl	8025c70 <sprintf>
 80198d4:	4620      	mov	r0, r4
 80198d6:	f005 fc1c 	bl	801f112 <crs_strlen>
 80198da:	b283      	uxth	r3, r0
 80198dc:	4622      	mov	r2, r4
 80198de:	2101      	movs	r1, #1
 80198e0:	2007      	movs	r0, #7
 80198e2:	f005 fc59 	bl	801f198 <traceIF_itmPrint>
 80198e6:	4620      	mov	r0, r4
 80198e8:	f005 fc13 	bl	801f112 <crs_strlen>
 80198ec:	b282      	uxth	r2, r0
 80198ee:	4621      	mov	r1, r4
 80198f0:	2007      	movs	r0, #7
 80198f2:	f005 fc8b 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Model                : %s", cst_cmd_cellular_info.model)
 80198f6:	f105 0270 	add.w	r2, r5, #112	; 0x70
 80198fa:	4955      	ldr	r1, [pc, #340]	; (8019a50 <CST_cmd+0xb34>)
 80198fc:	4620      	mov	r0, r4
 80198fe:	f00c f9b7 	bl	8025c70 <sprintf>
 8019902:	4620      	mov	r0, r4
 8019904:	f005 fc05 	bl	801f112 <crs_strlen>
 8019908:	b283      	uxth	r3, r0
 801990a:	4622      	mov	r2, r4
 801990c:	2101      	movs	r1, #1
 801990e:	2007      	movs	r0, #7
 8019910:	f005 fc42 	bl	801f198 <traceIF_itmPrint>
 8019914:	4620      	mov	r0, r4
 8019916:	f005 fbfc 	bl	801f112 <crs_strlen>
 801991a:	b282      	uxth	r2, r0
 801991c:	4621      	mov	r1, r4
 801991e:	2007      	movs	r0, #7
 8019920:	f005 fc74 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Revision             : %s", cst_cmd_cellular_info.revision)
 8019924:	f105 0290 	add.w	r2, r5, #144	; 0x90
 8019928:	494a      	ldr	r1, [pc, #296]	; (8019a54 <CST_cmd+0xb38>)
 801992a:	4620      	mov	r0, r4
 801992c:	f00c f9a0 	bl	8025c70 <sprintf>
 8019930:	4620      	mov	r0, r4
 8019932:	f005 fbee 	bl	801f112 <crs_strlen>
 8019936:	b283      	uxth	r3, r0
 8019938:	4622      	mov	r2, r4
 801993a:	2101      	movs	r1, #1
 801993c:	2007      	movs	r0, #7
 801993e:	f005 fc2b 	bl	801f198 <traceIF_itmPrint>
 8019942:	4620      	mov	r0, r4
 8019944:	f005 fbe5 	bl	801f112 <crs_strlen>
 8019948:	b282      	uxth	r2, r0
 801994a:	4621      	mov	r1, r4
 801994c:	2007      	movs	r0, #7
 801994e:	f005 fc5d 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Serial Number        : %s", cst_cmd_cellular_info.serial_number)
 8019952:	f105 02b0 	add.w	r2, r5, #176	; 0xb0
 8019956:	4940      	ldr	r1, [pc, #256]	; (8019a58 <CST_cmd+0xb3c>)
 8019958:	4620      	mov	r0, r4
 801995a:	f00c f989 	bl	8025c70 <sprintf>
 801995e:	4620      	mov	r0, r4
 8019960:	f005 fbd7 	bl	801f112 <crs_strlen>
 8019964:	b283      	uxth	r3, r0
 8019966:	4622      	mov	r2, r4
 8019968:	2101      	movs	r1, #1
 801996a:	2007      	movs	r0, #7
 801996c:	f005 fc14 	bl	801f198 <traceIF_itmPrint>
 8019970:	4620      	mov	r0, r4
 8019972:	f005 fbce 	bl	801f112 <crs_strlen>
 8019976:	b282      	uxth	r2, r0
 8019978:	4621      	mov	r1, r4
 801997a:	2007      	movs	r0, #7
 801997c:	f005 fc46 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("ICCID                : %s", cst_cmd_cellular_info.iccid)
 8019980:	f105 02d0 	add.w	r2, r5, #208	; 0xd0
 8019984:	4935      	ldr	r1, [pc, #212]	; (8019a5c <CST_cmd+0xb40>)
 8019986:	4620      	mov	r0, r4
 8019988:	f00c f972 	bl	8025c70 <sprintf>
 801998c:	4620      	mov	r0, r4
 801998e:	f005 fbc0 	bl	801f112 <crs_strlen>
 8019992:	b283      	uxth	r3, r0
 8019994:	4622      	mov	r2, r4
 8019996:	2101      	movs	r1, #1
 8019998:	2007      	movs	r0, #7
 801999a:	f005 fbfd 	bl	801f198 <traceIF_itmPrint>
 801999e:	4620      	mov	r0, r4
 80199a0:	f005 fbb7 	bl	801f112 <crs_strlen>
 80199a4:	b282      	uxth	r2, r0
 80199a6:	4621      	mov	r1, r4
 80199a8:	2007      	movs	r0, #7
 80199aa:	f005 fc2f 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("IMSI                 : %s", cst_cmd_sim_info.imsi)
 80199ae:	f107 0209 	add.w	r2, r7, #9
 80199b2:	492b      	ldr	r1, [pc, #172]	; (8019a60 <CST_cmd+0xb44>)
 80199b4:	4620      	mov	r0, r4
 80199b6:	f00c f95b 	bl	8025c70 <sprintf>
 80199ba:	4620      	mov	r0, r4
 80199bc:	f005 fba9 	bl	801f112 <crs_strlen>
 80199c0:	b283      	uxth	r3, r0
 80199c2:	4622      	mov	r2, r4
 80199c4:	2101      	movs	r1, #1
 80199c6:	2007      	movs	r0, #7
 80199c8:	f005 fbe6 	bl	801f198 <traceIF_itmPrint>
 80199cc:	4620      	mov	r0, r4
 80199ce:	f005 fba0 	bl	801f112 <crs_strlen>
 80199d2:	b282      	uxth	r2, r0
 80199d4:	4621      	mov	r1, r4
 80199d6:	2007      	movs	r0, #7
 80199d8:	f005 fc18 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Network register mode: %d (%s)", cst_cmd_cellular_info.access_techno,
 80199dc:	f895 20f0 	ldrb.w	r2, [r5, #240]	; 0xf0
 80199e0:	4b20      	ldr	r3, [pc, #128]	; (8019a64 <CST_cmd+0xb48>)
 80199e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80199e6:	4920      	ldr	r1, [pc, #128]	; (8019a68 <CST_cmd+0xb4c>)
 80199e8:	4620      	mov	r0, r4
 80199ea:	f00c f941 	bl	8025c70 <sprintf>
 80199ee:	4620      	mov	r0, r4
 80199f0:	f005 fb8f 	bl	801f112 <crs_strlen>
 80199f4:	b283      	uxth	r3, r0
 80199f6:	4622      	mov	r2, r4
 80199f8:	2101      	movs	r1, #1
 80199fa:	2007      	movs	r0, #7
 80199fc:	f005 fbcc 	bl	801f198 <traceIF_itmPrint>
 8019a00:	4620      	mov	r0, r4
 8019a02:	f005 fb86 	bl	801f112 <crs_strlen>
 8019a06:	b282      	uxth	r2, r0
 8019a08:	4621      	mov	r1, r4
 8019a0a:	2007      	movs	r0, #7
 8019a0c:	f005 fbfe 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8019a10:	2500      	movs	r5, #0
 8019a12:	e37e      	b.n	801a112 <CST_cmd+0x11f6>
 8019a14:	08032f90 	.word	0x08032f90
 8019a18:	20003a1c 	.word	0x20003a1c
 8019a1c:	200058b0 	.word	0x200058b0
 8019a20:	20000236 	.word	0x20000236
 8019a24:	20003cdc 	.word	0x20003cdc
 8019a28:	2000023c 	.word	0x2000023c
 8019a2c:	20004ddc 	.word	0x20004ddc
 8019a30:	08032f98 	.word	0x08032f98
 8019a34:	08033514 	.word	0x08033514
 8019a38:	08032fb4 	.word	0x08032fb4
 8019a3c:	08032fd8 	.word	0x08032fd8
 8019a40:	08032ff4 	.word	0x08032ff4
 8019a44:	08033014 	.word	0x08033014
 8019a48:	08033030 	.word	0x08033030
 8019a4c:	0803304c 	.word	0x0803304c
 8019a50:	08033068 	.word	0x08033068
 8019a54:	08033084 	.word	0x08033084
 8019a58:	080330a0 	.word	0x080330a0
 8019a5c:	080330bc 	.word	0x080330bc
 8019a60:	080330d8 	.word	0x080330d8
 8019a64:	08033554 	.word	0x08033554
 8019a68:	080330f4 	.word	0x080330f4
                      crs_strlen(argv_p[0]))
 8019a6c:	4630      	mov	r0, r6
 8019a6e:	f005 fb50 	bl	801f112 <crs_strlen>
 8019a72:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8019a74:	49d1      	ldr	r1, [pc, #836]	; (8019dbc <CST_cmd+0xea0>)
 8019a76:	4630      	mov	r0, r6
 8019a78:	f00c f95d 	bl	8025d36 <memcmp>
 8019a7c:	2800      	cmp	r0, #0
 8019a7e:	f040 81ee 	bne.w	8019e5e <CST_cmd+0xf42>
        PRINT_FORCE("Cellular Service Task Config")
 8019a82:	4ccf      	ldr	r4, [pc, #828]	; (8019dc0 <CST_cmd+0xea4>)
 8019a84:	4dcf      	ldr	r5, [pc, #828]	; (8019dc4 <CST_cmd+0xea8>)
 8019a86:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019a88:	6020      	str	r0, [r4, #0]
 8019a8a:	6061      	str	r1, [r4, #4]
 8019a8c:	60a2      	str	r2, [r4, #8]
 8019a8e:	60e3      	str	r3, [r4, #12]
 8019a90:	cd07      	ldmia	r5!, {r0, r1, r2}
 8019a92:	6120      	str	r0, [r4, #16]
 8019a94:	6161      	str	r1, [r4, #20]
 8019a96:	61a2      	str	r2, [r4, #24]
 8019a98:	882a      	ldrh	r2, [r5, #0]
 8019a9a:	78ab      	ldrb	r3, [r5, #2]
 8019a9c:	83a2      	strh	r2, [r4, #28]
 8019a9e:	77a3      	strb	r3, [r4, #30]
 8019aa0:	4620      	mov	r0, r4
 8019aa2:	f005 fb36 	bl	801f112 <crs_strlen>
 8019aa6:	b283      	uxth	r3, r0
 8019aa8:	4622      	mov	r2, r4
 8019aaa:	2101      	movs	r1, #1
 8019aac:	2007      	movs	r0, #7
 8019aae:	f005 fb73 	bl	801f198 <traceIF_itmPrint>
 8019ab2:	4620      	mov	r0, r4
 8019ab4:	f005 fb2d 	bl	801f112 <crs_strlen>
 8019ab8:	b282      	uxth	r2, r0
 8019aba:	4621      	mov	r1, r4
 8019abc:	2007      	movs	r0, #7
 8019abe:	f005 fba5 	bl	801f20c <traceIF_uartPrintForce>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 8019ac2:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 8019ac6:	4ac0      	ldr	r2, [pc, #768]	; (8019dc8 <CST_cmd+0xeac>)
 8019ac8:	49c0      	ldr	r1, [pc, #768]	; (8019dcc <CST_cmd+0xeb0>)
 8019aca:	8809      	ldrh	r1, [r1, #0]
 8019acc:	48c0      	ldr	r0, [pc, #768]	; (8019dd0 <CST_cmd+0xeb4>)
 8019ace:	f007 ff7b 	bl	80219c8 <dc_com_read>
        for (i = 0 ; i < cst_cmd_cellular_params.sim_slot_nb ; i++)
 8019ad2:	2700      	movs	r7, #0
 8019ad4:	4bbc      	ldr	r3, [pc, #752]	; (8019dc8 <CST_cmd+0xeac>)
 8019ad6:	7a9b      	ldrb	r3, [r3, #10]
 8019ad8:	42bb      	cmp	r3, r7
 8019ada:	f240 8085 	bls.w	8019be8 <CST_cmd+0xccc>
          PRINT_FORCE("Sim Slot             : %ld (%s)", i,
 8019ade:	4eba      	ldr	r6, [pc, #744]	; (8019dc8 <CST_cmd+0xeac>)
 8019ae0:	2562      	movs	r5, #98	; 0x62
 8019ae2:	fb07 f505 	mul.w	r5, r7, r5
 8019ae6:	eb06 0805 	add.w	r8, r6, r5
 8019aea:	f898 200b 	ldrb.w	r2, [r8, #11]
 8019aee:	4cb4      	ldr	r4, [pc, #720]	; (8019dc0 <CST_cmd+0xea4>)
 8019af0:	4bb8      	ldr	r3, [pc, #736]	; (8019dd4 <CST_cmd+0xeb8>)
 8019af2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019af6:	463a      	mov	r2, r7
 8019af8:	49b7      	ldr	r1, [pc, #732]	; (8019dd8 <CST_cmd+0xebc>)
 8019afa:	4620      	mov	r0, r4
 8019afc:	f00c f8b8 	bl	8025c70 <sprintf>
 8019b00:	4620      	mov	r0, r4
 8019b02:	f005 fb06 	bl	801f112 <crs_strlen>
 8019b06:	b283      	uxth	r3, r0
 8019b08:	4622      	mov	r2, r4
 8019b0a:	2101      	movs	r1, #1
 8019b0c:	2007      	movs	r0, #7
 8019b0e:	f005 fb43 	bl	801f198 <traceIF_itmPrint>
 8019b12:	4620      	mov	r0, r4
 8019b14:	f005 fafd 	bl	801f112 <crs_strlen>
 8019b18:	b282      	uxth	r2, r0
 8019b1a:	4621      	mov	r1, r4
 8019b1c:	2007      	movs	r0, #7
 8019b1e:	f005 fb75 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("APN                  : \"%s\"", cst_cmd_cellular_params.sim_slot[i].apn)
 8019b22:	f105 0208 	add.w	r2, r5, #8
 8019b26:	4432      	add	r2, r6
 8019b28:	3204      	adds	r2, #4
 8019b2a:	49ac      	ldr	r1, [pc, #688]	; (8019ddc <CST_cmd+0xec0>)
 8019b2c:	4620      	mov	r0, r4
 8019b2e:	f00c f89f 	bl	8025c70 <sprintf>
 8019b32:	4620      	mov	r0, r4
 8019b34:	f005 faed 	bl	801f112 <crs_strlen>
 8019b38:	b283      	uxth	r3, r0
 8019b3a:	4622      	mov	r2, r4
 8019b3c:	2101      	movs	r1, #1
 8019b3e:	2007      	movs	r0, #7
 8019b40:	f005 fb2a 	bl	801f198 <traceIF_itmPrint>
 8019b44:	4620      	mov	r0, r4
 8019b46:	f005 fae4 	bl	801f112 <crs_strlen>
 8019b4a:	b282      	uxth	r2, r0
 8019b4c:	4621      	mov	r1, r4
 8019b4e:	2007      	movs	r0, #7
 8019b50:	f005 fb5c 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("CID                  : %d", cst_cmd_cellular_params.sim_slot[i].cid)
 8019b54:	f898 202c 	ldrb.w	r2, [r8, #44]	; 0x2c
 8019b58:	49a1      	ldr	r1, [pc, #644]	; (8019de0 <CST_cmd+0xec4>)
 8019b5a:	4620      	mov	r0, r4
 8019b5c:	f00c f888 	bl	8025c70 <sprintf>
 8019b60:	4620      	mov	r0, r4
 8019b62:	f005 fad6 	bl	801f112 <crs_strlen>
 8019b66:	b283      	uxth	r3, r0
 8019b68:	4622      	mov	r2, r4
 8019b6a:	2101      	movs	r1, #1
 8019b6c:	2007      	movs	r0, #7
 8019b6e:	f005 fb13 	bl	801f198 <traceIF_itmPrint>
 8019b72:	4620      	mov	r0, r4
 8019b74:	f005 facd 	bl	801f112 <crs_strlen>
 8019b78:	b282      	uxth	r2, r0
 8019b7a:	4621      	mov	r1, r4
 8019b7c:	2007      	movs	r0, #7
 8019b7e:	f005 fb45 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("username             : %s", cst_cmd_cellular_params.sim_slot[i].username)
 8019b82:	f105 0228 	add.w	r2, r5, #40	; 0x28
 8019b86:	4432      	add	r2, r6
 8019b88:	3205      	adds	r2, #5
 8019b8a:	4996      	ldr	r1, [pc, #600]	; (8019de4 <CST_cmd+0xec8>)
 8019b8c:	4620      	mov	r0, r4
 8019b8e:	f00c f86f 	bl	8025c70 <sprintf>
 8019b92:	4620      	mov	r0, r4
 8019b94:	f005 fabd 	bl	801f112 <crs_strlen>
 8019b98:	b283      	uxth	r3, r0
 8019b9a:	4622      	mov	r2, r4
 8019b9c:	2101      	movs	r1, #1
 8019b9e:	2007      	movs	r0, #7
 8019ba0:	f005 fafa 	bl	801f198 <traceIF_itmPrint>
 8019ba4:	4620      	mov	r0, r4
 8019ba6:	f005 fab4 	bl	801f112 <crs_strlen>
 8019baa:	b282      	uxth	r2, r0
 8019bac:	4621      	mov	r1, r4
 8019bae:	2007      	movs	r0, #7
 8019bb0:	f005 fb2c 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("password             : %s", cst_cmd_cellular_params.sim_slot[i].password)
 8019bb4:	3548      	adds	r5, #72	; 0x48
 8019bb6:	1972      	adds	r2, r6, r5
 8019bb8:	3205      	adds	r2, #5
 8019bba:	498b      	ldr	r1, [pc, #556]	; (8019de8 <CST_cmd+0xecc>)
 8019bbc:	4620      	mov	r0, r4
 8019bbe:	f00c f857 	bl	8025c70 <sprintf>
 8019bc2:	4620      	mov	r0, r4
 8019bc4:	f005 faa5 	bl	801f112 <crs_strlen>
 8019bc8:	b283      	uxth	r3, r0
 8019bca:	4622      	mov	r2, r4
 8019bcc:	2101      	movs	r1, #1
 8019bce:	2007      	movs	r0, #7
 8019bd0:	f005 fae2 	bl	801f198 <traceIF_itmPrint>
 8019bd4:	4620      	mov	r0, r4
 8019bd6:	f005 fa9c 	bl	801f112 <crs_strlen>
 8019bda:	b282      	uxth	r2, r0
 8019bdc:	4621      	mov	r1, r4
 8019bde:	2007      	movs	r0, #7
 8019be0:	f005 fb14 	bl	801f20c <traceIF_uartPrintForce>
        for (i = 0 ; i < cst_cmd_cellular_params.sim_slot_nb ; i++)
 8019be4:	3701      	adds	r7, #1
 8019be6:	e775      	b.n	8019ad4 <CST_cmd+0xbb8>
        PRINT_FORCE("Target state         : %s", CST_TargetStateName_p[cst_cmd_cellular_params.target_state])
 8019be8:	4d77      	ldr	r5, [pc, #476]	; (8019dc8 <CST_cmd+0xeac>)
 8019bea:	f895 2131 	ldrb.w	r2, [r5, #305]	; 0x131
 8019bee:	4c74      	ldr	r4, [pc, #464]	; (8019dc0 <CST_cmd+0xea4>)
 8019bf0:	4b7e      	ldr	r3, [pc, #504]	; (8019dec <CST_cmd+0xed0>)
 8019bf2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019bf6:	497e      	ldr	r1, [pc, #504]	; (8019df0 <CST_cmd+0xed4>)
 8019bf8:	4620      	mov	r0, r4
 8019bfa:	f00c f839 	bl	8025c70 <sprintf>
 8019bfe:	4620      	mov	r0, r4
 8019c00:	f005 fa87 	bl	801f112 <crs_strlen>
 8019c04:	b283      	uxth	r3, r0
 8019c06:	4622      	mov	r2, r4
 8019c08:	2101      	movs	r1, #1
 8019c0a:	2007      	movs	r0, #7
 8019c0c:	f005 fac4 	bl	801f198 <traceIF_itmPrint>
 8019c10:	4620      	mov	r0, r4
 8019c12:	f005 fa7e 	bl	801f112 <crs_strlen>
 8019c16:	b282      	uxth	r2, r0
 8019c18:	4621      	mov	r1, r4
 8019c1a:	2007      	movs	r0, #7
 8019c1c:	f005 faf6 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("Attachment timeout   : %ld ms", cst_cmd_cellular_params.attachment_timeout)
 8019c20:	f8d5 2134 	ldr.w	r2, [r5, #308]	; 0x134
 8019c24:	4973      	ldr	r1, [pc, #460]	; (8019df4 <CST_cmd+0xed8>)
 8019c26:	4620      	mov	r0, r4
 8019c28:	f00c f822 	bl	8025c70 <sprintf>
 8019c2c:	4620      	mov	r0, r4
 8019c2e:	f005 fa70 	bl	801f112 <crs_strlen>
 8019c32:	b283      	uxth	r3, r0
 8019c34:	4622      	mov	r2, r4
 8019c36:	2101      	movs	r1, #1
 8019c38:	2007      	movs	r0, #7
 8019c3a:	f005 faad 	bl	801f198 <traceIF_itmPrint>
 8019c3e:	4620      	mov	r0, r4
 8019c40:	f005 fa67 	bl	801f112 <crs_strlen>
 8019c44:	b282      	uxth	r2, r0
 8019c46:	4621      	mov	r1, r4
 8019c48:	2007      	movs	r0, #7
 8019c4a:	f005 fadf 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("nfmc mode            : %s", CST_ActivateName_p[cst_cmd_cellular_params.nfmc_active])
 8019c4e:	f895 217c 	ldrb.w	r2, [r5, #380]	; 0x17c
 8019c52:	4b69      	ldr	r3, [pc, #420]	; (8019df8 <CST_cmd+0xedc>)
 8019c54:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019c58:	4968      	ldr	r1, [pc, #416]	; (8019dfc <CST_cmd+0xee0>)
 8019c5a:	4620      	mov	r0, r4
 8019c5c:	f00c f808 	bl	8025c70 <sprintf>
 8019c60:	4620      	mov	r0, r4
 8019c62:	f005 fa56 	bl	801f112 <crs_strlen>
 8019c66:	b283      	uxth	r3, r0
 8019c68:	4622      	mov	r2, r4
 8019c6a:	2101      	movs	r1, #1
 8019c6c:	2007      	movs	r0, #7
 8019c6e:	f005 fa93 	bl	801f198 <traceIF_itmPrint>
 8019c72:	4620      	mov	r0, r4
 8019c74:	f005 fa4d 	bl	801f112 <crs_strlen>
 8019c78:	b282      	uxth	r2, r0
 8019c7a:	4621      	mov	r1, r4
 8019c7c:	2007      	movs	r0, #7
 8019c7e:	f005 fac5 	bl	801f20c <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.nfmc_active != 0U)
 8019c82:	f895 317c 	ldrb.w	r3, [r5, #380]	; 0x17c
 8019c86:	2b00      	cmp	r3, #0
 8019c88:	d164      	bne.n	8019d54 <CST_cmd+0xe38>
        PRINT_FORCE("Network register mode: %d = %s", cst_cmd_cellular_params.operator_selector.network_reg_mode,
 8019c8a:	4d4f      	ldr	r5, [pc, #316]	; (8019dc8 <CST_cmd+0xeac>)
 8019c8c:	f895 2138 	ldrb.w	r2, [r5, #312]	; 0x138
 8019c90:	4c4b      	ldr	r4, [pc, #300]	; (8019dc0 <CST_cmd+0xea4>)
 8019c92:	4b5b      	ldr	r3, [pc, #364]	; (8019e00 <CST_cmd+0xee4>)
 8019c94:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019c98:	495a      	ldr	r1, [pc, #360]	; (8019e04 <CST_cmd+0xee8>)
 8019c9a:	4620      	mov	r0, r4
 8019c9c:	f00b ffe8 	bl	8025c70 <sprintf>
 8019ca0:	4620      	mov	r0, r4
 8019ca2:	f005 fa36 	bl	801f112 <crs_strlen>
 8019ca6:	b283      	uxth	r3, r0
 8019ca8:	4622      	mov	r2, r4
 8019caa:	2101      	movs	r1, #1
 8019cac:	2007      	movs	r0, #7
 8019cae:	f005 fa73 	bl	801f198 <traceIF_itmPrint>
 8019cb2:	4620      	mov	r0, r4
 8019cb4:	f005 fa2d 	bl	801f112 <crs_strlen>
 8019cb8:	b282      	uxth	r2, r0
 8019cba:	4621      	mov	r1, r4
 8019cbc:	2007      	movs	r0, #7
 8019cbe:	f005 faa5 	bl	801f20c <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.operator_selector.network_reg_mode != DC_NRM_AUTO)
 8019cc2:	f895 3138 	ldrb.w	r3, [r5, #312]	; 0x138
 8019cc6:	2b00      	cmp	r3, #0
 8019cc8:	d146      	bne.n	8019d58 <CST_cmd+0xe3c>
        PRINT_FORCE("Access techno present: %s",
 8019cca:	4b3f      	ldr	r3, [pc, #252]	; (8019dc8 <CST_cmd+0xeac>)
 8019ccc:	f893 317a 	ldrb.w	r3, [r3, #378]	; 0x17a
 8019cd0:	2b00      	cmp	r3, #0
 8019cd2:	f000 80a5 	beq.w	8019e20 <CST_cmd+0xf04>
 8019cd6:	4a4c      	ldr	r2, [pc, #304]	; (8019e08 <CST_cmd+0xeec>)
 8019cd8:	4c39      	ldr	r4, [pc, #228]	; (8019dc0 <CST_cmd+0xea4>)
 8019cda:	494c      	ldr	r1, [pc, #304]	; (8019e0c <CST_cmd+0xef0>)
 8019cdc:	4620      	mov	r0, r4
 8019cde:	f00b ffc7 	bl	8025c70 <sprintf>
 8019ce2:	4620      	mov	r0, r4
 8019ce4:	f005 fa15 	bl	801f112 <crs_strlen>
 8019ce8:	b283      	uxth	r3, r0
 8019cea:	4622      	mov	r2, r4
 8019cec:	2101      	movs	r1, #1
 8019cee:	2007      	movs	r0, #7
 8019cf0:	f005 fa52 	bl	801f198 <traceIF_itmPrint>
 8019cf4:	4620      	mov	r0, r4
 8019cf6:	f005 fa0c 	bl	801f112 <crs_strlen>
 8019cfa:	b282      	uxth	r2, r0
 8019cfc:	4621      	mov	r1, r4
 8019cfe:	2007      	movs	r0, #7
 8019d00:	f005 fa84 	bl	801f20c <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.operator_selector.access_techno_present != DC_ACT_PRESENT_FALSE)
 8019d04:	4b30      	ldr	r3, [pc, #192]	; (8019dc8 <CST_cmd+0xeac>)
 8019d06:	f893 317a 	ldrb.w	r3, [r3, #378]	; 0x17a
 8019d0a:	2b00      	cmp	r3, #0
 8019d0c:	f040 808a 	bne.w	8019e24 <CST_cmd+0xf08>
  cmd_status = CMD_OK;
 8019d10:	2500      	movs	r5, #0
 8019d12:	e1fe      	b.n	801a112 <CST_cmd+0x11f6>
            PRINT_FORCE("nfmc value %ld       : %ld", i + 1U, cst_cmd_cellular_params.nfmc_value[i])
 8019d14:	1c5d      	adds	r5, r3, #1
 8019d16:	3360      	adds	r3, #96	; 0x60
 8019d18:	4c29      	ldr	r4, [pc, #164]	; (8019dc0 <CST_cmd+0xea4>)
 8019d1a:	4a2b      	ldr	r2, [pc, #172]	; (8019dc8 <CST_cmd+0xeac>)
 8019d1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019d20:	462a      	mov	r2, r5
 8019d22:	493b      	ldr	r1, [pc, #236]	; (8019e10 <CST_cmd+0xef4>)
 8019d24:	4620      	mov	r0, r4
 8019d26:	f00b ffa3 	bl	8025c70 <sprintf>
 8019d2a:	4620      	mov	r0, r4
 8019d2c:	f005 f9f1 	bl	801f112 <crs_strlen>
 8019d30:	b283      	uxth	r3, r0
 8019d32:	4622      	mov	r2, r4
 8019d34:	2101      	movs	r1, #1
 8019d36:	2007      	movs	r0, #7
 8019d38:	f005 fa2e 	bl	801f198 <traceIF_itmPrint>
 8019d3c:	4620      	mov	r0, r4
 8019d3e:	f005 f9e8 	bl	801f112 <crs_strlen>
 8019d42:	b282      	uxth	r2, r0
 8019d44:	4621      	mov	r1, r4
 8019d46:	2007      	movs	r0, #7
 8019d48:	f005 fa60 	bl	801f20c <traceIF_uartPrintForce>
          for (i = 0U; i < DC_NFMC_TEMPO_NB ; i++)
 8019d4c:	462b      	mov	r3, r5
 8019d4e:	2b06      	cmp	r3, #6
 8019d50:	d9e0      	bls.n	8019d14 <CST_cmd+0xdf8>
 8019d52:	e79a      	b.n	8019c8a <CST_cmd+0xd6e>
 8019d54:	2300      	movs	r3, #0
 8019d56:	e7fa      	b.n	8019d4e <CST_cmd+0xe32>
          PRINT_FORCE("Operator name format: %d (%s)",
 8019d58:	f895 2139 	ldrb.w	r2, [r5, #313]	; 0x139
 8019d5c:	4b2d      	ldr	r3, [pc, #180]	; (8019e14 <CST_cmd+0xef8>)
 8019d5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019d62:	492d      	ldr	r1, [pc, #180]	; (8019e18 <CST_cmd+0xefc>)
 8019d64:	4620      	mov	r0, r4
 8019d66:	f00b ff83 	bl	8025c70 <sprintf>
 8019d6a:	4620      	mov	r0, r4
 8019d6c:	f005 f9d1 	bl	801f112 <crs_strlen>
 8019d70:	b283      	uxth	r3, r0
 8019d72:	4622      	mov	r2, r4
 8019d74:	2101      	movs	r1, #1
 8019d76:	2007      	movs	r0, #7
 8019d78:	f005 fa0e 	bl	801f198 <traceIF_itmPrint>
 8019d7c:	4620      	mov	r0, r4
 8019d7e:	f005 f9c8 	bl	801f112 <crs_strlen>
 8019d82:	b282      	uxth	r2, r0
 8019d84:	4621      	mov	r1, r4
 8019d86:	2007      	movs	r0, #7
 8019d88:	f005 fa40 	bl	801f20c <traceIF_uartPrintForce>
          PRINT_FORCE("Operator name: %s\n\r", cst_cmd_cellular_params.operator_selector.operator_name);
 8019d8c:	f505 729d 	add.w	r2, r5, #314	; 0x13a
 8019d90:	4922      	ldr	r1, [pc, #136]	; (8019e1c <CST_cmd+0xf00>)
 8019d92:	4620      	mov	r0, r4
 8019d94:	f00b ff6c 	bl	8025c70 <sprintf>
 8019d98:	4620      	mov	r0, r4
 8019d9a:	f005 f9ba 	bl	801f112 <crs_strlen>
 8019d9e:	b283      	uxth	r3, r0
 8019da0:	4622      	mov	r2, r4
 8019da2:	2101      	movs	r1, #1
 8019da4:	2007      	movs	r0, #7
 8019da6:	f005 f9f7 	bl	801f198 <traceIF_itmPrint>
 8019daa:	4620      	mov	r0, r4
 8019dac:	f005 f9b1 	bl	801f112 <crs_strlen>
 8019db0:	b282      	uxth	r2, r0
 8019db2:	4621      	mov	r1, r4
 8019db4:	2007      	movs	r0, #7
 8019db6:	f005 fa29 	bl	801f20c <traceIF_uartPrintForce>
 8019dba:	e786      	b.n	8019cca <CST_cmd+0xdae>
 8019dbc:	08032b50 	.word	0x08032b50
 8019dc0:	20004ddc 	.word	0x20004ddc
 8019dc4:	08033118 	.word	0x08033118
 8019dc8:	20003b10 	.word	0x20003b10
 8019dcc:	20000232 	.word	0x20000232
 8019dd0:	200058b0 	.word	0x200058b0
 8019dd4:	20000058 	.word	0x20000058
 8019dd8:	08033138 	.word	0x08033138
 8019ddc:	0803315c 	.word	0x0803315c
 8019de0:	0803317c 	.word	0x0803317c
 8019de4:	08033198 	.word	0x08033198
 8019de8:	080331b4 	.word	0x080331b4
 8019dec:	08033548 	.word	0x08033548
 8019df0:	080331d0 	.word	0x080331d0
 8019df4:	080331ec 	.word	0x080331ec
 8019df8:	0803350c 	.word	0x0803350c
 8019dfc:	0803320c 	.word	0x0803320c
 8019e00:	0803357c 	.word	0x0803357c
 8019e04:	08033248 	.word	0x08033248
 8019e08:	08032d6c 	.word	0x08032d6c
 8019e0c:	080332a4 	.word	0x080332a4
 8019e10:	08033228 	.word	0x08033228
 8019e14:	0803358c 	.word	0x0803358c
 8019e18:	0803326c 	.word	0x0803326c
 8019e1c:	0803328c 	.word	0x0803328c
        PRINT_FORCE("Access techno present: %s",
 8019e20:	4abe      	ldr	r2, [pc, #760]	; (801a11c <CST_cmd+0x1200>)
 8019e22:	e759      	b.n	8019cd8 <CST_cmd+0xdbc>
          PRINT_FORCE("Network register mode: %d (%s)", cst_cmd_cellular_params.operator_selector.access_techno,
 8019e24:	4bbe      	ldr	r3, [pc, #760]	; (801a120 <CST_cmd+0x1204>)
 8019e26:	f893 217b 	ldrb.w	r2, [r3, #379]	; 0x17b
 8019e2a:	4bbe      	ldr	r3, [pc, #760]	; (801a124 <CST_cmd+0x1208>)
 8019e2c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019e30:	49bd      	ldr	r1, [pc, #756]	; (801a128 <CST_cmd+0x120c>)
 8019e32:	4620      	mov	r0, r4
 8019e34:	f00b ff1c 	bl	8025c70 <sprintf>
 8019e38:	4620      	mov	r0, r4
 8019e3a:	f005 f96a 	bl	801f112 <crs_strlen>
 8019e3e:	b283      	uxth	r3, r0
 8019e40:	4622      	mov	r2, r4
 8019e42:	2101      	movs	r1, #1
 8019e44:	2007      	movs	r0, #7
 8019e46:	f005 f9a7 	bl	801f198 <traceIF_itmPrint>
 8019e4a:	4620      	mov	r0, r4
 8019e4c:	f005 f961 	bl	801f112 <crs_strlen>
 8019e50:	b282      	uxth	r2, r0
 8019e52:	4621      	mov	r1, r4
 8019e54:	2007      	movs	r0, #7
 8019e56:	f005 f9d9 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8019e5a:	2500      	movs	r5, #0
 8019e5c:	e159      	b.n	801a112 <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "power", crs_strlen(argv_p[0])) == 0)
 8019e5e:	4630      	mov	r0, r6
 8019e60:	f005 f957 	bl	801f112 <crs_strlen>
 8019e64:	4602      	mov	r2, r0
 8019e66:	49b1      	ldr	r1, [pc, #708]	; (801a12c <CST_cmd+0x1210>)
 8019e68:	4630      	mov	r0, r6
 8019e6a:	f00b ff64 	bl	8025d36 <memcmp>
 8019e6e:	2800      	cmp	r0, #0
 8019e70:	f040 8090 	bne.w	8019f94 <CST_cmd+0x1078>
        if (argc == 2U)
 8019e74:	2c02      	cmp	r4, #2
 8019e76:	d001      	beq.n	8019e7c <CST_cmd+0xf60>
  cmd_status = CMD_OK;
 8019e78:	2500      	movs	r5, #0
 8019e7a:	e14a      	b.n	801a112 <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "on", crs_strlen(argv_p[1])) == 0)
 8019e7c:	9c02      	ldr	r4, [sp, #8]
 8019e7e:	4620      	mov	r0, r4
 8019e80:	f005 f947 	bl	801f112 <crs_strlen>
 8019e84:	4602      	mov	r2, r0
 8019e86:	49aa      	ldr	r1, [pc, #680]	; (801a130 <CST_cmd+0x1214>)
 8019e88:	4620      	mov	r0, r4
 8019e8a:	f00b ff54 	bl	8025d36 <memcmp>
 8019e8e:	2800      	cmp	r0, #0
 8019e90:	d13a      	bne.n	8019f08 <CST_cmd+0xfec>
            PRINT_FORCE("modem power ON")
 8019e92:	4ca8      	ldr	r4, [pc, #672]	; (801a134 <CST_cmd+0x1218>)
 8019e94:	4da8      	ldr	r5, [pc, #672]	; (801a138 <CST_cmd+0x121c>)
 8019e96:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019e98:	6020      	str	r0, [r4, #0]
 8019e9a:	6061      	str	r1, [r4, #4]
 8019e9c:	60a2      	str	r2, [r4, #8]
 8019e9e:	60e3      	str	r3, [r4, #12]
 8019ea0:	782b      	ldrb	r3, [r5, #0]
 8019ea2:	7423      	strb	r3, [r4, #16]
 8019ea4:	4620      	mov	r0, r4
 8019ea6:	f005 f934 	bl	801f112 <crs_strlen>
 8019eaa:	b283      	uxth	r3, r0
 8019eac:	4622      	mov	r2, r4
 8019eae:	2101      	movs	r1, #1
 8019eb0:	2007      	movs	r0, #7
 8019eb2:	f005 f971 	bl	801f198 <traceIF_itmPrint>
 8019eb6:	4620      	mov	r0, r4
 8019eb8:	f005 f92b 	bl	801f112 <crs_strlen>
 8019ebc:	b282      	uxth	r2, r0
 8019ebe:	4621      	mov	r1, r4
 8019ec0:	2007      	movs	r0, #7
 8019ec2:	f005 f9a3 	bl	801f20c <traceIF_uartPrintForce>
            if (osCDS_power_on() != CELLULAR_OK)
 8019ec6:	f000 fdb9 	bl	801aa3c <osCDS_power_on>
 8019eca:	4605      	mov	r5, r0
 8019ecc:	2800      	cmp	r0, #0
 8019ece:	f000 8120 	beq.w	801a112 <CST_cmd+0x11f6>
              PRINT_FORCE("command fail\n\r")
 8019ed2:	4d9a      	ldr	r5, [pc, #616]	; (801a13c <CST_cmd+0x1220>)
 8019ed4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019ed6:	6020      	str	r0, [r4, #0]
 8019ed8:	6061      	str	r1, [r4, #4]
 8019eda:	60a2      	str	r2, [r4, #8]
 8019edc:	60e3      	str	r3, [r4, #12]
 8019ede:	782b      	ldrb	r3, [r5, #0]
 8019ee0:	7423      	strb	r3, [r4, #16]
 8019ee2:	4620      	mov	r0, r4
 8019ee4:	f005 f915 	bl	801f112 <crs_strlen>
 8019ee8:	b283      	uxth	r3, r0
 8019eea:	4622      	mov	r2, r4
 8019eec:	2101      	movs	r1, #1
 8019eee:	2007      	movs	r0, #7
 8019ef0:	f005 f952 	bl	801f198 <traceIF_itmPrint>
 8019ef4:	4620      	mov	r0, r4
 8019ef6:	f005 f90c 	bl	801f112 <crs_strlen>
 8019efa:	b282      	uxth	r2, r0
 8019efc:	4621      	mov	r1, r4
 8019efe:	2007      	movs	r0, #7
 8019f00:	f005 f984 	bl	801f20c <traceIF_uartPrintForce>
              cmd_status = CMD_PROCESS_ERROR;
 8019f04:	2502      	movs	r5, #2
 8019f06:	e104      	b.n	801a112 <CST_cmd+0x11f6>
          else if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 8019f08:	4620      	mov	r0, r4
 8019f0a:	f005 f902 	bl	801f112 <crs_strlen>
 8019f0e:	4602      	mov	r2, r0
 8019f10:	498b      	ldr	r1, [pc, #556]	; (801a140 <CST_cmd+0x1224>)
 8019f12:	4620      	mov	r0, r4
 8019f14:	f00b ff0f 	bl	8025d36 <memcmp>
 8019f18:	b108      	cbz	r0, 8019f1e <CST_cmd+0x1002>
  cmd_status = CMD_OK;
 8019f1a:	2500      	movs	r5, #0
 8019f1c:	e0f9      	b.n	801a112 <CST_cmd+0x11f6>
            PRINT_FORCE("modem power OFF")
 8019f1e:	4c85      	ldr	r4, [pc, #532]	; (801a134 <CST_cmd+0x1218>)
 8019f20:	4d88      	ldr	r5, [pc, #544]	; (801a144 <CST_cmd+0x1228>)
 8019f22:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019f24:	6020      	str	r0, [r4, #0]
 8019f26:	6061      	str	r1, [r4, #4]
 8019f28:	60a2      	str	r2, [r4, #8]
 8019f2a:	60e3      	str	r3, [r4, #12]
 8019f2c:	882b      	ldrh	r3, [r5, #0]
 8019f2e:	8223      	strh	r3, [r4, #16]
 8019f30:	4620      	mov	r0, r4
 8019f32:	f005 f8ee 	bl	801f112 <crs_strlen>
 8019f36:	b283      	uxth	r3, r0
 8019f38:	4622      	mov	r2, r4
 8019f3a:	2101      	movs	r1, #1
 8019f3c:	2007      	movs	r0, #7
 8019f3e:	f005 f92b 	bl	801f198 <traceIF_itmPrint>
 8019f42:	4620      	mov	r0, r4
 8019f44:	f005 f8e5 	bl	801f112 <crs_strlen>
 8019f48:	b282      	uxth	r2, r0
 8019f4a:	4621      	mov	r1, r4
 8019f4c:	2007      	movs	r0, #7
 8019f4e:	f005 f95d 	bl	801f20c <traceIF_uartPrintForce>
            if (osCDS_power_off() != CELLULAR_OK)
 8019f52:	f000 fd85 	bl	801aa60 <osCDS_power_off>
 8019f56:	4605      	mov	r5, r0
 8019f58:	2800      	cmp	r0, #0
 8019f5a:	f000 80da 	beq.w	801a112 <CST_cmd+0x11f6>
              PRINT_FORCE("command fail\n\r")
 8019f5e:	4d77      	ldr	r5, [pc, #476]	; (801a13c <CST_cmd+0x1220>)
 8019f60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019f62:	6020      	str	r0, [r4, #0]
 8019f64:	6061      	str	r1, [r4, #4]
 8019f66:	60a2      	str	r2, [r4, #8]
 8019f68:	60e3      	str	r3, [r4, #12]
 8019f6a:	782b      	ldrb	r3, [r5, #0]
 8019f6c:	7423      	strb	r3, [r4, #16]
 8019f6e:	4620      	mov	r0, r4
 8019f70:	f005 f8cf 	bl	801f112 <crs_strlen>
 8019f74:	b283      	uxth	r3, r0
 8019f76:	4622      	mov	r2, r4
 8019f78:	2101      	movs	r1, #1
 8019f7a:	2007      	movs	r0, #7
 8019f7c:	f005 f90c 	bl	801f198 <traceIF_itmPrint>
 8019f80:	4620      	mov	r0, r4
 8019f82:	f005 f8c6 	bl	801f112 <crs_strlen>
 8019f86:	b282      	uxth	r2, r0
 8019f88:	4621      	mov	r1, r4
 8019f8a:	2007      	movs	r0, #7
 8019f8c:	f005 f93e 	bl	801f20c <traceIF_uartPrintForce>
              cmd_status = CMD_PROCESS_ERROR;
 8019f90:	2502      	movs	r5, #2
 8019f92:	e0be      	b.n	801a112 <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "techno", crs_strlen(argv_p[0])) == 0)
 8019f94:	4630      	mov	r0, r6
 8019f96:	f005 f8bc 	bl	801f112 <crs_strlen>
 8019f9a:	4602      	mov	r2, r0
 8019f9c:	496a      	ldr	r1, [pc, #424]	; (801a148 <CST_cmd+0x122c>)
 8019f9e:	4630      	mov	r0, r6
 8019fa0:	f00b fec9 	bl	8025d36 <memcmp>
 8019fa4:	2800      	cmp	r0, #0
 8019fa6:	d178      	bne.n	801a09a <CST_cmd+0x117e>
        if (argc == 3U)
 8019fa8:	2c03      	cmp	r4, #3
 8019faa:	d01c      	beq.n	8019fe6 <CST_cmd+0x10ca>
        else if (argc == 2U)
 8019fac:	2c02      	cmp	r4, #2
 8019fae:	d05c      	beq.n	801a06a <CST_cmd+0x114e>
          PRINT_FORCE("%s bad command. Usage:", cmd_p)
 8019fb0:	4c60      	ldr	r4, [pc, #384]	; (801a134 <CST_cmd+0x1218>)
 8019fb2:	462a      	mov	r2, r5
 8019fb4:	4965      	ldr	r1, [pc, #404]	; (801a14c <CST_cmd+0x1230>)
 8019fb6:	4620      	mov	r0, r4
 8019fb8:	f00b fe5a 	bl	8025c70 <sprintf>
 8019fbc:	4620      	mov	r0, r4
 8019fbe:	f005 f8a8 	bl	801f112 <crs_strlen>
 8019fc2:	b283      	uxth	r3, r0
 8019fc4:	4622      	mov	r2, r4
 8019fc6:	2101      	movs	r1, #1
 8019fc8:	2007      	movs	r0, #7
 8019fca:	f005 f8e5 	bl	801f198 <traceIF_itmPrint>
 8019fce:	4620      	mov	r0, r4
 8019fd0:	f005 f89f 	bl	801f112 <crs_strlen>
 8019fd4:	b282      	uxth	r2, r0
 8019fd6:	4621      	mov	r1, r4
 8019fd8:	2007      	movs	r0, #7
 8019fda:	f005 f917 	bl	801f20c <traceIF_uartPrintForce>
          CST_HelpCmd();
 8019fde:	f7fe fae3 	bl	80185a8 <CST_HelpCmd>
          cmd_status = CMD_SYNTAX_ERROR;
 8019fe2:	2501      	movs	r5, #1
 8019fe4:	e095      	b.n	801a112 <CST_cmd+0x11f6>
          (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 8019fe6:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 8019fea:	4a4d      	ldr	r2, [pc, #308]	; (801a120 <CST_cmd+0x1204>)
 8019fec:	4958      	ldr	r1, [pc, #352]	; (801a150 <CST_cmd+0x1234>)
 8019fee:	8809      	ldrh	r1, [r1, #0]
 8019ff0:	4858      	ldr	r0, [pc, #352]	; (801a154 <CST_cmd+0x1238>)
 8019ff2:	f007 fce9 	bl	80219c8 <dc_com_read>
          tmpConversion = (uint8_t)crs_atoi(argv_p[2]);
 8019ff6:	9803      	ldr	r0, [sp, #12]
 8019ff8:	f005 f846 	bl	801f088 <crs_atoi>
 8019ffc:	b2c4      	uxtb	r4, r0
          if ((memcmp((CRC_CHAR_t *)argv_p[1], "on", crs_strlen(argv_p[1])) == 0) && (tmpConversion <= 9U))
 8019ffe:	9e02      	ldr	r6, [sp, #8]
 801a000:	4630      	mov	r0, r6
 801a002:	f005 f886 	bl	801f112 <crs_strlen>
 801a006:	4602      	mov	r2, r0
 801a008:	4949      	ldr	r1, [pc, #292]	; (801a130 <CST_cmd+0x1214>)
 801a00a:	4630      	mov	r0, r6
 801a00c:	f00b fe93 	bl	8025d36 <memcmp>
 801a010:	b908      	cbnz	r0, 801a016 <CST_cmd+0x10fa>
 801a012:	2c09      	cmp	r4, #9
 801a014:	d91a      	bls.n	801a04c <CST_cmd+0x1130>
            PRINT_FORCE("%s bad command. Usage:", cmd_p)
 801a016:	4c47      	ldr	r4, [pc, #284]	; (801a134 <CST_cmd+0x1218>)
 801a018:	462a      	mov	r2, r5
 801a01a:	494c      	ldr	r1, [pc, #304]	; (801a14c <CST_cmd+0x1230>)
 801a01c:	4620      	mov	r0, r4
 801a01e:	f00b fe27 	bl	8025c70 <sprintf>
 801a022:	4620      	mov	r0, r4
 801a024:	f005 f875 	bl	801f112 <crs_strlen>
 801a028:	b283      	uxth	r3, r0
 801a02a:	4622      	mov	r2, r4
 801a02c:	2101      	movs	r1, #1
 801a02e:	2007      	movs	r0, #7
 801a030:	f005 f8b2 	bl	801f198 <traceIF_itmPrint>
 801a034:	4620      	mov	r0, r4
 801a036:	f005 f86c 	bl	801f112 <crs_strlen>
 801a03a:	b282      	uxth	r2, r0
 801a03c:	4621      	mov	r1, r4
 801a03e:	2007      	movs	r0, #7
 801a040:	f005 f8e4 	bl	801f20c <traceIF_uartPrintForce>
            CST_HelpCmd();
 801a044:	f7fe fab0 	bl	80185a8 <CST_HelpCmd>
            cmd_status = CMD_SYNTAX_ERROR;
 801a048:	2501      	movs	r5, #1
 801a04a:	e062      	b.n	801a112 <CST_cmd+0x11f6>
            cst_cmd_cellular_params.operator_selector.access_techno_present = DC_ACT_PRESENT_TRUE;
 801a04c:	4a34      	ldr	r2, [pc, #208]	; (801a120 <CST_cmd+0x1204>)
 801a04e:	2301      	movs	r3, #1
 801a050:	f882 317a 	strb.w	r3, [r2, #378]	; 0x17a
            cst_cmd_cellular_params.operator_selector.access_techno = (dc_access_techno_t)tmpConversion;
 801a054:	f882 417b 	strb.w	r4, [r2, #379]	; 0x17b
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a058:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a05c:	493c      	ldr	r1, [pc, #240]	; (801a150 <CST_cmd+0x1234>)
 801a05e:	8809      	ldrh	r1, [r1, #0]
 801a060:	483c      	ldr	r0, [pc, #240]	; (801a154 <CST_cmd+0x1238>)
 801a062:	f007 fc65 	bl	8021930 <dc_com_write>
  cmd_status = CMD_OK;
 801a066:	2500      	movs	r5, #0
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a068:	e053      	b.n	801a112 <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 801a06a:	9c02      	ldr	r4, [sp, #8]
 801a06c:	4620      	mov	r0, r4
 801a06e:	f005 f850 	bl	801f112 <crs_strlen>
 801a072:	4602      	mov	r2, r0
 801a074:	4932      	ldr	r1, [pc, #200]	; (801a140 <CST_cmd+0x1224>)
 801a076:	4620      	mov	r0, r4
 801a078:	f00b fe5d 	bl	8025d36 <memcmp>
 801a07c:	b918      	cbnz	r0, 801a086 <CST_cmd+0x116a>
            cst_cmd_cellular_params.operator_selector.access_techno_present = DC_ACT_PRESENT_FALSE;
 801a07e:	4b28      	ldr	r3, [pc, #160]	; (801a120 <CST_cmd+0x1204>)
 801a080:	2200      	movs	r2, #0
 801a082:	f883 217a 	strb.w	r2, [r3, #378]	; 0x17a
          (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a086:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a08a:	4a25      	ldr	r2, [pc, #148]	; (801a120 <CST_cmd+0x1204>)
 801a08c:	4930      	ldr	r1, [pc, #192]	; (801a150 <CST_cmd+0x1234>)
 801a08e:	8809      	ldrh	r1, [r1, #0]
 801a090:	4830      	ldr	r0, [pc, #192]	; (801a154 <CST_cmd+0x1238>)
 801a092:	f007 fc4d 	bl	8021930 <dc_com_write>
  cmd_status = CMD_OK;
 801a096:	2500      	movs	r5, #0
 801a098:	e03b      	b.n	801a112 <CST_cmd+0x11f6>
        PRINT_FORCE("%s bad command. Usage:", cmd_p)
 801a09a:	4c26      	ldr	r4, [pc, #152]	; (801a134 <CST_cmd+0x1218>)
 801a09c:	462a      	mov	r2, r5
 801a09e:	492b      	ldr	r1, [pc, #172]	; (801a14c <CST_cmd+0x1230>)
 801a0a0:	4620      	mov	r0, r4
 801a0a2:	f00b fde5 	bl	8025c70 <sprintf>
 801a0a6:	4620      	mov	r0, r4
 801a0a8:	f005 f833 	bl	801f112 <crs_strlen>
 801a0ac:	b283      	uxth	r3, r0
 801a0ae:	4622      	mov	r2, r4
 801a0b0:	2101      	movs	r1, #1
 801a0b2:	2007      	movs	r0, #7
 801a0b4:	f005 f870 	bl	801f198 <traceIF_itmPrint>
 801a0b8:	4620      	mov	r0, r4
 801a0ba:	f005 f82a 	bl	801f112 <crs_strlen>
 801a0be:	b282      	uxth	r2, r0
 801a0c0:	4621      	mov	r1, r4
 801a0c2:	2007      	movs	r0, #7
 801a0c4:	f005 f8a2 	bl	801f20c <traceIF_uartPrintForce>
        CST_HelpCmd();
 801a0c8:	f7fe fa6e 	bl	80185a8 <CST_HelpCmd>
        cmd_status = CMD_SYNTAX_ERROR;
 801a0cc:	2501      	movs	r5, #1
 801a0ce:	e020      	b.n	801a112 <CST_cmd+0x11f6>
      PRINT_FORCE("Bad command. Usage:")
 801a0d0:	4c18      	ldr	r4, [pc, #96]	; (801a134 <CST_cmd+0x1218>)
 801a0d2:	4d21      	ldr	r5, [pc, #132]	; (801a158 <CST_cmd+0x123c>)
 801a0d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a0d6:	6020      	str	r0, [r4, #0]
 801a0d8:	6061      	str	r1, [r4, #4]
 801a0da:	60a2      	str	r2, [r4, #8]
 801a0dc:	60e3      	str	r3, [r4, #12]
 801a0de:	6828      	ldr	r0, [r5, #0]
 801a0e0:	6120      	str	r0, [r4, #16]
 801a0e2:	88ab      	ldrh	r3, [r5, #4]
 801a0e4:	82a3      	strh	r3, [r4, #20]
 801a0e6:	4620      	mov	r0, r4
 801a0e8:	f005 f813 	bl	801f112 <crs_strlen>
 801a0ec:	b283      	uxth	r3, r0
 801a0ee:	4622      	mov	r2, r4
 801a0f0:	2101      	movs	r1, #1
 801a0f2:	2007      	movs	r0, #7
 801a0f4:	f005 f850 	bl	801f198 <traceIF_itmPrint>
 801a0f8:	4620      	mov	r0, r4
 801a0fa:	f005 f80a 	bl	801f112 <crs_strlen>
 801a0fe:	b282      	uxth	r2, r0
 801a100:	4621      	mov	r1, r4
 801a102:	2007      	movs	r0, #7
 801a104:	f005 f882 	bl	801f20c <traceIF_uartPrintForce>
      CST_HelpCmd();
 801a108:	f7fe fa4e 	bl	80185a8 <CST_HelpCmd>
      cmd_status = CMD_SYNTAX_ERROR;
 801a10c:	2501      	movs	r5, #1
 801a10e:	e000      	b.n	801a112 <CST_cmd+0x11f6>
  cmd_status = CMD_OK;
 801a110:	2500      	movs	r5, #0
}
 801a112:	4628      	mov	r0, r5
 801a114:	b00f      	add	sp, #60	; 0x3c
 801a116:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801a11a:	bf00      	nop
 801a11c:	08032d74 	.word	0x08032d74
 801a120:	20003b10 	.word	0x20003b10
 801a124:	08033554 	.word	0x08033554
 801a128:	080330f4 	.word	0x080330f4
 801a12c:	080332c0 	.word	0x080332c0
 801a130:	080332c8 	.word	0x080332c8
 801a134:	20004ddc 	.word	0x20004ddc
 801a138:	080332cc 	.word	0x080332cc
 801a13c:	08032c48 	.word	0x08032c48
 801a140:	08032d88 	.word	0x08032d88
 801a144:	080332e0 	.word	0x080332e0
 801a148:	080332f4 	.word	0x080332f4
 801a14c:	080332fc 	.word	0x080332fc
 801a150:	20000232 	.word	0x20000232
 801a154:	200058b0 	.word	0x200058b0
 801a158:	08033318 	.word	0x08033318

0801a15c <CST_cmd_cellular_service_start>:
  * @brief  starts cellar command managememnt
  * @param  -
  * @retval CS_Status_t - function result
  */
CS_Status_t CST_cmd_cellular_service_start(void)
{
 801a15c:	b508      	push	{r3, lr}
  CMD_Declare(CST_cmd_label, CST_cmd, (uint8_t *)"cellular service task management");
 801a15e:	4a08      	ldr	r2, [pc, #32]	; (801a180 <CST_cmd_cellular_service_start+0x24>)
 801a160:	4908      	ldr	r1, [pc, #32]	; (801a184 <CST_cmd_cellular_service_start+0x28>)
 801a162:	4809      	ldr	r0, [pc, #36]	; (801a188 <CST_cmd_cellular_service_start+0x2c>)
 801a164:	f008 f814 	bl	8022190 <CMD_Declare>
  CMD_Declare(CST_cmd_at_label, CST_AtCmd, (uint8_t *)"send an at command");
 801a168:	4a08      	ldr	r2, [pc, #32]	; (801a18c <CST_cmd_cellular_service_start+0x30>)
 801a16a:	4909      	ldr	r1, [pc, #36]	; (801a190 <CST_cmd_cellular_service_start+0x34>)
 801a16c:	4809      	ldr	r0, [pc, #36]	; (801a194 <CST_cmd_cellular_service_start+0x38>)
 801a16e:	f008 f80f 	bl	8022190 <CMD_Declare>
#if (CST_CMD_USE_MODEM_CONFIG == 1)
  CMD_Declare(CST_cmd_modem_label, CST_ModemCmd, (uint8_t *)"modem configuration management");
 801a172:	4a09      	ldr	r2, [pc, #36]	; (801a198 <CST_cmd_cellular_service_start+0x3c>)
 801a174:	4909      	ldr	r1, [pc, #36]	; (801a19c <CST_cmd_cellular_service_start+0x40>)
 801a176:	480a      	ldr	r0, [pc, #40]	; (801a1a0 <CST_cmd_cellular_service_start+0x44>)
 801a178:	f008 f80a 	bl	8022190 <CMD_Declare>
#endif  /* CST_CMD_USE_MODEM_CONFIG == 1 */

  return CELLULAR_OK;
}
 801a17c:	2000      	movs	r0, #0
 801a17e:	bd08      	pop	{r3, pc}
 801a180:	08033330 	.word	0x08033330
 801a184:	08018f1d 	.word	0x08018f1d
 801a188:	08032838 	.word	0x08032838
 801a18c:	08033354 	.word	0x08033354
 801a190:	08018df1 	.word	0x08018df1
 801a194:	080327b4 	.word	0x080327b4
 801a198:	08033368 	.word	0x08033368
 801a19c:	08018915 	.word	0x08018915
 801a1a0:	08032360 	.word	0x08032360

0801a1a4 <cst_get_sim_socket_value>:
  * @retval dc_cs_sim_slot_type_t  - sim slot DC enum value
  */
static dc_cs_sim_slot_type_t  cst_get_sim_socket_value(uint8_t sim_slot_value)
{
  dc_cs_sim_slot_type_t enum_value;
  switch (sim_slot_value)
 801a1a4:	2801      	cmp	r0, #1
 801a1a6:	d002      	beq.n	801a1ae <cst_get_sim_socket_value+0xa>
 801a1a8:	2802      	cmp	r0, #2
 801a1aa:	d000      	beq.n	801a1ae <cst_get_sim_socket_value+0xa>
 801a1ac:	2000      	movs	r0, #0
      enum_value = DC_SIM_SLOT_MODEM_SOCKET;
      break;
    }
  }
  return enum_value;
}
 801a1ae:	4770      	bx	lr

0801a1b0 <cst_get_target_state_value>:
  * @retval dc_cs_sim_slot_type_t  - modem target state enum value
  */
static dc_cs_target_state_t  cst_get_target_state_value(uint8_t target_state_value)
{
  dc_cs_target_state_t enum_value;
  switch (target_state_value)
 801a1b0:	2801      	cmp	r0, #1
 801a1b2:	d003      	beq.n	801a1bc <cst_get_target_state_value+0xc>
 801a1b4:	2802      	cmp	r0, #2
 801a1b6:	d001      	beq.n	801a1bc <cst_get_target_state_value+0xc>
 801a1b8:	b100      	cbz	r0, 801a1bc <cst_get_target_state_value+0xc>
      enum_value = DC_TARGET_STATE_FULL;
      break;
    }
    default:
    {
      enum_value = DC_TARGET_STATE_FULL;
 801a1ba:	2002      	movs	r0, #2
      break;
    }
  }
  return enum_value;
}
 801a1bc:	4770      	bx	lr

0801a1be <cst_get_cid_value>:
  * @retval CS_PDN_conf_id_t  - cid enum value
  */
CS_PDN_conf_id_t  cst_get_cid_value(uint8_t cid_value)
{
  CS_PDN_conf_id_t enum_value;
  switch (cid_value)
 801a1be:	1e43      	subs	r3, r0, #1
 801a1c0:	2b0c      	cmp	r3, #12
 801a1c2:	d808      	bhi.n	801a1d6 <cst_get_cid_value+0x18>
 801a1c4:	e8df f003 	tbb	[pc, r3]
 801a1c8:	08080808 	.word	0x08080808
 801a1cc:	07070708 	.word	0x07070708
 801a1d0:	08080707 	.word	0x08080707
 801a1d4:	08          	.byte	0x08
 801a1d5:	00          	.byte	0x00
 801a1d6:	2000      	movs	r0, #0
      break;
    }

  }
  return enum_value;
}
 801a1d8:	4770      	bx	lr
	...

0801a1dc <CST_local_setup_handler>:
  * @note  used only if USE_DEFAULT_SETUP compilation flag is defined
  * @param  none
  * @retval none
  */
static void CST_local_setup_handler(void)
{
 801a1dc:	b530      	push	{r4, r5, lr}
 801a1de:	b0e9      	sub	sp, #420	; 0x1a4
  const uint8_t *tmp_string;
  dc_cellular_params_t cellular_params;
  uint32_t size;

  (void)memset((void *)&cellular_params, 0, sizeof(cellular_params));
 801a1e0:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 801a1e4:	2100      	movs	r1, #0
 801a1e6:	4668      	mov	r0, sp
 801a1e8:	f00b fdb5 	bl	8025d56 <memset>

  cellular_params.set_pdn_mode = 1U;
 801a1ec:	2301      	movs	r3, #1
 801a1ee:	f88d 3009 	strb.w	r3, [sp, #9]
  cellular_params.sim_slot_nb  = 1U;
 801a1f2:	f88d 300a 	strb.w	r3, [sp, #10]

  /* SIM slot 0 parameters BEGIN*/
  tmp_string = CST_default_setup_table[CST_PARAM_SIM_SLOT];
  cellular_params.sim_slot[0].sim_slot_type = cst_get_sim_socket_value(tmp_string[0] - (uint8_t)'0');
 801a1f6:	2000      	movs	r0, #0
 801a1f8:	f7ff ffd4 	bl	801a1a4 <cst_get_sim_socket_value>
 801a1fc:	f88d 000b 	strb.w	r0, [sp, #11]

  /* APN parameter */
  size = crs_strlen(CST_default_setup_table[CST_PARAM_APN]) + 1U;
 801a200:	483e      	ldr	r0, [pc, #248]	; (801a2fc <CST_local_setup_handler+0x120>)
 801a202:	f004 ff86 	bl	801f112 <crs_strlen>
 801a206:	1c42      	adds	r2, r0, #1
  /* to avoid string overflow */
  if (size <= DC_MAX_SIZE_APN)
 801a208:	2a20      	cmp	r2, #32
 801a20a:	d94e      	bls.n	801a2aa <CST_local_setup_handler+0xce>
                 size);
  }

  /* CID parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_CID];
  cellular_params.sim_slot[0].cid = cst_get_cid_value(tmp_string[0] - (uint8_t)'0');
 801a20c:	2001      	movs	r0, #1
 801a20e:	f7ff ffd6 	bl	801a1be <cst_get_cid_value>
 801a212:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c

  /* username parameter */
  size = crs_strlen(CST_default_setup_table[CST_PARAM_USERNAME]) + 1U;
 801a216:	4839      	ldr	r0, [pc, #228]	; (801a2fc <CST_local_setup_handler+0x120>)
 801a218:	f004 ff7b 	bl	801f112 <crs_strlen>
 801a21c:	1c42      	adds	r2, r0, #1
  /* to avoid string overflow */
  if (size <= DC_CST_USERNAME_SIZE)
 801a21e:	2a20      	cmp	r2, #32
 801a220:	d948      	bls.n	801a2b4 <CST_local_setup_handler+0xd8>
                 (CRC_CHAR_t *)CST_default_setup_table[CST_PARAM_USERNAME],
                 size);
  }

  /* password parameter */
  size = crs_strlen(CST_default_setup_table[CST_PARAM_PASSWORD]) + 1U;
 801a222:	4836      	ldr	r0, [pc, #216]	; (801a2fc <CST_local_setup_handler+0x120>)
 801a224:	f004 ff75 	bl	801f112 <crs_strlen>
 801a228:	1c42      	adds	r2, r0, #1
  /* to avoid string overflow */
  if (size <= DC_CST_PASSWORD_SIZE)
 801a22a:	2a20      	cmp	r2, #32
 801a22c:	d948      	bls.n	801a2c0 <CST_local_setup_handler+0xe4>

  /* SIM slot 0 parameters END*/

  /* modem target state parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_TARGET_STATE];
  cellular_params.target_state = cst_get_target_state_value(tmp_string[0] - (uint8_t)'0');
 801a22e:	2002      	movs	r0, #2
 801a230:	f7ff ffbe 	bl	801a1b0 <cst_get_target_state_value>
 801a234:	f88d 0131 	strb.w	r0, [sp, #305]	; 0x131

  /* attachment timeout parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_ATTACHMENT_TIMEOUT];
  cellular_params.attachment_timeout = (uint32_t)crs_atoi(tmp_string);
 801a238:	4831      	ldr	r0, [pc, #196]	; (801a300 <CST_local_setup_handler+0x124>)
 801a23a:	f004 ff25 	bl	801f088 <crs_atoi>
 801a23e:	904d      	str	r0, [sp, #308]	; 0x134

  cellular_params.operator_selector.network_reg_mode      =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_NETWORK_REG_MODE]);
 801a240:	4830      	ldr	r0, [pc, #192]	; (801a304 <CST_local_setup_handler+0x128>)
 801a242:	f004 ff21 	bl	801f088 <crs_atoi>
  cellular_params.operator_selector.network_reg_mode      =
 801a246:	f88d 0138 	strb.w	r0, [sp, #312]	; 0x138

  cellular_params.operator_selector.operator_name_format  =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_OPERATOR_NAME_FORMAT]);
 801a24a:	482f      	ldr	r0, [pc, #188]	; (801a308 <CST_local_setup_handler+0x12c>)
 801a24c:	f004 ff1c 	bl	801f088 <crs_atoi>
  cellular_params.operator_selector.operator_name_format  =
 801a250:	f88d 0139 	strb.w	r0, [sp, #313]	; 0x139

  memcpy(cellular_params.operator_selector.operator_name, CST_default_setup_table[CST_PARAM_OPERATOR_NAME],
 801a254:	4d2d      	ldr	r5, [pc, #180]	; (801a30c <CST_local_setup_handler+0x130>)
 801a256:	f50d 7c9d 	add.w	ip, sp, #314	; 0x13a
 801a25a:	f105 0e40 	add.w	lr, r5, #64	; 0x40
 801a25e:	462c      	mov	r4, r5
 801a260:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a262:	f8cc 0000 	str.w	r0, [ip]
 801a266:	f8cc 1004 	str.w	r1, [ip, #4]
 801a26a:	f8cc 2008 	str.w	r2, [ip, #8]
 801a26e:	f8cc 300c 	str.w	r3, [ip, #12]
 801a272:	4625      	mov	r5, r4
 801a274:	f10c 0c10 	add.w	ip, ip, #16
 801a278:	4574      	cmp	r4, lr
 801a27a:	d1f0      	bne.n	801a25e <CST_local_setup_handler+0x82>
         sizeof(cellular_params.operator_selector.operator_name));

  cellular_params.operator_selector.access_techno_present =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_ACT_PRESENT]);
 801a27c:	4821      	ldr	r0, [pc, #132]	; (801a304 <CST_local_setup_handler+0x128>)
 801a27e:	f004 ff03 	bl	801f088 <crs_atoi>
 801a282:	f010 0fff 	tst.w	r0, #255	; 0xff
 801a286:	bf14      	ite	ne
 801a288:	2301      	movne	r3, #1
 801a28a:	2300      	moveq	r3, #0
  cellular_params.operator_selector.access_techno_present =
 801a28c:	f88d 317a 	strb.w	r3, [sp, #378]	; 0x17a

  cellular_params.operator_selector.access_techno         =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_ACCESS_TECHNO]);
 801a290:	481f      	ldr	r0, [pc, #124]	; (801a310 <CST_local_setup_handler+0x134>)
 801a292:	f004 fef9 	bl	801f088 <crs_atoi>
  cellular_params.operator_selector.access_techno         =
 801a296:	f88d 017b 	strb.w	r0, [sp, #379]	; 0x17b

  /* low power inactivity timeout parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_LP_INACTIVITY_TIMEOUT];
  cellular_params.lp_inactivity_timeout = (uint32_t)crs_atoi(tmp_string);
 801a29a:	481e      	ldr	r0, [pc, #120]	; (801a314 <CST_local_setup_handler+0x138>)
 801a29c:	f004 fef4 	bl	801f088 <crs_atoi>
 801a2a0:	9067      	str	r0, [sp, #412]	; 0x19c
  {
    cellular_params.nfmc_active = 1U;
  }
  else
  {
    cellular_params.nfmc_active = 0U;
 801a2a2:	2400      	movs	r4, #0
 801a2a4:	f88d 417c 	strb.w	r4, [sp, #380]	; 0x17c
 801a2a8:	e018      	b.n	801a2dc <CST_local_setup_handler+0x100>
    (void)memcpy((CRC_CHAR_t *)cellular_params.sim_slot[0].apn,
 801a2aa:	4914      	ldr	r1, [pc, #80]	; (801a2fc <CST_local_setup_handler+0x120>)
 801a2ac:	a803      	add	r0, sp, #12
 801a2ae:	f00b fe2f 	bl	8025f10 <memcpy>
 801a2b2:	e7ab      	b.n	801a20c <CST_local_setup_handler+0x30>
    (void)memcpy((CRC_CHAR_t *)cellular_params.sim_slot[0].username,
 801a2b4:	4911      	ldr	r1, [pc, #68]	; (801a2fc <CST_local_setup_handler+0x120>)
 801a2b6:	f10d 002d 	add.w	r0, sp, #45	; 0x2d
 801a2ba:	f00b fe29 	bl	8025f10 <memcpy>
 801a2be:	e7b0      	b.n	801a222 <CST_local_setup_handler+0x46>
    (void)memcpy((CRC_CHAR_t *)cellular_params.sim_slot[0].password,
 801a2c0:	490e      	ldr	r1, [pc, #56]	; (801a2fc <CST_local_setup_handler+0x120>)
 801a2c2:	f10d 004d 	add.w	r0, sp, #77	; 0x4d
 801a2c6:	f00b fe23 	bl	8025f10 <memcpy>
 801a2ca:	e7b0      	b.n	801a22e <CST_local_setup_handler+0x52>
  }

  /* Set all NFMC tempo values */
  for (uint32_t i = 0U; i < CST_NFMC_TEMPO_NB ; i++)
  {
    cellular_params.nfmc_value[i] = (uint32_t)crs_atoi(CST_default_setup_table[CST_PARAM_NFMC_TEMPO]);
 801a2cc:	4812      	ldr	r0, [pc, #72]	; (801a318 <CST_local_setup_handler+0x13c>)
 801a2ce:	f004 fedb 	bl	801f088 <crs_atoi>
 801a2d2:	f104 0360 	add.w	r3, r4, #96	; 0x60
 801a2d6:	f84d 0023 	str.w	r0, [sp, r3, lsl #2]
  for (uint32_t i = 0U; i < CST_NFMC_TEMPO_NB ; i++)
 801a2da:	3401      	adds	r4, #1
 801a2dc:	2c06      	cmp	r4, #6
 801a2de:	d9f5      	bls.n	801a2cc <CST_local_setup_handler+0xf0>
  cellular_params.nfmc_value[5] = (uint32_t)crs_atoi(CST_DEFAULT_NFMC_TEMPO6_STRING);
  cellular_params.nfmc_value[6] = (uint32_t)crs_atoi(CST_DEFAULT_NFMC_TEMPO7_STRING);
#endif /* (CST_SETUP_NFMC == 1) */

  /* set Data Cache entry valid */
  cellular_params.rt_state = DC_SERVICE_ON;
 801a2e0:	2307      	movs	r3, #7
 801a2e2:	f88d 3008 	strb.w	r3, [sp, #8]

  /* write Entry to Data Cache */
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cellular_params, sizeof(cellular_params));
 801a2e6:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a2ea:	466a      	mov	r2, sp
 801a2ec:	490b      	ldr	r1, [pc, #44]	; (801a31c <CST_local_setup_handler+0x140>)
 801a2ee:	8809      	ldrh	r1, [r1, #0]
 801a2f0:	480b      	ldr	r0, [pc, #44]	; (801a320 <CST_local_setup_handler+0x144>)
 801a2f2:	f007 fb1d 	bl	8021930 <dc_com_write>
}
 801a2f6:	b069      	add	sp, #420	; 0x1a4
 801a2f8:	bd30      	pop	{r4, r5, pc}
 801a2fa:	bf00      	nop
 801a2fc:	08034f74 	.word	0x08034f74
 801a300:	080335b4 	.word	0x080335b4
 801a304:	080335d8 	.word	0x080335d8
 801a308:	080335bc 	.word	0x080335bc
 801a30c:	080335c0 	.word	0x080335c0
 801a310:	080335c8 	.word	0x080335c8
 801a314:	080335cc 	.word	0x080335cc
 801a318:	080335d4 	.word	0x080335d4
 801a31c:	20000232 	.word	0x20000232
 801a320:	200058b0 	.word	0x200058b0

0801a324 <CST_config_init>:
  * @param  cellular_params   - cellular configuration
  * @retval error code (O:OK)
  */

CS_Status_t CST_config_init(void)
{
 801a324:	b508      	push	{r3, lr}
                     CST_setup_dump,
                     CST_setup_help,
                     CST_default_setup_table, CST_DEFAULT_PARAMA_NB);
#else
  /* In case on default setup (without menu) calls default configuration setting */
  CST_local_setup_handler();
 801a326:	f7ff ff59 	bl	801a1dc <CST_local_setup_handler>
#endif   /* (!USE_DEFAULT_SETUP == 1) */

  return CELLULAR_OK;
}
 801a32a:	2000      	movs	r0, #0
 801a32c:	bd08      	pop	{r3, pc}
	...

0801a330 <csint_modem_reset_update_socket_state>:
  * @note  Update socket state after a modem reset
  * @param  none
  * @retval none
  */
void csint_modem_reset_update_socket_state(void)
{
 801a330:	b570      	push	{r4, r5, r6, lr}
  * - if SOCKETSTATE_CONNECTED => socket is lost, invalid state
  * - if SOCKETSTATE_ALLOC_BUT_INVALID => socket already in an invalid state
  */
  uint8_t cpt;

  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a332:	2500      	movs	r5, #0
 801a334:	e003      	b.n	801a33e <csint_modem_reset_update_socket_state+0xe>
  {
    switch (cs_ctxt_sockets_info[cpt].state)
 801a336:	2b01      	cmp	r3, #1
 801a338:	d80d      	bhi.n	801a356 <csint_modem_reset_update_socket_state+0x26>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a33a:	3501      	adds	r5, #1
 801a33c:	b2ed      	uxtb	r5, r5
 801a33e:	2d05      	cmp	r5, #5
 801a340:	d839      	bhi.n	801a3b6 <csint_modem_reset_update_socket_state+0x86>
    switch (cs_ctxt_sockets_info[cpt].state)
 801a342:	4b1d      	ldr	r3, [pc, #116]	; (801a3b8 <csint_modem_reset_update_socket_state+0x88>)
 801a344:	226c      	movs	r2, #108	; 0x6c
 801a346:	fb02 3305 	mla	r3, r2, r5, r3
 801a34a:	791b      	ldrb	r3, [r3, #4]
 801a34c:	2b02      	cmp	r3, #2
 801a34e:	d02b      	beq.n	801a3a8 <csint_modem_reset_update_socket_state+0x78>
 801a350:	d9f1      	bls.n	801a336 <csint_modem_reset_update_socket_state+0x6>
 801a352:	2b03      	cmp	r3, #3
 801a354:	d0f1      	beq.n	801a33a <csint_modem_reset_update_socket_state+0xa>
        */
        cs_ctxt_sockets_info[cpt].state = SOCKETSTATE_ALLOC_BUT_INVALID;
        break;

      default:
        PRINT_ERR("unknown socket state, Should not happen")
 801a356:	4e19      	ldr	r6, [pc, #100]	; (801a3bc <csint_modem_reset_update_socket_state+0x8c>)
 801a358:	4c19      	ldr	r4, [pc, #100]	; (801a3c0 <csint_modem_reset_update_socket_state+0x90>)
 801a35a:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 801a35e:	46b4      	mov	ip, r6
 801a360:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801a364:	6020      	str	r0, [r4, #0]
 801a366:	6061      	str	r1, [r4, #4]
 801a368:	60a2      	str	r2, [r4, #8]
 801a36a:	60e3      	str	r3, [r4, #12]
 801a36c:	4666      	mov	r6, ip
 801a36e:	3410      	adds	r4, #16
 801a370:	45f4      	cmp	ip, lr
 801a372:	d1f4      	bne.n	801a35e <csint_modem_reset_update_socket_state+0x2e>
 801a374:	f8bc 2000 	ldrh.w	r2, [ip]
 801a378:	f89c 3002 	ldrb.w	r3, [ip, #2]
 801a37c:	8022      	strh	r2, [r4, #0]
 801a37e:	70a3      	strb	r3, [r4, #2]
 801a380:	4c0f      	ldr	r4, [pc, #60]	; (801a3c0 <csint_modem_reset_update_socket_state+0x90>)
 801a382:	4620      	mov	r0, r4
 801a384:	f004 fec5 	bl	801f112 <crs_strlen>
 801a388:	b283      	uxth	r3, r0
 801a38a:	4622      	mov	r2, r4
 801a38c:	2110      	movs	r1, #16
 801a38e:	2001      	movs	r0, #1
 801a390:	f004 ff02 	bl	801f198 <traceIF_itmPrint>
 801a394:	4620      	mov	r0, r4
 801a396:	f004 febc 	bl	801f112 <crs_strlen>
 801a39a:	b283      	uxth	r3, r0
 801a39c:	4622      	mov	r2, r4
 801a39e:	2110      	movs	r1, #16
 801a3a0:	2001      	movs	r0, #1
 801a3a2:	f004 ff1b 	bl	801f1dc <traceIF_uartPrint>
        break;
 801a3a6:	e7c8      	b.n	801a33a <csint_modem_reset_update_socket_state+0xa>
        cs_ctxt_sockets_info[cpt].state = SOCKETSTATE_ALLOC_BUT_INVALID;
 801a3a8:	4b03      	ldr	r3, [pc, #12]	; (801a3b8 <csint_modem_reset_update_socket_state+0x88>)
 801a3aa:	226c      	movs	r2, #108	; 0x6c
 801a3ac:	fb02 3305 	mla	r3, r2, r5, r3
 801a3b0:	2203      	movs	r2, #3
 801a3b2:	711a      	strb	r2, [r3, #4]
        break;
 801a3b4:	e7c1      	b.n	801a33a <csint_modem_reset_update_socket_state+0xa>
    }
  }
}
 801a3b6:	bd70      	pop	{r4, r5, r6, pc}
 801a3b8:	20003d18 	.word	0x20003d18
 801a3bc:	080335dc 	.word	0x080335dc
 801a3c0:	200047dc 	.word	0x200047dc

0801a3c4 <csint_socket_init>:
  * @note   Initialize socket parameters
  * @param  index
  * @retval none
  */
void csint_socket_init(socket_handle_t index)
{
 801a3c4:	b538      	push	{r3, r4, r5, lr}
 801a3c6:	4604      	mov	r4, r0
  PRINT_API("<Cellular_Service> SOCKET_init (index=%ld)", index)
 801a3c8:	4d20      	ldr	r5, [pc, #128]	; (801a44c <csint_socket_init+0x88>)
 801a3ca:	4602      	mov	r2, r0
 801a3cc:	4920      	ldr	r1, [pc, #128]	; (801a450 <csint_socket_init+0x8c>)
 801a3ce:	4628      	mov	r0, r5
 801a3d0:	f00b fc4e 	bl	8025c70 <sprintf>
 801a3d4:	4628      	mov	r0, r5
 801a3d6:	f004 fe9c 	bl	801f112 <crs_strlen>
 801a3da:	b283      	uxth	r3, r0
 801a3dc:	462a      	mov	r2, r5
 801a3de:	2104      	movs	r1, #4
 801a3e0:	2001      	movs	r0, #1
 801a3e2:	f004 fed9 	bl	801f198 <traceIF_itmPrint>
 801a3e6:	4628      	mov	r0, r5
 801a3e8:	f004 fe93 	bl	801f112 <crs_strlen>
 801a3ec:	b283      	uxth	r3, r0
 801a3ee:	462a      	mov	r2, r5
 801a3f0:	2104      	movs	r1, #4
 801a3f2:	2001      	movs	r0, #1
 801a3f4:	f004 fef2 	bl	801f1dc <traceIF_uartPrint>

  cs_ctxt_sockets_info[index].socket_handle = index;
 801a3f8:	4916      	ldr	r1, [pc, #88]	; (801a454 <csint_socket_init+0x90>)
 801a3fa:	226c      	movs	r2, #108	; 0x6c
 801a3fc:	fb04 f202 	mul.w	r2, r4, r2
 801a400:	188b      	adds	r3, r1, r2
 801a402:	508c      	str	r4, [r1, r2]
  cs_ctxt_sockets_info[index].state = SOCKETSTATE_NOT_ALLOC;
 801a404:	2200      	movs	r2, #0
 801a406:	711a      	strb	r2, [r3, #4]
  cs_ctxt_sockets_info[index].config = CS_SON_NO_OPTION;
 801a408:	80da      	strh	r2, [r3, #6]

  cs_ctxt_sockets_info[index].addr_type = CS_IPAT_IPV4;
 801a40a:	2101      	movs	r1, #1
 801a40c:	7219      	strb	r1, [r3, #8]
  cs_ctxt_sockets_info[index].protocol = CS_TCP_PROTOCOL;
 801a40e:	725a      	strb	r2, [r3, #9]
  cs_ctxt_sockets_info[index].local_port = 0U;
 801a410:	815a      	strh	r2, [r3, #10]
  cs_ctxt_sockets_info[index].conf_id = CS_PDN_NOT_DEFINED;
 801a412:	210c      	movs	r1, #12
 801a414:	7319      	strb	r1, [r3, #12]

  cs_ctxt_sockets_info[index].ip_max_packet_size = DEFAULT_IP_MAX_PACKET_SIZE;
 801a416:	f240 51dc 	movw	r1, #1500	; 0x5dc
 801a41a:	f8a3 1050 	strh.w	r1, [r3, #80]	; 0x50
  cs_ctxt_sockets_info[index].trp_max_timeout = DEFAULT_TRP_MAX_TIMEOUT;
 801a41e:	215a      	movs	r1, #90	; 0x5a
 801a420:	f8a3 1052 	strh.w	r1, [r3, #82]	; 0x52
  cs_ctxt_sockets_info[index].trp_conn_setup_timeout = DEFAULT_TRP_CONN_SETUP_TIMEOUT;
 801a424:	f44f 7116 	mov.w	r1, #600	; 0x258
 801a428:	f8a3 1054 	strh.w	r1, [r3, #84]	; 0x54
  cs_ctxt_sockets_info[index].trp_transfer_timeout = DEFAULT_TRP_TRANSFER_TIMEOUT;
 801a42c:	2132      	movs	r1, #50	; 0x32
 801a42e:	f8a3 1056 	strh.w	r1, [r3, #86]	; 0x56
  cs_ctxt_sockets_info[index].trp_connect_mode = CS_CM_COMMAND_MODE;
 801a432:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
  cs_ctxt_sockets_info[index].trp_suspend_timeout = DEFAULT_TRP_SUSPEND_TIMEOUT;
 801a436:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801a43a:	f8a3 005a 	strh.w	r0, [r3, #90]	; 0x5a
  cs_ctxt_sockets_info[index].trp_rx_timeout = DEFAULT_TRP_RX_TIMEOUT;
 801a43e:	f8a3 105c 	strh.w	r1, [r3, #92]	; 0x5c

  /* socket callback functions pointers */
  cs_ctxt_sockets_info[index].socket_data_ready_callback = NULL;
 801a442:	661a      	str	r2, [r3, #96]	; 0x60
  cs_ctxt_sockets_info[index].socket_data_sent_callback = NULL;
 801a444:	665a      	str	r2, [r3, #100]	; 0x64
  cs_ctxt_sockets_info[index].socket_remote_close_callback = NULL;
 801a446:	669a      	str	r2, [r3, #104]	; 0x68
}
 801a448:	bd38      	pop	{r3, r4, r5, pc}
 801a44a:	bf00      	nop
 801a44c:	200047dc 	.word	0x200047dc
 801a450:	08033610 	.word	0x08033610
 801a454:	20003d18 	.word	0x20003d18

0801a458 <csint_socket_allocateHandle>:
socket_handle_t csint_socket_allocateHandle(void)
{
  socket_handle_t socket_handle = CS_INVALID_SOCKET_HANDLE;
  uint8_t cpt;

  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a458:	2300      	movs	r3, #0
 801a45a:	2b05      	cmp	r3, #5
 801a45c:	d809      	bhi.n	801a472 <csint_socket_allocateHandle+0x1a>
  {
    if (cs_ctxt_sockets_info[cpt].state == SOCKETSTATE_NOT_ALLOC)
 801a45e:	4618      	mov	r0, r3
 801a460:	4a05      	ldr	r2, [pc, #20]	; (801a478 <csint_socket_allocateHandle+0x20>)
 801a462:	216c      	movs	r1, #108	; 0x6c
 801a464:	fb01 2203 	mla	r2, r1, r3, r2
 801a468:	7912      	ldrb	r2, [r2, #4]
 801a46a:	b122      	cbz	r2, 801a476 <csint_socket_allocateHandle+0x1e>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a46c:	3301      	adds	r3, #1
 801a46e:	b2db      	uxtb	r3, r3
 801a470:	e7f3      	b.n	801a45a <csint_socket_allocateHandle+0x2>
  socket_handle_t socket_handle = CS_INVALID_SOCKET_HANDLE;
 801a472:	f04f 30ff 	mov.w	r0, #4294967295
      break;
    }
  }

  return (socket_handle);
}
 801a476:	4770      	bx	lr
 801a478:	20003d18 	.word	0x20003d18

0801a47c <csint_socket_deallocateHandle>:
  * @note   Deallocate a socket handle
  * @param  sockhandle
  * @retval none
  */
void csint_socket_deallocateHandle(socket_handle_t sockhandle)
{
 801a47c:	b538      	push	{r3, r4, r5, lr}
 801a47e:	4605      	mov	r5, r0
  PRINT_INFO("socket_deallocateHandle %ld", sockhandle)
 801a480:	4c0d      	ldr	r4, [pc, #52]	; (801a4b8 <csint_socket_deallocateHandle+0x3c>)
 801a482:	4602      	mov	r2, r0
 801a484:	490d      	ldr	r1, [pc, #52]	; (801a4bc <csint_socket_deallocateHandle+0x40>)
 801a486:	4620      	mov	r0, r4
 801a488:	f00b fbf2 	bl	8025c70 <sprintf>
 801a48c:	4620      	mov	r0, r4
 801a48e:	f004 fe40 	bl	801f112 <crs_strlen>
 801a492:	b283      	uxth	r3, r0
 801a494:	4622      	mov	r2, r4
 801a496:	2101      	movs	r1, #1
 801a498:	4608      	mov	r0, r1
 801a49a:	f004 fe7d 	bl	801f198 <traceIF_itmPrint>
 801a49e:	4620      	mov	r0, r4
 801a4a0:	f004 fe37 	bl	801f112 <crs_strlen>
 801a4a4:	b283      	uxth	r3, r0
 801a4a6:	4622      	mov	r2, r4
 801a4a8:	2101      	movs	r1, #1
 801a4aa:	4608      	mov	r0, r1
 801a4ac:	f004 fe96 	bl	801f1dc <traceIF_uartPrint>
  csint_socket_init(sockhandle);
 801a4b0:	4628      	mov	r0, r5
 801a4b2:	f7ff ff87 	bl	801a3c4 <csint_socket_init>
}
 801a4b6:	bd38      	pop	{r3, r4, r5, pc}
 801a4b8:	200047dc 	.word	0x200047dc
 801a4bc:	08033644 	.word	0x08033644

0801a4c0 <csint_socket_create>:
CS_Status_t csint_socket_create(socket_handle_t sockhandle,
                                CS_IPaddrType_t addr_type,
                                CS_TransportProtocol_t protocol,
                                uint16_t local_port,
                                CS_PDN_conf_id_t cid)
{
 801a4c0:	b510      	push	{r4, lr}
 801a4c2:	4686      	mov	lr, r0
  CS_Status_t retval;

  cs_ctxt_sockets_info[sockhandle].addr_type = addr_type;
 801a4c4:	4c17      	ldr	r4, [pc, #92]	; (801a524 <csint_socket_create+0x64>)
 801a4c6:	206c      	movs	r0, #108	; 0x6c
 801a4c8:	fb00 4c0e 	mla	ip, r0, lr, r4
 801a4cc:	f88c 1008 	strb.w	r1, [ip, #8]
  cs_ctxt_sockets_info[sockhandle].protocol = protocol;
 801a4d0:	f88c 2009 	strb.w	r2, [ip, #9]
  cs_ctxt_sockets_info[sockhandle].local_port = local_port;
 801a4d4:	f8ac 300a 	strh.w	r3, [ip, #10]
  cs_ctxt_sockets_info[sockhandle].conf_id = cid;
 801a4d8:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801a4dc:	f88c 300c 	strb.w	r3, [ip, #12]

  if (cs_ctxt_sockets_info[sockhandle].state == SOCKETSTATE_NOT_ALLOC)
 801a4e0:	f89c 0004 	ldrb.w	r0, [ip, #4]
 801a4e4:	b918      	cbnz	r0, 801a4ee <csint_socket_create+0x2e>
  {
    /* update socket state */
    cs_ctxt_sockets_info[sockhandle].state = SOCKETSTATE_CREATED;
 801a4e6:	2201      	movs	r2, #1
 801a4e8:	f88c 2004 	strb.w	r2, [ip, #4]
    PRINT_ERR("<Cellular_Service> socket handle %ld not available", sockhandle)
    retval = CELLULAR_ERROR;
  }

  return (retval);
}
 801a4ec:	bd10      	pop	{r4, pc}
    PRINT_ERR("<Cellular_Service> socket handle %ld not available", sockhandle)
 801a4ee:	4c0e      	ldr	r4, [pc, #56]	; (801a528 <csint_socket_create+0x68>)
 801a4f0:	4672      	mov	r2, lr
 801a4f2:	490e      	ldr	r1, [pc, #56]	; (801a52c <csint_socket_create+0x6c>)
 801a4f4:	4620      	mov	r0, r4
 801a4f6:	f00b fbbb 	bl	8025c70 <sprintf>
 801a4fa:	4620      	mov	r0, r4
 801a4fc:	f004 fe09 	bl	801f112 <crs_strlen>
 801a500:	b283      	uxth	r3, r0
 801a502:	4622      	mov	r2, r4
 801a504:	2110      	movs	r1, #16
 801a506:	2001      	movs	r0, #1
 801a508:	f004 fe46 	bl	801f198 <traceIF_itmPrint>
 801a50c:	4620      	mov	r0, r4
 801a50e:	f004 fe00 	bl	801f112 <crs_strlen>
 801a512:	b283      	uxth	r3, r0
 801a514:	4622      	mov	r2, r4
 801a516:	2110      	movs	r1, #16
 801a518:	2001      	movs	r0, #1
 801a51a:	f004 fe5f 	bl	801f1dc <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 801a51e:	2001      	movs	r0, #1
 801a520:	e7e4      	b.n	801a4ec <csint_socket_create+0x2c>
 801a522:	bf00      	nop
 801a524:	20003d18 	.word	0x20003d18
 801a528:	200047dc 	.word	0x200047dc
 801a52c:	08033668 	.word	0x08033668

0801a530 <csint_socket_bind>:
  * @param  local_port
  * @retval CS_Status_t
  */
CS_Status_t csint_socket_bind(socket_handle_t sockhandle,
                              uint16_t local_port)
{
 801a530:	4602      	mov	r2, r0
  CS_Status_t retval;

  /* check that socket has been allocated */
  if (cs_ctxt_sockets_info[sockhandle].state == SOCKETSTATE_NOT_ALLOC)
 801a532:	4b13      	ldr	r3, [pc, #76]	; (801a580 <csint_socket_bind+0x50>)
 801a534:	206c      	movs	r0, #108	; 0x6c
 801a536:	fb00 3302 	mla	r3, r0, r2, r3
 801a53a:	791b      	ldrb	r3, [r3, #4]
 801a53c:	b133      	cbz	r3, 801a54c <csint_socket_bind+0x1c>
    retval = CELLULAR_ERROR;
  }
  else
  {
    /* set the local port */
    cs_ctxt_sockets_info[sockhandle].local_port = local_port;
 801a53e:	4b10      	ldr	r3, [pc, #64]	; (801a580 <csint_socket_bind+0x50>)
 801a540:	206c      	movs	r0, #108	; 0x6c
 801a542:	fb00 3302 	mla	r3, r0, r2, r3
 801a546:	8159      	strh	r1, [r3, #10]
    retval = CELLULAR_OK;
 801a548:	2000      	movs	r0, #0
  }

  return (retval);
}
 801a54a:	4770      	bx	lr
{
 801a54c:	b510      	push	{r4, lr}
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (bind)", sockhandle)
 801a54e:	4c0d      	ldr	r4, [pc, #52]	; (801a584 <csint_socket_bind+0x54>)
 801a550:	490d      	ldr	r1, [pc, #52]	; (801a588 <csint_socket_bind+0x58>)
 801a552:	4620      	mov	r0, r4
 801a554:	f00b fb8c 	bl	8025c70 <sprintf>
 801a558:	4620      	mov	r0, r4
 801a55a:	f004 fdda 	bl	801f112 <crs_strlen>
 801a55e:	b283      	uxth	r3, r0
 801a560:	4622      	mov	r2, r4
 801a562:	2110      	movs	r1, #16
 801a564:	2001      	movs	r0, #1
 801a566:	f004 fe17 	bl	801f198 <traceIF_itmPrint>
 801a56a:	4620      	mov	r0, r4
 801a56c:	f004 fdd1 	bl	801f112 <crs_strlen>
 801a570:	b283      	uxth	r3, r0
 801a572:	4622      	mov	r2, r4
 801a574:	2110      	movs	r1, #16
 801a576:	2001      	movs	r0, #1
 801a578:	f004 fe30 	bl	801f1dc <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 801a57c:	2001      	movs	r0, #1
}
 801a57e:	bd10      	pop	{r4, pc}
 801a580:	20003d18 	.word	0x20003d18
 801a584:	200047dc 	.word	0x200047dc
 801a588:	080336a8 	.word	0x080336a8

0801a58c <csint_socket_configure_remote>:
  */
CS_Status_t csint_socket_configure_remote(socket_handle_t sockhandle,
                                          CS_IPaddrType_t ip_addr_type,
                                          CS_CHAR_t *p_ip_addr_value,
                                          uint16_t remote_port)
{
 801a58c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801a590:	4604      	mov	r4, r0
 801a592:	4698      	mov	r8, r3
  CS_Status_t retval = CELLULAR_ERROR;

  size_t ip_addr_length;

  /* check that socket has been allocated */
  if (cs_ctxt_sockets_info[sockhandle].state == SOCKETSTATE_NOT_ALLOC)
 801a594:	4d6c      	ldr	r5, [pc, #432]	; (801a748 <csint_socket_configure_remote+0x1bc>)
 801a596:	236c      	movs	r3, #108	; 0x6c
 801a598:	fb03 5500 	mla	r5, r3, r0, r5
 801a59c:	792b      	ldrb	r3, [r5, #4]
 801a59e:	b373      	cbz	r3, 801a5fe <csint_socket_configure_remote+0x72>
 801a5a0:	460f      	mov	r7, r1
 801a5a2:	4616      	mov	r6, r2
  {
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (cfg remote)", sockhandle)
  }
  /* check p_ip_addr_value ptr */
  else if (p_ip_addr_value == NULL)
 801a5a4:	2a00      	cmp	r2, #0
 801a5a6:	d045      	beq.n	801a634 <csint_socket_configure_remote+0xa8>
  {
    PRINT_ERR("<Cellular_Service> NULL ptr")
  }
  else
  {
    ip_addr_length = strlen((const CRC_CHAR_t *)p_ip_addr_value);
 801a5a8:	4610      	mov	r0, r2
 801a5aa:	f7e5 fe23 	bl	80001f4 <strlen>
 801a5ae:	4605      	mov	r5, r0
    if (ip_addr_length > MAX_IP_ADDR_SIZE)
 801a5b0:	2840      	cmp	r0, #64	; 0x40
 801a5b2:	d968      	bls.n	801a686 <csint_socket_configure_remote+0xfa>
    {
      PRINT_ERR("<Cellular_Service> IP address too long")
 801a5b4:	4e65      	ldr	r6, [pc, #404]	; (801a74c <csint_socket_configure_remote+0x1c0>)
 801a5b6:	4d66      	ldr	r5, [pc, #408]	; (801a750 <csint_socket_configure_remote+0x1c4>)
 801a5b8:	f106 0730 	add.w	r7, r6, #48	; 0x30
 801a5bc:	4634      	mov	r4, r6
 801a5be:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a5c0:	6028      	str	r0, [r5, #0]
 801a5c2:	6069      	str	r1, [r5, #4]
 801a5c4:	60aa      	str	r2, [r5, #8]
 801a5c6:	60eb      	str	r3, [r5, #12]
 801a5c8:	4626      	mov	r6, r4
 801a5ca:	3510      	adds	r5, #16
 801a5cc:	42bc      	cmp	r4, r7
 801a5ce:	d1f5      	bne.n	801a5bc <csint_socket_configure_remote+0x30>
 801a5d0:	8823      	ldrh	r3, [r4, #0]
 801a5d2:	802b      	strh	r3, [r5, #0]
 801a5d4:	4c5e      	ldr	r4, [pc, #376]	; (801a750 <csint_socket_configure_remote+0x1c4>)
 801a5d6:	4620      	mov	r0, r4
 801a5d8:	f004 fd9b 	bl	801f112 <crs_strlen>
 801a5dc:	b283      	uxth	r3, r0
 801a5de:	4622      	mov	r2, r4
 801a5e0:	2110      	movs	r1, #16
 801a5e2:	2001      	movs	r0, #1
 801a5e4:	f004 fdd8 	bl	801f198 <traceIF_itmPrint>
 801a5e8:	4620      	mov	r0, r4
 801a5ea:	f004 fd92 	bl	801f112 <crs_strlen>
 801a5ee:	b283      	uxth	r3, r0
 801a5f0:	4622      	mov	r2, r4
 801a5f2:	2110      	movs	r1, #16
 801a5f4:	2001      	movs	r0, #1
 801a5f6:	f004 fdf1 	bl	801f1dc <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 801a5fa:	2001      	movs	r0, #1
 801a5fc:	e018      	b.n	801a630 <csint_socket_configure_remote+0xa4>
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (cfg remote)", sockhandle)
 801a5fe:	4d54      	ldr	r5, [pc, #336]	; (801a750 <csint_socket_configure_remote+0x1c4>)
 801a600:	4602      	mov	r2, r0
 801a602:	4954      	ldr	r1, [pc, #336]	; (801a754 <csint_socket_configure_remote+0x1c8>)
 801a604:	4628      	mov	r0, r5
 801a606:	f00b fb33 	bl	8025c70 <sprintf>
 801a60a:	4628      	mov	r0, r5
 801a60c:	f004 fd81 	bl	801f112 <crs_strlen>
 801a610:	b283      	uxth	r3, r0
 801a612:	462a      	mov	r2, r5
 801a614:	2110      	movs	r1, #16
 801a616:	2001      	movs	r0, #1
 801a618:	f004 fdbe 	bl	801f198 <traceIF_itmPrint>
 801a61c:	4628      	mov	r0, r5
 801a61e:	f004 fd78 	bl	801f112 <crs_strlen>
 801a622:	b283      	uxth	r3, r0
 801a624:	462a      	mov	r2, r5
 801a626:	2110      	movs	r1, #16
 801a628:	2001      	movs	r0, #1
 801a62a:	f004 fdd7 	bl	801f1dc <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 801a62e:	2001      	movs	r0, #1
      PRINT_DBG("DBG: ip_addr cb=%s", cs_ctxt_sockets_info[sockhandle].ip_addr_value)
    }
  }

  return (retval);
}
 801a630:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("<Cellular_Service> NULL ptr")
 801a634:	4e48      	ldr	r6, [pc, #288]	; (801a758 <csint_socket_configure_remote+0x1cc>)
 801a636:	4c46      	ldr	r4, [pc, #280]	; (801a750 <csint_socket_configure_remote+0x1c4>)
 801a638:	f106 0720 	add.w	r7, r6, #32
 801a63c:	4635      	mov	r5, r6
 801a63e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a640:	6020      	str	r0, [r4, #0]
 801a642:	6061      	str	r1, [r4, #4]
 801a644:	60a2      	str	r2, [r4, #8]
 801a646:	60e3      	str	r3, [r4, #12]
 801a648:	462e      	mov	r6, r5
 801a64a:	3410      	adds	r4, #16
 801a64c:	42bd      	cmp	r5, r7
 801a64e:	d1f5      	bne.n	801a63c <csint_socket_configure_remote+0xb0>
 801a650:	6828      	ldr	r0, [r5, #0]
 801a652:	6020      	str	r0, [r4, #0]
 801a654:	88aa      	ldrh	r2, [r5, #4]
 801a656:	79ab      	ldrb	r3, [r5, #6]
 801a658:	80a2      	strh	r2, [r4, #4]
 801a65a:	71a3      	strb	r3, [r4, #6]
 801a65c:	4c3c      	ldr	r4, [pc, #240]	; (801a750 <csint_socket_configure_remote+0x1c4>)
 801a65e:	4620      	mov	r0, r4
 801a660:	f004 fd57 	bl	801f112 <crs_strlen>
 801a664:	b283      	uxth	r3, r0
 801a666:	4622      	mov	r2, r4
 801a668:	2110      	movs	r1, #16
 801a66a:	2001      	movs	r0, #1
 801a66c:	f004 fd94 	bl	801f198 <traceIF_itmPrint>
 801a670:	4620      	mov	r0, r4
 801a672:	f004 fd4e 	bl	801f112 <crs_strlen>
 801a676:	b283      	uxth	r3, r0
 801a678:	4622      	mov	r2, r4
 801a67a:	2110      	movs	r1, #16
 801a67c:	2001      	movs	r0, #1
 801a67e:	f004 fdad 	bl	801f1dc <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 801a682:	2001      	movs	r0, #1
 801a684:	e7d4      	b.n	801a630 <csint_socket_configure_remote+0xa4>
      cs_ctxt_sockets_info[sockhandle].remote_port = remote_port;
 801a686:	4b30      	ldr	r3, [pc, #192]	; (801a748 <csint_socket_configure_remote+0x1bc>)
 801a688:	226c      	movs	r2, #108	; 0x6c
 801a68a:	fb02 f404 	mul.w	r4, r2, r4
 801a68e:	eb03 0904 	add.w	r9, r3, r4
 801a692:	f8a9 804e 	strh.w	r8, [r9, #78]	; 0x4e
      cs_ctxt_sockets_info[sockhandle].ip_addr_type = ip_addr_type;
 801a696:	f889 700d 	strb.w	r7, [r9, #13]
      (void) memset((void *) &cs_ctxt_sockets_info[sockhandle].ip_addr_value, 0, MAX_IP_ADDR_SIZE);
 801a69a:	3408      	adds	r4, #8
 801a69c:	191f      	adds	r7, r3, r4
 801a69e:	3706      	adds	r7, #6
 801a6a0:	2240      	movs	r2, #64	; 0x40
 801a6a2:	2100      	movs	r1, #0
 801a6a4:	4638      	mov	r0, r7
 801a6a6:	f00b fb56 	bl	8025d56 <memset>
      (void) memcpy((void *) &cs_ctxt_sockets_info[sockhandle].ip_addr_value, (void *)p_ip_addr_value,
 801a6aa:	462a      	mov	r2, r5
 801a6ac:	4631      	mov	r1, r6
 801a6ae:	4638      	mov	r0, r7
 801a6b0:	f00b fc2e 	bl	8025f10 <memcpy>
      PRINT_DBG("DBG: remote_port=%d", cs_ctxt_sockets_info[sockhandle].remote_port)
 801a6b4:	4c26      	ldr	r4, [pc, #152]	; (801a750 <csint_socket_configure_remote+0x1c4>)
 801a6b6:	f8b9 204e 	ldrh.w	r2, [r9, #78]	; 0x4e
 801a6ba:	4928      	ldr	r1, [pc, #160]	; (801a75c <csint_socket_configure_remote+0x1d0>)
 801a6bc:	4620      	mov	r0, r4
 801a6be:	f00b fad7 	bl	8025c70 <sprintf>
 801a6c2:	4620      	mov	r0, r4
 801a6c4:	f004 fd25 	bl	801f112 <crs_strlen>
 801a6c8:	b283      	uxth	r3, r0
 801a6ca:	4622      	mov	r2, r4
 801a6cc:	2102      	movs	r1, #2
 801a6ce:	2001      	movs	r0, #1
 801a6d0:	f004 fd62 	bl	801f198 <traceIF_itmPrint>
 801a6d4:	4620      	mov	r0, r4
 801a6d6:	f004 fd1c 	bl	801f112 <crs_strlen>
 801a6da:	b283      	uxth	r3, r0
 801a6dc:	4622      	mov	r2, r4
 801a6de:	2102      	movs	r1, #2
 801a6e0:	2001      	movs	r0, #1
 801a6e2:	f004 fd7b 	bl	801f1dc <traceIF_uartPrint>
      PRINT_DBG("DBG: ip_addr_type=%d", cs_ctxt_sockets_info[sockhandle].ip_addr_type)
 801a6e6:	f899 200d 	ldrb.w	r2, [r9, #13]
 801a6ea:	491d      	ldr	r1, [pc, #116]	; (801a760 <csint_socket_configure_remote+0x1d4>)
 801a6ec:	4620      	mov	r0, r4
 801a6ee:	f00b fabf 	bl	8025c70 <sprintf>
 801a6f2:	4620      	mov	r0, r4
 801a6f4:	f004 fd0d 	bl	801f112 <crs_strlen>
 801a6f8:	b283      	uxth	r3, r0
 801a6fa:	4622      	mov	r2, r4
 801a6fc:	2102      	movs	r1, #2
 801a6fe:	2001      	movs	r0, #1
 801a700:	f004 fd4a 	bl	801f198 <traceIF_itmPrint>
 801a704:	4620      	mov	r0, r4
 801a706:	f004 fd04 	bl	801f112 <crs_strlen>
 801a70a:	b283      	uxth	r3, r0
 801a70c:	4622      	mov	r2, r4
 801a70e:	2102      	movs	r1, #2
 801a710:	2001      	movs	r0, #1
 801a712:	f004 fd63 	bl	801f1dc <traceIF_uartPrint>
      PRINT_DBG("DBG: ip_addr cb=%s", cs_ctxt_sockets_info[sockhandle].ip_addr_value)
 801a716:	463a      	mov	r2, r7
 801a718:	4912      	ldr	r1, [pc, #72]	; (801a764 <csint_socket_configure_remote+0x1d8>)
 801a71a:	4620      	mov	r0, r4
 801a71c:	f00b faa8 	bl	8025c70 <sprintf>
 801a720:	4620      	mov	r0, r4
 801a722:	f004 fcf6 	bl	801f112 <crs_strlen>
 801a726:	b283      	uxth	r3, r0
 801a728:	4622      	mov	r2, r4
 801a72a:	2102      	movs	r1, #2
 801a72c:	2001      	movs	r0, #1
 801a72e:	f004 fd33 	bl	801f198 <traceIF_itmPrint>
 801a732:	4620      	mov	r0, r4
 801a734:	f004 fced 	bl	801f112 <crs_strlen>
 801a738:	b283      	uxth	r3, r0
 801a73a:	4622      	mov	r2, r4
 801a73c:	2102      	movs	r1, #2
 801a73e:	2001      	movs	r0, #1
 801a740:	f004 fd4c 	bl	801f1dc <traceIF_uartPrint>
      retval = CELLULAR_OK;
 801a744:	2000      	movs	r0, #0
 801a746:	e773      	b.n	801a630 <csint_socket_configure_remote+0xa4>
 801a748:	20003d18 	.word	0x20003d18
 801a74c:	08032084 	.word	0x08032084
 801a750:	200047dc 	.word	0x200047dc
 801a754:	0803396c 	.word	0x0803396c
 801a758:	0803205c 	.word	0x0803205c
 801a75c:	080339b4 	.word	0x080339b4
 801a760:	080339d0 	.word	0x080339d0
 801a764:	080339ec 	.word	0x080339ec

0801a768 <osCS_get_signal_quality>:
  * @note   Call CS_get_signal_quality with mutex access protection
  * @param  same parameters as the CS_get_signal_quality function
  * @retval CS_Status_t
  */
CS_Status_t osCS_get_signal_quality(CS_SignalQuality_t *p_sig_qual)
{
 801a768:	b538      	push	{r3, r4, r5, lr}
 801a76a:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a76c:	4d07      	ldr	r5, [pc, #28]	; (801a78c <osCS_get_signal_quality+0x24>)
 801a76e:	f04f 31ff 	mov.w	r1, #4294967295
 801a772:	6828      	ldr	r0, [r5, #0]
 801a774:	f004 fbe7 	bl	801ef46 <rtosalMutexAcquire>

  result = CS_get_signal_quality(p_sig_qual);
 801a778:	4620      	mov	r0, r4
 801a77a:	f7fc f8db 	bl	8016934 <CS_get_signal_quality>
 801a77e:	4604      	mov	r4, r0

  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a780:	6828      	ldr	r0, [r5, #0]
 801a782:	f004 fbe4 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801a786:	4620      	mov	r0, r4
 801a788:	bd38      	pop	{r3, r4, r5, pc}
 801a78a:	bf00      	nop
 801a78c:	20003fa8 	.word	0x20003fa8

0801a790 <osCDS_socket_create>:
  * @retval Socket handle which references allocated socket
  */
socket_handle_t osCDS_socket_create(CS_IPaddrType_t addr_type,
                                    CS_TransportProtocol_t protocol,
                                    CS_PDN_conf_id_t cid)
{
 801a790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a792:	4604      	mov	r4, r0
 801a794:	460d      	mov	r5, r1
 801a796:	4616      	mov	r6, r2
  socket_handle_t socket_handle;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a798:	4f08      	ldr	r7, [pc, #32]	; (801a7bc <osCDS_socket_create+0x2c>)
 801a79a:	f04f 31ff 	mov.w	r1, #4294967295
 801a79e:	6838      	ldr	r0, [r7, #0]
 801a7a0:	f004 fbd1 	bl	801ef46 <rtosalMutexAcquire>

  socket_handle = CDS_socket_create(addr_type,
 801a7a4:	4632      	mov	r2, r6
 801a7a6:	4629      	mov	r1, r5
 801a7a8:	4620      	mov	r0, r4
 801a7aa:	f7fc fcfd 	bl	80171a8 <CDS_socket_create>
 801a7ae:	4604      	mov	r4, r0
                                    protocol,
                                    cid);
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a7b0:	6838      	ldr	r0, [r7, #0]
 801a7b2:	f004 fbcc 	bl	801ef4e <rtosalMutexRelease>

  return (socket_handle);
}
 801a7b6:	4620      	mov	r0, r4
 801a7b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801a7ba:	bf00      	nop
 801a7bc:	20003fa8 	.word	0x20003fa8

0801a7c0 <osCDS_socket_set_callbacks>:
  */
CS_Status_t osCDS_socket_set_callbacks(socket_handle_t sockHandle,
                                       cellular_socket_data_ready_callback_t data_ready_cb,
                                       cellular_socket_data_sent_callback_t data_sent_cb,
                                       cellular_socket_closed_callback_t remote_close_cb)
{
 801a7c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a7c4:	4604      	mov	r4, r0
 801a7c6:	460d      	mov	r5, r1
 801a7c8:	4616      	mov	r6, r2
 801a7ca:	461f      	mov	r7, r3
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a7cc:	f8df 8028 	ldr.w	r8, [pc, #40]	; 801a7f8 <osCDS_socket_set_callbacks+0x38>
 801a7d0:	f04f 31ff 	mov.w	r1, #4294967295
 801a7d4:	f8d8 0000 	ldr.w	r0, [r8]
 801a7d8:	f004 fbb5 	bl	801ef46 <rtosalMutexAcquire>

  result = CDS_socket_set_callbacks(sockHandle,
 801a7dc:	463b      	mov	r3, r7
 801a7de:	4632      	mov	r2, r6
 801a7e0:	4629      	mov	r1, r5
 801a7e2:	4620      	mov	r0, r4
 801a7e4:	f7fc fdfc 	bl	80173e0 <CDS_socket_set_callbacks>
 801a7e8:	4604      	mov	r4, r0
                                    data_ready_cb,
                                    data_sent_cb,
                                    remote_close_cb);

  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a7ea:	f8d8 0000 	ldr.w	r0, [r8]
 801a7ee:	f004 fbae 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801a7f2:	4620      	mov	r0, r4
 801a7f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801a7f8:	20003fa8 	.word	0x20003fa8

0801a7fc <osCDS_socket_bind>:
  * @param  same parameters as the CDS_socket_bind function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_socket_bind(socket_handle_t sockHandle,
                              uint16_t local_port)
{
 801a7fc:	b570      	push	{r4, r5, r6, lr}
 801a7fe:	4604      	mov	r4, r0
 801a800:	460d      	mov	r5, r1
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801a802:	f001 fe5d 	bl	801c4c0 <CST_get_state>
 801a806:	2808      	cmp	r0, #8
 801a808:	d002      	beq.n	801a810 <osCDS_socket_bind+0x14>
  CS_Status_t result = CELLULAR_ERROR;
 801a80a:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801a80c:	4620      	mov	r0, r4
 801a80e:	bd70      	pop	{r4, r5, r6, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a810:	4e07      	ldr	r6, [pc, #28]	; (801a830 <osCDS_socket_bind+0x34>)
 801a812:	f04f 31ff 	mov.w	r1, #4294967295
 801a816:	6830      	ldr	r0, [r6, #0]
 801a818:	f004 fb95 	bl	801ef46 <rtosalMutexAcquire>
    result = CDS_socket_bind(sockHandle,
 801a81c:	4629      	mov	r1, r5
 801a81e:	4620      	mov	r0, r4
 801a820:	f7fc fd6a 	bl	80172f8 <CDS_socket_bind>
 801a824:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a826:	6830      	ldr	r0, [r6, #0]
 801a828:	f004 fb91 	bl	801ef4e <rtosalMutexRelease>
 801a82c:	e7ee      	b.n	801a80c <osCDS_socket_bind+0x10>
 801a82e:	bf00      	nop
 801a830:	20003fa8 	.word	0x20003fa8

0801a834 <osCDS_socket_connect>:
  */
CS_Status_t osCDS_socket_connect(socket_handle_t sockHandle,
                                 CS_IPaddrType_t addr_type,
                                 CS_CHAR_t *p_ip_addr_value,
                                 uint16_t remote_port)
{
 801a834:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a838:	4607      	mov	r7, r0
 801a83a:	460c      	mov	r4, r1
 801a83c:	4615      	mov	r5, r2
 801a83e:	461e      	mov	r6, r3
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801a840:	f001 fe3e 	bl	801c4c0 <CST_get_state>
 801a844:	2808      	cmp	r0, #8
 801a846:	d003      	beq.n	801a850 <osCDS_socket_connect+0x1c>
  CS_Status_t result = CELLULAR_ERROR;
 801a848:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801a84a:	4620      	mov	r0, r4
 801a84c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a850:	f8df 8024 	ldr.w	r8, [pc, #36]	; 801a878 <osCDS_socket_connect+0x44>
 801a854:	f04f 31ff 	mov.w	r1, #4294967295
 801a858:	f8d8 0000 	ldr.w	r0, [r8]
 801a85c:	f004 fb73 	bl	801ef46 <rtosalMutexAcquire>
    result = CDS_socket_connect(sockHandle,
 801a860:	4633      	mov	r3, r6
 801a862:	462a      	mov	r2, r5
 801a864:	4621      	mov	r1, r4
 801a866:	4638      	mov	r0, r7
 801a868:	f7fc fe9c 	bl	80175a4 <CDS_socket_connect>
 801a86c:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a86e:	f8d8 0000 	ldr.w	r0, [r8]
 801a872:	f004 fb6c 	bl	801ef4e <rtosalMutexRelease>
 801a876:	e7e8      	b.n	801a84a <osCDS_socket_connect+0x16>
 801a878:	20003fa8 	.word	0x20003fa8

0801a87c <osCDS_socket_send>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_socket_send(socket_handle_t sockHandle,
                              const CS_CHAR_t *p_buf,
                              uint32_t length)
{
 801a87c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a87e:	4604      	mov	r4, r0
 801a880:	460d      	mov	r5, r1
 801a882:	4616      	mov	r6, r2
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801a884:	f001 fe1c 	bl	801c4c0 <CST_get_state>
 801a888:	2808      	cmp	r0, #8
 801a88a:	d002      	beq.n	801a892 <osCDS_socket_send+0x16>
  CS_Status_t result = CELLULAR_ERROR;
 801a88c:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801a88e:	4620      	mov	r0, r4
 801a890:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a892:	4f08      	ldr	r7, [pc, #32]	; (801a8b4 <osCDS_socket_send+0x38>)
 801a894:	f04f 31ff 	mov.w	r1, #4294967295
 801a898:	6838      	ldr	r0, [r7, #0]
 801a89a:	f004 fb54 	bl	801ef46 <rtosalMutexAcquire>
    result = CDS_socket_send(sockHandle,
 801a89e:	4632      	mov	r2, r6
 801a8a0:	4629      	mov	r1, r5
 801a8a2:	4620      	mov	r0, r4
 801a8a4:	f7fc ff06 	bl	80176b4 <CDS_socket_send>
 801a8a8:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a8aa:	6838      	ldr	r0, [r7, #0]
 801a8ac:	f004 fb4f 	bl	801ef4e <rtosalMutexRelease>
 801a8b0:	e7ed      	b.n	801a88e <osCDS_socket_send+0x12>
 801a8b2:	bf00      	nop
 801a8b4:	20003fa8 	.word	0x20003fa8

0801a8b8 <osCDS_socket_sendto>:
                                uint32_t length,
                                CS_IPaddrType_t addr_type,
                                CS_CHAR_t *p_ip_addr_value,
                                uint16_t remote_port)

{
 801a8b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a8bc:	b082      	sub	sp, #8
 801a8be:	4607      	mov	r7, r0
 801a8c0:	460e      	mov	r6, r1
 801a8c2:	4615      	mov	r5, r2
 801a8c4:	461c      	mov	r4, r3
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801a8c6:	f001 fdfb 	bl	801c4c0 <CST_get_state>
 801a8ca:	2808      	cmp	r0, #8
 801a8cc:	d004      	beq.n	801a8d8 <osCDS_socket_sendto+0x20>
  CS_Status_t result = CELLULAR_ERROR;
 801a8ce:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801a8d0:	4620      	mov	r0, r4
 801a8d2:	b002      	add	sp, #8
 801a8d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a8d8:	f8df 8030 	ldr.w	r8, [pc, #48]	; 801a90c <osCDS_socket_sendto+0x54>
 801a8dc:	f04f 31ff 	mov.w	r1, #4294967295
 801a8e0:	f8d8 0000 	ldr.w	r0, [r8]
 801a8e4:	f004 fb2f 	bl	801ef46 <rtosalMutexAcquire>
    result = CDS_socket_sendto(sockHandle,
 801a8e8:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 801a8ec:	9301      	str	r3, [sp, #4]
 801a8ee:	9b08      	ldr	r3, [sp, #32]
 801a8f0:	9300      	str	r3, [sp, #0]
 801a8f2:	4623      	mov	r3, r4
 801a8f4:	462a      	mov	r2, r5
 801a8f6:	4631      	mov	r1, r6
 801a8f8:	4638      	mov	r0, r7
 801a8fa:	f7fc ffb3 	bl	8017864 <CDS_socket_sendto>
 801a8fe:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a900:	f8d8 0000 	ldr.w	r0, [r8]
 801a904:	f004 fb23 	bl	801ef4e <rtosalMutexRelease>
 801a908:	e7e2      	b.n	801a8d0 <osCDS_socket_sendto+0x18>
 801a90a:	bf00      	nop
 801a90c:	20003fa8 	.word	0x20003fa8

0801a910 <osCDS_socket_close>:
  * @param  same parameters as the CDS_socket_close function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_socket_close(socket_handle_t sockHandle,
                               uint8_t force)
{
 801a910:	b570      	push	{r4, r5, r6, lr}
 801a912:	4604      	mov	r4, r0
 801a914:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a916:	4e08      	ldr	r6, [pc, #32]	; (801a938 <osCDS_socket_close+0x28>)
 801a918:	f04f 31ff 	mov.w	r1, #4294967295
 801a91c:	6830      	ldr	r0, [r6, #0]
 801a91e:	f004 fb12 	bl	801ef46 <rtosalMutexAcquire>

  result = CDS_socket_close(sockHandle,
 801a922:	4629      	mov	r1, r5
 801a924:	4620      	mov	r0, r4
 801a926:	f7fd f8d3 	bl	8017ad0 <CDS_socket_close>
 801a92a:	4604      	mov	r4, r0
                            force);

  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a92c:	6830      	ldr	r0, [r6, #0]
 801a92e:	f004 fb0e 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801a932:	4620      	mov	r0, r4
 801a934:	bd70      	pop	{r4, r5, r6, pc}
 801a936:	bf00      	nop
 801a938:	20003fa8 	.word	0x20003fa8

0801a93c <osCDS_cellular_service_init>:
  * @brief  cellular service initialization
  * @param  none
  * @retval CS_Bool_t   cellular initialized or not
  */
CS_Bool_t osCDS_cellular_service_init(void)
{
 801a93c:	b538      	push	{r3, r4, r5, lr}
  static CS_Bool_t CellularServiceInitialized = CELLULAR_FALSE;
  CS_Bool_t result;

  result = CELLULAR_TRUE;
  if (CellularServiceInitialized == CELLULAR_FALSE)
 801a93e:	4b12      	ldr	r3, [pc, #72]	; (801a988 <osCDS_cellular_service_init+0x4c>)
 801a940:	781c      	ldrb	r4, [r3, #0]
 801a942:	b114      	cbz	r4, 801a94a <osCDS_cellular_service_init+0xe>
  result = CELLULAR_TRUE;
 801a944:	2501      	movs	r5, #1
     */
    CellularServiceInitialized = CELLULAR_TRUE;
  }

  return result;
}
 801a946:	4628      	mov	r0, r5
 801a948:	bd38      	pop	{r3, r4, r5, pc}
    CellularServiceMutexHandle = rtosalMutexNew(NULL);
 801a94a:	2000      	movs	r0, #0
 801a94c:	f004 faf1 	bl	801ef32 <rtosalMutexNew>
 801a950:	4b0e      	ldr	r3, [pc, #56]	; (801a98c <osCDS_cellular_service_init+0x50>)
 801a952:	6018      	str	r0, [r3, #0]
    if (CellularServiceMutexHandle == NULL)
 801a954:	b150      	cbz	r0, 801a96c <osCDS_cellular_service_init+0x30>
  result = CELLULAR_TRUE;
 801a956:	2501      	movs	r5, #1
    CellularServiceGeneralMutexHandle = rtosalMutexNew(NULL);
 801a958:	2000      	movs	r0, #0
 801a95a:	f004 faea 	bl	801ef32 <rtosalMutexNew>
 801a95e:	4b0c      	ldr	r3, [pc, #48]	; (801a990 <osCDS_cellular_service_init+0x54>)
 801a960:	6018      	str	r0, [r3, #0]
    if (CellularServiceGeneralMutexHandle == NULL)
 801a962:	b150      	cbz	r0, 801a97a <osCDS_cellular_service_init+0x3e>
    CellularServiceInitialized = CELLULAR_TRUE;
 801a964:	4b08      	ldr	r3, [pc, #32]	; (801a988 <osCDS_cellular_service_init+0x4c>)
 801a966:	2201      	movs	r2, #1
 801a968:	701a      	strb	r2, [r3, #0]
 801a96a:	e7ec      	b.n	801a946 <osCDS_cellular_service_init+0xa>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 1, ERROR_FATAL);
 801a96c:	2203      	movs	r2, #3
 801a96e:	2101      	movs	r1, #1
 801a970:	2007      	movs	r0, #7
 801a972:	f003 fbeb 	bl	801e14c <ERROR_Handler>
      result = CELLULAR_FALSE;
 801a976:	4625      	mov	r5, r4
 801a978:	e7ee      	b.n	801a958 <osCDS_cellular_service_init+0x1c>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 2, ERROR_FATAL);
 801a97a:	2203      	movs	r2, #3
 801a97c:	2102      	movs	r1, #2
 801a97e:	2007      	movs	r0, #7
 801a980:	f003 fbe4 	bl	801e14c <ERROR_Handler>
      result = CELLULAR_FALSE;
 801a984:	4625      	mov	r5, r4
 801a986:	e7ed      	b.n	801a964 <osCDS_cellular_service_init+0x28>
 801a988:	20003fa4 	.word	0x20003fa4
 801a98c:	20003fa8 	.word	0x20003fa8
 801a990:	20003fa0 	.word	0x20003fa0

0801a994 <osCDS_get_net_status>:
  * @note   Call CS_get_net_status with mutex access protection
  * @param  same parameters as the CS_get_net_status function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_net_status(CS_RegistrationStatus_t *p_reg_status)
{
 801a994:	b538      	push	{r3, r4, r5, lr}
 801a996:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a998:	4d07      	ldr	r5, [pc, #28]	; (801a9b8 <osCDS_get_net_status+0x24>)
 801a99a:	f04f 31ff 	mov.w	r1, #4294967295
 801a99e:	6828      	ldr	r0, [r5, #0]
 801a9a0:	f004 fad1 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_get_net_status(p_reg_status);
 801a9a4:	4620      	mov	r0, r4
 801a9a6:	f7fb ff2b 	bl	8016800 <CS_get_net_status>
 801a9aa:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a9ac:	6828      	ldr	r0, [r5, #0]
 801a9ae:	f004 face 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801a9b2:	4620      	mov	r0, r4
 801a9b4:	bd38      	pop	{r3, r4, r5, pc}
 801a9b6:	bf00      	nop
 801a9b8:	20003fa8 	.word	0x20003fa8

0801a9bc <osCDS_get_device_info>:
  * @note   Call CS_get_device_info with mutex access protection
  * @param  same parameters as the CS_get_device_info function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_device_info(CS_DeviceInfo_t *p_devinfo)
{
 801a9bc:	b538      	push	{r3, r4, r5, lr}
 801a9be:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a9c0:	4d07      	ldr	r5, [pc, #28]	; (801a9e0 <osCDS_get_device_info+0x24>)
 801a9c2:	f04f 31ff 	mov.w	r1, #4294967295
 801a9c6:	6828      	ldr	r0, [r5, #0]
 801a9c8:	f004 fabd 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_get_device_info(p_devinfo);
 801a9cc:	4620      	mov	r0, r4
 801a9ce:	f7fb fbe7 	bl	80161a0 <CS_get_device_info>
 801a9d2:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a9d4:	6828      	ldr	r0, [r5, #0]
 801a9d6:	f004 faba 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801a9da:	4620      	mov	r0, r4
 801a9dc:	bd38      	pop	{r3, r4, r5, pc}
 801a9de:	bf00      	nop
 801a9e0:	20003fa8 	.word	0x20003fa8

0801a9e4 <osCDS_subscribe_net_event>:
  * @param  urc_callback Handle on user callback that will be used to notify a
  *                      change on requested event.
  * @retval CS_Status_t
  */
CS_Status_t osCDS_subscribe_net_event(CS_UrcEvent_t event, cellular_urc_callback_t urc_callback)
{
 801a9e4:	b570      	push	{r4, r5, r6, lr}
 801a9e6:	4604      	mov	r4, r0
 801a9e8:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a9ea:	4e08      	ldr	r6, [pc, #32]	; (801aa0c <osCDS_subscribe_net_event+0x28>)
 801a9ec:	f04f 31ff 	mov.w	r1, #4294967295
 801a9f0:	6830      	ldr	r0, [r6, #0]
 801a9f2:	f004 faa8 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_subscribe_net_event(event,  urc_callback);
 801a9f6:	4629      	mov	r1, r5
 801a9f8:	4620      	mov	r0, r4
 801a9fa:	f7fb fd11 	bl	8016420 <CS_subscribe_net_event>
 801a9fe:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa00:	6830      	ldr	r0, [r6, #0]
 801aa02:	f004 faa4 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aa06:	4620      	mov	r0, r4
 801aa08:	bd70      	pop	{r4, r5, r6, pc}
 801aa0a:	bf00      	nop
 801aa0c:	20003fa8 	.word	0x20003fa8

0801aa10 <osCDS_subscribe_modem_event>:
  * @param  same parameters as the CS_subscribe_modem_event function
  *         change on requested event.
  * @retval CS_Status_t
  */
CS_Status_t osCDS_subscribe_modem_event(CS_ModemEvent_t events_mask, cellular_modem_event_callback_t modem_evt_cb)
{
 801aa10:	b570      	push	{r4, r5, r6, lr}
 801aa12:	4604      	mov	r4, r0
 801aa14:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aa16:	4e08      	ldr	r6, [pc, #32]	; (801aa38 <osCDS_subscribe_modem_event+0x28>)
 801aa18:	f04f 31ff 	mov.w	r1, #4294967295
 801aa1c:	6830      	ldr	r0, [r6, #0]
 801aa1e:	f004 fa92 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_subscribe_modem_event(events_mask, modem_evt_cb);
 801aa22:	4629      	mov	r1, r5
 801aa24:	4620      	mov	r0, r4
 801aa26:	f7fc fa6b 	bl	8016f00 <CS_subscribe_modem_event>
 801aa2a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa2c:	6830      	ldr	r0, [r6, #0]
 801aa2e:	f004 fa8e 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aa32:	4620      	mov	r0, r4
 801aa34:	bd70      	pop	{r4, r5, r6, pc}
 801aa36:	bf00      	nop
 801aa38:	20003fa8 	.word	0x20003fa8

0801aa3c <osCDS_power_on>:
  * @note   Call CS_power_on with mutex access protection
  * @param  none
  * @retval CS_Status_t
  */
CS_Status_t osCDS_power_on(void)
{
 801aa3c:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aa3e:	4d07      	ldr	r5, [pc, #28]	; (801aa5c <osCDS_power_on+0x20>)
 801aa40:	f04f 31ff 	mov.w	r1, #4294967295
 801aa44:	6828      	ldr	r0, [r5, #0]
 801aa46:	f004 fa7e 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_power_on();
 801aa4a:	f7fb f941 	bl	8015cd0 <CS_power_on>
 801aa4e:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa50:	6828      	ldr	r0, [r5, #0]
 801aa52:	f004 fa7c 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aa56:	4620      	mov	r0, r4
 801aa58:	bd38      	pop	{r3, r4, r5, pc}
 801aa5a:	bf00      	nop
 801aa5c:	20003fa8 	.word	0x20003fa8

0801aa60 <osCDS_power_off>:
  * @note   Call CS_power_off with mutex access protection
  * @param  none
  * @retval CS_Status_t
  */
CS_Status_t osCDS_power_off(void)
{
 801aa60:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aa62:	4d07      	ldr	r5, [pc, #28]	; (801aa80 <osCDS_power_off+0x20>)
 801aa64:	f04f 31ff 	mov.w	r1, #4294967295
 801aa68:	6828      	ldr	r0, [r5, #0]
 801aa6a:	f004 fa6c 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_power_off();
 801aa6e:	f7fb f9c5 	bl	8015dfc <CS_power_off>
 801aa72:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa74:	6828      	ldr	r0, [r5, #0]
 801aa76:	f004 fa6a 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aa7a:	4620      	mov	r0, r4
 801aa7c:	bd38      	pop	{r3, r4, r5, pc}
 801aa7e:	bf00      	nop
 801aa80:	20003fa8 	.word	0x20003fa8

0801aa84 <osCDS_init_modem>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_init_modem(CS_ModemInit_t init,
                             CS_Bool_t reset,
                             const CS_CHAR_t *pin_code)
{
 801aa84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801aa86:	4604      	mov	r4, r0
 801aa88:	460d      	mov	r5, r1
 801aa8a:	4616      	mov	r6, r2
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aa8c:	4f08      	ldr	r7, [pc, #32]	; (801aab0 <osCDS_init_modem+0x2c>)
 801aa8e:	f04f 31ff 	mov.w	r1, #4294967295
 801aa92:	6838      	ldr	r0, [r7, #0]
 801aa94:	f004 fa57 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_init_modem(init,  reset, pin_code);
 801aa98:	4632      	mov	r2, r6
 801aa9a:	4629      	mov	r1, r5
 801aa9c:	4620      	mov	r0, r4
 801aa9e:	f7fb facf 	bl	8016040 <CS_init_modem>
 801aaa2:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aaa4:	6838      	ldr	r0, [r7, #0]
 801aaa6:	f004 fa52 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aaaa:	4620      	mov	r0, r4
 801aaac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801aaae:	bf00      	nop
 801aab0:	20003fa8 	.word	0x20003fa8

0801aab4 <osCDS_register_net>:
  * @param  same parameters as the CS_register_net function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_register_net(CS_OperatorSelector_t *p_operator,
                               CS_RegistrationStatus_t *p_reg_status)
{
 801aab4:	b570      	push	{r4, r5, r6, lr}
 801aab6:	4604      	mov	r4, r0
 801aab8:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aaba:	4e08      	ldr	r6, [pc, #32]	; (801aadc <osCDS_register_net+0x28>)
 801aabc:	f04f 31ff 	mov.w	r1, #4294967295
 801aac0:	6830      	ldr	r0, [r6, #0]
 801aac2:	f004 fa40 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_register_net(p_operator, p_reg_status);
 801aac6:	4629      	mov	r1, r5
 801aac8:	4620      	mov	r0, r4
 801aaca:	f7fb fc13 	bl	80162f4 <CS_register_net>
 801aace:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aad0:	6830      	ldr	r0, [r6, #0]
 801aad2:	f004 fa3c 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aad6:	4620      	mov	r0, r4
 801aad8:	bd70      	pop	{r4, r5, r6, pc}
 801aada:	bf00      	nop
 801aadc:	20003fa8 	.word	0x20003fa8

0801aae0 <osCDS_get_attach_status>:
  * @note   Call CDS_socket_set_callbacks with mutex access protection
  * @param  same parameters as the CDS_socket_set_callbacks function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_attach_status(CS_PSattach_t *p_attach)
{
 801aae0:	b538      	push	{r3, r4, r5, lr}
 801aae2:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aae4:	4d07      	ldr	r5, [pc, #28]	; (801ab04 <osCDS_get_attach_status+0x24>)
 801aae6:	f04f 31ff 	mov.w	r1, #4294967295
 801aaea:	6828      	ldr	r0, [r5, #0]
 801aaec:	f004 fa2b 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_get_attach_status(p_attach);
 801aaf0:	4620      	mov	r0, r4
 801aaf2:	f7fb fe09 	bl	8016708 <CS_get_attach_status>
 801aaf6:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aaf8:	6828      	ldr	r0, [r5, #0]
 801aafa:	f004 fa28 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aafe:	4620      	mov	r0, r4
 801ab00:	bd38      	pop	{r3, r4, r5, pc}
 801ab02:	bf00      	nop
 801ab04:	20003fa8 	.word	0x20003fa8

0801ab08 <osCDS_attach_PS_domain>:
  * @note   Call CS_attach_PS_domain with mutex access protection
  * @param  none.
  * @retval CS_Status_t
  */
CS_Status_t osCDS_attach_PS_domain(void)
{
 801ab08:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ab0a:	4d07      	ldr	r5, [pc, #28]	; (801ab28 <osCDS_attach_PS_domain+0x20>)
 801ab0c:	f04f 31ff 	mov.w	r1, #4294967295
 801ab10:	6828      	ldr	r0, [r5, #0]
 801ab12:	f004 fa18 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_attach_PS_domain();
 801ab16:	f7fb fd65 	bl	80165e4 <CS_attach_PS_domain>
 801ab1a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ab1c:	6828      	ldr	r0, [r5, #0]
 801ab1e:	f004 fa16 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801ab22:	4620      	mov	r0, r4
 801ab24:	bd38      	pop	{r3, r4, r5, pc}
 801ab26:	bf00      	nop
 801ab28:	20003fa8 	.word	0x20003fa8

0801ab2c <osCDS_define_pdn>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_define_pdn(CS_PDN_conf_id_t cid,
                             const CS_CHAR_t *apn,
                             CS_PDN_configuration_t *pdn_conf)
{
 801ab2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ab2e:	4604      	mov	r4, r0
 801ab30:	460d      	mov	r5, r1
 801ab32:	4616      	mov	r6, r2
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ab34:	4f08      	ldr	r7, [pc, #32]	; (801ab58 <osCDS_define_pdn+0x2c>)
 801ab36:	f04f 31ff 	mov.w	r1, #4294967295
 801ab3a:	6838      	ldr	r0, [r7, #0]
 801ab3c:	f004 fa03 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_define_pdn(cid, apn, pdn_conf);
 801ab40:	4632      	mov	r2, r6
 801ab42:	4629      	mov	r1, r5
 801ab44:	4620      	mov	r0, r4
 801ab46:	f7fb ffff 	bl	8016b48 <CS_define_pdn>
 801ab4a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ab4c:	6838      	ldr	r0, [r7, #0]
 801ab4e:	f004 f9fe 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801ab52:	4620      	mov	r0, r4
 801ab54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ab56:	bf00      	nop
 801ab58:	20003fa8 	.word	0x20003fa8

0801ab5c <osCDS_register_pdn_event>:
  * @param  same parameters as the CS_register_pdn_event function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_register_pdn_event(CS_PDN_conf_id_t cid,
                                     cellular_pdn_event_callback_t pdn_event_callback)
{
 801ab5c:	b570      	push	{r4, r5, r6, lr}
 801ab5e:	4604      	mov	r4, r0
 801ab60:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ab62:	4e08      	ldr	r6, [pc, #32]	; (801ab84 <osCDS_register_pdn_event+0x28>)
 801ab64:	f04f 31ff 	mov.w	r1, #4294967295
 801ab68:	6830      	ldr	r0, [r6, #0]
 801ab6a:	f004 f9ec 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_register_pdn_event(cid,  pdn_event_callback);
 801ab6e:	4629      	mov	r1, r5
 801ab70:	4620      	mov	r0, r4
 801ab72:	f7fc fa51 	bl	8017018 <CS_register_pdn_event>
 801ab76:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ab78:	6830      	ldr	r0, [r6, #0]
 801ab7a:	f004 f9e8 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801ab7e:	4620      	mov	r0, r4
 801ab80:	bd70      	pop	{r4, r5, r6, pc}
 801ab82:	bf00      	nop
 801ab84:	20003fa8 	.word	0x20003fa8

0801ab88 <osCDS_set_default_pdn>:
  * @note   Call CS_set_default_pdn with mutex access protection
  * @param  same parameters as the CS_set_default_pdn function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_set_default_pdn(CS_PDN_conf_id_t cid)
{
 801ab88:	b538      	push	{r3, r4, r5, lr}
 801ab8a:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ab8c:	4d07      	ldr	r5, [pc, #28]	; (801abac <osCDS_set_default_pdn+0x24>)
 801ab8e:	f04f 31ff 	mov.w	r1, #4294967295
 801ab92:	6828      	ldr	r0, [r5, #0]
 801ab94:	f004 f9d7 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_set_default_pdn(cid);
 801ab98:	4620      	mov	r0, r4
 801ab9a:	f7fc f887 	bl	8016cac <CS_set_default_pdn>
 801ab9e:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aba0:	6828      	ldr	r0, [r5, #0]
 801aba2:	f004 f9d4 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801aba6:	4620      	mov	r0, r4
 801aba8:	bd38      	pop	{r3, r4, r5, pc}
 801abaa:	bf00      	nop
 801abac:	20003fa8 	.word	0x20003fa8

0801abb0 <osCDS_activate_pdn>:
  * @note   Call CS_activate_pdn with mutex access protection
  * @param  same parameters as the CS_activate_pdn function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_activate_pdn(CS_PDN_conf_id_t cid)
{
 801abb0:	b538      	push	{r3, r4, r5, lr}
 801abb2:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801abb4:	4d07      	ldr	r5, [pc, #28]	; (801abd4 <osCDS_activate_pdn+0x24>)
 801abb6:	f04f 31ff 	mov.w	r1, #4294967295
 801abba:	6828      	ldr	r0, [r5, #0]
 801abbc:	f004 f9c3 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_activate_pdn(cid);
 801abc0:	4620      	mov	r0, r4
 801abc2:	f7fb ff4d 	bl	8016a60 <CS_activate_pdn>
 801abc6:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801abc8:	6828      	ldr	r0, [r5, #0]
 801abca:	f004 f9c0 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801abce:	4620      	mov	r0, r4
 801abd0:	bd38      	pop	{r3, r4, r5, pc}
 801abd2:	bf00      	nop
 801abd4:	20003fa8 	.word	0x20003fa8

0801abd8 <osCDS_direct_cmd>:
  * @param  same parameters as the CS_direct_cmd function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_direct_cmd(CS_direct_cmd_tx_t *direct_cmd_tx,
                             cellular_direct_cmd_callback_t direct_cmd_callback)
{
 801abd8:	b570      	push	{r4, r5, r6, lr}
 801abda:	4604      	mov	r4, r0
 801abdc:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801abde:	4e08      	ldr	r6, [pc, #32]	; (801ac00 <osCDS_direct_cmd+0x28>)
 801abe0:	f04f 31ff 	mov.w	r1, #4294967295
 801abe4:	6830      	ldr	r0, [r6, #0]
 801abe6:	f004 f9ae 	bl	801ef46 <rtosalMutexAcquire>
  result =  CS_direct_cmd(direct_cmd_tx, direct_cmd_callback);
 801abea:	4629      	mov	r1, r5
 801abec:	4620      	mov	r0, r4
 801abee:	f7fd f86b 	bl	8017cc8 <CS_direct_cmd>
 801abf2:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801abf4:	6830      	ldr	r0, [r6, #0]
 801abf6:	f004 f9aa 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801abfa:	4620      	mov	r0, r4
 801abfc:	bd70      	pop	{r4, r5, r6, pc}
 801abfe:	bf00      	nop
 801ac00:	20003fa8 	.word	0x20003fa8

0801ac04 <osCDS_get_dev_IP_address>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_dev_IP_address(CS_PDN_conf_id_t cid,
                                     CS_IPaddrType_t *ip_addr_type,
                                     CS_CHAR_t *p_ip_addr_value)
{
 801ac04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ac06:	4604      	mov	r4, r0
 801ac08:	460d      	mov	r5, r1
 801ac0a:	4616      	mov	r6, r2
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ac0c:	4f08      	ldr	r7, [pc, #32]	; (801ac30 <osCDS_get_dev_IP_address+0x2c>)
 801ac0e:	f04f 31ff 	mov.w	r1, #4294967295
 801ac12:	6838      	ldr	r0, [r7, #0]
 801ac14:	f004 f997 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_get_dev_IP_address(cid, ip_addr_type, p_ip_addr_value);
 801ac18:	4632      	mov	r2, r6
 801ac1a:	4629      	mov	r1, r5
 801ac1c:	4620      	mov	r0, r4
 801ac1e:	f7fc f8b9 	bl	8016d94 <CS_get_dev_IP_address>
 801ac22:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ac24:	6838      	ldr	r0, [r7, #0]
 801ac26:	f004 f992 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801ac2a:	4620      	mov	r0, r4
 801ac2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ac2e:	bf00      	nop
 801ac30:	20003fa8 	.word	0x20003fa8

0801ac34 <osCS_sim_select>:
  *         Call CS_sim_select with mutex access protection
  * @param  same parameters as the CS_sim_select function
  * @retval CS_Status_t
  */
CS_Status_t osCS_sim_select(CS_SimSlot_t simSelected)
{
 801ac34:	b538      	push	{r3, r4, r5, lr}
 801ac36:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ac38:	4d07      	ldr	r5, [pc, #28]	; (801ac58 <osCS_sim_select+0x24>)
 801ac3a:	f04f 31ff 	mov.w	r1, #4294967295
 801ac3e:	6828      	ldr	r0, [r5, #0]
 801ac40:	f004 f981 	bl	801ef46 <rtosalMutexAcquire>
  result = CS_sim_select(simSelected);
 801ac44:	4620      	mov	r0, r4
 801ac46:	f7fb f96f 	bl	8015f28 <CS_sim_select>
 801ac4a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ac4c:	6828      	ldr	r0, [r5, #0]
 801ac4e:	f004 f97e 	bl	801ef4e <rtosalMutexRelease>

  return (result);
}
 801ac52:	4620      	mov	r0, r4
 801ac54:	bd38      	pop	{r3, r4, r5, pc}
 801ac56:	bf00      	nop
 801ac58:	20003fa8 	.word	0x20003fa8

0801ac5c <CST_fota_timeout_event_mngt>:
  * @brief  FOTA timeout
  * @param  -
  * @retval -
  */
static void CST_fota_timeout_event_mngt(void)
{
 801ac5c:	b538      	push	{r3, r4, r5, lr}
  /* FOTA timeout has occurred : FAIL */

  PRINT_CELLULAR_SERVICE("CST FOTA FAIL : Timeout expired RESTART\n\r")
 801ac5e:	4c16      	ldr	r4, [pc, #88]	; (801acb8 <CST_fota_timeout_event_mngt+0x5c>)
 801ac60:	4d16      	ldr	r5, [pc, #88]	; (801acbc <CST_fota_timeout_event_mngt+0x60>)
 801ac62:	f104 0e20 	add.w	lr, r4, #32
 801ac66:	46a4      	mov	ip, r4
 801ac68:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ac6c:	6028      	str	r0, [r5, #0]
 801ac6e:	6069      	str	r1, [r5, #4]
 801ac70:	60aa      	str	r2, [r5, #8]
 801ac72:	60eb      	str	r3, [r5, #12]
 801ac74:	4664      	mov	r4, ip
 801ac76:	3510      	adds	r5, #16
 801ac78:	45f4      	cmp	ip, lr
 801ac7a:	d1f4      	bne.n	801ac66 <CST_fota_timeout_event_mngt+0xa>
 801ac7c:	cc03      	ldmia	r4!, {r0, r1}
 801ac7e:	6028      	str	r0, [r5, #0]
 801ac80:	6069      	str	r1, [r5, #4]
 801ac82:	8823      	ldrh	r3, [r4, #0]
 801ac84:	812b      	strh	r3, [r5, #8]
 801ac86:	4c0d      	ldr	r4, [pc, #52]	; (801acbc <CST_fota_timeout_event_mngt+0x60>)
 801ac88:	4620      	mov	r0, r4
 801ac8a:	f004 fa42 	bl	801f112 <crs_strlen>
 801ac8e:	b283      	uxth	r3, r0
 801ac90:	4622      	mov	r2, r4
 801ac92:	2101      	movs	r1, #1
 801ac94:	2007      	movs	r0, #7
 801ac96:	f004 fa7f 	bl	801f198 <traceIF_itmPrint>
 801ac9a:	4620      	mov	r0, r4
 801ac9c:	f004 fa39 	bl	801f112 <crs_strlen>
 801aca0:	b283      	uxth	r3, r0
 801aca2:	4622      	mov	r2, r4
 801aca4:	2101      	movs	r1, #1
 801aca6:	2007      	movs	r0, #7
 801aca8:	f004 fa98 	bl	801f1dc <traceIF_uartPrint>

  ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 4, ERROR_FATAL);
 801acac:	2203      	movs	r2, #3
 801acae:	2104      	movs	r1, #4
 801acb0:	2007      	movs	r0, #7
 801acb2:	f003 fa4b 	bl	801e14c <ERROR_Handler>
}
 801acb6:	bd38      	pop	{r3, r4, r5, pc}
 801acb8:	08033a04 	.word	0x08033a04
 801acbc:	20004ddc 	.word	0x20004ddc

0801acc0 <CST_modem_off_mngt>:
  * @brief  set modem off
  * @param  -
  * @retval -
  */
static void CST_modem_off_mngt(void)
{
 801acc0:	b570      	push	{r4, r5, r6, lr}
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801acc2:	4e09      	ldr	r6, [pc, #36]	; (801ace8 <CST_modem_off_mngt+0x28>)
 801acc4:	4c09      	ldr	r4, [pc, #36]	; (801acec <CST_modem_off_mngt+0x2c>)
 801acc6:	4d0a      	ldr	r5, [pc, #40]	; (801acf0 <CST_modem_off_mngt+0x30>)
 801acc8:	23f4      	movs	r3, #244	; 0xf4
 801acca:	4622      	mov	r2, r4
 801accc:	8831      	ldrh	r1, [r6, #0]
 801acce:	4628      	mov	r0, r5
 801acd0:	f006 fe7a 	bl	80219c8 <dc_com_read>
  cst_cellular_info.modem_state = DC_MODEM_STATE_OFF;
 801acd4:	2300      	movs	r3, #0
 801acd6:	7263      	strb	r3, [r4, #9]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801acd8:	23f4      	movs	r3, #244	; 0xf4
 801acda:	4622      	mov	r2, r4
 801acdc:	8831      	ldrh	r1, [r6, #0]
 801acde:	4628      	mov	r0, r5
 801ace0:	f006 fe26 	bl	8021930 <dc_com_write>
}
 801ace4:	bd70      	pop	{r4, r5, r6, pc}
 801ace6:	bf00      	nop
 801ace8:	20000236 	.word	0x20000236
 801acec:	2000406c 	.word	0x2000406c
 801acf0:	200058b0 	.word	0x200058b0

0801acf4 <CST_nw_reg_timeout_expiration_mngt>:
{
 801acf4:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("-----> NW REG TIMEOUT TIMER EXPIRY WE PWDN THE MODEM \n\r")
 801acf6:	4c2e      	ldr	r4, [pc, #184]	; (801adb0 <CST_nw_reg_timeout_expiration_mngt+0xbc>)
 801acf8:	4d2e      	ldr	r5, [pc, #184]	; (801adb4 <CST_nw_reg_timeout_expiration_mngt+0xc0>)
 801acfa:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801acfe:	46a4      	mov	ip, r4
 801ad00:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ad04:	6028      	str	r0, [r5, #0]
 801ad06:	6069      	str	r1, [r5, #4]
 801ad08:	60aa      	str	r2, [r5, #8]
 801ad0a:	60eb      	str	r3, [r5, #12]
 801ad0c:	4664      	mov	r4, ip
 801ad0e:	3510      	adds	r5, #16
 801ad10:	45f4      	cmp	ip, lr
 801ad12:	d1f4      	bne.n	801acfe <CST_nw_reg_timeout_expiration_mngt+0xa>
 801ad14:	cc03      	ldmia	r4!, {r0, r1}
 801ad16:	6028      	str	r0, [r5, #0]
 801ad18:	6069      	str	r1, [r5, #4]
 801ad1a:	4c26      	ldr	r4, [pc, #152]	; (801adb4 <CST_nw_reg_timeout_expiration_mngt+0xc0>)
 801ad1c:	4620      	mov	r0, r4
 801ad1e:	f004 f9f8 	bl	801f112 <crs_strlen>
 801ad22:	b283      	uxth	r3, r0
 801ad24:	4622      	mov	r2, r4
 801ad26:	2101      	movs	r1, #1
 801ad28:	2007      	movs	r0, #7
 801ad2a:	f004 fa35 	bl	801f198 <traceIF_itmPrint>
 801ad2e:	4620      	mov	r0, r4
 801ad30:	f004 f9ef 	bl	801f112 <crs_strlen>
 801ad34:	b283      	uxth	r3, r0
 801ad36:	4622      	mov	r2, r4
 801ad38:	2101      	movs	r1, #1
 801ad3a:	2007      	movs	r0, #7
 801ad3c:	f004 fa4e 	bl	801f1dc <traceIF_uartPrint>
  if (cst_nfmc_context.active == true)
 801ad40:	4b1d      	ldr	r3, [pc, #116]	; (801adb8 <CST_nw_reg_timeout_expiration_mngt+0xc4>)
 801ad42:	781b      	ldrb	r3, [r3, #0]
 801ad44:	b903      	cbnz	r3, 801ad48 <CST_nw_reg_timeout_expiration_mngt+0x54>
}
 801ad46:	bd70      	pop	{r4, r5, r6, pc}
    cst_nfmc_context.nfmc_timer_on_going = true;
 801ad48:	4c1b      	ldr	r4, [pc, #108]	; (801adb8 <CST_nw_reg_timeout_expiration_mngt+0xc4>)
 801ad4a:	2601      	movs	r6, #1
 801ad4c:	7066      	strb	r6, [r4, #1]
    (void)osCDS_power_off();
 801ad4e:	f7ff fe87 	bl	801aa60 <osCDS_power_off>
                           cst_nfmc_context.tempo[cst_context.register_retry_tempo_count]);
 801ad52:	4d1a      	ldr	r5, [pc, #104]	; (801adbc <CST_nw_reg_timeout_expiration_mngt+0xc8>)
 801ad54:	89eb      	ldrh	r3, [r5, #14]
    (void)rtosalTimerStart(cst_register_retry_timer_handle,
 801ad56:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801ad5a:	6859      	ldr	r1, [r3, #4]
 801ad5c:	4b18      	ldr	r3, [pc, #96]	; (801adc0 <CST_nw_reg_timeout_expiration_mngt+0xcc>)
 801ad5e:	6818      	ldr	r0, [r3, #0]
 801ad60:	f004 f927 	bl	801efb2 <rtosalTimerStart>
    PRINT_CELLULAR_SERVICE("-----> CST_waiting_for_network_status NOK - retry tempo %d : %ld\n\r",
 801ad64:	89ea      	ldrh	r2, [r5, #14]
 801ad66:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 801ad6a:	4c12      	ldr	r4, [pc, #72]	; (801adb4 <CST_nw_reg_timeout_expiration_mngt+0xc0>)
 801ad6c:	685b      	ldr	r3, [r3, #4]
 801ad6e:	4432      	add	r2, r6
 801ad70:	4914      	ldr	r1, [pc, #80]	; (801adc4 <CST_nw_reg_timeout_expiration_mngt+0xd0>)
 801ad72:	4620      	mov	r0, r4
 801ad74:	f00a ff7c 	bl	8025c70 <sprintf>
 801ad78:	4620      	mov	r0, r4
 801ad7a:	f004 f9ca 	bl	801f112 <crs_strlen>
 801ad7e:	b283      	uxth	r3, r0
 801ad80:	4622      	mov	r2, r4
 801ad82:	4631      	mov	r1, r6
 801ad84:	2007      	movs	r0, #7
 801ad86:	f004 fa07 	bl	801f198 <traceIF_itmPrint>
 801ad8a:	4620      	mov	r0, r4
 801ad8c:	f004 f9c1 	bl	801f112 <crs_strlen>
 801ad90:	b283      	uxth	r3, r0
 801ad92:	4622      	mov	r2, r4
 801ad94:	4631      	mov	r1, r6
 801ad96:	2007      	movs	r0, #7
 801ad98:	f004 fa20 	bl	801f1dc <traceIF_uartPrint>
    cst_context.register_retry_tempo_count++;
 801ad9c:	89eb      	ldrh	r3, [r5, #14]
 801ad9e:	4433      	add	r3, r6
 801ada0:	b29b      	uxth	r3, r3
 801ada2:	81eb      	strh	r3, [r5, #14]
    if (cst_context.register_retry_tempo_count >= CST_NFMC_TEMPO_NB)
 801ada4:	2b06      	cmp	r3, #6
 801ada6:	d9ce      	bls.n	801ad46 <CST_nw_reg_timeout_expiration_mngt+0x52>
      cst_context.register_retry_tempo_count = 0U;
 801ada8:	2200      	movs	r2, #0
 801adaa:	81ea      	strh	r2, [r5, #14]
}
 801adac:	e7cb      	b.n	801ad46 <CST_nw_reg_timeout_expiration_mngt+0x52>
 801adae:	bf00      	nop
 801adb0:	08033a30 	.word	0x08033a30
 801adb4:	20004ddc 	.word	0x20004ddc
 801adb8:	2000430c 	.word	0x2000430c
 801adbc:	200000b0 	.word	0x200000b0
 801adc0:	20004334 	.word	0x20004334
 801adc4:	08033a68 	.word	0x08033a68

0801adc8 <CST_off_state_target_cmd_state_mngt>:
{
 801adc8:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_init_state_mngt ********\n\r")
 801adca:	4c28      	ldr	r4, [pc, #160]	; (801ae6c <CST_off_state_target_cmd_state_mngt+0xa4>)
 801adcc:	4d28      	ldr	r5, [pc, #160]	; (801ae70 <CST_off_state_target_cmd_state_mngt+0xa8>)
 801adce:	f104 0e20 	add.w	lr, r4, #32
 801add2:	46a4      	mov	ip, r4
 801add4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801add8:	6028      	str	r0, [r5, #0]
 801adda:	6069      	str	r1, [r5, #4]
 801addc:	60aa      	str	r2, [r5, #8]
 801adde:	60eb      	str	r3, [r5, #12]
 801ade0:	4664      	mov	r4, ip
 801ade2:	3510      	adds	r5, #16
 801ade4:	45f4      	cmp	ip, lr
 801ade6:	d1f4      	bne.n	801add2 <CST_off_state_target_cmd_state_mngt+0xa>
 801ade8:	cc03      	ldmia	r4!, {r0, r1}
 801adea:	6028      	str	r0, [r5, #0]
 801adec:	6069      	str	r1, [r5, #4]
 801adee:	8822      	ldrh	r2, [r4, #0]
 801adf0:	78a3      	ldrb	r3, [r4, #2]
 801adf2:	812a      	strh	r2, [r5, #8]
 801adf4:	72ab      	strb	r3, [r5, #10]
 801adf6:	4c1e      	ldr	r4, [pc, #120]	; (801ae70 <CST_off_state_target_cmd_state_mngt+0xa8>)
 801adf8:	4620      	mov	r0, r4
 801adfa:	f004 f98a 	bl	801f112 <crs_strlen>
 801adfe:	b283      	uxth	r3, r0
 801ae00:	4622      	mov	r2, r4
 801ae02:	2101      	movs	r1, #1
 801ae04:	2007      	movs	r0, #7
 801ae06:	f004 f9c7 	bl	801f198 <traceIF_itmPrint>
 801ae0a:	4620      	mov	r0, r4
 801ae0c:	f004 f981 	bl	801f112 <crs_strlen>
 801ae10:	b283      	uxth	r3, r0
 801ae12:	4622      	mov	r2, r4
 801ae14:	2101      	movs	r1, #1
 801ae16:	2007      	movs	r0, #7
 801ae18:	f004 f9e0 	bl	801f1dc <traceIF_uartPrint>
  if (cst_cellular_params.target_state != DC_TARGET_STATE_OFF)
 801ae1c:	4b15      	ldr	r3, [pc, #84]	; (801ae74 <CST_off_state_target_cmd_state_mngt+0xac>)
 801ae1e:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801ae22:	b113      	cbz	r3, 801ae2a <CST_off_state_target_cmd_state_mngt+0x62>
    if (cst_nfmc_context.nfmc_timer_on_going == false)
 801ae24:	4b14      	ldr	r3, [pc, #80]	; (801ae78 <CST_off_state_target_cmd_state_mngt+0xb0>)
 801ae26:	785b      	ldrb	r3, [r3, #1]
 801ae28:	b103      	cbz	r3, 801ae2c <CST_off_state_target_cmd_state_mngt+0x64>
}
 801ae2a:	bd70      	pop	{r4, r5, r6, pc}
      cs_status = osCDS_power_on();
 801ae2c:	f7ff fe06 	bl	801aa3c <osCDS_power_on>
      if (cs_status != CELLULAR_OK)
 801ae30:	b130      	cbz	r0, 801ae40 <CST_off_state_target_cmd_state_mngt+0x78>
        CST_config_fail(((uint8_t *)"CST_cmd"),
 801ae32:	2305      	movs	r3, #5
 801ae34:	4a11      	ldr	r2, [pc, #68]	; (801ae7c <CST_off_state_target_cmd_state_mngt+0xb4>)
 801ae36:	2101      	movs	r1, #1
 801ae38:	4811      	ldr	r0, [pc, #68]	; (801ae80 <CST_off_state_target_cmd_state_mngt+0xb8>)
 801ae3a:	f002 fb0b 	bl	801d454 <CST_config_fail>
 801ae3e:	e7f4      	b.n	801ae2a <CST_off_state_target_cmd_state_mngt+0x62>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801ae40:	4e10      	ldr	r6, [pc, #64]	; (801ae84 <CST_off_state_target_cmd_state_mngt+0xbc>)
 801ae42:	4c11      	ldr	r4, [pc, #68]	; (801ae88 <CST_off_state_target_cmd_state_mngt+0xc0>)
 801ae44:	4d11      	ldr	r5, [pc, #68]	; (801ae8c <CST_off_state_target_cmd_state_mngt+0xc4>)
 801ae46:	23f4      	movs	r3, #244	; 0xf4
 801ae48:	4622      	mov	r2, r4
 801ae4a:	8831      	ldrh	r1, [r6, #0]
 801ae4c:	4628      	mov	r0, r5
 801ae4e:	f006 fdbb 	bl	80219c8 <dc_com_read>
        cst_cellular_info.rt_state    = DC_SERVICE_RUN;
 801ae52:	2306      	movs	r3, #6
 801ae54:	7223      	strb	r3, [r4, #8]
        cst_cellular_info.modem_state = DC_MODEM_STATE_POWERED_ON;
 801ae56:	2301      	movs	r3, #1
 801ae58:	7263      	strb	r3, [r4, #9]
        (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801ae5a:	23f4      	movs	r3, #244	; 0xf4
 801ae5c:	4622      	mov	r2, r4
 801ae5e:	8831      	ldrh	r1, [r6, #0]
 801ae60:	4628      	mov	r0, r5
 801ae62:	f006 fd65 	bl	8021930 <dc_com_write>
        CST_modem_sim_init();
 801ae66:	f002 fbf3 	bl	801d650 <CST_modem_sim_init>
}
 801ae6a:	e7de      	b.n	801ae2a <CST_off_state_target_cmd_state_mngt+0x62>
 801ae6c:	08033aac 	.word	0x08033aac
 801ae70:	20004ddc 	.word	0x20004ddc
 801ae74:	20004160 	.word	0x20004160
 801ae78:	2000430c 	.word	0x2000430c
 801ae7c:	200000c1 	.word	0x200000c1
 801ae80:	08033ad8 	.word	0x08033ad8
 801ae84:	20000236 	.word	0x20000236
 801ae88:	2000406c 	.word	0x2000406c
 801ae8c:	200058b0 	.word	0x200058b0

0801ae90 <CST_polling_timer_mngt>:
{
 801ae90:	b538      	push	{r3, r4, r5, lr}
  if (CST_polling_active == true)
 801ae92:	4b1b      	ldr	r3, [pc, #108]	; (801af00 <CST_polling_timer_mngt+0x70>)
 801ae94:	781b      	ldrb	r3, [r3, #0]
 801ae96:	b38b      	cbz	r3, 801aefc <CST_polling_timer_mngt+0x6c>
    if (CST_polling_on_going == false)
 801ae98:	4b1a      	ldr	r3, [pc, #104]	; (801af04 <CST_polling_timer_mngt+0x74>)
 801ae9a:	781b      	ldrb	r3, [r3, #0]
 801ae9c:	b93b      	cbnz	r3, 801aeae <CST_polling_timer_mngt+0x1e>
      CST_polling_on_going = true;
 801ae9e:	4c19      	ldr	r4, [pc, #100]	; (801af04 <CST_polling_timer_mngt+0x74>)
 801aea0:	2301      	movs	r3, #1
 801aea2:	7023      	strb	r3, [r4, #0]
      (void)CST_set_signal_quality();
 801aea4:	f002 ff72 	bl	801dd8c <CST_set_signal_quality>
      CST_polling_on_going = false;
 801aea8:	2300      	movs	r3, #0
 801aeaa:	7023      	strb	r3, [r4, #0]
 801aeac:	e026      	b.n	801aefc <CST_polling_timer_mngt+0x6c>
      PRINT_CELLULAR_SERVICE("Discard pooling timer, another one is already on going\n\r")
 801aeae:	4d16      	ldr	r5, [pc, #88]	; (801af08 <CST_polling_timer_mngt+0x78>)
 801aeb0:	4c16      	ldr	r4, [pc, #88]	; (801af0c <CST_polling_timer_mngt+0x7c>)
 801aeb2:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801aeb6:	46ac      	mov	ip, r5
 801aeb8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801aebc:	6020      	str	r0, [r4, #0]
 801aebe:	6061      	str	r1, [r4, #4]
 801aec0:	60a2      	str	r2, [r4, #8]
 801aec2:	60e3      	str	r3, [r4, #12]
 801aec4:	4665      	mov	r5, ip
 801aec6:	3410      	adds	r4, #16
 801aec8:	45f4      	cmp	ip, lr
 801aeca:	d1f4      	bne.n	801aeb6 <CST_polling_timer_mngt+0x26>
 801aecc:	cd03      	ldmia	r5!, {r0, r1}
 801aece:	6020      	str	r0, [r4, #0]
 801aed0:	6061      	str	r1, [r4, #4]
 801aed2:	782b      	ldrb	r3, [r5, #0]
 801aed4:	7223      	strb	r3, [r4, #8]
 801aed6:	4c0d      	ldr	r4, [pc, #52]	; (801af0c <CST_polling_timer_mngt+0x7c>)
 801aed8:	4620      	mov	r0, r4
 801aeda:	f004 f91a 	bl	801f112 <crs_strlen>
 801aede:	b283      	uxth	r3, r0
 801aee0:	4622      	mov	r2, r4
 801aee2:	2101      	movs	r1, #1
 801aee4:	2007      	movs	r0, #7
 801aee6:	f004 f957 	bl	801f198 <traceIF_itmPrint>
 801aeea:	4620      	mov	r0, r4
 801aeec:	f004 f911 	bl	801f112 <crs_strlen>
 801aef0:	b283      	uxth	r3, r0
 801aef2:	4622      	mov	r2, r4
 801aef4:	2101      	movs	r1, #1
 801aef6:	2007      	movs	r0, #7
 801aef8:	f004 f970 	bl	801f1dc <traceIF_uartPrint>
}
 801aefc:	bd38      	pop	{r3, r4, r5, pc}
 801aefe:	bf00      	nop
 801af00:	20003fac 	.word	0x20003fac
 801af04:	20003fad 	.word	0x20003fad
 801af08:	08033ae0 	.word	0x08033ae0
 801af0c:	20004ddc 	.word	0x20004ddc

0801af10 <CST_fota_end_event_mngt>:
{
 801af10:	b570      	push	{r4, r5, r6, lr}
  (void)rtosalTimerStop(cst_fota_timer_handle);
 801af12:	4b29      	ldr	r3, [pc, #164]	; (801afb8 <CST_fota_end_event_mngt+0xa8>)
 801af14:	6818      	ldr	r0, [r3, #0]
 801af16:	f004 f850 	bl	801efba <rtosalTimerStop>
  PRINT_CELLULAR_SERVICE("Modem event received:  CS_MDMEVENT_FOTA_END\n\r")
 801af1a:	4c28      	ldr	r4, [pc, #160]	; (801afbc <CST_fota_end_event_mngt+0xac>)
 801af1c:	4d28      	ldr	r5, [pc, #160]	; (801afc0 <CST_fota_end_event_mngt+0xb0>)
 801af1e:	f104 0620 	add.w	r6, r4, #32
 801af22:	46a4      	mov	ip, r4
 801af24:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801af28:	6028      	str	r0, [r5, #0]
 801af2a:	6069      	str	r1, [r5, #4]
 801af2c:	60aa      	str	r2, [r5, #8]
 801af2e:	60eb      	str	r3, [r5, #12]
 801af30:	4664      	mov	r4, ip
 801af32:	3510      	adds	r5, #16
 801af34:	45b4      	cmp	ip, r6
 801af36:	d1f4      	bne.n	801af22 <CST_fota_end_event_mngt+0x12>
 801af38:	cc07      	ldmia	r4!, {r0, r1, r2}
 801af3a:	6028      	str	r0, [r5, #0]
 801af3c:	6069      	str	r1, [r5, #4]
 801af3e:	60aa      	str	r2, [r5, #8]
 801af40:	8823      	ldrh	r3, [r4, #0]
 801af42:	81ab      	strh	r3, [r5, #12]
 801af44:	4c1e      	ldr	r4, [pc, #120]	; (801afc0 <CST_fota_end_event_mngt+0xb0>)
 801af46:	4620      	mov	r0, r4
 801af48:	f004 f8e3 	bl	801f112 <crs_strlen>
 801af4c:	b283      	uxth	r3, r0
 801af4e:	4622      	mov	r2, r4
 801af50:	2101      	movs	r1, #1
 801af52:	2007      	movs	r0, #7
 801af54:	f004 f920 	bl	801f198 <traceIF_itmPrint>
 801af58:	4620      	mov	r0, r4
 801af5a:	f004 f8da 	bl	801f112 <crs_strlen>
 801af5e:	b283      	uxth	r3, r0
 801af60:	4622      	mov	r2, r4
 801af62:	2101      	movs	r1, #1
 801af64:	2007      	movs	r0, #7
 801af66:	f004 f939 	bl	801f1dc <traceIF_uartPrint>
  PRINT_CELLULAR_SERVICE("TRIGGER PLATFORM REBOOT AFTER FOTA UPDATE ...\n\r")
 801af6a:	4e16      	ldr	r6, [pc, #88]	; (801afc4 <CST_fota_end_event_mngt+0xb4>)
 801af6c:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801af70:	4635      	mov	r5, r6
 801af72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801af74:	6020      	str	r0, [r4, #0]
 801af76:	6061      	str	r1, [r4, #4]
 801af78:	60a2      	str	r2, [r4, #8]
 801af7a:	60e3      	str	r3, [r4, #12]
 801af7c:	462e      	mov	r6, r5
 801af7e:	3410      	adds	r4, #16
 801af80:	4565      	cmp	r5, ip
 801af82:	d1f5      	bne.n	801af70 <CST_fota_end_event_mngt+0x60>
 801af84:	4c0e      	ldr	r4, [pc, #56]	; (801afc0 <CST_fota_end_event_mngt+0xb0>)
 801af86:	4620      	mov	r0, r4
 801af88:	f004 f8c3 	bl	801f112 <crs_strlen>
 801af8c:	b283      	uxth	r3, r0
 801af8e:	4622      	mov	r2, r4
 801af90:	2101      	movs	r1, #1
 801af92:	2007      	movs	r0, #7
 801af94:	f004 f900 	bl	801f198 <traceIF_itmPrint>
 801af98:	4620      	mov	r0, r4
 801af9a:	f004 f8ba 	bl	801f112 <crs_strlen>
 801af9e:	b283      	uxth	r3, r0
 801afa0:	4622      	mov	r2, r4
 801afa2:	2101      	movs	r1, #1
 801afa4:	2007      	movs	r0, #7
 801afa6:	f004 f919 	bl	801f1dc <traceIF_uartPrint>
  ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 3, ERROR_FATAL);
 801afaa:	2203      	movs	r2, #3
 801afac:	4611      	mov	r1, r2
 801afae:	2007      	movs	r0, #7
 801afb0:	f003 f8cc 	bl	801e14c <ERROR_Handler>
}
 801afb4:	bd70      	pop	{r4, r5, r6, pc}
 801afb6:	bf00      	nop
 801afb8:	20004304 	.word	0x20004304
 801afbc:	08033b1c 	.word	0x08033b1c
 801afc0:	20004ddc 	.word	0x20004ddc
 801afc4:	08033b4c 	.word	0x08033b4c

0801afc8 <CST_modem_reprog_state>:
  * @brief  FOTA state : modem formware update on going
  * @param  autom_event - automaton event
  * @retval -
  */
static void CST_modem_reprog_state(cst_autom_event_t autom_event)
{
 801afc8:	b508      	push	{r3, lr}
#if (USE_LOW_POWER == 1)
  (void)rtosalTimerStop(cst_lp_inactivity_timer_handle);
#endif /* (USE_LOW_POWER == 1) */
  switch (autom_event)
 801afca:	2816      	cmp	r0, #22
 801afcc:	d004      	beq.n	801afd8 <CST_modem_reprog_state+0x10>
 801afce:	2817      	cmp	r0, #23
 801afd0:	d005      	beq.n	801afde <CST_modem_reprog_state+0x16>
 801afd2:	2811      	cmp	r0, #17
 801afd4:	d006      	beq.n	801afe4 <CST_modem_reprog_state+0x1c>

    default:
      /* Nothing to do */
      break;
  }
}
 801afd6:	bd08      	pop	{r3, pc}
      CST_fota_end_event_mngt();
 801afd8:	f7ff ff9a 	bl	801af10 <CST_fota_end_event_mngt>
      break;
 801afdc:	e7fb      	b.n	801afd6 <CST_modem_reprog_state+0xe>
      CST_fota_timeout_event_mngt();
 801afde:	f7ff fe3d 	bl	801ac5c <CST_fota_timeout_event_mngt>
      break;
 801afe2:	e7f8      	b.n	801afd6 <CST_modem_reprog_state+0xe>
      __NOP();
 801afe4:	bf00      	nop
}
 801afe6:	e7f6      	b.n	801afd6 <CST_modem_reprog_state+0xe>

0801afe8 <CST_send_message>:
{
 801afe8:	b538      	push	{r3, r4, r5, lr}
  SET_AUTOMATON_MSG_ID(cmd_message, event);
 801afea:	ea40 4401 	orr.w	r4, r0, r1, lsl #16
  if (rtosalMessageQueuePut((osMessageQId)cst_queue_id, cmd_message, 0U) != osOK)
 801afee:	2200      	movs	r2, #0
 801aff0:	4621      	mov	r1, r4
 801aff2:	4b0f      	ldr	r3, [pc, #60]	; (801b030 <CST_send_message+0x48>)
 801aff4:	6818      	ldr	r0, [r3, #0]
 801aff6:	f003 ffba 	bl	801ef6e <rtosalMessageQueuePut>
 801affa:	b900      	cbnz	r0, 801affe <CST_send_message+0x16>
}
 801affc:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_CELLULAR_SERVICE_ERR("CST queue msg %ld can NOT be added. (Queue full ?)\n\r", cmd_message)
 801affe:	4d0d      	ldr	r5, [pc, #52]	; (801b034 <CST_send_message+0x4c>)
 801b000:	4622      	mov	r2, r4
 801b002:	490d      	ldr	r1, [pc, #52]	; (801b038 <CST_send_message+0x50>)
 801b004:	4628      	mov	r0, r5
 801b006:	f00a fe33 	bl	8025c70 <sprintf>
 801b00a:	4628      	mov	r0, r5
 801b00c:	f004 f881 	bl	801f112 <crs_strlen>
 801b010:	b283      	uxth	r3, r0
 801b012:	462a      	mov	r2, r5
 801b014:	2110      	movs	r1, #16
 801b016:	2007      	movs	r0, #7
 801b018:	f004 f8be 	bl	801f198 <traceIF_itmPrint>
 801b01c:	4628      	mov	r0, r5
 801b01e:	f004 f878 	bl	801f112 <crs_strlen>
 801b022:	b283      	uxth	r3, r0
 801b024:	462a      	mov	r2, r5
 801b026:	2110      	movs	r1, #16
 801b028:	2007      	movs	r0, #7
 801b02a:	f004 f8d7 	bl	801f1dc <traceIF_uartPrint>
}
 801b02e:	e7e5      	b.n	801affc <CST_send_message+0x14>
 801b030:	20004330 	.word	0x20004330
 801b034:	20004ddc 	.word	0x20004ddc
 801b038:	08033b7c 	.word	0x08033b7c

0801b03c <CST_fota_timer_callback>:
{
 801b03c:	b508      	push	{r3, lr}
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_FOTA_TIMEOUT_EVENT);
 801b03e:	2117      	movs	r1, #23
 801b040:	2000      	movs	r0, #0
 801b042:	f7ff ffd1 	bl	801afe8 <CST_send_message>
}
 801b046:	bd08      	pop	{r3, pc}

0801b048 <CST_network_status_timer_callback>:
{
 801b048:	b508      	push	{r3, lr}
  if (cst_context.current_state == CST_WAITING_FOR_NETWORK_STATUS_STATE)
 801b04a:	4b05      	ldr	r3, [pc, #20]	; (801b060 <CST_network_status_timer_callback+0x18>)
 801b04c:	881b      	ldrh	r3, [r3, #0]
 801b04e:	2b04      	cmp	r3, #4
 801b050:	d000      	beq.n	801b054 <CST_network_status_timer_callback+0xc>
}
 801b052:	bd08      	pop	{r3, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NW_REG_TIMEOUT_TIMER_EVENT);
 801b054:	2114      	movs	r1, #20
 801b056:	2000      	movs	r0, #0
 801b058:	f7ff ffc6 	bl	801afe8 <CST_send_message>
}
 801b05c:	e7f9      	b.n	801b052 <CST_network_status_timer_callback+0xa>
 801b05e:	bf00      	nop
 801b060:	200000b0 	.word	0x200000b0

0801b064 <CST_pdn_activate_retry_timer_callback>:
{
 801b064:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_pdn_activate_retry_timer_callback ********\n\r")
 801b066:	4c19      	ldr	r4, [pc, #100]	; (801b0cc <CST_pdn_activate_retry_timer_callback+0x68>)
 801b068:	4d19      	ldr	r5, [pc, #100]	; (801b0d0 <CST_pdn_activate_retry_timer_callback+0x6c>)
 801b06a:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801b06e:	46a4      	mov	ip, r4
 801b070:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b074:	6028      	str	r0, [r5, #0]
 801b076:	6069      	str	r1, [r5, #4]
 801b078:	60aa      	str	r2, [r5, #8]
 801b07a:	60eb      	str	r3, [r5, #12]
 801b07c:	4664      	mov	r4, ip
 801b07e:	3510      	adds	r5, #16
 801b080:	45f4      	cmp	ip, lr
 801b082:	d1f4      	bne.n	801b06e <CST_pdn_activate_retry_timer_callback+0xa>
 801b084:	cc07      	ldmia	r4!, {r0, r1, r2}
 801b086:	6028      	str	r0, [r5, #0]
 801b088:	6069      	str	r1, [r5, #4]
 801b08a:	60aa      	str	r2, [r5, #8]
 801b08c:	7823      	ldrb	r3, [r4, #0]
 801b08e:	732b      	strb	r3, [r5, #12]
 801b090:	4c0f      	ldr	r4, [pc, #60]	; (801b0d0 <CST_pdn_activate_retry_timer_callback+0x6c>)
 801b092:	4620      	mov	r0, r4
 801b094:	f004 f83d 	bl	801f112 <crs_strlen>
 801b098:	b283      	uxth	r3, r0
 801b09a:	4622      	mov	r2, r4
 801b09c:	2101      	movs	r1, #1
 801b09e:	2007      	movs	r0, #7
 801b0a0:	f004 f87a 	bl	801f198 <traceIF_itmPrint>
 801b0a4:	4620      	mov	r0, r4
 801b0a6:	f004 f834 	bl	801f112 <crs_strlen>
 801b0aa:	b283      	uxth	r3, r0
 801b0ac:	4622      	mov	r2, r4
 801b0ae:	2101      	movs	r1, #1
 801b0b0:	2007      	movs	r0, #7
 801b0b2:	f004 f893 	bl	801f1dc <traceIF_uartPrint>
  if (cst_context.current_state == CST_MODEM_PDN_ACTIVATING_STATE)
 801b0b6:	4b07      	ldr	r3, [pc, #28]	; (801b0d4 <CST_pdn_activate_retry_timer_callback+0x70>)
 801b0b8:	881b      	ldrh	r3, [r3, #0]
 801b0ba:	2b07      	cmp	r3, #7
 801b0bc:	d000      	beq.n	801b0c0 <CST_pdn_activate_retry_timer_callback+0x5c>
}
 801b0be:	bd38      	pop	{r3, r4, r5, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_PDN_ACTIVATE_RETRY_TIMER_EVENT);
 801b0c0:	2109      	movs	r1, #9
 801b0c2:	2000      	movs	r0, #0
 801b0c4:	f7ff ff90 	bl	801afe8 <CST_send_message>
}
 801b0c8:	e7f9      	b.n	801b0be <CST_pdn_activate_retry_timer_callback+0x5a>
 801b0ca:	bf00      	nop
 801b0cc:	08033bb8 	.word	0x08033bb8
 801b0d0:	20004ddc 	.word	0x20004ddc
 801b0d4:	200000b0 	.word	0x200000b0

0801b0d8 <CST_polling_timer_callback>:
{
 801b0d8:	b508      	push	{r3, lr}
  if (((cst_context.current_state == CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE)
 801b0da:	4b0d      	ldr	r3, [pc, #52]	; (801b110 <CST_polling_timer_callback+0x38>)
 801b0dc:	881a      	ldrh	r2, [r3, #0]
       || (cst_context.current_state == CST_WAITING_FOR_NETWORK_STATUS_STATE)
 801b0de:	1ed3      	subs	r3, r2, #3
 801b0e0:	b29b      	uxth	r3, r3
  if (((cst_context.current_state == CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE)
 801b0e2:	2b01      	cmp	r3, #1
 801b0e4:	d902      	bls.n	801b0ec <CST_polling_timer_callback+0x14>
       || (cst_context.current_state == CST_MODEM_DATA_READY_STATE))
 801b0e6:	2a08      	cmp	r2, #8
 801b0e8:	d000      	beq.n	801b0ec <CST_polling_timer_callback+0x14>
}
 801b0ea:	bd08      	pop	{r3, pc}
      && (cst_nfmc_context.nfmc_timer_on_going == false)
 801b0ec:	4b09      	ldr	r3, [pc, #36]	; (801b114 <CST_polling_timer_callback+0x3c>)
 801b0ee:	785b      	ldrb	r3, [r3, #1]
 801b0f0:	2b00      	cmp	r3, #0
 801b0f2:	d1fa      	bne.n	801b0ea <CST_polling_timer_callback+0x12>
      && (CST_polling_active == true)
 801b0f4:	4b08      	ldr	r3, [pc, #32]	; (801b118 <CST_polling_timer_callback+0x40>)
 801b0f6:	781b      	ldrb	r3, [r3, #0]
 801b0f8:	2b00      	cmp	r3, #0
 801b0fa:	d0f6      	beq.n	801b0ea <CST_polling_timer_callback+0x12>
    if (CST_polling_on_going == false)
 801b0fc:	4b07      	ldr	r3, [pc, #28]	; (801b11c <CST_polling_timer_callback+0x44>)
 801b0fe:	781b      	ldrb	r3, [r3, #0]
 801b100:	2b00      	cmp	r3, #0
 801b102:	d1f2      	bne.n	801b0ea <CST_polling_timer_callback+0x12>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_POLLING_TIMER_EVENT);
 801b104:	210b      	movs	r1, #11
 801b106:	2000      	movs	r0, #0
 801b108:	f7ff ff6e 	bl	801afe8 <CST_send_message>
}
 801b10c:	e7ed      	b.n	801b0ea <CST_polling_timer_callback+0x12>
 801b10e:	bf00      	nop
 801b110:	200000b0 	.word	0x200000b0
 801b114:	2000430c 	.word	0x2000430c
 801b118:	20003fac 	.word	0x20003fac
 801b11c:	20003fad 	.word	0x20003fad

0801b120 <CST_pdn_event_callback>:
{
 801b120:	b538      	push	{r3, r4, r5, lr}
 801b122:	4602      	mov	r2, r0
 801b124:	460d      	mov	r5, r1
  PRINT_CELLULAR_SERVICE("====================================CST_pdn_event_callback (cid=%d / event=%d)\n\r",
 801b126:	4c0f      	ldr	r4, [pc, #60]	; (801b164 <CST_pdn_event_callback+0x44>)
 801b128:	460b      	mov	r3, r1
 801b12a:	490f      	ldr	r1, [pc, #60]	; (801b168 <CST_pdn_event_callback+0x48>)
 801b12c:	4620      	mov	r0, r4
 801b12e:	f00a fd9f 	bl	8025c70 <sprintf>
 801b132:	4620      	mov	r0, r4
 801b134:	f003 ffed 	bl	801f112 <crs_strlen>
 801b138:	b283      	uxth	r3, r0
 801b13a:	4622      	mov	r2, r4
 801b13c:	2101      	movs	r1, #1
 801b13e:	2007      	movs	r0, #7
 801b140:	f004 f82a 	bl	801f198 <traceIF_itmPrint>
 801b144:	4620      	mov	r0, r4
 801b146:	f003 ffe4 	bl	801f112 <crs_strlen>
 801b14a:	b283      	uxth	r3, r0
 801b14c:	4622      	mov	r2, r4
 801b14e:	2101      	movs	r1, #1
 801b150:	2007      	movs	r0, #7
 801b152:	f004 f843 	bl	801f1dc <traceIF_uartPrint>
  cst_context.pdn_status = pdn_event;
 801b156:	4b05      	ldr	r3, [pc, #20]	; (801b16c <CST_pdn_event_callback+0x4c>)
 801b158:	70dd      	strb	r5, [r3, #3]
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_PDN_STATUS_TO_CHECK_EVENT);
 801b15a:	2108      	movs	r1, #8
 801b15c:	2000      	movs	r0, #0
 801b15e:	f7ff ff43 	bl	801afe8 <CST_send_message>
}
 801b162:	bd38      	pop	{r3, r4, r5, pc}
 801b164:	20004ddc 	.word	0x20004ddc
 801b168:	08033bf8 	.word	0x08033bf8
 801b16c:	200000b0 	.word	0x200000b0

0801b170 <CST_set_state>:
  * @brief  sets new automaton state
  * @param  new_state - new current automaton state to set
  * @retval -
  */
void CST_set_state(CST_autom_state_t new_state)
{
 801b170:	b510      	push	{r4, lr}
  cst_context.current_state = new_state;
 801b172:	4b0e      	ldr	r3, [pc, #56]	; (801b1ac <CST_set_state+0x3c>)
 801b174:	8018      	strh	r0, [r3, #0]
  PRINT_CELLULAR_SERVICE("-----> New State: %s <-----\n\r", CST_StateName[new_state])
 801b176:	4c0e      	ldr	r4, [pc, #56]	; (801b1b0 <CST_set_state+0x40>)
 801b178:	4b0e      	ldr	r3, [pc, #56]	; (801b1b4 <CST_set_state+0x44>)
 801b17a:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 801b17e:	490e      	ldr	r1, [pc, #56]	; (801b1b8 <CST_set_state+0x48>)
 801b180:	4620      	mov	r0, r4
 801b182:	f00a fd75 	bl	8025c70 <sprintf>
 801b186:	4620      	mov	r0, r4
 801b188:	f003 ffc3 	bl	801f112 <crs_strlen>
 801b18c:	b283      	uxth	r3, r0
 801b18e:	4622      	mov	r2, r4
 801b190:	2101      	movs	r1, #1
 801b192:	2007      	movs	r0, #7
 801b194:	f004 f800 	bl	801f198 <traceIF_itmPrint>
 801b198:	4620      	mov	r0, r4
 801b19a:	f003 ffba 	bl	801f112 <crs_strlen>
 801b19e:	b283      	uxth	r3, r0
 801b1a0:	4622      	mov	r2, r4
 801b1a2:	2101      	movs	r1, #1
 801b1a4:	2007      	movs	r0, #7
 801b1a6:	f004 f819 	bl	801f1dc <traceIF_uartPrint>

#if (USE_CELLULAR_SERVICE_TASK_TEST == 1)
  /* instrumentation code to test automaton */
  CSTE_cellular_service_task_test(cst_context.current_state);
#endif  /* (USE_CELLULAR_SERVICE_TASK_TEST == 1) */
}
 801b1aa:	bd10      	pop	{r4, pc}
 801b1ac:	200000b0 	.word	0x200000b0
 801b1b0:	20004ddc 	.word	0x20004ddc
 801b1b4:	20000064 	.word	0x20000064
 801b1b8:	08033c4c 	.word	0x08033c4c

0801b1bc <CST_register_retry_timer_callback>:
{
 801b1bc:	b510      	push	{r4, lr}
  cst_nfmc_context.nfmc_timer_on_going = false;
 801b1be:	2400      	movs	r4, #0
 801b1c0:	4b04      	ldr	r3, [pc, #16]	; (801b1d4 <CST_register_retry_timer_callback+0x18>)
 801b1c2:	705c      	strb	r4, [r3, #1]
  CST_set_state(CST_MODEM_INIT_STATE);
 801b1c4:	2001      	movs	r0, #1
 801b1c6:	f7ff ffd3 	bl	801b170 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b1ca:	2101      	movs	r1, #1
 801b1cc:	4620      	mov	r0, r4
 801b1ce:	f7ff ff0b 	bl	801afe8 <CST_send_message>
}
 801b1d2:	bd10      	pop	{r4, pc}
 801b1d4:	2000430c 	.word	0x2000430c

0801b1d8 <CST_boot_event_mngt>:
{
 801b1d8:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_boot_event_mngt ********\n\r")
 801b1da:	4c18      	ldr	r4, [pc, #96]	; (801b23c <CST_boot_event_mngt+0x64>)
 801b1dc:	4d18      	ldr	r5, [pc, #96]	; (801b240 <CST_boot_event_mngt+0x68>)
 801b1de:	f104 0e20 	add.w	lr, r4, #32
 801b1e2:	46a4      	mov	ip, r4
 801b1e4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b1e8:	6028      	str	r0, [r5, #0]
 801b1ea:	6069      	str	r1, [r5, #4]
 801b1ec:	60aa      	str	r2, [r5, #8]
 801b1ee:	60eb      	str	r3, [r5, #12]
 801b1f0:	4664      	mov	r4, ip
 801b1f2:	3510      	adds	r5, #16
 801b1f4:	45f4      	cmp	ip, lr
 801b1f6:	d1f4      	bne.n	801b1e2 <CST_boot_event_mngt+0xa>
 801b1f8:	cc03      	ldmia	r4!, {r0, r1}
 801b1fa:	6028      	str	r0, [r5, #0]
 801b1fc:	6069      	str	r1, [r5, #4]
 801b1fe:	8822      	ldrh	r2, [r4, #0]
 801b200:	78a3      	ldrb	r3, [r4, #2]
 801b202:	812a      	strh	r2, [r5, #8]
 801b204:	72ab      	strb	r3, [r5, #10]
 801b206:	4c0e      	ldr	r4, [pc, #56]	; (801b240 <CST_boot_event_mngt+0x68>)
 801b208:	4620      	mov	r0, r4
 801b20a:	f003 ff82 	bl	801f112 <crs_strlen>
 801b20e:	b283      	uxth	r3, r0
 801b210:	4622      	mov	r2, r4
 801b212:	2101      	movs	r1, #1
 801b214:	2007      	movs	r0, #7
 801b216:	f003 ffbf 	bl	801f198 <traceIF_itmPrint>
 801b21a:	4620      	mov	r0, r4
 801b21c:	f003 ff79 	bl	801f112 <crs_strlen>
 801b220:	b283      	uxth	r3, r0
 801b222:	4622      	mov	r2, r4
 801b224:	2101      	movs	r1, #1
 801b226:	2007      	movs	r0, #7
 801b228:	f003 ffd8 	bl	801f1dc <traceIF_uartPrint>
  CST_set_state(CST_MODEM_INIT_STATE);
 801b22c:	2001      	movs	r0, #1
 801b22e:	f7ff ff9f 	bl	801b170 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b232:	2101      	movs	r1, #1
 801b234:	2000      	movs	r0, #0
 801b236:	f7ff fed7 	bl	801afe8 <CST_send_message>
}
 801b23a:	bd38      	pop	{r3, r4, r5, pc}
 801b23c:	08033c6c 	.word	0x08033c6c
 801b240:	20004ddc 	.word	0x20004ddc

0801b244 <CST_reboot_modem_event_mngt>:
{
 801b244:	b538      	push	{r3, r4, r5, lr}
  if (cst_context.current_state != CST_MODEM_INIT_STATE)
 801b246:	4b1d      	ldr	r3, [pc, #116]	; (801b2bc <CST_reboot_modem_event_mngt+0x78>)
 801b248:	881b      	ldrh	r3, [r3, #0]
 801b24a:	2b01      	cmp	r3, #1
 801b24c:	d100      	bne.n	801b250 <CST_reboot_modem_event_mngt+0xc>
}
 801b24e:	bd38      	pop	{r3, r4, r5, pc}
    (void)osCDS_power_off();
 801b250:	f7ff fc06 	bl	801aa60 <osCDS_power_off>
    PRINT_CELLULAR_SERVICE("Modem event received: CS_MDMEVENT_BOOT\n\r")
 801b254:	4c1a      	ldr	r4, [pc, #104]	; (801b2c0 <CST_reboot_modem_event_mngt+0x7c>)
 801b256:	4d1b      	ldr	r5, [pc, #108]	; (801b2c4 <CST_reboot_modem_event_mngt+0x80>)
 801b258:	f104 0e20 	add.w	lr, r4, #32
 801b25c:	46a4      	mov	ip, r4
 801b25e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b262:	6028      	str	r0, [r5, #0]
 801b264:	6069      	str	r1, [r5, #4]
 801b266:	60aa      	str	r2, [r5, #8]
 801b268:	60eb      	str	r3, [r5, #12]
 801b26a:	4664      	mov	r4, ip
 801b26c:	3510      	adds	r5, #16
 801b26e:	45f4      	cmp	ip, lr
 801b270:	d1f4      	bne.n	801b25c <CST_reboot_modem_event_mngt+0x18>
 801b272:	cc03      	ldmia	r4!, {r0, r1}
 801b274:	6028      	str	r0, [r5, #0]
 801b276:	6069      	str	r1, [r5, #4]
 801b278:	7823      	ldrb	r3, [r4, #0]
 801b27a:	722b      	strb	r3, [r5, #8]
 801b27c:	4c11      	ldr	r4, [pc, #68]	; (801b2c4 <CST_reboot_modem_event_mngt+0x80>)
 801b27e:	4620      	mov	r0, r4
 801b280:	f003 ff47 	bl	801f112 <crs_strlen>
 801b284:	b283      	uxth	r3, r0
 801b286:	4622      	mov	r2, r4
 801b288:	2101      	movs	r1, #1
 801b28a:	2007      	movs	r0, #7
 801b28c:	f003 ff84 	bl	801f198 <traceIF_itmPrint>
 801b290:	4620      	mov	r0, r4
 801b292:	f003 ff3e 	bl	801f112 <crs_strlen>
 801b296:	b283      	uxth	r3, r0
 801b298:	4622      	mov	r2, r4
 801b29a:	2101      	movs	r1, #1
 801b29c:	2007      	movs	r0, #7
 801b29e:	f003 ff9d 	bl	801f1dc <traceIF_uartPrint>
    CST_set_state(CST_MODEM_INIT_STATE);
 801b2a2:	2001      	movs	r0, #1
 801b2a4:	f7ff ff64 	bl	801b170 <CST_set_state>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801b2a8:	2100      	movs	r1, #0
 801b2aa:	2003      	movs	r0, #3
 801b2ac:	f002 f892 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b2b0:	2101      	movs	r1, #1
 801b2b2:	2000      	movs	r0, #0
 801b2b4:	f7ff fe98 	bl	801afe8 <CST_send_message>
}
 801b2b8:	e7c9      	b.n	801b24e <CST_reboot_modem_event_mngt+0xa>
 801b2ba:	bf00      	nop
 801b2bc:	200000b0 	.word	0x200000b0
 801b2c0:	08033c98 	.word	0x08033c98
 801b2c4:	20004ddc 	.word	0x20004ddc

0801b2c8 <CST_modem_off_state>:
{
 801b2c8:	b508      	push	{r3, lr}
  switch (autom_event)
 801b2ca:	280f      	cmp	r0, #15
 801b2cc:	d004      	beq.n	801b2d8 <CST_modem_off_state+0x10>
 801b2ce:	2811      	cmp	r0, #17
 801b2d0:	d008      	beq.n	801b2e4 <CST_modem_off_state+0x1c>
 801b2d2:	2801      	cmp	r0, #1
 801b2d4:	d003      	beq.n	801b2de <CST_modem_off_state+0x16>
}
 801b2d6:	bd08      	pop	{r3, pc}
      CST_off_state_target_cmd_state_mngt();
 801b2d8:	f7ff fd76 	bl	801adc8 <CST_off_state_target_cmd_state_mngt>
      break;
 801b2dc:	e7fb      	b.n	801b2d6 <CST_modem_off_state+0xe>
      CST_modem_off_mngt();
 801b2de:	f7ff fcef 	bl	801acc0 <CST_modem_off_mngt>
      break;
 801b2e2:	e7f8      	b.n	801b2d6 <CST_modem_off_state+0xe>
      CST_reboot_modem_event_mngt();
 801b2e4:	f7ff ffae 	bl	801b244 <CST_reboot_modem_event_mngt>
}
 801b2e8:	e7f5      	b.n	801b2d6 <CST_modem_off_state+0xe>

0801b2ea <CST_fail_state>:
  switch (autom_event)
 801b2ea:	2811      	cmp	r0, #17
 801b2ec:	d000      	beq.n	801b2f0 <CST_fail_state+0x6>
 801b2ee:	4770      	bx	lr
{
 801b2f0:	b508      	push	{r3, lr}
      CST_reboot_modem_event_mngt();
 801b2f2:	f7ff ffa7 	bl	801b244 <CST_reboot_modem_event_mngt>
}
 801b2f6:	bd08      	pop	{r3, pc}

0801b2f8 <CST_boot_power_on_only_modem_mngt>:
{
 801b2f8:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_boot_modem_power_on_only_mngt ********\n\r")
 801b2fa:	4c17      	ldr	r4, [pc, #92]	; (801b358 <CST_boot_power_on_only_modem_mngt+0x60>)
 801b2fc:	4d17      	ldr	r5, [pc, #92]	; (801b35c <CST_boot_power_on_only_modem_mngt+0x64>)
 801b2fe:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801b302:	46a4      	mov	ip, r4
 801b304:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b308:	6028      	str	r0, [r5, #0]
 801b30a:	6069      	str	r1, [r5, #4]
 801b30c:	60aa      	str	r2, [r5, #8]
 801b30e:	60eb      	str	r3, [r5, #12]
 801b310:	4664      	mov	r4, ip
 801b312:	3510      	adds	r5, #16
 801b314:	45f4      	cmp	ip, lr
 801b316:	d1f4      	bne.n	801b302 <CST_boot_power_on_only_modem_mngt+0xa>
 801b318:	cc03      	ldmia	r4!, {r0, r1}
 801b31a:	6028      	str	r0, [r5, #0]
 801b31c:	6069      	str	r1, [r5, #4]
 801b31e:	7823      	ldrb	r3, [r4, #0]
 801b320:	722b      	strb	r3, [r5, #8]
 801b322:	4c0e      	ldr	r4, [pc, #56]	; (801b35c <CST_boot_power_on_only_modem_mngt+0x64>)
 801b324:	4620      	mov	r0, r4
 801b326:	f003 fef4 	bl	801f112 <crs_strlen>
 801b32a:	b283      	uxth	r3, r0
 801b32c:	4622      	mov	r2, r4
 801b32e:	2101      	movs	r1, #1
 801b330:	2007      	movs	r0, #7
 801b332:	f003 ff31 	bl	801f198 <traceIF_itmPrint>
 801b336:	4620      	mov	r0, r4
 801b338:	f003 feeb 	bl	801f112 <crs_strlen>
 801b33c:	b283      	uxth	r3, r0
 801b33e:	4622      	mov	r2, r4
 801b340:	2101      	movs	r1, #1
 801b342:	2007      	movs	r0, #7
 801b344:	f003 ff4a 	bl	801f1dc <traceIF_uartPrint>
  CST_set_state(CST_MODEM_INIT_STATE);
 801b348:	2001      	movs	r0, #1
 801b34a:	f7ff ff11 	bl	801b170 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_POWER_ON_ONLY_EVENT);
 801b34e:	2112      	movs	r1, #18
 801b350:	2000      	movs	r0, #0
 801b352:	f7ff fe49 	bl	801afe8 <CST_send_message>
}
 801b356:	bd38      	pop	{r3, r4, r5, pc}
 801b358:	08033cc4 	.word	0x08033cc4
 801b35c:	20004ddc 	.word	0x20004ddc

0801b360 <CST_boot_state>:
{
 801b360:	b508      	push	{r3, lr}
  switch (autom_event)
 801b362:	2811      	cmp	r0, #17
 801b364:	d006      	beq.n	801b374 <CST_boot_state+0x14>
 801b366:	2812      	cmp	r0, #18
 801b368:	d007      	beq.n	801b37a <CST_boot_state+0x1a>
 801b36a:	b100      	cbz	r0, 801b36e <CST_boot_state+0xe>
}
 801b36c:	bd08      	pop	{r3, pc}
      CST_boot_event_mngt();
 801b36e:	f7ff ff33 	bl	801b1d8 <CST_boot_event_mngt>
      break;
 801b372:	e7fb      	b.n	801b36c <CST_boot_state+0xc>
      CST_reboot_modem_event_mngt();
 801b374:	f7ff ff66 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801b378:	e7f8      	b.n	801b36c <CST_boot_state+0xc>
      CST_boot_power_on_only_modem_mngt();
 801b37a:	f7ff ffbd 	bl	801b2f8 <CST_boot_power_on_only_modem_mngt>
}
 801b37e:	e7f5      	b.n	801b36c <CST_boot_state+0xc>

0801b380 <CST_init_state_mngt>:
{
 801b380:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_init_state_mngt ********\n\r")
 801b382:	4c33      	ldr	r4, [pc, #204]	; (801b450 <CST_init_state_mngt+0xd0>)
 801b384:	4d33      	ldr	r5, [pc, #204]	; (801b454 <CST_init_state_mngt+0xd4>)
 801b386:	f104 0e20 	add.w	lr, r4, #32
 801b38a:	46a4      	mov	ip, r4
 801b38c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b390:	6028      	str	r0, [r5, #0]
 801b392:	6069      	str	r1, [r5, #4]
 801b394:	60aa      	str	r2, [r5, #8]
 801b396:	60eb      	str	r3, [r5, #12]
 801b398:	4664      	mov	r4, ip
 801b39a:	3510      	adds	r5, #16
 801b39c:	45f4      	cmp	ip, lr
 801b39e:	d1f4      	bne.n	801b38a <CST_init_state_mngt+0xa>
 801b3a0:	cc03      	ldmia	r4!, {r0, r1}
 801b3a2:	6028      	str	r0, [r5, #0]
 801b3a4:	6069      	str	r1, [r5, #4]
 801b3a6:	8822      	ldrh	r2, [r4, #0]
 801b3a8:	78a3      	ldrb	r3, [r4, #2]
 801b3aa:	812a      	strh	r2, [r5, #8]
 801b3ac:	72ab      	strb	r3, [r5, #10]
 801b3ae:	4c29      	ldr	r4, [pc, #164]	; (801b454 <CST_init_state_mngt+0xd4>)
 801b3b0:	4620      	mov	r0, r4
 801b3b2:	f003 feae 	bl	801f112 <crs_strlen>
 801b3b6:	b283      	uxth	r3, r0
 801b3b8:	4622      	mov	r2, r4
 801b3ba:	2101      	movs	r1, #1
 801b3bc:	2007      	movs	r0, #7
 801b3be:	f003 feeb 	bl	801f198 <traceIF_itmPrint>
 801b3c2:	4620      	mov	r0, r4
 801b3c4:	f003 fea5 	bl	801f112 <crs_strlen>
 801b3c8:	b283      	uxth	r3, r0
 801b3ca:	4622      	mov	r2, r4
 801b3cc:	2101      	movs	r1, #1
 801b3ce:	2007      	movs	r0, #7
 801b3d0:	f003 ff04 	bl	801f1dc <traceIF_uartPrint>
  if (cst_cellular_params.target_state == DC_TARGET_STATE_OFF)
 801b3d4:	4b20      	ldr	r3, [pc, #128]	; (801b458 <CST_init_state_mngt+0xd8>)
 801b3d6:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b3da:	b11b      	cbz	r3, 801b3e4 <CST_init_state_mngt+0x64>
    if (cst_nfmc_context.nfmc_timer_on_going == false)
 801b3dc:	4b1f      	ldr	r3, [pc, #124]	; (801b45c <CST_init_state_mngt+0xdc>)
 801b3de:	785b      	ldrb	r3, [r3, #1]
 801b3e0:	b1ab      	cbz	r3, 801b40e <CST_init_state_mngt+0x8e>
}
 801b3e2:	bd70      	pop	{r4, r5, r6, pc}
    CST_set_state(CST_MODEM_OFF_STATE);
 801b3e4:	200d      	movs	r0, #13
 801b3e6:	f7ff fec3 	bl	801b170 <CST_set_state>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b3ea:	4e1d      	ldr	r6, [pc, #116]	; (801b460 <CST_init_state_mngt+0xe0>)
 801b3ec:	4c1d      	ldr	r4, [pc, #116]	; (801b464 <CST_init_state_mngt+0xe4>)
 801b3ee:	4d1e      	ldr	r5, [pc, #120]	; (801b468 <CST_init_state_mngt+0xe8>)
 801b3f0:	23f4      	movs	r3, #244	; 0xf4
 801b3f2:	4622      	mov	r2, r4
 801b3f4:	8831      	ldrh	r1, [r6, #0]
 801b3f6:	4628      	mov	r0, r5
 801b3f8:	f006 fae6 	bl	80219c8 <dc_com_read>
    cst_cellular_info.modem_state = DC_MODEM_STATE_OFF;
 801b3fc:	2300      	movs	r3, #0
 801b3fe:	7263      	strb	r3, [r4, #9]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b400:	23f4      	movs	r3, #244	; 0xf4
 801b402:	4622      	mov	r2, r4
 801b404:	8831      	ldrh	r1, [r6, #0]
 801b406:	4628      	mov	r0, r5
 801b408:	f006 fa92 	bl	8021930 <dc_com_write>
 801b40c:	e7e9      	b.n	801b3e2 <CST_init_state_mngt+0x62>
      cs_status = osCDS_power_on();
 801b40e:	f7ff fb15 	bl	801aa3c <osCDS_power_on>
      if (cs_status != CELLULAR_OK)
 801b412:	b130      	cbz	r0, 801b422 <CST_init_state_mngt+0xa2>
        CST_config_fail(((uint8_t *)"CST_cmd"),
 801b414:	2305      	movs	r3, #5
 801b416:	4a15      	ldr	r2, [pc, #84]	; (801b46c <CST_init_state_mngt+0xec>)
 801b418:	2101      	movs	r1, #1
 801b41a:	4815      	ldr	r0, [pc, #84]	; (801b470 <CST_init_state_mngt+0xf0>)
 801b41c:	f002 f81a 	bl	801d454 <CST_config_fail>
 801b420:	e7df      	b.n	801b3e2 <CST_init_state_mngt+0x62>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b422:	4e0f      	ldr	r6, [pc, #60]	; (801b460 <CST_init_state_mngt+0xe0>)
 801b424:	4c0f      	ldr	r4, [pc, #60]	; (801b464 <CST_init_state_mngt+0xe4>)
 801b426:	4d10      	ldr	r5, [pc, #64]	; (801b468 <CST_init_state_mngt+0xe8>)
 801b428:	23f4      	movs	r3, #244	; 0xf4
 801b42a:	4622      	mov	r2, r4
 801b42c:	8831      	ldrh	r1, [r6, #0]
 801b42e:	4628      	mov	r0, r5
 801b430:	f006 faca 	bl	80219c8 <dc_com_read>
        cst_cellular_info.rt_state    = DC_SERVICE_RUN;
 801b434:	2306      	movs	r3, #6
 801b436:	7223      	strb	r3, [r4, #8]
        cst_cellular_info.modem_state = DC_MODEM_STATE_POWERED_ON;
 801b438:	2301      	movs	r3, #1
 801b43a:	7263      	strb	r3, [r4, #9]
        (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b43c:	23f4      	movs	r3, #244	; 0xf4
 801b43e:	4622      	mov	r2, r4
 801b440:	8831      	ldrh	r1, [r6, #0]
 801b442:	4628      	mov	r0, r5
 801b444:	f006 fa74 	bl	8021930 <dc_com_write>
        CST_modem_sim_init();
 801b448:	f002 f902 	bl	801d650 <CST_modem_sim_init>
}
 801b44c:	e7c9      	b.n	801b3e2 <CST_init_state_mngt+0x62>
 801b44e:	bf00      	nop
 801b450:	08033aac 	.word	0x08033aac
 801b454:	20004ddc 	.word	0x20004ddc
 801b458:	20004160 	.word	0x20004160
 801b45c:	2000430c 	.word	0x2000430c
 801b460:	20000236 	.word	0x20000236
 801b464:	2000406c 	.word	0x2000406c
 801b468:	200058b0 	.word	0x200058b0
 801b46c:	200000c1 	.word	0x200000c1
 801b470:	08033ad8 	.word	0x08033ad8

0801b474 <CST_init_power_on_only_modem_mngt>:
{
 801b474:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_power_on_only_modem_mngt ********\n\r")
 801b476:	4d15      	ldr	r5, [pc, #84]	; (801b4cc <CST_init_power_on_only_modem_mngt+0x58>)
 801b478:	4c15      	ldr	r4, [pc, #84]	; (801b4d0 <CST_init_power_on_only_modem_mngt+0x5c>)
 801b47a:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801b47e:	46ac      	mov	ip, r5
 801b480:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b484:	6020      	str	r0, [r4, #0]
 801b486:	6061      	str	r1, [r4, #4]
 801b488:	60a2      	str	r2, [r4, #8]
 801b48a:	60e3      	str	r3, [r4, #12]
 801b48c:	4665      	mov	r5, ip
 801b48e:	3410      	adds	r4, #16
 801b490:	45f4      	cmp	ip, lr
 801b492:	d1f4      	bne.n	801b47e <CST_init_power_on_only_modem_mngt+0xa>
 801b494:	f8dc 0000 	ldr.w	r0, [ip]
 801b498:	6020      	str	r0, [r4, #0]
 801b49a:	4c0d      	ldr	r4, [pc, #52]	; (801b4d0 <CST_init_power_on_only_modem_mngt+0x5c>)
 801b49c:	4620      	mov	r0, r4
 801b49e:	f003 fe38 	bl	801f112 <crs_strlen>
 801b4a2:	b283      	uxth	r3, r0
 801b4a4:	4622      	mov	r2, r4
 801b4a6:	2101      	movs	r1, #1
 801b4a8:	2007      	movs	r0, #7
 801b4aa:	f003 fe75 	bl	801f198 <traceIF_itmPrint>
 801b4ae:	4620      	mov	r0, r4
 801b4b0:	f003 fe2f 	bl	801f112 <crs_strlen>
 801b4b4:	b283      	uxth	r3, r0
 801b4b6:	4622      	mov	r2, r4
 801b4b8:	2101      	movs	r1, #1
 801b4ba:	2007      	movs	r0, #7
 801b4bc:	f003 fe8e 	bl	801f1dc <traceIF_uartPrint>
  (void)osCDS_power_on();
 801b4c0:	f7ff fabc 	bl	801aa3c <osCDS_power_on>
  CST_set_state(CST_MODEM_POWER_ON_ONLY_STATE);
 801b4c4:	200e      	movs	r0, #14
 801b4c6:	f7ff fe53 	bl	801b170 <CST_set_state>
}
 801b4ca:	bd38      	pop	{r3, r4, r5, pc}
 801b4cc:	08033d00 	.word	0x08033d00
 801b4d0:	20004ddc 	.word	0x20004ddc

0801b4d4 <CST_target_state_cmd_event_mngt>:
{
 801b4d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (cst_cellular_params.target_state == DC_TARGET_STATE_SIM_ONLY)
 801b4d6:	4b4b      	ldr	r3, [pc, #300]	; (801b604 <CST_target_state_cmd_event_mngt+0x130>)
 801b4d8:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b4dc:	2b01      	cmp	r3, #1
 801b4de:	d003      	beq.n	801b4e8 <CST_target_state_cmd_event_mngt+0x14>
  else if (cst_cellular_params.target_state == DC_TARGET_STATE_OFF)
 801b4e0:	2b00      	cmp	r3, #0
 801b4e2:	d06e      	beq.n	801b5c2 <CST_target_state_cmd_event_mngt+0xee>
    __NOP();
 801b4e4:	bf00      	nop
}
 801b4e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_CELLULAR_SERVICE("****** Transition to CST_MODEM_SIM_ONLY_STATE Ongoing *****\n\r")
 801b4e8:	4d47      	ldr	r5, [pc, #284]	; (801b608 <CST_target_state_cmd_event_mngt+0x134>)
 801b4ea:	4c48      	ldr	r4, [pc, #288]	; (801b60c <CST_target_state_cmd_event_mngt+0x138>)
 801b4ec:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801b4f0:	46ac      	mov	ip, r5
 801b4f2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b4f6:	6020      	str	r0, [r4, #0]
 801b4f8:	6061      	str	r1, [r4, #4]
 801b4fa:	60a2      	str	r2, [r4, #8]
 801b4fc:	60e3      	str	r3, [r4, #12]
 801b4fe:	4665      	mov	r5, ip
 801b500:	3410      	adds	r4, #16
 801b502:	45f4      	cmp	ip, lr
 801b504:	d1f4      	bne.n	801b4f0 <CST_target_state_cmd_event_mngt+0x1c>
 801b506:	cd07      	ldmia	r5!, {r0, r1, r2}
 801b508:	6020      	str	r0, [r4, #0]
 801b50a:	6061      	str	r1, [r4, #4]
 801b50c:	60a2      	str	r2, [r4, #8]
 801b50e:	882b      	ldrh	r3, [r5, #0]
 801b510:	81a3      	strh	r3, [r4, #12]
 801b512:	4c3e      	ldr	r4, [pc, #248]	; (801b60c <CST_target_state_cmd_event_mngt+0x138>)
 801b514:	4620      	mov	r0, r4
 801b516:	f003 fdfc 	bl	801f112 <crs_strlen>
 801b51a:	b283      	uxth	r3, r0
 801b51c:	4622      	mov	r2, r4
 801b51e:	2101      	movs	r1, #1
 801b520:	2007      	movs	r0, #7
 801b522:	f003 fe39 	bl	801f198 <traceIF_itmPrint>
 801b526:	4620      	mov	r0, r4
 801b528:	f003 fdf3 	bl	801f112 <crs_strlen>
 801b52c:	b283      	uxth	r3, r0
 801b52e:	4622      	mov	r2, r4
 801b530:	2101      	movs	r1, #1
 801b532:	2007      	movs	r0, #7
 801b534:	f003 fe52 	bl	801f1dc <traceIF_uartPrint>
    (void) osCDS_init_modem(CS_CMI_SIM_ONLY, CELLULAR_FALSE, CST_SIM_PINCODE);
 801b538:	4a35      	ldr	r2, [pc, #212]	; (801b610 <CST_target_state_cmd_event_mngt+0x13c>)
 801b53a:	2100      	movs	r1, #0
 801b53c:	2002      	movs	r0, #2
 801b53e:	f7ff faa1 	bl	801aa84 <osCDS_init_modem>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b542:	4f34      	ldr	r7, [pc, #208]	; (801b614 <CST_target_state_cmd_event_mngt+0x140>)
 801b544:	4d34      	ldr	r5, [pc, #208]	; (801b618 <CST_target_state_cmd_event_mngt+0x144>)
 801b546:	4e35      	ldr	r6, [pc, #212]	; (801b61c <CST_target_state_cmd_event_mngt+0x148>)
 801b548:	23f4      	movs	r3, #244	; 0xf4
 801b54a:	462a      	mov	r2, r5
 801b54c:	8839      	ldrh	r1, [r7, #0]
 801b54e:	4630      	mov	r0, r6
 801b550:	f006 fa3a 	bl	80219c8 <dc_com_read>
    cst_cellular_info.modem_state = DC_MODEM_STATE_SIM_CONNECTED;
 801b554:	2302      	movs	r3, #2
 801b556:	726b      	strb	r3, [r5, #9]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b558:	23f4      	movs	r3, #244	; 0xf4
 801b55a:	462a      	mov	r2, r5
 801b55c:	8839      	ldrh	r1, [r7, #0]
 801b55e:	4630      	mov	r0, r6
 801b560:	f006 f9e6 	bl	8021930 <dc_com_write>
    CST_set_state(CST_MODEM_SIM_ONLY_STATE);
 801b564:	200b      	movs	r0, #11
 801b566:	f7ff fe03 	bl	801b170 <CST_set_state>
    PRINT_CELLULAR_SERVICE("****** CST_MODEM_SIM_ONLY_STATE *****\n\r")
 801b56a:	4d2d      	ldr	r5, [pc, #180]	; (801b620 <CST_target_state_cmd_event_mngt+0x14c>)
 801b56c:	46a4      	mov	ip, r4
 801b56e:	f105 0e20 	add.w	lr, r5, #32
 801b572:	462c      	mov	r4, r5
 801b574:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801b576:	f8cc 0000 	str.w	r0, [ip]
 801b57a:	f8cc 1004 	str.w	r1, [ip, #4]
 801b57e:	f8cc 2008 	str.w	r2, [ip, #8]
 801b582:	f8cc 300c 	str.w	r3, [ip, #12]
 801b586:	4625      	mov	r5, r4
 801b588:	f10c 0c10 	add.w	ip, ip, #16
 801b58c:	4574      	cmp	r4, lr
 801b58e:	d1f0      	bne.n	801b572 <CST_target_state_cmd_event_mngt+0x9e>
 801b590:	cd03      	ldmia	r5!, {r0, r1}
 801b592:	f8cc 0000 	str.w	r0, [ip]
 801b596:	f8cc 1004 	str.w	r1, [ip, #4]
 801b59a:	4c1c      	ldr	r4, [pc, #112]	; (801b60c <CST_target_state_cmd_event_mngt+0x138>)
 801b59c:	4620      	mov	r0, r4
 801b59e:	f003 fdb8 	bl	801f112 <crs_strlen>
 801b5a2:	b283      	uxth	r3, r0
 801b5a4:	4622      	mov	r2, r4
 801b5a6:	2101      	movs	r1, #1
 801b5a8:	2007      	movs	r0, #7
 801b5aa:	f003 fdf5 	bl	801f198 <traceIF_itmPrint>
 801b5ae:	4620      	mov	r0, r4
 801b5b0:	f003 fdaf 	bl	801f112 <crs_strlen>
 801b5b4:	b283      	uxth	r3, r0
 801b5b6:	4622      	mov	r2, r4
 801b5b8:	2101      	movs	r1, #1
 801b5ba:	2007      	movs	r0, #7
 801b5bc:	f003 fe0e 	bl	801f1dc <traceIF_uartPrint>
 801b5c0:	e791      	b.n	801b4e6 <CST_target_state_cmd_event_mngt+0x12>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801b5c2:	4e18      	ldr	r6, [pc, #96]	; (801b624 <CST_target_state_cmd_event_mngt+0x150>)
 801b5c4:	4c18      	ldr	r4, [pc, #96]	; (801b628 <CST_target_state_cmd_event_mngt+0x154>)
 801b5c6:	4d15      	ldr	r5, [pc, #84]	; (801b61c <CST_target_state_cmd_event_mngt+0x148>)
 801b5c8:	2330      	movs	r3, #48	; 0x30
 801b5ca:	4622      	mov	r2, r4
 801b5cc:	8831      	ldrh	r1, [r6, #0]
 801b5ce:	4628      	mov	r0, r5
 801b5d0:	f006 f9fa 	bl	80219c8 <dc_com_read>
    cst_sim_info.rt_state = DC_SERVICE_OFF;
 801b5d4:	2303      	movs	r3, #3
 801b5d6:	7223      	strb	r3, [r4, #8]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801b5d8:	2330      	movs	r3, #48	; 0x30
 801b5da:	4622      	mov	r2, r4
 801b5dc:	8831      	ldrh	r1, [r6, #0]
 801b5de:	4628      	mov	r0, r5
 801b5e0:	f006 f9a6 	bl	8021930 <dc_com_write>
    (void) osCDS_init_modem(CS_CMI_MINI, CELLULAR_FALSE, CST_SIM_PINCODE);
 801b5e4:	4a0a      	ldr	r2, [pc, #40]	; (801b610 <CST_target_state_cmd_event_mngt+0x13c>)
 801b5e6:	2100      	movs	r1, #0
 801b5e8:	4608      	mov	r0, r1
 801b5ea:	f7ff fa4b 	bl	801aa84 <osCDS_init_modem>
    (void)osCDS_power_off();
 801b5ee:	f7ff fa37 	bl	801aa60 <osCDS_power_off>
    CST_set_state(CST_MODEM_OFF_STATE);
 801b5f2:	200d      	movs	r0, #13
 801b5f4:	f7ff fdbc 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b5f8:	2101      	movs	r1, #1
 801b5fa:	2000      	movs	r0, #0
 801b5fc:	f7ff fcf4 	bl	801afe8 <CST_send_message>
 801b600:	e771      	b.n	801b4e6 <CST_target_state_cmd_event_mngt+0x12>
 801b602:	bf00      	nop
 801b604:	20004160 	.word	0x20004160
 801b608:	08033d34 	.word	0x08033d34
 801b60c:	20004ddc 	.word	0x20004ddc
 801b610:	08034f74 	.word	0x08034f74
 801b614:	20000236 	.word	0x20000236
 801b618:	2000406c 	.word	0x2000406c
 801b61c:	200058b0 	.word	0x200058b0
 801b620:	08033d74 	.word	0x08033d74
 801b624:	2000023c 	.word	0x2000023c
 801b628:	20004338 	.word	0x20004338

0801b62c <CST_data_mode_target_state_event_mngt>:
{
 801b62c:	b508      	push	{r3, lr}
  if (cst_cellular_params.target_state != DC_TARGET_STATE_FULL)
 801b62e:	4b06      	ldr	r3, [pc, #24]	; (801b648 <CST_data_mode_target_state_event_mngt+0x1c>)
 801b630:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b634:	2b02      	cmp	r3, #2
 801b636:	d100      	bne.n	801b63a <CST_data_mode_target_state_event_mngt+0xe>
}
 801b638:	bd08      	pop	{r3, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801b63a:	2100      	movs	r1, #0
 801b63c:	2003      	movs	r0, #3
 801b63e:	f001 fec9 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    CST_target_state_cmd_event_mngt();
 801b642:	f7ff ff47 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
}
 801b646:	e7f7      	b.n	801b638 <CST_data_mode_target_state_event_mngt+0xc>
 801b648:	20004160 	.word	0x20004160

0801b64c <CST_fota_start_event_mngt>:
{
 801b64c:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("Modem event received:  CS_MDMEVENT_FOTA_START\n\r")
 801b64e:	4d1e      	ldr	r5, [pc, #120]	; (801b6c8 <CST_fota_start_event_mngt+0x7c>)
 801b650:	4c1e      	ldr	r4, [pc, #120]	; (801b6cc <CST_fota_start_event_mngt+0x80>)
 801b652:	f105 0630 	add.w	r6, r5, #48	; 0x30
 801b656:	46ac      	mov	ip, r5
 801b658:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b65c:	6020      	str	r0, [r4, #0]
 801b65e:	6061      	str	r1, [r4, #4]
 801b660:	60a2      	str	r2, [r4, #8]
 801b662:	60e3      	str	r3, [r4, #12]
 801b664:	4665      	mov	r5, ip
 801b666:	3410      	adds	r4, #16
 801b668:	45b4      	cmp	ip, r6
 801b66a:	d1f4      	bne.n	801b656 <CST_fota_start_event_mngt+0xa>
 801b66c:	4c17      	ldr	r4, [pc, #92]	; (801b6cc <CST_fota_start_event_mngt+0x80>)
 801b66e:	4620      	mov	r0, r4
 801b670:	f003 fd4f 	bl	801f112 <crs_strlen>
 801b674:	b283      	uxth	r3, r0
 801b676:	4622      	mov	r2, r4
 801b678:	2101      	movs	r1, #1
 801b67a:	2007      	movs	r0, #7
 801b67c:	f003 fd8c 	bl	801f198 <traceIF_itmPrint>
 801b680:	4620      	mov	r0, r4
 801b682:	f003 fd46 	bl	801f112 <crs_strlen>
 801b686:	b283      	uxth	r3, r0
 801b688:	4622      	mov	r2, r4
 801b68a:	2101      	movs	r1, #1
 801b68c:	2007      	movs	r0, #7
 801b68e:	f003 fda5 	bl	801f1dc <traceIF_uartPrint>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801b692:	4e0f      	ldr	r6, [pc, #60]	; (801b6d0 <CST_fota_start_event_mngt+0x84>)
 801b694:	4c0f      	ldr	r4, [pc, #60]	; (801b6d4 <CST_fota_start_event_mngt+0x88>)
 801b696:	4d10      	ldr	r5, [pc, #64]	; (801b6d8 <CST_fota_start_event_mngt+0x8c>)
 801b698:	2310      	movs	r3, #16
 801b69a:	4622      	mov	r2, r4
 801b69c:	8831      	ldrh	r1, [r6, #0]
 801b69e:	4628      	mov	r0, r5
 801b6a0:	f006 f992 	bl	80219c8 <dc_com_read>
  cst_cellular_data_info.rt_state = DC_SERVICE_SHUTTING_DOWN;
 801b6a4:	2304      	movs	r3, #4
 801b6a6:	7223      	strb	r3, [r4, #8]
  CST_set_state(CST_MODEM_REPROG_STATE);
 801b6a8:	2009      	movs	r0, #9
 801b6aa:	f7ff fd61 	bl	801b170 <CST_set_state>
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801b6ae:	2310      	movs	r3, #16
 801b6b0:	4622      	mov	r2, r4
 801b6b2:	8831      	ldrh	r1, [r6, #0]
 801b6b4:	4628      	mov	r0, r5
 801b6b6:	f006 f93b 	bl	8021930 <dc_com_write>
  (void)rtosalTimerStart(cst_fota_timer_handle, CST_FOTA_TIMEOUT);
 801b6ba:	4908      	ldr	r1, [pc, #32]	; (801b6dc <CST_fota_start_event_mngt+0x90>)
 801b6bc:	4b08      	ldr	r3, [pc, #32]	; (801b6e0 <CST_fota_start_event_mngt+0x94>)
 801b6be:	6818      	ldr	r0, [r3, #0]
 801b6c0:	f003 fc77 	bl	801efb2 <rtosalTimerStart>
}
 801b6c4:	bd70      	pop	{r4, r5, r6, pc}
 801b6c6:	bf00      	nop
 801b6c8:	08033d9c 	.word	0x08033d9c
 801b6cc:	20004ddc 	.word	0x20004ddc
 801b6d0:	20000234 	.word	0x20000234
 801b6d4:	2000405c 	.word	0x2000405c
 801b6d8:	200058b0 	.word	0x200058b0
 801b6dc:	00057e40 	.word	0x00057e40
 801b6e0:	20004304 	.word	0x20004304

0801b6e4 <CST_init_state>:
{
 801b6e4:	b508      	push	{r3, lr}
  switch (autom_event)
 801b6e6:	3801      	subs	r0, #1
 801b6e8:	2814      	cmp	r0, #20
 801b6ea:	d80e      	bhi.n	801b70a <CST_init_state+0x26>
 801b6ec:	e8df f000 	tbb	[pc, r0]
 801b6f0:	0d0d0d0b 	.word	0x0d0d0d0b
 801b6f4:	0d0d0d0d 	.word	0x0d0d0d0d
 801b6f8:	0d0d0d0d 	.word	0x0d0d0d0d
 801b6fc:	0d160d0d 	.word	0x0d160d0d
 801b700:	0d0d1013 	.word	0x0d0d1013
 801b704:	19          	.byte	0x19
 801b705:	00          	.byte	0x00
      CST_init_state_mngt();
 801b706:	f7ff fe3b 	bl	801b380 <CST_init_state_mngt>
  CST_subscribe_modem_events();
 801b70a:	f002 fc15 	bl	801df38 <CST_subscribe_modem_events>
}
 801b70e:	bd08      	pop	{r3, pc}
      CST_init_power_on_only_modem_mngt();
 801b710:	f7ff feb0 	bl	801b474 <CST_init_power_on_only_modem_mngt>
      break;
 801b714:	e7f9      	b.n	801b70a <CST_init_state+0x26>
      CST_reboot_modem_event_mngt();
 801b716:	f7ff fd95 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801b71a:	e7f6      	b.n	801b70a <CST_init_state+0x26>
      CST_target_state_cmd_event_mngt();
 801b71c:	f7ff feda 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801b720:	e7f3      	b.n	801b70a <CST_init_state+0x26>
      CST_fota_start_event_mngt();
 801b722:	f7ff ff93 	bl	801b64c <CST_fota_start_event_mngt>
      break;
 801b726:	e7f0      	b.n	801b70a <CST_init_state+0x26>

0801b728 <CST_net_register_mngt>:
{
 801b728:	b530      	push	{r4, r5, lr}
 801b72a:	b095      	sub	sp, #84	; 0x54
  PRINT_CELLULAR_SERVICE("=== CST_net_register_mngt ===\n\r")
 801b72c:	4c39      	ldr	r4, [pc, #228]	; (801b814 <CST_net_register_mngt+0xec>)
 801b72e:	4d3a      	ldr	r5, [pc, #232]	; (801b818 <CST_net_register_mngt+0xf0>)
 801b730:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801b732:	6020      	str	r0, [r4, #0]
 801b734:	6061      	str	r1, [r4, #4]
 801b736:	60a2      	str	r2, [r4, #8]
 801b738:	60e3      	str	r3, [r4, #12]
 801b73a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801b73c:	6120      	str	r0, [r4, #16]
 801b73e:	6161      	str	r1, [r4, #20]
 801b740:	61a2      	str	r2, [r4, #24]
 801b742:	61e3      	str	r3, [r4, #28]
 801b744:	4620      	mov	r0, r4
 801b746:	f003 fce4 	bl	801f112 <crs_strlen>
 801b74a:	b283      	uxth	r3, r0
 801b74c:	4622      	mov	r2, r4
 801b74e:	2101      	movs	r1, #1
 801b750:	2007      	movs	r0, #7
 801b752:	f003 fd21 	bl	801f198 <traceIF_itmPrint>
 801b756:	4620      	mov	r0, r4
 801b758:	f003 fcdb 	bl	801f112 <crs_strlen>
 801b75c:	b283      	uxth	r3, r0
 801b75e:	4622      	mov	r2, r4
 801b760:	2101      	movs	r1, #1
 801b762:	2007      	movs	r0, #7
 801b764:	f003 fd3a 	bl	801f1dc <traceIF_uartPrint>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params));
 801b768:	4c2c      	ldr	r4, [pc, #176]	; (801b81c <CST_net_register_mngt+0xf4>)
 801b76a:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801b76e:	4622      	mov	r2, r4
 801b770:	492b      	ldr	r1, [pc, #172]	; (801b820 <CST_net_register_mngt+0xf8>)
 801b772:	8809      	ldrh	r1, [r1, #0]
 801b774:	482b      	ldr	r0, [pc, #172]	; (801b824 <CST_net_register_mngt+0xfc>)
 801b776:	f006 f927 	bl	80219c8 <dc_com_read>
  ctxt_operator.mode = (CS_NetworkRegMode_t)cst_cellular_params.operator_selector.network_reg_mode;
 801b77a:	f894 3138 	ldrb.w	r3, [r4, #312]	; 0x138
 801b77e:	4d2a      	ldr	r5, [pc, #168]	; (801b828 <CST_net_register_mngt+0x100>)
 801b780:	802b      	strh	r3, [r5, #0]
  ctxt_operator.format = (CS_OperatorNameFormat_t)cst_cellular_params.operator_selector.operator_name_format;
 801b782:	f894 3139 	ldrb.w	r3, [r4, #313]	; 0x139
 801b786:	806b      	strh	r3, [r5, #2]
  (void)memcpy(ctxt_operator.operator_name, cst_cellular_params.operator_selector.operator_name,
 801b788:	f504 7c9d 	add.w	ip, r4, #314	; 0x13a
 801b78c:	3504      	adds	r5, #4
 801b78e:	f504 74bd 	add.w	r4, r4, #378	; 0x17a
 801b792:	46ae      	mov	lr, r5
 801b794:	f8dc 0000 	ldr.w	r0, [ip]
 801b798:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801b79c:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801b7a0:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801b7a4:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801b7a8:	f10c 0c10 	add.w	ip, ip, #16
 801b7ac:	4675      	mov	r5, lr
 801b7ae:	45a4      	cmp	ip, r4
 801b7b0:	d1ef      	bne.n	801b792 <CST_net_register_mngt+0x6a>
  ctxt_operator.AcT_present = (CS_Bool_t)cst_cellular_params.operator_selector.access_techno_present;
 801b7b2:	4b1a      	ldr	r3, [pc, #104]	; (801b81c <CST_net_register_mngt+0xf4>)
 801b7b4:	f893 217a 	ldrb.w	r2, [r3, #378]	; 0x17a
 801b7b8:	481b      	ldr	r0, [pc, #108]	; (801b828 <CST_net_register_mngt+0x100>)
 801b7ba:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
  ctxt_operator.AcT = (CS_AccessTechno_t)cst_cellular_params.operator_selector.access_techno;
 801b7be:	f893 317b 	ldrb.w	r3, [r3, #379]	; 0x17b
 801b7c2:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  cs_status = osCDS_register_net(&ctxt_operator, &cst_ctxt_reg_status);
 801b7c6:	4669      	mov	r1, sp
 801b7c8:	f7ff f974 	bl	801aab4 <osCDS_register_net>
  if (cs_status == CELLULAR_OK)
 801b7cc:	b9a0      	cbnz	r0, 801b7f8 <CST_net_register_mngt+0xd0>
    cst_context.current_EPS_NetworkRegState  = cst_ctxt_reg_status.EPS_NetworkRegState;
 801b7ce:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 801b7d2:	4b16      	ldr	r3, [pc, #88]	; (801b82c <CST_net_register_mngt+0x104>)
 801b7d4:	80da      	strh	r2, [r3, #6]
    cst_context.current_GPRS_NetworkRegState = cst_ctxt_reg_status.GPRS_NetworkRegState;
 801b7d6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 801b7da:	811a      	strh	r2, [r3, #8]
    cst_context.current_CS_NetworkRegState   = cst_ctxt_reg_status.CS_NetworkRegState;
 801b7dc:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 801b7e0:	815a      	strh	r2, [r3, #10]
    (void)osCDS_attach_PS_domain();
 801b7e2:	f7ff f991 	bl	801ab08 <osCDS_attach_PS_domain>
    CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801b7e6:	2003      	movs	r0, #3
 801b7e8:	f7ff fcc2 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_SIGNAL_QUALITY_TO_CHECK_EVENT);
 801b7ec:	2103      	movs	r1, #3
 801b7ee:	2000      	movs	r0, #0
 801b7f0:	f7ff fbfa 	bl	801afe8 <CST_send_message>
}
 801b7f4:	b015      	add	sp, #84	; 0x54
 801b7f6:	bd30      	pop	{r4, r5, pc}
    CST_config_fail(((uint8_t *)"CST_net_register_mngt"),
 801b7f8:	4c0c      	ldr	r4, [pc, #48]	; (801b82c <CST_net_register_mngt+0x104>)
 801b7fa:	2305      	movs	r3, #5
 801b7fc:	f104 0216 	add.w	r2, r4, #22
 801b800:	2104      	movs	r1, #4
 801b802:	480b      	ldr	r0, [pc, #44]	; (801b830 <CST_net_register_mngt+0x108>)
 801b804:	f001 fe26 	bl	801d454 <CST_config_fail>
    cst_context.current_EPS_NetworkRegState  = CS_NRS_NOT_REGISTERED_SEARCHING;
 801b808:	2302      	movs	r3, #2
 801b80a:	80e3      	strh	r3, [r4, #6]
    cst_context.current_GPRS_NetworkRegState = CS_NRS_NOT_REGISTERED_SEARCHING;
 801b80c:	8123      	strh	r3, [r4, #8]
    cst_context.current_CS_NetworkRegState   = CS_NRS_NOT_REGISTERED_SEARCHING;
 801b80e:	8163      	strh	r3, [r4, #10]
}
 801b810:	e7f0      	b.n	801b7f4 <CST_net_register_mngt+0xcc>
 801b812:	bf00      	nop
 801b814:	20004ddc 	.word	0x20004ddc
 801b818:	08033dcc 	.word	0x08033dcc
 801b81c:	20004160 	.word	0x20004160
 801b820:	20000232 	.word	0x20000232
 801b824:	200058b0 	.word	0x200058b0
 801b828:	20004368 	.word	0x20004368
 801b82c:	200000b0 	.word	0x200000b0
 801b830:	08033dec 	.word	0x08033dec

0801b834 <CST_modem_ready_state>:
{
 801b834:	b508      	push	{r3, lr}
  switch (autom_event)
 801b836:	3802      	subs	r0, #2
 801b838:	2813      	cmp	r0, #19
 801b83a:	d80d      	bhi.n	801b858 <CST_modem_ready_state+0x24>
 801b83c:	e8df f000 	tbb	[pc, r0]
 801b840:	0c0c0c0a 	.word	0x0c0c0c0a
 801b844:	0c0c0c0c 	.word	0x0c0c0c0c
 801b848:	0c0c0c0c 	.word	0x0c0c0c0c
 801b84c:	100c0d0c 	.word	0x100c0d0c
 801b850:	130c0c0c 	.word	0x130c0c0c
      CST_net_register_mngt();
 801b854:	f7ff ff68 	bl	801b728 <CST_net_register_mngt>
}
 801b858:	bd08      	pop	{r3, pc}
      CST_target_state_cmd_event_mngt();
 801b85a:	f7ff fe3b 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801b85e:	e7fb      	b.n	801b858 <CST_modem_ready_state+0x24>
      CST_reboot_modem_event_mngt();
 801b860:	f7ff fcf0 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801b864:	e7f8      	b.n	801b858 <CST_modem_ready_state+0x24>
      CST_fota_start_event_mngt();
 801b866:	f7ff fef1 	bl	801b64c <CST_fota_start_event_mngt>
}
 801b86a:	e7f5      	b.n	801b858 <CST_modem_ready_state+0x24>

0801b86c <CST_signal_quality_test_mngt>:
{
 801b86c:	b538      	push	{r3, r4, r5, lr}
  cs_status = CST_set_signal_quality();
 801b86e:	f002 fa8d 	bl	801dd8c <CST_set_signal_quality>
  if (cs_status == CELLULAR_OK)
 801b872:	b100      	cbz	r0, 801b876 <CST_signal_quality_test_mngt+0xa>
}
 801b874:	bd38      	pop	{r3, r4, r5, pc}
    (void)rtosalTimerStart(cst_network_status_timer_handle, cst_cellular_params.attachment_timeout);
 801b876:	4d14      	ldr	r5, [pc, #80]	; (801b8c8 <CST_signal_quality_test_mngt+0x5c>)
 801b878:	f8d5 1134 	ldr.w	r1, [r5, #308]	; 0x134
 801b87c:	4b13      	ldr	r3, [pc, #76]	; (801b8cc <CST_signal_quality_test_mngt+0x60>)
 801b87e:	6818      	ldr	r0, [r3, #0]
 801b880:	f003 fb97 	bl	801efb2 <rtosalTimerStart>
    PRINT_CELLULAR_SERVICE("-----> Start NW REG TIMEOUT TIMER   : %ld\n\r", cst_cellular_params.attachment_timeout)
 801b884:	4c12      	ldr	r4, [pc, #72]	; (801b8d0 <CST_signal_quality_test_mngt+0x64>)
 801b886:	f8d5 2134 	ldr.w	r2, [r5, #308]	; 0x134
 801b88a:	4912      	ldr	r1, [pc, #72]	; (801b8d4 <CST_signal_quality_test_mngt+0x68>)
 801b88c:	4620      	mov	r0, r4
 801b88e:	f00a f9ef 	bl	8025c70 <sprintf>
 801b892:	4620      	mov	r0, r4
 801b894:	f003 fc3d 	bl	801f112 <crs_strlen>
 801b898:	b283      	uxth	r3, r0
 801b89a:	4622      	mov	r2, r4
 801b89c:	2101      	movs	r1, #1
 801b89e:	2007      	movs	r0, #7
 801b8a0:	f003 fc7a 	bl	801f198 <traceIF_itmPrint>
 801b8a4:	4620      	mov	r0, r4
 801b8a6:	f003 fc34 	bl	801f112 <crs_strlen>
 801b8aa:	b283      	uxth	r3, r0
 801b8ac:	4622      	mov	r2, r4
 801b8ae:	2101      	movs	r1, #1
 801b8b0:	2007      	movs	r0, #7
 801b8b2:	f003 fc93 	bl	801f1dc <traceIF_uartPrint>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801b8b6:	2004      	movs	r0, #4
 801b8b8:	f7ff fc5a 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_STATUS_TO_CHECK_EVENT);
 801b8bc:	2104      	movs	r1, #4
 801b8be:	2000      	movs	r0, #0
 801b8c0:	f7ff fb92 	bl	801afe8 <CST_send_message>
}
 801b8c4:	e7d6      	b.n	801b874 <CST_signal_quality_test_mngt+0x8>
 801b8c6:	bf00      	nop
 801b8c8:	20004160 	.word	0x20004160
 801b8cc:	20004308 	.word	0x20004308
 801b8d0:	20004ddc 	.word	0x20004ddc
 801b8d4:	08033e04 	.word	0x08033e04

0801b8d8 <CST_network_event_mngt>:
{
 801b8d8:	b510      	push	{r4, lr}
  ret = CST_get_network_status();
 801b8da:	f002 fb9d 	bl	801e018 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801b8de:	b330      	cbz	r0, 801b92e <CST_network_event_mngt+0x56>
  else if (ret == CST_NOT_REGISTERED)
 801b8e0:	2801      	cmp	r0, #1
 801b8e2:	d02c      	beq.n	801b93e <CST_network_event_mngt+0x66>
  else if (ret == CST_NET_UNKNOWN)
 801b8e4:	2803      	cmp	r0, #3
 801b8e6:	d032      	beq.n	801b94e <CST_network_event_mngt+0x76>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801b8e8:	2100      	movs	r1, #0
 801b8ea:	2003      	movs	r0, #3
 801b8ec:	f001 fd72 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    PRINT_CELLULAR_SERVICE("******** CST_network_event_mngt: osCDS_get_net_status FAIL ****\n\r")
 801b8f0:	4c19      	ldr	r4, [pc, #100]	; (801b958 <CST_network_event_mngt+0x80>)
 801b8f2:	2242      	movs	r2, #66	; 0x42
 801b8f4:	4919      	ldr	r1, [pc, #100]	; (801b95c <CST_network_event_mngt+0x84>)
 801b8f6:	4620      	mov	r0, r4
 801b8f8:	f00a fb0a 	bl	8025f10 <memcpy>
 801b8fc:	4620      	mov	r0, r4
 801b8fe:	f003 fc08 	bl	801f112 <crs_strlen>
 801b902:	b283      	uxth	r3, r0
 801b904:	4622      	mov	r2, r4
 801b906:	2101      	movs	r1, #1
 801b908:	2007      	movs	r0, #7
 801b90a:	f003 fc45 	bl	801f198 <traceIF_itmPrint>
 801b90e:	4620      	mov	r0, r4
 801b910:	f003 fbff 	bl	801f112 <crs_strlen>
 801b914:	b283      	uxth	r3, r0
 801b916:	4622      	mov	r2, r4
 801b918:	2101      	movs	r1, #1
 801b91a:	2007      	movs	r0, #7
 801b91c:	f003 fc5e 	bl	801f1dc <traceIF_uartPrint>
    CST_config_fail(((uint8_t *)"CST_network_status_test_mngt"),
 801b920:	2305      	movs	r3, #5
 801b922:	4a0f      	ldr	r2, [pc, #60]	; (801b960 <CST_network_event_mngt+0x88>)
 801b924:	4619      	mov	r1, r3
 801b926:	480f      	ldr	r0, [pc, #60]	; (801b964 <CST_network_event_mngt+0x8c>)
 801b928:	f001 fd94 	bl	801d454 <CST_config_fail>
}
 801b92c:	bd10      	pop	{r4, pc}
    CST_set_state(CST_NETWORK_STATUS_OK_STATE);
 801b92e:	2005      	movs	r0, #5
 801b930:	f7ff fc1e 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_STATUS_OK_EVENT);
 801b934:	2105      	movs	r1, #5
 801b936:	2000      	movs	r0, #0
 801b938:	f7ff fb56 	bl	801afe8 <CST_send_message>
 801b93c:	e7f6      	b.n	801b92c <CST_network_event_mngt+0x54>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801b93e:	2100      	movs	r1, #0
 801b940:	2003      	movs	r0, #3
 801b942:	f001 fd47 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801b946:	2004      	movs	r0, #4
 801b948:	f7ff fc12 	bl	801b170 <CST_set_state>
 801b94c:	e7ee      	b.n	801b92c <CST_network_event_mngt+0x54>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801b94e:	210d      	movs	r1, #13
 801b950:	2000      	movs	r0, #0
 801b952:	f7ff fb49 	bl	801afe8 <CST_send_message>
 801b956:	e7e9      	b.n	801b92c <CST_network_event_mngt+0x54>
 801b958:	20004ddc 	.word	0x20004ddc
 801b95c:	08033e30 	.word	0x08033e30
 801b960:	200000c7 	.word	0x200000c7
 801b964:	08033e74 	.word	0x08033e74

0801b968 <CST_waiting_for_signal_quality_ok_state>:
{
 801b968:	b570      	push	{r4, r5, r6, lr}
 801b96a:	4606      	mov	r6, r0
  PRINT_CELLULAR_SERVICE("\n\r ====> CST_waiting_for_signal_quality_ok_state <===== \n\r")
 801b96c:	4c23      	ldr	r4, [pc, #140]	; (801b9fc <CST_waiting_for_signal_quality_ok_state+0x94>)
 801b96e:	4d24      	ldr	r5, [pc, #144]	; (801ba00 <CST_waiting_for_signal_quality_ok_state+0x98>)
 801b970:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801b974:	46a4      	mov	ip, r4
 801b976:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b97a:	6028      	str	r0, [r5, #0]
 801b97c:	6069      	str	r1, [r5, #4]
 801b97e:	60aa      	str	r2, [r5, #8]
 801b980:	60eb      	str	r3, [r5, #12]
 801b982:	4664      	mov	r4, ip
 801b984:	3510      	adds	r5, #16
 801b986:	45f4      	cmp	ip, lr
 801b988:	d1f4      	bne.n	801b974 <CST_waiting_for_signal_quality_ok_state+0xc>
 801b98a:	cc03      	ldmia	r4!, {r0, r1}
 801b98c:	6028      	str	r0, [r5, #0]
 801b98e:	6069      	str	r1, [r5, #4]
 801b990:	8822      	ldrh	r2, [r4, #0]
 801b992:	78a3      	ldrb	r3, [r4, #2]
 801b994:	812a      	strh	r2, [r5, #8]
 801b996:	72ab      	strb	r3, [r5, #10]
 801b998:	4c19      	ldr	r4, [pc, #100]	; (801ba00 <CST_waiting_for_signal_quality_ok_state+0x98>)
 801b99a:	4620      	mov	r0, r4
 801b99c:	f003 fbb9 	bl	801f112 <crs_strlen>
 801b9a0:	b283      	uxth	r3, r0
 801b9a2:	4622      	mov	r2, r4
 801b9a4:	2101      	movs	r1, #1
 801b9a6:	2007      	movs	r0, #7
 801b9a8:	f003 fbf6 	bl	801f198 <traceIF_itmPrint>
 801b9ac:	4620      	mov	r0, r4
 801b9ae:	f003 fbb0 	bl	801f112 <crs_strlen>
 801b9b2:	b283      	uxth	r3, r0
 801b9b4:	4622      	mov	r2, r4
 801b9b6:	2101      	movs	r1, #1
 801b9b8:	2007      	movs	r0, #7
 801b9ba:	f003 fc0f 	bl	801f1dc <traceIF_uartPrint>
  switch (autom_event)
 801b9be:	1ef0      	subs	r0, r6, #3
 801b9c0:	2812      	cmp	r0, #18
 801b9c2:	d80d      	bhi.n	801b9e0 <CST_waiting_for_signal_quality_ok_state+0x78>
 801b9c4:	e8df f000 	tbb	[pc, r0]
 801b9c8:	0c0c0c0a 	.word	0x0c0c0c0a
 801b9cc:	0c0c0c0c 	.word	0x0c0c0c0c
 801b9d0:	0c0c0c0a 	.word	0x0c0c0c0a
 801b9d4:	0c130c10 	.word	0x0c130c10
 801b9d8:	0c0d      	.short	0x0c0d
 801b9da:	16          	.byte	0x16
 801b9db:	00          	.byte	0x00
      CST_signal_quality_test_mngt();
 801b9dc:	f7ff ff46 	bl	801b86c <CST_signal_quality_test_mngt>
}
 801b9e0:	bd70      	pop	{r4, r5, r6, pc}
      CST_network_event_mngt();
 801b9e2:	f7ff ff79 	bl	801b8d8 <CST_network_event_mngt>
      break;
 801b9e6:	e7fb      	b.n	801b9e0 <CST_waiting_for_signal_quality_ok_state+0x78>
      CST_target_state_cmd_event_mngt();
 801b9e8:	f7ff fd74 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801b9ec:	e7f8      	b.n	801b9e0 <CST_waiting_for_signal_quality_ok_state+0x78>
      CST_reboot_modem_event_mngt();
 801b9ee:	f7ff fc29 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801b9f2:	e7f5      	b.n	801b9e0 <CST_waiting_for_signal_quality_ok_state+0x78>
      CST_fota_start_event_mngt();
 801b9f4:	f7ff fe2a 	bl	801b64c <CST_fota_start_event_mngt>
}
 801b9f8:	e7f2      	b.n	801b9e0 <CST_waiting_for_signal_quality_ok_state+0x78>
 801b9fa:	bf00      	nop
 801b9fc:	08033e94 	.word	0x08033e94
 801ba00:	20004ddc 	.word	0x20004ddc

0801ba04 <CST_network_status_test_mngt>:
{
 801ba04:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_network_status_test_mngt ********\n\r")
 801ba06:	4d4f      	ldr	r5, [pc, #316]	; (801bb44 <CST_network_status_test_mngt+0x140>)
 801ba08:	4c4f      	ldr	r4, [pc, #316]	; (801bb48 <CST_network_status_test_mngt+0x144>)
 801ba0a:	f105 0630 	add.w	r6, r5, #48	; 0x30
 801ba0e:	46ac      	mov	ip, r5
 801ba10:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ba14:	6020      	str	r0, [r4, #0]
 801ba16:	6061      	str	r1, [r4, #4]
 801ba18:	60a2      	str	r2, [r4, #8]
 801ba1a:	60e3      	str	r3, [r4, #12]
 801ba1c:	4665      	mov	r5, ip
 801ba1e:	3410      	adds	r4, #16
 801ba20:	45b4      	cmp	ip, r6
 801ba22:	d1f4      	bne.n	801ba0e <CST_network_status_test_mngt+0xa>
 801ba24:	f8dc 0000 	ldr.w	r0, [ip]
 801ba28:	6020      	str	r0, [r4, #0]
 801ba2a:	4c47      	ldr	r4, [pc, #284]	; (801bb48 <CST_network_status_test_mngt+0x144>)
 801ba2c:	4620      	mov	r0, r4
 801ba2e:	f003 fb70 	bl	801f112 <crs_strlen>
 801ba32:	b283      	uxth	r3, r0
 801ba34:	4622      	mov	r2, r4
 801ba36:	2101      	movs	r1, #1
 801ba38:	2007      	movs	r0, #7
 801ba3a:	f003 fbad 	bl	801f198 <traceIF_itmPrint>
 801ba3e:	4620      	mov	r0, r4
 801ba40:	f003 fb67 	bl	801f112 <crs_strlen>
 801ba44:	b283      	uxth	r3, r0
 801ba46:	4622      	mov	r2, r4
 801ba48:	2101      	movs	r1, #1
 801ba4a:	2007      	movs	r0, #7
 801ba4c:	f003 fbc6 	bl	801f1dc <traceIF_uartPrint>
  ret = CST_get_network_status();
 801ba50:	f002 fae2 	bl	801e018 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801ba54:	b150      	cbz	r0, 801ba6c <CST_network_status_test_mngt+0x68>
  else if (ret == CST_NOT_REGISTERED)
 801ba56:	2801      	cmp	r0, #1
 801ba58:	d03b      	beq.n	801bad2 <CST_network_status_test_mngt+0xce>
  else if (ret == CST_NET_UNKNOWN)
 801ba5a:	2803      	cmp	r0, #3
 801ba5c:	d06d      	beq.n	801bb3a <CST_network_status_test_mngt+0x136>
    CST_config_fail(((uint8_t *)"CST_network_status_test_mngt"),
 801ba5e:	2305      	movs	r3, #5
 801ba60:	4a3a      	ldr	r2, [pc, #232]	; (801bb4c <CST_network_status_test_mngt+0x148>)
 801ba62:	4619      	mov	r1, r3
 801ba64:	483a      	ldr	r0, [pc, #232]	; (801bb50 <CST_network_status_test_mngt+0x14c>)
 801ba66:	f001 fcf5 	bl	801d454 <CST_config_fail>
}
 801ba6a:	bd70      	pop	{r4, r5, r6, pc}
    (void)rtosalTimerStop(cst_network_status_timer_handle);
 801ba6c:	4b39      	ldr	r3, [pc, #228]	; (801bb54 <CST_network_status_test_mngt+0x150>)
 801ba6e:	6818      	ldr	r0, [r3, #0]
 801ba70:	f003 faa3 	bl	801efba <rtosalTimerStop>
    PRINT_CELLULAR_SERVICE("-----> Stop NW REG TIMEOUT TIMER\n\r")
 801ba74:	4e38      	ldr	r6, [pc, #224]	; (801bb58 <CST_network_status_test_mngt+0x154>)
 801ba76:	f106 0c20 	add.w	ip, r6, #32
 801ba7a:	4635      	mov	r5, r6
 801ba7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ba7e:	6020      	str	r0, [r4, #0]
 801ba80:	6061      	str	r1, [r4, #4]
 801ba82:	60a2      	str	r2, [r4, #8]
 801ba84:	60e3      	str	r3, [r4, #12]
 801ba86:	462e      	mov	r6, r5
 801ba88:	3410      	adds	r4, #16
 801ba8a:	4565      	cmp	r5, ip
 801ba8c:	d1f5      	bne.n	801ba7a <CST_network_status_test_mngt+0x76>
 801ba8e:	882a      	ldrh	r2, [r5, #0]
 801ba90:	78ab      	ldrb	r3, [r5, #2]
 801ba92:	8022      	strh	r2, [r4, #0]
 801ba94:	70a3      	strb	r3, [r4, #2]
 801ba96:	4c2c      	ldr	r4, [pc, #176]	; (801bb48 <CST_network_status_test_mngt+0x144>)
 801ba98:	4620      	mov	r0, r4
 801ba9a:	f003 fb3a 	bl	801f112 <crs_strlen>
 801ba9e:	b283      	uxth	r3, r0
 801baa0:	4622      	mov	r2, r4
 801baa2:	2101      	movs	r1, #1
 801baa4:	2007      	movs	r0, #7
 801baa6:	f003 fb77 	bl	801f198 <traceIF_itmPrint>
 801baaa:	4620      	mov	r0, r4
 801baac:	f003 fb31 	bl	801f112 <crs_strlen>
 801bab0:	b283      	uxth	r3, r0
 801bab2:	4622      	mov	r2, r4
 801bab4:	2101      	movs	r1, #1
 801bab6:	2007      	movs	r0, #7
 801bab8:	f003 fb90 	bl	801f1dc <traceIF_uartPrint>
    cst_context.register_retry_tempo_count = 0U;
 801babc:	2400      	movs	r4, #0
 801babe:	4b27      	ldr	r3, [pc, #156]	; (801bb5c <CST_network_status_test_mngt+0x158>)
 801bac0:	81dc      	strh	r4, [r3, #14]
    CST_set_state(CST_NETWORK_STATUS_OK_STATE);
 801bac2:	2005      	movs	r0, #5
 801bac4:	f7ff fb54 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_STATUS_OK_EVENT);
 801bac8:	2105      	movs	r1, #5
 801baca:	4620      	mov	r0, r4
 801bacc:	f7ff fa8c 	bl	801afe8 <CST_send_message>
 801bad0:	e7cb      	b.n	801ba6a <CST_network_status_test_mngt+0x66>
    cs_status = CST_set_signal_quality();
 801bad2:	f002 f95b 	bl	801dd8c <CST_set_signal_quality>
    if (cs_status != CELLULAR_OK)
 801bad6:	2800      	cmp	r0, #0
 801bad8:	d0c7      	beq.n	801ba6a <CST_network_status_test_mngt+0x66>
      (void)rtosalTimerStop(cst_network_status_timer_handle);
 801bada:	4b1e      	ldr	r3, [pc, #120]	; (801bb54 <CST_network_status_test_mngt+0x150>)
 801badc:	6818      	ldr	r0, [r3, #0]
 801bade:	f003 fa6c 	bl	801efba <rtosalTimerStop>
      PRINT_CELLULAR_SERVICE("-----> BAD SIGNAL : Stop NW REG TIMEOUT TIMER\n\r")
 801bae2:	4e1f      	ldr	r6, [pc, #124]	; (801bb60 <CST_network_status_test_mngt+0x15c>)
 801bae4:	4d18      	ldr	r5, [pc, #96]	; (801bb48 <CST_network_status_test_mngt+0x144>)
 801bae6:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801baea:	4634      	mov	r4, r6
 801baec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801baee:	6028      	str	r0, [r5, #0]
 801baf0:	6069      	str	r1, [r5, #4]
 801baf2:	60aa      	str	r2, [r5, #8]
 801baf4:	60eb      	str	r3, [r5, #12]
 801baf6:	4626      	mov	r6, r4
 801baf8:	3510      	adds	r5, #16
 801bafa:	4564      	cmp	r4, ip
 801bafc:	d1f5      	bne.n	801baea <CST_network_status_test_mngt+0xe6>
 801bafe:	4c12      	ldr	r4, [pc, #72]	; (801bb48 <CST_network_status_test_mngt+0x144>)
 801bb00:	4620      	mov	r0, r4
 801bb02:	f003 fb06 	bl	801f112 <crs_strlen>
 801bb06:	b283      	uxth	r3, r0
 801bb08:	4622      	mov	r2, r4
 801bb0a:	2101      	movs	r1, #1
 801bb0c:	2007      	movs	r0, #7
 801bb0e:	f003 fb43 	bl	801f198 <traceIF_itmPrint>
 801bb12:	4620      	mov	r0, r4
 801bb14:	f003 fafd 	bl	801f112 <crs_strlen>
 801bb18:	b283      	uxth	r3, r0
 801bb1a:	4622      	mov	r2, r4
 801bb1c:	2101      	movs	r1, #1
 801bb1e:	2007      	movs	r0, #7
 801bb20:	f003 fb5c 	bl	801f1dc <traceIF_uartPrint>
      cst_context.register_retry_tempo_count = 0U;
 801bb24:	2400      	movs	r4, #0
 801bb26:	4b0d      	ldr	r3, [pc, #52]	; (801bb5c <CST_network_status_test_mngt+0x158>)
 801bb28:	81dc      	strh	r4, [r3, #14]
      CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801bb2a:	2003      	movs	r0, #3
 801bb2c:	f7ff fb20 	bl	801b170 <CST_set_state>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_SIGNAL_QUALITY_TO_CHECK_EVENT);
 801bb30:	2103      	movs	r1, #3
 801bb32:	4620      	mov	r0, r4
 801bb34:	f7ff fa58 	bl	801afe8 <CST_send_message>
 801bb38:	e797      	b.n	801ba6a <CST_network_status_test_mngt+0x66>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801bb3a:	210d      	movs	r1, #13
 801bb3c:	2000      	movs	r0, #0
 801bb3e:	f7ff fa53 	bl	801afe8 <CST_send_message>
 801bb42:	e792      	b.n	801ba6a <CST_network_status_test_mngt+0x66>
 801bb44:	08033ed0 	.word	0x08033ed0
 801bb48:	20004ddc 	.word	0x20004ddc
 801bb4c:	200000c7 	.word	0x200000c7
 801bb50:	08033e74 	.word	0x08033e74
 801bb54:	20004308 	.word	0x20004308
 801bb58:	08033f04 	.word	0x08033f04
 801bb5c:	200000b0 	.word	0x200000b0
 801bb60:	08033f28 	.word	0x08033f28

0801bb64 <CST_waiting_for_network_status_state>:
{
 801bb64:	b508      	push	{r3, lr}
  switch (autom_event)
 801bb66:	3803      	subs	r0, #3
 801bb68:	2812      	cmp	r0, #18
 801bb6a:	d80d      	bhi.n	801bb88 <CST_waiting_for_network_status_state+0x24>
 801bb6c:	e8df f000 	tbb	[pc, r0]
 801bb70:	0c0c0a0a 	.word	0x0c0c0a0a
 801bb74:	0c0c0c0c 	.word	0x0c0c0c0c
 801bb78:	0c0c0c0a 	.word	0x0c0c0c0a
 801bb7c:	0c130c10 	.word	0x0c130c10
 801bb80:	0d0a      	.short	0x0d0a
 801bb82:	16          	.byte	0x16
 801bb83:	00          	.byte	0x00
      CST_network_status_test_mngt();
 801bb84:	f7ff ff3e 	bl	801ba04 <CST_network_status_test_mngt>
}
 801bb88:	bd08      	pop	{r3, pc}
      CST_nw_reg_timeout_expiration_mngt();
 801bb8a:	f7ff f8b3 	bl	801acf4 <CST_nw_reg_timeout_expiration_mngt>
      break;
 801bb8e:	e7fb      	b.n	801bb88 <CST_waiting_for_network_status_state+0x24>
      CST_target_state_cmd_event_mngt();
 801bb90:	f7ff fca0 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801bb94:	e7f8      	b.n	801bb88 <CST_waiting_for_network_status_state+0x24>
      CST_reboot_modem_event_mngt();
 801bb96:	f7ff fb55 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801bb9a:	e7f5      	b.n	801bb88 <CST_waiting_for_network_status_state+0x24>
      CST_fota_start_event_mngt();
 801bb9c:	f7ff fd56 	bl	801b64c <CST_fota_start_event_mngt>
}
 801bba0:	e7f2      	b.n	801bb88 <CST_waiting_for_network_status_state+0x24>
	...

0801bba4 <CST_attach_modem_mngt>:
{
 801bba4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801bba8:	b094      	sub	sp, #80	; 0x50
  PRINT_CELLULAR_SERVICE("*********** CST_attach_modem_mngt ********\n\r")
 801bbaa:	4c8f      	ldr	r4, [pc, #572]	; (801bde8 <CST_attach_modem_mngt+0x244>)
 801bbac:	4d8f      	ldr	r5, [pc, #572]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bbae:	f104 0620 	add.w	r6, r4, #32
 801bbb2:	46a4      	mov	ip, r4
 801bbb4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801bbb8:	6028      	str	r0, [r5, #0]
 801bbba:	6069      	str	r1, [r5, #4]
 801bbbc:	60aa      	str	r2, [r5, #8]
 801bbbe:	60eb      	str	r3, [r5, #12]
 801bbc0:	4664      	mov	r4, ip
 801bbc2:	3510      	adds	r5, #16
 801bbc4:	45b4      	cmp	ip, r6
 801bbc6:	d1f4      	bne.n	801bbb2 <CST_attach_modem_mngt+0xe>
 801bbc8:	cc07      	ldmia	r4!, {r0, r1, r2}
 801bbca:	6028      	str	r0, [r5, #0]
 801bbcc:	6069      	str	r1, [r5, #4]
 801bbce:	60aa      	str	r2, [r5, #8]
 801bbd0:	7823      	ldrb	r3, [r4, #0]
 801bbd2:	732b      	strb	r3, [r5, #12]
 801bbd4:	4c85      	ldr	r4, [pc, #532]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bbd6:	4620      	mov	r0, r4
 801bbd8:	f003 fa9b 	bl	801f112 <crs_strlen>
 801bbdc:	b283      	uxth	r3, r0
 801bbde:	4622      	mov	r2, r4
 801bbe0:	2101      	movs	r1, #1
 801bbe2:	2007      	movs	r0, #7
 801bbe4:	f003 fad8 	bl	801f198 <traceIF_itmPrint>
 801bbe8:	4620      	mov	r0, r4
 801bbea:	f003 fa92 	bl	801f112 <crs_strlen>
 801bbee:	b283      	uxth	r3, r0
 801bbf0:	4622      	mov	r2, r4
 801bbf2:	2101      	movs	r1, #1
 801bbf4:	2007      	movs	r0, #7
 801bbf6:	f003 faf1 	bl	801f1dc <traceIF_uartPrint>
  (void)memset((void *)&reg_status, 0, sizeof(CS_RegistrationStatus_t));
 801bbfa:	224e      	movs	r2, #78	; 0x4e
 801bbfc:	2100      	movs	r1, #0
 801bbfe:	4668      	mov	r0, sp
 801bc00:	f00a f8a9 	bl	8025d56 <memset>
  cs_status = osCDS_get_net_status(&reg_status);
 801bc04:	4668      	mov	r0, sp
 801bc06:	f7fe fec5 	bl	801a994 <osCDS_get_net_status>
  if (cs_status == CELLULAR_OK)
 801bc0a:	b920      	cbnz	r0, 801bc16 <CST_attach_modem_mngt+0x72>
    if (((uint16_t)reg_status.optional_fields_presence & (uint16_t)CS_RSF_FORMAT_PRESENT) != 0U)
 801bc0c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 801bc10:	f013 0f01 	tst.w	r3, #1
 801bc14:	d158      	bne.n	801bcc8 <CST_attach_modem_mngt+0x124>
  cs_status = osCDS_get_attach_status(&cst_ctxt_attach_status);
 801bc16:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
 801bc1a:	f7fe ff61 	bl	801aae0 <osCDS_get_attach_status>
  if (cs_status != CELLULAR_OK)
 801bc1e:	2800      	cmp	r0, #0
 801bc20:	f040 808e 	bne.w	801bd40 <CST_attach_modem_mngt+0x19c>
    if (cst_ctxt_attach_status == CS_PS_ATTACHED)
 801bc24:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 801bc28:	2b01      	cmp	r3, #1
 801bc2a:	f000 80b3 	beq.w	801bd94 <CST_attach_modem_mngt+0x1f0>
      PRINT_CELLULAR_SERVICE("===CST_attach_modem_mngt - NOT ATTACHED !!! ===\n\r")
 801bc2e:	4e70      	ldr	r6, [pc, #448]	; (801bdf0 <CST_attach_modem_mngt+0x24c>)
 801bc30:	4d6e      	ldr	r5, [pc, #440]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bc32:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bc36:	4634      	mov	r4, r6
 801bc38:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bc3a:	6028      	str	r0, [r5, #0]
 801bc3c:	6069      	str	r1, [r5, #4]
 801bc3e:	60aa      	str	r2, [r5, #8]
 801bc40:	60eb      	str	r3, [r5, #12]
 801bc42:	4626      	mov	r6, r4
 801bc44:	3510      	adds	r5, #16
 801bc46:	4564      	cmp	r4, ip
 801bc48:	d1f5      	bne.n	801bc36 <CST_attach_modem_mngt+0x92>
 801bc4a:	8823      	ldrh	r3, [r4, #0]
 801bc4c:	802b      	strh	r3, [r5, #0]
 801bc4e:	4c67      	ldr	r4, [pc, #412]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bc50:	4620      	mov	r0, r4
 801bc52:	f003 fa5e 	bl	801f112 <crs_strlen>
 801bc56:	b283      	uxth	r3, r0
 801bc58:	4622      	mov	r2, r4
 801bc5a:	2101      	movs	r1, #1
 801bc5c:	2007      	movs	r0, #7
 801bc5e:	f003 fa9b 	bl	801f198 <traceIF_itmPrint>
 801bc62:	4620      	mov	r0, r4
 801bc64:	f003 fa55 	bl	801f112 <crs_strlen>
 801bc68:	b283      	uxth	r3, r0
 801bc6a:	4622      	mov	r2, r4
 801bc6c:	2101      	movs	r1, #1
 801bc6e:	2007      	movs	r0, #7
 801bc70:	f003 fab4 	bl	801f1dc <traceIF_uartPrint>
      PRINT_CELLULAR_SERVICE("===>CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE <===\n\r")
 801bc74:	4e5f      	ldr	r6, [pc, #380]	; (801bdf4 <CST_attach_modem_mngt+0x250>)
 801bc76:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bc7a:	4635      	mov	r5, r6
 801bc7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801bc7e:	6020      	str	r0, [r4, #0]
 801bc80:	6061      	str	r1, [r4, #4]
 801bc82:	60a2      	str	r2, [r4, #8]
 801bc84:	60e3      	str	r3, [r4, #12]
 801bc86:	462e      	mov	r6, r5
 801bc88:	3410      	adds	r4, #16
 801bc8a:	4565      	cmp	r5, ip
 801bc8c:	d1f5      	bne.n	801bc7a <CST_attach_modem_mngt+0xd6>
 801bc8e:	882a      	ldrh	r2, [r5, #0]
 801bc90:	78ab      	ldrb	r3, [r5, #2]
 801bc92:	8022      	strh	r2, [r4, #0]
 801bc94:	70a3      	strb	r3, [r4, #2]
 801bc96:	4c55      	ldr	r4, [pc, #340]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bc98:	4620      	mov	r0, r4
 801bc9a:	f003 fa3a 	bl	801f112 <crs_strlen>
 801bc9e:	b283      	uxth	r3, r0
 801bca0:	4622      	mov	r2, r4
 801bca2:	2101      	movs	r1, #1
 801bca4:	2007      	movs	r0, #7
 801bca6:	f003 fa77 	bl	801f198 <traceIF_itmPrint>
 801bcaa:	4620      	mov	r0, r4
 801bcac:	f003 fa31 	bl	801f112 <crs_strlen>
 801bcb0:	b283      	uxth	r3, r0
 801bcb2:	4622      	mov	r2, r4
 801bcb4:	2101      	movs	r1, #1
 801bcb6:	2007      	movs	r0, #7
 801bcb8:	f003 fa90 	bl	801f1dc <traceIF_uartPrint>
      CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801bcbc:	2003      	movs	r0, #3
 801bcbe:	f7ff fa57 	bl	801b170 <CST_set_state>
}
 801bcc2:	b014      	add	sp, #80	; 0x50
 801bcc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      (void)dc_com_read(&dc_com_db,  DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801bcc8:	f8df 8148 	ldr.w	r8, [pc, #328]	; 801be14 <CST_attach_modem_mngt+0x270>
 801bccc:	4e4a      	ldr	r6, [pc, #296]	; (801bdf8 <CST_attach_modem_mngt+0x254>)
 801bcce:	4f4b      	ldr	r7, [pc, #300]	; (801bdfc <CST_attach_modem_mngt+0x258>)
 801bcd0:	23f4      	movs	r3, #244	; 0xf4
 801bcd2:	4632      	mov	r2, r6
 801bcd4:	f8b8 1000 	ldrh.w	r1, [r8]
 801bcd8:	4638      	mov	r0, r7
 801bcda:	f005 fe75 	bl	80219c8 <dc_com_read>
      (void)memcpy(cst_cellular_info.mno_name, reg_status.operator_name, DC_MAX_SIZE_MNO_NAME - 1U);
 801bcde:	f106 0430 	add.w	r4, r6, #48	; 0x30
 801bce2:	ad03      	add	r5, sp, #12
 801bce4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801bce6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801bce8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 801bcec:	c407      	stmia	r4!, {r0, r1, r2}
 801bcee:	f824 3b02 	strh.w	r3, [r4], #2
 801bcf2:	0c1b      	lsrs	r3, r3, #16
 801bcf4:	7023      	strb	r3, [r4, #0]
      cst_cellular_info.mno_name[DC_MAX_SIZE_MNO_NAME - 1U] = 0U;  /* to avoid a non null terminated string */
 801bcf6:	2300      	movs	r3, #0
 801bcf8:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
      cst_cellular_info.rt_state              = DC_SERVICE_ON;
 801bcfc:	2507      	movs	r5, #7
 801bcfe:	7235      	strb	r5, [r6, #8]
      (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801bd00:	23f4      	movs	r3, #244	; 0xf4
 801bd02:	4632      	mov	r2, r6
 801bd04:	f8b8 1000 	ldrh.w	r1, [r8]
 801bd08:	4638      	mov	r0, r7
 801bd0a:	f005 fe11 	bl	8021930 <dc_com_write>
      PRINT_CELLULAR_SERVICE(" ->operator_name = %s\n\r", reg_status.operator_name)
 801bd0e:	4c37      	ldr	r4, [pc, #220]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bd10:	aa03      	add	r2, sp, #12
 801bd12:	493b      	ldr	r1, [pc, #236]	; (801be00 <CST_attach_modem_mngt+0x25c>)
 801bd14:	4620      	mov	r0, r4
 801bd16:	f009 ffab 	bl	8025c70 <sprintf>
 801bd1a:	4620      	mov	r0, r4
 801bd1c:	f003 f9f9 	bl	801f112 <crs_strlen>
 801bd20:	b283      	uxth	r3, r0
 801bd22:	4622      	mov	r2, r4
 801bd24:	2101      	movs	r1, #1
 801bd26:	4628      	mov	r0, r5
 801bd28:	f003 fa36 	bl	801f198 <traceIF_itmPrint>
 801bd2c:	4620      	mov	r0, r4
 801bd2e:	f003 f9f0 	bl	801f112 <crs_strlen>
 801bd32:	b283      	uxth	r3, r0
 801bd34:	4622      	mov	r2, r4
 801bd36:	2101      	movs	r1, #1
 801bd38:	4628      	mov	r0, r5
 801bd3a:	f003 fa4f 	bl	801f1dc <traceIF_uartPrint>
 801bd3e:	e76a      	b.n	801bc16 <CST_attach_modem_mngt+0x72>
    PRINT_CELLULAR_SERVICE("*********** CST_attach_modem_mngt fail ********\n\r")
 801bd40:	4e30      	ldr	r6, [pc, #192]	; (801be04 <CST_attach_modem_mngt+0x260>)
 801bd42:	4d2a      	ldr	r5, [pc, #168]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bd44:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bd48:	4634      	mov	r4, r6
 801bd4a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bd4c:	6028      	str	r0, [r5, #0]
 801bd4e:	6069      	str	r1, [r5, #4]
 801bd50:	60aa      	str	r2, [r5, #8]
 801bd52:	60eb      	str	r3, [r5, #12]
 801bd54:	4626      	mov	r6, r4
 801bd56:	3510      	adds	r5, #16
 801bd58:	4564      	cmp	r4, ip
 801bd5a:	d1f5      	bne.n	801bd48 <CST_attach_modem_mngt+0x1a4>
 801bd5c:	8823      	ldrh	r3, [r4, #0]
 801bd5e:	802b      	strh	r3, [r5, #0]
 801bd60:	4c22      	ldr	r4, [pc, #136]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bd62:	4620      	mov	r0, r4
 801bd64:	f003 f9d5 	bl	801f112 <crs_strlen>
 801bd68:	b283      	uxth	r3, r0
 801bd6a:	4622      	mov	r2, r4
 801bd6c:	2101      	movs	r1, #1
 801bd6e:	2007      	movs	r0, #7
 801bd70:	f003 fa12 	bl	801f198 <traceIF_itmPrint>
 801bd74:	4620      	mov	r0, r4
 801bd76:	f003 f9cc 	bl	801f112 <crs_strlen>
 801bd7a:	b283      	uxth	r3, r0
 801bd7c:	4622      	mov	r2, r4
 801bd7e:	2101      	movs	r1, #1
 801bd80:	2007      	movs	r0, #7
 801bd82:	f003 fa2b 	bl	801f1dc <traceIF_uartPrint>
    CST_config_fail(((uint8_t *)"CS_get_attach_status FAIL"),
 801bd86:	2305      	movs	r3, #5
 801bd88:	4a1f      	ldr	r2, [pc, #124]	; (801be08 <CST_attach_modem_mngt+0x264>)
 801bd8a:	2106      	movs	r1, #6
 801bd8c:	481f      	ldr	r0, [pc, #124]	; (801be0c <CST_attach_modem_mngt+0x268>)
 801bd8e:	f001 fb61 	bl	801d454 <CST_config_fail>
 801bd92:	e796      	b.n	801bcc2 <CST_attach_modem_mngt+0x11e>
      PRINT_CELLULAR_SERVICE("*********** CST_attach_modem_mngt OK ********\n\r")
 801bd94:	4e1e      	ldr	r6, [pc, #120]	; (801be10 <CST_attach_modem_mngt+0x26c>)
 801bd96:	4d15      	ldr	r5, [pc, #84]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bd98:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bd9c:	4634      	mov	r4, r6
 801bd9e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bda0:	6028      	str	r0, [r5, #0]
 801bda2:	6069      	str	r1, [r5, #4]
 801bda4:	60aa      	str	r2, [r5, #8]
 801bda6:	60eb      	str	r3, [r5, #12]
 801bda8:	4626      	mov	r6, r4
 801bdaa:	3510      	adds	r5, #16
 801bdac:	4564      	cmp	r4, ip
 801bdae:	d1f5      	bne.n	801bd9c <CST_attach_modem_mngt+0x1f8>
 801bdb0:	4c0e      	ldr	r4, [pc, #56]	; (801bdec <CST_attach_modem_mngt+0x248>)
 801bdb2:	4620      	mov	r0, r4
 801bdb4:	f003 f9ad 	bl	801f112 <crs_strlen>
 801bdb8:	b283      	uxth	r3, r0
 801bdba:	4622      	mov	r2, r4
 801bdbc:	2101      	movs	r1, #1
 801bdbe:	2007      	movs	r0, #7
 801bdc0:	f003 f9ea 	bl	801f198 <traceIF_itmPrint>
 801bdc4:	4620      	mov	r0, r4
 801bdc6:	f003 f9a4 	bl	801f112 <crs_strlen>
 801bdca:	b283      	uxth	r3, r0
 801bdcc:	4622      	mov	r2, r4
 801bdce:	2101      	movs	r1, #1
 801bdd0:	2007      	movs	r0, #7
 801bdd2:	f003 fa03 	bl	801f1dc <traceIF_uartPrint>
      CST_set_state(CST_MODEM_REGISTERED_STATE);
 801bdd6:	2006      	movs	r0, #6
 801bdd8:	f7ff f9ca 	bl	801b170 <CST_set_state>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_ATTACHED_EVENT);
 801bddc:	2106      	movs	r1, #6
 801bdde:	2000      	movs	r0, #0
 801bde0:	f7ff f902 	bl	801afe8 <CST_send_message>
 801bde4:	e76d      	b.n	801bcc2 <CST_attach_modem_mngt+0x11e>
 801bde6:	bf00      	nop
 801bde8:	08033f58 	.word	0x08033f58
 801bdec:	20004ddc 	.word	0x20004ddc
 801bdf0:	08034020 	.word	0x08034020
 801bdf4:	08034054 	.word	0x08034054
 801bdf8:	2000406c 	.word	0x2000406c
 801bdfc:	200058b0 	.word	0x200058b0
 801be00:	08033f88 	.word	0x08033f88
 801be04:	08033fa0 	.word	0x08033fa0
 801be08:	200000c4 	.word	0x200000c4
 801be0c:	08033fd4 	.word	0x08033fd4
 801be10:	08033ff0 	.word	0x08033ff0
 801be14:	20000236 	.word	0x20000236

0801be18 <CST_network_status_ok_state>:
{
 801be18:	b508      	push	{r3, lr}
  switch (autom_event)
 801be1a:	3805      	subs	r0, #5
 801be1c:	2810      	cmp	r0, #16
 801be1e:	d80c      	bhi.n	801be3a <CST_network_status_ok_state+0x22>
 801be20:	e8df f000 	tbb	[pc, r0]
 801be24:	0b0b0b09 	.word	0x0b0b0b09
 801be28:	0b0b0b0b 	.word	0x0b0b0b0b
 801be2c:	0b0c0b0b 	.word	0x0b0c0b0b
 801be30:	0b0b0b0f 	.word	0x0b0b0b0f
 801be34:	12          	.byte	0x12
 801be35:	00          	.byte	0x00
      CST_attach_modem_mngt();
 801be36:	f7ff feb5 	bl	801bba4 <CST_attach_modem_mngt>
}
 801be3a:	bd08      	pop	{r3, pc}
      CST_target_state_cmd_event_mngt();
 801be3c:	f7ff fb4a 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801be40:	e7fb      	b.n	801be3a <CST_network_status_ok_state+0x22>
      CST_reboot_modem_event_mngt();
 801be42:	f7ff f9ff 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801be46:	e7f8      	b.n	801be3a <CST_network_status_ok_state+0x22>
      CST_fota_start_event_mngt();
 801be48:	f7ff fc00 	bl	801b64c <CST_fota_start_event_mngt>
}
 801be4c:	e7f5      	b.n	801be3a <CST_network_status_ok_state+0x22>
	...

0801be50 <CST_modem_activate_pdn_mngt>:
{
 801be50:	b570      	push	{r4, r5, r6, lr}
  CST_set_state(CST_MODEM_PDN_ACTIVATING_STATE);
 801be52:	2007      	movs	r0, #7
 801be54:	f7ff f98c 	bl	801b170 <CST_set_state>
  (void)osCDS_set_default_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid));
 801be58:	4e3a      	ldr	r6, [pc, #232]	; (801bf44 <CST_modem_activate_pdn_mngt+0xf4>)
 801be5a:	7c33      	ldrb	r3, [r6, #16]
 801be5c:	4c3a      	ldr	r4, [pc, #232]	; (801bf48 <CST_modem_activate_pdn_mngt+0xf8>)
 801be5e:	2562      	movs	r5, #98	; 0x62
 801be60:	fb05 4303 	mla	r3, r5, r3, r4
 801be64:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801be68:	f7fe f9a9 	bl	801a1be <cst_get_cid_value>
 801be6c:	f7fe fe8c 	bl	801ab88 <osCDS_set_default_pdn>
  (void)osCDS_register_pdn_event(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801be70:	7c33      	ldrb	r3, [r6, #16]
 801be72:	fb05 4403 	mla	r4, r5, r3, r4
 801be76:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 801be7a:	f7fe f9a0 	bl	801a1be <cst_get_cid_value>
 801be7e:	4933      	ldr	r1, [pc, #204]	; (801bf4c <CST_modem_activate_pdn_mngt+0xfc>)
 801be80:	f7fe fe6c 	bl	801ab5c <osCDS_register_pdn_event>
  cs_status = osCDS_activate_pdn(CS_PDN_CONFIG_DEFAULT);
 801be84:	200b      	movs	r0, #11
 801be86:	f7fe fe93 	bl	801abb0 <osCDS_activate_pdn>
  if (cs_status != CELLULAR_OK)
 801be8a:	2800      	cmp	r0, #0
 801be8c:	d053      	beq.n	801bf36 <CST_modem_activate_pdn_mngt+0xe6>
    if (cst_nfmc_context.active == false)
 801be8e:	4b30      	ldr	r3, [pc, #192]	; (801bf50 <CST_modem_activate_pdn_mngt+0x100>)
 801be90:	781b      	ldrb	r3, [r3, #0]
 801be92:	bb4b      	cbnz	r3, 801bee8 <CST_modem_activate_pdn_mngt+0x98>
      (void)rtosalTimerStart(cst_pdn_activate_retry_timer_handle, CST_PDN_ACTIVATE_RETRY_DELAY);
 801be94:	f247 5130 	movw	r1, #30000	; 0x7530
 801be98:	4b2e      	ldr	r3, [pc, #184]	; (801bf54 <CST_modem_activate_pdn_mngt+0x104>)
 801be9a:	6818      	ldr	r0, [r3, #0]
 801be9c:	f003 f889 	bl	801efb2 <rtosalTimerStart>
      PRINT_CELLULAR_SERVICE("-----> CST_modem_activate_pdn_mngt NOK - retry tempo  : %d\n\r",
 801bea0:	4c2d      	ldr	r4, [pc, #180]	; (801bf58 <CST_modem_activate_pdn_mngt+0x108>)
 801bea2:	f247 5230 	movw	r2, #30000	; 0x7530
 801bea6:	492d      	ldr	r1, [pc, #180]	; (801bf5c <CST_modem_activate_pdn_mngt+0x10c>)
 801bea8:	4620      	mov	r0, r4
 801beaa:	f009 fee1 	bl	8025c70 <sprintf>
 801beae:	4620      	mov	r0, r4
 801beb0:	f003 f92f 	bl	801f112 <crs_strlen>
 801beb4:	b283      	uxth	r3, r0
 801beb6:	4622      	mov	r2, r4
 801beb8:	2101      	movs	r1, #1
 801beba:	2007      	movs	r0, #7
 801bebc:	f003 f96c 	bl	801f198 <traceIF_itmPrint>
 801bec0:	4620      	mov	r0, r4
 801bec2:	f003 f926 	bl	801f112 <crs_strlen>
 801bec6:	b283      	uxth	r3, r0
 801bec8:	4622      	mov	r2, r4
 801beca:	2101      	movs	r1, #1
 801becc:	2007      	movs	r0, #7
 801bece:	f003 f985 	bl	801f1dc <traceIF_uartPrint>
    cst_context.activate_pdn_nfmc_tempo_count++;
 801bed2:	4a1c      	ldr	r2, [pc, #112]	; (801bf44 <CST_modem_activate_pdn_mngt+0xf4>)
 801bed4:	8993      	ldrh	r3, [r2, #12]
 801bed6:	3301      	adds	r3, #1
 801bed8:	b29b      	uxth	r3, r3
 801beda:	8193      	strh	r3, [r2, #12]
    if (cst_context.activate_pdn_nfmc_tempo_count >= CST_NFMC_TEMPO_NB)
 801bedc:	2b06      	cmp	r3, #6
 801bede:	d902      	bls.n	801bee6 <CST_modem_activate_pdn_mngt+0x96>
      cst_context.activate_pdn_nfmc_tempo_count = 0U;
 801bee0:	4613      	mov	r3, r2
 801bee2:	2200      	movs	r2, #0
 801bee4:	819a      	strh	r2, [r3, #12]
}
 801bee6:	bd70      	pop	{r4, r5, r6, pc}
                             cst_nfmc_context.tempo[cst_context.activate_pdn_nfmc_tempo_count]);
 801bee8:	4d16      	ldr	r5, [pc, #88]	; (801bf44 <CST_modem_activate_pdn_mngt+0xf4>)
 801beea:	89ab      	ldrh	r3, [r5, #12]
      (void)rtosalTimerStart(cst_pdn_activate_retry_timer_handle,
 801beec:	4c18      	ldr	r4, [pc, #96]	; (801bf50 <CST_modem_activate_pdn_mngt+0x100>)
 801beee:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801bef2:	6859      	ldr	r1, [r3, #4]
 801bef4:	4b17      	ldr	r3, [pc, #92]	; (801bf54 <CST_modem_activate_pdn_mngt+0x104>)
 801bef6:	6818      	ldr	r0, [r3, #0]
 801bef8:	f003 f85b 	bl	801efb2 <rtosalTimerStart>
      PRINT_CELLULAR_SERVICE("-----> CST_modem_activate_pdn_mngt NOK - retry tempo %d : %ld\n\r",
 801befc:	89aa      	ldrh	r2, [r5, #12]
 801befe:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 801bf02:	4c15      	ldr	r4, [pc, #84]	; (801bf58 <CST_modem_activate_pdn_mngt+0x108>)
 801bf04:	685b      	ldr	r3, [r3, #4]
 801bf06:	3201      	adds	r2, #1
 801bf08:	4915      	ldr	r1, [pc, #84]	; (801bf60 <CST_modem_activate_pdn_mngt+0x110>)
 801bf0a:	4620      	mov	r0, r4
 801bf0c:	f009 feb0 	bl	8025c70 <sprintf>
 801bf10:	4620      	mov	r0, r4
 801bf12:	f003 f8fe 	bl	801f112 <crs_strlen>
 801bf16:	b283      	uxth	r3, r0
 801bf18:	4622      	mov	r2, r4
 801bf1a:	2101      	movs	r1, #1
 801bf1c:	2007      	movs	r0, #7
 801bf1e:	f003 f93b 	bl	801f198 <traceIF_itmPrint>
 801bf22:	4620      	mov	r0, r4
 801bf24:	f003 f8f5 	bl	801f112 <crs_strlen>
 801bf28:	b283      	uxth	r3, r0
 801bf2a:	4622      	mov	r2, r4
 801bf2c:	2101      	movs	r1, #1
 801bf2e:	2007      	movs	r0, #7
 801bf30:	f003 f954 	bl	801f1dc <traceIF_uartPrint>
 801bf34:	e7cd      	b.n	801bed2 <CST_modem_activate_pdn_mngt+0x82>
    cst_context.activate_pdn_nfmc_tempo_count = 0U;
 801bf36:	2000      	movs	r0, #0
 801bf38:	4b02      	ldr	r3, [pc, #8]	; (801bf44 <CST_modem_activate_pdn_mngt+0xf4>)
 801bf3a:	8198      	strh	r0, [r3, #12]
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_PDP_ACTIVATED_EVENT);
 801bf3c:	2107      	movs	r1, #7
 801bf3e:	f7ff f853 	bl	801afe8 <CST_send_message>
}
 801bf42:	e7d0      	b.n	801bee6 <CST_modem_activate_pdn_mngt+0x96>
 801bf44:	200000b0 	.word	0x200000b0
 801bf48:	20004160 	.word	0x20004160
 801bf4c:	0801b121 	.word	0x0801b121
 801bf50:	2000430c 	.word	0x2000430c
 801bf54:	2000432c 	.word	0x2000432c
 801bf58:	20004ddc 	.word	0x20004ddc
 801bf5c:	08034088 	.word	0x08034088
 801bf60:	080340c8 	.word	0x080340c8

0801bf64 <CST_modem_registered_state>:
{
 801bf64:	b508      	push	{r3, lr}
  switch (autom_event)
 801bf66:	3806      	subs	r0, #6
 801bf68:	280f      	cmp	r0, #15
 801bf6a:	d80b      	bhi.n	801bf84 <CST_modem_registered_state+0x20>
 801bf6c:	e8df f000 	tbb	[pc, r0]
 801bf70:	0a0a0a08 	.word	0x0a0a0a08
 801bf74:	0a0a0a0a 	.word	0x0a0a0a0a
 801bf78:	110a0e0a 	.word	0x110a0e0a
 801bf7c:	140a0b0a 	.word	0x140a0b0a
      CST_modem_activate_pdn_mngt();
 801bf80:	f7ff ff66 	bl	801be50 <CST_modem_activate_pdn_mngt>
}
 801bf84:	bd08      	pop	{r3, pc}
      CST_network_event_mngt();
 801bf86:	f7ff fca7 	bl	801b8d8 <CST_network_event_mngt>
      break;
 801bf8a:	e7fb      	b.n	801bf84 <CST_modem_registered_state+0x20>
      CST_target_state_cmd_event_mngt();
 801bf8c:	f7ff faa2 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801bf90:	e7f8      	b.n	801bf84 <CST_modem_registered_state+0x20>
      CST_reboot_modem_event_mngt();
 801bf92:	f7ff f957 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801bf96:	e7f5      	b.n	801bf84 <CST_modem_registered_state+0x20>
      CST_fota_start_event_mngt();
 801bf98:	f7ff fb58 	bl	801b64c <CST_fota_start_event_mngt>
}
 801bf9c:	e7f2      	b.n	801bf84 <CST_modem_registered_state+0x20>
	...

0801bfa0 <CST_pdn_event_nw_detach_mngt>:
{
 801bfa0:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_pdn_event_nw_detach_mngt ********\n\r")
 801bfa2:	4d2c      	ldr	r5, [pc, #176]	; (801c054 <CST_pdn_event_nw_detach_mngt+0xb4>)
 801bfa4:	4c2c      	ldr	r4, [pc, #176]	; (801c058 <CST_pdn_event_nw_detach_mngt+0xb8>)
 801bfa6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801bfaa:	46ac      	mov	ip, r5
 801bfac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801bfb0:	6020      	str	r0, [r4, #0]
 801bfb2:	6061      	str	r1, [r4, #4]
 801bfb4:	60a2      	str	r2, [r4, #8]
 801bfb6:	60e3      	str	r3, [r4, #12]
 801bfb8:	4665      	mov	r5, ip
 801bfba:	3410      	adds	r4, #16
 801bfbc:	45f4      	cmp	ip, lr
 801bfbe:	d1f4      	bne.n	801bfaa <CST_pdn_event_nw_detach_mngt+0xa>
 801bfc0:	f8dc 0000 	ldr.w	r0, [ip]
 801bfc4:	6020      	str	r0, [r4, #0]
 801bfc6:	4c24      	ldr	r4, [pc, #144]	; (801c058 <CST_pdn_event_nw_detach_mngt+0xb8>)
 801bfc8:	4620      	mov	r0, r4
 801bfca:	f003 f8a2 	bl	801f112 <crs_strlen>
 801bfce:	b283      	uxth	r3, r0
 801bfd0:	4622      	mov	r2, r4
 801bfd2:	2101      	movs	r1, #1
 801bfd4:	2007      	movs	r0, #7
 801bfd6:	f003 f8df 	bl	801f198 <traceIF_itmPrint>
 801bfda:	4620      	mov	r0, r4
 801bfdc:	f003 f899 	bl	801f112 <crs_strlen>
 801bfe0:	b283      	uxth	r3, r0
 801bfe2:	4622      	mov	r2, r4
 801bfe4:	2101      	movs	r1, #1
 801bfe6:	2007      	movs	r0, #7
 801bfe8:	f003 f8f8 	bl	801f1dc <traceIF_uartPrint>
  if (cst_context.current_state == CST_MODEM_DATA_READY_STATE)
 801bfec:	4b1b      	ldr	r3, [pc, #108]	; (801c05c <CST_pdn_event_nw_detach_mngt+0xbc>)
 801bfee:	881b      	ldrh	r3, [r3, #0]
 801bff0:	2b08      	cmp	r3, #8
 801bff2:	d024      	beq.n	801c03e <CST_pdn_event_nw_detach_mngt+0x9e>
  ret = CST_get_network_status();
 801bff4:	f002 f810 	bl	801e018 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801bff8:	b1e8      	cbz	r0, 801c036 <CST_pdn_event_nw_detach_mngt+0x96>
  else if (ret == CST_NOT_REGISTERED)
 801bffa:	2801      	cmp	r0, #1
 801bffc:	d024      	beq.n	801c048 <CST_pdn_event_nw_detach_mngt+0xa8>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801bffe:	2100      	movs	r1, #0
 801c000:	2003      	movs	r0, #3
 801c002:	f001 f9e7 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    PRINT_CELLULAR_SERVICE("******** CST_pdn_event_nw_detach_mngt: osCDS_get_net_status FAIL ****\n\r")
 801c006:	4c14      	ldr	r4, [pc, #80]	; (801c058 <CST_pdn_event_nw_detach_mngt+0xb8>)
 801c008:	2248      	movs	r2, #72	; 0x48
 801c00a:	4915      	ldr	r1, [pc, #84]	; (801c060 <CST_pdn_event_nw_detach_mngt+0xc0>)
 801c00c:	4620      	mov	r0, r4
 801c00e:	f009 ff7f 	bl	8025f10 <memcpy>
 801c012:	4620      	mov	r0, r4
 801c014:	f003 f87d 	bl	801f112 <crs_strlen>
 801c018:	b283      	uxth	r3, r0
 801c01a:	4622      	mov	r2, r4
 801c01c:	2101      	movs	r1, #1
 801c01e:	2007      	movs	r0, #7
 801c020:	f003 f8ba 	bl	801f198 <traceIF_itmPrint>
 801c024:	4620      	mov	r0, r4
 801c026:	f003 f874 	bl	801f112 <crs_strlen>
 801c02a:	b283      	uxth	r3, r0
 801c02c:	4622      	mov	r2, r4
 801c02e:	2101      	movs	r1, #1
 801c030:	2007      	movs	r0, #7
 801c032:	f003 f8d3 	bl	801f1dc <traceIF_uartPrint>
  CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801c036:	2004      	movs	r0, #4
 801c038:	f7ff f89a 	bl	801b170 <CST_set_state>
}
 801c03c:	bd38      	pop	{r3, r4, r5, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c03e:	2100      	movs	r1, #0
 801c040:	2003      	movs	r0, #3
 801c042:	f001 f9c7 	bl	801d3d4 <CST_data_cache_cellular_info_set>
 801c046:	e7d5      	b.n	801bff4 <CST_pdn_event_nw_detach_mngt+0x54>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c048:	2100      	movs	r1, #0
 801c04a:	2003      	movs	r0, #3
 801c04c:	f001 f9c2 	bl	801d3d4 <CST_data_cache_cellular_info_set>
 801c050:	e7f1      	b.n	801c036 <CST_pdn_event_nw_detach_mngt+0x96>
 801c052:	bf00      	nop
 801c054:	08034108 	.word	0x08034108
 801c058:	20004ddc 	.word	0x20004ddc
 801c05c:	200000b0 	.word	0x200000b0
 801c060:	0803413c 	.word	0x0803413c

0801c064 <CST_pdn_event_mngt>:
{
 801c064:	b538      	push	{r3, r4, r5, lr}
  CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c066:	2100      	movs	r1, #0
 801c068:	2003      	movs	r0, #3
 801c06a:	f001 f9b3 	bl	801d3d4 <CST_data_cache_cellular_info_set>
  if (cst_context.pdn_status == CS_PDN_EVENT_NW_DETACH)
 801c06e:	4b20      	ldr	r3, [pc, #128]	; (801c0f0 <CST_pdn_event_mngt+0x8c>)
 801c070:	78db      	ldrb	r3, [r3, #3]
 801c072:	2b01      	cmp	r3, #1
 801c074:	d00b      	beq.n	801c08e <CST_pdn_event_mngt+0x2a>
    || (cst_context.pdn_status == CS_PDN_EVENT_NW_PDN_DEACT))
 801c076:	3b02      	subs	r3, #2
 801c078:	b2db      	uxtb	r3, r3
  else if (
 801c07a:	2b01      	cmp	r3, #1
 801c07c:	d90a      	bls.n	801c094 <CST_pdn_event_mngt+0x30>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801c07e:	2004      	movs	r0, #4
 801c080:	f7ff f876 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_CALLBACK_EVENT);
 801c084:	2113      	movs	r1, #19
 801c086:	2000      	movs	r0, #0
 801c088:	f7fe ffae 	bl	801afe8 <CST_send_message>
}
 801c08c:	bd38      	pop	{r3, r4, r5, pc}
    CST_pdn_event_nw_detach_mngt();
 801c08e:	f7ff ff87 	bl	801bfa0 <CST_pdn_event_nw_detach_mngt>
 801c092:	e7fb      	b.n	801c08c <CST_pdn_event_mngt+0x28>
    PRINT_CELLULAR_SERVICE("=========CST_pdn_event_mngt CS_PDN_EVENT_NW_DEACT\n\r")
 801c094:	4d17      	ldr	r5, [pc, #92]	; (801c0f4 <CST_pdn_event_mngt+0x90>)
 801c096:	4c18      	ldr	r4, [pc, #96]	; (801c0f8 <CST_pdn_event_mngt+0x94>)
 801c098:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801c09c:	46ac      	mov	ip, r5
 801c09e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801c0a2:	6020      	str	r0, [r4, #0]
 801c0a4:	6061      	str	r1, [r4, #4]
 801c0a6:	60a2      	str	r2, [r4, #8]
 801c0a8:	60e3      	str	r3, [r4, #12]
 801c0aa:	4665      	mov	r5, ip
 801c0ac:	3410      	adds	r4, #16
 801c0ae:	45f4      	cmp	ip, lr
 801c0b0:	d1f4      	bne.n	801c09c <CST_pdn_event_mngt+0x38>
 801c0b2:	f8dc 0000 	ldr.w	r0, [ip]
 801c0b6:	6020      	str	r0, [r4, #0]
 801c0b8:	4c0f      	ldr	r4, [pc, #60]	; (801c0f8 <CST_pdn_event_mngt+0x94>)
 801c0ba:	4620      	mov	r0, r4
 801c0bc:	f003 f829 	bl	801f112 <crs_strlen>
 801c0c0:	b283      	uxth	r3, r0
 801c0c2:	4622      	mov	r2, r4
 801c0c4:	2101      	movs	r1, #1
 801c0c6:	2007      	movs	r0, #7
 801c0c8:	f003 f866 	bl	801f198 <traceIF_itmPrint>
 801c0cc:	4620      	mov	r0, r4
 801c0ce:	f003 f820 	bl	801f112 <crs_strlen>
 801c0d2:	b283      	uxth	r3, r0
 801c0d4:	4622      	mov	r2, r4
 801c0d6:	2101      	movs	r1, #1
 801c0d8:	2007      	movs	r0, #7
 801c0da:	f003 f87f 	bl	801f1dc <traceIF_uartPrint>
    CST_set_state(CST_MODEM_REGISTERED_STATE);
 801c0de:	2006      	movs	r0, #6
 801c0e0:	f7ff f846 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_ATTACHED_EVENT);
 801c0e4:	2106      	movs	r1, #6
 801c0e6:	2000      	movs	r0, #0
 801c0e8:	f7fe ff7e 	bl	801afe8 <CST_send_message>
 801c0ec:	e7ce      	b.n	801c08c <CST_pdn_event_mngt+0x28>
 801c0ee:	bf00      	nop
 801c0f0:	200000b0 	.word	0x200000b0
 801c0f4:	08034184 	.word	0x08034184
 801c0f8:	20004ddc 	.word	0x20004ddc

0801c0fc <CST_data_ready_state_network_event_mngt>:
{
 801c0fc:	b510      	push	{r4, lr}
  ret = CST_get_network_status();
 801c0fe:	f001 ff8b 	bl	801e018 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801c102:	b330      	cbz	r0, 801c152 <CST_data_ready_state_network_event_mngt+0x56>
  else if (ret == CST_NOT_REGISTERED)
 801c104:	2801      	cmp	r0, #1
 801c106:	d028      	beq.n	801c15a <CST_data_ready_state_network_event_mngt+0x5e>
  else if (ret == CST_NET_UNKNOWN)
 801c108:	2803      	cmp	r0, #3
 801c10a:	d02e      	beq.n	801c16a <CST_data_ready_state_network_event_mngt+0x6e>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c10c:	2100      	movs	r1, #0
 801c10e:	2003      	movs	r0, #3
 801c110:	f001 f960 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    PRINT_CELLULAR_SERVICE("******** CST_network_event_mngt: osCDS_get_net_status FAIL ****\n\r")
 801c114:	4c17      	ldr	r4, [pc, #92]	; (801c174 <CST_data_ready_state_network_event_mngt+0x78>)
 801c116:	2242      	movs	r2, #66	; 0x42
 801c118:	4917      	ldr	r1, [pc, #92]	; (801c178 <CST_data_ready_state_network_event_mngt+0x7c>)
 801c11a:	4620      	mov	r0, r4
 801c11c:	f009 fef8 	bl	8025f10 <memcpy>
 801c120:	4620      	mov	r0, r4
 801c122:	f002 fff6 	bl	801f112 <crs_strlen>
 801c126:	b283      	uxth	r3, r0
 801c128:	4622      	mov	r2, r4
 801c12a:	2101      	movs	r1, #1
 801c12c:	2007      	movs	r0, #7
 801c12e:	f003 f833 	bl	801f198 <traceIF_itmPrint>
 801c132:	4620      	mov	r0, r4
 801c134:	f002 ffed 	bl	801f112 <crs_strlen>
 801c138:	b283      	uxth	r3, r0
 801c13a:	4622      	mov	r2, r4
 801c13c:	2101      	movs	r1, #1
 801c13e:	2007      	movs	r0, #7
 801c140:	f003 f84c 	bl	801f1dc <traceIF_uartPrint>
    CST_config_fail(((uint8_t *)"CST_network_status_test_mngt"),
 801c144:	2305      	movs	r3, #5
 801c146:	4a0d      	ldr	r2, [pc, #52]	; (801c17c <CST_data_ready_state_network_event_mngt+0x80>)
 801c148:	4619      	mov	r1, r3
 801c14a:	480d      	ldr	r0, [pc, #52]	; (801c180 <CST_data_ready_state_network_event_mngt+0x84>)
 801c14c:	f001 f982 	bl	801d454 <CST_config_fail>
}
 801c150:	bd10      	pop	{r4, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801c152:	210d      	movs	r1, #13
 801c154:	f7fe ff48 	bl	801afe8 <CST_send_message>
 801c158:	e7fa      	b.n	801c150 <CST_data_ready_state_network_event_mngt+0x54>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c15a:	2100      	movs	r1, #0
 801c15c:	2003      	movs	r0, #3
 801c15e:	f001 f939 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801c162:	2004      	movs	r0, #4
 801c164:	f7ff f804 	bl	801b170 <CST_set_state>
 801c168:	e7f2      	b.n	801c150 <CST_data_ready_state_network_event_mngt+0x54>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801c16a:	210d      	movs	r1, #13
 801c16c:	2000      	movs	r0, #0
 801c16e:	f7fe ff3b 	bl	801afe8 <CST_send_message>
 801c172:	e7ed      	b.n	801c150 <CST_data_ready_state_network_event_mngt+0x54>
 801c174:	20004ddc 	.word	0x20004ddc
 801c178:	08033e30 	.word	0x08033e30
 801c17c:	200000c7 	.word	0x200000c7
 801c180:	08033e74 	.word	0x08033e74

0801c184 <CST_cellular_data_fail_mngt>:
{
 801c184:	b508      	push	{r3, lr}
  if (cst_context.current_state == CST_MODEM_DATA_READY_STATE)
 801c186:	4b06      	ldr	r3, [pc, #24]	; (801c1a0 <CST_cellular_data_fail_mngt+0x1c>)
 801c188:	881b      	ldrh	r3, [r3, #0]
 801c18a:	2b08      	cmp	r3, #8
 801c18c:	d003      	beq.n	801c196 <CST_cellular_data_fail_mngt+0x12>
  CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801c18e:	2003      	movs	r0, #3
 801c190:	f7fe ffee 	bl	801b170 <CST_set_state>
}
 801c194:	bd08      	pop	{r3, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c196:	2100      	movs	r1, #0
 801c198:	2003      	movs	r0, #3
 801c19a:	f001 f91b 	bl	801d3d4 <CST_data_cache_cellular_info_set>
 801c19e:	e7f6      	b.n	801c18e <CST_cellular_data_fail_mngt+0xa>
 801c1a0:	200000b0 	.word	0x200000b0

0801c1a4 <CST_data_ready_state>:
{
 801c1a4:	b508      	push	{r3, lr}
  switch (autom_event)
 801c1a6:	3808      	subs	r0, #8
 801c1a8:	2813      	cmp	r0, #19
 801c1aa:	d80d      	bhi.n	801c1c8 <CST_data_ready_state+0x24>
 801c1ac:	e8df f000 	tbb	[pc, r0]
 801c1b0:	0d100c13 	.word	0x0d100c13
 801c1b4:	160c0c0c 	.word	0x160c0c0c
 801c1b8:	0a0c190c 	.word	0x0a0c190c
 801c1bc:	0c0c1c0c 	.word	0x0c0c1c0c
 801c1c0:	190c0c0c 	.word	0x190c0c0c
      CST_data_ready_state_network_event_mngt();
 801c1c4:	f7ff ff9a 	bl	801c0fc <CST_data_ready_state_network_event_mngt>
}
 801c1c8:	bd08      	pop	{r3, pc}
      CST_polling_timer_mngt();
 801c1ca:	f7fe fe61 	bl	801ae90 <CST_polling_timer_mngt>
      break;
 801c1ce:	e7fb      	b.n	801c1c8 <CST_data_ready_state+0x24>
      CST_cellular_data_fail_mngt();
 801c1d0:	f7ff ffd8 	bl	801c184 <CST_cellular_data_fail_mngt>
      break;
 801c1d4:	e7f8      	b.n	801c1c8 <CST_data_ready_state+0x24>
      CST_pdn_event_mngt();
 801c1d6:	f7ff ff45 	bl	801c064 <CST_pdn_event_mngt>
      break;
 801c1da:	e7f5      	b.n	801c1c8 <CST_data_ready_state+0x24>
      CST_data_mode_target_state_event_mngt();
 801c1dc:	f7ff fa26 	bl	801b62c <CST_data_mode_target_state_event_mngt>
      break;
 801c1e0:	e7f2      	b.n	801c1c8 <CST_data_ready_state+0x24>
      CST_reboot_modem_event_mngt();
 801c1e2:	f7ff f82f 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801c1e6:	e7ef      	b.n	801c1c8 <CST_data_ready_state+0x24>
      CST_fota_start_event_mngt();
 801c1e8:	f7ff fa30 	bl	801b64c <CST_fota_start_event_mngt>
}
 801c1ec:	e7ec      	b.n	801c1c8 <CST_data_ready_state+0x24>
	...

0801c1f0 <CST_sim_only_target_state_event_mngt>:
{
 801c1f0:	b508      	push	{r3, lr}
  if (cst_cellular_params.target_state == DC_TARGET_STATE_FULL)
 801c1f2:	4b0d      	ldr	r3, [pc, #52]	; (801c228 <CST_sim_only_target_state_event_mngt+0x38>)
 801c1f4:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801c1f8:	2b02      	cmp	r3, #2
 801c1fa:	d002      	beq.n	801c202 <CST_sim_only_target_state_event_mngt+0x12>
  else if (cst_cellular_params.target_state == DC_TARGET_STATE_OFF)
 801c1fc:	b123      	cbz	r3, 801c208 <CST_sim_only_target_state_event_mngt+0x18>
    __NOP();
 801c1fe:	bf00      	nop
}
 801c200:	bd08      	pop	{r3, pc}
    CST_modem_sim_init();
 801c202:	f001 fa25 	bl	801d650 <CST_modem_sim_init>
 801c206:	e7fb      	b.n	801c200 <CST_sim_only_target_state_event_mngt+0x10>
    (void) osCDS_init_modem(CS_CMI_MINI, CELLULAR_FALSE, CST_SIM_PINCODE);
 801c208:	4a08      	ldr	r2, [pc, #32]	; (801c22c <CST_sim_only_target_state_event_mngt+0x3c>)
 801c20a:	2100      	movs	r1, #0
 801c20c:	4608      	mov	r0, r1
 801c20e:	f7fe fc39 	bl	801aa84 <osCDS_init_modem>
    (void)osCDS_power_off();
 801c212:	f7fe fc25 	bl	801aa60 <osCDS_power_off>
    CST_set_state(CST_MODEM_OFF_STATE);
 801c216:	200d      	movs	r0, #13
 801c218:	f7fe ffaa 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801c21c:	2101      	movs	r1, #1
 801c21e:	2000      	movs	r0, #0
 801c220:	f7fe fee2 	bl	801afe8 <CST_send_message>
 801c224:	e7ec      	b.n	801c200 <CST_sim_only_target_state_event_mngt+0x10>
 801c226:	bf00      	nop
 801c228:	20004160 	.word	0x20004160
 801c22c:	08034f74 	.word	0x08034f74

0801c230 <CST_modem_sim_only_state>:
{
 801c230:	b508      	push	{r3, lr}
  switch (autom_event)
 801c232:	280f      	cmp	r0, #15
 801c234:	d002      	beq.n	801c23c <CST_modem_sim_only_state+0xc>
 801c236:	2811      	cmp	r0, #17
 801c238:	d003      	beq.n	801c242 <CST_modem_sim_only_state+0x12>
}
 801c23a:	bd08      	pop	{r3, pc}
      CST_sim_only_target_state_event_mngt();
 801c23c:	f7ff ffd8 	bl	801c1f0 <CST_sim_only_target_state_event_mngt>
      break;
 801c240:	e7fb      	b.n	801c23a <CST_modem_sim_only_state+0xa>
      CST_reboot_modem_event_mngt();
 801c242:	f7fe ffff 	bl	801b244 <CST_reboot_modem_event_mngt>
}
 801c246:	e7f8      	b.n	801c23a <CST_modem_sim_only_state+0xa>

0801c248 <CST_apn_set_new_config_mngt>:
{
 801c248:	b570      	push	{r4, r5, r6, lr}
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&cst_apn_config, sizeof(dc_apn_config_t));
 801c24a:	4d36      	ldr	r5, [pc, #216]	; (801c324 <CST_apn_set_new_config_mngt+0xdc>)
 801c24c:	4e36      	ldr	r6, [pc, #216]	; (801c328 <CST_apn_set_new_config_mngt+0xe0>)
 801c24e:	236c      	movs	r3, #108	; 0x6c
 801c250:	462a      	mov	r2, r5
 801c252:	4936      	ldr	r1, [pc, #216]	; (801c32c <CST_apn_set_new_config_mngt+0xe4>)
 801c254:	8809      	ldrh	r1, [r1, #0]
 801c256:	4630      	mov	r0, r6
 801c258:	f005 fbb6 	bl	80219c8 <dc_com_read>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params));
 801c25c:	4c34      	ldr	r4, [pc, #208]	; (801c330 <CST_apn_set_new_config_mngt+0xe8>)
 801c25e:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801c262:	4622      	mov	r2, r4
 801c264:	4933      	ldr	r1, [pc, #204]	; (801c334 <CST_apn_set_new_config_mngt+0xec>)
 801c266:	8809      	ldrh	r1, [r1, #0]
 801c268:	4630      	mov	r0, r6
 801c26a:	f005 fbad 	bl	80219c8 <dc_com_read>
  cst_cellular_params.sim_slot[cst_sim_info.index_slot].cid  = cst_apn_config.cid;
 801c26e:	4b32      	ldr	r3, [pc, #200]	; (801c338 <CST_apn_set_new_config_mngt+0xf0>)
 801c270:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 801c274:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
 801c278:	2162      	movs	r1, #98	; 0x62
 801c27a:	fb01 4402 	mla	r4, r1, r2, r4
 801c27e:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  size = crs_strlen(cst_apn_config.apn) + 1U;
 801c282:	f105 0009 	add.w	r0, r5, #9
 801c286:	f002 ff44 	bl	801f112 <crs_strlen>
 801c28a:	1c42      	adds	r2, r0, #1
  if (size <= DC_MAX_SIZE_APN)
 801c28c:	2a20      	cmp	r2, #32
 801c28e:	d91d      	bls.n	801c2cc <CST_apn_set_new_config_mngt+0x84>
  size =  crs_strlen(cst_apn_config.username) + 1U;
 801c290:	482a      	ldr	r0, [pc, #168]	; (801c33c <CST_apn_set_new_config_mngt+0xf4>)
 801c292:	f002 ff3e 	bl	801f112 <crs_strlen>
 801c296:	1c42      	adds	r2, r0, #1
  if (size <= DC_CST_USERNAME_SIZE)
 801c298:	2a20      	cmp	r2, #32
 801c29a:	d926      	bls.n	801c2ea <CST_apn_set_new_config_mngt+0xa2>
  size =  crs_strlen(cst_apn_config.password) + 1U;
 801c29c:	4828      	ldr	r0, [pc, #160]	; (801c340 <CST_apn_set_new_config_mngt+0xf8>)
 801c29e:	f002 ff38 	bl	801f112 <crs_strlen>
 801c2a2:	1c42      	adds	r2, r0, #1
  if (size <= DC_CST_PASSWORD_SIZE)
 801c2a4:	2a20      	cmp	r2, #32
 801c2a6:	d92e      	bls.n	801c306 <CST_apn_set_new_config_mngt+0xbe>
  cst_cellular_params.rt_state = DC_SERVICE_ON;
 801c2a8:	4a21      	ldr	r2, [pc, #132]	; (801c330 <CST_apn_set_new_config_mngt+0xe8>)
 801c2aa:	2307      	movs	r3, #7
 801c2ac:	7213      	strb	r3, [r2, #8]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params));
 801c2ae:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801c2b2:	4920      	ldr	r1, [pc, #128]	; (801c334 <CST_apn_set_new_config_mngt+0xec>)
 801c2b4:	8809      	ldrh	r1, [r1, #0]
 801c2b6:	481c      	ldr	r0, [pc, #112]	; (801c328 <CST_apn_set_new_config_mngt+0xe0>)
 801c2b8:	f005 fb3a 	bl	8021930 <dc_com_write>
  CST_set_state(CST_MODEM_RESET_STATE);
 801c2bc:	200c      	movs	r0, #12
 801c2be:	f7fe ff57 	bl	801b170 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_RESET_EVENT);
 801c2c2:	2118      	movs	r1, #24
 801c2c4:	2000      	movs	r0, #0
 801c2c6:	f7fe fe8f 	bl	801afe8 <CST_send_message>
}
 801c2ca:	bd70      	pop	{r4, r5, r6, pc}
    (void)memcpy(cst_cellular_params.sim_slot[cst_sim_info.index_slot].apn,
 801c2cc:	4b1a      	ldr	r3, [pc, #104]	; (801c338 <CST_apn_set_new_config_mngt+0xf0>)
 801c2ce:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801c2d2:	2162      	movs	r1, #98	; 0x62
 801c2d4:	fb01 f303 	mul.w	r3, r1, r3
 801c2d8:	3308      	adds	r3, #8
 801c2da:	4815      	ldr	r0, [pc, #84]	; (801c330 <CST_apn_set_new_config_mngt+0xe8>)
 801c2dc:	4418      	add	r0, r3
 801c2de:	f105 0109 	add.w	r1, r5, #9
 801c2e2:	3004      	adds	r0, #4
 801c2e4:	f009 fe14 	bl	8025f10 <memcpy>
 801c2e8:	e7d2      	b.n	801c290 <CST_apn_set_new_config_mngt+0x48>
    (void)memcpy(cst_cellular_params.sim_slot[cst_sim_info.index_slot].username,
 801c2ea:	4b13      	ldr	r3, [pc, #76]	; (801c338 <CST_apn_set_new_config_mngt+0xf0>)
 801c2ec:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801c2f0:	2162      	movs	r1, #98	; 0x62
 801c2f2:	fb01 f303 	mul.w	r3, r1, r3
 801c2f6:	3328      	adds	r3, #40	; 0x28
 801c2f8:	480d      	ldr	r0, [pc, #52]	; (801c330 <CST_apn_set_new_config_mngt+0xe8>)
 801c2fa:	4418      	add	r0, r3
 801c2fc:	490f      	ldr	r1, [pc, #60]	; (801c33c <CST_apn_set_new_config_mngt+0xf4>)
 801c2fe:	3005      	adds	r0, #5
 801c300:	f009 fe06 	bl	8025f10 <memcpy>
 801c304:	e7ca      	b.n	801c29c <CST_apn_set_new_config_mngt+0x54>
    (void)memcpy(cst_cellular_params.sim_slot[cst_sim_info.index_slot].password,
 801c306:	4b0c      	ldr	r3, [pc, #48]	; (801c338 <CST_apn_set_new_config_mngt+0xf0>)
 801c308:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801c30c:	2162      	movs	r1, #98	; 0x62
 801c30e:	fb01 f303 	mul.w	r3, r1, r3
 801c312:	3348      	adds	r3, #72	; 0x48
 801c314:	4806      	ldr	r0, [pc, #24]	; (801c330 <CST_apn_set_new_config_mngt+0xe8>)
 801c316:	4418      	add	r0, r3
 801c318:	4909      	ldr	r1, [pc, #36]	; (801c340 <CST_apn_set_new_config_mngt+0xf8>)
 801c31a:	3005      	adds	r0, #5
 801c31c:	f009 fdf8 	bl	8025f10 <memcpy>
 801c320:	e7c2      	b.n	801c2a8 <CST_apn_set_new_config_mngt+0x60>
 801c322:	bf00      	nop
 801c324:	20003ff0 	.word	0x20003ff0
 801c328:	200058b0 	.word	0x200058b0
 801c32c:	20000230 	.word	0x20000230
 801c330:	20004160 	.word	0x20004160
 801c334:	20000232 	.word	0x20000232
 801c338:	20004338 	.word	0x20004338
 801c33c:	2000401a 	.word	0x2000401a
 801c340:	2000403a 	.word	0x2000403a

0801c344 <CST_apn_config_state>:
  switch (autom_event)
 801c344:	2810      	cmp	r0, #16
 801c346:	d000      	beq.n	801c34a <CST_apn_config_state+0x6>
 801c348:	4770      	bx	lr
{
 801c34a:	b508      	push	{r3, lr}
      CST_apn_set_new_config_mngt();
 801c34c:	f7ff ff7c 	bl	801c248 <CST_apn_set_new_config_mngt>
}
 801c350:	bd08      	pop	{r3, pc}
	...

0801c354 <CST_modem_reset_mngt>:
{
 801c354:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_modem_reset_mngt ********\n\r")
 801c356:	4c26      	ldr	r4, [pc, #152]	; (801c3f0 <CST_modem_reset_mngt+0x9c>)
 801c358:	4d26      	ldr	r5, [pc, #152]	; (801c3f4 <CST_modem_reset_mngt+0xa0>)
 801c35a:	f104 0e20 	add.w	lr, r4, #32
 801c35e:	46a4      	mov	ip, r4
 801c360:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801c364:	6028      	str	r0, [r5, #0]
 801c366:	6069      	str	r1, [r5, #4]
 801c368:	60aa      	str	r2, [r5, #8]
 801c36a:	60eb      	str	r3, [r5, #12]
 801c36c:	4664      	mov	r4, ip
 801c36e:	3510      	adds	r5, #16
 801c370:	45f4      	cmp	ip, lr
 801c372:	d1f4      	bne.n	801c35e <CST_modem_reset_mngt+0xa>
 801c374:	cc07      	ldmia	r4!, {r0, r1, r2}
 801c376:	6028      	str	r0, [r5, #0]
 801c378:	6069      	str	r1, [r5, #4]
 801c37a:	60aa      	str	r2, [r5, #8]
 801c37c:	4c1d      	ldr	r4, [pc, #116]	; (801c3f4 <CST_modem_reset_mngt+0xa0>)
 801c37e:	4620      	mov	r0, r4
 801c380:	f002 fec7 	bl	801f112 <crs_strlen>
 801c384:	b283      	uxth	r3, r0
 801c386:	4622      	mov	r2, r4
 801c388:	2101      	movs	r1, #1
 801c38a:	2007      	movs	r0, #7
 801c38c:	f002 ff04 	bl	801f198 <traceIF_itmPrint>
 801c390:	4620      	mov	r0, r4
 801c392:	f002 febe 	bl	801f112 <crs_strlen>
 801c396:	b283      	uxth	r3, r0
 801c398:	4622      	mov	r2, r4
 801c39a:	2101      	movs	r1, #1
 801c39c:	2007      	movs	r0, #7
 801c39e:	f002 ff1d 	bl	801f1dc <traceIF_uartPrint>
  cs_status = osCDS_power_off();
 801c3a2:	f7fe fb5d 	bl	801aa60 <osCDS_power_off>
  if (cs_status != CELLULAR_OK)
 801c3a6:	b130      	cbz	r0, 801c3b6 <CST_modem_reset_mngt+0x62>
    CST_config_fail(((uint8_t *)"CST_modem_reset_mngt"),
 801c3a8:	2305      	movs	r3, #5
 801c3aa:	4a13      	ldr	r2, [pc, #76]	; (801c3f8 <CST_modem_reset_mngt+0xa4>)
 801c3ac:	2102      	movs	r1, #2
 801c3ae:	4813      	ldr	r0, [pc, #76]	; (801c3fc <CST_modem_reset_mngt+0xa8>)
 801c3b0:	f001 f850 	bl	801d454 <CST_config_fail>
}
 801c3b4:	bd70      	pop	{r4, r5, r6, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c3b6:	2100      	movs	r1, #0
 801c3b8:	2003      	movs	r0, #3
 801c3ba:	f001 f80b 	bl	801d3d4 <CST_data_cache_cellular_info_set>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c3be:	4e10      	ldr	r6, [pc, #64]	; (801c400 <CST_modem_reset_mngt+0xac>)
 801c3c0:	4c10      	ldr	r4, [pc, #64]	; (801c404 <CST_modem_reset_mngt+0xb0>)
 801c3c2:	4d11      	ldr	r5, [pc, #68]	; (801c408 <CST_modem_reset_mngt+0xb4>)
 801c3c4:	23f4      	movs	r3, #244	; 0xf4
 801c3c6:	4622      	mov	r2, r4
 801c3c8:	8831      	ldrh	r1, [r6, #0]
 801c3ca:	4628      	mov	r0, r5
 801c3cc:	f005 fafc 	bl	80219c8 <dc_com_read>
    cst_cellular_info.rt_state = DC_SERVICE_ON;
 801c3d0:	2307      	movs	r3, #7
 801c3d2:	7223      	strb	r3, [r4, #8]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c3d4:	23f4      	movs	r3, #244	; 0xf4
 801c3d6:	4622      	mov	r2, r4
 801c3d8:	8831      	ldrh	r1, [r6, #0]
 801c3da:	4628      	mov	r0, r5
 801c3dc:	f005 faa8 	bl	8021930 <dc_com_write>
    CST_set_state(CST_MODEM_INIT_STATE);
 801c3e0:	2001      	movs	r0, #1
 801c3e2:	f7fe fec5 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801c3e6:	2101      	movs	r1, #1
 801c3e8:	2000      	movs	r0, #0
 801c3ea:	f7fe fdfd 	bl	801afe8 <CST_send_message>
}
 801c3ee:	e7e1      	b.n	801c3b4 <CST_modem_reset_mngt+0x60>
 801c3f0:	080341b8 	.word	0x080341b8
 801c3f4:	20004ddc 	.word	0x20004ddc
 801c3f8:	200000c2 	.word	0x200000c2
 801c3fc:	080341e4 	.word	0x080341e4
 801c400:	20000236 	.word	0x20000236
 801c404:	2000406c 	.word	0x2000406c
 801c408:	200058b0 	.word	0x200058b0

0801c40c <CST_modem_reset_state>:
{
 801c40c:	b508      	push	{r3, lr}
  CST_modem_reset_mngt();
 801c40e:	f7ff ffa1 	bl	801c354 <CST_modem_reset_mngt>
}
 801c412:	bd08      	pop	{r3, pc}

0801c414 <CST_notif_callback>:
{
 801c414:	b510      	push	{r4, lr}
  if ((dc_event_id == DC_CELLULAR_DATA_INFO)
 801c416:	4601      	mov	r1, r0
 801c418:	4b21      	ldr	r3, [pc, #132]	; (801c4a0 <CST_notif_callback+0x8c>)
 801c41a:	881b      	ldrh	r3, [r3, #0]
 801c41c:	4298      	cmp	r0, r3
 801c41e:	d009      	beq.n	801c434 <CST_notif_callback+0x20>
      || (dc_event_id == DC_CELLULAR_TARGET_STATE_CMD))
 801c420:	4b20      	ldr	r3, [pc, #128]	; (801c4a4 <CST_notif_callback+0x90>)
 801c422:	881b      	ldrh	r3, [r3, #0]
 801c424:	4298      	cmp	r0, r3
 801c426:	d005      	beq.n	801c434 <CST_notif_callback+0x20>
  else if (dc_event_id == DC_CELLULAR_APN_CONFIG)
 801c428:	4b1f      	ldr	r3, [pc, #124]	; (801c4a8 <CST_notif_callback+0x94>)
 801c42a:	8818      	ldrh	r0, [r3, #0]
 801c42c:	4281      	cmp	r1, r0
 801c42e:	d005      	beq.n	801c43c <CST_notif_callback+0x28>
    __NOP(); /* Nothing to do */
 801c430:	bf00      	nop
}
 801c432:	e002      	b.n	801c43a <CST_notif_callback+0x26>
    CST_send_message(CST_MESSAGE_DC_EVENT, (cst_autom_event_t)dc_event_id);
 801c434:	2001      	movs	r0, #1
 801c436:	f7fe fdd7 	bl	801afe8 <CST_send_message>
}
 801c43a:	bd10      	pop	{r4, pc}
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&cst_apn_config,
 801c43c:	4c1b      	ldr	r4, [pc, #108]	; (801c4ac <CST_notif_callback+0x98>)
 801c43e:	236c      	movs	r3, #108	; 0x6c
 801c440:	4622      	mov	r2, r4
 801c442:	4601      	mov	r1, r0
 801c444:	481a      	ldr	r0, [pc, #104]	; (801c4b0 <CST_notif_callback+0x9c>)
 801c446:	f005 fabf 	bl	80219c8 <dc_com_read>
    if (cst_apn_config.rt_state == DC_SERVICE_ON)
 801c44a:	7a23      	ldrb	r3, [r4, #8]
 801c44c:	2b07      	cmp	r3, #7
 801c44e:	d1f4      	bne.n	801c43a <CST_notif_callback+0x26>
      old_apn_len = crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn);
 801c450:	4b18      	ldr	r3, [pc, #96]	; (801c4b4 <CST_notif_callback+0xa0>)
 801c452:	7c1b      	ldrb	r3, [r3, #16]
 801c454:	2262      	movs	r2, #98	; 0x62
 801c456:	fb02 f303 	mul.w	r3, r2, r3
 801c45a:	3308      	adds	r3, #8
 801c45c:	4816      	ldr	r0, [pc, #88]	; (801c4b8 <CST_notif_callback+0xa4>)
 801c45e:	4418      	add	r0, r3
 801c460:	3004      	adds	r0, #4
 801c462:	f002 fe56 	bl	801f112 <crs_strlen>
 801c466:	4604      	mov	r4, r0
      new_apn_len = crs_strlen(cst_apn_config.apn);
 801c468:	4814      	ldr	r0, [pc, #80]	; (801c4bc <CST_notif_callback+0xa8>)
 801c46a:	f002 fe52 	bl	801f112 <crs_strlen>
 801c46e:	4602      	mov	r2, r0
      if ((old_apn_len != new_apn_len)
 801c470:	4284      	cmp	r4, r0
 801c472:	d10d      	bne.n	801c490 <CST_notif_callback+0x7c>
          (memcmp(cst_apn_config.apn, cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn, new_apn_len) != 0))
 801c474:	4b0f      	ldr	r3, [pc, #60]	; (801c4b4 <CST_notif_callback+0xa0>)
 801c476:	7c1b      	ldrb	r3, [r3, #16]
 801c478:	2162      	movs	r1, #98	; 0x62
 801c47a:	fb01 f303 	mul.w	r3, r1, r3
 801c47e:	3308      	adds	r3, #8
 801c480:	490d      	ldr	r1, [pc, #52]	; (801c4b8 <CST_notif_callback+0xa4>)
 801c482:	4419      	add	r1, r3
 801c484:	3104      	adds	r1, #4
 801c486:	480d      	ldr	r0, [pc, #52]	; (801c4bc <CST_notif_callback+0xa8>)
 801c488:	f009 fc55 	bl	8025d36 <memcmp>
          ||
 801c48c:	2800      	cmp	r0, #0
 801c48e:	d0d4      	beq.n	801c43a <CST_notif_callback+0x26>
          CST_set_state(CST_APN_CONFIG_STATE);
 801c490:	2010      	movs	r0, #16
 801c492:	f7fe fe6d 	bl	801b170 <CST_set_state>
          CST_send_message(CST_MESSAGE_CS_EVENT, CST_APN_CONFIG_EVENT);
 801c496:	2110      	movs	r1, #16
 801c498:	2000      	movs	r0, #0
 801c49a:	f7fe fda5 	bl	801afe8 <CST_send_message>
 801c49e:	e7cc      	b.n	801c43a <CST_notif_callback+0x26>
 801c4a0:	20000234 	.word	0x20000234
 801c4a4:	2000023e 	.word	0x2000023e
 801c4a8:	20000230 	.word	0x20000230
 801c4ac:	20003ff0 	.word	0x20003ff0
 801c4b0:	200058b0 	.word	0x200058b0
 801c4b4:	200000b0 	.word	0x200000b0
 801c4b8:	20004160 	.word	0x20004160
 801c4bc:	20003ff9 	.word	0x20003ff9

0801c4c0 <CST_get_state>:
  * @retval CST_autom_state_t - automaton state
  */
CST_autom_state_t CST_get_state(void)
{
  return cst_context.current_state;
}
 801c4c0:	4b01      	ldr	r3, [pc, #4]	; (801c4c8 <CST_get_state+0x8>)
 801c4c2:	8818      	ldrh	r0, [r3, #0]
 801c4c4:	4770      	bx	lr
 801c4c6:	bf00      	nop
 801c4c8:	200000b0 	.word	0x200000b0

0801c4cc <CST_radio_on>:
  * @brief  allows to set radio on: start cellular automaton
  * @param  -
  * @retval CS_Status_t - return code
  */
CS_Status_t  CST_radio_on(void)
{
 801c4cc:	b508      	push	{r3, lr}
  /* Sends a message to start automaton */
  CST_send_message(CST_MESSAGE_CMD, CST_BOOT_EVENT);
 801c4ce:	2100      	movs	r1, #0
 801c4d0:	2002      	movs	r0, #2
 801c4d2:	f7fe fd89 	bl	801afe8 <CST_send_message>
  return CELLULAR_OK;
}
 801c4d6:	2000      	movs	r0, #0
 801c4d8:	bd08      	pop	{r3, pc}
	...

0801c4dc <CST_get_dev_IP_address>:
  * @param  ip_addr_type - type of IP address
  * @param  p_ip_addr_value - IP address value returned by the function
  * @retval CS_Status_t - return code
  */
CS_Status_t CST_get_dev_IP_address(CS_IPaddrType_t *ip_addr_type, CS_CHAR_t *p_ip_addr_value)
{
 801c4dc:	b538      	push	{r3, r4, r5, lr}
 801c4de:	4604      	mov	r4, r0
 801c4e0:	460d      	mov	r5, r1
  return osCDS_get_dev_IP_address(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801c4e2:	4b07      	ldr	r3, [pc, #28]	; (801c500 <CST_get_dev_IP_address+0x24>)
 801c4e4:	7c1a      	ldrb	r2, [r3, #16]
 801c4e6:	4b07      	ldr	r3, [pc, #28]	; (801c504 <CST_get_dev_IP_address+0x28>)
 801c4e8:	2162      	movs	r1, #98	; 0x62
 801c4ea:	fb01 3302 	mla	r3, r1, r2, r3
 801c4ee:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801c4f2:	f7fd fe64 	bl	801a1be <cst_get_cid_value>
 801c4f6:	462a      	mov	r2, r5
 801c4f8:	4621      	mov	r1, r4
 801c4fa:	f7fe fb83 	bl	801ac04 <osCDS_get_dev_IP_address>
                                  ip_addr_type,
                                  p_ip_addr_value);
}
 801c4fe:	bd38      	pop	{r3, r4, r5, pc}
 801c500:	200000b0 	.word	0x200000b0
 801c504:	20004160 	.word	0x20004160

0801c508 <CST_data_ready_mngt>:
{
 801c508:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c50a:	b083      	sub	sp, #12
  cst_context.power_on_reset_count       = 0U;
 801c50c:	4b20      	ldr	r3, [pc, #128]	; (801c590 <CST_data_ready_mngt+0x88>)
 801c50e:	2400      	movs	r4, #0
 801c510:	745c      	strb	r4, [r3, #17]
  cst_context.reset_count                = 0U;
 801c512:	749c      	strb	r4, [r3, #18]
  cst_context.csq_reset_count            = 0U;
 801c514:	74dc      	strb	r4, [r3, #19]
  cst_context.attach_reset_count         = 0U;
 801c516:	751c      	strb	r4, [r3, #20]
  cst_context.activate_pdn_reset_count   = 0U;
 801c518:	755c      	strb	r4, [r3, #21]
  cst_context.cellular_data_retry_count  = 0U;
 801c51a:	769c      	strb	r4, [r3, #26]
  cst_context.ppp_fail_count             = 0U;
 801c51c:	765c      	strb	r4, [r3, #25]
  cst_context.global_retry_count         = 0U;
 801c51e:	76dc      	strb	r4, [r3, #27]
  CST_set_state(CST_MODEM_DATA_READY_STATE);
 801c520:	2008      	movs	r0, #8
 801c522:	f7fe fe25 	bl	801b170 <CST_set_state>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c526:	4f1b      	ldr	r7, [pc, #108]	; (801c594 <CST_data_ready_mngt+0x8c>)
 801c528:	4d1b      	ldr	r5, [pc, #108]	; (801c598 <CST_data_ready_mngt+0x90>)
 801c52a:	4e1c      	ldr	r6, [pc, #112]	; (801c59c <CST_data_ready_mngt+0x94>)
 801c52c:	23f4      	movs	r3, #244	; 0xf4
 801c52e:	462a      	mov	r2, r5
 801c530:	8839      	ldrh	r1, [r7, #0]
 801c532:	4630      	mov	r0, r6
 801c534:	f005 fa48 	bl	80219c8 <dc_com_read>
  cst_cellular_info.modem_state = DC_MODEM_STATE_DATA_OK;
 801c538:	2303      	movs	r3, #3
 801c53a:	726b      	strb	r3, [r5, #9]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c53c:	23f4      	movs	r3, #244	; 0xf4
 801c53e:	462a      	mov	r2, r5
 801c540:	8839      	ldrh	r1, [r7, #0]
 801c542:	4630      	mov	r0, r6
 801c544:	f005 f9f4 	bl	8021930 <dc_com_write>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801c548:	210d      	movs	r1, #13
 801c54a:	4620      	mov	r0, r4
 801c54c:	f7fe fd4c 	bl	801afe8 <CST_send_message>
  (void)CST_get_dev_IP_address(&ip_addr_type, cs_ip_addr);
 801c550:	4d13      	ldr	r5, [pc, #76]	; (801c5a0 <CST_data_ready_mngt+0x98>)
 801c552:	4629      	mov	r1, r5
 801c554:	f10d 0007 	add.w	r0, sp, #7
 801c558:	f7ff ffc0 	bl	801c4dc <CST_get_dev_IP_address>
  err = crc_get_ip_addr(&cs_ip_addr[1], cs_ip_addr, NULL);
 801c55c:	4622      	mov	r2, r4
 801c55e:	4629      	mov	r1, r5
 801c560:	1c68      	adds	r0, r5, #1
 801c562:	f002 fd32 	bl	801efca <crc_get_ip_addr>
  if (err == 0U)
 801c566:	b980      	cbnz	r0, 801c58a <CST_data_ready_mngt+0x82>
    ip_addr.addr = (uint32_t)cs_ip_addr[0] +
 801c568:	782b      	ldrb	r3, [r5, #0]
                   ((uint32_t)cs_ip_addr[1] <<  8) +
 801c56a:	7869      	ldrb	r1, [r5, #1]
    ip_addr.addr = (uint32_t)cs_ip_addr[0] +
 801c56c:	eb03 2301 	add.w	r3, r3, r1, lsl #8
                   ((uint32_t)cs_ip_addr[2] << 16) +
 801c570:	78a9      	ldrb	r1, [r5, #2]
                   ((uint32_t)cs_ip_addr[1] <<  8) +
 801c572:	eb03 4301 	add.w	r3, r3, r1, lsl #16
                   ((uint32_t)cs_ip_addr[3] << 24);
 801c576:	78ea      	ldrb	r2, [r5, #3]
                   ((uint32_t)cs_ip_addr[2] << 16) +
 801c578:	eb03 6302 	add.w	r3, r3, r2, lsl #24
    ip_addr.addr = (uint32_t)cs_ip_addr[0] +
 801c57c:	9300      	str	r3, [sp, #0]
  CST_data_cache_cellular_info_set(DC_SERVICE_ON, &ip_addr);
 801c57e:	4669      	mov	r1, sp
 801c580:	2007      	movs	r0, #7
 801c582:	f000 ff27 	bl	801d3d4 <CST_data_cache_cellular_info_set>
}
 801c586:	b003      	add	sp, #12
 801c588:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ip_addr.addr = 0;
 801c58a:	2300      	movs	r3, #0
 801c58c:	9300      	str	r3, [sp, #0]
 801c58e:	e7f6      	b.n	801c57e <CST_data_ready_mngt+0x76>
 801c590:	200000b0 	.word	0x200000b0
 801c594:	20000236 	.word	0x20000236
 801c598:	2000406c 	.word	0x2000406c
 801c59c:	200058b0 	.word	0x200058b0
 801c5a0:	20003fb0 	.word	0x20003fb0

0801c5a4 <CST_modem_activated_mngt>:
{
 801c5a4:	b508      	push	{r3, lr}
  CST_data_ready_mngt();
 801c5a6:	f7ff ffaf 	bl	801c508 <CST_data_ready_mngt>
}
 801c5aa:	bd08      	pop	{r3, pc}

0801c5ac <CST_modem_pdn_activating_state>:
{
 801c5ac:	b508      	push	{r3, lr}
  switch (autom_event)
 801c5ae:	3807      	subs	r0, #7
 801c5b0:	280e      	cmp	r0, #14
 801c5b2:	d80b      	bhi.n	801c5cc <CST_modem_pdn_activating_state+0x20>
 801c5b4:	e8df f000 	tbb	[pc, r0]
 801c5b8:	0a0b1108 	.word	0x0a0b1108
 801c5bc:	0a0a0a0a 	.word	0x0a0a0a0a
 801c5c0:	0a170a14 	.word	0x0a170a14
 801c5c4:	0a0e      	.short	0x0a0e
 801c5c6:	1a          	.byte	0x1a
 801c5c7:	00          	.byte	0x00
      CST_modem_activated_mngt();
 801c5c8:	f7ff ffec 	bl	801c5a4 <CST_modem_activated_mngt>
}
 801c5cc:	bd08      	pop	{r3, pc}
      CST_modem_activate_pdn_mngt();
 801c5ce:	f7ff fc3f 	bl	801be50 <CST_modem_activate_pdn_mngt>
      break;
 801c5d2:	e7fb      	b.n	801c5cc <CST_modem_pdn_activating_state+0x20>
      CST_network_event_mngt();
 801c5d4:	f7ff f980 	bl	801b8d8 <CST_network_event_mngt>
      break;
 801c5d8:	e7f8      	b.n	801c5cc <CST_modem_pdn_activating_state+0x20>
      CST_pdn_event_mngt();
 801c5da:	f7ff fd43 	bl	801c064 <CST_pdn_event_mngt>
      break;
 801c5de:	e7f5      	b.n	801c5cc <CST_modem_pdn_activating_state+0x20>
      CST_target_state_cmd_event_mngt();
 801c5e0:	f7fe ff78 	bl	801b4d4 <CST_target_state_cmd_event_mngt>
      break;
 801c5e4:	e7f2      	b.n	801c5cc <CST_modem_pdn_activating_state+0x20>
      CST_reboot_modem_event_mngt();
 801c5e6:	f7fe fe2d 	bl	801b244 <CST_reboot_modem_event_mngt>
      break;
 801c5ea:	e7ef      	b.n	801c5cc <CST_modem_pdn_activating_state+0x20>
      CST_fota_start_event_mngt();
 801c5ec:	f7ff f82e 	bl	801b64c <CST_fota_start_event_mngt>
}
 801c5f0:	e7ec      	b.n	801c5cc <CST_modem_pdn_activating_state+0x20>
	...

0801c5f4 <CST_cellular_service_task>:
{
 801c5f4:	b530      	push	{r4, r5, lr}
 801c5f6:	b083      	sub	sp, #12
 801c5f8:	e071      	b.n	801c6de <CST_cellular_service_task+0xea>
      PRINT_CELLULAR_SERVICE("AUTOM TASK:  %s - %s\n\r", CST_StateName[cst_context.current_state],
 801c5fa:	4d58      	ldr	r5, [pc, #352]	; (801c75c <CST_cellular_service_task+0x168>)
 801c5fc:	4b58      	ldr	r3, [pc, #352]	; (801c760 <CST_cellular_service_task+0x16c>)
 801c5fe:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 801c602:	4958      	ldr	r1, [pc, #352]	; (801c764 <CST_cellular_service_task+0x170>)
 801c604:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 801c608:	4957      	ldr	r1, [pc, #348]	; (801c768 <CST_cellular_service_task+0x174>)
 801c60a:	4628      	mov	r0, r5
 801c60c:	f009 fb30 	bl	8025c70 <sprintf>
 801c610:	4628      	mov	r0, r5
 801c612:	f002 fd7e 	bl	801f112 <crs_strlen>
 801c616:	b283      	uxth	r3, r0
 801c618:	462a      	mov	r2, r5
 801c61a:	2101      	movs	r1, #1
 801c61c:	2007      	movs	r0, #7
 801c61e:	f002 fdbb 	bl	801f198 <traceIF_itmPrint>
 801c622:	4628      	mov	r0, r5
 801c624:	f002 fd75 	bl	801f112 <crs_strlen>
 801c628:	b283      	uxth	r3, r0
 801c62a:	462a      	mov	r2, r5
 801c62c:	2101      	movs	r1, #1
 801c62e:	2007      	movs	r0, #7
 801c630:	f002 fdd4 	bl	801f1dc <traceIF_uartPrint>
 801c634:	e066      	b.n	801c704 <CST_cellular_service_task+0x110>
          CST_boot_state(autom_event);
 801c636:	4620      	mov	r0, r4
 801c638:	f7fe fe92 	bl	801b360 <CST_boot_state>
          break;
 801c63c:	e04f      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_init_state(autom_event);
 801c63e:	4620      	mov	r0, r4
 801c640:	f7ff f850 	bl	801b6e4 <CST_init_state>
          break;
 801c644:	e04b      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_ready_state(autom_event);
 801c646:	4620      	mov	r0, r4
 801c648:	f7ff f8f4 	bl	801b834 <CST_modem_ready_state>
          break;
 801c64c:	e047      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_waiting_for_signal_quality_ok_state(autom_event);
 801c64e:	4620      	mov	r0, r4
 801c650:	f7ff f98a 	bl	801b968 <CST_waiting_for_signal_quality_ok_state>
          break;
 801c654:	e043      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_waiting_for_network_status_state(autom_event);
 801c656:	4620      	mov	r0, r4
 801c658:	f7ff fa84 	bl	801bb64 <CST_waiting_for_network_status_state>
          break;
 801c65c:	e03f      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_network_status_ok_state(autom_event);
 801c65e:	4620      	mov	r0, r4
 801c660:	f7ff fbda 	bl	801be18 <CST_network_status_ok_state>
          break;
 801c664:	e03b      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_registered_state(autom_event);
 801c666:	4620      	mov	r0, r4
 801c668:	f7ff fc7c 	bl	801bf64 <CST_modem_registered_state>
          break;
 801c66c:	e037      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_pdn_activating_state(autom_event);
 801c66e:	4620      	mov	r0, r4
 801c670:	f7ff ff9c 	bl	801c5ac <CST_modem_pdn_activating_state>
          break;
 801c674:	e033      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_data_ready_state(autom_event);
 801c676:	4620      	mov	r0, r4
 801c678:	f7ff fd94 	bl	801c1a4 <CST_data_ready_state>
          break;
 801c67c:	e02f      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_off_state(autom_event);
 801c67e:	4620      	mov	r0, r4
 801c680:	f7fe fe22 	bl	801b2c8 <CST_modem_off_state>
          break;
 801c684:	e02b      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_sim_only_state(autom_event);
 801c686:	4620      	mov	r0, r4
 801c688:	f7ff fdd2 	bl	801c230 <CST_modem_sim_only_state>
          break;
 801c68c:	e027      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_reprog_state(autom_event);
 801c68e:	4620      	mov	r0, r4
 801c690:	f7fe fc9a 	bl	801afc8 <CST_modem_reprog_state>
          break;
 801c694:	e023      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_apn_config_state(autom_event);
 801c696:	4620      	mov	r0, r4
 801c698:	f7ff fe54 	bl	801c344 <CST_apn_config_state>
          break;
 801c69c:	e01f      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_modem_reset_state(autom_event);
 801c69e:	4620      	mov	r0, r4
 801c6a0:	f7ff feb4 	bl	801c40c <CST_modem_reset_state>
          break;
 801c6a4:	e01b      	b.n	801c6de <CST_cellular_service_task+0xea>
          CST_fail_state(autom_event);
 801c6a6:	4620      	mov	r0, r4
 801c6a8:	f7fe fe1f 	bl	801b2ea <CST_fail_state>
          break;
 801c6ac:	e017      	b.n	801c6de <CST_cellular_service_task+0xea>
      PRINT_CELLULAR_SERVICE("============ CST_cellular_service_task : autom_event = no event \n\r")
 801c6ae:	4c2b      	ldr	r4, [pc, #172]	; (801c75c <CST_cellular_service_task+0x168>)
 801c6b0:	2243      	movs	r2, #67	; 0x43
 801c6b2:	492e      	ldr	r1, [pc, #184]	; (801c76c <CST_cellular_service_task+0x178>)
 801c6b4:	4620      	mov	r0, r4
 801c6b6:	f009 fc2b 	bl	8025f10 <memcpy>
 801c6ba:	4620      	mov	r0, r4
 801c6bc:	f002 fd29 	bl	801f112 <crs_strlen>
 801c6c0:	b283      	uxth	r3, r0
 801c6c2:	4622      	mov	r2, r4
 801c6c4:	2101      	movs	r1, #1
 801c6c6:	2007      	movs	r0, #7
 801c6c8:	f002 fd66 	bl	801f198 <traceIF_itmPrint>
 801c6cc:	4620      	mov	r0, r4
 801c6ce:	f002 fd20 	bl	801f112 <crs_strlen>
 801c6d2:	b283      	uxth	r3, r0
 801c6d4:	4622      	mov	r2, r4
 801c6d6:	2101      	movs	r1, #1
 801c6d8:	2007      	movs	r0, #7
 801c6da:	f002 fd7f 	bl	801f1dc <traceIF_uartPrint>
    event = 0xffffffffU;
 801c6de:	f04f 32ff 	mov.w	r2, #4294967295
 801c6e2:	9201      	str	r2, [sp, #4]
    (void)rtosalMessageQueueGet((osMessageQId)cst_queue_id, &event, RTOSAL_WAIT_FOREVER);
 801c6e4:	a901      	add	r1, sp, #4
 801c6e6:	4b22      	ldr	r3, [pc, #136]	; (801c770 <CST_cellular_service_task+0x17c>)
 801c6e8:	6818      	ldr	r0, [r3, #0]
 801c6ea:	f002 fc44 	bl	801ef76 <rtosalMessageQueueGet>
    autom_event = CST_get_autom_event(event);
 801c6ee:	9801      	ldr	r0, [sp, #4]
 801c6f0:	f001 fc4c 	bl	801df8c <CST_get_autom_event>
 801c6f4:	4604      	mov	r4, r0
    if ((cst_context.current_state < CST_MAX_STATE) && (autom_event < CST_MAX_EVENT))
 801c6f6:	4b1f      	ldr	r3, [pc, #124]	; (801c774 <CST_cellular_service_task+0x180>)
 801c6f8:	881a      	ldrh	r2, [r3, #0]
 801c6fa:	2a12      	cmp	r2, #18
 801c6fc:	d802      	bhi.n	801c704 <CST_cellular_service_task+0x110>
 801c6fe:	281b      	cmp	r0, #27
 801c700:	f67f af7b 	bls.w	801c5fa <CST_cellular_service_task+0x6>
    if (autom_event != CST_NO_EVENT)
 801c704:	2c0d      	cmp	r4, #13
 801c706:	d0d2      	beq.n	801c6ae <CST_cellular_service_task+0xba>
      switch (cst_context.current_state)
 801c708:	4b1a      	ldr	r3, [pc, #104]	; (801c774 <CST_cellular_service_task+0x180>)
 801c70a:	881b      	ldrh	r3, [r3, #0]
 801c70c:	2b10      	cmp	r3, #16
 801c70e:	d8e6      	bhi.n	801c6de <CST_cellular_service_task+0xea>
 801c710:	a201      	add	r2, pc, #4	; (adr r2, 801c718 <CST_cellular_service_task+0x124>)
 801c712:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c716:	bf00      	nop
 801c718:	0801c637 	.word	0x0801c637
 801c71c:	0801c63f 	.word	0x0801c63f
 801c720:	0801c647 	.word	0x0801c647
 801c724:	0801c64f 	.word	0x0801c64f
 801c728:	0801c657 	.word	0x0801c657
 801c72c:	0801c65f 	.word	0x0801c65f
 801c730:	0801c667 	.word	0x0801c667
 801c734:	0801c66f 	.word	0x0801c66f
 801c738:	0801c677 	.word	0x0801c677
 801c73c:	0801c68f 	.word	0x0801c68f
 801c740:	0801c6a7 	.word	0x0801c6a7
 801c744:	0801c687 	.word	0x0801c687
 801c748:	0801c69f 	.word	0x0801c69f
 801c74c:	0801c67f 	.word	0x0801c67f
 801c750:	0801c6df 	.word	0x0801c6df
 801c754:	0801c6df 	.word	0x0801c6df
 801c758:	0801c697 	.word	0x0801c697
 801c75c:	20004ddc 	.word	0x20004ddc
 801c760:	080346e4 	.word	0x080346e4
 801c764:	20000064 	.word	0x20000064
 801c768:	080341fc 	.word	0x080341fc
 801c76c:	08034214 	.word	0x08034214
 801c770:	20004330 	.word	0x20004330
 801c774:	200000b0 	.word	0x200000b0

0801c778 <CST_cellular_service_init>:
  * @brief  initializes cellular service component
  * @param  -
  * @retval CS_Status_t - return code
  */
CS_Status_t CST_cellular_service_init(void)
{
 801c778:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t ret;

  CST_set_state(CST_BOOT_STATE);
 801c77a:	2000      	movs	r0, #0
 801c77c:	f7fe fcf8 	bl	801b170 <CST_set_state>

  /* request modem init to Cellular Service */
  ret = CS_init();
 801c780:	f7f9 fa82 	bl	8015c88 <CS_init>

  if (ret == CELLULAR_OK)
 801c784:	4604      	mov	r4, r0
 801c786:	b108      	cbz	r0, 801c78c <CST_cellular_service_init+0x14>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 5, ERROR_FATAL);
      ret = CELLULAR_ERROR;
    }
  }
  return ret;
}
 801c788:	4620      	mov	r0, r4
 801c78a:	bd38      	pop	{r3, r4, r5, pc}
    (void)osCDS_cellular_service_init();
 801c78c:	f7fe f8d6 	bl	801a93c <osCDS_cellular_service_init>
    cst_context.csq_count_fail = 0U;
 801c790:	2500      	movs	r5, #0
 801c792:	4b0c      	ldr	r3, [pc, #48]	; (801c7c4 <CST_cellular_service_init+0x4c>)
 801c794:	771d      	strb	r5, [r3, #28]
    CST_polling_active = true;
 801c796:	4b0c      	ldr	r3, [pc, #48]	; (801c7c8 <CST_cellular_service_init+0x50>)
 801c798:	2201      	movs	r2, #1
 801c79a:	701a      	strb	r2, [r3, #0]
    CST_polling_on_going = false;
 801c79c:	4b0b      	ldr	r3, [pc, #44]	; (801c7cc <CST_cellular_service_init+0x54>)
 801c79e:	701d      	strb	r5, [r3, #0]
    (void)CST_config_init();
 801c7a0:	f7fd fdc0 	bl	801a324 <CST_config_init>
    cst_queue_id = rtosalMessageQueueNew(NULL, CST_QUEUE_SIZE);
 801c7a4:	210a      	movs	r1, #10
 801c7a6:	4628      	mov	r0, r5
 801c7a8:	f002 fbd5 	bl	801ef56 <rtosalMessageQueueNew>
 801c7ac:	4b08      	ldr	r3, [pc, #32]	; (801c7d0 <CST_cellular_service_init+0x58>)
 801c7ae:	6018      	str	r0, [r3, #0]
    if (cst_queue_id == NULL)
 801c7b0:	2800      	cmp	r0, #0
 801c7b2:	d1e9      	bne.n	801c788 <CST_cellular_service_init+0x10>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 5, ERROR_FATAL);
 801c7b4:	2203      	movs	r2, #3
 801c7b6:	2105      	movs	r1, #5
 801c7b8:	2007      	movs	r0, #7
 801c7ba:	f001 fcc7 	bl	801e14c <ERROR_Handler>
      ret = CELLULAR_ERROR;
 801c7be:	2401      	movs	r4, #1
 801c7c0:	e7e2      	b.n	801c788 <CST_cellular_service_init+0x10>
 801c7c2:	bf00      	nop
 801c7c4:	200000b0 	.word	0x200000b0
 801c7c8:	20003fac 	.word	0x20003fac
 801c7cc:	20003fad 	.word	0x20003fad
 801c7d0:	20004330 	.word	0x20004330

0801c7d4 <CST_cellular_service_start>:
  * @note   cellular service task automaton and tempos are started
  * @param  -
  * @retval CS_Status_t - return code
  */
CS_Status_t CST_cellular_service_start(void)
{
 801c7d4:	b570      	push	{r4, r5, r6, lr}
 801c7d6:	b08e      	sub	sp, #56	; 0x38
  cs_ret  = 0U;

  osTimerId         cst_polling_timer_handle;

#if (USE_CMD_CONSOLE == 1)
  (void)CST_cmd_cellular_service_start();
 801c7d8:	f7fd fcc0 	bl	801a15c <CST_cmd_cellular_service_start>
#endif /*  (USE_CMD_CONSOLE == 1) */

  /* reads cellular configuration in Data Cache */
  if (dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params)) ==
 801c7dc:	4d55      	ldr	r5, [pc, #340]	; (801c934 <CST_cellular_service_start+0x160>)
 801c7de:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801c7e2:	4a55      	ldr	r2, [pc, #340]	; (801c938 <CST_cellular_service_start+0x164>)
 801c7e4:	4955      	ldr	r1, [pc, #340]	; (801c93c <CST_cellular_service_start+0x168>)
 801c7e6:	8809      	ldrh	r1, [r1, #0]
 801c7e8:	4628      	mov	r0, r5
 801c7ea:	f005 f8ed 	bl	80219c8 <dc_com_read>
 801c7ee:	4604      	mov	r4, r0
  {
    dc_ret = DC_COM_ERROR;
  }

  /* initializes Data Cache SIM slot entry  */
  if (dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info)) == DC_COM_ERROR)
 801c7f0:	2330      	movs	r3, #48	; 0x30
 801c7f2:	4a53      	ldr	r2, [pc, #332]	; (801c940 <CST_cellular_service_start+0x16c>)
 801c7f4:	4953      	ldr	r1, [pc, #332]	; (801c944 <CST_cellular_service_start+0x170>)
 801c7f6:	8809      	ldrh	r1, [r1, #0]
 801c7f8:	4628      	mov	r0, r5
 801c7fa:	f005 f8e5 	bl	80219c8 <dc_com_read>
 801c7fe:	4606      	mov	r6, r0
 801c800:	b100      	cbz	r0, 801c804 <CST_cellular_service_start+0x30>
 801c802:	4626      	mov	r6, r4
  {
    dc_ret = DC_COM_ERROR;
  }
  cst_sim_info.sim_status[DC_SIM_SLOT_MODEM_SOCKET]       = DC_SIM_NOT_USED;
 801c804:	4a4e      	ldr	r2, [pc, #312]	; (801c940 <CST_cellular_service_start+0x16c>)
 801c806:	2307      	movs	r3, #7
 801c808:	f882 302b 	strb.w	r3, [r2, #43]	; 0x2b
  cst_sim_info.sim_status[DC_SIM_SLOT_MODEM_EMBEDDED_SIM] = DC_SIM_NOT_USED;
 801c80c:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
  cst_sim_info.sim_status[DC_SIM_SLOT_STM32_EMBEDDED_SIM] = DC_SIM_NOT_USED;
 801c810:	f882 302d 	strb.w	r3, [r2, #45]	; 0x2d
  cst_context.sim_slot_index = 0U;
 801c814:	2300      	movs	r3, #0
 801c816:	494c      	ldr	r1, [pc, #304]	; (801c948 <CST_cellular_service_start+0x174>)
 801c818:	740b      	strb	r3, [r1, #16]
  cst_sim_info.active_slot = cst_cellular_params.sim_slot[cst_context.sim_slot_index].sim_slot_type;
 801c81a:	4947      	ldr	r1, [pc, #284]	; (801c938 <CST_cellular_service_start+0x164>)
 801c81c:	7ac9      	ldrb	r1, [r1, #11]
 801c81e:	f882 102a 	strb.w	r1, [r2, #42]	; 0x2a
  cst_sim_info.index_slot  = cst_context.sim_slot_index;
 801c822:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
  if (dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info)) == DC_COM_ERROR)
 801c826:	2330      	movs	r3, #48	; 0x30
 801c828:	4946      	ldr	r1, [pc, #280]	; (801c944 <CST_cellular_service_start+0x170>)
 801c82a:	8809      	ldrh	r1, [r1, #0]
 801c82c:	4841      	ldr	r0, [pc, #260]	; (801c934 <CST_cellular_service_start+0x160>)
 801c82e:	f005 f87f 	bl	8021930 <dc_com_write>
 801c832:	4605      	mov	r5, r0
 801c834:	b100      	cbz	r0, 801c838 <CST_cellular_service_start+0x64>
 801c836:	4635      	mov	r5, r6
  {
    dc_ret = DC_COM_ERROR;
  }

  /* request AT core to start */
  if (atcore_task_start(ATCORE_THREAD_STACK_PRIO, ATCORE_THREAD_STACK_SIZE) != ATSTATUS_OK)
 801c838:	f44f 71c0 	mov.w	r1, #384	; 0x180
 801c83c:	2000      	movs	r0, #0
 801c83e:	f7ef fb3f 	bl	800bec0 <atcore_task_start>
 801c842:	2800      	cmp	r0, #0
 801c844:	d15f      	bne.n	801c906 <CST_cellular_service_start+0x132>
  cs_ret  = 0U;
 801c846:	2400      	movs	r4, #0
    cs_ret |= (uint32_t)CELLULAR_ERROR;
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 6, ERROR_WARNING);
  }

  /* register component to Data Cache  */
  if (dc_com_register_gen_event_cb(&dc_com_db, CST_notif_callback, (const void *)NULL) == DC_COM_INVALID_ENTRY)
 801c848:	2200      	movs	r2, #0
 801c84a:	4940      	ldr	r1, [pc, #256]	; (801c94c <CST_cellular_service_start+0x178>)
 801c84c:	4839      	ldr	r0, [pc, #228]	; (801c934 <CST_cellular_service_start+0x160>)
 801c84e:	f005 f83f 	bl	80218d0 <dc_com_register_gen_event_cb>
 801c852:	28ff      	cmp	r0, #255	; 0xff
 801c854:	d05e      	beq.n	801c914 <CST_cellular_service_start+0x140>
  {
    dc_ret = DC_COM_ERROR;
  }
  cst_cellular_info.mno_name[0]           = 0U;
 801c856:	4a3e      	ldr	r2, [pc, #248]	; (801c950 <CST_cellular_service_start+0x17c>)
 801c858:	2300      	movs	r3, #0
 801c85a:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
  cst_cellular_info.rt_state              = DC_SERVICE_UNAVAIL;
 801c85e:	7213      	strb	r3, [r2, #8]

  /* registers component callback to Data Cache  */
  if (dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info)) == DC_COM_ERROR)
 801c860:	23f4      	movs	r3, #244	; 0xf4
 801c862:	493c      	ldr	r1, [pc, #240]	; (801c954 <CST_cellular_service_start+0x180>)
 801c864:	8809      	ldrh	r1, [r1, #0]
 801c866:	4833      	ldr	r0, [pc, #204]	; (801c934 <CST_cellular_service_start+0x160>)
 801c868:	f005 f862 	bl	8021930 <dc_com_write>
 801c86c:	4606      	mov	r6, r0
 801c86e:	b100      	cbz	r0, 801c872 <CST_cellular_service_start+0x9e>
 801c870:	462e      	mov	r6, r5
  {
    dc_ret = DC_COM_ERROR;
  }

  /* initializes Data Cache NFMC entry  */
  nfmc_info.rt_state = DC_SERVICE_UNAVAIL;
 801c872:	2300      	movs	r3, #0
 801c874:	f88d 3014 	strb.w	r3, [sp, #20]
  if (dc_com_write(&dc_com_db, DC_CELLULAR_NFMC_INFO, (void *)&nfmc_info, sizeof(nfmc_info)) == DC_COM_ERROR)
 801c878:	232c      	movs	r3, #44	; 0x2c
 801c87a:	aa03      	add	r2, sp, #12
 801c87c:	4936      	ldr	r1, [pc, #216]	; (801c958 <CST_cellular_service_start+0x184>)
 801c87e:	8809      	ldrh	r1, [r1, #0]
 801c880:	482c      	ldr	r0, [pc, #176]	; (801c934 <CST_cellular_service_start+0x160>)
 801c882:	f005 f855 	bl	8021930 <dc_com_write>
 801c886:	4605      	mov	r5, r0
 801c888:	b100      	cbz	r0, 801c88c <CST_cellular_service_start+0xb8>
 801c88a:	4635      	mov	r5, r6
  {
    dc_ret = DC_COM_ERROR;
  }

  /* creates and starts cellar service task automaton */
  cst_cellular_service_thread_id = rtosalThreadNew((const rtosal_char_t *)"cellularServiceTask",
 801c88c:	2200      	movs	r2, #0
 801c88e:	9200      	str	r2, [sp, #0]
 801c890:	f44f 7300 	mov.w	r3, #512	; 0x200
 801c894:	4931      	ldr	r1, [pc, #196]	; (801c95c <CST_cellular_service_start+0x188>)
 801c896:	4832      	ldr	r0, [pc, #200]	; (801c960 <CST_cellular_service_start+0x18c>)
 801c898:	f002 fb29 	bl	801eeee <rtosalThreadNew>
 801c89c:	4b31      	ldr	r3, [pc, #196]	; (801c964 <CST_cellular_service_start+0x190>)
 801c89e:	6018      	str	r0, [r3, #0]
                                                   (os_pthread)CST_cellular_service_task, CELLULAR_SERVICE_THREAD_PRIO,
                                                   USED_CELLULAR_SERVICE_THREAD_STACK_SIZE, NULL);

  if (cst_cellular_service_thread_id == NULL)
 801c8a0:	2800      	cmp	r0, #0
 801c8a2:	d039      	beq.n	801c918 <CST_cellular_service_start+0x144>
    (void)stackAnalysis_addStackSizeByHandle(cst_cellular_service_thread_id, USED_CELLULAR_SERVICE_THREAD_STACK_SIZE);
#endif /* USE_STACK_ANALYSIS == 1 */
  }

  /* creates and start modem polling timer */
  cst_polling_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_polling_timer_callback, osTimerPeriodic, NULL);
 801c8a4:	2300      	movs	r3, #0
 801c8a6:	2201      	movs	r2, #1
 801c8a8:	492f      	ldr	r1, [pc, #188]	; (801c968 <CST_cellular_service_start+0x194>)
 801c8aa:	4618      	mov	r0, r3
 801c8ac:	f002 fb75 	bl	801ef9a <rtosalTimerNew>
#if (CST_MODEM_POLLING_PERIOD == 0)
  cst_polling_period = CST_MODEM_POLLING_PERIOD_DEFAULT;
#else
  cst_polling_period = CST_MODEM_POLLING_PERIOD;
#endif /* (CST_MODEM_POLLING_PERIOD == 1) */
  os_ret = rtosalTimerStart(cst_polling_timer_handle, cst_polling_period);
 801c8b0:	f242 7110 	movw	r1, #10000	; 0x2710
 801c8b4:	f002 fb7d 	bl	801efb2 <rtosalTimerStart>
  if (os_ret != osOK)
 801c8b8:	b108      	cbz	r0, 801c8be <CST_cellular_service_start+0xea>
  {
    /* polling timer start fails */
    cs_ret |= (uint32_t)CELLULAR_ERROR;
 801c8ba:	f044 0401 	orr.w	r4, r4, #1
  }

  /* creates timers */

  /* initializes pdn activation timer */
  cst_pdn_activate_retry_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_pdn_activate_retry_timer_callback,
 801c8be:	2300      	movs	r3, #0
 801c8c0:	461a      	mov	r2, r3
 801c8c2:	492a      	ldr	r1, [pc, #168]	; (801c96c <CST_cellular_service_start+0x198>)
 801c8c4:	4618      	mov	r0, r3
 801c8c6:	f002 fb68 	bl	801ef9a <rtosalTimerNew>
 801c8ca:	4b29      	ldr	r3, [pc, #164]	; (801c970 <CST_cellular_service_start+0x19c>)
 801c8cc:	6018      	str	r0, [r3, #0]
                                                       osTimerOnce, NULL);

  /* initializes network monitoring state timer */
  cst_network_status_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_network_status_timer_callback, osTimerOnce,
 801c8ce:	2300      	movs	r3, #0
 801c8d0:	461a      	mov	r2, r3
 801c8d2:	4928      	ldr	r1, [pc, #160]	; (801c974 <CST_cellular_service_start+0x1a0>)
 801c8d4:	4618      	mov	r0, r3
 801c8d6:	f002 fb60 	bl	801ef9a <rtosalTimerNew>
 801c8da:	4b27      	ldr	r3, [pc, #156]	; (801c978 <CST_cellular_service_start+0x1a4>)
 801c8dc:	6018      	str	r0, [r3, #0]
                                                   NULL);

  /* initializes register timer */
  cst_register_retry_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_register_retry_timer_callback, osTimerOnce,
 801c8de:	2300      	movs	r3, #0
 801c8e0:	461a      	mov	r2, r3
 801c8e2:	4926      	ldr	r1, [pc, #152]	; (801c97c <CST_cellular_service_start+0x1a8>)
 801c8e4:	4618      	mov	r0, r3
 801c8e6:	f002 fb58 	bl	801ef9a <rtosalTimerNew>
 801c8ea:	4b25      	ldr	r3, [pc, #148]	; (801c980 <CST_cellular_service_start+0x1ac>)
 801c8ec:	6018      	str	r0, [r3, #0]
                                                   NULL);

  /* initializes FOTA timer */
  cst_fota_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_fota_timer_callback, osTimerOnce, NULL);
 801c8ee:	2300      	movs	r3, #0
 801c8f0:	461a      	mov	r2, r3
 801c8f2:	4924      	ldr	r1, [pc, #144]	; (801c984 <CST_cellular_service_start+0x1b0>)
 801c8f4:	4618      	mov	r0, r3
 801c8f6:	f002 fb50 	bl	801ef9a <rtosalTimerNew>
 801c8fa:	4b23      	ldr	r3, [pc, #140]	; (801c988 <CST_cellular_service_start+0x1b4>)
 801c8fc:	6018      	str	r0, [r3, #0]
  /* initializes low power inactivity timer */
  cst_lp_inactivity_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_lp_inactivity_timer_callback, osTimerOnce,
                                                  NULL);
#endif /* (USE_LOW_POWER == 1) */

  if ((dc_ret != DC_COM_OK) || (cs_ret != 0U))
 801c8fe:	b19d      	cbz	r5, 801c928 <CST_cellular_service_start+0x154>
 801c900:	b9ac      	cbnz	r4, 801c92e <CST_cellular_service_start+0x15a>
  cst_ret = CELLULAR_OK;
 801c902:	2000      	movs	r0, #0
 801c904:	e011      	b.n	801c92a <CST_cellular_service_start+0x156>
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 6, ERROR_WARNING);
 801c906:	2202      	movs	r2, #2
 801c908:	2106      	movs	r1, #6
 801c90a:	2007      	movs	r0, #7
 801c90c:	f001 fc1e 	bl	801e14c <ERROR_Handler>
    cs_ret |= (uint32_t)CELLULAR_ERROR;
 801c910:	2401      	movs	r4, #1
 801c912:	e799      	b.n	801c848 <CST_cellular_service_start+0x74>
    dc_ret = DC_COM_ERROR;
 801c914:	2500      	movs	r5, #0
 801c916:	e79e      	b.n	801c856 <CST_cellular_service_start+0x82>
    cs_ret |= (uint32_t)CELLULAR_ERROR;
 801c918:	f044 0401 	orr.w	r4, r4, #1
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 7, ERROR_FATAL);
 801c91c:	2203      	movs	r2, #3
 801c91e:	2107      	movs	r1, #7
 801c920:	4608      	mov	r0, r1
 801c922:	f001 fc13 	bl	801e14c <ERROR_Handler>
 801c926:	e7bd      	b.n	801c8a4 <CST_cellular_service_start+0xd0>
  {
    /* At least one error occurs during start function */
    cst_ret = CELLULAR_ERROR;
 801c928:	2001      	movs	r0, #1
  }

  return cst_ret;
}
 801c92a:	b00e      	add	sp, #56	; 0x38
 801c92c:	bd70      	pop	{r4, r5, r6, pc}
    cst_ret = CELLULAR_ERROR;
 801c92e:	2001      	movs	r0, #1
 801c930:	e7fb      	b.n	801c92a <CST_cellular_service_start+0x156>
 801c932:	bf00      	nop
 801c934:	200058b0 	.word	0x200058b0
 801c938:	20004160 	.word	0x20004160
 801c93c:	20000232 	.word	0x20000232
 801c940:	20004338 	.word	0x20004338
 801c944:	2000023c 	.word	0x2000023c
 801c948:	200000b0 	.word	0x200000b0
 801c94c:	0801c415 	.word	0x0801c415
 801c950:	2000406c 	.word	0x2000406c
 801c954:	20000236 	.word	0x20000236
 801c958:	20000238 	.word	0x20000238
 801c95c:	0801c5f5 	.word	0x0801c5f5
 801c960:	08034258 	.word	0x08034258
 801c964:	20004300 	.word	0x20004300
 801c968:	0801b0d9 	.word	0x0801b0d9
 801c96c:	0801b065 	.word	0x0801b065
 801c970:	2000432c 	.word	0x2000432c
 801c974:	0801b049 	.word	0x0801b049
 801c978:	20004308 	.word	0x20004308
 801c97c:	0801b1bd 	.word	0x0801b1bd
 801c980:	20004334 	.word	0x20004334
 801c984:	0801b03d 	.word	0x0801b03d
 801c988:	20004304 	.word	0x20004304

0801c98c <cst_convert_sim_socket_type>:
  * @retval CS_SimSlot_t  - sim slot CS enum value
  */
static CS_SimSlot_t  cst_convert_sim_socket_type(dc_cs_sim_slot_type_t sim_slot_value)
{
  CS_SimSlot_t enum_value;
  switch (sim_slot_value)
 801c98c:	2801      	cmp	r0, #1
 801c98e:	d002      	beq.n	801c996 <cst_convert_sim_socket_type+0xa>
 801c990:	2802      	cmp	r0, #2
 801c992:	d000      	beq.n	801c996 <cst_convert_sim_socket_type+0xa>
 801c994:	2000      	movs	r0, #0
    default:
      enum_value = CS_MODEM_SIM_SOCKET_0;
      break;
  }
  return enum_value;
}
 801c996:	4770      	bx	lr

0801c998 <cst_modulo64>:

  tmp_l = 0U;
  div_m = div;
  div_l = 0U;

  if (div_m != 0U)
 801c998:	b320      	cbz	r0, 801c9e4 <cst_modulo64+0x4c>
  {
    tmp_m = val_m % div_m;
 801c99a:	fbb1 f3f0 	udiv	r3, r1, r0
 801c99e:	fb00 1113 	mls	r1, r0, r3, r1
  div_m = div;
 801c9a2:	4603      	mov	r3, r0
  div_l = 0U;
 801c9a4:	f04f 0c00 	mov.w	ip, #0

    tmp_l = val_l;

    while (tmp_m > 0U)
 801c9a8:	e00d      	b.n	801c9c6 <cst_modulo64+0x2e>
    {
      if ((div_m > tmp_m) || ((div_m == tmp_m) && (div_l > tmp_l)))
 801c9aa:	4594      	cmp	ip, r2
 801c9ac:	d803      	bhi.n	801c9b6 <cst_modulo64+0x1e>
 801c9ae:	e00e      	b.n	801c9ce <cst_modulo64+0x36>
        tmp_m--;
        tmp_m = tmp_m - div_m;
      }
      else
      {
        tmp_m = tmp_m - div_m;
 801c9b0:	1ac9      	subs	r1, r1, r3
        tmp_l = tmp_l - div_l;
 801c9b2:	eba2 020c 	sub.w	r2, r2, ip
      }

      div_l = div_l >> 1;
 801c9b6:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
      if ((div_m & 1U) == 1U)
 801c9ba:	f013 0f01 	tst.w	r3, #1
 801c9be:	d001      	beq.n	801c9c4 <cst_modulo64+0x2c>
      {
        div_l = div_l | 0x80000000U;
 801c9c0:	f04c 4c00 	orr.w	ip, ip, #2147483648	; 0x80000000
      }
      div_m = div_m >> 1U;
 801c9c4:	085b      	lsrs	r3, r3, #1
    while (tmp_m > 0U)
 801c9c6:	b149      	cbz	r1, 801c9dc <cst_modulo64+0x44>
      if ((div_m > tmp_m) || ((div_m == tmp_m) && (div_l > tmp_l)))
 801c9c8:	428b      	cmp	r3, r1
 801c9ca:	d8f4      	bhi.n	801c9b6 <cst_modulo64+0x1e>
 801c9cc:	d0ed      	beq.n	801c9aa <cst_modulo64+0x12>
      else if (div_l > tmp_l)
 801c9ce:	4594      	cmp	ip, r2
 801c9d0:	d9ee      	bls.n	801c9b0 <cst_modulo64+0x18>
        tmp_l = tmp_l - div_l;
 801c9d2:	eba2 020c 	sub.w	r2, r2, ip
        tmp_m--;
 801c9d6:	3901      	subs	r1, #1
        tmp_m = tmp_m - div_m;
 801c9d8:	1ac9      	subs	r1, r1, r3
 801c9da:	e7ec      	b.n	801c9b6 <cst_modulo64+0x1e>
    }
    tmp_l = tmp_l % div;
 801c9dc:	fbb2 f3f0 	udiv	r3, r2, r0
 801c9e0:	fb00 2013 	mls	r0, r0, r3, r2
  }
  return tmp_l;
}
 801c9e4:	4770      	bx	lr
	...

0801c9e8 <CST_location_info_callback>:
  * @brief  location info callback callback
  * @param  -
  * @retval -
  */
static void CST_location_info_callback(void)
{
 801c9e8:	b538      	push	{r3, r4, r5, lr}
  /* Not used yet: reserved for future usage */
  PRINT_CELLULAR_SERVICE("CST_location_info_callback\n\r")
 801c9ea:	4c10      	ldr	r4, [pc, #64]	; (801ca2c <CST_location_info_callback+0x44>)
 801c9ec:	4d10      	ldr	r5, [pc, #64]	; (801ca30 <CST_location_info_callback+0x48>)
 801c9ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801c9f0:	6020      	str	r0, [r4, #0]
 801c9f2:	6061      	str	r1, [r4, #4]
 801c9f4:	60a2      	str	r2, [r4, #8]
 801c9f6:	60e3      	str	r3, [r4, #12]
 801c9f8:	cd07      	ldmia	r5!, {r0, r1, r2}
 801c9fa:	6120      	str	r0, [r4, #16]
 801c9fc:	6161      	str	r1, [r4, #20]
 801c9fe:	61a2      	str	r2, [r4, #24]
 801ca00:	782b      	ldrb	r3, [r5, #0]
 801ca02:	7723      	strb	r3, [r4, #28]
 801ca04:	4620      	mov	r0, r4
 801ca06:	f002 fb84 	bl	801f112 <crs_strlen>
 801ca0a:	b283      	uxth	r3, r0
 801ca0c:	4622      	mov	r2, r4
 801ca0e:	2101      	movs	r1, #1
 801ca10:	2007      	movs	r0, #7
 801ca12:	f002 fbc1 	bl	801f198 <traceIF_itmPrint>
 801ca16:	4620      	mov	r0, r4
 801ca18:	f002 fb7b 	bl	801f112 <crs_strlen>
 801ca1c:	b283      	uxth	r3, r0
 801ca1e:	4622      	mov	r2, r4
 801ca20:	2101      	movs	r1, #1
 801ca22:	2007      	movs	r0, #7
 801ca24:	f002 fbda 	bl	801f1dc <traceIF_uartPrint>
}
 801ca28:	bd38      	pop	{r3, r4, r5, pc}
 801ca2a:	bf00      	nop
 801ca2c:	20004ddc 	.word	0x20004ddc
 801ca30:	08034754 	.word	0x08034754

0801ca34 <CST_fill_nfmc_tempo>:
  * @param  imsi_high  - high IMSI 32bits value
  * @param  imsi_low   - low IMSI  32bits value
  * @retval -
  */
static void CST_fill_nfmc_tempo(uint32_t imsi_high, uint32_t imsi_low)
{
 801ca34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801ca38:	b08c      	sub	sp, #48	; 0x30
  uint32_t i;
  dc_nfmc_info_t nfmc_info;

  if (cst_cellular_params.nfmc_active != 0U)
 801ca3a:	4b2b      	ldr	r3, [pc, #172]	; (801cae8 <CST_fill_nfmc_tempo+0xb4>)
 801ca3c:	f893 317c 	ldrb.w	r3, [r3, #380]	; 0x17c
 801ca40:	2b00      	cmp	r3, #0
 801ca42:	d049      	beq.n	801cad8 <CST_fill_nfmc_tempo+0xa4>
 801ca44:	4680      	mov	r8, r0
 801ca46:	460f      	mov	r7, r1
  {
    /* NFMC active : NFMC tempos calculation */
    cst_nfmc_context.active = true;
 801ca48:	2301      	movs	r3, #1
 801ca4a:	4a28      	ldr	r2, [pc, #160]	; (801caec <CST_fill_nfmc_tempo+0xb8>)
 801ca4c:	7013      	strb	r3, [r2, #0]
    nfmc_info.activate = 1U;
 801ca4e:	9304      	str	r3, [sp, #16]
    for (i = 0U; i < CST_NFMC_TEMPO_NB; i++)
 801ca50:	2400      	movs	r4, #0
 801ca52:	e029      	b.n	801caa8 <CST_fill_nfmc_tempo+0x74>
      uint32_t temp_value32;

      /* calculation of NFMC tempo */
      if (cst_cellular_params.nfmc_value[i] != 0U)
      {
        temp_value32 = cst_modulo64(cst_cellular_params.nfmc_value[i], imsi_high, imsi_low);
 801ca54:	463a      	mov	r2, r7
 801ca56:	4641      	mov	r1, r8
 801ca58:	4630      	mov	r0, r6
 801ca5a:	f7ff ff9d 	bl	801c998 <cst_modulo64>
 801ca5e:	4603      	mov	r3, r0
      }
      else
      {
        temp_value32 = imsi_low;  /* parameter value == 0 => value set to imsi_low */
      }
      temp_value32 = temp_value32 + cst_cellular_params.nfmc_value[i];
 801ca60:	4433      	add	r3, r6
      cst_nfmc_context.tempo[i] = (0xffffffffU & temp_value32);
 801ca62:	4a22      	ldr	r2, [pc, #136]	; (801caec <CST_fill_nfmc_tempo+0xb8>)
 801ca64:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 801ca68:	6053      	str	r3, [r2, #4]

      nfmc_info.tempo[i] = cst_nfmc_context.tempo[i];
 801ca6a:	1d22      	adds	r2, r4, #4
 801ca6c:	a90c      	add	r1, sp, #48	; 0x30
 801ca6e:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801ca72:	f842 3c2c 	str.w	r3, [r2, #-44]
      PRINT_CELLULAR_SERVICE("VALUE/TEMPO %ld/%ld\n\r",  cst_cellular_params.nfmc_value[i], cst_nfmc_context.tempo[i])
 801ca76:	4d1e      	ldr	r5, [pc, #120]	; (801caf0 <CST_fill_nfmc_tempo+0xbc>)
 801ca78:	4632      	mov	r2, r6
 801ca7a:	491e      	ldr	r1, [pc, #120]	; (801caf4 <CST_fill_nfmc_tempo+0xc0>)
 801ca7c:	4628      	mov	r0, r5
 801ca7e:	f009 f8f7 	bl	8025c70 <sprintf>
 801ca82:	4628      	mov	r0, r5
 801ca84:	f002 fb45 	bl	801f112 <crs_strlen>
 801ca88:	b283      	uxth	r3, r0
 801ca8a:	462a      	mov	r2, r5
 801ca8c:	2101      	movs	r1, #1
 801ca8e:	2007      	movs	r0, #7
 801ca90:	f002 fb82 	bl	801f198 <traceIF_itmPrint>
 801ca94:	4628      	mov	r0, r5
 801ca96:	f002 fb3c 	bl	801f112 <crs_strlen>
 801ca9a:	b283      	uxth	r3, r0
 801ca9c:	462a      	mov	r2, r5
 801ca9e:	2101      	movs	r1, #1
 801caa0:	2007      	movs	r0, #7
 801caa2:	f002 fb9b 	bl	801f1dc <traceIF_uartPrint>
    for (i = 0U; i < CST_NFMC_TEMPO_NB; i++)
 801caa6:	3401      	adds	r4, #1
 801caa8:	2c06      	cmp	r4, #6
 801caaa:	d808      	bhi.n	801cabe <CST_fill_nfmc_tempo+0x8a>
      if (cst_cellular_params.nfmc_value[i] != 0U)
 801caac:	f104 0360 	add.w	r3, r4, #96	; 0x60
 801cab0:	4a0d      	ldr	r2, [pc, #52]	; (801cae8 <CST_fill_nfmc_tempo+0xb4>)
 801cab2:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
 801cab6:	2e00      	cmp	r6, #0
 801cab8:	d1cc      	bne.n	801ca54 <CST_fill_nfmc_tempo+0x20>
        temp_value32 = imsi_low;  /* parameter value == 0 => value set to imsi_low */
 801caba:	463b      	mov	r3, r7
 801cabc:	e7d0      	b.n	801ca60 <CST_fill_nfmc_tempo+0x2c>
    }
    nfmc_info.rt_state = DC_SERVICE_ON;
 801cabe:	2307      	movs	r3, #7
 801cac0:	f88d 300c 	strb.w	r3, [sp, #12]
    /* NFMC not active */
    nfmc_info.activate = 0U;
    nfmc_info.rt_state = DC_SERVICE_OFF;
    cst_nfmc_context.active = false;
  }
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_NFMC_INFO, (void *)&nfmc_info, sizeof(nfmc_info));
 801cac4:	232c      	movs	r3, #44	; 0x2c
 801cac6:	aa01      	add	r2, sp, #4
 801cac8:	490b      	ldr	r1, [pc, #44]	; (801caf8 <CST_fill_nfmc_tempo+0xc4>)
 801caca:	8809      	ldrh	r1, [r1, #0]
 801cacc:	480b      	ldr	r0, [pc, #44]	; (801cafc <CST_fill_nfmc_tempo+0xc8>)
 801cace:	f004 ff2f 	bl	8021930 <dc_com_write>
}
 801cad2:	b00c      	add	sp, #48	; 0x30
 801cad4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    nfmc_info.activate = 0U;
 801cad8:	2300      	movs	r3, #0
 801cada:	9304      	str	r3, [sp, #16]
    nfmc_info.rt_state = DC_SERVICE_OFF;
 801cadc:	2203      	movs	r2, #3
 801cade:	f88d 200c 	strb.w	r2, [sp, #12]
    cst_nfmc_context.active = false;
 801cae2:	4a02      	ldr	r2, [pc, #8]	; (801caec <CST_fill_nfmc_tempo+0xb8>)
 801cae4:	7013      	strb	r3, [r2, #0]
 801cae6:	e7ed      	b.n	801cac4 <CST_fill_nfmc_tempo+0x90>
 801cae8:	20004160 	.word	0x20004160
 801caec:	2000430c 	.word	0x2000430c
 801caf0:	20004ddc 	.word	0x20004ddc
 801caf4:	08034774 	.word	0x08034774
 801caf8:	20000238 	.word	0x20000238
 801cafc:	200058b0 	.word	0x200058b0

0801cb00 <CST_fail_setting>:
  * @brief  setting FAIL mode in DC
  * @param  -
  * @retval -
  */
static void CST_fail_setting(void)
{
 801cb00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801cb04:	f8df 8058 	ldr.w	r8, [pc, #88]	; 801cb60 <CST_fail_setting+0x60>
 801cb08:	4e11      	ldr	r6, [pc, #68]	; (801cb50 <CST_fail_setting+0x50>)
 801cb0a:	4c12      	ldr	r4, [pc, #72]	; (801cb54 <CST_fail_setting+0x54>)
 801cb0c:	23f4      	movs	r3, #244	; 0xf4
 801cb0e:	4632      	mov	r2, r6
 801cb10:	f8b8 1000 	ldrh.w	r1, [r8]
 801cb14:	4620      	mov	r0, r4
 801cb16:	f004 ff57 	bl	80219c8 <dc_com_read>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801cb1a:	4f0f      	ldr	r7, [pc, #60]	; (801cb58 <CST_fail_setting+0x58>)
 801cb1c:	4d0f      	ldr	r5, [pc, #60]	; (801cb5c <CST_fail_setting+0x5c>)
 801cb1e:	2310      	movs	r3, #16
 801cb20:	462a      	mov	r2, r5
 801cb22:	8839      	ldrh	r1, [r7, #0]
 801cb24:	4620      	mov	r0, r4
 801cb26:	f004 ff4f 	bl	80219c8 <dc_com_read>
                    sizeof(dc_cellular_data_info_t));
  cst_cellular_info.rt_state      = DC_SERVICE_FAIL;
 801cb2a:	2308      	movs	r3, #8
 801cb2c:	7233      	strb	r3, [r6, #8]
  cst_cellular_data_info.rt_state = DC_SERVICE_FAIL;
 801cb2e:	722b      	strb	r3, [r5, #8]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801cb30:	23f4      	movs	r3, #244	; 0xf4
 801cb32:	4632      	mov	r2, r6
 801cb34:	f8b8 1000 	ldrh.w	r1, [r8]
 801cb38:	4620      	mov	r0, r4
 801cb3a:	f004 fef9 	bl	8021930 <dc_com_write>
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801cb3e:	2310      	movs	r3, #16
 801cb40:	462a      	mov	r2, r5
 801cb42:	8839      	ldrh	r1, [r7, #0]
 801cb44:	4620      	mov	r0, r4
 801cb46:	f004 fef3 	bl	8021930 <dc_com_write>
                     sizeof(dc_cellular_data_info_t));
}
 801cb4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801cb4e:	bf00      	nop
 801cb50:	2000406c 	.word	0x2000406c
 801cb54:	200058b0 	.word	0x200058b0
 801cb58:	20000234 	.word	0x20000234
 801cb5c:	2000405c 	.word	0x2000405c
 801cb60:	20000236 	.word	0x20000236

0801cb64 <CST_network_reg_callback>:
{
 801cb64:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("==================================CST_network_reg_callback\n\r")
 801cb66:	4c16      	ldr	r4, [pc, #88]	; (801cbc0 <CST_network_reg_callback+0x5c>)
 801cb68:	4d16      	ldr	r5, [pc, #88]	; (801cbc4 <CST_network_reg_callback+0x60>)
 801cb6a:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801cb6e:	46a4      	mov	ip, r4
 801cb70:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801cb74:	6028      	str	r0, [r5, #0]
 801cb76:	6069      	str	r1, [r5, #4]
 801cb78:	60aa      	str	r2, [r5, #8]
 801cb7a:	60eb      	str	r3, [r5, #12]
 801cb7c:	4664      	mov	r4, ip
 801cb7e:	3510      	adds	r5, #16
 801cb80:	45f4      	cmp	ip, lr
 801cb82:	d1f4      	bne.n	801cb6e <CST_network_reg_callback+0xa>
 801cb84:	cc07      	ldmia	r4!, {r0, r1, r2}
 801cb86:	6028      	str	r0, [r5, #0]
 801cb88:	6069      	str	r1, [r5, #4]
 801cb8a:	60aa      	str	r2, [r5, #8]
 801cb8c:	7823      	ldrb	r3, [r4, #0]
 801cb8e:	732b      	strb	r3, [r5, #12]
 801cb90:	4c0c      	ldr	r4, [pc, #48]	; (801cbc4 <CST_network_reg_callback+0x60>)
 801cb92:	4620      	mov	r0, r4
 801cb94:	f002 fabd 	bl	801f112 <crs_strlen>
 801cb98:	b283      	uxth	r3, r0
 801cb9a:	4622      	mov	r2, r4
 801cb9c:	2101      	movs	r1, #1
 801cb9e:	2007      	movs	r0, #7
 801cba0:	f002 fafa 	bl	801f198 <traceIF_itmPrint>
 801cba4:	4620      	mov	r0, r4
 801cba6:	f002 fab4 	bl	801f112 <crs_strlen>
 801cbaa:	b283      	uxth	r3, r0
 801cbac:	4622      	mov	r2, r4
 801cbae:	2101      	movs	r1, #1
 801cbb0:	2007      	movs	r0, #7
 801cbb2:	f002 fb13 	bl	801f1dc <traceIF_uartPrint>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_CALLBACK_EVENT);
 801cbb6:	2113      	movs	r1, #19
 801cbb8:	2000      	movs	r0, #0
 801cbba:	f7fe fa15 	bl	801afe8 <CST_send_message>
}
 801cbbe:	bd38      	pop	{r3, r4, r5, pc}
 801cbc0:	0803478c 	.word	0x0803478c
 801cbc4:	20004ddc 	.word	0x20004ddc

0801cbc8 <CST_modem_event_callback>:
{
 801cbc8:	b570      	push	{r4, r5, r6, lr}
 801cbca:	4604      	mov	r4, r0
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_BOOT) != 0U)
 801cbcc:	f010 0f01 	tst.w	r0, #1
 801cbd0:	d109      	bne.n	801cbe6 <CST_modem_event_callback+0x1e>
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_POWER_DOWN) != 0U)
 801cbd2:	f014 0f02 	tst.w	r4, #2
 801cbd6:	d10b      	bne.n	801cbf0 <CST_modem_event_callback+0x28>
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_FOTA_START) != 0U)
 801cbd8:	f014 0f04 	tst.w	r4, #4
 801cbdc:	d12f      	bne.n	801cc3e <CST_modem_event_callback+0x76>
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_FOTA_END) != 0U)
 801cbde:	f014 0f08 	tst.w	r4, #8
 801cbe2:	d131      	bne.n	801cc48 <CST_modem_event_callback+0x80>
}
 801cbe4:	bd70      	pop	{r4, r5, r6, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_REBOOT_MODEM_EVENT);
 801cbe6:	2111      	movs	r1, #17
 801cbe8:	2000      	movs	r0, #0
 801cbea:	f7fe f9fd 	bl	801afe8 <CST_send_message>
 801cbee:	e7f0      	b.n	801cbd2 <CST_modem_event_callback+0xa>
    PRINT_CELLULAR_SERVICE("Modem event received:  CS_MDMEVENT_POWER_DOWN\n\r")
 801cbf0:	4e18      	ldr	r6, [pc, #96]	; (801cc54 <CST_modem_event_callback+0x8c>)
 801cbf2:	4d19      	ldr	r5, [pc, #100]	; (801cc58 <CST_modem_event_callback+0x90>)
 801cbf4:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 801cbf8:	46b4      	mov	ip, r6
 801cbfa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801cbfe:	6028      	str	r0, [r5, #0]
 801cc00:	6069      	str	r1, [r5, #4]
 801cc02:	60aa      	str	r2, [r5, #8]
 801cc04:	60eb      	str	r3, [r5, #12]
 801cc06:	4666      	mov	r6, ip
 801cc08:	3510      	adds	r5, #16
 801cc0a:	45f4      	cmp	ip, lr
 801cc0c:	d1f4      	bne.n	801cbf8 <CST_modem_event_callback+0x30>
 801cc0e:	4d12      	ldr	r5, [pc, #72]	; (801cc58 <CST_modem_event_callback+0x90>)
 801cc10:	4628      	mov	r0, r5
 801cc12:	f002 fa7e 	bl	801f112 <crs_strlen>
 801cc16:	b283      	uxth	r3, r0
 801cc18:	462a      	mov	r2, r5
 801cc1a:	2101      	movs	r1, #1
 801cc1c:	2007      	movs	r0, #7
 801cc1e:	f002 fabb 	bl	801f198 <traceIF_itmPrint>
 801cc22:	4628      	mov	r0, r5
 801cc24:	f002 fa75 	bl	801f112 <crs_strlen>
 801cc28:	b283      	uxth	r3, r0
 801cc2a:	462a      	mov	r2, r5
 801cc2c:	2101      	movs	r1, #1
 801cc2e:	2007      	movs	r0, #7
 801cc30:	f002 fad4 	bl	801f1dc <traceIF_uartPrint>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_POWER_DOWN_EVENT);
 801cc34:	211b      	movs	r1, #27
 801cc36:	2000      	movs	r0, #0
 801cc38:	f7fe f9d6 	bl	801afe8 <CST_send_message>
 801cc3c:	e7cc      	b.n	801cbd8 <CST_modem_event_callback+0x10>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_FOTA_START_EVENT);
 801cc3e:	2115      	movs	r1, #21
 801cc40:	2000      	movs	r0, #0
 801cc42:	f7fe f9d1 	bl	801afe8 <CST_send_message>
 801cc46:	e7ca      	b.n	801cbde <CST_modem_event_callback+0x16>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_FOTA_END_EVENT);
 801cc48:	2116      	movs	r1, #22
 801cc4a:	2000      	movs	r0, #0
 801cc4c:	f7fe f9cc 	bl	801afe8 <CST_send_message>
}
 801cc50:	e7c8      	b.n	801cbe4 <CST_modem_event_callback+0x1c>
 801cc52:	bf00      	nop
 801cc54:	080347cc 	.word	0x080347cc
 801cc58:	20004ddc 	.word	0x20004ddc

0801cc5c <CST_get_device_all_infos>:
{
 801cc5c:	b570      	push	{r4, r5, r6, lr}
 801cc5e:	b082      	sub	sp, #8
 801cc60:	4605      	mov	r5, r0
  (void)memset((void *)&cst_device_info, 0, sizeof(CS_DeviceInfo_t));
 801cc62:	4cd5      	ldr	r4, [pc, #852]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801cc64:	f44f 7281 	mov.w	r2, #258	; 0x102
 801cc68:	2100      	movs	r1, #0
 801cc6a:	4620      	mov	r0, r4
 801cc6c:	f009 f873 	bl	8025d56 <memset>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801cc70:	23f4      	movs	r3, #244	; 0xf4
 801cc72:	4ad2      	ldr	r2, [pc, #840]	; (801cfbc <CST_get_device_all_infos+0x360>)
 801cc74:	49d2      	ldr	r1, [pc, #840]	; (801cfc0 <CST_get_device_all_infos+0x364>)
 801cc76:	8809      	ldrh	r1, [r1, #0]
 801cc78:	48d2      	ldr	r0, [pc, #840]	; (801cfc4 <CST_get_device_all_infos+0x368>)
 801cc7a:	f004 fea5 	bl	80219c8 <dc_com_read>
  cst_device_info.field_requested = CS_DIF_IMEI_PRESENT;
 801cc7e:	2301      	movs	r3, #1
 801cc80:	8023      	strh	r3, [r4, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801cc82:	4620      	mov	r0, r4
 801cc84:	f7fd fe9a 	bl	801a9bc <osCDS_get_device_info>
 801cc88:	2800      	cmp	r0, #0
 801cc8a:	f040 8177 	bne.w	801cf7c <CST_get_device_all_infos+0x320>
    (void)memcpy(cst_cellular_info.imei, cst_device_info.u.imei, DC_MAX_SIZE_IMEI - 1U);
 801cc8e:	4ece      	ldr	r6, [pc, #824]	; (801cfc8 <CST_get_device_all_infos+0x36c>)
 801cc90:	46b4      	mov	ip, r6
 801cc92:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801cc96:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801cc9a:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801cc9e:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801cca2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cca6:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801ccaa:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801ccae:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801ccb2:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801ccb6:	8be2      	ldrh	r2, [r4, #30]
 801ccb8:	f894 3020 	ldrb.w	r3, [r4, #32]
 801ccbc:	f8ac 2000 	strh.w	r2, [ip]
 801ccc0:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.imei[DC_MAX_SIZE_IMEI - 1U] = 0U;     /* to avoid a non null terminated string */
 801ccc4:	2300      	movs	r3, #0
 801ccc6:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -IMEI: %s\n\r", cst_device_info.u.imei)
 801ccc8:	4ec0      	ldr	r6, [pc, #768]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801ccca:	1ca2      	adds	r2, r4, #2
 801cccc:	49c0      	ldr	r1, [pc, #768]	; (801cfd0 <CST_get_device_all_infos+0x374>)
 801ccce:	4630      	mov	r0, r6
 801ccd0:	f008 ffce 	bl	8025c70 <sprintf>
 801ccd4:	4630      	mov	r0, r6
 801ccd6:	f002 fa1c 	bl	801f112 <crs_strlen>
 801ccda:	b283      	uxth	r3, r0
 801ccdc:	4632      	mov	r2, r6
 801ccde:	2101      	movs	r1, #1
 801cce0:	2007      	movs	r0, #7
 801cce2:	f002 fa59 	bl	801f198 <traceIF_itmPrint>
 801cce6:	4630      	mov	r0, r6
 801cce8:	f002 fa13 	bl	801f112 <crs_strlen>
 801ccec:	b283      	uxth	r3, r0
 801ccee:	4632      	mov	r2, r6
 801ccf0:	2101      	movs	r1, #1
 801ccf2:	2007      	movs	r0, #7
 801ccf4:	f002 fa72 	bl	801f1dc <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_MANUF_NAME_PRESENT;
 801ccf8:	48af      	ldr	r0, [pc, #700]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801ccfa:	2302      	movs	r3, #2
 801ccfc:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801ccfe:	f7fd fe5d 	bl	801a9bc <osCDS_get_device_info>
 801cd02:	2800      	cmp	r0, #0
 801cd04:	f040 817c 	bne.w	801d000 <CST_get_device_all_infos+0x3a4>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.manufacturer_name,
 801cd08:	4eb2      	ldr	r6, [pc, #712]	; (801cfd4 <CST_get_device_all_infos+0x378>)
 801cd0a:	4cab      	ldr	r4, [pc, #684]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801cd0c:	46b4      	mov	ip, r6
 801cd0e:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801cd12:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801cd16:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801cd1a:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801cd1e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cd22:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801cd26:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801cd2a:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801cd2e:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cd32:	8be2      	ldrh	r2, [r4, #30]
 801cd34:	f894 3020 	ldrb.w	r3, [r4, #32]
 801cd38:	f8ac 2000 	strh.w	r2, [ip]
 801cd3c:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.manufacturer_name[DC_MAX_SIZE_MANUFACT_NAME - 1U] = 0U;
 801cd40:	2300      	movs	r3, #0
 801cd42:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -MANUFACTURER: %s\n\r", cst_device_info.u.manufacturer_name)
 801cd44:	4ea1      	ldr	r6, [pc, #644]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801cd46:	1ca2      	adds	r2, r4, #2
 801cd48:	49a3      	ldr	r1, [pc, #652]	; (801cfd8 <CST_get_device_all_infos+0x37c>)
 801cd4a:	4630      	mov	r0, r6
 801cd4c:	f008 ff90 	bl	8025c70 <sprintf>
 801cd50:	4630      	mov	r0, r6
 801cd52:	f002 f9de 	bl	801f112 <crs_strlen>
 801cd56:	b283      	uxth	r3, r0
 801cd58:	4632      	mov	r2, r6
 801cd5a:	2101      	movs	r1, #1
 801cd5c:	2007      	movs	r0, #7
 801cd5e:	f002 fa1b 	bl	801f198 <traceIF_itmPrint>
 801cd62:	4630      	mov	r0, r6
 801cd64:	f002 f9d5 	bl	801f112 <crs_strlen>
 801cd68:	b283      	uxth	r3, r0
 801cd6a:	4632      	mov	r2, r6
 801cd6c:	2101      	movs	r1, #1
 801cd6e:	2007      	movs	r0, #7
 801cd70:	f002 fa34 	bl	801f1dc <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_MODEL_PRESENT;
 801cd74:	4890      	ldr	r0, [pc, #576]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801cd76:	2304      	movs	r3, #4
 801cd78:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801cd7a:	f7fd fe1f 	bl	801a9bc <osCDS_get_device_info>
 801cd7e:	2800      	cmp	r0, #0
 801cd80:	f040 8161 	bne.w	801d046 <CST_get_device_all_infos+0x3ea>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.model,
 801cd84:	4e95      	ldr	r6, [pc, #596]	; (801cfdc <CST_get_device_all_infos+0x380>)
 801cd86:	4c8c      	ldr	r4, [pc, #560]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801cd88:	46b4      	mov	ip, r6
 801cd8a:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801cd8e:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801cd92:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801cd96:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801cd9a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cd9e:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801cda2:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801cda6:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801cdaa:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cdae:	8be2      	ldrh	r2, [r4, #30]
 801cdb0:	f894 3020 	ldrb.w	r3, [r4, #32]
 801cdb4:	f8ac 2000 	strh.w	r2, [ip]
 801cdb8:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.model[DC_MAX_SIZE_MODEL - 1U] = 0U; /* to avoid a non null terminated string */
 801cdbc:	2300      	movs	r3, #0
 801cdbe:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -MODEL: %s\n\r", cst_device_info.u.model)
 801cdc0:	4e82      	ldr	r6, [pc, #520]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801cdc2:	1ca2      	adds	r2, r4, #2
 801cdc4:	4986      	ldr	r1, [pc, #536]	; (801cfe0 <CST_get_device_all_infos+0x384>)
 801cdc6:	4630      	mov	r0, r6
 801cdc8:	f008 ff52 	bl	8025c70 <sprintf>
 801cdcc:	4630      	mov	r0, r6
 801cdce:	f002 f9a0 	bl	801f112 <crs_strlen>
 801cdd2:	b283      	uxth	r3, r0
 801cdd4:	4632      	mov	r2, r6
 801cdd6:	2101      	movs	r1, #1
 801cdd8:	2007      	movs	r0, #7
 801cdda:	f002 f9dd 	bl	801f198 <traceIF_itmPrint>
 801cdde:	4630      	mov	r0, r6
 801cde0:	f002 f997 	bl	801f112 <crs_strlen>
 801cde4:	b283      	uxth	r3, r0
 801cde6:	4632      	mov	r2, r6
 801cde8:	2101      	movs	r1, #1
 801cdea:	2007      	movs	r0, #7
 801cdec:	f002 f9f6 	bl	801f1dc <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_REV_PRESENT;
 801cdf0:	4871      	ldr	r0, [pc, #452]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801cdf2:	2308      	movs	r3, #8
 801cdf4:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801cdf6:	f7fd fde1 	bl	801a9bc <osCDS_get_device_info>
 801cdfa:	2800      	cmp	r0, #0
 801cdfc:	f040 8142 	bne.w	801d084 <CST_get_device_all_infos+0x428>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.revision,
 801ce00:	4e78      	ldr	r6, [pc, #480]	; (801cfe4 <CST_get_device_all_infos+0x388>)
 801ce02:	4c6d      	ldr	r4, [pc, #436]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801ce04:	46b4      	mov	ip, r6
 801ce06:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801ce0a:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801ce0e:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801ce12:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801ce16:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801ce1a:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801ce1e:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801ce22:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801ce26:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801ce2a:	8be2      	ldrh	r2, [r4, #30]
 801ce2c:	f894 3020 	ldrb.w	r3, [r4, #32]
 801ce30:	f8ac 2000 	strh.w	r2, [ip]
 801ce34:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.revision[DC_MAX_SIZE_REV - 1U] = 0U; /* to avoid a non null terminated string */
 801ce38:	2300      	movs	r3, #0
 801ce3a:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -REVISION: %s\n\r", cst_device_info.u.revision)
 801ce3c:	4e63      	ldr	r6, [pc, #396]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801ce3e:	1ca2      	adds	r2, r4, #2
 801ce40:	4969      	ldr	r1, [pc, #420]	; (801cfe8 <CST_get_device_all_infos+0x38c>)
 801ce42:	4630      	mov	r0, r6
 801ce44:	f008 ff14 	bl	8025c70 <sprintf>
 801ce48:	4630      	mov	r0, r6
 801ce4a:	f002 f962 	bl	801f112 <crs_strlen>
 801ce4e:	b283      	uxth	r3, r0
 801ce50:	4632      	mov	r2, r6
 801ce52:	2101      	movs	r1, #1
 801ce54:	2007      	movs	r0, #7
 801ce56:	f002 f99f 	bl	801f198 <traceIF_itmPrint>
 801ce5a:	4630      	mov	r0, r6
 801ce5c:	f002 f959 	bl	801f112 <crs_strlen>
 801ce60:	b283      	uxth	r3, r0
 801ce62:	4632      	mov	r2, r6
 801ce64:	2101      	movs	r1, #1
 801ce66:	2007      	movs	r0, #7
 801ce68:	f002 f9b8 	bl	801f1dc <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_SN_PRESENT;
 801ce6c:	4852      	ldr	r0, [pc, #328]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801ce6e:	2310      	movs	r3, #16
 801ce70:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801ce72:	f7fd fda3 	bl	801a9bc <osCDS_get_device_info>
 801ce76:	2800      	cmp	r0, #0
 801ce78:	f040 8124 	bne.w	801d0c4 <CST_get_device_all_infos+0x468>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.serial_number,
 801ce7c:	4e5b      	ldr	r6, [pc, #364]	; (801cfec <CST_get_device_all_infos+0x390>)
 801ce7e:	4c4e      	ldr	r4, [pc, #312]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801ce80:	46b4      	mov	ip, r6
 801ce82:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801ce86:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801ce8a:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801ce8e:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801ce92:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801ce96:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801ce9a:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801ce9e:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801cea2:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cea6:	8be2      	ldrh	r2, [r4, #30]
 801cea8:	f894 3020 	ldrb.w	r3, [r4, #32]
 801ceac:	f8ac 2000 	strh.w	r2, [ip]
 801ceb0:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.serial_number[DC_MAX_SIZE_SN - 1U] = 0U; /* to avoid a non null terminated string */
 801ceb4:	2300      	movs	r3, #0
 801ceb6:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -SERIAL NBR: %s\n\r", cst_device_info.u.serial_number)
 801ceb8:	4e44      	ldr	r6, [pc, #272]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801ceba:	1ca2      	adds	r2, r4, #2
 801cebc:	494c      	ldr	r1, [pc, #304]	; (801cff0 <CST_get_device_all_infos+0x394>)
 801cebe:	4630      	mov	r0, r6
 801cec0:	f008 fed6 	bl	8025c70 <sprintf>
 801cec4:	4630      	mov	r0, r6
 801cec6:	f002 f924 	bl	801f112 <crs_strlen>
 801ceca:	b283      	uxth	r3, r0
 801cecc:	4632      	mov	r2, r6
 801cece:	2101      	movs	r1, #1
 801ced0:	2007      	movs	r0, #7
 801ced2:	f002 f961 	bl	801f198 <traceIF_itmPrint>
 801ced6:	4630      	mov	r0, r6
 801ced8:	f002 f91b 	bl	801f112 <crs_strlen>
 801cedc:	b283      	uxth	r3, r0
 801cede:	4632      	mov	r2, r6
 801cee0:	2101      	movs	r1, #1
 801cee2:	2007      	movs	r0, #7
 801cee4:	f002 f97a 	bl	801f1dc <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_ICCID_PRESENT;
 801cee8:	4833      	ldr	r0, [pc, #204]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801ceea:	2380      	movs	r3, #128	; 0x80
 801ceec:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801ceee:	f7fd fd65 	bl	801a9bc <osCDS_get_device_info>
 801cef2:	2800      	cmp	r0, #0
 801cef4:	f040 8108 	bne.w	801d108 <CST_get_device_all_infos+0x4ac>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.iccid,
 801cef8:	4e3e      	ldr	r6, [pc, #248]	; (801cff4 <CST_get_device_all_infos+0x398>)
 801cefa:	4c2f      	ldr	r4, [pc, #188]	; (801cfb8 <CST_get_device_all_infos+0x35c>)
 801cefc:	46b4      	mov	ip, r6
 801cefe:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801cf02:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801cf06:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801cf0a:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801cf0e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cf12:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801cf16:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801cf1a:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801cf1e:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cf22:	8be2      	ldrh	r2, [r4, #30]
 801cf24:	f894 3020 	ldrb.w	r3, [r4, #32]
 801cf28:	f8ac 2000 	strh.w	r2, [ip]
 801cf2c:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.iccid[DC_MAX_SIZE_ICCID - 1U] = 0U; /* to avoid a non null terminated string */
 801cf30:	2300      	movs	r3, #0
 801cf32:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -ICCID: %s\n\r", cst_device_info.u.iccid)
 801cf34:	4e25      	ldr	r6, [pc, #148]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801cf36:	1ca2      	adds	r2, r4, #2
 801cf38:	492f      	ldr	r1, [pc, #188]	; (801cff8 <CST_get_device_all_infos+0x39c>)
 801cf3a:	4630      	mov	r0, r6
 801cf3c:	f008 fe98 	bl	8025c70 <sprintf>
 801cf40:	4630      	mov	r0, r6
 801cf42:	f002 f8e6 	bl	801f112 <crs_strlen>
 801cf46:	b283      	uxth	r3, r0
 801cf48:	4632      	mov	r2, r6
 801cf4a:	2101      	movs	r1, #1
 801cf4c:	2007      	movs	r0, #7
 801cf4e:	f002 f923 	bl	801f198 <traceIF_itmPrint>
 801cf52:	4630      	mov	r0, r6
 801cf54:	f002 f8dd 	bl	801f112 <crs_strlen>
 801cf58:	b283      	uxth	r3, r0
 801cf5a:	4632      	mov	r2, r6
 801cf5c:	2101      	movs	r1, #1
 801cf5e:	2007      	movs	r0, #7
 801cf60:	f002 f93c 	bl	801f1dc <traceIF_uartPrint>
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801cf64:	23f4      	movs	r3, #244	; 0xf4
 801cf66:	4a15      	ldr	r2, [pc, #84]	; (801cfbc <CST_get_device_all_infos+0x360>)
 801cf68:	4915      	ldr	r1, [pc, #84]	; (801cfc0 <CST_get_device_all_infos+0x364>)
 801cf6a:	8809      	ldrh	r1, [r1, #0]
 801cf6c:	4815      	ldr	r0, [pc, #84]	; (801cfc4 <CST_get_device_all_infos+0x368>)
 801cf6e:	f004 fcdf 	bl	8021930 <dc_com_write>
  if (target_state == DC_TARGET_STATE_FULL)
 801cf72:	2d02      	cmp	r5, #2
 801cf74:	f000 80ea 	beq.w	801d14c <CST_get_device_all_infos+0x4f0>
}
 801cf78:	b002      	add	sp, #8
 801cf7a:	bd70      	pop	{r4, r5, r6, pc}
    cst_cellular_info.imei[0] = 0U;
 801cf7c:	4b0f      	ldr	r3, [pc, #60]	; (801cfbc <CST_get_device_all_infos+0x360>)
 801cf7e:	2200      	movs	r2, #0
 801cf80:	741a      	strb	r2, [r3, #16]
    PRINT_CELLULAR_SERVICE("IMEI error\n\r")
 801cf82:	4c12      	ldr	r4, [pc, #72]	; (801cfcc <CST_get_device_all_infos+0x370>)
 801cf84:	4b1d      	ldr	r3, [pc, #116]	; (801cffc <CST_get_device_all_infos+0x3a0>)
 801cf86:	cb07      	ldmia	r3!, {r0, r1, r2}
 801cf88:	6020      	str	r0, [r4, #0]
 801cf8a:	6061      	str	r1, [r4, #4]
 801cf8c:	60a2      	str	r2, [r4, #8]
 801cf8e:	781b      	ldrb	r3, [r3, #0]
 801cf90:	7323      	strb	r3, [r4, #12]
 801cf92:	4620      	mov	r0, r4
 801cf94:	f002 f8bd 	bl	801f112 <crs_strlen>
 801cf98:	b283      	uxth	r3, r0
 801cf9a:	4622      	mov	r2, r4
 801cf9c:	2101      	movs	r1, #1
 801cf9e:	2007      	movs	r0, #7
 801cfa0:	f002 f8fa 	bl	801f198 <traceIF_itmPrint>
 801cfa4:	4620      	mov	r0, r4
 801cfa6:	f002 f8b4 	bl	801f112 <crs_strlen>
 801cfaa:	b283      	uxth	r3, r0
 801cfac:	4622      	mov	r2, r4
 801cfae:	2101      	movs	r1, #1
 801cfb0:	2007      	movs	r0, #7
 801cfb2:	f002 f913 	bl	801f1dc <traceIF_uartPrint>
 801cfb6:	e69f      	b.n	801ccf8 <CST_get_device_all_infos+0x9c>
 801cfb8:	200043b0 	.word	0x200043b0
 801cfbc:	2000406c 	.word	0x2000406c
 801cfc0:	20000236 	.word	0x20000236
 801cfc4:	200058b0 	.word	0x200058b0
 801cfc8:	2000407c 	.word	0x2000407c
 801cfcc:	20004ddc 	.word	0x20004ddc
 801cfd0:	080347fc 	.word	0x080347fc
 801cfd4:	200040bc 	.word	0x200040bc
 801cfd8:	0803481c 	.word	0x0803481c
 801cfdc:	200040dc 	.word	0x200040dc
 801cfe0:	08034850 	.word	0x08034850
 801cfe4:	200040fc 	.word	0x200040fc
 801cfe8:	08034870 	.word	0x08034870
 801cfec:	2000411c 	.word	0x2000411c
 801cff0:	08034898 	.word	0x08034898
 801cff4:	2000413c 	.word	0x2000413c
 801cff8:	080348c4 	.word	0x080348c4
 801cffc:	0803480c 	.word	0x0803480c
    cst_cellular_info.manufacturer_name[0] = 0U;
 801d000:	4baa      	ldr	r3, [pc, #680]	; (801d2ac <CST_get_device_all_infos+0x650>)
 801d002:	2200      	movs	r2, #0
 801d004:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    PRINT_CELLULAR_SERVICE("Manufacturer Name error\n\r")
 801d008:	4ca9      	ldr	r4, [pc, #676]	; (801d2b0 <CST_get_device_all_infos+0x654>)
 801d00a:	4eaa      	ldr	r6, [pc, #680]	; (801d2b4 <CST_get_device_all_infos+0x658>)
 801d00c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d00e:	6020      	str	r0, [r4, #0]
 801d010:	6061      	str	r1, [r4, #4]
 801d012:	60a2      	str	r2, [r4, #8]
 801d014:	60e3      	str	r3, [r4, #12]
 801d016:	ce03      	ldmia	r6!, {r0, r1}
 801d018:	6120      	str	r0, [r4, #16]
 801d01a:	6161      	str	r1, [r4, #20]
 801d01c:	8833      	ldrh	r3, [r6, #0]
 801d01e:	8323      	strh	r3, [r4, #24]
 801d020:	4620      	mov	r0, r4
 801d022:	f002 f876 	bl	801f112 <crs_strlen>
 801d026:	b283      	uxth	r3, r0
 801d028:	4622      	mov	r2, r4
 801d02a:	2101      	movs	r1, #1
 801d02c:	2007      	movs	r0, #7
 801d02e:	f002 f8b3 	bl	801f198 <traceIF_itmPrint>
 801d032:	4620      	mov	r0, r4
 801d034:	f002 f86d 	bl	801f112 <crs_strlen>
 801d038:	b283      	uxth	r3, r0
 801d03a:	4622      	mov	r2, r4
 801d03c:	2101      	movs	r1, #1
 801d03e:	2007      	movs	r0, #7
 801d040:	f002 f8cc 	bl	801f1dc <traceIF_uartPrint>
 801d044:	e696      	b.n	801cd74 <CST_get_device_all_infos+0x118>
    cst_cellular_info.model[0] = 0U;
 801d046:	4b99      	ldr	r3, [pc, #612]	; (801d2ac <CST_get_device_all_infos+0x650>)
 801d048:	2200      	movs	r2, #0
 801d04a:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
    PRINT_CELLULAR_SERVICE("Model error\n\r")
 801d04e:	4c98      	ldr	r4, [pc, #608]	; (801d2b0 <CST_get_device_all_infos+0x654>)
 801d050:	4b99      	ldr	r3, [pc, #612]	; (801d2b8 <CST_get_device_all_infos+0x65c>)
 801d052:	cb07      	ldmia	r3!, {r0, r1, r2}
 801d054:	6020      	str	r0, [r4, #0]
 801d056:	6061      	str	r1, [r4, #4]
 801d058:	60a2      	str	r2, [r4, #8]
 801d05a:	881b      	ldrh	r3, [r3, #0]
 801d05c:	81a3      	strh	r3, [r4, #12]
 801d05e:	4620      	mov	r0, r4
 801d060:	f002 f857 	bl	801f112 <crs_strlen>
 801d064:	b283      	uxth	r3, r0
 801d066:	4622      	mov	r2, r4
 801d068:	2101      	movs	r1, #1
 801d06a:	2007      	movs	r0, #7
 801d06c:	f002 f894 	bl	801f198 <traceIF_itmPrint>
 801d070:	4620      	mov	r0, r4
 801d072:	f002 f84e 	bl	801f112 <crs_strlen>
 801d076:	b283      	uxth	r3, r0
 801d078:	4622      	mov	r2, r4
 801d07a:	2101      	movs	r1, #1
 801d07c:	2007      	movs	r0, #7
 801d07e:	f002 f8ad 	bl	801f1dc <traceIF_uartPrint>
 801d082:	e6b5      	b.n	801cdf0 <CST_get_device_all_infos+0x194>
    cst_cellular_info.revision[0] = 0U;
 801d084:	4b89      	ldr	r3, [pc, #548]	; (801d2ac <CST_get_device_all_infos+0x650>)
 801d086:	2200      	movs	r2, #0
 801d088:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
    PRINT_CELLULAR_SERVICE("Revision error\n\r")
 801d08c:	4c88      	ldr	r4, [pc, #544]	; (801d2b0 <CST_get_device_all_infos+0x654>)
 801d08e:	4e8b      	ldr	r6, [pc, #556]	; (801d2bc <CST_get_device_all_infos+0x660>)
 801d090:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d092:	6020      	str	r0, [r4, #0]
 801d094:	6061      	str	r1, [r4, #4]
 801d096:	60a2      	str	r2, [r4, #8]
 801d098:	60e3      	str	r3, [r4, #12]
 801d09a:	7833      	ldrb	r3, [r6, #0]
 801d09c:	7423      	strb	r3, [r4, #16]
 801d09e:	4620      	mov	r0, r4
 801d0a0:	f002 f837 	bl	801f112 <crs_strlen>
 801d0a4:	b283      	uxth	r3, r0
 801d0a6:	4622      	mov	r2, r4
 801d0a8:	2101      	movs	r1, #1
 801d0aa:	2007      	movs	r0, #7
 801d0ac:	f002 f874 	bl	801f198 <traceIF_itmPrint>
 801d0b0:	4620      	mov	r0, r4
 801d0b2:	f002 f82e 	bl	801f112 <crs_strlen>
 801d0b6:	b283      	uxth	r3, r0
 801d0b8:	4622      	mov	r2, r4
 801d0ba:	2101      	movs	r1, #1
 801d0bc:	2007      	movs	r0, #7
 801d0be:	f002 f88d 	bl	801f1dc <traceIF_uartPrint>
 801d0c2:	e6d3      	b.n	801ce6c <CST_get_device_all_infos+0x210>
    cst_cellular_info.serial_number[0] = 0U;
 801d0c4:	4b79      	ldr	r3, [pc, #484]	; (801d2ac <CST_get_device_all_infos+0x650>)
 801d0c6:	2200      	movs	r2, #0
 801d0c8:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
    PRINT_CELLULAR_SERVICE("Serial Number error\n\r")
 801d0cc:	4c78      	ldr	r4, [pc, #480]	; (801d2b0 <CST_get_device_all_infos+0x654>)
 801d0ce:	4e7c      	ldr	r6, [pc, #496]	; (801d2c0 <CST_get_device_all_infos+0x664>)
 801d0d0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d0d2:	6020      	str	r0, [r4, #0]
 801d0d4:	6061      	str	r1, [r4, #4]
 801d0d6:	60a2      	str	r2, [r4, #8]
 801d0d8:	60e3      	str	r3, [r4, #12]
 801d0da:	6830      	ldr	r0, [r6, #0]
 801d0dc:	6120      	str	r0, [r4, #16]
 801d0de:	88b3      	ldrh	r3, [r6, #4]
 801d0e0:	82a3      	strh	r3, [r4, #20]
 801d0e2:	4620      	mov	r0, r4
 801d0e4:	f002 f815 	bl	801f112 <crs_strlen>
 801d0e8:	b283      	uxth	r3, r0
 801d0ea:	4622      	mov	r2, r4
 801d0ec:	2101      	movs	r1, #1
 801d0ee:	2007      	movs	r0, #7
 801d0f0:	f002 f852 	bl	801f198 <traceIF_itmPrint>
 801d0f4:	4620      	mov	r0, r4
 801d0f6:	f002 f80c 	bl	801f112 <crs_strlen>
 801d0fa:	b283      	uxth	r3, r0
 801d0fc:	4622      	mov	r2, r4
 801d0fe:	2101      	movs	r1, #1
 801d100:	2007      	movs	r0, #7
 801d102:	f002 f86b 	bl	801f1dc <traceIF_uartPrint>
 801d106:	e6ef      	b.n	801cee8 <CST_get_device_all_infos+0x28c>
    cst_cellular_info.serial_number[0] = 0U;
 801d108:	4b68      	ldr	r3, [pc, #416]	; (801d2ac <CST_get_device_all_infos+0x650>)
 801d10a:	2200      	movs	r2, #0
 801d10c:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
    PRINT_CELLULAR_SERVICE("Serial Number error\n\r")
 801d110:	4c67      	ldr	r4, [pc, #412]	; (801d2b0 <CST_get_device_all_infos+0x654>)
 801d112:	4e6b      	ldr	r6, [pc, #428]	; (801d2c0 <CST_get_device_all_infos+0x664>)
 801d114:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d116:	6020      	str	r0, [r4, #0]
 801d118:	6061      	str	r1, [r4, #4]
 801d11a:	60a2      	str	r2, [r4, #8]
 801d11c:	60e3      	str	r3, [r4, #12]
 801d11e:	6830      	ldr	r0, [r6, #0]
 801d120:	6120      	str	r0, [r4, #16]
 801d122:	88b3      	ldrh	r3, [r6, #4]
 801d124:	82a3      	strh	r3, [r4, #20]
 801d126:	4620      	mov	r0, r4
 801d128:	f001 fff3 	bl	801f112 <crs_strlen>
 801d12c:	b283      	uxth	r3, r0
 801d12e:	4622      	mov	r2, r4
 801d130:	2101      	movs	r1, #1
 801d132:	2007      	movs	r0, #7
 801d134:	f002 f830 	bl	801f198 <traceIF_itmPrint>
 801d138:	4620      	mov	r0, r4
 801d13a:	f001 ffea 	bl	801f112 <crs_strlen>
 801d13e:	b283      	uxth	r3, r0
 801d140:	4622      	mov	r2, r4
 801d142:	2101      	movs	r1, #1
 801d144:	2007      	movs	r0, #7
 801d146:	f002 f849 	bl	801f1dc <traceIF_uartPrint>
 801d14a:	e70b      	b.n	801cf64 <CST_get_device_all_infos+0x308>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d14c:	4e5d      	ldr	r6, [pc, #372]	; (801d2c4 <CST_get_device_all_infos+0x668>)
 801d14e:	4c5e      	ldr	r4, [pc, #376]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d150:	4d5e      	ldr	r5, [pc, #376]	; (801d2cc <CST_get_device_all_infos+0x670>)
 801d152:	2330      	movs	r3, #48	; 0x30
 801d154:	4622      	mov	r2, r4
 801d156:	8831      	ldrh	r1, [r6, #0]
 801d158:	4628      	mov	r0, r5
 801d15a:	f004 fc35 	bl	80219c8 <dc_com_read>
    cst_sim_info.rt_state   = DC_SERVICE_ON;
 801d15e:	2307      	movs	r3, #7
 801d160:	7223      	strb	r3, [r4, #8]
    cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_CONNECTION_ON_GOING;
 801d162:	4b5b      	ldr	r3, [pc, #364]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d164:	7c1b      	ldrb	r3, [r3, #16]
 801d166:	4423      	add	r3, r4
 801d168:	2208      	movs	r2, #8
 801d16a:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d16e:	2330      	movs	r3, #48	; 0x30
 801d170:	4622      	mov	r2, r4
 801d172:	8831      	ldrh	r1, [r6, #0]
 801d174:	4628      	mov	r0, r5
 801d176:	f004 fbdb 	bl	8021930 <dc_com_write>
  sim_poll_count = 0U;
 801d17a:	2500      	movs	r5, #0
      cst_device_info.field_requested = CS_DIF_IMSI_PRESENT;
 801d17c:	4855      	ldr	r0, [pc, #340]	; (801d2d4 <CST_get_device_all_infos+0x678>)
 801d17e:	2320      	movs	r3, #32
 801d180:	8003      	strh	r3, [r0, #0]
      cs_status = osCDS_get_device_info(&cst_device_info);
 801d182:	f7fd fc1b 	bl	801a9bc <osCDS_get_device_info>
      if (cs_status == CELLULAR_OK)
 801d186:	4604      	mov	r4, r0
 801d188:	b140      	cbz	r0, 801d19c <CST_get_device_all_infos+0x540>
      else if ((cs_status == CELLULAR_SIM_BUSY)
 801d18a:	1ee3      	subs	r3, r4, #3
 801d18c:	2b04      	cmp	r3, #4
 801d18e:	f200 8085 	bhi.w	801d29c <CST_get_device_all_infos+0x640>
 801d192:	e8df f003 	tbb	[pc, r3]
 801d196:	644b      	.short	0x644b
 801d198:	7b73      	.short	0x7b73
 801d19a:	4b          	.byte	0x4b
 801d19b:	00          	.byte	0x00
        (void)ATutil_convertHexaStringToInt64(cst_device_info.u.imsi, 15U, &cst_imsi_high, &cst_imsi_low);
 801d19c:	4e4d      	ldr	r6, [pc, #308]	; (801d2d4 <CST_get_device_all_infos+0x678>)
 801d19e:	1cb4      	adds	r4, r6, #2
 801d1a0:	466b      	mov	r3, sp
 801d1a2:	aa01      	add	r2, sp, #4
 801d1a4:	210f      	movs	r1, #15
 801d1a6:	4620      	mov	r0, r4
 801d1a8:	f7f7 fdf8 	bl	8014d9c <ATutil_convertHexaStringToInt64>
        PRINT_CELLULAR_SERVICE(" -IMSI: %s\n\r", cst_device_info.u.imsi)
 801d1ac:	4d40      	ldr	r5, [pc, #256]	; (801d2b0 <CST_get_device_all_infos+0x654>)
 801d1ae:	4622      	mov	r2, r4
 801d1b0:	4949      	ldr	r1, [pc, #292]	; (801d2d8 <CST_get_device_all_infos+0x67c>)
 801d1b2:	4628      	mov	r0, r5
 801d1b4:	f008 fd5c 	bl	8025c70 <sprintf>
 801d1b8:	4628      	mov	r0, r5
 801d1ba:	f001 ffaa 	bl	801f112 <crs_strlen>
 801d1be:	b283      	uxth	r3, r0
 801d1c0:	462a      	mov	r2, r5
 801d1c2:	2101      	movs	r1, #1
 801d1c4:	2007      	movs	r0, #7
 801d1c6:	f001 ffe7 	bl	801f198 <traceIF_itmPrint>
 801d1ca:	4628      	mov	r0, r5
 801d1cc:	f001 ffa1 	bl	801f112 <crs_strlen>
 801d1d0:	b283      	uxth	r3, r0
 801d1d2:	462a      	mov	r2, r5
 801d1d4:	2101      	movs	r1, #1
 801d1d6:	2007      	movs	r0, #7
 801d1d8:	f002 f800 	bl	801f1dc <traceIF_uartPrint>
        CST_fill_nfmc_tempo(cst_imsi_high, cst_imsi_low);
 801d1dc:	9900      	ldr	r1, [sp, #0]
 801d1de:	9801      	ldr	r0, [sp, #4]
 801d1e0:	f7ff fc28 	bl	801ca34 <CST_fill_nfmc_tempo>
        (void)memcpy((CRC_CHAR_t *)cst_sim_info.imsi,
 801d1e4:	4b3d      	ldr	r3, [pc, #244]	; (801d2dc <CST_get_device_all_infos+0x680>)
 801d1e6:	f8d6 0002 	ldr.w	r0, [r6, #2]
 801d1ea:	f8d6 1006 	ldr.w	r1, [r6, #6]
 801d1ee:	f8d6 200a 	ldr.w	r2, [r6, #10]
 801d1f2:	f8d6 500e 	ldr.w	r5, [r6, #14]
 801d1f6:	6018      	str	r0, [r3, #0]
 801d1f8:	6059      	str	r1, [r3, #4]
 801d1fa:	609a      	str	r2, [r3, #8]
 801d1fc:	60dd      	str	r5, [r3, #12]
 801d1fe:	f8d6 0012 	ldr.w	r0, [r6, #18]
 801d202:	f8d6 1016 	ldr.w	r1, [r6, #22]
 801d206:	f8d6 201a 	ldr.w	r2, [r6, #26]
 801d20a:	6118      	str	r0, [r3, #16]
 801d20c:	6159      	str	r1, [r3, #20]
 801d20e:	619a      	str	r2, [r3, #24]
 801d210:	8bf1      	ldrh	r1, [r6, #30]
 801d212:	f896 2020 	ldrb.w	r2, [r6, #32]
 801d216:	8399      	strh	r1, [r3, #28]
 801d218:	779a      	strb	r2, [r3, #30]
        cst_sim_info.imsi[DC_MAX_SIZE_IMSI - 1U] = 0;  /* to avoid a non null terminated string */
 801d21a:	2200      	movs	r2, #0
 801d21c:	77da      	strb	r2, [r3, #31]
 801d21e:	3b09      	subs	r3, #9
        cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_OK;
 801d220:	492b      	ldr	r1, [pc, #172]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d222:	7c09      	ldrb	r1, [r1, #16]
 801d224:	440b      	add	r3, r1
 801d226:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    while (end_of_loop != false)
 801d22a:	e01f      	b.n	801d26c <CST_get_device_all_infos+0x610>
        (void)rtosalDelay(100U);
 801d22c:	2064      	movs	r0, #100	; 0x64
 801d22e:	f001 fec8 	bl	801efc2 <rtosalDelay>
        sim_poll_count++;
 801d232:	3501      	adds	r5, #1
 801d234:	b2ad      	uxth	r5, r5
        if (sim_poll_count > CST_SIM_POLL_COUNT)
 801d236:	2dc8      	cmp	r5, #200	; 0xc8
 801d238:	d9a0      	bls.n	801d17c <CST_get_device_all_infos+0x520>
          if (cs_status == CELLULAR_SIM_BUSY)
 801d23a:	2c03      	cmp	r4, #3
 801d23c:	d007      	beq.n	801d24e <CST_get_device_all_infos+0x5f2>
            cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_ERROR;
 801d23e:	4b24      	ldr	r3, [pc, #144]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d240:	7c1a      	ldrb	r2, [r3, #16]
 801d242:	4b21      	ldr	r3, [pc, #132]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d244:	4413      	add	r3, r2
 801d246:	2206      	movs	r2, #6
 801d248:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d24c:	e00e      	b.n	801d26c <CST_get_device_all_infos+0x610>
            cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_BUSY;
 801d24e:	4b20      	ldr	r3, [pc, #128]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d250:	7c1a      	ldrb	r2, [r3, #16]
 801d252:	4b1d      	ldr	r3, [pc, #116]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d254:	4413      	add	r3, r2
 801d256:	2202      	movs	r2, #2
 801d258:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d25c:	e006      	b.n	801d26c <CST_get_device_all_infos+0x610>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_NOT_INSERTED;
 801d25e:	4b1c      	ldr	r3, [pc, #112]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d260:	7c1a      	ldrb	r2, [r3, #16]
 801d262:	4b19      	ldr	r3, [pc, #100]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d264:	4413      	add	r3, r2
 801d266:	2203      	movs	r2, #3
 801d268:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d26c:	2330      	movs	r3, #48	; 0x30
 801d26e:	4a16      	ldr	r2, [pc, #88]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d270:	4914      	ldr	r1, [pc, #80]	; (801d2c4 <CST_get_device_all_infos+0x668>)
 801d272:	8809      	ldrh	r1, [r1, #0]
 801d274:	4815      	ldr	r0, [pc, #84]	; (801d2cc <CST_get_device_all_infos+0x670>)
 801d276:	f004 fb5b 	bl	8021930 <dc_com_write>
}
 801d27a:	e67d      	b.n	801cf78 <CST_get_device_all_infos+0x31c>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_PIN_OR_PUK_LOCKED;
 801d27c:	4b14      	ldr	r3, [pc, #80]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d27e:	7c1a      	ldrb	r2, [r3, #16]
 801d280:	4b11      	ldr	r3, [pc, #68]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d282:	4413      	add	r3, r2
 801d284:	2204      	movs	r2, #4
 801d286:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d28a:	e7ef      	b.n	801d26c <CST_get_device_all_infos+0x610>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_INCORRECT_PASSWORD;
 801d28c:	4b10      	ldr	r3, [pc, #64]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d28e:	7c1a      	ldrb	r2, [r3, #16]
 801d290:	4b0d      	ldr	r3, [pc, #52]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d292:	4413      	add	r3, r2
 801d294:	2205      	movs	r2, #5
 801d296:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d29a:	e7e7      	b.n	801d26c <CST_get_device_all_infos+0x610>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_ERROR;
 801d29c:	4b0c      	ldr	r3, [pc, #48]	; (801d2d0 <CST_get_device_all_infos+0x674>)
 801d29e:	7c1a      	ldrb	r2, [r3, #16]
 801d2a0:	4b09      	ldr	r3, [pc, #36]	; (801d2c8 <CST_get_device_all_infos+0x66c>)
 801d2a2:	4413      	add	r3, r2
 801d2a4:	2206      	movs	r2, #6
 801d2a6:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d2aa:	e7df      	b.n	801d26c <CST_get_device_all_infos+0x610>
 801d2ac:	2000406c 	.word	0x2000406c
 801d2b0:	20004ddc 	.word	0x20004ddc
 801d2b4:	08034834 	.word	0x08034834
 801d2b8:	08034860 	.word	0x08034860
 801d2bc:	08034884 	.word	0x08034884
 801d2c0:	080348ac 	.word	0x080348ac
 801d2c4:	2000023c 	.word	0x2000023c
 801d2c8:	20004338 	.word	0x20004338
 801d2cc:	200058b0 	.word	0x200058b0
 801d2d0:	200000b0 	.word	0x200000b0
 801d2d4:	200043b0 	.word	0x200043b0
 801d2d8:	080348d4 	.word	0x080348d4
 801d2dc:	20004341 	.word	0x20004341

0801d2e0 <CST_subscribe_all_net_events>:
{
 801d2e0:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("Subscribe URC events: Network registration\n\r")
 801d2e2:	4c37      	ldr	r4, [pc, #220]	; (801d3c0 <CST_subscribe_all_net_events+0xe0>)
 801d2e4:	4d37      	ldr	r5, [pc, #220]	; (801d3c4 <CST_subscribe_all_net_events+0xe4>)
 801d2e6:	f104 0e20 	add.w	lr, r4, #32
 801d2ea:	46a4      	mov	ip, r4
 801d2ec:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801d2f0:	6028      	str	r0, [r5, #0]
 801d2f2:	6069      	str	r1, [r5, #4]
 801d2f4:	60aa      	str	r2, [r5, #8]
 801d2f6:	60eb      	str	r3, [r5, #12]
 801d2f8:	4664      	mov	r4, ip
 801d2fa:	3510      	adds	r5, #16
 801d2fc:	45f4      	cmp	ip, lr
 801d2fe:	d1f4      	bne.n	801d2ea <CST_subscribe_all_net_events+0xa>
 801d300:	cc07      	ldmia	r4!, {r0, r1, r2}
 801d302:	6028      	str	r0, [r5, #0]
 801d304:	6069      	str	r1, [r5, #4]
 801d306:	60aa      	str	r2, [r5, #8]
 801d308:	7823      	ldrb	r3, [r4, #0]
 801d30a:	732b      	strb	r3, [r5, #12]
 801d30c:	4c2d      	ldr	r4, [pc, #180]	; (801d3c4 <CST_subscribe_all_net_events+0xe4>)
 801d30e:	4620      	mov	r0, r4
 801d310:	f001 feff 	bl	801f112 <crs_strlen>
 801d314:	b283      	uxth	r3, r0
 801d316:	4622      	mov	r2, r4
 801d318:	2101      	movs	r1, #1
 801d31a:	2007      	movs	r0, #7
 801d31c:	f001 ff3c 	bl	801f198 <traceIF_itmPrint>
 801d320:	4620      	mov	r0, r4
 801d322:	f001 fef6 	bl	801f112 <crs_strlen>
 801d326:	b283      	uxth	r3, r0
 801d328:	4622      	mov	r2, r4
 801d32a:	2101      	movs	r1, #1
 801d32c:	2007      	movs	r0, #7
 801d32e:	f001 ff55 	bl	801f1dc <traceIF_uartPrint>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_CS_NETWORK_REG_STAT, CST_network_reg_callback);
 801d332:	4d25      	ldr	r5, [pc, #148]	; (801d3c8 <CST_subscribe_all_net_events+0xe8>)
 801d334:	4629      	mov	r1, r5
 801d336:	2005      	movs	r0, #5
 801d338:	f7fd fb54 	bl	801a9e4 <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_GPRS_NETWORK_REG_STAT, CST_network_reg_callback);
 801d33c:	4629      	mov	r1, r5
 801d33e:	2003      	movs	r0, #3
 801d340:	f7fd fb50 	bl	801a9e4 <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_EPS_NETWORK_REG_STAT, CST_network_reg_callback);
 801d344:	4629      	mov	r1, r5
 801d346:	2001      	movs	r0, #1
 801d348:	f7fd fb4c 	bl	801a9e4 <osCDS_subscribe_net_event>
  PRINT_CELLULAR_SERVICE("Subscribe URC events: Location info\n\r")
 801d34c:	4d1f      	ldr	r5, [pc, #124]	; (801d3cc <CST_subscribe_all_net_events+0xec>)
 801d34e:	46a4      	mov	ip, r4
 801d350:	f105 0e20 	add.w	lr, r5, #32
 801d354:	462c      	mov	r4, r5
 801d356:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d358:	f8cc 0000 	str.w	r0, [ip]
 801d35c:	f8cc 1004 	str.w	r1, [ip, #4]
 801d360:	f8cc 2008 	str.w	r2, [ip, #8]
 801d364:	f8cc 300c 	str.w	r3, [ip, #12]
 801d368:	4625      	mov	r5, r4
 801d36a:	f10c 0c10 	add.w	ip, ip, #16
 801d36e:	4574      	cmp	r4, lr
 801d370:	d1f0      	bne.n	801d354 <CST_subscribe_all_net_events+0x74>
 801d372:	6820      	ldr	r0, [r4, #0]
 801d374:	f8cc 0000 	str.w	r0, [ip]
 801d378:	88a3      	ldrh	r3, [r4, #4]
 801d37a:	f8ac 3004 	strh.w	r3, [ip, #4]
 801d37e:	4c11      	ldr	r4, [pc, #68]	; (801d3c4 <CST_subscribe_all_net_events+0xe4>)
 801d380:	4620      	mov	r0, r4
 801d382:	f001 fec6 	bl	801f112 <crs_strlen>
 801d386:	b283      	uxth	r3, r0
 801d388:	4622      	mov	r2, r4
 801d38a:	2101      	movs	r1, #1
 801d38c:	2007      	movs	r0, #7
 801d38e:	f001 ff03 	bl	801f198 <traceIF_itmPrint>
 801d392:	4620      	mov	r0, r4
 801d394:	f001 febd 	bl	801f112 <crs_strlen>
 801d398:	b283      	uxth	r3, r0
 801d39a:	4622      	mov	r2, r4
 801d39c:	2101      	movs	r1, #1
 801d39e:	2007      	movs	r0, #7
 801d3a0:	f001 ff1c 	bl	801f1dc <traceIF_uartPrint>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_EPS_LOCATION_INFO, CST_location_info_callback);
 801d3a4:	4c0a      	ldr	r4, [pc, #40]	; (801d3d0 <CST_subscribe_all_net_events+0xf0>)
 801d3a6:	4621      	mov	r1, r4
 801d3a8:	2002      	movs	r0, #2
 801d3aa:	f7fd fb1b 	bl	801a9e4 <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_GPRS_LOCATION_INFO, CST_location_info_callback);
 801d3ae:	4621      	mov	r1, r4
 801d3b0:	2004      	movs	r0, #4
 801d3b2:	f7fd fb17 	bl	801a9e4 <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_CS_LOCATION_INFO, CST_location_info_callback);
 801d3b6:	4621      	mov	r1, r4
 801d3b8:	2006      	movs	r0, #6
 801d3ba:	f7fd fb13 	bl	801a9e4 <osCDS_subscribe_net_event>
}
 801d3be:	bd38      	pop	{r3, r4, r5, pc}
 801d3c0:	080348e4 	.word	0x080348e4
 801d3c4:	20004ddc 	.word	0x20004ddc
 801d3c8:	0801cb65 	.word	0x0801cb65
 801d3cc:	08034914 	.word	0x08034914
 801d3d0:	0801c9e9 	.word	0x0801c9e9

0801d3d4 <CST_data_cache_cellular_info_set>:
{
 801d3d4:	b570      	push	{r4, r5, r6, lr}
 801d3d6:	b084      	sub	sp, #16
 801d3d8:	4604      	mov	r4, r0
 801d3da:	460d      	mov	r5, r1
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_NIFMAN_INFO, (void *)&nifman_info, sizeof(nifman_info));
 801d3dc:	2310      	movs	r3, #16
 801d3de:	466a      	mov	r2, sp
 801d3e0:	4918      	ldr	r1, [pc, #96]	; (801d444 <CST_data_cache_cellular_info_set+0x70>)
 801d3e2:	8809      	ldrh	r1, [r1, #0]
 801d3e4:	4818      	ldr	r0, [pc, #96]	; (801d448 <CST_data_cache_cellular_info_set+0x74>)
 801d3e6:	f004 faef 	bl	80219c8 <dc_com_read>
  if (nifman_info.rt_state != dc_service_state)
 801d3ea:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801d3ee:	42a3      	cmp	r3, r4
 801d3f0:	d00e      	beq.n	801d410 <CST_data_cache_cellular_info_set+0x3c>
    nifman_info.rt_state   =  dc_service_state;
 801d3f2:	f88d 4008 	strb.w	r4, [sp, #8]
    nifman_info.network    =  DC_CELLULAR_SOCKET_MODEM;
 801d3f6:	2301      	movs	r3, #1
 801d3f8:	f88d 3009 	strb.w	r3, [sp, #9]
    if (ip_addr != NULL)
 801d3fc:	b10d      	cbz	r5, 801d402 <CST_data_cache_cellular_info_set+0x2e>
      (void)memcpy(&nifman_info.ip_addr, ip_addr, sizeof(dc_network_addr_t));
 801d3fe:	682b      	ldr	r3, [r5, #0]
 801d400:	9303      	str	r3, [sp, #12]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_NIFMAN_INFO, (void *)&nifman_info, sizeof(nifman_info));
 801d402:	2310      	movs	r3, #16
 801d404:	466a      	mov	r2, sp
 801d406:	490f      	ldr	r1, [pc, #60]	; (801d444 <CST_data_cache_cellular_info_set+0x70>)
 801d408:	8809      	ldrh	r1, [r1, #0]
 801d40a:	480f      	ldr	r0, [pc, #60]	; (801d448 <CST_data_cache_cellular_info_set+0x74>)
 801d40c:	f004 fa90 	bl	8021930 <dc_com_write>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801d410:	4e0e      	ldr	r6, [pc, #56]	; (801d44c <CST_data_cache_cellular_info_set+0x78>)
 801d412:	2310      	movs	r3, #16
 801d414:	4632      	mov	r2, r6
 801d416:	490e      	ldr	r1, [pc, #56]	; (801d450 <CST_data_cache_cellular_info_set+0x7c>)
 801d418:	8809      	ldrh	r1, [r1, #0]
 801d41a:	480b      	ldr	r0, [pc, #44]	; (801d448 <CST_data_cache_cellular_info_set+0x74>)
 801d41c:	f004 fad4 	bl	80219c8 <dc_com_read>
  if (cst_cellular_data_info.rt_state != dc_service_state)
 801d420:	7a33      	ldrb	r3, [r6, #8]
 801d422:	42a3      	cmp	r3, r4
 801d424:	d00c      	beq.n	801d440 <CST_data_cache_cellular_info_set+0x6c>
    cst_cellular_data_info.rt_state   =  dc_service_state;
 801d426:	7234      	strb	r4, [r6, #8]
    cst_cellular_data_info.network    =  DC_NETWORK_SOCKET_MODEM;
 801d428:	2201      	movs	r2, #1
 801d42a:	7272      	strb	r2, [r6, #9]
    if (ip_addr != NULL)
 801d42c:	b10d      	cbz	r5, 801d432 <CST_data_cache_cellular_info_set+0x5e>
      (void)memcpy(&cst_cellular_data_info.ip_addr, ip_addr, sizeof(dc_network_addr_t));
 801d42e:	682a      	ldr	r2, [r5, #0]
 801d430:	60f2      	str	r2, [r6, #12]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801d432:	2310      	movs	r3, #16
 801d434:	4a05      	ldr	r2, [pc, #20]	; (801d44c <CST_data_cache_cellular_info_set+0x78>)
 801d436:	4906      	ldr	r1, [pc, #24]	; (801d450 <CST_data_cache_cellular_info_set+0x7c>)
 801d438:	8809      	ldrh	r1, [r1, #0]
 801d43a:	4803      	ldr	r0, [pc, #12]	; (801d448 <CST_data_cache_cellular_info_set+0x74>)
 801d43c:	f004 fa78 	bl	8021930 <dc_com_write>
}
 801d440:	b004      	add	sp, #16
 801d442:	bd70      	pop	{r4, r5, r6, pc}
 801d444:	2000023a 	.word	0x2000023a
 801d448:	200058b0 	.word	0x200058b0
 801d44c:	2000405c 	.word	0x2000405c
 801d450:	20000234 	.word	0x20000234

0801d454 <CST_config_fail>:
{
 801d454:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d456:	b083      	sub	sp, #12
 801d458:	460f      	mov	r7, r1
 801d45a:	4614      	mov	r4, r2
 801d45c:	461e      	mov	r6, r3
  PRINT_CELLULAR_SERVICE("=== %s Fail !!! === \r\n", msg_fail)
 801d45e:	4d33      	ldr	r5, [pc, #204]	; (801d52c <CST_config_fail+0xd8>)
 801d460:	4602      	mov	r2, r0
 801d462:	4933      	ldr	r1, [pc, #204]	; (801d530 <CST_config_fail+0xdc>)
 801d464:	4628      	mov	r0, r5
 801d466:	f008 fc03 	bl	8025c70 <sprintf>
 801d46a:	4628      	mov	r0, r5
 801d46c:	f001 fe51 	bl	801f112 <crs_strlen>
 801d470:	b283      	uxth	r3, r0
 801d472:	462a      	mov	r2, r5
 801d474:	2101      	movs	r1, #1
 801d476:	2007      	movs	r0, #7
 801d478:	f001 fe8e 	bl	801f198 <traceIF_itmPrint>
 801d47c:	4628      	mov	r0, r5
 801d47e:	f001 fe48 	bl	801f112 <crs_strlen>
 801d482:	b283      	uxth	r3, r0
 801d484:	462a      	mov	r2, r5
 801d486:	2101      	movs	r1, #1
 801d488:	2007      	movs	r0, #7
 801d48a:	f001 fea7 	bl	801f1dc <traceIF_uartPrint>
  ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 1, ERROR_WARNING);
 801d48e:	2202      	movs	r2, #2
 801d490:	2101      	movs	r1, #1
 801d492:	2007      	movs	r0, #7
 801d494:	f000 fe5a 	bl	801e14c <ERROR_Handler>
  *fail_count = *fail_count + 1U;
 801d498:	7823      	ldrb	r3, [r4, #0]
 801d49a:	3301      	adds	r3, #1
 801d49c:	7023      	strb	r3, [r4, #0]
  cst_context.global_retry_count++;
 801d49e:	4825      	ldr	r0, [pc, #148]	; (801d534 <CST_config_fail+0xe0>)
 801d4a0:	7ec3      	ldrb	r3, [r0, #27]
 801d4a2:	3301      	adds	r3, #1
 801d4a4:	76c3      	strb	r3, [r0, #27]
  cst_context.reset_count++;
 801d4a6:	7c83      	ldrb	r3, [r0, #18]
 801d4a8:	3301      	adds	r3, #1
 801d4aa:	7483      	strb	r3, [r0, #18]
  CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801d4ac:	2100      	movs	r1, #0
 801d4ae:	2003      	movs	r0, #3
 801d4b0:	f7ff ff90 	bl	801d3d4 <CST_data_cache_cellular_info_set>
  if ((*fail_count <= fail_max) && (cst_context.global_retry_count <= CST_GLOBAL_RETRY_MAX))
 801d4b4:	7823      	ldrb	r3, [r4, #0]
 801d4b6:	42b3      	cmp	r3, r6
 801d4b8:	d803      	bhi.n	801d4c2 <CST_config_fail+0x6e>
 801d4ba:	4b1e      	ldr	r3, [pc, #120]	; (801d534 <CST_config_fail+0xe0>)
 801d4bc:	7edb      	ldrb	r3, [r3, #27]
 801d4be:	2b05      	cmp	r3, #5
 801d4c0:	d929      	bls.n	801d516 <CST_config_fail+0xc2>
    CST_set_state(CST_MODEM_FAIL_STATE);
 801d4c2:	200a      	movs	r0, #10
 801d4c4:	f7fd fe54 	bl	801b170 <CST_set_state>
    CST_fail_setting();
 801d4c8:	f7ff fb1a 	bl	801cb00 <CST_fail_setting>
    cst_context.fail_cause    = CST_MODEM_POWER_ON_FAIL;
 801d4cc:	4b19      	ldr	r3, [pc, #100]	; (801d534 <CST_config_fail+0xe0>)
 801d4ce:	2201      	movs	r2, #1
 801d4d0:	709a      	strb	r2, [r3, #2]
    PRINT_CELLULAR_SERVICE_ERR("=== CST_set_fail_state %d - count %d/%d FATAL !!! ===\n\r",
 801d4d2:	7822      	ldrb	r2, [r4, #0]
 801d4d4:	4c15      	ldr	r4, [pc, #84]	; (801d52c <CST_config_fail+0xd8>)
 801d4d6:	9200      	str	r2, [sp, #0]
 801d4d8:	7edb      	ldrb	r3, [r3, #27]
 801d4da:	463a      	mov	r2, r7
 801d4dc:	4916      	ldr	r1, [pc, #88]	; (801d538 <CST_config_fail+0xe4>)
 801d4de:	4620      	mov	r0, r4
 801d4e0:	f008 fbc6 	bl	8025c70 <sprintf>
 801d4e4:	4620      	mov	r0, r4
 801d4e6:	f001 fe14 	bl	801f112 <crs_strlen>
 801d4ea:	b283      	uxth	r3, r0
 801d4ec:	4622      	mov	r2, r4
 801d4ee:	2110      	movs	r1, #16
 801d4f0:	2007      	movs	r0, #7
 801d4f2:	f001 fe51 	bl	801f198 <traceIF_itmPrint>
 801d4f6:	4620      	mov	r0, r4
 801d4f8:	f001 fe0b 	bl	801f112 <crs_strlen>
 801d4fc:	b283      	uxth	r3, r0
 801d4fe:	4622      	mov	r2, r4
 801d500:	2110      	movs	r1, #16
 801d502:	2007      	movs	r0, #7
 801d504:	f001 fe6a 	bl	801f1dc <traceIF_uartPrint>
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 2, ERROR_FATAL);
 801d508:	2203      	movs	r2, #3
 801d50a:	2102      	movs	r1, #2
 801d50c:	2007      	movs	r0, #7
 801d50e:	f000 fe1d 	bl	801e14c <ERROR_Handler>
}
 801d512:	b003      	add	sp, #12
 801d514:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CST_set_state(CST_MODEM_RESET_STATE);
 801d516:	200c      	movs	r0, #12
 801d518:	f7fd fe2a 	bl	801b170 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801d51c:	2101      	movs	r1, #1
 801d51e:	2000      	movs	r0, #0
 801d520:	f7fd fd62 	bl	801afe8 <CST_send_message>
    cst_context.fail_cause    = fail_cause;
 801d524:	4b03      	ldr	r3, [pc, #12]	; (801d534 <CST_config_fail+0xe0>)
 801d526:	709f      	strb	r7, [r3, #2]
 801d528:	e7f3      	b.n	801d512 <CST_config_fail+0xbe>
 801d52a:	bf00      	nop
 801d52c:	20004ddc 	.word	0x20004ddc
 801d530:	0803493c 	.word	0x0803493c
 801d534:	200000b0 	.word	0x200000b0
 801d538:	08034954 	.word	0x08034954

0801d53c <CST_modem_define_pdn>:
{
 801d53c:	b570      	push	{r4, r5, r6, lr}
 801d53e:	b092      	sub	sp, #72	; 0x48
 801d540:	4604      	mov	r4, r0
 801d542:	460e      	mov	r6, r1
 801d544:	4615      	mov	r5, r2
  (void)memset((void *)&pdn_conf, 0, sizeof(CS_PDN_configuration_t));
 801d546:	2241      	movs	r2, #65	; 0x41
 801d548:	2100      	movs	r1, #0
 801d54a:	a801      	add	r0, sp, #4
 801d54c:	f008 fc03 	bl	8025d56 <memset>
  if (crs_strlen(apn) == 0U)
 801d550:	4620      	mov	r0, r4
 801d552:	f001 fdde 	bl	801f112 <crs_strlen>
 801d556:	bb88      	cbnz	r0, 801d5bc <CST_modem_define_pdn+0x80>
    size =  crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].username) + 1U;
 801d558:	4b39      	ldr	r3, [pc, #228]	; (801d640 <CST_modem_define_pdn+0x104>)
 801d55a:	7c18      	ldrb	r0, [r3, #16]
 801d55c:	2362      	movs	r3, #98	; 0x62
 801d55e:	fb03 f000 	mul.w	r0, r3, r0
 801d562:	3028      	adds	r0, #40	; 0x28
 801d564:	4b37      	ldr	r3, [pc, #220]	; (801d644 <CST_modem_define_pdn+0x108>)
 801d566:	4418      	add	r0, r3
 801d568:	3005      	adds	r0, #5
 801d56a:	f001 fdd2 	bl	801f112 <crs_strlen>
 801d56e:	1c42      	adds	r2, r0, #1
    if (size <= MAX_SIZE_USERNAME)
 801d570:	2a20      	cmp	r2, #32
 801d572:	d835      	bhi.n	801d5e0 <CST_modem_define_pdn+0xa4>
                   (CRC_CHAR_t *)cst_cellular_params.sim_slot[cst_context.sim_slot_index].username,
 801d574:	4b32      	ldr	r3, [pc, #200]	; (801d640 <CST_modem_define_pdn+0x104>)
 801d576:	7c1d      	ldrb	r5, [r3, #16]
 801d578:	2362      	movs	r3, #98	; 0x62
 801d57a:	fb03 f505 	mul.w	r5, r3, r5
 801d57e:	f105 0128 	add.w	r1, r5, #40	; 0x28
 801d582:	4e30      	ldr	r6, [pc, #192]	; (801d644 <CST_modem_define_pdn+0x108>)
 801d584:	4431      	add	r1, r6
      (void)memcpy((CRC_CHAR_t *)pdn_conf.username,
 801d586:	3105      	adds	r1, #5
 801d588:	f10d 0005 	add.w	r0, sp, #5
 801d58c:	f008 fcc0 	bl	8025f10 <memcpy>
      size =  crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].password) + 1U;
 801d590:	f105 0048 	add.w	r0, r5, #72	; 0x48
 801d594:	4430      	add	r0, r6
 801d596:	3005      	adds	r0, #5
 801d598:	f001 fdbb 	bl	801f112 <crs_strlen>
 801d59c:	1c42      	adds	r2, r0, #1
      if (size <= MAX_SIZE_USERNAME)
 801d59e:	2a20      	cmp	r2, #32
 801d5a0:	d81e      	bhi.n	801d5e0 <CST_modem_define_pdn+0xa4>
                     (CRC_CHAR_t *)cst_cellular_params.sim_slot[cst_context.sim_slot_index].password,
 801d5a2:	4b27      	ldr	r3, [pc, #156]	; (801d640 <CST_modem_define_pdn+0x104>)
 801d5a4:	7c19      	ldrb	r1, [r3, #16]
 801d5a6:	2362      	movs	r3, #98	; 0x62
 801d5a8:	fb03 f101 	mul.w	r1, r3, r1
 801d5ac:	3148      	adds	r1, #72	; 0x48
 801d5ae:	4431      	add	r1, r6
        (void)memcpy((CRC_CHAR_t *)pdn_conf.password,
 801d5b0:	3105      	adds	r1, #5
 801d5b2:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 801d5b6:	f008 fcab 	bl	8025f10 <memcpy>
 801d5ba:	e011      	b.n	801d5e0 <CST_modem_define_pdn+0xa4>
                 crs_strlen(username) + 1U);
 801d5bc:	4630      	mov	r0, r6
 801d5be:	f001 fda8 	bl	801f112 <crs_strlen>
    (void)memcpy((CRC_CHAR_t *)pdn_conf.username,
 801d5c2:	1c42      	adds	r2, r0, #1
 801d5c4:	4631      	mov	r1, r6
 801d5c6:	f10d 0005 	add.w	r0, sp, #5
 801d5ca:	f008 fca1 	bl	8025f10 <memcpy>
                 crs_strlen(password) + 1U);
 801d5ce:	4628      	mov	r0, r5
 801d5d0:	f001 fd9f 	bl	801f112 <crs_strlen>
    (void)memcpy((CRC_CHAR_t *)pdn_conf.password,
 801d5d4:	1c42      	adds	r2, r0, #1
 801d5d6:	4629      	mov	r1, r5
 801d5d8:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 801d5dc:	f008 fc98 	bl	8025f10 <memcpy>
  if (crs_strlen(apn) == 0U)
 801d5e0:	4620      	mov	r0, r4
 801d5e2:	f001 fd96 	bl	801f112 <crs_strlen>
 801d5e6:	b9a8      	cbnz	r0, 801d614 <CST_modem_define_pdn+0xd8>
    cs_status = osCDS_define_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801d5e8:	4e15      	ldr	r6, [pc, #84]	; (801d640 <CST_modem_define_pdn+0x104>)
 801d5ea:	7c33      	ldrb	r3, [r6, #16]
 801d5ec:	4c15      	ldr	r4, [pc, #84]	; (801d644 <CST_modem_define_pdn+0x108>)
 801d5ee:	2562      	movs	r5, #98	; 0x62
 801d5f0:	fb05 4303 	mla	r3, r5, r3, r4
 801d5f4:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801d5f8:	f7fc fde1 	bl	801a1be <cst_get_cid_value>
                                 (const uint8_t *)cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn,
 801d5fc:	7c31      	ldrb	r1, [r6, #16]
 801d5fe:	fb05 f101 	mul.w	r1, r5, r1
 801d602:	3108      	adds	r1, #8
 801d604:	4421      	add	r1, r4
    cs_status = osCDS_define_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801d606:	aa01      	add	r2, sp, #4
 801d608:	3104      	adds	r1, #4
 801d60a:	f7fd fa8f 	bl	801ab2c <osCDS_define_pdn>
  if (cs_status != CELLULAR_OK)
 801d60e:	b980      	cbnz	r0, 801d632 <CST_modem_define_pdn+0xf6>
}
 801d610:	b012      	add	sp, #72	; 0x48
 801d612:	bd70      	pop	{r4, r5, r6, pc}
    cs_status = osCDS_define_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801d614:	4b0a      	ldr	r3, [pc, #40]	; (801d640 <CST_modem_define_pdn+0x104>)
 801d616:	7c1a      	ldrb	r2, [r3, #16]
 801d618:	4b0a      	ldr	r3, [pc, #40]	; (801d644 <CST_modem_define_pdn+0x108>)
 801d61a:	2162      	movs	r1, #98	; 0x62
 801d61c:	fb01 3302 	mla	r3, r1, r2, r3
 801d620:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801d624:	f7fc fdcb 	bl	801a1be <cst_get_cid_value>
 801d628:	aa01      	add	r2, sp, #4
 801d62a:	4621      	mov	r1, r4
 801d62c:	f7fd fa7e 	bl	801ab2c <osCDS_define_pdn>
 801d630:	e7ed      	b.n	801d60e <CST_modem_define_pdn+0xd2>
    CST_config_fail(((uint8_t *)"CST_modem_define_pdn"),
 801d632:	2305      	movs	r3, #5
 801d634:	4a04      	ldr	r2, [pc, #16]	; (801d648 <CST_modem_define_pdn+0x10c>)
 801d636:	2107      	movs	r1, #7
 801d638:	4804      	ldr	r0, [pc, #16]	; (801d64c <CST_modem_define_pdn+0x110>)
 801d63a:	f7ff ff0b 	bl	801d454 <CST_config_fail>
}
 801d63e:	e7e7      	b.n	801d610 <CST_modem_define_pdn+0xd4>
 801d640:	200000b0 	.word	0x200000b0
 801d644:	20004160 	.word	0x20004160
 801d648:	200000c5 	.word	0x200000c5
 801d64c:	08034994 	.word	0x08034994

0801d650 <CST_modem_sim_init>:
{
 801d650:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d654:	b0e2      	sub	sp, #392	; 0x188
  PRINT_CELLULAR_SERVICE("*********** CST_modem_sim_init ********\n\r")
 801d656:	4d98      	ldr	r5, [pc, #608]	; (801d8b8 <CST_modem_sim_init+0x268>)
 801d658:	4c98      	ldr	r4, [pc, #608]	; (801d8bc <CST_modem_sim_init+0x26c>)
 801d65a:	f105 0e20 	add.w	lr, r5, #32
 801d65e:	46ac      	mov	ip, r5
 801d660:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801d664:	6020      	str	r0, [r4, #0]
 801d666:	6061      	str	r1, [r4, #4]
 801d668:	60a2      	str	r2, [r4, #8]
 801d66a:	60e3      	str	r3, [r4, #12]
 801d66c:	4665      	mov	r5, ip
 801d66e:	3410      	adds	r4, #16
 801d670:	45f4      	cmp	ip, lr
 801d672:	d1f4      	bne.n	801d65e <CST_modem_sim_init+0xe>
 801d674:	cd03      	ldmia	r5!, {r0, r1}
 801d676:	6020      	str	r0, [r4, #0]
 801d678:	6061      	str	r1, [r4, #4]
 801d67a:	882b      	ldrh	r3, [r5, #0]
 801d67c:	8123      	strh	r3, [r4, #8]
 801d67e:	4c8f      	ldr	r4, [pc, #572]	; (801d8bc <CST_modem_sim_init+0x26c>)
 801d680:	4620      	mov	r0, r4
 801d682:	f001 fd46 	bl	801f112 <crs_strlen>
 801d686:	b283      	uxth	r3, r0
 801d688:	4622      	mov	r2, r4
 801d68a:	2101      	movs	r1, #1
 801d68c:	2007      	movs	r0, #7
 801d68e:	f001 fd83 	bl	801f198 <traceIF_itmPrint>
 801d692:	4620      	mov	r0, r4
 801d694:	f001 fd3d 	bl	801f112 <crs_strlen>
 801d698:	b283      	uxth	r3, r0
 801d69a:	4622      	mov	r2, r4
 801d69c:	2101      	movs	r1, #1
 801d69e:	2007      	movs	r0, #7
 801d6a0:	f001 fd9c 	bl	801f1dc <traceIF_uartPrint>
  (void)osCS_sim_select(cst_convert_sim_socket_type(cst_sim_info.active_slot));
 801d6a4:	4b86      	ldr	r3, [pc, #536]	; (801d8c0 <CST_modem_sim_init+0x270>)
 801d6a6:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
 801d6aa:	f7ff f96f 	bl	801c98c <cst_convert_sim_socket_type>
 801d6ae:	f7fd fac1 	bl	801ac34 <osCS_sim_select>
  (void)rtosalDelay(10);  /* waiting for 10ms after sim selection */
 801d6b2:	200a      	movs	r0, #10
 801d6b4:	f001 fc85 	bl	801efc2 <rtosalDelay>
  if (cst_cellular_params.target_state == DC_TARGET_STATE_SIM_ONLY)
 801d6b8:	4b82      	ldr	r3, [pc, #520]	; (801d8c4 <CST_modem_sim_init+0x274>)
 801d6ba:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801d6be:	2b01      	cmp	r3, #1
 801d6c0:	d043      	beq.n	801d74a <CST_modem_sim_init+0xfa>
  else if (cst_cellular_params.target_state == DC_TARGET_STATE_FULL)
 801d6c2:	2b02      	cmp	r3, #2
 801d6c4:	f000 8112 	beq.w	801d8ec <CST_modem_sim_init+0x29c>
    __NOP(); /* Nothing to do */
 801d6c8:	bf00      	nop
  cs_status = CELLULAR_OK;
 801d6ca:	2400      	movs	r4, #0
  else if (cs_status == CELLULAR_SIM_PIN_OR_PUK_LOCKED)
 801d6cc:	2c05      	cmp	r4, #5
 801d6ce:	f000 826f 	beq.w	801dbb0 <CST_modem_sim_init+0x560>
    __NOP(); /* Nothing to do */
 801d6d2:	bf00      	nop
  if ((cs_status == CELLULAR_SIM_NOT_INSERTED) || (cs_status == CELLULAR_ERROR) || (cs_status == CELLULAR_SIM_ERROR))
 801d6d4:	2c04      	cmp	r4, #4
 801d6d6:	d004      	beq.n	801d6e2 <CST_modem_sim_init+0x92>
 801d6d8:	2c01      	cmp	r4, #1
 801d6da:	d002      	beq.n	801d6e2 <CST_modem_sim_init+0x92>
 801d6dc:	2c07      	cmp	r4, #7
 801d6de:	f040 8317 	bne.w	801dd10 <CST_modem_sim_init+0x6c0>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d6e2:	4c77      	ldr	r4, [pc, #476]	; (801d8c0 <CST_modem_sim_init+0x270>)
 801d6e4:	2330      	movs	r3, #48	; 0x30
 801d6e6:	4622      	mov	r2, r4
 801d6e8:	4977      	ldr	r1, [pc, #476]	; (801d8c8 <CST_modem_sim_init+0x278>)
 801d6ea:	8809      	ldrh	r1, [r1, #0]
 801d6ec:	4877      	ldr	r0, [pc, #476]	; (801d8cc <CST_modem_sim_init+0x27c>)
 801d6ee:	f004 f96b 	bl	80219c8 <dc_com_read>
    cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_ERROR;
 801d6f2:	4a77      	ldr	r2, [pc, #476]	; (801d8d0 <CST_modem_sim_init+0x280>)
 801d6f4:	7c13      	ldrb	r3, [r2, #16]
 801d6f6:	18e1      	adds	r1, r4, r3
 801d6f8:	2006      	movs	r0, #6
 801d6fa:	f881 002b 	strb.w	r0, [r1, #43]	; 0x2b
    cst_sim_info.rt_state   = DC_SERVICE_ON;
 801d6fe:	2107      	movs	r1, #7
 801d700:	7221      	strb	r1, [r4, #8]
    cst_context.sim_slot_index++;
 801d702:	3301      	adds	r3, #1
 801d704:	b2db      	uxtb	r3, r3
 801d706:	7413      	strb	r3, [r2, #16]
    if (cst_context.sim_slot_index  >= cst_cellular_params.sim_slot_nb)
 801d708:	4a6e      	ldr	r2, [pc, #440]	; (801d8c4 <CST_modem_sim_init+0x274>)
 801d70a:	7a92      	ldrb	r2, [r2, #10]
 801d70c:	4293      	cmp	r3, r2
 801d70e:	f080 82d4 	bcs.w	801dcba <CST_modem_sim_init+0x66a>
    cst_sim_info.active_slot = cst_cellular_params.sim_slot[cst_context.sim_slot_index].sim_slot_type;
 801d712:	4c6f      	ldr	r4, [pc, #444]	; (801d8d0 <CST_modem_sim_init+0x280>)
 801d714:	7c21      	ldrb	r1, [r4, #16]
 801d716:	4b6b      	ldr	r3, [pc, #428]	; (801d8c4 <CST_modem_sim_init+0x274>)
 801d718:	2262      	movs	r2, #98	; 0x62
 801d71a:	fb02 3301 	mla	r3, r2, r1, r3
 801d71e:	7adb      	ldrb	r3, [r3, #11]
 801d720:	4a67      	ldr	r2, [pc, #412]	; (801d8c0 <CST_modem_sim_init+0x270>)
 801d722:	f882 302a 	strb.w	r3, [r2, #42]	; 0x2a
    cst_sim_info.index_slot  = cst_context.sim_slot_index;
 801d726:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d72a:	2330      	movs	r3, #48	; 0x30
 801d72c:	4966      	ldr	r1, [pc, #408]	; (801d8c8 <CST_modem_sim_init+0x278>)
 801d72e:	8809      	ldrh	r1, [r1, #0]
 801d730:	4866      	ldr	r0, [pc, #408]	; (801d8cc <CST_modem_sim_init+0x27c>)
 801d732:	f004 f8fd 	bl	8021930 <dc_com_write>
    CST_config_fail(((uint8_t *)"CST_modem_sim_init"),
 801d736:	2305      	movs	r3, #5
 801d738:	f104 0218 	add.w	r2, r4, #24
 801d73c:	2108      	movs	r1, #8
 801d73e:	4865      	ldr	r0, [pc, #404]	; (801d8d4 <CST_modem_sim_init+0x284>)
 801d740:	f7ff fe88 	bl	801d454 <CST_config_fail>
}
 801d744:	b062      	add	sp, #392	; 0x188
 801d746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    cs_status = osCDS_init_modem(CS_CMI_SIM_ONLY, CELLULAR_FALSE, CST_SIM_PINCODE);
 801d74a:	4a63      	ldr	r2, [pc, #396]	; (801d8d8 <CST_modem_sim_init+0x288>)
 801d74c:	2100      	movs	r1, #0
 801d74e:	2002      	movs	r0, #2
 801d750:	f7fd f998 	bl	801aa84 <osCDS_init_modem>
 801d754:	4604      	mov	r4, r0
  if (cs_status == CELLULAR_SIM_INCORRECT_PASSWORD)
 801d756:	2c06      	cmp	r4, #6
 801d758:	d1b8      	bne.n	801d6cc <CST_modem_sim_init+0x7c>
    PRINT_FORCE("==================================\n\r")
 801d75a:	4e60      	ldr	r6, [pc, #384]	; (801d8dc <CST_modem_sim_init+0x28c>)
 801d75c:	4c57      	ldr	r4, [pc, #348]	; (801d8bc <CST_modem_sim_init+0x26c>)
 801d75e:	f106 0c20 	add.w	ip, r6, #32
 801d762:	4635      	mov	r5, r6
 801d764:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d766:	6020      	str	r0, [r4, #0]
 801d768:	6061      	str	r1, [r4, #4]
 801d76a:	60a2      	str	r2, [r4, #8]
 801d76c:	60e3      	str	r3, [r4, #12]
 801d76e:	462e      	mov	r6, r5
 801d770:	3410      	adds	r4, #16
 801d772:	4565      	cmp	r5, ip
 801d774:	d1f5      	bne.n	801d762 <CST_modem_sim_init+0x112>
 801d776:	6828      	ldr	r0, [r5, #0]
 801d778:	6020      	str	r0, [r4, #0]
 801d77a:	792b      	ldrb	r3, [r5, #4]
 801d77c:	7123      	strb	r3, [r4, #4]
 801d77e:	4c4f      	ldr	r4, [pc, #316]	; (801d8bc <CST_modem_sim_init+0x26c>)
 801d780:	4620      	mov	r0, r4
 801d782:	f001 fcc6 	bl	801f112 <crs_strlen>
 801d786:	b283      	uxth	r3, r0
 801d788:	4622      	mov	r2, r4
 801d78a:	2101      	movs	r1, #1
 801d78c:	2007      	movs	r0, #7
 801d78e:	f001 fd03 	bl	801f198 <traceIF_itmPrint>
 801d792:	4620      	mov	r0, r4
 801d794:	f001 fcbd 	bl	801f112 <crs_strlen>
 801d798:	b282      	uxth	r2, r0
 801d79a:	4621      	mov	r1, r4
 801d79c:	2007      	movs	r0, #7
 801d79e:	f001 fd35 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE(" WARNING: WRONG PIN CODE !!!\n\r")
 801d7a2:	4d4f      	ldr	r5, [pc, #316]	; (801d8e0 <CST_modem_sim_init+0x290>)
 801d7a4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d7a6:	6020      	str	r0, [r4, #0]
 801d7a8:	6061      	str	r1, [r4, #4]
 801d7aa:	60a2      	str	r2, [r4, #8]
 801d7ac:	60e3      	str	r3, [r4, #12]
 801d7ae:	cd07      	ldmia	r5!, {r0, r1, r2}
 801d7b0:	6120      	str	r0, [r4, #16]
 801d7b2:	6161      	str	r1, [r4, #20]
 801d7b4:	61a2      	str	r2, [r4, #24]
 801d7b6:	882a      	ldrh	r2, [r5, #0]
 801d7b8:	78ab      	ldrb	r3, [r5, #2]
 801d7ba:	83a2      	strh	r2, [r4, #28]
 801d7bc:	77a3      	strb	r3, [r4, #30]
 801d7be:	4620      	mov	r0, r4
 801d7c0:	f001 fca7 	bl	801f112 <crs_strlen>
 801d7c4:	b283      	uxth	r3, r0
 801d7c6:	4622      	mov	r2, r4
 801d7c8:	2101      	movs	r1, #1
 801d7ca:	2007      	movs	r0, #7
 801d7cc:	f001 fce4 	bl	801f198 <traceIF_itmPrint>
 801d7d0:	4620      	mov	r0, r4
 801d7d2:	f001 fc9e 	bl	801f112 <crs_strlen>
 801d7d6:	b282      	uxth	r2, r0
 801d7d8:	4621      	mov	r1, r4
 801d7da:	2007      	movs	r0, #7
 801d7dc:	f001 fd16 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE(" DO NOT RESTART THE BOARD WITHOUT SETTING A CORRECT PIN CODE\n\r")
 801d7e0:	4d40      	ldr	r5, [pc, #256]	; (801d8e4 <CST_modem_sim_init+0x294>)
 801d7e2:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 801d7e6:	462e      	mov	r6, r5
 801d7e8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d7ea:	6020      	str	r0, [r4, #0]
 801d7ec:	6061      	str	r1, [r4, #4]
 801d7ee:	60a2      	str	r2, [r4, #8]
 801d7f0:	60e3      	str	r3, [r4, #12]
 801d7f2:	4635      	mov	r5, r6
 801d7f4:	3410      	adds	r4, #16
 801d7f6:	4566      	cmp	r6, ip
 801d7f8:	d1f5      	bne.n	801d7e6 <CST_modem_sim_init+0x196>
 801d7fa:	cd07      	ldmia	r5!, {r0, r1, r2}
 801d7fc:	6020      	str	r0, [r4, #0]
 801d7fe:	6061      	str	r1, [r4, #4]
 801d800:	60a2      	str	r2, [r4, #8]
 801d802:	882a      	ldrh	r2, [r5, #0]
 801d804:	78ab      	ldrb	r3, [r5, #2]
 801d806:	81a2      	strh	r2, [r4, #12]
 801d808:	73a3      	strb	r3, [r4, #14]
 801d80a:	4c2c      	ldr	r4, [pc, #176]	; (801d8bc <CST_modem_sim_init+0x26c>)
 801d80c:	4620      	mov	r0, r4
 801d80e:	f001 fc80 	bl	801f112 <crs_strlen>
 801d812:	b283      	uxth	r3, r0
 801d814:	4622      	mov	r2, r4
 801d816:	2101      	movs	r1, #1
 801d818:	2007      	movs	r0, #7
 801d81a:	f001 fcbd 	bl	801f198 <traceIF_itmPrint>
 801d81e:	4620      	mov	r0, r4
 801d820:	f001 fc77 	bl	801f112 <crs_strlen>
 801d824:	b282      	uxth	r2, r0
 801d826:	4621      	mov	r1, r4
 801d828:	2007      	movs	r0, #7
 801d82a:	f001 fcef 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE(" TO AVOID LOCKING THE SIM ! \n\r")
 801d82e:	4d2e      	ldr	r5, [pc, #184]	; (801d8e8 <CST_modem_sim_init+0x298>)
 801d830:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d832:	6020      	str	r0, [r4, #0]
 801d834:	6061      	str	r1, [r4, #4]
 801d836:	60a2      	str	r2, [r4, #8]
 801d838:	60e3      	str	r3, [r4, #12]
 801d83a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801d83c:	6120      	str	r0, [r4, #16]
 801d83e:	6161      	str	r1, [r4, #20]
 801d840:	61a2      	str	r2, [r4, #24]
 801d842:	882a      	ldrh	r2, [r5, #0]
 801d844:	78ab      	ldrb	r3, [r5, #2]
 801d846:	83a2      	strh	r2, [r4, #28]
 801d848:	77a3      	strb	r3, [r4, #30]
 801d84a:	4620      	mov	r0, r4
 801d84c:	f001 fc61 	bl	801f112 <crs_strlen>
 801d850:	b283      	uxth	r3, r0
 801d852:	4622      	mov	r2, r4
 801d854:	2101      	movs	r1, #1
 801d856:	2007      	movs	r0, #7
 801d858:	f001 fc9e 	bl	801f198 <traceIF_itmPrint>
 801d85c:	4620      	mov	r0, r4
 801d85e:	f001 fc58 	bl	801f112 <crs_strlen>
 801d862:	b282      	uxth	r2, r0
 801d864:	4621      	mov	r1, r4
 801d866:	2007      	movs	r0, #7
 801d868:	f001 fcd0 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE("==================================\n\r")
 801d86c:	4e1b      	ldr	r6, [pc, #108]	; (801d8dc <CST_modem_sim_init+0x28c>)
 801d86e:	f106 0c20 	add.w	ip, r6, #32
 801d872:	4635      	mov	r5, r6
 801d874:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d876:	6020      	str	r0, [r4, #0]
 801d878:	6061      	str	r1, [r4, #4]
 801d87a:	60a2      	str	r2, [r4, #8]
 801d87c:	60e3      	str	r3, [r4, #12]
 801d87e:	462e      	mov	r6, r5
 801d880:	3410      	adds	r4, #16
 801d882:	4565      	cmp	r5, ip
 801d884:	d1f5      	bne.n	801d872 <CST_modem_sim_init+0x222>
 801d886:	6828      	ldr	r0, [r5, #0]
 801d888:	6020      	str	r0, [r4, #0]
 801d88a:	792b      	ldrb	r3, [r5, #4]
 801d88c:	7123      	strb	r3, [r4, #4]
 801d88e:	4c0b      	ldr	r4, [pc, #44]	; (801d8bc <CST_modem_sim_init+0x26c>)
 801d890:	4620      	mov	r0, r4
 801d892:	f001 fc3e 	bl	801f112 <crs_strlen>
 801d896:	b283      	uxth	r3, r0
 801d898:	4622      	mov	r2, r4
 801d89a:	2101      	movs	r1, #1
 801d89c:	2007      	movs	r0, #7
 801d89e:	f001 fc7b 	bl	801f198 <traceIF_itmPrint>
 801d8a2:	4620      	mov	r0, r4
 801d8a4:	f001 fc35 	bl	801f112 <crs_strlen>
 801d8a8:	b282      	uxth	r2, r0
 801d8aa:	4621      	mov	r1, r4
 801d8ac:	2007      	movs	r0, #7
 801d8ae:	f001 fcad 	bl	801f20c <traceIF_uartPrintForce>
      __NOP(); /* Nothing to do */
 801d8b2:	bf00      	nop
    for (;;)
 801d8b4:	e7fd      	b.n	801d8b2 <CST_modem_sim_init+0x262>
 801d8b6:	bf00      	nop
 801d8b8:	080349ac 	.word	0x080349ac
 801d8bc:	20004ddc 	.word	0x20004ddc
 801d8c0:	20004338 	.word	0x20004338
 801d8c4:	20004160 	.word	0x20004160
 801d8c8:	2000023c 	.word	0x2000023c
 801d8cc:	200058b0 	.word	0x200058b0
 801d8d0:	200000b0 	.word	0x200000b0
 801d8d4:	08034bdc 	.word	0x08034bdc
 801d8d8:	08034f74 	.word	0x08034f74
 801d8dc:	08034acc 	.word	0x08034acc
 801d8e0:	08034af4 	.word	0x08034af4
 801d8e4:	08034b14 	.word	0x08034b14
 801d8e8:	08034b54 	.word	0x08034b54
    PRINT_CELLULAR_SERVICE("CST_modem_sim_init : check SIM First \n\r")
 801d8ec:	f8df c2b8 	ldr.w	ip, [pc, #696]	; 801dba8 <CST_modem_sim_init+0x558>
 801d8f0:	4da3      	ldr	r5, [pc, #652]	; (801db80 <CST_modem_sim_init+0x530>)
 801d8f2:	f10c 0620 	add.w	r6, ip, #32
 801d8f6:	4664      	mov	r4, ip
 801d8f8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d8fa:	6028      	str	r0, [r5, #0]
 801d8fc:	6069      	str	r1, [r5, #4]
 801d8fe:	60aa      	str	r2, [r5, #8]
 801d900:	60eb      	str	r3, [r5, #12]
 801d902:	46a4      	mov	ip, r4
 801d904:	3510      	adds	r5, #16
 801d906:	42b4      	cmp	r4, r6
 801d908:	d1f5      	bne.n	801d8f6 <CST_modem_sim_init+0x2a6>
 801d90a:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 801d90e:	6028      	str	r0, [r5, #0]
 801d910:	6069      	str	r1, [r5, #4]
 801d912:	4c9b      	ldr	r4, [pc, #620]	; (801db80 <CST_modem_sim_init+0x530>)
 801d914:	4620      	mov	r0, r4
 801d916:	f001 fbfc 	bl	801f112 <crs_strlen>
 801d91a:	b283      	uxth	r3, r0
 801d91c:	4622      	mov	r2, r4
 801d91e:	2101      	movs	r1, #1
 801d920:	2007      	movs	r0, #7
 801d922:	f001 fc39 	bl	801f198 <traceIF_itmPrint>
 801d926:	4620      	mov	r0, r4
 801d928:	f001 fbf3 	bl	801f112 <crs_strlen>
 801d92c:	b283      	uxth	r3, r0
 801d92e:	4622      	mov	r2, r4
 801d930:	2101      	movs	r1, #1
 801d932:	2007      	movs	r0, #7
 801d934:	f001 fc52 	bl	801f1dc <traceIF_uartPrint>
    cs_status = osCDS_init_modem(CS_CMI_SIM_ONLY, CELLULAR_FALSE, CST_SIM_PINCODE);
 801d938:	4a92      	ldr	r2, [pc, #584]	; (801db84 <CST_modem_sim_init+0x534>)
 801d93a:	2100      	movs	r1, #0
 801d93c:	2002      	movs	r0, #2
 801d93e:	f7fd f8a1 	bl	801aa84 <osCDS_init_modem>
    if (cs_status == CELLULAR_OK)
 801d942:	4604      	mov	r4, r0
 801d944:	2800      	cmp	r0, #0
 801d946:	f47f af06 	bne.w	801d756 <CST_modem_sim_init+0x106>
      cst_imsi_info.field_requested = CS_DIF_IMSI_PRESENT;
 801d94a:	2320      	movs	r3, #32
 801d94c:	f8ad 3018 	strh.w	r3, [sp, #24]
      cs_status = osCDS_get_device_info(&cst_imsi_info);
 801d950:	a806      	add	r0, sp, #24
 801d952:	f7fd f833 	bl	801a9bc <osCDS_get_device_info>
 801d956:	4606      	mov	r6, r0
      (void)ATutil_convertHexaStringToInt64(cst_imsi_info.u.imsi, 15U, &cst_imsi_high, &cst_imsi_low);
 801d958:	ab03      	add	r3, sp, #12
 801d95a:	aa02      	add	r2, sp, #8
 801d95c:	210f      	movs	r1, #15
 801d95e:	f10d 001a 	add.w	r0, sp, #26
 801d962:	f7f7 fa1b 	bl	8014d9c <ATutil_convertHexaStringToInt64>
      (void)memcpy(mmc_mnc, cst_imsi_info.u.imsi, 5);
 801d966:	ab04      	add	r3, sp, #16
 801d968:	f8dd 001a 	ldr.w	r0, [sp, #26]
 801d96c:	9004      	str	r0, [sp, #16]
 801d96e:	f89d 201e 	ldrb.w	r2, [sp, #30]
 801d972:	f88d 2014 	strb.w	r2, [sp, #20]
      mmc_mnc[5] = 0;
 801d976:	2200      	movs	r2, #0
 801d978:	f88d 2015 	strb.w	r2, [sp, #21]
      PRINT_CELLULAR_SERVICE(" -IMSI: %lx%lx\n\r -MMC/MNC: %s\n\r", cst_imsi_high, cst_imsi_low, mmc_mnc)
 801d97c:	4d80      	ldr	r5, [pc, #512]	; (801db80 <CST_modem_sim_init+0x530>)
 801d97e:	9300      	str	r3, [sp, #0]
 801d980:	9b03      	ldr	r3, [sp, #12]
 801d982:	9a02      	ldr	r2, [sp, #8]
 801d984:	4980      	ldr	r1, [pc, #512]	; (801db88 <CST_modem_sim_init+0x538>)
 801d986:	4628      	mov	r0, r5
 801d988:	f008 f972 	bl	8025c70 <sprintf>
 801d98c:	4628      	mov	r0, r5
 801d98e:	f001 fbc0 	bl	801f112 <crs_strlen>
 801d992:	b283      	uxth	r3, r0
 801d994:	462a      	mov	r2, r5
 801d996:	2101      	movs	r1, #1
 801d998:	2007      	movs	r0, #7
 801d99a:	f001 fbfd 	bl	801f198 <traceIF_itmPrint>
 801d99e:	4628      	mov	r0, r5
 801d9a0:	f001 fbb7 	bl	801f112 <crs_strlen>
 801d9a4:	b283      	uxth	r3, r0
 801d9a6:	462a      	mov	r2, r5
 801d9a8:	2101      	movs	r1, #1
 801d9aa:	2007      	movs	r0, #7
 801d9ac:	f001 fc16 	bl	801f1dc <traceIF_uartPrint>
      if (cst_cellular_params.set_pdn_mode != 0U)
 801d9b0:	4b76      	ldr	r3, [pc, #472]	; (801db8c <CST_modem_sim_init+0x53c>)
 801d9b2:	7a5b      	ldrb	r3, [r3, #9]
 801d9b4:	b90b      	cbnz	r3, 801d9ba <CST_modem_sim_init+0x36a>
 801d9b6:	4634      	mov	r4, r6
 801d9b8:	e6cd      	b.n	801d756 <CST_modem_sim_init+0x106>
        if (crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn) == 0U)
 801d9ba:	4b75      	ldr	r3, [pc, #468]	; (801db90 <CST_modem_sim_init+0x540>)
 801d9bc:	7c18      	ldrb	r0, [r3, #16]
 801d9be:	2362      	movs	r3, #98	; 0x62
 801d9c0:	fb03 f000 	mul.w	r0, r3, r0
 801d9c4:	3008      	adds	r0, #8
 801d9c6:	4b71      	ldr	r3, [pc, #452]	; (801db8c <CST_modem_sim_init+0x53c>)
 801d9c8:	4418      	add	r0, r3
 801d9ca:	3004      	adds	r0, #4
 801d9cc:	f001 fba1 	bl	801f112 <crs_strlen>
 801d9d0:	2800      	cmp	r0, #0
 801d9d2:	f040 80b6 	bne.w	801db42 <CST_modem_sim_init+0x4f2>
          for (uint8_t i = 0U; i < MMCMNC_APN_MAX; i++)
 801d9d6:	4625      	mov	r5, r4
          apn_found = false;
 801d9d8:	2600      	movs	r6, #0
 801d9da:	e001      	b.n	801d9e0 <CST_modem_sim_init+0x390>
          for (uint8_t i = 0U; i < MMCMNC_APN_MAX; i++)
 801d9dc:	3501      	adds	r5, #1
 801d9de:	b2ed      	uxtb	r5, r5
 801d9e0:	2d04      	cmp	r5, #4
 801d9e2:	d82a      	bhi.n	801da3a <CST_modem_sim_init+0x3ea>
            if (memcmp(mmc_mnc, mmcmnc_apn_a[i].mmcmnc, sizeof(mmc_mnc)) == 0)
 801d9e4:	eb05 1345 	add.w	r3, r5, r5, lsl #5
 801d9e8:	2206      	movs	r2, #6
 801d9ea:	496a      	ldr	r1, [pc, #424]	; (801db94 <CST_modem_sim_init+0x544>)
 801d9ec:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 801d9f0:	a804      	add	r0, sp, #16
 801d9f2:	f008 f9a0 	bl	8025d36 <memcmp>
 801d9f6:	2800      	cmp	r0, #0
 801d9f8:	d1f0      	bne.n	801d9dc <CST_modem_sim_init+0x38c>
              PRINT_CELLULAR_SERVICE(" -Found corresponding APN: \"%s\" in table\n\r", mmcmnc_apn_a[i].apn)
 801d9fa:	eb05 1345 	add.w	r3, r5, r5, lsl #5
 801d9fe:	4a65      	ldr	r2, [pc, #404]	; (801db94 <CST_modem_sim_init+0x544>)
 801da00:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801da04:	4c5e      	ldr	r4, [pc, #376]	; (801db80 <CST_modem_sim_init+0x530>)
 801da06:	3206      	adds	r2, #6
 801da08:	4963      	ldr	r1, [pc, #396]	; (801db98 <CST_modem_sim_init+0x548>)
 801da0a:	4620      	mov	r0, r4
 801da0c:	f008 f930 	bl	8025c70 <sprintf>
 801da10:	4620      	mov	r0, r4
 801da12:	f001 fb7e 	bl	801f112 <crs_strlen>
 801da16:	b283      	uxth	r3, r0
 801da18:	4622      	mov	r2, r4
 801da1a:	2101      	movs	r1, #1
 801da1c:	2007      	movs	r0, #7
 801da1e:	f001 fbbb 	bl	801f198 <traceIF_itmPrint>
 801da22:	4620      	mov	r0, r4
 801da24:	f001 fb75 	bl	801f112 <crs_strlen>
 801da28:	b283      	uxth	r3, r0
 801da2a:	4622      	mov	r2, r4
 801da2c:	2101      	movs	r1, #1
 801da2e:	2007      	movs	r0, #7
 801da30:	f001 fbd4 	bl	801f1dc <traceIF_uartPrint>
              idx_apn_found = i;
 801da34:	462c      	mov	r4, r5
              apn_found = true;
 801da36:	2601      	movs	r6, #1
 801da38:	e7d0      	b.n	801d9dc <CST_modem_sim_init+0x38c>
          if (apn_found)
 801da3a:	2e00      	cmp	r6, #0
 801da3c:	d063      	beq.n	801db06 <CST_modem_sim_init+0x4b6>
            PRINT_CELLULAR_SERVICE("CST_modem_sim_init : CST_modem_define_pdn with APN: \"%s\"\n\r",
 801da3e:	4e55      	ldr	r6, [pc, #340]	; (801db94 <CST_modem_sim_init+0x544>)
 801da40:	ea4f 1844 	mov.w	r8, r4, lsl #5
 801da44:	eb04 1744 	add.w	r7, r4, r4, lsl #5
 801da48:	eb06 0747 	add.w	r7, r6, r7, lsl #1
 801da4c:	3706      	adds	r7, #6
 801da4e:	4d4c      	ldr	r5, [pc, #304]	; (801db80 <CST_modem_sim_init+0x530>)
 801da50:	463a      	mov	r2, r7
 801da52:	4952      	ldr	r1, [pc, #328]	; (801db9c <CST_modem_sim_init+0x54c>)
 801da54:	4628      	mov	r0, r5
 801da56:	f008 f90b 	bl	8025c70 <sprintf>
 801da5a:	4628      	mov	r0, r5
 801da5c:	f001 fb59 	bl	801f112 <crs_strlen>
 801da60:	b283      	uxth	r3, r0
 801da62:	462a      	mov	r2, r5
 801da64:	2101      	movs	r1, #1
 801da66:	2007      	movs	r0, #7
 801da68:	f001 fb96 	bl	801f198 <traceIF_itmPrint>
 801da6c:	4628      	mov	r0, r5
 801da6e:	f001 fb50 	bl	801f112 <crs_strlen>
 801da72:	b283      	uxth	r3, r0
 801da74:	462a      	mov	r2, r5
 801da76:	2101      	movs	r1, #1
 801da78:	2007      	movs	r0, #7
 801da7a:	f001 fbaf 	bl	801f1dc <traceIF_uartPrint>
                                 mmcmnc_apn_a[idx_apn_found].username,
 801da7e:	eb08 0504 	add.w	r5, r8, r4
 801da82:	006d      	lsls	r5, r5, #1
 801da84:	3518      	adds	r5, #24
 801da86:	4435      	add	r5, r6
 801da88:	3502      	adds	r5, #2
                                 mmcmnc_apn_a[idx_apn_found].password);
 801da8a:	eb08 0304 	add.w	r3, r8, r4
 801da8e:	005b      	lsls	r3, r3, #1
 801da90:	3328      	adds	r3, #40	; 0x28
 801da92:	18f4      	adds	r4, r6, r3
 801da94:	3406      	adds	r4, #6
            CST_modem_define_pdn(mmcmnc_apn_a[idx_apn_found].apn,
 801da96:	4622      	mov	r2, r4
 801da98:	4629      	mov	r1, r5
 801da9a:	4638      	mov	r0, r7
 801da9c:	f7ff fd4e 	bl	801d53c <CST_modem_define_pdn>
            (void)dc_com_read(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&apn_config, sizeof(apn_config));
 801daa0:	f8df 8108 	ldr.w	r8, [pc, #264]	; 801dbac <CST_modem_sim_init+0x55c>
 801daa4:	4e3e      	ldr	r6, [pc, #248]	; (801dba0 <CST_modem_sim_init+0x550>)
 801daa6:	236c      	movs	r3, #108	; 0x6c
 801daa8:	aa47      	add	r2, sp, #284	; 0x11c
 801daaa:	f8b8 1000 	ldrh.w	r1, [r8]
 801daae:	4630      	mov	r0, r6
 801dab0:	f003 ff8a 	bl	80219c8 <dc_com_read>
                         crs_strlen(mmcmnc_apn_a[idx_apn_found].apn) + 1U);
 801dab4:	4638      	mov	r0, r7
 801dab6:	f001 fb2c 	bl	801f112 <crs_strlen>
            (void)memcpy(apn_config.apn, mmcmnc_apn_a[idx_apn_found].apn,
 801daba:	1c42      	adds	r2, r0, #1
 801dabc:	4639      	mov	r1, r7
 801dabe:	f20d 1025 	addw	r0, sp, #293	; 0x125
 801dac2:	f008 fa25 	bl	8025f10 <memcpy>
                         crs_strlen(mmcmnc_apn_a[idx_apn_found].username) + 1U);
 801dac6:	4628      	mov	r0, r5
 801dac8:	f001 fb23 	bl	801f112 <crs_strlen>
            (void)memcpy(apn_config.apn, mmcmnc_apn_a[idx_apn_found].username,
 801dacc:	1c42      	adds	r2, r0, #1
 801dace:	4629      	mov	r1, r5
 801dad0:	f20d 1025 	addw	r0, sp, #293	; 0x125
 801dad4:	f008 fa1c 	bl	8025f10 <memcpy>
                         crs_strlen(mmcmnc_apn_a[idx_apn_found].password) + 1U);
 801dad8:	4620      	mov	r0, r4
 801dada:	f001 fb1a 	bl	801f112 <crs_strlen>
            (void)memcpy(apn_config.apn, mmcmnc_apn_a[idx_apn_found].password,
 801dade:	1c42      	adds	r2, r0, #1
 801dae0:	4621      	mov	r1, r4
 801dae2:	f20d 1025 	addw	r0, sp, #293	; 0x125
 801dae6:	f008 fa13 	bl	8025f10 <memcpy>
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&apn_config, sizeof(apn_config));
 801daea:	236c      	movs	r3, #108	; 0x6c
 801daec:	aa47      	add	r2, sp, #284	; 0x11c
 801daee:	f8b8 1000 	ldrh.w	r1, [r8]
 801daf2:	4630      	mov	r0, r6
 801daf4:	f003 ff1c 	bl	8021930 <dc_com_write>
        cs_status = osCDS_init_modem(CS_CMI_FULL, CELLULAR_FALSE, CST_SIM_PINCODE);
 801daf8:	4a22      	ldr	r2, [pc, #136]	; (801db84 <CST_modem_sim_init+0x534>)
 801dafa:	2100      	movs	r1, #0
 801dafc:	2001      	movs	r0, #1
 801dafe:	f7fc ffc1 	bl	801aa84 <osCDS_init_modem>
 801db02:	4606      	mov	r6, r0
 801db04:	e757      	b.n	801d9b6 <CST_modem_sim_init+0x366>
            PRINT_CELLULAR_SERVICE("CST_modem_sim_init : CST_modem_define_pdn with Flash stored APN\n\r")
 801db06:	4c1e      	ldr	r4, [pc, #120]	; (801db80 <CST_modem_sim_init+0x530>)
 801db08:	2242      	movs	r2, #66	; 0x42
 801db0a:	4926      	ldr	r1, [pc, #152]	; (801dba4 <CST_modem_sim_init+0x554>)
 801db0c:	4620      	mov	r0, r4
 801db0e:	f008 f9ff 	bl	8025f10 <memcpy>
 801db12:	4620      	mov	r0, r4
 801db14:	f001 fafd 	bl	801f112 <crs_strlen>
 801db18:	b283      	uxth	r3, r0
 801db1a:	4622      	mov	r2, r4
 801db1c:	2101      	movs	r1, #1
 801db1e:	2007      	movs	r0, #7
 801db20:	f001 fb3a 	bl	801f198 <traceIF_itmPrint>
 801db24:	4620      	mov	r0, r4
 801db26:	f001 faf4 	bl	801f112 <crs_strlen>
 801db2a:	b283      	uxth	r3, r0
 801db2c:	4622      	mov	r2, r4
 801db2e:	2101      	movs	r1, #1
 801db30:	2007      	movs	r0, #7
 801db32:	f001 fb53 	bl	801f1dc <traceIF_uartPrint>
            CST_modem_define_pdn((uint8_t *)"", (uint8_t *)"", (uint8_t *)"");
 801db36:	4813      	ldr	r0, [pc, #76]	; (801db84 <CST_modem_sim_init+0x534>)
 801db38:	4602      	mov	r2, r0
 801db3a:	4601      	mov	r1, r0
 801db3c:	f7ff fcfe 	bl	801d53c <CST_modem_define_pdn>
 801db40:	e7da      	b.n	801daf8 <CST_modem_sim_init+0x4a8>
          PRINT_CELLULAR_SERVICE("CST_modem_sim_init : CST_modem_define_pdn with Flash stored APN\n\r")
 801db42:	4c0f      	ldr	r4, [pc, #60]	; (801db80 <CST_modem_sim_init+0x530>)
 801db44:	2242      	movs	r2, #66	; 0x42
 801db46:	4917      	ldr	r1, [pc, #92]	; (801dba4 <CST_modem_sim_init+0x554>)
 801db48:	4620      	mov	r0, r4
 801db4a:	f008 f9e1 	bl	8025f10 <memcpy>
 801db4e:	4620      	mov	r0, r4
 801db50:	f001 fadf 	bl	801f112 <crs_strlen>
 801db54:	b283      	uxth	r3, r0
 801db56:	4622      	mov	r2, r4
 801db58:	2101      	movs	r1, #1
 801db5a:	2007      	movs	r0, #7
 801db5c:	f001 fb1c 	bl	801f198 <traceIF_itmPrint>
 801db60:	4620      	mov	r0, r4
 801db62:	f001 fad6 	bl	801f112 <crs_strlen>
 801db66:	b283      	uxth	r3, r0
 801db68:	4622      	mov	r2, r4
 801db6a:	2101      	movs	r1, #1
 801db6c:	2007      	movs	r0, #7
 801db6e:	f001 fb35 	bl	801f1dc <traceIF_uartPrint>
          CST_modem_define_pdn((uint8_t *)"", (uint8_t *)"", (uint8_t *)"");
 801db72:	4804      	ldr	r0, [pc, #16]	; (801db84 <CST_modem_sim_init+0x534>)
 801db74:	4602      	mov	r2, r0
 801db76:	4601      	mov	r1, r0
 801db78:	f7ff fce0 	bl	801d53c <CST_modem_define_pdn>
 801db7c:	e7bc      	b.n	801daf8 <CST_modem_sim_init+0x4a8>
 801db7e:	bf00      	nop
 801db80:	20004ddc 	.word	0x20004ddc
 801db84:	08034f74 	.word	0x08034f74
 801db88:	08034a00 	.word	0x08034a00
 801db8c:	20004160 	.word	0x20004160
 801db90:	200000b0 	.word	0x200000b0
 801db94:	200000d0 	.word	0x200000d0
 801db98:	08034a20 	.word	0x08034a20
 801db9c:	08034a4c 	.word	0x08034a4c
 801dba0:	200058b0 	.word	0x200058b0
 801dba4:	08034a88 	.word	0x08034a88
 801dba8:	080349d8 	.word	0x080349d8
 801dbac:	20000230 	.word	0x20000230
    PRINT_FORCE("==================================\n\r")
 801dbb0:	4e6c      	ldr	r6, [pc, #432]	; (801dd64 <CST_modem_sim_init+0x714>)
 801dbb2:	4c6d      	ldr	r4, [pc, #436]	; (801dd68 <CST_modem_sim_init+0x718>)
 801dbb4:	f106 0c20 	add.w	ip, r6, #32
 801dbb8:	4635      	mov	r5, r6
 801dbba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801dbbc:	6020      	str	r0, [r4, #0]
 801dbbe:	6061      	str	r1, [r4, #4]
 801dbc0:	60a2      	str	r2, [r4, #8]
 801dbc2:	60e3      	str	r3, [r4, #12]
 801dbc4:	462e      	mov	r6, r5
 801dbc6:	3410      	adds	r4, #16
 801dbc8:	4565      	cmp	r5, ip
 801dbca:	d1f5      	bne.n	801dbb8 <CST_modem_sim_init+0x568>
 801dbcc:	6828      	ldr	r0, [r5, #0]
 801dbce:	6020      	str	r0, [r4, #0]
 801dbd0:	792b      	ldrb	r3, [r5, #4]
 801dbd2:	7123      	strb	r3, [r4, #4]
 801dbd4:	4c64      	ldr	r4, [pc, #400]	; (801dd68 <CST_modem_sim_init+0x718>)
 801dbd6:	4620      	mov	r0, r4
 801dbd8:	f001 fa9b 	bl	801f112 <crs_strlen>
 801dbdc:	b283      	uxth	r3, r0
 801dbde:	4622      	mov	r2, r4
 801dbe0:	2101      	movs	r1, #1
 801dbe2:	2007      	movs	r0, #7
 801dbe4:	f001 fad8 	bl	801f198 <traceIF_itmPrint>
 801dbe8:	4620      	mov	r0, r4
 801dbea:	f001 fa92 	bl	801f112 <crs_strlen>
 801dbee:	b282      	uxth	r2, r0
 801dbf0:	4621      	mov	r1, r4
 801dbf2:	2007      	movs	r0, #7
 801dbf4:	f001 fb0a 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE(" WARNING: PIN OK PUK LOCKED !!!  \n\r")
 801dbf8:	4e5c      	ldr	r6, [pc, #368]	; (801dd6c <CST_modem_sim_init+0x71c>)
 801dbfa:	f106 0c20 	add.w	ip, r6, #32
 801dbfe:	4635      	mov	r5, r6
 801dc00:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801dc02:	6020      	str	r0, [r4, #0]
 801dc04:	6061      	str	r1, [r4, #4]
 801dc06:	60a2      	str	r2, [r4, #8]
 801dc08:	60e3      	str	r3, [r4, #12]
 801dc0a:	462e      	mov	r6, r5
 801dc0c:	3410      	adds	r4, #16
 801dc0e:	4565      	cmp	r5, ip
 801dc10:	d1f5      	bne.n	801dbfe <CST_modem_sim_init+0x5ae>
 801dc12:	6828      	ldr	r0, [r5, #0]
 801dc14:	6020      	str	r0, [r4, #0]
 801dc16:	4c54      	ldr	r4, [pc, #336]	; (801dd68 <CST_modem_sim_init+0x718>)
 801dc18:	4620      	mov	r0, r4
 801dc1a:	f001 fa7a 	bl	801f112 <crs_strlen>
 801dc1e:	b283      	uxth	r3, r0
 801dc20:	4622      	mov	r2, r4
 801dc22:	2101      	movs	r1, #1
 801dc24:	2007      	movs	r0, #7
 801dc26:	f001 fab7 	bl	801f198 <traceIF_itmPrint>
 801dc2a:	4620      	mov	r0, r4
 801dc2c:	f001 fa71 	bl	801f112 <crs_strlen>
 801dc30:	b282      	uxth	r2, r0
 801dc32:	4621      	mov	r1, r4
 801dc34:	2007      	movs	r0, #7
 801dc36:	f001 fae9 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE(" PROCESSING STOPPED\n\r")
 801dc3a:	4d4d      	ldr	r5, [pc, #308]	; (801dd70 <CST_modem_sim_init+0x720>)
 801dc3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801dc3e:	6020      	str	r0, [r4, #0]
 801dc40:	6061      	str	r1, [r4, #4]
 801dc42:	60a2      	str	r2, [r4, #8]
 801dc44:	60e3      	str	r3, [r4, #12]
 801dc46:	6828      	ldr	r0, [r5, #0]
 801dc48:	6120      	str	r0, [r4, #16]
 801dc4a:	88ab      	ldrh	r3, [r5, #4]
 801dc4c:	82a3      	strh	r3, [r4, #20]
 801dc4e:	4620      	mov	r0, r4
 801dc50:	f001 fa5f 	bl	801f112 <crs_strlen>
 801dc54:	b283      	uxth	r3, r0
 801dc56:	4622      	mov	r2, r4
 801dc58:	2101      	movs	r1, #1
 801dc5a:	2007      	movs	r0, #7
 801dc5c:	f001 fa9c 	bl	801f198 <traceIF_itmPrint>
 801dc60:	4620      	mov	r0, r4
 801dc62:	f001 fa56 	bl	801f112 <crs_strlen>
 801dc66:	b282      	uxth	r2, r0
 801dc68:	4621      	mov	r1, r4
 801dc6a:	2007      	movs	r0, #7
 801dc6c:	f001 face 	bl	801f20c <traceIF_uartPrintForce>
    PRINT_FORCE("==================================\n\r")
 801dc70:	4e3c      	ldr	r6, [pc, #240]	; (801dd64 <CST_modem_sim_init+0x714>)
 801dc72:	f106 0c20 	add.w	ip, r6, #32
 801dc76:	4635      	mov	r5, r6
 801dc78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801dc7a:	6020      	str	r0, [r4, #0]
 801dc7c:	6061      	str	r1, [r4, #4]
 801dc7e:	60a2      	str	r2, [r4, #8]
 801dc80:	60e3      	str	r3, [r4, #12]
 801dc82:	462e      	mov	r6, r5
 801dc84:	3410      	adds	r4, #16
 801dc86:	4565      	cmp	r5, ip
 801dc88:	d1f5      	bne.n	801dc76 <CST_modem_sim_init+0x626>
 801dc8a:	6828      	ldr	r0, [r5, #0]
 801dc8c:	6020      	str	r0, [r4, #0]
 801dc8e:	792b      	ldrb	r3, [r5, #4]
 801dc90:	7123      	strb	r3, [r4, #4]
 801dc92:	4c35      	ldr	r4, [pc, #212]	; (801dd68 <CST_modem_sim_init+0x718>)
 801dc94:	4620      	mov	r0, r4
 801dc96:	f001 fa3c 	bl	801f112 <crs_strlen>
 801dc9a:	b283      	uxth	r3, r0
 801dc9c:	4622      	mov	r2, r4
 801dc9e:	2101      	movs	r1, #1
 801dca0:	2007      	movs	r0, #7
 801dca2:	f001 fa79 	bl	801f198 <traceIF_itmPrint>
 801dca6:	4620      	mov	r0, r4
 801dca8:	f001 fa33 	bl	801f112 <crs_strlen>
 801dcac:	b282      	uxth	r2, r0
 801dcae:	4621      	mov	r1, r4
 801dcb0:	2007      	movs	r0, #7
 801dcb2:	f001 faab 	bl	801f20c <traceIF_uartPrintForce>
      __NOP(); /* Nothing to do */
 801dcb6:	bf00      	nop
    for (;;)
 801dcb8:	e7fd      	b.n	801dcb6 <CST_modem_sim_init+0x666>
      cst_context.sim_slot_index = 0U; /* No available SIM found: set default SIM socket (Modem socket) */
 801dcba:	4b2e      	ldr	r3, [pc, #184]	; (801dd74 <CST_modem_sim_init+0x724>)
 801dcbc:	2200      	movs	r2, #0
 801dcbe:	741a      	strb	r2, [r3, #16]
      PRINT_CELLULAR_SERVICE("CST_modem_powered_on_state : No SIM found\n\r")
 801dcc0:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 801dd88 <CST_modem_sim_init+0x738>
 801dcc4:	4c28      	ldr	r4, [pc, #160]	; (801dd68 <CST_modem_sim_init+0x718>)
 801dcc6:	f10c 0620 	add.w	r6, ip, #32
 801dcca:	4665      	mov	r5, ip
 801dccc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801dcce:	6020      	str	r0, [r4, #0]
 801dcd0:	6061      	str	r1, [r4, #4]
 801dcd2:	60a2      	str	r2, [r4, #8]
 801dcd4:	60e3      	str	r3, [r4, #12]
 801dcd6:	46ac      	mov	ip, r5
 801dcd8:	3410      	adds	r4, #16
 801dcda:	42b5      	cmp	r5, r6
 801dcdc:	d1f5      	bne.n	801dcca <CST_modem_sim_init+0x67a>
 801dcde:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 801dce2:	6020      	str	r0, [r4, #0]
 801dce4:	6061      	str	r1, [r4, #4]
 801dce6:	60a2      	str	r2, [r4, #8]
 801dce8:	4c1f      	ldr	r4, [pc, #124]	; (801dd68 <CST_modem_sim_init+0x718>)
 801dcea:	4620      	mov	r0, r4
 801dcec:	f001 fa11 	bl	801f112 <crs_strlen>
 801dcf0:	b283      	uxth	r3, r0
 801dcf2:	4622      	mov	r2, r4
 801dcf4:	2101      	movs	r1, #1
 801dcf6:	2007      	movs	r0, #7
 801dcf8:	f001 fa4e 	bl	801f198 <traceIF_itmPrint>
 801dcfc:	4620      	mov	r0, r4
 801dcfe:	f001 fa08 	bl	801f112 <crs_strlen>
 801dd02:	b283      	uxth	r3, r0
 801dd04:	4622      	mov	r2, r4
 801dd06:	2101      	movs	r1, #1
 801dd08:	2007      	movs	r0, #7
 801dd0a:	f001 fa67 	bl	801f1dc <traceIF_uartPrint>
 801dd0e:	e500      	b.n	801d712 <CST_modem_sim_init+0xc2>
    CST_subscribe_all_net_events();
 801dd10:	f7ff fae6 	bl	801d2e0 <CST_subscribe_all_net_events>
    CST_get_device_all_infos(cst_cellular_params.target_state);
 801dd14:	4c18      	ldr	r4, [pc, #96]	; (801dd78 <CST_modem_sim_init+0x728>)
 801dd16:	f894 0131 	ldrb.w	r0, [r4, #305]	; 0x131
 801dd1a:	f7fe ff9f 	bl	801cc5c <CST_get_device_all_infos>
    if (cst_cellular_params.target_state != DC_TARGET_STATE_SIM_ONLY)
 801dd1e:	f894 3131 	ldrb.w	r3, [r4, #305]	; 0x131
 801dd22:	2b01      	cmp	r3, #1
 801dd24:	d007      	beq.n	801dd36 <CST_modem_sim_init+0x6e6>
      CST_set_state(CST_MODEM_READY_STATE);
 801dd26:	2002      	movs	r0, #2
 801dd28:	f7fd fa22 	bl	801b170 <CST_set_state>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_READY_EVENT);
 801dd2c:	2102      	movs	r1, #2
 801dd2e:	2000      	movs	r0, #0
 801dd30:	f7fd f95a 	bl	801afe8 <CST_send_message>
 801dd34:	e506      	b.n	801d744 <CST_modem_sim_init+0xf4>
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801dd36:	4e11      	ldr	r6, [pc, #68]	; (801dd7c <CST_modem_sim_init+0x72c>)
 801dd38:	4c11      	ldr	r4, [pc, #68]	; (801dd80 <CST_modem_sim_init+0x730>)
 801dd3a:	4d12      	ldr	r5, [pc, #72]	; (801dd84 <CST_modem_sim_init+0x734>)
 801dd3c:	23f4      	movs	r3, #244	; 0xf4
 801dd3e:	4622      	mov	r2, r4
 801dd40:	8831      	ldrh	r1, [r6, #0]
 801dd42:	4628      	mov	r0, r5
 801dd44:	f003 fe40 	bl	80219c8 <dc_com_read>
      cst_cellular_info.rt_state    = DC_SERVICE_ON;
 801dd48:	2307      	movs	r3, #7
 801dd4a:	7223      	strb	r3, [r4, #8]
      cst_cellular_info.modem_state = DC_MODEM_STATE_SIM_CONNECTED;
 801dd4c:	2302      	movs	r3, #2
 801dd4e:	7263      	strb	r3, [r4, #9]
      (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801dd50:	23f4      	movs	r3, #244	; 0xf4
 801dd52:	4622      	mov	r2, r4
 801dd54:	8831      	ldrh	r1, [r6, #0]
 801dd56:	4628      	mov	r0, r5
 801dd58:	f003 fdea 	bl	8021930 <dc_com_write>
      CST_set_state(CST_MODEM_SIM_ONLY_STATE);
 801dd5c:	200b      	movs	r0, #11
 801dd5e:	f7fd fa07 	bl	801b170 <CST_set_state>
}
 801dd62:	e4ef      	b.n	801d744 <CST_modem_sim_init+0xf4>
 801dd64:	08034acc 	.word	0x08034acc
 801dd68:	20004ddc 	.word	0x20004ddc
 801dd6c:	08034b74 	.word	0x08034b74
 801dd70:	08034b98 	.word	0x08034b98
 801dd74:	200000b0 	.word	0x200000b0
 801dd78:	20004160 	.word	0x20004160
 801dd7c:	20000236 	.word	0x20000236
 801dd80:	2000406c 	.word	0x2000406c
 801dd84:	200058b0 	.word	0x200058b0
 801dd88:	08034bb0 	.word	0x08034bb0

0801dd8c <CST_set_signal_quality>:
{
 801dd8c:	b570      	push	{r4, r5, r6, lr}
 801dd8e:	b082      	sub	sp, #8
  if (osCS_get_signal_quality(&sig_quality) == CELLULAR_OK)
 801dd90:	a801      	add	r0, sp, #4
 801dd92:	f7fc fce9 	bl	801a768 <osCS_get_signal_quality>
 801dd96:	2800      	cmp	r0, #0
 801dd98:	d164      	bne.n	801de64 <CST_set_signal_quality+0xd8>
 801dd9a:	4605      	mov	r5, r0
    cst_context.csq_count_fail = 0U;
 801dd9c:	4b5c      	ldr	r3, [pc, #368]	; (801df10 <CST_set_signal_quality+0x184>)
 801dd9e:	2200      	movs	r2, #0
 801dda0:	771a      	strb	r2, [r3, #28]
    if ((sig_quality.rssi != cst_context.signal_quality.rssi) || (sig_quality.ber != cst_context.signal_quality.ber))
 801dda2:	f89d 2004 	ldrb.w	r2, [sp, #4]
 801dda6:	791b      	ldrb	r3, [r3, #4]
 801dda8:	429a      	cmp	r2, r3
 801ddaa:	d105      	bne.n	801ddb8 <CST_set_signal_quality+0x2c>
 801ddac:	f89d 1005 	ldrb.w	r1, [sp, #5]
 801ddb0:	4b57      	ldr	r3, [pc, #348]	; (801df10 <CST_set_signal_quality+0x184>)
 801ddb2:	795b      	ldrb	r3, [r3, #5]
 801ddb4:	4299      	cmp	r1, r3
 801ddb6:	d01b      	beq.n	801ddf0 <CST_set_signal_quality+0x64>
      cst_context.signal_quality.rssi = sig_quality.rssi;
 801ddb8:	4b55      	ldr	r3, [pc, #340]	; (801df10 <CST_set_signal_quality+0x184>)
 801ddba:	711a      	strb	r2, [r3, #4]
      cst_context.signal_quality.ber  = sig_quality.ber;
 801ddbc:	f89d 2005 	ldrb.w	r2, [sp, #5]
 801ddc0:	715a      	strb	r2, [r3, #5]
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801ddc2:	23f4      	movs	r3, #244	; 0xf4
 801ddc4:	4a53      	ldr	r2, [pc, #332]	; (801df14 <CST_set_signal_quality+0x188>)
 801ddc6:	4954      	ldr	r1, [pc, #336]	; (801df18 <CST_set_signal_quality+0x18c>)
 801ddc8:	8809      	ldrh	r1, [r1, #0]
 801ddca:	4854      	ldr	r0, [pc, #336]	; (801df1c <CST_set_signal_quality+0x190>)
 801ddcc:	f003 fdfc 	bl	80219c8 <dc_com_read>
      if (sig_quality.rssi == CST_BAD_SIG_RSSI)
 801ddd0:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801ddd4:	2b63      	cmp	r3, #99	; 0x63
 801ddd6:	d03f      	beq.n	801de58 <CST_set_signal_quality+0xcc>
        cst_cellular_info.cs_signal_level     = sig_quality.rssi;                         /* range 0..99 */
 801ddd8:	4a4e      	ldr	r2, [pc, #312]	; (801df14 <CST_set_signal_quality+0x188>)
 801ddda:	7293      	strb	r3, [r2, #10]
        cst_cellular_info.cs_signal_level_db  = (-113 + (2 * (int32_t)sig_quality.rssi)); /* dBm value   */
 801dddc:	005b      	lsls	r3, r3, #1
 801ddde:	3b71      	subs	r3, #113	; 0x71
 801dde0:	60d3      	str	r3, [r2, #12]
      (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801dde2:	23f4      	movs	r3, #244	; 0xf4
 801dde4:	4a4b      	ldr	r2, [pc, #300]	; (801df14 <CST_set_signal_quality+0x188>)
 801dde6:	494c      	ldr	r1, [pc, #304]	; (801df18 <CST_set_signal_quality+0x18c>)
 801dde8:	8809      	ldrh	r1, [r1, #0]
 801ddea:	484c      	ldr	r0, [pc, #304]	; (801df1c <CST_set_signal_quality+0x190>)
 801ddec:	f003 fda0 	bl	8021930 <dc_com_write>
    PRINT_CELLULAR_SERVICE(" -Sig quality rssi : %d\n\r", sig_quality.rssi)
 801ddf0:	4c4b      	ldr	r4, [pc, #300]	; (801df20 <CST_set_signal_quality+0x194>)
 801ddf2:	f89d 2004 	ldrb.w	r2, [sp, #4]
 801ddf6:	494b      	ldr	r1, [pc, #300]	; (801df24 <CST_set_signal_quality+0x198>)
 801ddf8:	4620      	mov	r0, r4
 801ddfa:	f007 ff39 	bl	8025c70 <sprintf>
 801ddfe:	4620      	mov	r0, r4
 801de00:	f001 f987 	bl	801f112 <crs_strlen>
 801de04:	b283      	uxth	r3, r0
 801de06:	4622      	mov	r2, r4
 801de08:	2101      	movs	r1, #1
 801de0a:	2007      	movs	r0, #7
 801de0c:	f001 f9c4 	bl	801f198 <traceIF_itmPrint>
 801de10:	4620      	mov	r0, r4
 801de12:	f001 f97e 	bl	801f112 <crs_strlen>
 801de16:	b283      	uxth	r3, r0
 801de18:	4622      	mov	r2, r4
 801de1a:	2101      	movs	r1, #1
 801de1c:	2007      	movs	r0, #7
 801de1e:	f001 f9dd 	bl	801f1dc <traceIF_uartPrint>
    PRINT_CELLULAR_SERVICE(" -Sig quality ber  : %d\n\r", sig_quality.ber)
 801de22:	f89d 2005 	ldrb.w	r2, [sp, #5]
 801de26:	4940      	ldr	r1, [pc, #256]	; (801df28 <CST_set_signal_quality+0x19c>)
 801de28:	4620      	mov	r0, r4
 801de2a:	f007 ff21 	bl	8025c70 <sprintf>
 801de2e:	4620      	mov	r0, r4
 801de30:	f001 f96f 	bl	801f112 <crs_strlen>
 801de34:	b283      	uxth	r3, r0
 801de36:	4622      	mov	r2, r4
 801de38:	2101      	movs	r1, #1
 801de3a:	2007      	movs	r0, #7
 801de3c:	f001 f9ac 	bl	801f198 <traceIF_itmPrint>
 801de40:	4620      	mov	r0, r4
 801de42:	f001 f966 	bl	801f112 <crs_strlen>
 801de46:	b283      	uxth	r3, r0
 801de48:	4622      	mov	r2, r4
 801de4a:	2101      	movs	r1, #1
 801de4c:	2007      	movs	r0, #7
 801de4e:	f001 f9c5 	bl	801f1dc <traceIF_uartPrint>
}
 801de52:	4628      	mov	r0, r5
 801de54:	b002      	add	sp, #8
 801de56:	bd70      	pop	{r4, r5, r6, pc}
        cst_cellular_info.cs_signal_level    = DC_NO_ATTACHED;
 801de58:	4b2e      	ldr	r3, [pc, #184]	; (801df14 <CST_set_signal_quality+0x188>)
 801de5a:	2200      	movs	r2, #0
 801de5c:	729a      	strb	r2, [r3, #10]
        cst_cellular_info.cs_signal_level_db = (int32_t)DC_NO_ATTACHED;
 801de5e:	60da      	str	r2, [r3, #12]
        cs_status = CELLULAR_ERROR;
 801de60:	2501      	movs	r5, #1
 801de62:	e7be      	b.n	801dde2 <CST_set_signal_quality+0x56>
    cst_context.csq_count_fail++;
 801de64:	4e2a      	ldr	r6, [pc, #168]	; (801df10 <CST_set_signal_quality+0x184>)
 801de66:	7f33      	ldrb	r3, [r6, #28]
 801de68:	3301      	adds	r3, #1
 801de6a:	7733      	strb	r3, [r6, #28]
    PRINT_CELLULAR_SERVICE("Modem signal quality error\n\r")
 801de6c:	4c2c      	ldr	r4, [pc, #176]	; (801df20 <CST_set_signal_quality+0x194>)
 801de6e:	4d2f      	ldr	r5, [pc, #188]	; (801df2c <CST_set_signal_quality+0x1a0>)
 801de70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801de72:	6020      	str	r0, [r4, #0]
 801de74:	6061      	str	r1, [r4, #4]
 801de76:	60a2      	str	r2, [r4, #8]
 801de78:	60e3      	str	r3, [r4, #12]
 801de7a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801de7c:	6120      	str	r0, [r4, #16]
 801de7e:	6161      	str	r1, [r4, #20]
 801de80:	61a2      	str	r2, [r4, #24]
 801de82:	782b      	ldrb	r3, [r5, #0]
 801de84:	7723      	strb	r3, [r4, #28]
 801de86:	4620      	mov	r0, r4
 801de88:	f001 f943 	bl	801f112 <crs_strlen>
 801de8c:	b283      	uxth	r3, r0
 801de8e:	4622      	mov	r2, r4
 801de90:	2101      	movs	r1, #1
 801de92:	2007      	movs	r0, #7
 801de94:	f001 f980 	bl	801f198 <traceIF_itmPrint>
 801de98:	4620      	mov	r0, r4
 801de9a:	f001 f93a 	bl	801f112 <crs_strlen>
 801de9e:	b283      	uxth	r3, r0
 801dea0:	4622      	mov	r2, r4
 801dea2:	2101      	movs	r1, #1
 801dea4:	2007      	movs	r0, #7
 801dea6:	f001 f999 	bl	801f1dc <traceIF_uartPrint>
    if (cst_context.csq_count_fail >= CST_COUNT_FAIL_MAX)
 801deaa:	7f33      	ldrb	r3, [r6, #28]
 801deac:	2b04      	cmp	r3, #4
 801deae:	d801      	bhi.n	801deb4 <CST_set_signal_quality+0x128>
    cs_status = CELLULAR_ERROR;
 801deb0:	2501      	movs	r5, #1
 801deb2:	e7ce      	b.n	801de52 <CST_set_signal_quality+0xc6>
      PRINT_CELLULAR_SERVICE("Modem signal quality error max\n\r")
 801deb4:	4e1e      	ldr	r6, [pc, #120]	; (801df30 <CST_set_signal_quality+0x1a4>)
 801deb6:	4625      	mov	r5, r4
 801deb8:	f106 0c20 	add.w	ip, r6, #32
 801debc:	4634      	mov	r4, r6
 801debe:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801dec0:	6028      	str	r0, [r5, #0]
 801dec2:	6069      	str	r1, [r5, #4]
 801dec4:	60aa      	str	r2, [r5, #8]
 801dec6:	60eb      	str	r3, [r5, #12]
 801dec8:	4626      	mov	r6, r4
 801deca:	3510      	adds	r5, #16
 801decc:	4564      	cmp	r4, ip
 801dece:	d1f5      	bne.n	801debc <CST_set_signal_quality+0x130>
 801ded0:	7823      	ldrb	r3, [r4, #0]
 801ded2:	702b      	strb	r3, [r5, #0]
 801ded4:	4c12      	ldr	r4, [pc, #72]	; (801df20 <CST_set_signal_quality+0x194>)
 801ded6:	4620      	mov	r0, r4
 801ded8:	f001 f91b 	bl	801f112 <crs_strlen>
 801dedc:	b283      	uxth	r3, r0
 801dede:	4622      	mov	r2, r4
 801dee0:	2101      	movs	r1, #1
 801dee2:	2007      	movs	r0, #7
 801dee4:	f001 f958 	bl	801f198 <traceIF_itmPrint>
 801dee8:	4620      	mov	r0, r4
 801deea:	f001 f912 	bl	801f112 <crs_strlen>
 801deee:	b283      	uxth	r3, r0
 801def0:	4622      	mov	r2, r4
 801def2:	2101      	movs	r1, #1
 801def4:	2007      	movs	r0, #7
 801def6:	f001 f971 	bl	801f1dc <traceIF_uartPrint>
      cst_context.csq_count_fail = 0U;
 801defa:	4a05      	ldr	r2, [pc, #20]	; (801df10 <CST_set_signal_quality+0x184>)
 801defc:	2300      	movs	r3, #0
 801defe:	7713      	strb	r3, [r2, #28]
      CST_config_fail(((uint8_t *)"CS_get_signal_quality"),
 801df00:	2305      	movs	r3, #5
 801df02:	3213      	adds	r2, #19
 801df04:	2103      	movs	r1, #3
 801df06:	480b      	ldr	r0, [pc, #44]	; (801df34 <CST_set_signal_quality+0x1a8>)
 801df08:	f7ff faa4 	bl	801d454 <CST_config_fail>
    cs_status = CELLULAR_ERROR;
 801df0c:	2501      	movs	r5, #1
 801df0e:	e7a0      	b.n	801de52 <CST_set_signal_quality+0xc6>
 801df10:	200000b0 	.word	0x200000b0
 801df14:	2000406c 	.word	0x2000406c
 801df18:	20000236 	.word	0x20000236
 801df1c:	200058b0 	.word	0x200058b0
 801df20:	20004ddc 	.word	0x20004ddc
 801df24:	08034bf0 	.word	0x08034bf0
 801df28:	08034c0c 	.word	0x08034c0c
 801df2c:	08034c28 	.word	0x08034c28
 801df30:	08034c48 	.word	0x08034c48
 801df34:	08034c6c 	.word	0x08034c6c

0801df38 <CST_subscribe_modem_events>:
{
 801df38:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("Subscribe modems events\n\r")
 801df3a:	4c11      	ldr	r4, [pc, #68]	; (801df80 <CST_subscribe_modem_events+0x48>)
 801df3c:	4d11      	ldr	r5, [pc, #68]	; (801df84 <CST_subscribe_modem_events+0x4c>)
 801df3e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801df40:	6020      	str	r0, [r4, #0]
 801df42:	6061      	str	r1, [r4, #4]
 801df44:	60a2      	str	r2, [r4, #8]
 801df46:	60e3      	str	r3, [r4, #12]
 801df48:	cd03      	ldmia	r5!, {r0, r1}
 801df4a:	6120      	str	r0, [r4, #16]
 801df4c:	6161      	str	r1, [r4, #20]
 801df4e:	882b      	ldrh	r3, [r5, #0]
 801df50:	8323      	strh	r3, [r4, #24]
 801df52:	4620      	mov	r0, r4
 801df54:	f001 f8dd 	bl	801f112 <crs_strlen>
 801df58:	b283      	uxth	r3, r0
 801df5a:	4622      	mov	r2, r4
 801df5c:	2101      	movs	r1, #1
 801df5e:	2007      	movs	r0, #7
 801df60:	f001 f91a 	bl	801f198 <traceIF_itmPrint>
 801df64:	4620      	mov	r0, r4
 801df66:	f001 f8d4 	bl	801f112 <crs_strlen>
 801df6a:	b283      	uxth	r3, r0
 801df6c:	4622      	mov	r2, r4
 801df6e:	2101      	movs	r1, #1
 801df70:	2007      	movs	r0, #7
 801df72:	f001 f933 	bl	801f1dc <traceIF_uartPrint>
  (void)osCDS_subscribe_modem_event(events_mask, CST_modem_event_callback);
 801df76:	4904      	ldr	r1, [pc, #16]	; (801df88 <CST_subscribe_modem_events+0x50>)
 801df78:	200f      	movs	r0, #15
 801df7a:	f7fc fd49 	bl	801aa10 <osCDS_subscribe_modem_event>
}
 801df7e:	bd38      	pop	{r3, r4, r5, pc}
 801df80:	20004ddc 	.word	0x20004ddc
 801df84:	08034c84 	.word	0x08034c84
 801df88:	0801cbc9 	.word	0x0801cbc9

0801df8c <CST_get_autom_event>:
  if (GET_AUTOMATON_MSG_TYPE(event) == CST_MESSAGE_CS_EVENT)
 801df8c:	b283      	uxth	r3, r0
 801df8e:	b90b      	cbnz	r3, 801df94 <CST_get_autom_event+0x8>
    autom_event = (cst_autom_event_t)GET_AUTOMATON_MSG_ID(event);
 801df90:	0c00      	lsrs	r0, r0, #16
 801df92:	4770      	bx	lr
  else if (GET_AUTOMATON_MSG_TYPE(event) == CST_MESSAGE_CMD)
 801df94:	2b02      	cmp	r3, #2
 801df96:	d004      	beq.n	801dfa2 <CST_get_autom_event+0x16>
  else if (GET_AUTOMATON_MSG_TYPE(event) == CST_MESSAGE_DC_EVENT)
 801df98:	2b01      	cmp	r3, #1
 801df9a:	d004      	beq.n	801dfa6 <CST_get_autom_event+0x1a>
    __NOP(); /* Nothing to do */
 801df9c:	bf00      	nop
  autom_event = CST_NO_EVENT;
 801df9e:	200d      	movs	r0, #13
}
 801dfa0:	4770      	bx	lr
    autom_event = (cst_autom_event_t)GET_AUTOMATON_MSG_ID(event);
 801dfa2:	0c00      	lsrs	r0, r0, #16
 801dfa4:	4770      	bx	lr
{
 801dfa6:	b510      	push	{r4, lr}
    if (GET_AUTOMATON_MSG_ID(event) == (uint16_t)DC_CELLULAR_DATA_INFO)
 801dfa8:	0c02      	lsrs	r2, r0, #16
 801dfaa:	4b15      	ldr	r3, [pc, #84]	; (801e000 <CST_get_autom_event+0x74>)
 801dfac:	8819      	ldrh	r1, [r3, #0]
 801dfae:	ebb1 4f10 	cmp.w	r1, r0, lsr #16
 801dfb2:	d006      	beq.n	801dfc2 <CST_get_autom_event+0x36>
    else if (GET_AUTOMATON_MSG_ID(event) == (uint16_t)DC_CELLULAR_TARGET_STATE_CMD)
 801dfb4:	4b13      	ldr	r3, [pc, #76]	; (801e004 <CST_get_autom_event+0x78>)
 801dfb6:	8819      	ldrh	r1, [r3, #0]
 801dfb8:	428a      	cmp	r2, r1
 801dfba:	d00d      	beq.n	801dfd8 <CST_get_autom_event+0x4c>
      __NOP(); /* Nothing to do */
 801dfbc:	bf00      	nop
  autom_event = CST_NO_EVENT;
 801dfbe:	200d      	movs	r0, #13
}
 801dfc0:	bd10      	pop	{r4, pc}
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801dfc2:	4c11      	ldr	r4, [pc, #68]	; (801e008 <CST_get_autom_event+0x7c>)
 801dfc4:	2310      	movs	r3, #16
 801dfc6:	4622      	mov	r2, r4
 801dfc8:	4810      	ldr	r0, [pc, #64]	; (801e00c <CST_get_autom_event+0x80>)
 801dfca:	f003 fcfd 	bl	80219c8 <dc_com_read>
      if (cst_cellular_data_info.rt_state == DC_SERVICE_FAIL)
 801dfce:	7a23      	ldrb	r3, [r4, #8]
 801dfd0:	2b08      	cmp	r3, #8
 801dfd2:	d012      	beq.n	801dffa <CST_get_autom_event+0x6e>
  autom_event = CST_NO_EVENT;
 801dfd4:	200d      	movs	r0, #13
 801dfd6:	e7f3      	b.n	801dfc0 <CST_get_autom_event+0x34>
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&cst_target_state, sizeof(cst_target_state));
 801dfd8:	4c0d      	ldr	r4, [pc, #52]	; (801e010 <CST_get_autom_event+0x84>)
 801dfda:	230c      	movs	r3, #12
 801dfdc:	4622      	mov	r2, r4
 801dfde:	480b      	ldr	r0, [pc, #44]	; (801e00c <CST_get_autom_event+0x80>)
 801dfe0:	f003 fcf2 	bl	80219c8 <dc_com_read>
      if (cst_target_state.rt_state == DC_SERVICE_ON)
 801dfe4:	7a23      	ldrb	r3, [r4, #8]
 801dfe6:	2b07      	cmp	r3, #7
 801dfe8:	d001      	beq.n	801dfee <CST_get_autom_event+0x62>
  autom_event = CST_NO_EVENT;
 801dfea:	200d      	movs	r0, #13
 801dfec:	e7e8      	b.n	801dfc0 <CST_get_autom_event+0x34>
        cst_cellular_params.target_state = cst_target_state.target_state;
 801dfee:	7a62      	ldrb	r2, [r4, #9]
 801dff0:	4b08      	ldr	r3, [pc, #32]	; (801e014 <CST_get_autom_event+0x88>)
 801dff2:	f883 2131 	strb.w	r2, [r3, #305]	; 0x131
        autom_event = CST_TARGET_STATE_CMD_EVENT;
 801dff6:	200f      	movs	r0, #15
 801dff8:	e7e2      	b.n	801dfc0 <CST_get_autom_event+0x34>
        autom_event = CST_CELLULAR_DATA_FAIL_EVENT;
 801dffa:	200a      	movs	r0, #10
 801dffc:	e7e0      	b.n	801dfc0 <CST_get_autom_event+0x34>
 801dffe:	bf00      	nop
 801e000:	20000234 	.word	0x20000234
 801e004:	2000023e 	.word	0x2000023e
 801e008:	2000405c 	.word	0x2000405c
 801e00c:	200058b0 	.word	0x200058b0
 801e010:	200044b4 	.word	0x200044b4
 801e014:	20004160 	.word	0x20004160

0801e018 <CST_get_network_status>:
{
 801e018:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e01c:	b094      	sub	sp, #80	; 0x50
  (void)memset((void *)&reg_status, 0, sizeof(reg_status));
 801e01e:	224e      	movs	r2, #78	; 0x4e
 801e020:	2100      	movs	r1, #0
 801e022:	4668      	mov	r0, sp
 801e024:	f007 fe97 	bl	8025d56 <memset>
  cs_status = osCDS_get_net_status(&reg_status);
 801e028:	4668      	mov	r0, sp
 801e02a:	f7fc fcb3 	bl	801a994 <osCDS_get_net_status>
  if (cs_status == CELLULAR_OK)
 801e02e:	2800      	cmp	r0, #0
 801e030:	d162      	bne.n	801e0f8 <CST_get_network_status+0xe0>
    cst_context.current_EPS_NetworkRegState  = reg_status.EPS_NetworkRegState;
 801e032:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 801e036:	4b33      	ldr	r3, [pc, #204]	; (801e104 <CST_get_network_status+0xec>)
 801e038:	80da      	strh	r2, [r3, #6]
    cst_context.current_GPRS_NetworkRegState = reg_status.GPRS_NetworkRegState;
 801e03a:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 801e03e:	8119      	strh	r1, [r3, #8]
    cst_context.current_CS_NetworkRegState   = reg_status.CS_NetworkRegState;
 801e040:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 801e044:	8158      	strh	r0, [r3, #10]
    if ((cst_context.current_EPS_NetworkRegState  != CS_NRS_REGISTERED_HOME_NETWORK)
 801e046:	2a01      	cmp	r2, #1
 801e048:	d00b      	beq.n	801e062 <CST_get_network_status+0x4a>
        && (cst_context.current_EPS_NetworkRegState  != CS_NRS_REGISTERED_ROAMING)
 801e04a:	2a05      	cmp	r2, #5
 801e04c:	d009      	beq.n	801e062 <CST_get_network_status+0x4a>
        && (cst_context.current_GPRS_NetworkRegState != CS_NRS_REGISTERED_HOME_NETWORK)
 801e04e:	2901      	cmp	r1, #1
 801e050:	d007      	beq.n	801e062 <CST_get_network_status+0x4a>
        && (cst_context.current_GPRS_NetworkRegState != CS_NRS_REGISTERED_ROAMING))
 801e052:	2905      	cmp	r1, #5
 801e054:	d005      	beq.n	801e062 <CST_get_network_status+0x4a>
      if (cst_context.current_CS_NetworkRegState == CS_NRS_UNKNOWN)
 801e056:	2804      	cmp	r0, #4
 801e058:	d001      	beq.n	801e05e <CST_get_network_status+0x46>
        ret = CST_NOT_REGISTERED;
 801e05a:	2001      	movs	r0, #1
 801e05c:	e006      	b.n	801e06c <CST_get_network_status+0x54>
        ret = CST_NET_UNKNOWN ;
 801e05e:	2003      	movs	r0, #3
 801e060:	e004      	b.n	801e06c <CST_get_network_status+0x54>
      if (((uint16_t)reg_status.optional_fields_presence & (uint16_t)CS_RSF_FORMAT_PRESENT) != 0U)
 801e062:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 801e066:	f010 0001 	ands.w	r0, r0, #1
 801e06a:	d102      	bne.n	801e072 <CST_get_network_status+0x5a>
}
 801e06c:	b014      	add	sp, #80	; 0x50
 801e06e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        (void)dc_com_read(&dc_com_db,  DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801e072:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 801e118 <CST_get_network_status+0x100>
 801e076:	4d24      	ldr	r5, [pc, #144]	; (801e108 <CST_get_network_status+0xf0>)
 801e078:	4f24      	ldr	r7, [pc, #144]	; (801e10c <CST_get_network_status+0xf4>)
 801e07a:	23f4      	movs	r3, #244	; 0xf4
 801e07c:	462a      	mov	r2, r5
 801e07e:	f8b8 1000 	ldrh.w	r1, [r8]
 801e082:	4638      	mov	r0, r7
 801e084:	f003 fca0 	bl	80219c8 <dc_com_read>
        (void)memcpy(cst_cellular_info.mno_name, reg_status.operator_name, DC_MAX_SIZE_MNO_NAME - 1U);
 801e088:	f105 0430 	add.w	r4, r5, #48	; 0x30
 801e08c:	f10d 0c0c 	add.w	ip, sp, #12
 801e090:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801e094:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e096:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 801e09a:	c407      	stmia	r4!, {r0, r1, r2}
 801e09c:	f824 3b02 	strh.w	r3, [r4], #2
 801e0a0:	0c1b      	lsrs	r3, r3, #16
 801e0a2:	7023      	strb	r3, [r4, #0]
        cst_cellular_info.mno_name[DC_MAX_SIZE_MNO_NAME - 1U] = 0;  /* to avoid a non null terminated string */
 801e0a4:	2400      	movs	r4, #0
 801e0a6:	f885 404f 	strb.w	r4, [r5, #79]	; 0x4f
        cst_cellular_info.rt_state = DC_SERVICE_ON;
 801e0aa:	2607      	movs	r6, #7
 801e0ac:	722e      	strb	r6, [r5, #8]
        cst_cellular_info.access_techno = (dc_access_techno_t)reg_status.AcT;
 801e0ae:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
 801e0b2:	f885 30f0 	strb.w	r3, [r5, #240]	; 0xf0
        (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801e0b6:	23f4      	movs	r3, #244	; 0xf4
 801e0b8:	462a      	mov	r2, r5
 801e0ba:	f8b8 1000 	ldrh.w	r1, [r8]
 801e0be:	4638      	mov	r0, r7
 801e0c0:	f003 fc36 	bl	8021930 <dc_com_write>
        PRINT_CELLULAR_SERVICE(" ->operator_name = %s", reg_status.operator_name)
 801e0c4:	4d12      	ldr	r5, [pc, #72]	; (801e110 <CST_get_network_status+0xf8>)
 801e0c6:	aa03      	add	r2, sp, #12
 801e0c8:	4912      	ldr	r1, [pc, #72]	; (801e114 <CST_get_network_status+0xfc>)
 801e0ca:	4628      	mov	r0, r5
 801e0cc:	f007 fdd0 	bl	8025c70 <sprintf>
 801e0d0:	4628      	mov	r0, r5
 801e0d2:	f001 f81e 	bl	801f112 <crs_strlen>
 801e0d6:	b283      	uxth	r3, r0
 801e0d8:	462a      	mov	r2, r5
 801e0da:	2101      	movs	r1, #1
 801e0dc:	4630      	mov	r0, r6
 801e0de:	f001 f85b 	bl	801f198 <traceIF_itmPrint>
 801e0e2:	4628      	mov	r0, r5
 801e0e4:	f001 f815 	bl	801f112 <crs_strlen>
 801e0e8:	b283      	uxth	r3, r0
 801e0ea:	462a      	mov	r2, r5
 801e0ec:	2101      	movs	r1, #1
 801e0ee:	4630      	mov	r0, r6
 801e0f0:	f001 f874 	bl	801f1dc <traceIF_uartPrint>
      ret = CST_NET_REGISTERED;
 801e0f4:	4620      	mov	r0, r4
 801e0f6:	e7b9      	b.n	801e06c <CST_get_network_status+0x54>
    cst_context.current_EPS_NetworkRegState  = CS_NRS_NOT_REGISTERED_SEARCHING;
 801e0f8:	4b02      	ldr	r3, [pc, #8]	; (801e104 <CST_get_network_status+0xec>)
 801e0fa:	2002      	movs	r0, #2
 801e0fc:	80d8      	strh	r0, [r3, #6]
    cst_context.current_GPRS_NetworkRegState = CS_NRS_NOT_REGISTERED_SEARCHING;
 801e0fe:	8118      	strh	r0, [r3, #8]
    cst_context.current_CS_NetworkRegState   = CS_NRS_NOT_REGISTERED_SEARCHING;
 801e100:	8158      	strh	r0, [r3, #10]
    ret = CST_NET_STATUS_ERROR;
 801e102:	e7b3      	b.n	801e06c <CST_get_network_status+0x54>
 801e104:	200000b0 	.word	0x200000b0
 801e108:	2000406c 	.word	0x2000406c
 801e10c:	200058b0 	.word	0x200058b0
 801e110:	20004ddc 	.word	0x20004ddc
 801e114:	08034ca0 	.word	0x08034ca0
 801e118:	20000236 	.word	0x20000236

0801e11c <ERROR_Handler_Init>:
void ERROR_Handler_Init(void)
{
  uint32_t i;

  /* initialize error array */
  for (i = 0U; i < MAX_ERROR_ENTRIES; i++)
 801e11c:	2300      	movs	r3, #0
 801e11e:	e00b      	b.n	801e138 <ERROR_Handler_Init+0x1c>
  {
    errors_table[i].channel = DBG_CHAN_ERROR_LOGGER; /* default value = self (ie no error) */
 801e120:	4908      	ldr	r1, [pc, #32]	; (801e144 <ERROR_Handler_Init+0x28>)
 801e122:	0118      	lsls	r0, r3, #4
 801e124:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 801e128:	f04f 0c0b 	mov.w	ip, #11
 801e12c:	f801 c000 	strb.w	ip, [r1, r0]
    errors_table[i].errorId = 0;
 801e130:	2100      	movs	r1, #0
 801e132:	6051      	str	r1, [r2, #4]
    errors_table[i].gravity = ERROR_NO;
 801e134:	7211      	strb	r1, [r2, #8]
  for (i = 0U; i < MAX_ERROR_ENTRIES; i++)
 801e136:	3301      	adds	r3, #1
 801e138:	2b1f      	cmp	r3, #31
 801e13a:	d9f1      	bls.n	801e120 <ERROR_Handler_Init+0x4>
  }
  error_index = 0U; /* current error index */
 801e13c:	4b02      	ldr	r3, [pc, #8]	; (801e148 <ERROR_Handler_Init+0x2c>)
 801e13e:	2200      	movs	r2, #0
 801e140:	801a      	strh	r2, [r3, #0]
}
 801e142:	4770      	bx	lr
 801e144:	200044c4 	.word	0x200044c4
 801e148:	200044c2 	.word	0x200044c2

0801e14c <ERROR_Handler>:

void ERROR_Handler(dbg_channels_t chan, int32_t errorId, error_gravity_t gravity)
{
 801e14c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e14e:	b083      	sub	sp, #12
 801e150:	4606      	mov	r6, r0
 801e152:	460f      	mov	r7, r1
 801e154:	4615      	mov	r5, r2
  /* if this is the very first error, init error array */
  if (error_counter == 0U)
 801e156:	4b2a      	ldr	r3, [pc, #168]	; (801e200 <ERROR_Handler+0xb4>)
 801e158:	881b      	ldrh	r3, [r3, #0]
 801e15a:	2b00      	cmp	r3, #0
 801e15c:	d03c      	beq.n	801e1d8 <ERROR_Handler+0x8c>
  {
    ERROR_Handler_Init();
  }

  /* log the error */
  error_counter = (error_counter + 1U) % MAX_ERROR_COUNTER;
 801e15e:	4928      	ldr	r1, [pc, #160]	; (801e200 <ERROR_Handler+0xb4>)
 801e160:	880b      	ldrh	r3, [r1, #0]
 801e162:	3301      	adds	r3, #1
 801e164:	4a27      	ldr	r2, [pc, #156]	; (801e204 <ERROR_Handler+0xb8>)
 801e166:	fba2 2c03 	umull	r2, ip, r2, r3
 801e16a:	ea4f 3cdc 	mov.w	ip, ip, lsr #15
 801e16e:	ebcc 4c0c 	rsb	ip, ip, ip, lsl #16
 801e172:	eba3 0c0c 	sub.w	ip, r3, ip
 801e176:	fa1f f28c 	uxth.w	r2, ip
 801e17a:	800a      	strh	r2, [r1, #0]
  errors_table[error_index].count = error_counter;
 801e17c:	4b22      	ldr	r3, [pc, #136]	; (801e208 <ERROR_Handler+0xbc>)
 801e17e:	881b      	ldrh	r3, [r3, #0]
 801e180:	4922      	ldr	r1, [pc, #136]	; (801e20c <ERROR_Handler+0xc0>)
 801e182:	0118      	lsls	r0, r3, #4
 801e184:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 801e188:	60da      	str	r2, [r3, #12]
  errors_table[error_index].channel = chan;
 801e18a:	540e      	strb	r6, [r1, r0]
  errors_table[error_index].errorId = errorId;
 801e18c:	605f      	str	r7, [r3, #4]
  errors_table[error_index].gravity = gravity;
 801e18e:	721d      	strb	r5, [r3, #8]

  PRINT_INFO("LOG ERROR #%d: channel=%d / errorId=%ld / gravity=%d", error_counter, chan, errorId, gravity)
 801e190:	4c1f      	ldr	r4, [pc, #124]	; (801e210 <ERROR_Handler+0xc4>)
 801e192:	9501      	str	r5, [sp, #4]
 801e194:	9700      	str	r7, [sp, #0]
 801e196:	4633      	mov	r3, r6
 801e198:	491e      	ldr	r1, [pc, #120]	; (801e214 <ERROR_Handler+0xc8>)
 801e19a:	4620      	mov	r0, r4
 801e19c:	f007 fd68 	bl	8025c70 <sprintf>
 801e1a0:	4620      	mov	r0, r4
 801e1a2:	f000 ffb6 	bl	801f112 <crs_strlen>
 801e1a6:	b283      	uxth	r3, r0
 801e1a8:	4622      	mov	r2, r4
 801e1aa:	2101      	movs	r1, #1
 801e1ac:	200b      	movs	r0, #11
 801e1ae:	f000 fff3 	bl	801f198 <traceIF_itmPrint>
 801e1b2:	4620      	mov	r0, r4
 801e1b4:	f000 ffad 	bl	801f112 <crs_strlen>
 801e1b8:	b283      	uxth	r3, r0
 801e1ba:	4622      	mov	r2, r4
 801e1bc:	2101      	movs	r1, #1
 801e1be:	200b      	movs	r0, #11
 801e1c0:	f001 f80c 	bl	801f1dc <traceIF_uartPrint>

  /* endless loop if error is fatal */
  if (gravity == ERROR_FATAL)
 801e1c4:	2d03      	cmp	r5, #3
 801e1c6:	d00a      	beq.n	801e1de <ERROR_Handler+0x92>
    NVIC_SystemReset();
    /* Infinite loop is done in NVIC_SystemReset(); */
  }

  /* increment error index */
  error_index = (error_index + 1U) %  MAX_ERROR_ENTRIES;
 801e1c8:	4a0f      	ldr	r2, [pc, #60]	; (801e208 <ERROR_Handler+0xbc>)
 801e1ca:	8813      	ldrh	r3, [r2, #0]
 801e1cc:	3301      	adds	r3, #1
 801e1ce:	f003 031f 	and.w	r3, r3, #31
 801e1d2:	8013      	strh	r3, [r2, #0]
}
 801e1d4:	b003      	add	sp, #12
 801e1d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ERROR_Handler_Init();
 801e1d8:	f7ff ffa0 	bl	801e11c <ERROR_Handler_Init>
 801e1dc:	e7bf      	b.n	801e15e <ERROR_Handler+0x12>
    HAL_Delay(1000U);
 801e1de:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801e1e2:	f7e8 fedf 	bl	8006fa4 <HAL_Delay>
  __ASM volatile ("dsb 0xF":::"memory");
 801e1e6:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 801e1ea:	490b      	ldr	r1, [pc, #44]	; (801e218 <ERROR_Handler+0xcc>)
 801e1ec:	68ca      	ldr	r2, [r1, #12]
 801e1ee:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 801e1f2:	4b0a      	ldr	r3, [pc, #40]	; (801e21c <ERROR_Handler+0xd0>)
 801e1f4:	4313      	orrs	r3, r2
 801e1f6:	60cb      	str	r3, [r1, #12]
 801e1f8:	f3bf 8f4f 	dsb	sy
    __NOP();
 801e1fc:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 801e1fe:	e7fd      	b.n	801e1fc <ERROR_Handler+0xb0>
 801e200:	200044c0 	.word	0x200044c0
 801e204:	80008001 	.word	0x80008001
 801e208:	200044c2 	.word	0x200044c2
 801e20c:	200044c4 	.word	0x200044c4
 801e210:	200051dc 	.word	0x200051dc
 801e214:	08034cb8 	.word	0x08034cb8
 801e218:	e000ed00 	.word	0xe000ed00
 801e21c:	05fa0004 	.word	0x05fa0004

0801e220 <HAL_GPIO_EXTI_Callback>:
/* Functions Definition ------------------------------------------------------*/


void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == MODEM_RING_PIN)
 801e220:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 801e224:	d001      	beq.n	801e22a <HAL_GPIO_EXTI_Callback+0xa>
  }
#endif /* USE_BUTTONS == 1 */
  else
  {
    /* Nothing to do */
    __NOP();
 801e226:	bf00      	nop
 801e228:	4770      	bx	lr
{
 801e22a:	b508      	push	{r3, lr}
    GPIO_PinState gstate = HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN);
 801e22c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801e230:	4804      	ldr	r0, [pc, #16]	; (801e244 <HAL_GPIO_EXTI_Callback+0x24>)
 801e232:	f7e9 fc31 	bl	8007a98 <HAL_GPIO_ReadPin>
 801e236:	4602      	mov	r2, r0
    atcc_hw_event(DEVTYPE_MODEM_CELLULAR, HWEVT_MODEM_RING, gstate);
 801e238:	2101      	movs	r1, #1
 801e23a:	2000      	movs	r0, #0
 801e23c:	f7ee fa56 	bl	800c6ec <atcc_hw_event>
  }
}
 801e240:	bd08      	pop	{r3, pc}
 801e242:	bf00      	nop
 801e244:	48000400 	.word	0x48000400

0801e248 <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 801e248:	b508      	push	{r3, lr}
  if (huart->Instance == MODEM_UART_INSTANCE)
 801e24a:	6803      	ldr	r3, [r0, #0]
 801e24c:	4a06      	ldr	r2, [pc, #24]	; (801e268 <HAL_UART_RxCpltCallback+0x20>)
 801e24e:	4293      	cmp	r3, r2
 801e250:	d004      	beq.n	801e25c <HAL_UART_RxCpltCallback+0x14>
  {
    IPC_UART_RxCpltCallback(huart);
  }
#if (USE_CMD_CONSOLE == 1)
  else if (huart->Instance == TRACE_INTERFACE_INSTANCE)
 801e252:	4a06      	ldr	r2, [pc, #24]	; (801e26c <HAL_UART_RxCpltCallback+0x24>)
 801e254:	4293      	cmp	r3, r2
 801e256:	d004      	beq.n	801e262 <HAL_UART_RxCpltCallback+0x1a>
#endif  /* USE_LINK_UART */
#endif  /* USE_CMD_CONSOLE */
  else
  {
    /* Nothing to do */
    __NOP();
 801e258:	bf00      	nop
  }
}
 801e25a:	bd08      	pop	{r3, pc}
    IPC_UART_RxCpltCallback(huart);
 801e25c:	f000 fe1a 	bl	801ee94 <IPC_UART_RxCpltCallback>
 801e260:	e7fb      	b.n	801e25a <HAL_UART_RxCpltCallback+0x12>
    CMD_RxCpltCallback(huart);
 801e262:	f003 ffb3 	bl	80221cc <CMD_RxCpltCallback>
 801e266:	e7f8      	b.n	801e25a <HAL_UART_RxCpltCallback+0x12>
 801e268:	40004800 	.word	0x40004800
 801e26c:	40013800 	.word	0x40013800

0801e270 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 801e270:	b508      	push	{r3, lr}
  if (huart->Instance == MODEM_UART_INSTANCE)
 801e272:	6802      	ldr	r2, [r0, #0]
 801e274:	4b03      	ldr	r3, [pc, #12]	; (801e284 <HAL_UART_TxCpltCallback+0x14>)
 801e276:	429a      	cmp	r2, r3
 801e278:	d000      	beq.n	801e27c <HAL_UART_TxCpltCallback+0xc>
  {
    IPC_UART_TxCpltCallback(huart);
  }
}
 801e27a:	bd08      	pop	{r3, pc}
    IPC_UART_TxCpltCallback(huart);
 801e27c:	f000 fe20 	bl	801eec0 <IPC_UART_TxCpltCallback>
}
 801e280:	e7fb      	b.n	801e27a <HAL_UART_TxCpltCallback+0xa>
 801e282:	bf00      	nop
 801e284:	40004800 	.word	0x40004800

0801e288 <HAL_UART_ErrorCallback>:

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 801e288:	b508      	push	{r3, lr}
  if (huart->Instance == MODEM_UART_INSTANCE)
 801e28a:	6802      	ldr	r2, [r0, #0]
 801e28c:	4b03      	ldr	r3, [pc, #12]	; (801e29c <HAL_UART_ErrorCallback+0x14>)
 801e28e:	429a      	cmp	r2, r3
 801e290:	d000      	beq.n	801e294 <HAL_UART_ErrorCallback+0xc>
  {
    IPC_UART_ErrorCallback(huart);
  }
}
 801e292:	bd08      	pop	{r3, pc}
    IPC_UART_ErrorCallback(huart);
 801e294:	f000 fe26 	bl	801eee4 <IPC_UART_ErrorCallback>
}
 801e298:	e7fb      	b.n	801e292 <HAL_UART_ErrorCallback+0xa>
 801e29a:	bf00      	nop
 801e29c:	40004800 	.word	0x40004800

0801e2a0 <board_leds_init>:
  * @brief  Component initialisation
  * @param  -
  * @retval true/false - init OK/NOK
  */
bool board_leds_init(void)
{
 801e2a0:	b508      	push	{r3, lr}
  bool result = true;

  if (BOARD_LEDS_1 != NO_LED)
  {
    BSP_LED_Init((Led_TypeDef)BOARD_LEDS_1);
 801e2a2:	2000      	movs	r0, #0
 801e2a4:	f7e3 fd66 	bl	8001d74 <BSP_LED_Init>
  }
  if (BOARD_LEDS_2 != NO_LED)
  {
    BSP_LED_Init((Led_TypeDef)BOARD_LEDS_2);
 801e2a8:	2001      	movs	r0, #1
 801e2aa:	f7e3 fd63 	bl	8001d74 <BSP_LED_Init>
  }
  if (BOARD_LEDS_3 != NO_LED)
  {
    BSP_LED_Init((Led_TypeDef)BOARD_LEDS_3);
 801e2ae:	2002      	movs	r0, #2
 801e2b0:	f7e3 fd60 	bl	8001d74 <BSP_LED_Init>
  }

  return (result);
}
 801e2b4:	2001      	movs	r0, #1
 801e2b6:	bd08      	pop	{r3, pc}

0801e2b8 <board_leds_start>:
  */
bool board_leds_start(void)
{
  bool result = true;
  return (result);
}
 801e2b8:	2001      	movs	r0, #1
 801e2ba:	4770      	bx	lr

0801e2bc <IPC_init>:
IPC_Status_t IPC_init(IPC_Device_t device, IPC_Interface_t itf_type, void *hitf)
{
  IPC_Status_t status;

  /* check that device value is valid */
  if (device >= IPC_MAX_DEVICES)
 801e2bc:	b948      	cbnz	r0, 801e2d2 <IPC_init+0x16>
{
 801e2be:	b508      	push	{r3, lr}
  {
    /* IPC device id exceed maximum size defined */
    status = IPC_ERROR;
  }
  else if (hitf == NULL)
 801e2c0:	b14a      	cbz	r2, 801e2d6 <IPC_init+0x1a>
  {
    status = IPC_ERROR;
  }
  else
  {
    if (itf_type == IPC_INTERFACE_UART)
 801e2c2:	2901      	cmp	r1, #1
 801e2c4:	d001      	beq.n	801e2ca <IPC_init+0xe>
      status = IPC_ERROR;
#endif /* IPC_USE_UART == 1U */
    }
    else if (itf_type == IPC_INTERFACE_SPI)
    {
      status = IPC_ERROR;
 801e2c6:	2001      	movs	r0, #1
      /* interface not supported yet */
      status = IPC_ERROR;
    }
  }
  return (status);
}
 801e2c8:	bd08      	pop	{r3, pc}
      status = IPC_UART_init(device, (UART_HandleTypeDef *) hitf);
 801e2ca:	4611      	mov	r1, r2
 801e2cc:	f000 fa7a 	bl	801e7c4 <IPC_UART_init>
 801e2d0:	e7fa      	b.n	801e2c8 <IPC_init+0xc>
    status = IPC_ERROR;
 801e2d2:	2001      	movs	r0, #1
}
 801e2d4:	4770      	bx	lr
    status = IPC_ERROR;
 801e2d6:	2001      	movs	r0, #1
 801e2d8:	e7f6      	b.n	801e2c8 <IPC_init+0xc>
	...

0801e2dc <IPC_open>:
                      IPC_CheckEndOfMsgCallbackTypeDef pCheckEndOfMsg)
{
  IPC_Status_t status;

  /* check pointers */
  if ((hipc == NULL) ||
 801e2dc:	b1f0      	cbz	r0, 801e31c <IPC_open+0x40>
 801e2de:	4684      	mov	ip, r0
 801e2e0:	b1f3      	cbz	r3, 801e320 <IPC_open+0x44>
{
 801e2e2:	b510      	push	{r4, lr}
 801e2e4:	b082      	sub	sp, #8
      (pRxClientCallback == NULL) ||
 801e2e6:	9804      	ldr	r0, [sp, #16]
 801e2e8:	b1e0      	cbz	r0, 801e324 <IPC_open+0x48>
      (pTxClientCallback == NULL))
  {
    status = IPC_ERROR;
  }
  else if (device >= IPC_MAX_DEVICES)
 801e2ea:	b9e9      	cbnz	r1, 801e328 <IPC_open+0x4c>
  {
    /* IPC device id exceed maximum size defined */
    status = IPC_ERROR;
  }
  /* check if the device has been correctly initialized */
  else if (IPC_DevicesList[device].state != IPC_STATE_INITIALIZED)
 801e2ec:	eb01 0041 	add.w	r0, r1, r1, lsl #1
 801e2f0:	4c0f      	ldr	r4, [pc, #60]	; (801e330 <IPC_open+0x54>)
 801e2f2:	f814 0030 	ldrb.w	r0, [r4, r0, lsl #3]
 801e2f6:	2801      	cmp	r0, #1
 801e2f8:	d001      	beq.n	801e2fe <IPC_open+0x22>
  {
    status = IPC_ERROR;
 801e2fa:	2001      	movs	r0, #1
 801e2fc:	e015      	b.n	801e32a <IPC_open+0x4e>
  }
  else
  {
    if (IPC_DevicesList[device].phy_int.interface_type == IPC_INTERFACE_UART)
 801e2fe:	eb01 0e41 	add.w	lr, r1, r1, lsl #1
 801e302:	eb04 04ce 	add.w	r4, r4, lr, lsl #3
 801e306:	7924      	ldrb	r4, [r4, #4]
 801e308:	2c01      	cmp	r4, #1
 801e30a:	d10e      	bne.n	801e32a <IPC_open+0x4e>
    {
#if (IPC_USE_UART == 1U)
      status = IPC_UART_open(hipc, device, mode, pRxClientCallback, pTxClientCallback, pCheckEndOfMsg);
 801e30c:	9805      	ldr	r0, [sp, #20]
 801e30e:	9001      	str	r0, [sp, #4]
 801e310:	9804      	ldr	r0, [sp, #16]
 801e312:	9000      	str	r0, [sp, #0]
 801e314:	4660      	mov	r0, ip
 801e316:	f000 fa73 	bl	801e800 <IPC_UART_open>
 801e31a:	e006      	b.n	801e32a <IPC_open+0x4e>
    status = IPC_ERROR;
 801e31c:	2001      	movs	r0, #1
 801e31e:	4770      	bx	lr
 801e320:	2001      	movs	r0, #1
      status = IPC_ERROR;
    }
  }

  return (status);
}
 801e322:	4770      	bx	lr
    status = IPC_ERROR;
 801e324:	2001      	movs	r0, #1
 801e326:	e000      	b.n	801e32a <IPC_open+0x4e>
    status = IPC_ERROR;
 801e328:	2001      	movs	r0, #1
}
 801e32a:	b002      	add	sp, #8
 801e32c:	bd10      	pop	{r4, pc}
 801e32e:	bf00      	nop
 801e330:	200046c4 	.word	0x200046c4

0801e334 <IPC_close>:
  */
IPC_Status_t IPC_close(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e334:	b118      	cbz	r0, 801e33e <IPC_close+0xa>
{
 801e336:	b508      	push	{r3, lr}
  {
    status = IPC_UART_close(hipc);
 801e338:	f000 fb60 	bl	801e9fc <IPC_UART_close>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e33c:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e33e:	2001      	movs	r0, #1
}
 801e340:	4770      	bx	lr

0801e342 <IPC_reset>:
  */
IPC_Status_t IPC_reset(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e342:	b118      	cbz	r0, 801e34c <IPC_reset+0xa>
{
 801e344:	b508      	push	{r3, lr}
  {
    status = IPC_UART_reset(hipc);
 801e346:	f000 fc1b 	bl	801eb80 <IPC_UART_reset>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e34a:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e34c:	2001      	movs	r0, #1
}
 801e34e:	4770      	bx	lr

0801e350 <IPC_abort>:
  */
IPC_Status_t IPC_abort(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e350:	b118      	cbz	r0, 801e35a <IPC_abort+0xa>
{
 801e352:	b508      	push	{r3, lr}
  {
    status = IPC_UART_abort(hipc);
 801e354:	f000 fc54 	bl	801ec00 <IPC_UART_abort>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e358:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e35a:	2001      	movs	r0, #1
}
 801e35c:	4770      	bx	lr

0801e35e <IPC_select>:
  */
IPC_Status_t IPC_select(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e35e:	b118      	cbz	r0, 801e368 <IPC_select+0xa>
{
 801e360:	b508      	push	{r3, lr}
  {
    status = IPC_UART_select(hipc);
 801e362:	f000 fc75 	bl	801ec50 <IPC_UART_select>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e366:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e368:	2001      	movs	r0, #1
}
 801e36a:	4770      	bx	lr

0801e36c <IPC_get_other_channel>:
  * @brief  Get other channel handle if exists.
  * @param  hipc IPC handle.
  * @retval IPC_Handle_t*
  */
IPC_Handle_t *IPC_get_other_channel(IPC_Handle_t *hipc)
{
 801e36c:	b508      	push	{r3, lr}
  return (IPC_UART_get_other_channel(hipc));
 801e36e:	f000 fc9d 	bl	801ecac <IPC_UART_get_other_channel>
}
 801e372:	bd08      	pop	{r3, pc}

0801e374 <IPC_send>:
  */
IPC_Status_t IPC_send(IPC_Handle_t *hipc, uint8_t *p_TxBuffer, uint16_t bufsize)
{
  IPC_Status_t status;

  if ((hipc != NULL) && (p_TxBuffer != NULL))
 801e374:	b120      	cbz	r0, 801e380 <IPC_send+0xc>
{
 801e376:	b508      	push	{r3, lr}
  if ((hipc != NULL) && (p_TxBuffer != NULL))
 801e378:	b121      	cbz	r1, 801e384 <IPC_send+0x10>
  {
    status = IPC_UART_send(hipc, p_TxBuffer, bufsize);
 801e37a:	f000 fcb9 	bl	801ecf0 <IPC_UART_send>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e37e:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e380:	2001      	movs	r0, #1
}
 801e382:	4770      	bx	lr
    status = IPC_ERROR;
 801e384:	2001      	movs	r0, #1
 801e386:	e7fa      	b.n	801e37e <IPC_send+0xa>

0801e388 <IPC_receive>:
  */
IPC_Status_t IPC_receive(IPC_Handle_t *hipc, IPC_RxMessage_t *p_msg)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e388:	b118      	cbz	r0, 801e392 <IPC_receive+0xa>
{
 801e38a:	b508      	push	{r3, lr}
  {
    status = IPC_UART_receive(hipc, p_msg);
 801e38c:	f000 fcc4 	bl	801ed18 <IPC_UART_receive>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e390:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e392:	2001      	movs	r0, #1
}
 801e394:	4770      	bx	lr
	...

0801e398 <RXFIFO_incrementTail>:
  * @param  inc_size Size to increment.
  * @retval none.
  */
static void RXFIFO_incrementTail(IPC_Handle_t *hipc, uint16_t inc_size)
{
  hipc->RxQueue.index_read = (hipc->RxQueue.index_read + inc_size) % IPC_RXBUF_MAXSIZE;
 801e398:	f8b0 37de 	ldrh.w	r3, [r0, #2014]	; 0x7de
 801e39c:	4419      	add	r1, r3
 801e39e:	4b05      	ldr	r3, [pc, #20]	; (801e3b4 <RXFIFO_incrementTail+0x1c>)
 801e3a0:	fb83 2301 	smull	r2, r3, r3, r1
 801e3a4:	11db      	asrs	r3, r3, #7
 801e3a6:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e3aa:	fb02 1313 	mls	r3, r2, r3, r1
 801e3ae:	f8a0 37de 	strh.w	r3, [r0, #2014]	; 0x7de
}
 801e3b2:	4770      	bx	lr
 801e3b4:	10624dd3 	.word	0x10624dd3

0801e3b8 <RXFIFO_updateMsgHeader>:
  uint8_t header_byte1;
  uint8_t header_byte2;
  uint16_t index;

  /* set header byte 1:  complete bit + size (upper part)*/
  header_byte1 = (uint8_t)(IPC_RXMSG_HEADER_COMPLETE_MASK | ((hipc->RxQueue.current_msg_size >> 8) & 0x9FU));
 801e3b8:	f8b0 17e4 	ldrh.w	r1, [r0, #2020]	; 0x7e4
 801e3bc:	f3c1 2304 	ubfx	r3, r1, #8, #5
 801e3c0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  /* set header byte 2:  size (lower part)*/
  header_byte2 = (uint8_t)(hipc->RxQueue.current_msg_size & 0x00FFU);

  /* write header bytes */
  index = hipc->RxQueue.current_msg_index;
 801e3c4:	f8b0 27e2 	ldrh.w	r2, [r0, #2018]	; 0x7e2
  hipc->RxQueue.data[index] = header_byte1;
 801e3c8:	eb00 0c02 	add.w	ip, r0, r2
 801e3cc:	f88c 300e 	strb.w	r3, [ip, #14]
  index = (index + 1U) % IPC_RXBUF_MAXSIZE;
 801e3d0:	3201      	adds	r2, #1
 801e3d2:	4b06      	ldr	r3, [pc, #24]	; (801e3ec <RXFIFO_updateMsgHeader+0x34>)
 801e3d4:	fba3 c302 	umull	ip, r3, r3, r2
 801e3d8:	09db      	lsrs	r3, r3, #7
 801e3da:	f44f 6cfa 	mov.w	ip, #2000	; 0x7d0
 801e3de:	fb0c 2313 	mls	r3, ip, r3, r2
  hipc->RxQueue.data[index] = header_byte2;
 801e3e2:	fa10 f383 	uxtah	r3, r0, r3
 801e3e6:	7399      	strb	r1, [r3, #14]
  hipc->dbgRxQueue.msg_info_queue[hipc->dbgRxQueue.queue_pos].complete = 1;
  hipc->dbgRxQueue.queue_pos = (hipc->dbgRxQueue.queue_pos + 1) % DBG_QUEUE_SIZE;
  hipc->dbgRxQueue.msg_info_queue[hipc->dbgRxQueue.queue_pos].start_pos = hipc->RxQueue.current_msg_index;
  hipc->dbgRxQueue.msg_info_queue[hipc->dbgRxQueue.queue_pos].complete = 0;
#endif /* DBG_IPC_RX_FIFO */
}
 801e3e8:	4770      	bx	lr
 801e3ea:	bf00      	nop
 801e3ec:	10624dd3 	.word	0x10624dd3

0801e3f0 <RXFIFO_rearm_RX_IT>:
    RXFIFO_incrementHead(hipc);
  }
}

static void RXFIFO_rearm_RX_IT(IPC_Handle_t *hipc)
{
 801e3f0:	b508      	push	{r3, lr}
#if (IPC_USE_UART == 1U)
  IPC_UART_rearm_RX_IT(hipc);
 801e3f2:	f000 fd39 	bl	801ee68 <IPC_UART_rearm_RX_IT>
#else
  __NOP();
#endif /* IPC_USE_UART == 1U */
}
 801e3f6:	bd08      	pop	{r3, pc}

0801e3f8 <IPC_RXFIFO_init>:
{
 801e3f8:	b510      	push	{r4, lr}
 801e3fa:	4604      	mov	r4, r0
  (void) memset(hipc->RxQueue.data, 0, sizeof(uint8_t) * IPC_RXBUF_MAXSIZE);
 801e3fc:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e400:	2100      	movs	r1, #0
 801e402:	300e      	adds	r0, #14
 801e404:	f007 fca7 	bl	8025d56 <memset>
  hipc->RxQueue.index_read = 0U;
 801e408:	2300      	movs	r3, #0
 801e40a:	f8a4 37de 	strh.w	r3, [r4, #2014]	; 0x7de
  hipc->RxQueue.index_write = IPC_RXMSG_HEADER_SIZE;
 801e40e:	2202      	movs	r2, #2
 801e410:	f8a4 27e0 	strh.w	r2, [r4, #2016]	; 0x7e0
  hipc->RxQueue.current_msg_index = 0U;
 801e414:	f8a4 37e2 	strh.w	r3, [r4, #2018]	; 0x7e2
  hipc->RxQueue.current_msg_size = 0U;
 801e418:	f8a4 37e4 	strh.w	r3, [r4, #2020]	; 0x7e4
  hipc->RxQueue.nb_unread_msg = 0U;
 801e41c:	f884 37e6 	strb.w	r3, [r4, #2022]	; 0x7e6
}
 801e420:	bd10      	pop	{r4, pc}

0801e422 <IPC_RXFIFO_getFreeBytes>:
  if (hipc != NULL)
 801e422:	b170      	cbz	r0, 801e442 <IPC_RXFIFO_getFreeBytes+0x20>
    if (hipc->RxQueue.index_write > hipc->RxQueue.index_read)
 801e424:	f8b0 27e0 	ldrh.w	r2, [r0, #2016]	; 0x7e0
 801e428:	f8b0 07de 	ldrh.w	r0, [r0, #2014]	; 0x7de
 801e42c:	4282      	cmp	r2, r0
 801e42e:	d905      	bls.n	801e43c <IPC_RXFIFO_getFreeBytes+0x1a>
      free_bytes = (IPC_RXBUF_MAXSIZE - hipc->RxQueue.index_write +  hipc->RxQueue.index_read);
 801e430:	1a80      	subs	r0, r0, r2
 801e432:	b280      	uxth	r0, r0
 801e434:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 801e438:	b280      	uxth	r0, r0
 801e43a:	4770      	bx	lr
      free_bytes =  hipc->RxQueue.index_read - hipc->RxQueue.index_write;
 801e43c:	1a80      	subs	r0, r0, r2
 801e43e:	b280      	uxth	r0, r0
 801e440:	4770      	bx	lr
    free_bytes = 0U;
 801e442:	2000      	movs	r0, #0
}
 801e444:	4770      	bx	lr
	...

0801e448 <RXFIFO_incrementHead>:
{
 801e448:	b510      	push	{r4, lr}
 801e44a:	4604      	mov	r4, r0
  hipc->RxQueue.index_write = (hipc->RxQueue.index_write + 1U) % IPC_RXBUF_MAXSIZE;
 801e44c:	f8b0 27e0 	ldrh.w	r2, [r0, #2016]	; 0x7e0
 801e450:	3201      	adds	r2, #1
 801e452:	4b08      	ldr	r3, [pc, #32]	; (801e474 <RXFIFO_incrementHead+0x2c>)
 801e454:	fba3 1302 	umull	r1, r3, r3, r2
 801e458:	09db      	lsrs	r3, r3, #7
 801e45a:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 801e45e:	fb01 2313 	mls	r3, r1, r3, r2
 801e462:	f8a0 37e0 	strh.w	r3, [r0, #2016]	; 0x7e0
  free_bytes = IPC_RXFIFO_getFreeBytes(hipc);
 801e466:	f7ff ffdc 	bl	801e422 <IPC_RXFIFO_getFreeBytes>
  if (free_bytes <= IPC_RXBUF_THRESHOLD)
 801e46a:	2814      	cmp	r0, #20
 801e46c:	d801      	bhi.n	801e472 <RXFIFO_incrementHead+0x2a>
    hipc->State = IPC_STATE_PAUSED;
 801e46e:	2303      	movs	r3, #3
 801e470:	7363      	strb	r3, [r4, #13]
}
 801e472:	bd10      	pop	{r4, pc}
 801e474:	10624dd3 	.word	0x10624dd3

0801e478 <RXFIFO_prepareNextMsgHeader>:
{
 801e478:	b538      	push	{r3, r4, r5, lr}
 801e47a:	4605      	mov	r5, r0
  for (idx = 0U; idx < IPC_RXMSG_HEADER_SIZE; idx++)
 801e47c:	2400      	movs	r4, #0
 801e47e:	e009      	b.n	801e494 <RXFIFO_prepareNextMsgHeader+0x1c>
    hipc->RxQueue.data[hipc->RxQueue.index_write] = 0U;
 801e480:	f8b5 37e0 	ldrh.w	r3, [r5, #2016]	; 0x7e0
 801e484:	442b      	add	r3, r5
 801e486:	2200      	movs	r2, #0
 801e488:	739a      	strb	r2, [r3, #14]
    RXFIFO_incrementHead(hipc);
 801e48a:	4628      	mov	r0, r5
 801e48c:	f7ff ffdc 	bl	801e448 <RXFIFO_incrementHead>
  for (idx = 0U; idx < IPC_RXMSG_HEADER_SIZE; idx++)
 801e490:	3401      	adds	r4, #1
 801e492:	b2e4      	uxtb	r4, r4
 801e494:	2c01      	cmp	r4, #1
 801e496:	d9f3      	bls.n	801e480 <RXFIFO_prepareNextMsgHeader+0x8>
}
 801e498:	bd38      	pop	{r3, r4, r5, pc}

0801e49a <IPC_RXFIFO_writeCharacter>:
  if (hipc != NULL)
 801e49a:	b390      	cbz	r0, 801e502 <IPC_RXFIFO_writeCharacter+0x68>
{
 801e49c:	b538      	push	{r3, r4, r5, lr}
 801e49e:	460d      	mov	r5, r1
 801e4a0:	4604      	mov	r4, r0
    hipc->RxQueue.data[hipc->RxQueue.index_write] = rxChar;
 801e4a2:	f8b0 37e0 	ldrh.w	r3, [r0, #2016]	; 0x7e0
 801e4a6:	4403      	add	r3, r0
 801e4a8:	7399      	strb	r1, [r3, #14]
    hipc->RxQueue.current_msg_size++;
 801e4aa:	f8b0 37e4 	ldrh.w	r3, [r0, #2020]	; 0x7e4
 801e4ae:	3301      	adds	r3, #1
 801e4b0:	f8a0 37e4 	strh.w	r3, [r0, #2020]	; 0x7e4
    RXFIFO_incrementHead(hipc);
 801e4b4:	f7ff ffc8 	bl	801e448 <RXFIFO_incrementHead>
    if (hipc->State != IPC_STATE_PAUSED)
 801e4b8:	7b63      	ldrb	r3, [r4, #13]
 801e4ba:	2b03      	cmp	r3, #3
 801e4bc:	d106      	bne.n	801e4cc <IPC_RXFIFO_writeCharacter+0x32>
    if ((*hipc->CheckEndOfMsgCallback)(rxChar) == 1U)
 801e4be:	f8d4 37f0 	ldr.w	r3, [r4, #2032]	; 0x7f0
 801e4c2:	4628      	mov	r0, r5
 801e4c4:	4798      	blx	r3
 801e4c6:	2801      	cmp	r0, #1
 801e4c8:	d004      	beq.n	801e4d4 <IPC_RXFIFO_writeCharacter+0x3a>
}
 801e4ca:	bd38      	pop	{r3, r4, r5, pc}
      RXFIFO_rearm_RX_IT(hipc);
 801e4cc:	4620      	mov	r0, r4
 801e4ce:	f7ff ff8f 	bl	801e3f0 <RXFIFO_rearm_RX_IT>
 801e4d2:	e7f4      	b.n	801e4be <IPC_RXFIFO_writeCharacter+0x24>
      hipc->RxQueue.nb_unread_msg++;
 801e4d4:	f894 37e6 	ldrb.w	r3, [r4, #2022]	; 0x7e6
 801e4d8:	3301      	adds	r3, #1
 801e4da:	f884 37e6 	strb.w	r3, [r4, #2022]	; 0x7e6
      RXFIFO_updateMsgHeader(hipc);
 801e4de:	4620      	mov	r0, r4
 801e4e0:	f7ff ff6a 	bl	801e3b8 <RXFIFO_updateMsgHeader>
      hipc->RxQueue.current_msg_index = hipc->RxQueue.index_write;
 801e4e4:	f8b4 37e0 	ldrh.w	r3, [r4, #2016]	; 0x7e0
 801e4e8:	f8a4 37e2 	strh.w	r3, [r4, #2018]	; 0x7e2
      hipc->RxQueue.current_msg_size = 0U;
 801e4ec:	2300      	movs	r3, #0
 801e4ee:	f8a4 37e4 	strh.w	r3, [r4, #2020]	; 0x7e4
      RXFIFO_prepareNextMsgHeader(hipc);
 801e4f2:	4620      	mov	r0, r4
 801e4f4:	f7ff ffc0 	bl	801e478 <RXFIFO_prepareNextMsgHeader>
      (* hipc->RxClientCallback)((IPC_Handle_t *)hipc);
 801e4f8:	f8d4 37e8 	ldr.w	r3, [r4, #2024]	; 0x7e8
 801e4fc:	4620      	mov	r0, r4
 801e4fe:	4798      	blx	r3
}
 801e500:	e7e3      	b.n	801e4ca <IPC_RXFIFO_writeCharacter+0x30>
 801e502:	4770      	bx	lr

0801e504 <IPC_RXFIFO_readMsgHeader_at_pos>:
  if (hipc != NULL)
 801e504:	2800      	cmp	r0, #0
 801e506:	d064      	beq.n	801e5d2 <IPC_RXFIFO_readMsgHeader_at_pos+0xce>
{
 801e508:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e50c:	460f      	mov	r7, r1
 801e50e:	4616      	mov	r6, r2
 801e510:	4680      	mov	r8, r0
    PRINT_DBG("DBG IPC_RXFIFO_readMsgHeader: index_read = %d", hipc->RxQueue.index_read)
 801e512:	4c30      	ldr	r4, [pc, #192]	; (801e5d4 <IPC_RXFIFO_readMsgHeader_at_pos+0xd0>)
 801e514:	f8b0 27de 	ldrh.w	r2, [r0, #2014]	; 0x7de
 801e518:	492f      	ldr	r1, [pc, #188]	; (801e5d8 <IPC_RXFIFO_readMsgHeader_at_pos+0xd4>)
 801e51a:	4620      	mov	r0, r4
 801e51c:	f007 fba8 	bl	8025c70 <sprintf>
 801e520:	4620      	mov	r0, r4
 801e522:	f000 fdf6 	bl	801f112 <crs_strlen>
 801e526:	b283      	uxth	r3, r0
 801e528:	4622      	mov	r2, r4
 801e52a:	2102      	movs	r1, #2
 801e52c:	2005      	movs	r0, #5
 801e52e:	f000 fe33 	bl	801f198 <traceIF_itmPrint>
 801e532:	4620      	mov	r0, r4
 801e534:	f000 fded 	bl	801f112 <crs_strlen>
 801e538:	b283      	uxth	r3, r0
 801e53a:	4622      	mov	r2, r4
 801e53c:	2102      	movs	r1, #2
 801e53e:	2005      	movs	r0, #5
 801e540:	f000 fe4c 	bl	801f1dc <traceIF_uartPrint>
    header_byte1 = hipc->RxQueue.data[index];
 801e544:	eb08 0306 	add.w	r3, r8, r6
 801e548:	7b9d      	ldrb	r5, [r3, #14]
    index = (index + 1U) % IPC_RXBUF_MAXSIZE;
 801e54a:	3601      	adds	r6, #1
 801e54c:	4b23      	ldr	r3, [pc, #140]	; (801e5dc <IPC_RXFIFO_readMsgHeader_at_pos+0xd8>)
 801e54e:	fba3 2306 	umull	r2, r3, r3, r6
 801e552:	09db      	lsrs	r3, r3, #7
 801e554:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e558:	fb02 6313 	mls	r3, r2, r3, r6
    header_byte2 = hipc->RxQueue.data[index];
 801e55c:	fa18 f383 	uxtah	r3, r8, r3
 801e560:	7b9e      	ldrb	r6, [r3, #14]
    PRINT_DBG("header_byte1[0x%x] header_byte2[0x%x]", header_byte1, header_byte2)
 801e562:	4633      	mov	r3, r6
 801e564:	462a      	mov	r2, r5
 801e566:	491e      	ldr	r1, [pc, #120]	; (801e5e0 <IPC_RXFIFO_readMsgHeader_at_pos+0xdc>)
 801e568:	4620      	mov	r0, r4
 801e56a:	f007 fb81 	bl	8025c70 <sprintf>
 801e56e:	4620      	mov	r0, r4
 801e570:	f000 fdcf 	bl	801f112 <crs_strlen>
 801e574:	b283      	uxth	r3, r0
 801e576:	4622      	mov	r2, r4
 801e578:	2102      	movs	r1, #2
 801e57a:	2005      	movs	r0, #5
 801e57c:	f000 fe0c 	bl	801f198 <traceIF_itmPrint>
 801e580:	4620      	mov	r0, r4
 801e582:	f000 fdc6 	bl	801f112 <crs_strlen>
 801e586:	b283      	uxth	r3, r0
 801e588:	4622      	mov	r2, r4
 801e58a:	2102      	movs	r1, #2
 801e58c:	2005      	movs	r0, #5
 801e58e:	f000 fe25 	bl	801f1dc <traceIF_uartPrint>
    pHeader->complete = (IPC_RXMSG_HEADER_COMPLETE_MASK & header_byte1) >> 7;
 801e592:	09ea      	lsrs	r2, r5, #7
 801e594:	703a      	strb	r2, [r7, #0]
    pHeader->size = (((uint16_t)IPC_RXMSG_HEADER_SIZE_MASK & (uint16_t)header_byte1) << 8);
 801e596:	022b      	lsls	r3, r5, #8
 801e598:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 801e59c:	807b      	strh	r3, [r7, #2]
    pHeader->size = pHeader->size + header_byte2;
 801e59e:	4433      	add	r3, r6
 801e5a0:	807b      	strh	r3, [r7, #2]
    PRINT_DBG("complete=%d size=%d", pHeader->complete, pHeader->size)
 801e5a2:	4910      	ldr	r1, [pc, #64]	; (801e5e4 <IPC_RXFIFO_readMsgHeader_at_pos+0xe0>)
 801e5a4:	4620      	mov	r0, r4
 801e5a6:	f007 fb63 	bl	8025c70 <sprintf>
 801e5aa:	4620      	mov	r0, r4
 801e5ac:	f000 fdb1 	bl	801f112 <crs_strlen>
 801e5b0:	b283      	uxth	r3, r0
 801e5b2:	4622      	mov	r2, r4
 801e5b4:	2102      	movs	r1, #2
 801e5b6:	2005      	movs	r0, #5
 801e5b8:	f000 fdee 	bl	801f198 <traceIF_itmPrint>
 801e5bc:	4620      	mov	r0, r4
 801e5be:	f000 fda8 	bl	801f112 <crs_strlen>
 801e5c2:	b283      	uxth	r3, r0
 801e5c4:	4622      	mov	r2, r4
 801e5c6:	2102      	movs	r1, #2
 801e5c8:	2005      	movs	r0, #5
 801e5ca:	f000 fe07 	bl	801f1dc <traceIF_uartPrint>
}
 801e5ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801e5d2:	4770      	bx	lr
 801e5d4:	20004bdc 	.word	0x20004bdc
 801e5d8:	08034cf0 	.word	0x08034cf0
 801e5dc:	10624dd3 	.word	0x10624dd3
 801e5e0:	08034d24 	.word	0x08034d24
 801e5e4:	08034d50 	.word	0x08034d50

0801e5e8 <IPC_RXFIFO_read>:
  if (hipc != NULL)
 801e5e8:	2800      	cmp	r0, #0
 801e5ea:	d044      	beq.n	801e676 <IPC_RXFIFO_read+0x8e>
{
 801e5ec:	b570      	push	{r4, r5, r6, lr}
 801e5ee:	b082      	sub	sp, #8
 801e5f0:	460d      	mov	r5, r1
 801e5f2:	4604      	mov	r4, r0
    IPC_RXFIFO_readMsgHeader_at_pos(hipc, &header, hipc->RxQueue.index_read);
 801e5f4:	f8b0 27de 	ldrh.w	r2, [r0, #2014]	; 0x7de
 801e5f8:	a901      	add	r1, sp, #4
 801e5fa:	f7ff ff83 	bl	801e504 <IPC_RXFIFO_readMsgHeader_at_pos>
    if (header.complete != 1U)
 801e5fe:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801e602:	2b01      	cmp	r3, #1
 801e604:	d13a      	bne.n	801e67c <IPC_RXFIFO_read+0x94>
      RXFIFO_incrementTail(hipc, IPC_RXMSG_HEADER_SIZE);
 801e606:	2102      	movs	r1, #2
 801e608:	4620      	mov	r0, r4
 801e60a:	f7ff fec5 	bl	801e398 <RXFIFO_incrementTail>
      pMsg->size = header.size;
 801e60e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 801e612:	f8a5 27d0 	strh.w	r2, [r5, #2000]	; 0x7d0
      if ((hipc->RxQueue.index_read + header.size) > IPC_RXBUF_MAXSIZE)
 801e616:	f8b4 37de 	ldrh.w	r3, [r4, #2014]	; 0x7de
 801e61a:	1899      	adds	r1, r3, r2
 801e61c:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
 801e620:	dd22      	ble.n	801e668 <IPC_RXFIFO_read+0x80>
        oversize = (hipc->RxQueue.index_read + header.size - IPC_RXBUF_MAXSIZE);
 801e622:	b28e      	uxth	r6, r1
 801e624:	f5a6 66fa 	sub.w	r6, r6, #2000	; 0x7d0
 801e628:	b2b6      	uxth	r6, r6
        uint16_t remaining_size = header.size - oversize;
 801e62a:	1b92      	subs	r2, r2, r6
                      (void *) & (hipc->RxQueue.data[hipc->RxQueue.index_read]),
 801e62c:	3308      	adds	r3, #8
 801e62e:	4423      	add	r3, r4
        (void) memcpy((void *) & (pMsg->buffer[0]),
 801e630:	b292      	uxth	r2, r2
 801e632:	1d99      	adds	r1, r3, #6
 801e634:	4628      	mov	r0, r5
 801e636:	f007 fc6b 	bl	8025f10 <memcpy>
        (void) memcpy((void *) & (pMsg->buffer[header.size - oversize]),
 801e63a:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 801e63e:	1b80      	subs	r0, r0, r6
 801e640:	4632      	mov	r2, r6
 801e642:	f104 010e 	add.w	r1, r4, #14
 801e646:	4428      	add	r0, r5
 801e648:	f007 fc62 	bl	8025f10 <memcpy>
      RXFIFO_incrementTail(hipc, header.size);
 801e64c:	f8bd 1006 	ldrh.w	r1, [sp, #6]
 801e650:	4620      	mov	r0, r4
 801e652:	f7ff fea1 	bl	801e398 <RXFIFO_incrementTail>
      hipc->RxQueue.nb_unread_msg--;
 801e656:	f894 07e6 	ldrb.w	r0, [r4, #2022]	; 0x7e6
 801e65a:	3801      	subs	r0, #1
 801e65c:	b2c0      	uxtb	r0, r0
 801e65e:	f884 07e6 	strb.w	r0, [r4, #2022]	; 0x7e6
      retval = (int16_t)hipc->RxQueue.nb_unread_msg;
 801e662:	b200      	sxth	r0, r0
}
 801e664:	b002      	add	sp, #8
 801e666:	bd70      	pop	{r4, r5, r6, pc}
                      (void *) & (hipc->RxQueue.data[hipc->RxQueue.index_read]),
 801e668:	3308      	adds	r3, #8
 801e66a:	4423      	add	r3, r4
        (void) memcpy((void *)pMsg->buffer,
 801e66c:	1d99      	adds	r1, r3, #6
 801e66e:	4628      	mov	r0, r5
 801e670:	f007 fc4e 	bl	8025f10 <memcpy>
 801e674:	e7ea      	b.n	801e64c <IPC_RXFIFO_read+0x64>
    retval = -1;
 801e676:	f04f 30ff 	mov.w	r0, #4294967295
}
 801e67a:	4770      	bx	lr
      retval = -1;
 801e67c:	f04f 30ff 	mov.w	r0, #4294967295
 801e680:	e7f0      	b.n	801e664 <IPC_RXFIFO_read+0x7c>
	...

0801e684 <find_Device_Id>:
  bool leave_loop = false;

  do
  {
    /* search the device corresponding to this instance */
    if (huart->Instance == IPC_DevicesList[idx].phy_int.h_uart->Instance)
 801e684:	6802      	ldr	r2, [r0, #0]
 801e686:	4b04      	ldr	r3, [pc, #16]	; (801e698 <find_Device_Id+0x14>)
 801e688:	689b      	ldr	r3, [r3, #8]
 801e68a:	681b      	ldr	r3, [r3, #0]
 801e68c:	429a      	cmp	r2, r3
 801e68e:	d001      	beq.n	801e694 <find_Device_Id+0x10>
 801e690:	20ff      	movs	r0, #255	; 0xff
 801e692:	4770      	bx	lr
    {
      /* force loop exit */
      device_id = idx;
 801e694:	2000      	movs	r0, #0
    }
    idx++;
  } while ((leave_loop == false) && (idx < IPC_MAX_DEVICES));

  return (device_id);
}
 801e696:	4770      	bx	lr
 801e698:	200046c4 	.word	0x200046c4

0801e69c <change_ipc_channel>:
  * brief  Change the IPC channel.
  * param  hipc IPC handle.
  * retval status
  */
static IPC_Status_t change_ipc_channel(IPC_Handle_t *hipc)
{
 801e69c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e69e:	4607      	mov	r7, r0
  IPC_Handle_t *tmp_handle;
  tmp_handle = IPC_DevicesList[hipc->Device_ID].h_current_channel;
 801e6a0:	7803      	ldrb	r3, [r0, #0]
 801e6a2:	4e42      	ldr	r6, [pc, #264]	; (801e7ac <change_ipc_channel+0x110>)
 801e6a4:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 801e6a8:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 801e6ac:	6912      	ldr	r2, [r2, #16]

  /* swap channels */
  IPC_DevicesList[hipc->Device_ID].h_current_channel = hipc;
 801e6ae:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e6b2:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801e6b6:	6118      	str	r0, [r3, #16]
  IPC_DevicesList[hipc->Device_ID].h_inactive_channel = tmp_handle;
 801e6b8:	7803      	ldrb	r3, [r0, #0]
 801e6ba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e6be:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801e6c2:	615a      	str	r2, [r3, #20]

  PRINT_DBG("Change IPC channels")
 801e6c4:	4c3a      	ldr	r4, [pc, #232]	; (801e7b0 <change_ipc_channel+0x114>)
 801e6c6:	4d3b      	ldr	r5, [pc, #236]	; (801e7b4 <change_ipc_channel+0x118>)
 801e6c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e6ca:	6020      	str	r0, [r4, #0]
 801e6cc:	6061      	str	r1, [r4, #4]
 801e6ce:	60a2      	str	r2, [r4, #8]
 801e6d0:	60e3      	str	r3, [r4, #12]
 801e6d2:	cd03      	ldmia	r5!, {r0, r1}
 801e6d4:	6120      	str	r0, [r4, #16]
 801e6d6:	6161      	str	r1, [r4, #20]
 801e6d8:	882b      	ldrh	r3, [r5, #0]
 801e6da:	8323      	strh	r3, [r4, #24]
 801e6dc:	4620      	mov	r0, r4
 801e6de:	f000 fd18 	bl	801f112 <crs_strlen>
 801e6e2:	b283      	uxth	r3, r0
 801e6e4:	4622      	mov	r2, r4
 801e6e6:	2102      	movs	r1, #2
 801e6e8:	2005      	movs	r0, #5
 801e6ea:	f000 fd55 	bl	801f198 <traceIF_itmPrint>
 801e6ee:	4620      	mov	r0, r4
 801e6f0:	f000 fd0f 	bl	801f112 <crs_strlen>
 801e6f4:	b283      	uxth	r3, r0
 801e6f6:	4622      	mov	r2, r4
 801e6f8:	2102      	movs	r1, #2
 801e6fa:	2005      	movs	r0, #5
 801e6fc:	f000 fd6e 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("state 0x%x", IPC_DevicesList[hipc->Device_ID].state)
 801e700:	783b      	ldrb	r3, [r7, #0]
 801e702:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e706:	f816 2033 	ldrb.w	r2, [r6, r3, lsl #3]
 801e70a:	492b      	ldr	r1, [pc, #172]	; (801e7b8 <change_ipc_channel+0x11c>)
 801e70c:	4620      	mov	r0, r4
 801e70e:	f007 faaf 	bl	8025c70 <sprintf>
 801e712:	4620      	mov	r0, r4
 801e714:	f000 fcfd 	bl	801f112 <crs_strlen>
 801e718:	b283      	uxth	r3, r0
 801e71a:	4622      	mov	r2, r4
 801e71c:	2102      	movs	r1, #2
 801e71e:	2005      	movs	r0, #5
 801e720:	f000 fd3a 	bl	801f198 <traceIF_itmPrint>
 801e724:	4620      	mov	r0, r4
 801e726:	f000 fcf4 	bl	801f112 <crs_strlen>
 801e72a:	b283      	uxth	r3, r0
 801e72c:	4622      	mov	r2, r4
 801e72e:	2102      	movs	r1, #2
 801e730:	2005      	movs	r0, #5
 801e732:	f000 fd53 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("active channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801e736:	783b      	ldrb	r3, [r7, #0]
 801e738:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e73c:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801e740:	691a      	ldr	r2, [r3, #16]
 801e742:	491e      	ldr	r1, [pc, #120]	; (801e7bc <change_ipc_channel+0x120>)
 801e744:	4620      	mov	r0, r4
 801e746:	f007 fa93 	bl	8025c70 <sprintf>
 801e74a:	4620      	mov	r0, r4
 801e74c:	f000 fce1 	bl	801f112 <crs_strlen>
 801e750:	b283      	uxth	r3, r0
 801e752:	4622      	mov	r2, r4
 801e754:	2102      	movs	r1, #2
 801e756:	2005      	movs	r0, #5
 801e758:	f000 fd1e 	bl	801f198 <traceIF_itmPrint>
 801e75c:	4620      	mov	r0, r4
 801e75e:	f000 fcd8 	bl	801f112 <crs_strlen>
 801e762:	b283      	uxth	r3, r0
 801e764:	4622      	mov	r2, r4
 801e766:	2102      	movs	r1, #2
 801e768:	2005      	movs	r0, #5
 801e76a:	f000 fd37 	bl	801f1dc <traceIF_uartPrint>
  PRINT_DBG("inactive channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_inactive_channel)
 801e76e:	783b      	ldrb	r3, [r7, #0]
 801e770:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e774:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 801e778:	6972      	ldr	r2, [r6, #20]
 801e77a:	4911      	ldr	r1, [pc, #68]	; (801e7c0 <change_ipc_channel+0x124>)
 801e77c:	4620      	mov	r0, r4
 801e77e:	f007 fa77 	bl	8025c70 <sprintf>
 801e782:	4620      	mov	r0, r4
 801e784:	f000 fcc5 	bl	801f112 <crs_strlen>
 801e788:	b283      	uxth	r3, r0
 801e78a:	4622      	mov	r2, r4
 801e78c:	2102      	movs	r1, #2
 801e78e:	2005      	movs	r0, #5
 801e790:	f000 fd02 	bl	801f198 <traceIF_itmPrint>
 801e794:	4620      	mov	r0, r4
 801e796:	f000 fcbc 	bl	801f112 <crs_strlen>
 801e79a:	b283      	uxth	r3, r0
 801e79c:	4622      	mov	r2, r4
 801e79e:	2102      	movs	r1, #2
 801e7a0:	2005      	movs	r0, #5
 801e7a2:	f000 fd1b 	bl	801f1dc <traceIF_uartPrint>

  return (IPC_OK);
}
 801e7a6:	2000      	movs	r0, #0
 801e7a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e7aa:	bf00      	nop
 801e7ac:	200046c4 	.word	0x200046c4
 801e7b0:	20004bdc 	.word	0x20004bdc
 801e7b4:	08034d6c 	.word	0x08034d6c
 801e7b8:	08034d88 	.word	0x08034d88
 801e7bc:	08034d9c 	.word	0x08034d9c
 801e7c0:	08034dbc 	.word	0x08034dbc

0801e7c4 <IPC_UART_init>:
{
 801e7c4:	4603      	mov	r3, r0
  if (IPC_DevicesList[device].state != IPC_STATE_NOT_INITIALIZED)
 801e7c6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801e7ca:	4a0c      	ldr	r2, [pc, #48]	; (801e7fc <IPC_UART_init+0x38>)
 801e7cc:	f812 0030 	ldrb.w	r0, [r2, r0, lsl #3]
 801e7d0:	b990      	cbnz	r0, 801e7f8 <IPC_UART_init+0x34>
{
 801e7d2:	b510      	push	{r4, lr}
    IPC_DevicesList[device].state = IPC_STATE_INITIALIZED;
 801e7d4:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 801e7d8:	eb02 0cc4 	add.w	ip, r2, r4, lsl #3
 801e7dc:	f04f 0e01 	mov.w	lr, #1
 801e7e0:	f802 e034 	strb.w	lr, [r2, r4, lsl #3]
    IPC_DevicesList[device].phy_int.interface_type = IPC_INTERFACE_UART;
 801e7e4:	f88c e004 	strb.w	lr, [ip, #4]
    IPC_DevicesList[device].phy_int.h_uart = huart;
 801e7e8:	f8cc 1008 	str.w	r1, [ip, #8]
    IPC_DevicesList[device].h_current_channel = NULL;
 801e7ec:	2100      	movs	r1, #0
 801e7ee:	f8cc 1010 	str.w	r1, [ip, #16]
    IPC_DevicesList[device].h_inactive_channel = NULL;
 801e7f2:	f8cc 1014 	str.w	r1, [ip, #20]
}
 801e7f6:	bd10      	pop	{r4, pc}
    retval = IPC_ERROR;
 801e7f8:	2001      	movs	r0, #1
}
 801e7fa:	4770      	bx	lr
 801e7fc:	200046c4 	.word	0x200046c4

0801e800 <IPC_UART_open>:
  if ((mode != IPC_MODE_UART_CHARACTER) && (mode != IPC_MODE_UART_STREAM))
 801e800:	2a01      	cmp	r2, #1
 801e802:	d901      	bls.n	801e808 <IPC_UART_open+0x8>
    retval = IPC_ERROR;
 801e804:	2001      	movs	r0, #1
}
 801e806:	4770      	bx	lr
{
 801e808:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e80c:	4605      	mov	r5, r0
 801e80e:	460c      	mov	r4, r1
 801e810:	4616      	mov	r6, r2
 801e812:	4698      	mov	r8, r3
  else if ((mode == IPC_MODE_UART_CHARACTER) && (pCheckEndOfMsg == NULL))
 801e814:	b91a      	cbnz	r2, 801e81e <IPC_UART_open+0x1e>
 801e816:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e818:	2b00      	cmp	r3, #0
 801e81a:	f000 80dc 	beq.w	801e9d6 <IPC_UART_open+0x1d6>
    if (IPC_DevicesList[device].h_current_channel == NULL)
 801e81e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801e822:	4b6e      	ldr	r3, [pc, #440]	; (801e9dc <IPC_UART_open+0x1dc>)
 801e824:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801e828:	691b      	ldr	r3, [r3, #16]
 801e82a:	b15b      	cbz	r3, 801e844 <IPC_UART_open+0x44>
    else if (IPC_DevicesList[device].h_inactive_channel == NULL)
 801e82c:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801e830:	4b6a      	ldr	r3, [pc, #424]	; (801e9dc <IPC_UART_open+0x1dc>)
 801e832:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801e836:	695b      	ldr	r3, [r3, #20]
 801e838:	2b00      	cmp	r3, #0
 801e83a:	f000 80a0 	beq.w	801e97e <IPC_UART_open+0x17e>
      retval = IPC_ERROR;
 801e83e:	2001      	movs	r0, #1
}
 801e840:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      IPC_DevicesList[device].h_current_channel = hipc;
 801e844:	4b65      	ldr	r3, [pc, #404]	; (801e9dc <IPC_UART_open+0x1dc>)
 801e846:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801e84a:	611d      	str	r5, [r3, #16]
    IPC_DevicesList[device].RxChar[0] = (IPC_CHAR_t)('\0');
 801e84c:	f8df a18c 	ldr.w	sl, [pc, #396]	; 801e9dc <IPC_UART_open+0x1dc>
 801e850:	eb04 0944 	add.w	r9, r4, r4, lsl #1
 801e854:	ea4f 0bc9 	mov.w	fp, r9, lsl #3
 801e858:	eb0a 09c9 	add.w	r9, sl, r9, lsl #3
 801e85c:	2300      	movs	r3, #0
 801e85e:	f889 300c 	strb.w	r3, [r9, #12]
    PRINT_DBG("IPC channel %p registered", IPC_DevicesList[device].h_current_channel)
 801e862:	4f5f      	ldr	r7, [pc, #380]	; (801e9e0 <IPC_UART_open+0x1e0>)
 801e864:	f8d9 2010 	ldr.w	r2, [r9, #16]
 801e868:	495e      	ldr	r1, [pc, #376]	; (801e9e4 <IPC_UART_open+0x1e4>)
 801e86a:	4638      	mov	r0, r7
 801e86c:	f007 fa00 	bl	8025c70 <sprintf>
 801e870:	4638      	mov	r0, r7
 801e872:	f000 fc4e 	bl	801f112 <crs_strlen>
 801e876:	b283      	uxth	r3, r0
 801e878:	463a      	mov	r2, r7
 801e87a:	2102      	movs	r1, #2
 801e87c:	2005      	movs	r0, #5
 801e87e:	f000 fc8b 	bl	801f198 <traceIF_itmPrint>
 801e882:	4638      	mov	r0, r7
 801e884:	f000 fc45 	bl	801f112 <crs_strlen>
 801e888:	b283      	uxth	r3, r0
 801e88a:	463a      	mov	r2, r7
 801e88c:	2102      	movs	r1, #2
 801e88e:	2005      	movs	r0, #5
 801e890:	f000 fca4 	bl	801f1dc <traceIF_uartPrint>
    PRINT_DBG("state 0x%x", IPC_DevicesList[device].state)
 801e894:	f81a 200b 	ldrb.w	r2, [sl, fp]
 801e898:	4953      	ldr	r1, [pc, #332]	; (801e9e8 <IPC_UART_open+0x1e8>)
 801e89a:	4638      	mov	r0, r7
 801e89c:	f007 f9e8 	bl	8025c70 <sprintf>
 801e8a0:	4638      	mov	r0, r7
 801e8a2:	f000 fc36 	bl	801f112 <crs_strlen>
 801e8a6:	b283      	uxth	r3, r0
 801e8a8:	463a      	mov	r2, r7
 801e8aa:	2102      	movs	r1, #2
 801e8ac:	2005      	movs	r0, #5
 801e8ae:	f000 fc73 	bl	801f198 <traceIF_itmPrint>
 801e8b2:	4638      	mov	r0, r7
 801e8b4:	f000 fc2d 	bl	801f112 <crs_strlen>
 801e8b8:	b283      	uxth	r3, r0
 801e8ba:	463a      	mov	r2, r7
 801e8bc:	2102      	movs	r1, #2
 801e8be:	2005      	movs	r0, #5
 801e8c0:	f000 fc8c 	bl	801f1dc <traceIF_uartPrint>
    PRINT_DBG("active channel handle: %p", IPC_DevicesList[device].h_current_channel)
 801e8c4:	f8d9 2010 	ldr.w	r2, [r9, #16]
 801e8c8:	4948      	ldr	r1, [pc, #288]	; (801e9ec <IPC_UART_open+0x1ec>)
 801e8ca:	4638      	mov	r0, r7
 801e8cc:	f007 f9d0 	bl	8025c70 <sprintf>
 801e8d0:	4638      	mov	r0, r7
 801e8d2:	f000 fc1e 	bl	801f112 <crs_strlen>
 801e8d6:	b283      	uxth	r3, r0
 801e8d8:	463a      	mov	r2, r7
 801e8da:	2102      	movs	r1, #2
 801e8dc:	2005      	movs	r0, #5
 801e8de:	f000 fc5b 	bl	801f198 <traceIF_itmPrint>
 801e8e2:	4638      	mov	r0, r7
 801e8e4:	f000 fc15 	bl	801f112 <crs_strlen>
 801e8e8:	b283      	uxth	r3, r0
 801e8ea:	463a      	mov	r2, r7
 801e8ec:	2102      	movs	r1, #2
 801e8ee:	2005      	movs	r0, #5
 801e8f0:	f000 fc74 	bl	801f1dc <traceIF_uartPrint>
    PRINT_DBG("inactive channel handle: %p", IPC_DevicesList[device].h_inactive_channel)
 801e8f4:	f8d9 2014 	ldr.w	r2, [r9, #20]
 801e8f8:	493d      	ldr	r1, [pc, #244]	; (801e9f0 <IPC_UART_open+0x1f0>)
 801e8fa:	4638      	mov	r0, r7
 801e8fc:	f007 f9b8 	bl	8025c70 <sprintf>
 801e900:	4638      	mov	r0, r7
 801e902:	f000 fc06 	bl	801f112 <crs_strlen>
 801e906:	b283      	uxth	r3, r0
 801e908:	463a      	mov	r2, r7
 801e90a:	2102      	movs	r1, #2
 801e90c:	2005      	movs	r0, #5
 801e90e:	f000 fc43 	bl	801f198 <traceIF_itmPrint>
 801e912:	4638      	mov	r0, r7
 801e914:	f000 fbfd 	bl	801f112 <crs_strlen>
 801e918:	b283      	uxth	r3, r0
 801e91a:	463a      	mov	r2, r7
 801e91c:	2102      	movs	r1, #2
 801e91e:	2005      	movs	r0, #5
 801e920:	f000 fc5c 	bl	801f1dc <traceIF_uartPrint>
    if (mode == IPC_MODE_UART_CHARACTER)
 801e924:	b916      	cbnz	r6, 801e92c <IPC_UART_open+0x12c>
      hipc->RxFifoWrite = IPC_RXFIFO_writeCharacter;
 801e926:	4b33      	ldr	r3, [pc, #204]	; (801e9f4 <IPC_UART_open+0x1f4>)
 801e928:	f8c5 37f4 	str.w	r3, [r5, #2036]	; 0x7f4
    hipc->Device_ID = device;
 801e92c:	702c      	strb	r4, [r5, #0]
    hipc->Interface.interface_type = IPC_DevicesList[device].phy_int.interface_type;
 801e92e:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 801e9dc <IPC_UART_open+0x1dc>
 801e932:	0067      	lsls	r7, r4, #1
 801e934:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801e938:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
 801e93c:	791a      	ldrb	r2, [r3, #4]
 801e93e:	712a      	strb	r2, [r5, #4]
    hipc->Interface.h_uart = IPC_DevicesList[device].phy_int.h_uart;
 801e940:	689b      	ldr	r3, [r3, #8]
 801e942:	60ab      	str	r3, [r5, #8]
    hipc->State = IPC_STATE_INITIALIZED;
 801e944:	f04f 0901 	mov.w	r9, #1
 801e948:	f885 900d 	strb.w	r9, [r5, #13]
    hipc->RxClientCallback = pRxClientCallback;
 801e94c:	f8c5 87e8 	str.w	r8, [r5, #2024]	; 0x7e8
    hipc->TxClientCallback = pTxClientCallback;
 801e950:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801e952:	f8c5 37ec 	str.w	r3, [r5, #2028]	; 0x7ec
    hipc->CheckEndOfMsgCallback = pCheckEndOfMsg;
 801e956:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e958:	f8c5 37f0 	str.w	r3, [r5, #2032]	; 0x7f0
    hipc->Mode = mode;
 801e95c:	732e      	strb	r6, [r5, #12]
    IPC_RXFIFO_init(hipc);
 801e95e:	4628      	mov	r0, r5
 801e960:	f7ff fd4a 	bl	801e3f8 <IPC_RXFIFO_init>
    uart_status = HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[device].RxChar, 1U);
 801e964:	1939      	adds	r1, r7, r4
 801e966:	00c9      	lsls	r1, r1, #3
 801e968:	3108      	adds	r1, #8
 801e96a:	4451      	add	r1, sl
 801e96c:	464a      	mov	r2, r9
 801e96e:	3104      	adds	r1, #4
 801e970:	68a8      	ldr	r0, [r5, #8]
 801e972:	f7eb fb8d 	bl	800a090 <HAL_UART_Receive_IT>
    if (uart_status != HAL_OK)
 801e976:	b938      	cbnz	r0, 801e988 <IPC_UART_open+0x188>
      hipc->State = IPC_STATE_ACTIVE;
 801e978:	2302      	movs	r3, #2
 801e97a:	736b      	strb	r3, [r5, #13]
 801e97c:	e760      	b.n	801e840 <IPC_UART_open+0x40>
      IPC_DevicesList[device].h_inactive_channel = hipc;
 801e97e:	4b17      	ldr	r3, [pc, #92]	; (801e9dc <IPC_UART_open+0x1dc>)
 801e980:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801e984:	615d      	str	r5, [r3, #20]
  if (retval != IPC_ERROR)
 801e986:	e761      	b.n	801e84c <IPC_UART_open+0x4c>
      PRINT_ERR("HAL_UART_Receive_IT error")
 801e988:	4e1b      	ldr	r6, [pc, #108]	; (801e9f8 <IPC_UART_open+0x1f8>)
 801e98a:	4c15      	ldr	r4, [pc, #84]	; (801e9e0 <IPC_UART_open+0x1e0>)
 801e98c:	f106 0720 	add.w	r7, r6, #32
 801e990:	4635      	mov	r5, r6
 801e992:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e994:	6020      	str	r0, [r4, #0]
 801e996:	6061      	str	r1, [r4, #4]
 801e998:	60a2      	str	r2, [r4, #8]
 801e99a:	60e3      	str	r3, [r4, #12]
 801e99c:	462e      	mov	r6, r5
 801e99e:	3410      	adds	r4, #16
 801e9a0:	42bd      	cmp	r5, r7
 801e9a2:	d1f5      	bne.n	801e990 <IPC_UART_open+0x190>
 801e9a4:	6828      	ldr	r0, [r5, #0]
 801e9a6:	6020      	str	r0, [r4, #0]
 801e9a8:	88ab      	ldrh	r3, [r5, #4]
 801e9aa:	80a3      	strh	r3, [r4, #4]
 801e9ac:	4c0c      	ldr	r4, [pc, #48]	; (801e9e0 <IPC_UART_open+0x1e0>)
 801e9ae:	4620      	mov	r0, r4
 801e9b0:	f000 fbaf 	bl	801f112 <crs_strlen>
 801e9b4:	b283      	uxth	r3, r0
 801e9b6:	4622      	mov	r2, r4
 801e9b8:	2110      	movs	r1, #16
 801e9ba:	2005      	movs	r0, #5
 801e9bc:	f000 fbec 	bl	801f198 <traceIF_itmPrint>
 801e9c0:	4620      	mov	r0, r4
 801e9c2:	f000 fba6 	bl	801f112 <crs_strlen>
 801e9c6:	b283      	uxth	r3, r0
 801e9c8:	4622      	mov	r2, r4
 801e9ca:	2110      	movs	r1, #16
 801e9cc:	2005      	movs	r0, #5
 801e9ce:	f000 fc05 	bl	801f1dc <traceIF_uartPrint>
      retval = IPC_ERROR;
 801e9d2:	2001      	movs	r0, #1
 801e9d4:	e734      	b.n	801e840 <IPC_UART_open+0x40>
    retval = IPC_ERROR;
 801e9d6:	2001      	movs	r0, #1
 801e9d8:	e732      	b.n	801e840 <IPC_UART_open+0x40>
 801e9da:	bf00      	nop
 801e9dc:	200046c4 	.word	0x200046c4
 801e9e0:	20004bdc 	.word	0x20004bdc
 801e9e4:	08034de0 	.word	0x08034de0
 801e9e8:	08034d88 	.word	0x08034d88
 801e9ec:	08034d9c 	.word	0x08034d9c
 801e9f0:	08034dbc 	.word	0x08034dbc
 801e9f4:	0801e49b 	.word	0x0801e49b
 801e9f8:	08034e00 	.word	0x08034e00

0801e9fc <IPC_UART_close>:
  if (hipc->State != IPC_STATE_NOT_INITIALIZED)
 801e9fc:	7b43      	ldrb	r3, [r0, #13]
 801e9fe:	b90b      	cbnz	r3, 801ea04 <IPC_UART_close+0x8>
    retval = IPC_ERROR;
 801ea00:	2001      	movs	r0, #1
}
 801ea02:	4770      	bx	lr
{
 801ea04:	b570      	push	{r4, r5, r6, lr}
 801ea06:	4604      	mov	r4, r0
    hipc->State = IPC_STATE_NOT_INITIALIZED;
 801ea08:	2300      	movs	r3, #0
 801ea0a:	7343      	strb	r3, [r0, #13]
    hipc->RxClientCallback = NULL;
 801ea0c:	f8c0 37e8 	str.w	r3, [r0, #2024]	; 0x7e8
    hipc->CheckEndOfMsgCallback = NULL;
 801ea10:	f8c0 37f0 	str.w	r3, [r0, #2032]	; 0x7f0
    IPC_RXFIFO_init(hipc);
 801ea14:	f7ff fcf0 	bl	801e3f8 <IPC_RXFIFO_init>
    uint8_t device_id = hipc->Device_ID;
 801ea18:	7823      	ldrb	r3, [r4, #0]
    if (device_id != IPC_DEVICE_NOT_FOUND)
 801ea1a:	2bff      	cmp	r3, #255	; 0xff
 801ea1c:	f000 80a2 	beq.w	801eb64 <IPC_UART_close+0x168>
      if (IPC_DevicesList[device_id].h_current_channel == hipc)
 801ea20:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801ea24:	4a50      	ldr	r2, [pc, #320]	; (801eb68 <IPC_UART_close+0x16c>)
 801ea26:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ea2a:	6912      	ldr	r2, [r2, #16]
 801ea2c:	42a2      	cmp	r2, r4
 801ea2e:	d07d      	beq.n	801eb2c <IPC_UART_close+0x130>
      else if (IPC_DevicesList[device_id].h_inactive_channel == hipc)
 801ea30:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801ea34:	4a4c      	ldr	r2, [pc, #304]	; (801eb68 <IPC_UART_close+0x16c>)
 801ea36:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ea3a:	6952      	ldr	r2, [r2, #20]
 801ea3c:	42a2      	cmp	r2, r4
 801ea3e:	d07d      	beq.n	801eb3c <IPC_UART_close+0x140>
      if ((IPC_DevicesList[device_id].h_current_channel == NULL) &&
 801ea40:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801ea44:	4a48      	ldr	r2, [pc, #288]	; (801eb68 <IPC_UART_close+0x16c>)
 801ea46:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ea4a:	6912      	ldr	r2, [r2, #16]
 801ea4c:	2a00      	cmp	r2, #0
 801ea4e:	d07b      	beq.n	801eb48 <IPC_UART_close+0x14c>
      PRINT_DBG("IPC channel %p closed", hipc)
 801ea50:	4d46      	ldr	r5, [pc, #280]	; (801eb6c <IPC_UART_close+0x170>)
 801ea52:	4622      	mov	r2, r4
 801ea54:	4946      	ldr	r1, [pc, #280]	; (801eb70 <IPC_UART_close+0x174>)
 801ea56:	4628      	mov	r0, r5
 801ea58:	f007 f90a 	bl	8025c70 <sprintf>
 801ea5c:	4628      	mov	r0, r5
 801ea5e:	f000 fb58 	bl	801f112 <crs_strlen>
 801ea62:	b283      	uxth	r3, r0
 801ea64:	462a      	mov	r2, r5
 801ea66:	2102      	movs	r1, #2
 801ea68:	2005      	movs	r0, #5
 801ea6a:	f000 fb95 	bl	801f198 <traceIF_itmPrint>
 801ea6e:	4628      	mov	r0, r5
 801ea70:	f000 fb4f 	bl	801f112 <crs_strlen>
 801ea74:	b283      	uxth	r3, r0
 801ea76:	462a      	mov	r2, r5
 801ea78:	2102      	movs	r1, #2
 801ea7a:	2005      	movs	r0, #5
 801ea7c:	f000 fbae 	bl	801f1dc <traceIF_uartPrint>
      PRINT_DBG("state 0x%x", IPC_DevicesList[hipc->Device_ID].state)
 801ea80:	7823      	ldrb	r3, [r4, #0]
 801ea82:	4e39      	ldr	r6, [pc, #228]	; (801eb68 <IPC_UART_close+0x16c>)
 801ea84:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ea88:	f816 2033 	ldrb.w	r2, [r6, r3, lsl #3]
 801ea8c:	4939      	ldr	r1, [pc, #228]	; (801eb74 <IPC_UART_close+0x178>)
 801ea8e:	4628      	mov	r0, r5
 801ea90:	f007 f8ee 	bl	8025c70 <sprintf>
 801ea94:	4628      	mov	r0, r5
 801ea96:	f000 fb3c 	bl	801f112 <crs_strlen>
 801ea9a:	b283      	uxth	r3, r0
 801ea9c:	462a      	mov	r2, r5
 801ea9e:	2102      	movs	r1, #2
 801eaa0:	2005      	movs	r0, #5
 801eaa2:	f000 fb79 	bl	801f198 <traceIF_itmPrint>
 801eaa6:	4628      	mov	r0, r5
 801eaa8:	f000 fb33 	bl	801f112 <crs_strlen>
 801eaac:	b283      	uxth	r3, r0
 801eaae:	462a      	mov	r2, r5
 801eab0:	2102      	movs	r1, #2
 801eab2:	2005      	movs	r0, #5
 801eab4:	f000 fb92 	bl	801f1dc <traceIF_uartPrint>
      PRINT_DBG("active channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801eab8:	7823      	ldrb	r3, [r4, #0]
 801eaba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eabe:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801eac2:	691a      	ldr	r2, [r3, #16]
 801eac4:	492c      	ldr	r1, [pc, #176]	; (801eb78 <IPC_UART_close+0x17c>)
 801eac6:	4628      	mov	r0, r5
 801eac8:	f007 f8d2 	bl	8025c70 <sprintf>
 801eacc:	4628      	mov	r0, r5
 801eace:	f000 fb20 	bl	801f112 <crs_strlen>
 801ead2:	b283      	uxth	r3, r0
 801ead4:	462a      	mov	r2, r5
 801ead6:	2102      	movs	r1, #2
 801ead8:	2005      	movs	r0, #5
 801eada:	f000 fb5d 	bl	801f198 <traceIF_itmPrint>
 801eade:	4628      	mov	r0, r5
 801eae0:	f000 fb17 	bl	801f112 <crs_strlen>
 801eae4:	b283      	uxth	r3, r0
 801eae6:	462a      	mov	r2, r5
 801eae8:	2102      	movs	r1, #2
 801eaea:	2005      	movs	r0, #5
 801eaec:	f000 fb76 	bl	801f1dc <traceIF_uartPrint>
      PRINT_DBG("inactive channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_inactive_channel)
 801eaf0:	7823      	ldrb	r3, [r4, #0]
 801eaf2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eaf6:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 801eafa:	6972      	ldr	r2, [r6, #20]
 801eafc:	491f      	ldr	r1, [pc, #124]	; (801eb7c <IPC_UART_close+0x180>)
 801eafe:	4628      	mov	r0, r5
 801eb00:	f007 f8b6 	bl	8025c70 <sprintf>
 801eb04:	4628      	mov	r0, r5
 801eb06:	f000 fb04 	bl	801f112 <crs_strlen>
 801eb0a:	b283      	uxth	r3, r0
 801eb0c:	462a      	mov	r2, r5
 801eb0e:	2102      	movs	r1, #2
 801eb10:	2005      	movs	r0, #5
 801eb12:	f000 fb41 	bl	801f198 <traceIF_itmPrint>
 801eb16:	4628      	mov	r0, r5
 801eb18:	f000 fafb 	bl	801f112 <crs_strlen>
 801eb1c:	b283      	uxth	r3, r0
 801eb1e:	462a      	mov	r2, r5
 801eb20:	2102      	movs	r1, #2
 801eb22:	2005      	movs	r0, #5
 801eb24:	f000 fb5a 	bl	801f1dc <traceIF_uartPrint>
      retval = IPC_OK;
 801eb28:	2000      	movs	r0, #0
}
 801eb2a:	bd70      	pop	{r4, r5, r6, pc}
        IPC_DevicesList[device_id].h_current_channel = IPC_DevicesList[device_id].h_inactive_channel;
 801eb2c:	4a0e      	ldr	r2, [pc, #56]	; (801eb68 <IPC_UART_close+0x16c>)
 801eb2e:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801eb32:	6951      	ldr	r1, [r2, #20]
 801eb34:	6111      	str	r1, [r2, #16]
        IPC_DevicesList[device_id].h_inactive_channel = NULL;
 801eb36:	2100      	movs	r1, #0
 801eb38:	6151      	str	r1, [r2, #20]
 801eb3a:	e781      	b.n	801ea40 <IPC_UART_close+0x44>
        IPC_DevicesList[device_id].h_inactive_channel = NULL;
 801eb3c:	4a0a      	ldr	r2, [pc, #40]	; (801eb68 <IPC_UART_close+0x16c>)
 801eb3e:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801eb42:	2100      	movs	r1, #0
 801eb44:	6151      	str	r1, [r2, #20]
 801eb46:	e77b      	b.n	801ea40 <IPC_UART_close+0x44>
          (IPC_DevicesList[device_id].h_inactive_channel == NULL))
 801eb48:	4a07      	ldr	r2, [pc, #28]	; (801eb68 <IPC_UART_close+0x16c>)
 801eb4a:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
 801eb4e:	695b      	ldr	r3, [r3, #20]
      if ((IPC_DevicesList[device_id].h_current_channel == NULL) &&
 801eb50:	2b00      	cmp	r3, #0
 801eb52:	f47f af7d 	bne.w	801ea50 <IPC_UART_close+0x54>
        if (hipc->Interface.h_uart != NULL)
 801eb56:	68a0      	ldr	r0, [r4, #8]
 801eb58:	2800      	cmp	r0, #0
 801eb5a:	f43f af79 	beq.w	801ea50 <IPC_UART_close+0x54>
          (void)HAL_UART_AbortTransmit_IT(hipc->Interface.h_uart);
 801eb5e:	f7eb fc41 	bl	800a3e4 <HAL_UART_AbortTransmit_IT>
 801eb62:	e775      	b.n	801ea50 <IPC_UART_close+0x54>
      retval = IPC_ERROR;
 801eb64:	2001      	movs	r0, #1
 801eb66:	e7e0      	b.n	801eb2a <IPC_UART_close+0x12e>
 801eb68:	200046c4 	.word	0x200046c4
 801eb6c:	20004bdc 	.word	0x20004bdc
 801eb70:	08034e28 	.word	0x08034e28
 801eb74:	08034d88 	.word	0x08034d88
 801eb78:	08034d9c 	.word	0x08034d9c
 801eb7c:	08034dbc 	.word	0x08034dbc

0801eb80 <IPC_UART_reset>:
{
 801eb80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801eb84:	4604      	mov	r4, r0
  PRINT_DBG("IPC reset %p", hipc)
 801eb86:	4d1b      	ldr	r5, [pc, #108]	; (801ebf4 <IPC_UART_reset+0x74>)
 801eb88:	4602      	mov	r2, r0
 801eb8a:	491b      	ldr	r1, [pc, #108]	; (801ebf8 <IPC_UART_reset+0x78>)
 801eb8c:	4628      	mov	r0, r5
 801eb8e:	f007 f86f 	bl	8025c70 <sprintf>
 801eb92:	4628      	mov	r0, r5
 801eb94:	f000 fabd 	bl	801f112 <crs_strlen>
 801eb98:	b283      	uxth	r3, r0
 801eb9a:	462a      	mov	r2, r5
 801eb9c:	2102      	movs	r1, #2
 801eb9e:	2005      	movs	r0, #5
 801eba0:	f000 fafa 	bl	801f198 <traceIF_itmPrint>
 801eba4:	4628      	mov	r0, r5
 801eba6:	f000 fab4 	bl	801f112 <crs_strlen>
 801ebaa:	b283      	uxth	r3, r0
 801ebac:	462a      	mov	r2, r5
 801ebae:	2102      	movs	r1, #2
 801ebb0:	2005      	movs	r0, #5
 801ebb2:	f000 fb13 	bl	801f1dc <traceIF_uartPrint>
  uint8_t device_id = hipc->Device_ID;
 801ebb6:	7826      	ldrb	r6, [r4, #0]
  if (device_id != IPC_DEVICE_NOT_FOUND)
 801ebb8:	2eff      	cmp	r6, #255	; 0xff
 801ebba:	d102      	bne.n	801ebc2 <IPC_UART_reset+0x42>
  IPC_Status_t retval = IPC_ERROR;
 801ebbc:	2001      	movs	r0, #1
}
 801ebbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    IPC_DevicesList[device_id].RxChar[0] = (IPC_CHAR_t)('\0');
 801ebc2:	f8df 8038 	ldr.w	r8, [pc, #56]	; 801ebfc <IPC_UART_reset+0x7c>
 801ebc6:	0075      	lsls	r5, r6, #1
 801ebc8:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 801ebcc:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 801ebd0:	2700      	movs	r7, #0
 801ebd2:	731f      	strb	r7, [r3, #12]
    IPC_RXFIFO_init(hipc);
 801ebd4:	4620      	mov	r0, r4
 801ebd6:	f7ff fc0f 	bl	801e3f8 <IPC_RXFIFO_init>
    (void) HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[device_id].RxChar, 1U);
 801ebda:	19a9      	adds	r1, r5, r6
 801ebdc:	00c9      	lsls	r1, r1, #3
 801ebde:	3108      	adds	r1, #8
 801ebe0:	4441      	add	r1, r8
 801ebe2:	2201      	movs	r2, #1
 801ebe4:	3104      	adds	r1, #4
 801ebe6:	68a0      	ldr	r0, [r4, #8]
 801ebe8:	f7eb fa52 	bl	800a090 <HAL_UART_Receive_IT>
    hipc->State = IPC_STATE_ACTIVE;
 801ebec:	2302      	movs	r3, #2
 801ebee:	7363      	strb	r3, [r4, #13]
    retval = IPC_OK;
 801ebf0:	4638      	mov	r0, r7
 801ebf2:	e7e4      	b.n	801ebbe <IPC_UART_reset+0x3e>
 801ebf4:	20004bdc 	.word	0x20004bdc
 801ebf8:	08034e44 	.word	0x08034e44
 801ebfc:	200046c4 	.word	0x200046c4

0801ec00 <IPC_UART_abort>:
{
 801ec00:	b538      	push	{r3, r4, r5, lr}
 801ec02:	4605      	mov	r5, r0
  PRINT_DBG("IPC abort %p", hipc)
 801ec04:	4c10      	ldr	r4, [pc, #64]	; (801ec48 <IPC_UART_abort+0x48>)
 801ec06:	4602      	mov	r2, r0
 801ec08:	4910      	ldr	r1, [pc, #64]	; (801ec4c <IPC_UART_abort+0x4c>)
 801ec0a:	4620      	mov	r0, r4
 801ec0c:	f007 f830 	bl	8025c70 <sprintf>
 801ec10:	4620      	mov	r0, r4
 801ec12:	f000 fa7e 	bl	801f112 <crs_strlen>
 801ec16:	b283      	uxth	r3, r0
 801ec18:	4622      	mov	r2, r4
 801ec1a:	2102      	movs	r1, #2
 801ec1c:	2005      	movs	r0, #5
 801ec1e:	f000 fabb 	bl	801f198 <traceIF_itmPrint>
 801ec22:	4620      	mov	r0, r4
 801ec24:	f000 fa75 	bl	801f112 <crs_strlen>
 801ec28:	b283      	uxth	r3, r0
 801ec2a:	4622      	mov	r2, r4
 801ec2c:	2102      	movs	r1, #2
 801ec2e:	2005      	movs	r0, #5
 801ec30:	f000 fad4 	bl	801f1dc <traceIF_uartPrint>
  if (hipc->Interface.h_uart != NULL)
 801ec34:	68a8      	ldr	r0, [r5, #8]
 801ec36:	b108      	cbz	r0, 801ec3c <IPC_UART_abort+0x3c>
    if (hipc->Interface.h_uart->gState != HAL_UART_STATE_RESET)
 801ec38:	6f43      	ldr	r3, [r0, #116]	; 0x74
 801ec3a:	b90b      	cbnz	r3, 801ec40 <IPC_UART_abort+0x40>
}
 801ec3c:	2000      	movs	r0, #0
 801ec3e:	bd38      	pop	{r3, r4, r5, pc}
      (void)HAL_UART_AbortTransmit_IT(hipc->Interface.h_uart);
 801ec40:	f7eb fbd0 	bl	800a3e4 <HAL_UART_AbortTransmit_IT>
 801ec44:	e7fa      	b.n	801ec3c <IPC_UART_abort+0x3c>
 801ec46:	bf00      	nop
 801ec48:	20004bdc 	.word	0x20004bdc
 801ec4c:	08034e58 	.word	0x08034e58

0801ec50 <IPC_UART_select>:
{
 801ec50:	b538      	push	{r3, r4, r5, lr}
 801ec52:	4604      	mov	r4, r0
  PRINT_DBG("IPC select %p", hipc)
 801ec54:	4d12      	ldr	r5, [pc, #72]	; (801eca0 <IPC_UART_select+0x50>)
 801ec56:	4602      	mov	r2, r0
 801ec58:	4912      	ldr	r1, [pc, #72]	; (801eca4 <IPC_UART_select+0x54>)
 801ec5a:	4628      	mov	r0, r5
 801ec5c:	f007 f808 	bl	8025c70 <sprintf>
 801ec60:	4628      	mov	r0, r5
 801ec62:	f000 fa56 	bl	801f112 <crs_strlen>
 801ec66:	b283      	uxth	r3, r0
 801ec68:	462a      	mov	r2, r5
 801ec6a:	2102      	movs	r1, #2
 801ec6c:	2005      	movs	r0, #5
 801ec6e:	f000 fa93 	bl	801f198 <traceIF_itmPrint>
 801ec72:	4628      	mov	r0, r5
 801ec74:	f000 fa4d 	bl	801f112 <crs_strlen>
 801ec78:	b283      	uxth	r3, r0
 801ec7a:	462a      	mov	r2, r5
 801ec7c:	2102      	movs	r1, #2
 801ec7e:	2005      	movs	r0, #5
 801ec80:	f000 faac 	bl	801f1dc <traceIF_uartPrint>
  if (hipc != IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801ec84:	7823      	ldrb	r3, [r4, #0]
 801ec86:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ec8a:	4a07      	ldr	r2, [pc, #28]	; (801eca8 <IPC_UART_select+0x58>)
 801ec8c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801ec90:	691b      	ldr	r3, [r3, #16]
 801ec92:	42a3      	cmp	r3, r4
 801ec94:	d002      	beq.n	801ec9c <IPC_UART_select+0x4c>
    (void) change_ipc_channel(hipc);
 801ec96:	4620      	mov	r0, r4
 801ec98:	f7ff fd00 	bl	801e69c <change_ipc_channel>
}
 801ec9c:	2000      	movs	r0, #0
 801ec9e:	bd38      	pop	{r3, r4, r5, pc}
 801eca0:	20004bdc 	.word	0x20004bdc
 801eca4:	08034e6c 	.word	0x08034e6c
 801eca8:	200046c4 	.word	0x200046c4

0801ecac <IPC_UART_get_other_channel>:
{
 801ecac:	b410      	push	{r4}
 801ecae:	4602      	mov	r2, r0
  if ((IPC_DevicesList[hipc->Device_ID].h_current_channel == hipc) &&
 801ecb0:	7803      	ldrb	r3, [r0, #0]
 801ecb2:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 801ecb6:	490d      	ldr	r1, [pc, #52]	; (801ecec <IPC_UART_get_other_channel+0x40>)
 801ecb8:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801ecbc:	690c      	ldr	r4, [r1, #16]
 801ecbe:	4294      	cmp	r4, r2
 801ecc0:	d00b      	beq.n	801ecda <IPC_UART_get_other_channel+0x2e>
  IPC_Handle_t *handle = NULL;
 801ecc2:	2000      	movs	r0, #0
  if ((IPC_DevicesList[hipc->Device_ID].h_inactive_channel == hipc) &&
 801ecc4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ecc8:	4908      	ldr	r1, [pc, #32]	; (801ecec <IPC_UART_get_other_channel+0x40>)
 801ecca:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 801ecce:	695b      	ldr	r3, [r3, #20]
 801ecd0:	4293      	cmp	r3, r2
 801ecd2:	d007      	beq.n	801ece4 <IPC_UART_get_other_channel+0x38>
}
 801ecd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 801ecd8:	4770      	bx	lr
      (IPC_DevicesList[hipc->Device_ID].h_inactive_channel != NULL))
 801ecda:	4904      	ldr	r1, [pc, #16]	; (801ecec <IPC_UART_get_other_channel+0x40>)
 801ecdc:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801ece0:	6948      	ldr	r0, [r1, #20]
 801ece2:	e7ef      	b.n	801ecc4 <IPC_UART_get_other_channel+0x18>
  if ((IPC_DevicesList[hipc->Device_ID].h_inactive_channel == hipc) &&
 801ece4:	2c00      	cmp	r4, #0
 801ece6:	d0f5      	beq.n	801ecd4 <IPC_UART_get_other_channel+0x28>
    handle = IPC_DevicesList[hipc->Device_ID].h_current_channel;
 801ece8:	4620      	mov	r0, r4
  return (handle);
 801ecea:	e7f3      	b.n	801ecd4 <IPC_UART_get_other_channel+0x28>
 801ecec:	200046c4 	.word	0x200046c4

0801ecf0 <IPC_UART_send>:
{
 801ecf0:	b510      	push	{r4, lr}
  if (hipc != IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801ecf2:	7803      	ldrb	r3, [r0, #0]
 801ecf4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ecf8:	4c06      	ldr	r4, [pc, #24]	; (801ed14 <IPC_UART_send+0x24>)
 801ecfa:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 801ecfe:	691b      	ldr	r3, [r3, #16]
 801ed00:	4283      	cmp	r3, r0
 801ed02:	d001      	beq.n	801ed08 <IPC_UART_send+0x18>
    retval = IPC_ERROR;
 801ed04:	2001      	movs	r0, #1
}
 801ed06:	bd10      	pop	{r4, pc}
    (void)HAL_UART_Transmit_IT(hipc->Interface.h_uart, (uint8_t *)p_TxBuffer, bufsize);
 801ed08:	6880      	ldr	r0, [r0, #8]
 801ed0a:	f7eb f989 	bl	800a020 <HAL_UART_Transmit_IT>
    retval = IPC_OK;
 801ed0e:	2000      	movs	r0, #0
 801ed10:	e7f9      	b.n	801ed06 <IPC_UART_send+0x16>
 801ed12:	bf00      	nop
 801ed14:	200046c4 	.word	0x200046c4

0801ed18 <IPC_UART_receive>:
{
 801ed18:	b538      	push	{r3, r4, r5, lr}
  if (hipc->Mode == IPC_MODE_UART_CHARACTER)
 801ed1a:	7b03      	ldrb	r3, [r0, #12]
 801ed1c:	2b00      	cmp	r3, #0
 801ed1e:	d16f      	bne.n	801ee00 <IPC_UART_receive+0xe8>
 801ed20:	4604      	mov	r4, r0
    if (p_msg == NULL)
 801ed22:	b169      	cbz	r1, 801ed40 <IPC_UART_receive+0x28>
      unread_msg = IPC_RXFIFO_read(hipc, p_msg);
 801ed24:	f7ff fc60 	bl	801e5e8 <IPC_RXFIFO_read>
 801ed28:	4605      	mov	r5, r0
      if (unread_msg == -1)
 801ed2a:	f1b0 3fff 	cmp.w	r0, #4294967295
 801ed2e:	d030      	beq.n	801ed92 <IPC_UART_receive+0x7a>
        if (hipc->State == IPC_STATE_PAUSED)
 801ed30:	7b63      	ldrb	r3, [r4, #13]
 801ed32:	2b03      	cmp	r3, #3
 801ed34:	d055      	beq.n	801ede2 <IPC_UART_receive+0xca>
        if (unread_msg == 0)
 801ed36:	2d00      	cmp	r5, #0
 801ed38:	f040 8089 	bne.w	801ee4e <IPC_UART_receive+0x136>
          retval = IPC_RXQUEUE_EMPTY;
 801ed3c:	2002      	movs	r0, #2
 801ed3e:	e085      	b.n	801ee4c <IPC_UART_receive+0x134>
      PRINT_ERR("IPC_receive err - p_msg NULL")
 801ed40:	4d44      	ldr	r5, [pc, #272]	; (801ee54 <IPC_UART_receive+0x13c>)
 801ed42:	4c45      	ldr	r4, [pc, #276]	; (801ee58 <IPC_UART_receive+0x140>)
 801ed44:	f105 0e20 	add.w	lr, r5, #32
 801ed48:	46ac      	mov	ip, r5
 801ed4a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ed4e:	6020      	str	r0, [r4, #0]
 801ed50:	6061      	str	r1, [r4, #4]
 801ed52:	60a2      	str	r2, [r4, #8]
 801ed54:	60e3      	str	r3, [r4, #12]
 801ed56:	4665      	mov	r5, ip
 801ed58:	3410      	adds	r4, #16
 801ed5a:	45f4      	cmp	ip, lr
 801ed5c:	d1f4      	bne.n	801ed48 <IPC_UART_receive+0x30>
 801ed5e:	cd03      	ldmia	r5!, {r0, r1}
 801ed60:	6020      	str	r0, [r4, #0]
 801ed62:	6061      	str	r1, [r4, #4]
 801ed64:	782b      	ldrb	r3, [r5, #0]
 801ed66:	7223      	strb	r3, [r4, #8]
 801ed68:	4c3b      	ldr	r4, [pc, #236]	; (801ee58 <IPC_UART_receive+0x140>)
 801ed6a:	4620      	mov	r0, r4
 801ed6c:	f000 f9d1 	bl	801f112 <crs_strlen>
 801ed70:	b283      	uxth	r3, r0
 801ed72:	4622      	mov	r2, r4
 801ed74:	2110      	movs	r1, #16
 801ed76:	2005      	movs	r0, #5
 801ed78:	f000 fa0e 	bl	801f198 <traceIF_itmPrint>
 801ed7c:	4620      	mov	r0, r4
 801ed7e:	f000 f9c8 	bl	801f112 <crs_strlen>
 801ed82:	b283      	uxth	r3, r0
 801ed84:	4622      	mov	r2, r4
 801ed86:	2110      	movs	r1, #16
 801ed88:	2005      	movs	r0, #5
 801ed8a:	f000 fa27 	bl	801f1dc <traceIF_uartPrint>
      retval = IPC_ERROR;
 801ed8e:	2001      	movs	r0, #1
 801ed90:	e05c      	b.n	801ee4c <IPC_UART_receive+0x134>
        PRINT_ERR("IPC_receive err - no unread msg")
 801ed92:	4d32      	ldr	r5, [pc, #200]	; (801ee5c <IPC_UART_receive+0x144>)
 801ed94:	4c30      	ldr	r4, [pc, #192]	; (801ee58 <IPC_UART_receive+0x140>)
 801ed96:	f105 0e20 	add.w	lr, r5, #32
 801ed9a:	46ac      	mov	ip, r5
 801ed9c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801eda0:	6020      	str	r0, [r4, #0]
 801eda2:	6061      	str	r1, [r4, #4]
 801eda4:	60a2      	str	r2, [r4, #8]
 801eda6:	60e3      	str	r3, [r4, #12]
 801eda8:	4665      	mov	r5, ip
 801edaa:	3410      	adds	r4, #16
 801edac:	45f4      	cmp	ip, lr
 801edae:	d1f4      	bne.n	801ed9a <IPC_UART_receive+0x82>
 801edb0:	cd07      	ldmia	r5!, {r0, r1, r2}
 801edb2:	6020      	str	r0, [r4, #0]
 801edb4:	6061      	str	r1, [r4, #4]
 801edb6:	60a2      	str	r2, [r4, #8]
 801edb8:	4c27      	ldr	r4, [pc, #156]	; (801ee58 <IPC_UART_receive+0x140>)
 801edba:	4620      	mov	r0, r4
 801edbc:	f000 f9a9 	bl	801f112 <crs_strlen>
 801edc0:	b283      	uxth	r3, r0
 801edc2:	4622      	mov	r2, r4
 801edc4:	2110      	movs	r1, #16
 801edc6:	2005      	movs	r0, #5
 801edc8:	f000 f9e6 	bl	801f198 <traceIF_itmPrint>
 801edcc:	4620      	mov	r0, r4
 801edce:	f000 f9a0 	bl	801f112 <crs_strlen>
 801edd2:	b283      	uxth	r3, r0
 801edd4:	4622      	mov	r2, r4
 801edd6:	2110      	movs	r1, #16
 801edd8:	2005      	movs	r0, #5
 801edda:	f000 f9ff 	bl	801f1dc <traceIF_uartPrint>
        retval = IPC_ERROR;
 801edde:	2001      	movs	r0, #1
 801ede0:	e034      	b.n	801ee4c <IPC_UART_receive+0x134>
          hipc->State = IPC_STATE_ACTIVE;
 801ede2:	2302      	movs	r3, #2
 801ede4:	7363      	strb	r3, [r4, #13]
          (void) HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[hipc->Device_ID].RxChar, 1U);
 801ede6:	7823      	ldrb	r3, [r4, #0]
 801ede8:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801edec:	00c9      	lsls	r1, r1, #3
 801edee:	3108      	adds	r1, #8
 801edf0:	4b1b      	ldr	r3, [pc, #108]	; (801ee60 <IPC_UART_receive+0x148>)
 801edf2:	4419      	add	r1, r3
 801edf4:	2201      	movs	r2, #1
 801edf6:	3104      	adds	r1, #4
 801edf8:	68a0      	ldr	r0, [r4, #8]
 801edfa:	f7eb f949 	bl	800a090 <HAL_UART_Receive_IT>
 801edfe:	e79a      	b.n	801ed36 <IPC_UART_receive+0x1e>
    PRINT_ERR("IPC_receive err - IPC mode not matching")
 801ee00:	4d18      	ldr	r5, [pc, #96]	; (801ee64 <IPC_UART_receive+0x14c>)
 801ee02:	4c15      	ldr	r4, [pc, #84]	; (801ee58 <IPC_UART_receive+0x140>)
 801ee04:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801ee08:	46ac      	mov	ip, r5
 801ee0a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ee0e:	6020      	str	r0, [r4, #0]
 801ee10:	6061      	str	r1, [r4, #4]
 801ee12:	60a2      	str	r2, [r4, #8]
 801ee14:	60e3      	str	r3, [r4, #12]
 801ee16:	4665      	mov	r5, ip
 801ee18:	3410      	adds	r4, #16
 801ee1a:	45f4      	cmp	ip, lr
 801ee1c:	d1f4      	bne.n	801ee08 <IPC_UART_receive+0xf0>
 801ee1e:	f8dc 0000 	ldr.w	r0, [ip]
 801ee22:	6020      	str	r0, [r4, #0]
 801ee24:	4c0c      	ldr	r4, [pc, #48]	; (801ee58 <IPC_UART_receive+0x140>)
 801ee26:	4620      	mov	r0, r4
 801ee28:	f000 f973 	bl	801f112 <crs_strlen>
 801ee2c:	b283      	uxth	r3, r0
 801ee2e:	4622      	mov	r2, r4
 801ee30:	2110      	movs	r1, #16
 801ee32:	2005      	movs	r0, #5
 801ee34:	f000 f9b0 	bl	801f198 <traceIF_itmPrint>
 801ee38:	4620      	mov	r0, r4
 801ee3a:	f000 f96a 	bl	801f112 <crs_strlen>
 801ee3e:	b283      	uxth	r3, r0
 801ee40:	4622      	mov	r2, r4
 801ee42:	2110      	movs	r1, #16
 801ee44:	2005      	movs	r0, #5
 801ee46:	f000 f9c9 	bl	801f1dc <traceIF_uartPrint>
    retval = IPC_ERROR;
 801ee4a:	2001      	movs	r0, #1
}
 801ee4c:	bd38      	pop	{r3, r4, r5, pc}
          retval = IPC_RXQUEUE_MSG_AVAIL;
 801ee4e:	2003      	movs	r0, #3
 801ee50:	e7fc      	b.n	801ee4c <IPC_UART_receive+0x134>
 801ee52:	bf00      	nop
 801ee54:	08034e80 	.word	0x08034e80
 801ee58:	20004bdc 	.word	0x20004bdc
 801ee5c:	08034eac 	.word	0x08034eac
 801ee60:	200046c4 	.word	0x200046c4
 801ee64:	08034ed8 	.word	0x08034ed8

0801ee68 <IPC_UART_rearm_RX_IT>:
  if (hipc != NULL)
 801ee68:	b188      	cbz	r0, 801ee8e <IPC_UART_rearm_RX_IT+0x26>
{
 801ee6a:	b508      	push	{r3, lr}
    if (hipc->Interface.interface_type == IPC_INTERFACE_UART)
 801ee6c:	7902      	ldrb	r2, [r0, #4]
 801ee6e:	2a01      	cmp	r2, #1
 801ee70:	d000      	beq.n	801ee74 <IPC_UART_rearm_RX_IT+0xc>
}
 801ee72:	bd08      	pop	{r3, pc}
      (void)HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[hipc->Device_ID].RxChar, 1U);
 801ee74:	7802      	ldrb	r2, [r0, #0]
 801ee76:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 801ee7a:	00c9      	lsls	r1, r1, #3
 801ee7c:	3108      	adds	r1, #8
 801ee7e:	4a04      	ldr	r2, [pc, #16]	; (801ee90 <IPC_UART_rearm_RX_IT+0x28>)
 801ee80:	4411      	add	r1, r2
 801ee82:	2201      	movs	r2, #1
 801ee84:	3104      	adds	r1, #4
 801ee86:	6880      	ldr	r0, [r0, #8]
 801ee88:	f7eb f902 	bl	800a090 <HAL_UART_Receive_IT>
}
 801ee8c:	e7f1      	b.n	801ee72 <IPC_UART_rearm_RX_IT+0xa>
 801ee8e:	4770      	bx	lr
 801ee90:	200046c4 	.word	0x200046c4

0801ee94 <IPC_UART_RxCpltCallback>:
{
 801ee94:	b510      	push	{r4, lr}
  uint8_t device_id = find_Device_Id(UartHandle);
 801ee96:	f7ff fbf5 	bl	801e684 <find_Device_Id>
  if (device_id < IPC_MAX_DEVICES)
 801ee9a:	b968      	cbnz	r0, 801eeb8 <IPC_UART_RxCpltCallback+0x24>
    if (IPC_DevicesList[device_id].h_current_channel != NULL)
 801ee9c:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 801eea0:	4a06      	ldr	r2, [pc, #24]	; (801eebc <IPC_UART_RxCpltCallback+0x28>)
 801eea2:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801eea6:	6910      	ldr	r0, [r2, #16]
 801eea8:	b130      	cbz	r0, 801eeb8 <IPC_UART_RxCpltCallback+0x24>
      IPC_DevicesList[device_id].h_current_channel->RxFifoWrite(IPC_DevicesList[device_id].h_current_channel,
 801eeaa:	f8d0 47f4 	ldr.w	r4, [r0, #2036]	; 0x7f4
 801eeae:	4a03      	ldr	r2, [pc, #12]	; (801eebc <IPC_UART_RxCpltCallback+0x28>)
 801eeb0:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
 801eeb4:	7b19      	ldrb	r1, [r3, #12]
 801eeb6:	47a0      	blx	r4
}
 801eeb8:	bd10      	pop	{r4, pc}
 801eeba:	bf00      	nop
 801eebc:	200046c4 	.word	0x200046c4

0801eec0 <IPC_UART_TxCpltCallback>:
{
 801eec0:	b508      	push	{r3, lr}
  uint8_t device_id = find_Device_Id(UartHandle);
 801eec2:	f7ff fbdf 	bl	801e684 <find_Device_Id>
  if (device_id < IPC_MAX_DEVICES)
 801eec6:	b948      	cbnz	r0, 801eedc <IPC_UART_TxCpltCallback+0x1c>
    if (IPC_DevicesList[device_id].h_current_channel != NULL)
 801eec8:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 801eecc:	4a04      	ldr	r2, [pc, #16]	; (801eee0 <IPC_UART_TxCpltCallback+0x20>)
 801eece:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801eed2:	6918      	ldr	r0, [r3, #16]
 801eed4:	b110      	cbz	r0, 801eedc <IPC_UART_TxCpltCallback+0x1c>
      IPC_DevicesList[device_id].h_current_channel->TxClientCallback(
 801eed6:	f8d0 37ec 	ldr.w	r3, [r0, #2028]	; 0x7ec
 801eeda:	4798      	blx	r3
}
 801eedc:	bd08      	pop	{r3, pc}
 801eede:	bf00      	nop
 801eee0:	200046c4 	.word	0x200046c4

0801eee4 <IPC_UART_ErrorCallback>:
}
 801eee4:	4770      	bx	lr

0801eee6 <rtosalGetSysTimerCount>:
/**
  * @brief  Get the RTOS kernel system timer count.
  * @retval uint32_t - RTOS kernel current system timer count as 32-bit value.
  */
uint32_t rtosalGetSysTimerCount(void)
{
 801eee6:	b508      	push	{r3, lr}
  uint32_t retval;
#if (osCMSIS < 0x20000U)
  retval = osKernelSysTick();
 801eee8:	f004 fb95 	bl	8023616 <osKernelSysTick>
#else
  retval = osKernelGetSysTimerCount();
#endif /* osCMSIS < 0x20000U */
  return (retval);
}
 801eeec:	bd08      	pop	{r3, pc}

0801eeee <rtosalThreadNew>:
  * @param  p_arg      - argument passed to the thread function when it is started.
  * @retval osThreadId - thread ID for reference by other functions or NULL in case of error.
  */
osThreadId rtosalThreadNew(const rtosal_char_t *p_name, os_pthread func, osPriority priority, uint32_t stacksize,
                           void *p_arg)
{
 801eeee:	b500      	push	{lr}
 801eef0:	b087      	sub	sp, #28
  osThreadId retval;

#if (osCMSIS < 0x20000U)
  /* Thread definition */

  const osThreadDef_t rtosal_thread_def =
 801eef2:	9001      	str	r0, [sp, #4]
 801eef4:	9102      	str	r1, [sp, #8]
 801eef6:	f8ad 200c 	strh.w	r2, [sp, #12]
 801eefa:	2200      	movs	r2, #0
 801eefc:	9204      	str	r2, [sp, #16]
 801eefe:	9305      	str	r3, [sp, #20]
    .tpriority = priority,
    .instances = 0U,
    .stacksize = stacksize /* allocated size : stacksize * sizeof(StackType_t) done by CMSIS */
  };

  retval = osThreadCreate(&rtosal_thread_def, p_arg);
 801ef00:	9908      	ldr	r1, [sp, #32]
 801ef02:	a801      	add	r0, sp, #4
 801ef04:	f004 fb91 	bl	802362a <osThreadCreate>

  retval = osThreadNew((osThreadFunc_t)func, p_arg, &rtosal_thread_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801ef08:	b007      	add	sp, #28
 801ef0a:	f85d fb04 	ldr.w	pc, [sp], #4

0801ef0e <rtosalSemaphoreNew>:
  * @param  count         - number of available resources.
  * @note   At creation semaphore max count is set to count.
  * @retval osSemaphoreId - semaphore ID for reference by other functions or NULL in case of error.
  */
osSemaphoreId rtosalSemaphoreNew(const rtosal_char_t *p_name, uint32_t count)
{
 801ef0e:	b500      	push	{lr}
 801ef10:	b083      	sub	sp, #12
  osSemaphoreId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  osSemaphoreDef(SEM); /* true name can not be used when (osCMSIS < 0x20000U) */
 801ef12:	2300      	movs	r3, #0
 801ef14:	9301      	str	r3, [sp, #4]
  retval = osSemaphoreCreate(osSemaphore(SEM), (int32_t)count); /* No issue with cast to (int32_t) */
 801ef16:	a801      	add	r0, sp, #4
 801ef18:	f004 fc84 	bl	8023824 <osSemaphoreCreate>

  retval = osSemaphoreNew(count, count, &rtosal_sem_attr); /* maximum count is set to initial count */
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801ef1c:	b003      	add	sp, #12
 801ef1e:	f85d fb04 	ldr.w	pc, [sp], #4

0801ef22 <rtosalSemaphoreAcquire>:
  * @note   With CMSIS RTOS V1, this function returns osErrorOS when no token is available.
  *         With CMSIS RTOS V2, this function returns osErrorResource when no token is available.
  *         Conclusion: test (rtosalStatus != osOK) to be independent of osCMSIS version.
  */
rtosalStatus rtosalSemaphoreAcquire(osSemaphoreId semaphore_id, uint32_t timeout)
{
 801ef22:	b508      	push	{r3, lr}
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  /* Due to incompatibility between V1 and V2 return type retval is converted to osStatus
     see V1 API documentation for more details */
  status = (osStatus)osSemaphoreWait(semaphore_id, timeout);
 801ef24:	f004 fc95 	bl	8023852 <osSemaphoreWait>
#else
  status = osSemaphoreAcquire(semaphore_id, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801ef28:	bd08      	pop	{r3, pc}

0801ef2a <rtosalSemaphoreRelease>:
  * @brief  Release a Semaphore token.
  * @param  semaphore_id - semaphore ID obtained by rtosalSemaphoreNew.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalSemaphoreRelease(osSemaphoreId semaphore_id)
{
 801ef2a:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osSemaphoreRelease(semaphore_id);
 801ef2c:	f004 fcc0 	bl	80238b0 <osSemaphoreRelease>
  return (status);
}
 801ef30:	bd08      	pop	{r3, pc}

0801ef32 <rtosalMutexNew>:
  * @param  p_name    - mutex name.
  * @note   With CMSIS RTOS V1, name is unused.
  * @retval osMutexId - mutex ID for reference by other functions or NULL in case of error.
  */
osMutexId rtosalMutexNew(const rtosal_char_t *p_name)
{
 801ef32:	b500      	push	{lr}
 801ef34:	b083      	sub	sp, #12
  osMutexId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  osMutexDef(MUTEX); /* true name can not be used when (osCMSIS < 0x20000U) */
 801ef36:	2300      	movs	r3, #0
 801ef38:	9301      	str	r3, [sp, #4]
  retval = osMutexCreate(osMutex(MUTEX));
 801ef3a:	a801      	add	r0, sp, #4
 801ef3c:	f004 fc10 	bl	8023760 <osMutexCreate>

  retval = osMutexNew(&rtosal_mutex_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801ef40:	b003      	add	sp, #12
 801ef42:	f85d fb04 	ldr.w	pc, [sp], #4

0801ef46 <rtosalMutexAcquire>:
  * @note   With CMSIS RTOS V1, this function returns osErrorOS when no mutex is available.
  *         With CMSIS RTOS V2, this function returns osErrorResource when no mutex is available.
  *         Conclusion: test (rtosalStatus != osOK) to be independent of osCMSIS version.
  */
rtosalStatus rtosalMutexAcquire(osMutexId mutex_id, uint32_t timeout)
{
 801ef46:	b508      	push	{r3, lr}
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  status = osMutexWait(mutex_id, timeout);
 801ef48:	f004 fc0f 	bl	802376a <osMutexWait>
#else
  status = osMutexAcquire(mutex_id, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801ef4c:	bd08      	pop	{r3, pc}

0801ef4e <rtosalMutexRelease>:
  * @brief  Release a Mutex that was acquired by rtosalMutexAcquire.
  * @param  mutex_id     - mutex ID obtained by rtosalMutexNew.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalMutexRelease(osMutexId mutex_id)
{
 801ef4e:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osMutexRelease(mutex_id);
 801ef50:	f004 fc3b 	bl	80237ca <osMutexRelease>
  return (status);
}
 801ef54:	bd08      	pop	{r3, pc}

0801ef56 <rtosalMessageQueueNew>:
  * @note   With CMSIS RTOS V1, name is unused.
  * @param  queue_size   - maximum number of messages in queue.
  * @retval osMessageQId - message queue ID for reference by other functions or NULL in case of error.
  */
osMessageQId rtosalMessageQueueNew(const rtosal_char_t *p_name, uint32_t queue_size)
{
 801ef56:	b500      	push	{lr}
 801ef58:	b083      	sub	sp, #12
  osMessageQId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  const osMessageQDef_t rtosal_queue_def =
 801ef5a:	9100      	str	r1, [sp, #0]
 801ef5c:	2304      	movs	r3, #4
 801ef5e:	9301      	str	r3, [sp, #4]
  {
    .queue_sz = queue_size,
    .item_sz = sizeof(uint32_t) /* This implementation supports 32-bit sized messages only */
  };

  retval = osMessageCreate(&rtosal_queue_def, NULL);
 801ef60:	2100      	movs	r1, #0
 801ef62:	4668      	mov	r0, sp
 801ef64:	f004 fcd1 	bl	802390a <osMessageCreate>
  /* This implementation supports 32-bit sized messages only */
  retval = osMessageQueueNew(queue_size, sizeof(uint32_t), &rtosal_message_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801ef68:	b003      	add	sp, #12
 801ef6a:	f85d fb04 	ldr.w	pc, [sp], #4

0801ef6e <rtosalMessageQueuePut>:
  * @note   With CMSIS RTOS V1, this function returns osErrorOS if the queue is full.
  *         With CMSIS RTOS V2, this function returns osErrorResource if the queue is fulle.
  *         Conclusion: test (rtosalStatus != osOK) to be independent of osCMSIS version.
  */
rtosalStatus rtosalMessageQueuePut(osMessageQId mq_id, uint32_t msg, uint32_t timeout)
{
 801ef6e:	b508      	push	{r3, lr}
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  status = osMessagePut(mq_id, msg, timeout);
 801ef70:	f004 fcd2 	bl	8023918 <osMessagePut>
  /* Message priority always set to same priority : 0 */
  status = osMessageQueuePut(mq_id, (const void *)&msg, 0U, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801ef74:	bd08      	pop	{r3, pc}

0801ef76 <rtosalMessageQueueGet>:
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  osEvent event;

  if (p_msg == NULL)  /* Check parameter */
 801ef76:	b171      	cbz	r1, 801ef96 <rtosalMessageQueueGet+0x20>
{
 801ef78:	b510      	push	{r4, lr}
 801ef7a:	b084      	sub	sp, #16
 801ef7c:	460c      	mov	r4, r1
  {
    status = osErrorParameter;
  }
  else
  {
    event = osMessageGet(mq_id, timeout);
 801ef7e:	4601      	mov	r1, r0
 801ef80:	a801      	add	r0, sp, #4
 801ef82:	f004 fcfc 	bl	802397e <osMessageGet>

    /* Retrieve the status from the returned structure */
    status = event.status;
 801ef86:	9801      	ldr	r0, [sp, #4]
    /* if a msg has been received then store it in user buffer */
    if (status == osEventMessage)
 801ef88:	2810      	cmp	r0, #16
 801ef8a:	d001      	beq.n	801ef90 <rtosalMessageQueueGet+0x1a>
  /* msg_prio is not managed, so set to NULL */
  status = osMessageQueueGet(mq_id, p_msg, NULL, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801ef8c:	b004      	add	sp, #16
 801ef8e:	bd10      	pop	{r4, pc}
      *p_msg = event.value.v;
 801ef90:	9b02      	ldr	r3, [sp, #8]
 801ef92:	6023      	str	r3, [r4, #0]
 801ef94:	e7fa      	b.n	801ef8c <rtosalMessageQueueGet+0x16>
    status = osErrorParameter;
 801ef96:	2080      	movs	r0, #128	; 0x80
}
 801ef98:	4770      	bx	lr

0801ef9a <rtosalTimerNew>:
  * @param   type     - osTimerOnce for one-shot or osTimerPeriodic for periodic behavior
  * @param   p_arg    - argument passed to the timer callback function when it is called.
  * @retval osTimerId - timer ID for reference by other functions or NULL in case of error.
  */
osTimerId rtosalTimerNew(const rtosal_char_t *p_name, os_ptimer func, os_timer_type type, void *p_arg)
{
 801ef9a:	b500      	push	{lr}
 801ef9c:	b083      	sub	sp, #12
 801ef9e:	4608      	mov	r0, r1
 801efa0:	4611      	mov	r1, r2
  osTimerId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  osTimerDef(TIM, func); /* true name can not be used when (osCMSIS < 0x20000U) */
 801efa2:	9001      	str	r0, [sp, #4]
  retval = osTimerCreate(osTimer(TIM), type, p_arg);
 801efa4:	461a      	mov	r2, r3
 801efa6:	a801      	add	r0, sp, #4
 801efa8:	f004 fb60 	bl	802366c <osTimerCreate>

  retval = osTimerNew((osTimerFunc_t)func, (osTimerType_t)type, p_arg, &rtosal_timer_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801efac:	b003      	add	sp, #12
 801efae:	f85d fb04 	ldr.w	pc, [sp], #4

0801efb2 <rtosalTimerStart>:
  * @param  timer_id     - timer ID obtained by rtosalTimerNew.
  * @param  ticks        - "time ticks" value of the timer.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalTimerStart(osTimerId timer_id, uint32_t ticks)
{
 801efb2:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osTimerStart(timer_id, ticks);
 801efb4:	f004 fb6e 	bl	8023694 <osTimerStart>
  return (status);
}
 801efb8:	bd08      	pop	{r3, pc}

0801efba <rtosalTimerStop>:
  * @retval rtosalStatus - indicate the execution status of the function.
  * @note   With CMSIS RTOS V1, this function returns osOK if the timer is not started.
  *         With CMSIS RTOS V2, this function returns osErrorResource if the timer is not started.
  */
rtosalStatus rtosalTimerStop(osTimerId timer_id)
{
 801efba:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osTimerStop(timer_id);
 801efbc:	f004 fb9f 	bl	80236fe <osTimerStop>
  return (status);
}
 801efc0:	bd08      	pop	{r3, pc}

0801efc2 <rtosalDelay>:
  * @brief Wait for Timeout (Time Delay).
  * @param ticks         - "time ticks" value.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalDelay(uint32_t ticks)
{
 801efc2:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osDelay(ticks);
 801efc4:	f004 fb4b 	bl	802365e <osDelay>
  return (status);
}
 801efc8:	bd08      	pop	{r3, pc}

0801efca <crc_get_ip_addr>:
  * @param  port      (out) optional ip port
  * @note             if no port is needed put this parameter to NULL
  * @retval validity of conversion: retval==0 conversion OK /   retval!=0 conversion KO
  */
uint32_t crc_get_ip_addr(uint8_t *string, uint8_t *addr, uint16_t *port)
{
 801efca:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801efce:	4606      	mov	r6, r0
 801efd0:	4689      	mov	r9, r1
 801efd2:	4693      	mov	fp, r2
  bool leave;

  ret    = 0U;
  offset = 0;

  leave = false;
 801efd4:	f04f 0800 	mov.w	r8, #0
  offset = 0;
 801efd8:	4647      	mov	r7, r8
  ret    = 0U;
 801efda:	46c2      	mov	sl, r8

  /* parse the 4 byte of the IP addr */
  for (i = 0U ; (i < 4U) && (leave == false) ; i++)
 801efdc:	4645      	mov	r5, r8
 801efde:	e011      	b.n	801f004 <crc_get_ip_addr+0x3a>
  {
    /* parse the digits (max 3) of the IP addr */
    for (j = 0U ; j <= CRC_IP_ADDR_DIGIT_SIZE ; j++)
 801efe0:	3401      	adds	r4, #1
 801efe2:	b2e4      	uxtb	r4, r4
 801efe4:	2c03      	cmp	r4, #3
 801efe6:	d805      	bhi.n	801eff4 <crc_get_ip_addr+0x2a>
    {
      if ((string[j + offset] < (uint8_t)'0') || (string[j + offset] > (uint8_t)'9'))
 801efe8:	19e3      	adds	r3, r4, r7
 801efea:	5cf3      	ldrb	r3, [r6, r3]
 801efec:	3b30      	subs	r3, #48	; 0x30
 801efee:	b2db      	uxtb	r3, r3
 801eff0:	2b09      	cmp	r3, #9
 801eff2:	d9f5      	bls.n	801efe0 <crc_get_ip_addr+0x16>
        /* not a decimal digit => end of  addr byte */
        break;
      }
    }

    if ((j == (CRC_IP_ADDR_DIGIT_SIZE + 1U)) || (j == 0U))
 801eff4:	2c04      	cmp	r4, #4
 801eff6:	d019      	beq.n	801f02c <crc_get_ip_addr+0x62>
 801eff8:	b95c      	cbnz	r4, 801f012 <crc_get_ip_addr+0x48>
    {
      /* not a correct addr byte found => return error */
      ret = 1;
      leave = true;
 801effa:	f04f 0801 	mov.w	r8, #1
      ret = 1;
 801effe:	46c2      	mov	sl, r8
  for (i = 0U ; (i < 4U) && (leave == false) ; i++)
 801f000:	3501      	adds	r5, #1
 801f002:	b2ed      	uxtb	r5, r5
 801f004:	2d03      	cmp	r5, #3
 801f006:	d815      	bhi.n	801f034 <crc_get_ip_addr+0x6a>
 801f008:	f1b8 0f00 	cmp.w	r8, #0
 801f00c:	d112      	bne.n	801f034 <crc_get_ip_addr+0x6a>
    for (j = 0U ; j <= CRC_IP_ADDR_DIGIT_SIZE ; j++)
 801f00e:	2400      	movs	r4, #0
 801f010:	e7e8      	b.n	801efe4 <crc_get_ip_addr+0x1a>
    }
    else
    {
      /* correct addr byte found: convert it ito integer */
      addr[i] = (uint8_t)crs_atoi(&string[offset]);
 801f012:	19f0      	adds	r0, r6, r7
 801f014:	f000 f838 	bl	801f088 <crs_atoi>
 801f018:	f809 0005 	strb.w	r0, [r9, r5]
      if (string[offset + j] != (uint8_t)'.')
 801f01c:	443c      	add	r4, r7
 801f01e:	5d33      	ldrb	r3, [r6, r4]
 801f020:	2b2e      	cmp	r3, #46	; 0x2e
 801f022:	d001      	beq.n	801f028 <crc_get_ip_addr+0x5e>
      {
        /* not the byte separator => end of parsing */
        leave = true;
 801f024:	f04f 0801 	mov.w	r8, #1
      }
      offset = offset + j + 1U;
 801f028:	1c67      	adds	r7, r4, #1
 801f02a:	e7e9      	b.n	801f000 <crc_get_ip_addr+0x36>
      leave = true;
 801f02c:	f04f 0801 	mov.w	r8, #1
      ret = 1;
 801f030:	46c2      	mov	sl, r8
 801f032:	e7e5      	b.n	801f000 <crc_get_ip_addr+0x36>
    }
  }

  if (i != 4U)
 801f034:	2d04      	cmp	r5, #4
 801f036:	d012      	beq.n	801f05e <crc_get_ip_addr+0x94>
  {
    /* number of arrd bytes != 4 => not an ip addr */
    ret = 1;
 801f038:	f04f 0a01 	mov.w	sl, #1
  }

  if (ret == 1U)
  {
    /* conversion fail => set returned ip addr to 0  */
    addr[0] = 0U;
 801f03c:	2300      	movs	r3, #0
 801f03e:	f889 3000 	strb.w	r3, [r9]
    addr[1] = 0U;
 801f042:	f889 3001 	strb.w	r3, [r9, #1]
    addr[2] = 0U;
 801f046:	f889 3002 	strb.w	r3, [r9, #2]
    addr[3] = 0U;
 801f04a:	f889 3003 	strb.w	r3, [r9, #3]
    if (port != NULL)
 801f04e:	f1bb 0f00 	cmp.w	fp, #0
 801f052:	d001      	beq.n	801f058 <crc_get_ip_addr+0x8e>
    {
      /* set returned port number to 0  */
      *port = 0;
 801f054:	f8ab 3000 	strh.w	r3, [fp]
    }
  }
  return ret;
}
 801f058:	4650      	mov	r0, sl
 801f05a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (port != NULL)
 801f05e:	f1bb 0f00 	cmp.w	fp, #0
 801f062:	d007      	beq.n	801f074 <crc_get_ip_addr+0xaa>
      if (string[offset - 1U] == (uint8_t)':')
 801f064:	19f3      	adds	r3, r6, r7
 801f066:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 801f06a:	2b3a      	cmp	r3, #58	; 0x3a
 801f06c:	d006      	beq.n	801f07c <crc_get_ip_addr+0xb2>
        *port = 0;
 801f06e:	2300      	movs	r3, #0
 801f070:	f8ab 3000 	strh.w	r3, [fp]
  if (ret == 1U)
 801f074:	f1ba 0f00 	cmp.w	sl, #0
 801f078:	d0ee      	beq.n	801f058 <crc_get_ip_addr+0x8e>
 801f07a:	e7df      	b.n	801f03c <crc_get_ip_addr+0x72>
        *port = (uint16_t)crs_atoi(&string[offset]);
 801f07c:	19f0      	adds	r0, r6, r7
 801f07e:	f000 f803 	bl	801f088 <crs_atoi>
 801f082:	f8ab 0000 	strh.w	r0, [fp]
 801f086:	e7f5      	b.n	801f074 <crc_get_ip_addr+0xaa>

0801f088 <crs_atoi>:
  * @brief  convert a ascci number to an integer
  * @param  string  ascii string number to convert
  * @retval result of conversion
  */
int32_t crs_atoi(const uint8_t *string)
{
 801f088:	b410      	push	{r4}
 801f08a:	4684      	mov	ip, r0
  bool  leave;

  result = 0;
  offset = 0U;

  if (*string == (uint8_t)'-')
 801f08c:	7803      	ldrb	r3, [r0, #0]
 801f08e:	2b2d      	cmp	r3, #45	; 0x2d
 801f090:	d006      	beq.n	801f0a0 <crs_atoi+0x18>
  }
  else
  {
    /* positive number */
    sign = 0;
    if (string[offset] == (uint8_t)'+')
 801f092:	2b2b      	cmp	r3, #43	; 0x2b
 801f094:	d007      	beq.n	801f0a6 <crs_atoi+0x1e>
    sign = 0;
 801f096:	2400      	movs	r4, #0
  offset = 0U;
 801f098:	4622      	mov	r2, r4
    {
      offset++;
    }
  }

  leave = false;
 801f09a:	2100      	movs	r1, #0
  result = 0;
 801f09c:	4608      	mov	r0, r1

  /* partsing string while decimal digit are found */
  while (leave == false)
 801f09e:	e006      	b.n	801f0ae <crs_atoi+0x26>
    sign = 1;
 801f0a0:	2401      	movs	r4, #1
    offset++;
 801f0a2:	4622      	mov	r2, r4
 801f0a4:	e7f9      	b.n	801f09a <crs_atoi+0x12>
    sign = 0;
 801f0a6:	2400      	movs	r4, #0
      offset++;
 801f0a8:	2201      	movs	r2, #1
 801f0aa:	e7f6      	b.n	801f09a <crs_atoi+0x12>
  {
    if ((string[offset] < (uint8_t)'0') || (string[offset] > (uint8_t)'9'))
    {
      /* not a digit => end of parsing */
      leave = true;
 801f0ac:	2101      	movs	r1, #1
  while (leave == false)
 801f0ae:	b959      	cbnz	r1, 801f0c8 <crs_atoi+0x40>
    if ((string[offset] < (uint8_t)'0') || (string[offset] > (uint8_t)'9'))
 801f0b0:	f81c 3002 	ldrb.w	r3, [ip, r2]
 801f0b4:	3b30      	subs	r3, #48	; 0x30
 801f0b6:	b2db      	uxtb	r3, r3
 801f0b8:	2b09      	cmp	r3, #9
 801f0ba:	d8f7      	bhi.n	801f0ac <crs_atoi+0x24>
    else
    {
      /* digit found => adding it in the integer result */
      digit8 = string[offset] - (uint8_t)'0';
      digit  = (int32_t)digit8;
      result = (10 * result) + digit;
 801f0bc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801f0c0:	eb03 0040 	add.w	r0, r3, r0, lsl #1
      offset++;
 801f0c4:	3201      	adds	r2, #1
 801f0c6:	e7f2      	b.n	801f0ae <crs_atoi+0x26>
    }
  }

  if (sign != 0)
 801f0c8:	b104      	cbz	r4, 801f0cc <crs_atoi+0x44>
  {
    /* negative number => set the opposite */
    result = -result;
 801f0ca:	4240      	negs	r0, r0
  }
  return result;
}
 801f0cc:	f85d 4b04 	ldr.w	r4, [sp], #4
 801f0d0:	4770      	bx	lr

0801f0d2 <crs_atoi_hex>:
  uint32_t offset;

  result = 0;
  offset = 0;

  if (string != NULL)
 801f0d2:	4684      	mov	ip, r0
 801f0d4:	b1d8      	cbz	r0, 801f10e <crs_atoi_hex+0x3c>
  offset = 0;
 801f0d6:	2100      	movs	r1, #0
  result = 0;
 801f0d8:	4608      	mov	r0, r1
 801f0da:	e009      	b.n	801f0f0 <crs_atoi_hex+0x1e>
      {
        /* hexa decimal digit found */
        digit8 = string[offset] - (uint8_t)'a' + 10U;
        digit  = (uint32_t)digit8;
      }
      else if ((string[offset] >= (uint8_t)'A') && (string[offset] <= (uint8_t)'F'))
 801f0dc:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 801f0e0:	b2db      	uxtb	r3, r3
 801f0e2:	2b05      	cmp	r3, #5
 801f0e4:	d814      	bhi.n	801f110 <crs_atoi_hex+0x3e>
      {
        /* hexa decimal digit found */
        digit8 =  string[offset] - (uint8_t)'A' + 10U;
 801f0e6:	3a37      	subs	r2, #55	; 0x37
 801f0e8:	b2d3      	uxtb	r3, r2
        /* not a digit => end of number */
        break;
      }

      /*  adding the current digit in the integer result */
      result = (16 * result) + (int32_t)digit;
 801f0ea:	eb03 1000 	add.w	r0, r3, r0, lsl #4
      offset++;
 801f0ee:	3101      	adds	r1, #1
      if ((string[offset] >= (uint8_t)'0') && (string[offset] <= (uint8_t)'9'))
 801f0f0:	f81c 2001 	ldrb.w	r2, [ip, r1]
 801f0f4:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 801f0f8:	b2db      	uxtb	r3, r3
 801f0fa:	2b09      	cmp	r3, #9
 801f0fc:	d9f5      	bls.n	801f0ea <crs_atoi_hex+0x18>
      else if ((string[offset] >= (uint8_t)'a') && (string[offset] <= (uint8_t)'f'))
 801f0fe:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 801f102:	b2db      	uxtb	r3, r3
 801f104:	2b05      	cmp	r3, #5
 801f106:	d8e9      	bhi.n	801f0dc <crs_atoi_hex+0xa>
        digit8 = string[offset] - (uint8_t)'a' + 10U;
 801f108:	3a57      	subs	r2, #87	; 0x57
 801f10a:	b2d3      	uxtb	r3, r2
        digit  = (uint32_t)digit8;
 801f10c:	e7ed      	b.n	801f0ea <crs_atoi_hex+0x18>
  result = 0;
 801f10e:	2000      	movs	r0, #0
    }
  }
  return result;
}
 801f110:	4770      	bx	lr

0801f112 <crs_strlen>:
{
  uint32_t i;
  uint32_t res;
  res = 0;

  if (string != NULL)
 801f112:	4602      	mov	r2, r0
 801f114:	b138      	cbz	r0, 801f126 <crs_strlen+0x14>
  {
    /* parsing string looking for '0' char */
    for (i = 0U ; i < CRS_STRLEN_MAX ; i++)
 801f116:	2000      	movs	r0, #0
 801f118:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 801f11c:	d204      	bcs.n	801f128 <crs_strlen+0x16>
    {
      if (string[i] == 0U)
 801f11e:	5c13      	ldrb	r3, [r2, r0]
 801f120:	b11b      	cbz	r3, 801f12a <crs_strlen+0x18>
    for (i = 0U ; i < CRS_STRLEN_MAX ; i++)
 801f122:	3001      	adds	r0, #1
 801f124:	e7f8      	b.n	801f118 <crs_strlen+0x6>
 801f126:	4770      	bx	lr
  res = 0;
 801f128:	2000      	movs	r0, #0
        break;
      }
    }
  }
  return res;
}
 801f12a:	4770      	bx	lr

0801f12c <ITM_Out>:
  * @retval -
  */
static void ITM_Out(uint32_t port, uint32_t ch)
{
  /* Check port validity (0-31)*/
  if (port <= 31U)
 801f12c:	281f      	cmp	r0, #31
 801f12e:	d819      	bhi.n	801f164 <ITM_Out+0x38>
  {
    uint32_t tmp_mask;
    tmp_mask = (ITM->TER & (1UL << port));
 801f130:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
 801f134:	f8dc 2e00 	ldr.w	r2, [ip, #3584]	; 0xe00
 801f138:	2301      	movs	r3, #1
 801f13a:	4083      	lsls	r3, r0
 801f13c:	401a      	ands	r2, r3
    if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&   /* ITM enabled ? */
 801f13e:	f8dc 3e80 	ldr.w	r3, [ip, #3712]	; 0xe80
 801f142:	f013 0f01 	tst.w	r3, #1
 801f146:	d00d      	beq.n	801f164 <ITM_Out+0x38>
 801f148:	b90a      	cbnz	r2, 801f14e <ITM_Out+0x22>
 801f14a:	4770      	bx	lr
    {
      /* Wait until ITM port is ready */
      while (ITM->PORT[port].u32 == 0UL)
      {
        /* Nothing to do except continue to wait */
        __NOP();
 801f14c:	bf00      	nop
      while (ITM->PORT[port].u32 == 0UL)
 801f14e:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 801f152:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 801f156:	2b00      	cmp	r3, #0
 801f158:	d0f8      	beq.n	801f14c <ITM_Out+0x20>
      }

      /* ITM port is ready, send data, one byte at a time */
      ITM->PORT[port].u8 = (uint8_t) ch;
 801f15a:	b2c9      	uxtb	r1, r1
 801f15c:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 801f160:	f803 1020 	strb.w	r1, [r3, r0, lsl #2]
    }
  }
}
 801f164:	4770      	bx	lr
	...

0801f168 <traceIF_uartTransmit>:
  * @param  ptr - pointer on the trace string
  * @param  len - length of the trace string
  * @retval -
  */
static void traceIF_uartTransmit(uint8_t *ptr, uint16_t len)
{
 801f168:	b570      	push	{r4, r5, r6, lr}
 801f16a:	4604      	mov	r4, r0
 801f16c:	460d      	mov	r5, r1
#if (RTOS_USED == 1)
  /* Mutex is used to avoid trace mixing between components */
  (void)rtosalMutexAcquire(traceIF_uart_mutex, RTOSAL_WAIT_FOREVER);
 801f16e:	4e08      	ldr	r6, [pc, #32]	; (801f190 <traceIF_uartTransmit+0x28>)
 801f170:	f04f 31ff 	mov.w	r1, #4294967295
 801f174:	6830      	ldr	r0, [r6, #0]
 801f176:	f7ff fee6 	bl	801ef46 <rtosalMutexAcquire>
#endif /* (RTOS_USED == 1) */

  /* Send the trace */
  (void)HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)ptr, len, HAL_MAX_DELAY);
 801f17a:	f04f 33ff 	mov.w	r3, #4294967295
 801f17e:	462a      	mov	r2, r5
 801f180:	4621      	mov	r1, r4
 801f182:	4804      	ldr	r0, [pc, #16]	; (801f194 <traceIF_uartTransmit+0x2c>)
 801f184:	f7eb fb90 	bl	800a8a8 <HAL_UART_Transmit>

#if (RTOS_USED == 1)
  (void)rtosalMutexRelease(traceIF_uart_mutex);
 801f188:	6830      	ldr	r0, [r6, #0]
 801f18a:	f7ff fee0 	bl	801ef4e <rtosalMutexRelease>
#endif /* (RTOS_USED == 1) */
}
 801f18e:	bd70      	pop	{r4, r5, r6, pc}
 801f190:	200054dc 	.word	0x200054dc
 801f194:	20000c04 	.word	0x20000c04

0801f198 <traceIF_itmPrint>:
  * @param  pptr - pointer on the trace
  * @param  len - length of the trace
  * @retval -
  */
void traceIF_itmPrint(uint8_t port, uint8_t lvl, uint8_t *pptr, uint16_t len)
{
 801f198:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f19a:	461f      	mov	r7, r3
  /* Is trace enable ? */
  if (traceIF_traceEnable == true)
 801f19c:	4b0c      	ldr	r3, [pc, #48]	; (801f1d0 <traceIF_itmPrint+0x38>)
 801f19e:	781b      	ldrb	r3, [r3, #0]
 801f1a0:	b143      	cbz	r3, 801f1b4 <traceIF_itmPrint+0x1c>
 801f1a2:	4606      	mov	r6, r0
 801f1a4:	4615      	mov	r5, r2
  {
    /* Is this level of trace activated ? */
    if ((traceIF_Level & lvl) != 0U)
 801f1a6:	4b0b      	ldr	r3, [pc, #44]	; (801f1d4 <traceIF_itmPrint+0x3c>)
 801f1a8:	681b      	ldr	r3, [r3, #0]
 801f1aa:	4219      	tst	r1, r3
 801f1ac:	d002      	beq.n	801f1b4 <traceIF_itmPrint+0x1c>
    {
      /* Is the trace for this component activated ? */
      if (traceIF_traceComponent[port] != 0U)
 801f1ae:	4b0a      	ldr	r3, [pc, #40]	; (801f1d8 <traceIF_itmPrint+0x40>)
 801f1b0:	5c1b      	ldrb	r3, [r3, r0]
 801f1b2:	b953      	cbnz	r3, 801f1ca <traceIF_itmPrint+0x32>
          ptr++;
        }
      }
    }
  }
}
 801f1b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          ITM_Out((uint32_t) port, (uint32_t) *ptr);
 801f1b6:	f815 1b01 	ldrb.w	r1, [r5], #1
 801f1ba:	4630      	mov	r0, r6
 801f1bc:	f7ff ffb6 	bl	801f12c <ITM_Out>
        for (uint16_t i = 0U; i < len; i++)
 801f1c0:	3401      	adds	r4, #1
 801f1c2:	b2a4      	uxth	r4, r4
 801f1c4:	42bc      	cmp	r4, r7
 801f1c6:	d3f6      	bcc.n	801f1b6 <traceIF_itmPrint+0x1e>
 801f1c8:	e7f4      	b.n	801f1b4 <traceIF_itmPrint+0x1c>
 801f1ca:	2400      	movs	r4, #0
 801f1cc:	e7fa      	b.n	801f1c4 <traceIF_itmPrint+0x2c>
 801f1ce:	bf00      	nop
 801f1d0:	2000022e 	.word	0x2000022e
 801f1d4:	2000021c 	.word	0x2000021c
 801f1d8:	20000220 	.word	0x20000220

0801f1dc <traceIF_uartPrint>:
  * @param  pptr - pointer on the trace
  * @param  len - length of the trace
  * @retval -
  */
void traceIF_uartPrint(uint8_t port, uint8_t lvl, uint8_t *pptr, uint16_t len)
{
 801f1dc:	b510      	push	{r4, lr}
  /* Is trace enable ? */
  if (traceIF_traceEnable == true)
 801f1de:	4c08      	ldr	r4, [pc, #32]	; (801f200 <traceIF_uartPrint+0x24>)
 801f1e0:	7824      	ldrb	r4, [r4, #0]
 801f1e2:	b134      	cbz	r4, 801f1f2 <traceIF_uartPrint+0x16>
  {
    /* Is this level of trace activated ? */
    if ((traceIF_Level & lvl) != 0U)
 801f1e4:	4c07      	ldr	r4, [pc, #28]	; (801f204 <traceIF_uartPrint+0x28>)
 801f1e6:	6824      	ldr	r4, [r4, #0]
 801f1e8:	4221      	tst	r1, r4
 801f1ea:	d002      	beq.n	801f1f2 <traceIF_uartPrint+0x16>
    {
      /* Is the trace for this component activated ? */
      if (traceIF_traceComponent[port] != 0U)
 801f1ec:	4906      	ldr	r1, [pc, #24]	; (801f208 <traceIF_uartPrint+0x2c>)
 801f1ee:	5c09      	ldrb	r1, [r1, r0]
 801f1f0:	b901      	cbnz	r1, 801f1f4 <traceIF_uartPrint+0x18>
        /* Print bytes of the trace  */
        traceIF_uartTransmit(ptr, len);
      }
    }
  }
}
 801f1f2:	bd10      	pop	{r4, pc}
        traceIF_uartTransmit(ptr, len);
 801f1f4:	4619      	mov	r1, r3
 801f1f6:	4610      	mov	r0, r2
 801f1f8:	f7ff ffb6 	bl	801f168 <traceIF_uartTransmit>
}
 801f1fc:	e7f9      	b.n	801f1f2 <traceIF_uartPrint+0x16>
 801f1fe:	bf00      	nop
 801f200:	2000022e 	.word	0x2000022e
 801f204:	2000021c 	.word	0x2000021c
 801f208:	20000220 	.word	0x20000220

0801f20c <traceIF_uartPrintForce>:
  * @param  pptr - pointer on the trace
  * @param  len - length of the trace
  * @retval -
  */
void traceIF_uartPrintForce(uint8_t port, uint8_t *pptr, uint16_t len)
{
 801f20c:	b508      	push	{r3, lr}
 801f20e:	4608      	mov	r0, r1

  uint8_t *ptr;
  ptr = pptr;

  /* Print bytes of the trace */
  traceIF_uartTransmit(ptr, len);
 801f210:	4611      	mov	r1, r2
 801f212:	f7ff ffa9 	bl	801f168 <traceIF_uartTransmit>
}
 801f216:	bd08      	pop	{r3, pc}

0801f218 <CMD_ComponentEnableDisable>:
{
 801f218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f21a:	4606      	mov	r6, r0
 801f21c:	460d      	mov	r5, r1
  if (strncmp((CRC_CHAR_t *)component,
 801f21e:	f7e0 ffe9 	bl	80001f4 <strlen>
 801f222:	4607      	mov	r7, r0
 801f224:	4602      	mov	r2, r0
 801f226:	491c      	ldr	r1, [pc, #112]	; (801f298 <CMD_ComponentEnableDisable+0x80>)
 801f228:	4630      	mov	r0, r6
 801f22a:	f006 fd9c 	bl	8025d66 <strncmp>
 801f22e:	b1a0      	cbz	r0, 801f25a <CMD_ComponentEnableDisable+0x42>
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f230:	2400      	movs	r4, #0
 801f232:	2c0d      	cmp	r4, #13
 801f234:	d813      	bhi.n	801f25e <CMD_ComponentEnableDisable+0x46>
      if (strncmp((CRC_CHAR_t *)component,
 801f236:	463a      	mov	r2, r7
 801f238:	4b18      	ldr	r3, [pc, #96]	; (801f29c <CMD_ComponentEnableDisable+0x84>)
 801f23a:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 801f23e:	4630      	mov	r0, r6
 801f240:	f006 fd91 	bl	8025d66 <strncmp>
 801f244:	b158      	cbz	r0, 801f25e <CMD_ComponentEnableDisable+0x46>
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f246:	3401      	adds	r4, #1
 801f248:	b2e4      	uxtb	r4, r4
 801f24a:	e7f2      	b.n	801f232 <CMD_ComponentEnableDisable+0x1a>
      traceIF_traceComponent[i] = enable;
 801f24c:	4a14      	ldr	r2, [pc, #80]	; (801f2a0 <CMD_ComponentEnableDisable+0x88>)
 801f24e:	54d5      	strb	r5, [r2, r3]
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f250:	3301      	adds	r3, #1
 801f252:	b2db      	uxtb	r3, r3
 801f254:	2b0d      	cmp	r3, #13
 801f256:	d9f9      	bls.n	801f24c <CMD_ComponentEnableDisable+0x34>
}
 801f258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f25a:	2300      	movs	r3, #0
 801f25c:	e7fa      	b.n	801f254 <CMD_ComponentEnableDisable+0x3c>
    if (i >= (uint8_t)DBG_CHAN_MAX_VALUE)
 801f25e:	2c0d      	cmp	r4, #13
 801f260:	d802      	bhi.n	801f268 <CMD_ComponentEnableDisable+0x50>
      traceIF_traceComponent[i] = enable;
 801f262:	4b0f      	ldr	r3, [pc, #60]	; (801f2a0 <CMD_ComponentEnableDisable+0x88>)
 801f264:	551d      	strb	r5, [r3, r4]
}
 801f266:	e7f7      	b.n	801f258 <CMD_ComponentEnableDisable+0x40>
      PRINT_FORCE("invalid canal name %s\r\n", component);
 801f268:	4c0e      	ldr	r4, [pc, #56]	; (801f2a4 <CMD_ComponentEnableDisable+0x8c>)
 801f26a:	4632      	mov	r2, r6
 801f26c:	490e      	ldr	r1, [pc, #56]	; (801f2a8 <CMD_ComponentEnableDisable+0x90>)
 801f26e:	4620      	mov	r0, r4
 801f270:	f006 fcfe 	bl	8025c70 <sprintf>
 801f274:	4620      	mov	r0, r4
 801f276:	f7ff ff4c 	bl	801f112 <crs_strlen>
 801f27a:	b283      	uxth	r3, r0
 801f27c:	4622      	mov	r2, r4
 801f27e:	2101      	movs	r1, #1
 801f280:	200a      	movs	r0, #10
 801f282:	f7ff ff89 	bl	801f198 <traceIF_itmPrint>
 801f286:	4620      	mov	r0, r4
 801f288:	f7ff ff43 	bl	801f112 <crs_strlen>
 801f28c:	b282      	uxth	r2, r0
 801f28e:	4621      	mov	r1, r4
 801f290:	200a      	movs	r0, #10
 801f292:	f7ff ffbb 	bl	801f20c <traceIF_uartPrintForce>
 801f296:	e7df      	b.n	801f258 <CMD_ComponentEnableDisable+0x40>
 801f298:	08034f0c 	.word	0x08034f0c
 801f29c:	08035240 	.word	0x08035240
 801f2a0:	20000220 	.word	0x20000220
 801f2a4:	200050dc 	.word	0x200050dc
 801f2a8:	08034f10 	.word	0x08034f10

0801f2ac <traceIF_cmd_Help>:
{
 801f2ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CMD_print_help(trace_cmd_label);
 801f2b0:	f8df 8210 	ldr.w	r8, [pc, #528]	; 801f4c4 <traceIF_cmd_Help+0x218>
 801f2b4:	4640      	mov	r0, r8
 801f2b6:	f002 ffcb 	bl	8022250 <CMD_print_help>
  PRINT_FORCE("%s help\r\n", trace_cmd_label);
 801f2ba:	4c79      	ldr	r4, [pc, #484]	; (801f4a0 <traceIF_cmd_Help+0x1f4>)
 801f2bc:	4642      	mov	r2, r8
 801f2be:	4979      	ldr	r1, [pc, #484]	; (801f4a4 <traceIF_cmd_Help+0x1f8>)
 801f2c0:	4620      	mov	r0, r4
 801f2c2:	f006 fcd5 	bl	8025c70 <sprintf>
 801f2c6:	4620      	mov	r0, r4
 801f2c8:	f7ff ff23 	bl	801f112 <crs_strlen>
 801f2cc:	b283      	uxth	r3, r0
 801f2ce:	4622      	mov	r2, r4
 801f2d0:	2101      	movs	r1, #1
 801f2d2:	200a      	movs	r0, #10
 801f2d4:	f7ff ff60 	bl	801f198 <traceIF_itmPrint>
 801f2d8:	4620      	mov	r0, r4
 801f2da:	f7ff ff1a 	bl	801f112 <crs_strlen>
 801f2de:	b282      	uxth	r2, r0
 801f2e0:	4621      	mov	r1, r4
 801f2e2:	200a      	movs	r0, #10
 801f2e4:	f7ff ff92 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s on (activate traces)\r\n", trace_cmd_label);
 801f2e8:	4642      	mov	r2, r8
 801f2ea:	496f      	ldr	r1, [pc, #444]	; (801f4a8 <traceIF_cmd_Help+0x1fc>)
 801f2ec:	4620      	mov	r0, r4
 801f2ee:	f006 fcbf 	bl	8025c70 <sprintf>
 801f2f2:	4620      	mov	r0, r4
 801f2f4:	f7ff ff0d 	bl	801f112 <crs_strlen>
 801f2f8:	b283      	uxth	r3, r0
 801f2fa:	4622      	mov	r2, r4
 801f2fc:	2101      	movs	r1, #1
 801f2fe:	200a      	movs	r0, #10
 801f300:	f7ff ff4a 	bl	801f198 <traceIF_itmPrint>
 801f304:	4620      	mov	r0, r4
 801f306:	f7ff ff04 	bl	801f112 <crs_strlen>
 801f30a:	b282      	uxth	r2, r0
 801f30c:	4621      	mov	r1, r4
 801f30e:	200a      	movs	r0, #10
 801f310:	f7ff ff7c 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s off (deactivate traces)\r\n", trace_cmd_label);
 801f314:	4642      	mov	r2, r8
 801f316:	4965      	ldr	r1, [pc, #404]	; (801f4ac <traceIF_cmd_Help+0x200>)
 801f318:	4620      	mov	r0, r4
 801f31a:	f006 fca9 	bl	8025c70 <sprintf>
 801f31e:	4620      	mov	r0, r4
 801f320:	f7ff fef7 	bl	801f112 <crs_strlen>
 801f324:	b283      	uxth	r3, r0
 801f326:	4622      	mov	r2, r4
 801f328:	2101      	movs	r1, #1
 801f32a:	200a      	movs	r0, #10
 801f32c:	f7ff ff34 	bl	801f198 <traceIF_itmPrint>
 801f330:	4620      	mov	r0, r4
 801f332:	f7ff feee 	bl	801f112 <crs_strlen>
 801f336:	b282      	uxth	r2, r0
 801f338:	4621      	mov	r1, r4
 801f33a:	200a      	movs	r0, #10
 801f33c:	f7ff ff66 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s enable  all|generic|main|atcmd|comlib|echoclt|http|ping|ipc|ppposif|cellular_service|nifman",
 801f340:	4642      	mov	r2, r8
 801f342:	495b      	ldr	r1, [pc, #364]	; (801f4b0 <traceIF_cmd_Help+0x204>)
 801f344:	4620      	mov	r0, r4
 801f346:	f006 fc93 	bl	8025c70 <sprintf>
 801f34a:	4620      	mov	r0, r4
 801f34c:	f7ff fee1 	bl	801f112 <crs_strlen>
 801f350:	b283      	uxth	r3, r0
 801f352:	4622      	mov	r2, r4
 801f354:	2101      	movs	r1, #1
 801f356:	200a      	movs	r0, #10
 801f358:	f7ff ff1e 	bl	801f198 <traceIF_itmPrint>
 801f35c:	4620      	mov	r0, r4
 801f35e:	f7ff fed8 	bl	801f112 <crs_strlen>
 801f362:	b282      	uxth	r2, r0
 801f364:	4621      	mov	r1, r4
 801f366:	200a      	movs	r0, #10
 801f368:	f7ff ff50 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("           |data_cache|utilities|error\r\n")
 801f36c:	4e51      	ldr	r6, [pc, #324]	; (801f4b4 <traceIF_cmd_Help+0x208>)
 801f36e:	46a4      	mov	ip, r4
 801f370:	4635      	mov	r5, r6
 801f372:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f374:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f378:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f37a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f37e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f382:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f386:	f88c 2000 	strb.w	r2, [ip]
 801f38a:	4620      	mov	r0, r4
 801f38c:	f7ff fec1 	bl	801f112 <crs_strlen>
 801f390:	b283      	uxth	r3, r0
 801f392:	4622      	mov	r2, r4
 801f394:	2101      	movs	r1, #1
 801f396:	200a      	movs	r0, #10
 801f398:	f7ff fefe 	bl	801f198 <traceIF_itmPrint>
 801f39c:	4620      	mov	r0, r4
 801f39e:	f7ff feb8 	bl	801f112 <crs_strlen>
 801f3a2:	b282      	uxth	r2, r0
 801f3a4:	4621      	mov	r1, r4
 801f3a6:	200a      	movs	r0, #10
 801f3a8:	f7ff ff30 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE(" -> enable traces of selected component\r\n")
 801f3ac:	46a4      	mov	ip, r4
 801f3ae:	4f42      	ldr	r7, [pc, #264]	; (801f4b8 <traceIF_cmd_Help+0x20c>)
 801f3b0:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801f3b2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f3b6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801f3b8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f3bc:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 801f3c0:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f3c4:	f8ac 2000 	strh.w	r2, [ip]
 801f3c8:	4620      	mov	r0, r4
 801f3ca:	f7ff fea2 	bl	801f112 <crs_strlen>
 801f3ce:	b283      	uxth	r3, r0
 801f3d0:	4622      	mov	r2, r4
 801f3d2:	2101      	movs	r1, #1
 801f3d4:	200a      	movs	r0, #10
 801f3d6:	f7ff fedf 	bl	801f198 <traceIF_itmPrint>
 801f3da:	4620      	mov	r0, r4
 801f3dc:	f7ff fe99 	bl	801f112 <crs_strlen>
 801f3e0:	b282      	uxth	r2, r0
 801f3e2:	4621      	mov	r1, r4
 801f3e4:	200a      	movs	r0, #10
 801f3e6:	f7ff ff11 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s disable all|generic|main|atcmd|comlib|echoclt|http|ping|ipc|ppposif|cellular_service|nifman",
 801f3ea:	4642      	mov	r2, r8
 801f3ec:	4933      	ldr	r1, [pc, #204]	; (801f4bc <traceIF_cmd_Help+0x210>)
 801f3ee:	4620      	mov	r0, r4
 801f3f0:	f006 fc3e 	bl	8025c70 <sprintf>
 801f3f4:	4620      	mov	r0, r4
 801f3f6:	f7ff fe8c 	bl	801f112 <crs_strlen>
 801f3fa:	b283      	uxth	r3, r0
 801f3fc:	4622      	mov	r2, r4
 801f3fe:	2101      	movs	r1, #1
 801f400:	200a      	movs	r0, #10
 801f402:	f7ff fec9 	bl	801f198 <traceIF_itmPrint>
 801f406:	4620      	mov	r0, r4
 801f408:	f7ff fe83 	bl	801f112 <crs_strlen>
 801f40c:	b282      	uxth	r2, r0
 801f40e:	4621      	mov	r1, r4
 801f410:	200a      	movs	r0, #10
 801f412:	f7ff fefb 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("           |data_cache|utilities|error\r\n")
 801f416:	46a4      	mov	ip, r4
 801f418:	46b6      	mov	lr, r6
 801f41a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801f41e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f422:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801f426:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f42a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f42e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f432:	f88c 2000 	strb.w	r2, [ip]
 801f436:	4620      	mov	r0, r4
 801f438:	f7ff fe6b 	bl	801f112 <crs_strlen>
 801f43c:	b283      	uxth	r3, r0
 801f43e:	4622      	mov	r2, r4
 801f440:	2101      	movs	r1, #1
 801f442:	200a      	movs	r0, #10
 801f444:	f7ff fea8 	bl	801f198 <traceIF_itmPrint>
 801f448:	4620      	mov	r0, r4
 801f44a:	f7ff fe62 	bl	801f112 <crs_strlen>
 801f44e:	b282      	uxth	r2, r0
 801f450:	4621      	mov	r1, r4
 801f452:	200a      	movs	r0, #10
 801f454:	f7ff feda 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE(" -> disable traces of selected component\r\n")
 801f458:	46a4      	mov	ip, r4
 801f45a:	4d19      	ldr	r5, [pc, #100]	; (801f4c0 <traceIF_cmd_Help+0x214>)
 801f45c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f45e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f462:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f464:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f468:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f46c:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f470:	f82c 2b02 	strh.w	r2, [ip], #2
 801f474:	0c12      	lsrs	r2, r2, #16
 801f476:	f88c 2000 	strb.w	r2, [ip]
 801f47a:	4620      	mov	r0, r4
 801f47c:	f7ff fe49 	bl	801f112 <crs_strlen>
 801f480:	b283      	uxth	r3, r0
 801f482:	4622      	mov	r2, r4
 801f484:	2101      	movs	r1, #1
 801f486:	200a      	movs	r0, #10
 801f488:	f7ff fe86 	bl	801f198 <traceIF_itmPrint>
 801f48c:	4620      	mov	r0, r4
 801f48e:	f7ff fe40 	bl	801f112 <crs_strlen>
 801f492:	b282      	uxth	r2, r0
 801f494:	4621      	mov	r1, r4
 801f496:	200a      	movs	r0, #10
 801f498:	f7ff feb8 	bl	801f20c <traceIF_uartPrintForce>
}
 801f49c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801f4a0:	200050dc 	.word	0x200050dc
 801f4a4:	08034f30 	.word	0x08034f30
 801f4a8:	08034f3c 	.word	0x08034f3c
 801f4ac:	08034f58 	.word	0x08034f58
 801f4b0:	08034f78 	.word	0x08034f78
 801f4b4:	08034fd8 	.word	0x08034fd8
 801f4b8:	08035004 	.word	0x08035004
 801f4bc:	08035030 	.word	0x08035030
 801f4c0:	08035090 	.word	0x08035090
 801f4c4:	08034f28 	.word	0x08034f28

0801f4c8 <traceIF_cmd>:
{
 801f4c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801f4ca:	b08d      	sub	sp, #52	; 0x34
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 801f4cc:	4997      	ldr	r1, [pc, #604]	; (801f72c <traceIF_cmd+0x264>)
 801f4ce:	f006 fc5d 	bl	8025d8c <strtok>
  if (cmd_p != NULL)
 801f4d2:	2800      	cmp	r0, #0
 801f4d4:	f000 8128 	beq.w	801f728 <traceIF_cmd+0x260>
 801f4d8:	4604      	mov	r4, r0
    if (strncmp((const CRC_CHAR_t *)cmd_p,
 801f4da:	f7e0 fe8b 	bl	80001f4 <strlen>
 801f4de:	4602      	mov	r2, r0
 801f4e0:	4993      	ldr	r1, [pc, #588]	; (801f730 <traceIF_cmd+0x268>)
 801f4e2:	4620      	mov	r0, r4
 801f4e4:	f006 fc3f 	bl	8025d66 <strncmp>
 801f4e8:	b110      	cbz	r0, 801f4f0 <traceIF_cmd+0x28>
  cmd_status = CMD_OK;
 801f4ea:	2000      	movs	r0, #0
}
 801f4ec:	b00d      	add	sp, #52	; 0x34
 801f4ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
      for (argc = 0U ; argc < 10U ; argc++)
 801f4f0:	2400      	movs	r4, #0
 801f4f2:	2c09      	cmp	r4, #9
 801f4f4:	d80b      	bhi.n	801f50e <traceIF_cmd+0x46>
        argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 801f4f6:	498d      	ldr	r1, [pc, #564]	; (801f72c <traceIF_cmd+0x264>)
 801f4f8:	2000      	movs	r0, #0
 801f4fa:	f006 fc47 	bl	8025d8c <strtok>
 801f4fe:	ab0c      	add	r3, sp, #48	; 0x30
 801f500:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 801f504:	f843 0c28 	str.w	r0, [r3, #-40]
        if (argv_p[argc] == NULL)
 801f508:	b108      	cbz	r0, 801f50e <traceIF_cmd+0x46>
      for (argc = 0U ; argc < 10U ; argc++)
 801f50a:	3401      	adds	r4, #1
 801f50c:	e7f1      	b.n	801f4f2 <traceIF_cmd+0x2a>
      if ((argc == 0U)
 801f50e:	b154      	cbz	r4, 801f526 <traceIF_cmd+0x5e>
          || (strncmp((CRC_CHAR_t *)argv_p[0],
 801f510:	9d02      	ldr	r5, [sp, #8]
 801f512:	4628      	mov	r0, r5
 801f514:	f7e0 fe6e 	bl	80001f4 <strlen>
 801f518:	4604      	mov	r4, r0
 801f51a:	4602      	mov	r2, r0
 801f51c:	4985      	ldr	r1, [pc, #532]	; (801f734 <traceIF_cmd+0x26c>)
 801f51e:	4628      	mov	r0, r5
 801f520:	f006 fc21 	bl	8025d66 <strncmp>
 801f524:	b918      	cbnz	r0, 801f52e <traceIF_cmd+0x66>
        traceIF_cmd_Help();
 801f526:	f7ff fec1 	bl	801f2ac <traceIF_cmd_Help>
  cmd_status = CMD_OK;
 801f52a:	2000      	movs	r0, #0
        traceIF_cmd_Help();
 801f52c:	e7de      	b.n	801f4ec <traceIF_cmd+0x24>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f52e:	4622      	mov	r2, r4
 801f530:	4981      	ldr	r1, [pc, #516]	; (801f738 <traceIF_cmd+0x270>)
 801f532:	4628      	mov	r0, r5
 801f534:	f006 fc17 	bl	8025d66 <strncmp>
 801f538:	2800      	cmp	r0, #0
 801f53a:	d03c      	beq.n	801f5b6 <traceIF_cmd+0xee>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f53c:	4622      	mov	r2, r4
 801f53e:	497f      	ldr	r1, [pc, #508]	; (801f73c <traceIF_cmd+0x274>)
 801f540:	4628      	mov	r0, r5
 801f542:	f006 fc10 	bl	8025d66 <strncmp>
 801f546:	2800      	cmp	r0, #0
 801f548:	d054      	beq.n	801f5f4 <traceIF_cmd+0x12c>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f54a:	4622      	mov	r2, r4
 801f54c:	497c      	ldr	r1, [pc, #496]	; (801f740 <traceIF_cmd+0x278>)
 801f54e:	4628      	mov	r0, r5
 801f550:	f006 fc09 	bl	8025d66 <strncmp>
 801f554:	2800      	cmp	r0, #0
 801f556:	d06d      	beq.n	801f634 <traceIF_cmd+0x16c>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f558:	4622      	mov	r2, r4
 801f55a:	497a      	ldr	r1, [pc, #488]	; (801f744 <traceIF_cmd+0x27c>)
 801f55c:	4628      	mov	r0, r5
 801f55e:	f006 fc02 	bl	8025d66 <strncmp>
 801f562:	2800      	cmp	r0, #0
 801f564:	f000 8089 	beq.w	801f67a <traceIF_cmd+0x1b2>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f568:	4622      	mov	r2, r4
 801f56a:	4977      	ldr	r1, [pc, #476]	; (801f748 <traceIF_cmd+0x280>)
 801f56c:	4628      	mov	r0, r5
 801f56e:	f006 fbfa 	bl	8025d66 <strncmp>
 801f572:	2800      	cmp	r0, #0
 801f574:	f040 80be 	bne.w	801f6f4 <traceIF_cmd+0x22c>
        traceIF_traceEnable = false;
 801f578:	2400      	movs	r4, #0
 801f57a:	4b74      	ldr	r3, [pc, #464]	; (801f74c <traceIF_cmd+0x284>)
 801f57c:	701c      	strb	r4, [r3, #0]
        PRINT_FORCE("\n\r <<< TRACE INACTIVE >>>\n\r")
 801f57e:	4f74      	ldr	r7, [pc, #464]	; (801f750 <traceIF_cmd+0x288>)
 801f580:	463d      	mov	r5, r7
 801f582:	4e74      	ldr	r6, [pc, #464]	; (801f754 <traceIF_cmd+0x28c>)
 801f584:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801f586:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801f588:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 801f58c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 801f590:	4638      	mov	r0, r7
 801f592:	f7ff fdbe 	bl	801f112 <crs_strlen>
 801f596:	b283      	uxth	r3, r0
 801f598:	463a      	mov	r2, r7
 801f59a:	2101      	movs	r1, #1
 801f59c:	200a      	movs	r0, #10
 801f59e:	f7ff fdfb 	bl	801f198 <traceIF_itmPrint>
 801f5a2:	4638      	mov	r0, r7
 801f5a4:	f7ff fdb5 	bl	801f112 <crs_strlen>
 801f5a8:	b282      	uxth	r2, r0
 801f5aa:	4639      	mov	r1, r7
 801f5ac:	200a      	movs	r0, #10
 801f5ae:	f7ff fe2d 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 801f5b2:	4620      	mov	r0, r4
 801f5b4:	e79a      	b.n	801f4ec <traceIF_cmd+0x24>
        traceIF_traceEnable = true;
 801f5b6:	2701      	movs	r7, #1
 801f5b8:	4b64      	ldr	r3, [pc, #400]	; (801f74c <traceIF_cmd+0x284>)
 801f5ba:	701f      	strb	r7, [r3, #0]
        PRINT_FORCE("\n\r <<< TRACE ACTIVE >>>\n\r")
 801f5bc:	4e64      	ldr	r6, [pc, #400]	; (801f750 <traceIF_cmd+0x288>)
 801f5be:	4634      	mov	r4, r6
 801f5c0:	4d65      	ldr	r5, [pc, #404]	; (801f758 <traceIF_cmd+0x290>)
 801f5c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f5c4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f5c6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f5ca:	c403      	stmia	r4!, {r0, r1}
 801f5cc:	8022      	strh	r2, [r4, #0]
 801f5ce:	4630      	mov	r0, r6
 801f5d0:	f7ff fd9f 	bl	801f112 <crs_strlen>
 801f5d4:	b283      	uxth	r3, r0
 801f5d6:	4632      	mov	r2, r6
 801f5d8:	4639      	mov	r1, r7
 801f5da:	200a      	movs	r0, #10
 801f5dc:	f7ff fddc 	bl	801f198 <traceIF_itmPrint>
 801f5e0:	4630      	mov	r0, r6
 801f5e2:	f7ff fd96 	bl	801f112 <crs_strlen>
 801f5e6:	b282      	uxth	r2, r0
 801f5e8:	4631      	mov	r1, r6
 801f5ea:	200a      	movs	r0, #10
 801f5ec:	f7ff fe0e 	bl	801f20c <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 801f5f0:	2000      	movs	r0, #0
 801f5f2:	e77b      	b.n	801f4ec <traceIF_cmd+0x24>
        PRINT_FORCE("\n\r <<< TRACE ENABLE >>>\n\r")
 801f5f4:	4e56      	ldr	r6, [pc, #344]	; (801f750 <traceIF_cmd+0x288>)
 801f5f6:	4634      	mov	r4, r6
 801f5f8:	4d58      	ldr	r5, [pc, #352]	; (801f75c <traceIF_cmd+0x294>)
 801f5fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f5fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f5fe:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f602:	c403      	stmia	r4!, {r0, r1}
 801f604:	8022      	strh	r2, [r4, #0]
 801f606:	4630      	mov	r0, r6
 801f608:	f7ff fd83 	bl	801f112 <crs_strlen>
 801f60c:	b283      	uxth	r3, r0
 801f60e:	4632      	mov	r2, r6
 801f610:	2101      	movs	r1, #1
 801f612:	200a      	movs	r0, #10
 801f614:	f7ff fdc0 	bl	801f198 <traceIF_itmPrint>
 801f618:	4630      	mov	r0, r6
 801f61a:	f7ff fd7a 	bl	801f112 <crs_strlen>
 801f61e:	b282      	uxth	r2, r0
 801f620:	4631      	mov	r1, r6
 801f622:	200a      	movs	r0, #10
 801f624:	f7ff fdf2 	bl	801f20c <traceIF_uartPrintForce>
        CMD_ComponentEnableDisable(argv_p[1], 1);
 801f628:	2101      	movs	r1, #1
 801f62a:	9803      	ldr	r0, [sp, #12]
 801f62c:	f7ff fdf4 	bl	801f218 <CMD_ComponentEnableDisable>
  cmd_status = CMD_OK;
 801f630:	2000      	movs	r0, #0
 801f632:	e75b      	b.n	801f4ec <traceIF_cmd+0x24>
        PRINT_FORCE("\n\r <<< TRACE DISABLE >>>\n\r")
 801f634:	4e46      	ldr	r6, [pc, #280]	; (801f750 <traceIF_cmd+0x288>)
 801f636:	4634      	mov	r4, r6
 801f638:	4d49      	ldr	r5, [pc, #292]	; (801f760 <traceIF_cmd+0x298>)
 801f63a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f63c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f63e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f642:	c403      	stmia	r4!, {r0, r1}
 801f644:	f824 2b02 	strh.w	r2, [r4], #2
 801f648:	0c12      	lsrs	r2, r2, #16
 801f64a:	7022      	strb	r2, [r4, #0]
 801f64c:	4630      	mov	r0, r6
 801f64e:	f7ff fd60 	bl	801f112 <crs_strlen>
 801f652:	b283      	uxth	r3, r0
 801f654:	4632      	mov	r2, r6
 801f656:	2101      	movs	r1, #1
 801f658:	200a      	movs	r0, #10
 801f65a:	f7ff fd9d 	bl	801f198 <traceIF_itmPrint>
 801f65e:	4630      	mov	r0, r6
 801f660:	f7ff fd57 	bl	801f112 <crs_strlen>
 801f664:	b282      	uxth	r2, r0
 801f666:	4631      	mov	r1, r6
 801f668:	200a      	movs	r0, #10
 801f66a:	f7ff fdcf 	bl	801f20c <traceIF_uartPrintForce>
        CMD_ComponentEnableDisable(argv_p[1], 0);
 801f66e:	2100      	movs	r1, #0
 801f670:	9803      	ldr	r0, [sp, #12]
 801f672:	f7ff fdd1 	bl	801f218 <CMD_ComponentEnableDisable>
  cmd_status = CMD_OK;
 801f676:	2000      	movs	r0, #0
 801f678:	e738      	b.n	801f4ec <traceIF_cmd+0x24>
        PRINT_FORCE("\n\r <<< TRACE LEVEL >>>\n\r")
 801f67a:	4e35      	ldr	r6, [pc, #212]	; (801f750 <traceIF_cmd+0x288>)
 801f67c:	4634      	mov	r4, r6
 801f67e:	4d39      	ldr	r5, [pc, #228]	; (801f764 <traceIF_cmd+0x29c>)
 801f680:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f682:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f684:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f688:	c403      	stmia	r4!, {r0, r1}
 801f68a:	7022      	strb	r2, [r4, #0]
 801f68c:	4630      	mov	r0, r6
 801f68e:	f7ff fd40 	bl	801f112 <crs_strlen>
 801f692:	b283      	uxth	r3, r0
 801f694:	4632      	mov	r2, r6
 801f696:	2101      	movs	r1, #1
 801f698:	200a      	movs	r0, #10
 801f69a:	f7ff fd7d 	bl	801f198 <traceIF_itmPrint>
 801f69e:	4630      	mov	r0, r6
 801f6a0:	f7ff fd37 	bl	801f112 <crs_strlen>
 801f6a4:	b282      	uxth	r2, r0
 801f6a6:	4631      	mov	r1, r6
 801f6a8:	200a      	movs	r0, #10
 801f6aa:	f7ff fdaf 	bl	801f20c <traceIF_uartPrintForce>
        ret = CMD_GetValue(argv_p[1], (uint32_t *)&level);
 801f6ae:	9c03      	ldr	r4, [sp, #12]
 801f6b0:	a901      	add	r1, sp, #4
 801f6b2:	4620      	mov	r0, r4
 801f6b4:	f002 fd48 	bl	8022148 <CMD_GetValue>
        if (ret != 0U)
 801f6b8:	b920      	cbnz	r0, 801f6c4 <traceIF_cmd+0x1fc>
          traceIF_Level = level;
 801f6ba:	4b2b      	ldr	r3, [pc, #172]	; (801f768 <traceIF_cmd+0x2a0>)
 801f6bc:	9a01      	ldr	r2, [sp, #4]
 801f6be:	601a      	str	r2, [r3, #0]
  cmd_status = CMD_OK;
 801f6c0:	2000      	movs	r0, #0
 801f6c2:	e713      	b.n	801f4ec <traceIF_cmd+0x24>
          PRINT_FORCE("invalid level %s\r\n", argv_p[1]);
 801f6c4:	4622      	mov	r2, r4
 801f6c6:	4929      	ldr	r1, [pc, #164]	; (801f76c <traceIF_cmd+0x2a4>)
 801f6c8:	4630      	mov	r0, r6
 801f6ca:	f006 fad1 	bl	8025c70 <sprintf>
 801f6ce:	4630      	mov	r0, r6
 801f6d0:	f7ff fd1f 	bl	801f112 <crs_strlen>
 801f6d4:	b283      	uxth	r3, r0
 801f6d6:	4632      	mov	r2, r6
 801f6d8:	2101      	movs	r1, #1
 801f6da:	200a      	movs	r0, #10
 801f6dc:	f7ff fd5c 	bl	801f198 <traceIF_itmPrint>
 801f6e0:	4630      	mov	r0, r6
 801f6e2:	f7ff fd16 	bl	801f112 <crs_strlen>
 801f6e6:	b282      	uxth	r2, r0
 801f6e8:	4631      	mov	r1, r6
 801f6ea:	200a      	movs	r0, #10
 801f6ec:	f7ff fd8e 	bl	801f20c <traceIF_uartPrintForce>
          cmd_status = CMD_SYNTAX_ERROR;
 801f6f0:	2001      	movs	r0, #1
 801f6f2:	e6fb      	b.n	801f4ec <traceIF_cmd+0x24>
        PRINT_FORCE("\n\rTRACE usage\n\r")
 801f6f4:	4c16      	ldr	r4, [pc, #88]	; (801f750 <traceIF_cmd+0x288>)
 801f6f6:	4b1e      	ldr	r3, [pc, #120]	; (801f770 <traceIF_cmd+0x2a8>)
 801f6f8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801f6fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801f6fe:	4620      	mov	r0, r4
 801f700:	f7ff fd07 	bl	801f112 <crs_strlen>
 801f704:	b283      	uxth	r3, r0
 801f706:	4622      	mov	r2, r4
 801f708:	2101      	movs	r1, #1
 801f70a:	200a      	movs	r0, #10
 801f70c:	f7ff fd44 	bl	801f198 <traceIF_itmPrint>
 801f710:	4620      	mov	r0, r4
 801f712:	f7ff fcfe 	bl	801f112 <crs_strlen>
 801f716:	b282      	uxth	r2, r0
 801f718:	4621      	mov	r1, r4
 801f71a:	200a      	movs	r0, #10
 801f71c:	f7ff fd76 	bl	801f20c <traceIF_uartPrintForce>
        traceIF_cmd_Help();
 801f720:	f7ff fdc4 	bl	801f2ac <traceIF_cmd_Help>
  cmd_status = CMD_OK;
 801f724:	2000      	movs	r0, #0
 801f726:	e6e1      	b.n	801f4ec <traceIF_cmd+0x24>
 801f728:	2000      	movs	r0, #0
 801f72a:	e6df      	b.n	801f4ec <traceIF_cmd+0x24>
 801f72c:	08032b44 	.word	0x08032b44
 801f730:	08034f28 	.word	0x08034f28
 801f734:	08032b48 	.word	0x08032b48
 801f738:	080332c8 	.word	0x080332c8
 801f73c:	080350d8 	.word	0x080350d8
 801f740:	080350fc 	.word	0x080350fc
 801f744:	08035120 	.word	0x08035120
 801f748:	08032d88 	.word	0x08032d88
 801f74c:	2000022e 	.word	0x2000022e
 801f750:	200050dc 	.word	0x200050dc
 801f754:	08035158 	.word	0x08035158
 801f758:	080350bc 	.word	0x080350bc
 801f75c:	080350e0 	.word	0x080350e0
 801f760:	08035104 	.word	0x08035104
 801f764:	08035128 	.word	0x08035128
 801f768:	2000021c 	.word	0x2000021c
 801f76c:	08035144 	.word	0x08035144
 801f770:	08035174 	.word	0x08035174

0801f774 <traceIF_BufCharPrint>:
  * @param  buf   - pointer on the trace
  * @param  size  - size of the trace
  * @retval -
  */
void traceIF_BufCharPrint(dbg_channels_t chan, dbg_levels_t level, const CRC_CHAR_t *buf, uint16_t size)
{
 801f774:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801f778:	4606      	mov	r6, r0
 801f77a:	460f      	mov	r7, r1
 801f77c:	4691      	mov	r9, r2
 801f77e:	4698      	mov	r8, r3
  for (uint16_t cpt = 0U; cpt < size; cpt++)
 801f780:	2400      	movs	r4, #0
 801f782:	e01f      	b.n	801f7c4 <traceIF_BufCharPrint+0x50>
  {
    if (buf[cpt] == (CRC_CHAR_t)0)
    {
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<NULL CHAR>")
 801f784:	f8df e1b8 	ldr.w	lr, [pc, #440]	; 801f940 <traceIF_BufCharPrint+0x1cc>
 801f788:	ea4f 2c06 	mov.w	ip, r6, lsl #8
 801f78c:	eb0e 2506 	add.w	r5, lr, r6, lsl #8
 801f790:	4b6a      	ldr	r3, [pc, #424]	; (801f93c <traceIF_BufCharPrint+0x1c8>)
 801f792:	cb07      	ldmia	r3!, {r0, r1, r2}
 801f794:	f84e 000c 	str.w	r0, [lr, ip]
 801f798:	6069      	str	r1, [r5, #4]
 801f79a:	60aa      	str	r2, [r5, #8]
 801f79c:	4628      	mov	r0, r5
 801f79e:	f7ff fcb8 	bl	801f112 <crs_strlen>
 801f7a2:	b283      	uxth	r3, r0
 801f7a4:	462a      	mov	r2, r5
 801f7a6:	4639      	mov	r1, r7
 801f7a8:	4630      	mov	r0, r6
 801f7aa:	f7ff fcf5 	bl	801f198 <traceIF_itmPrint>
 801f7ae:	4628      	mov	r0, r5
 801f7b0:	f7ff fcaf 	bl	801f112 <crs_strlen>
 801f7b4:	b283      	uxth	r3, r0
 801f7b6:	462a      	mov	r2, r5
 801f7b8:	4639      	mov	r1, r7
 801f7ba:	4630      	mov	r0, r6
 801f7bc:	f7ff fd0e 	bl	801f1dc <traceIF_uartPrint>
  for (uint16_t cpt = 0U; cpt < size; cpt++)
 801f7c0:	3401      	adds	r4, #1
 801f7c2:	b2a4      	uxth	r4, r4
 801f7c4:	4544      	cmp	r4, r8
 801f7c6:	f080 809c 	bcs.w	801f902 <traceIF_BufCharPrint+0x18e>
    if (buf[cpt] == (CRC_CHAR_t)0)
 801f7ca:	f819 2004 	ldrb.w	r2, [r9, r4]
 801f7ce:	2a00      	cmp	r2, #0
 801f7d0:	d0d8      	beq.n	801f784 <traceIF_BufCharPrint+0x10>
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if (buf[cpt] == '\r')
 801f7d2:	2a0d      	cmp	r2, #13
 801f7d4:	d022      	beq.n	801f81c <traceIF_BufCharPrint+0xa8>
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<CR>")
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if (buf[cpt] == '\n')
 801f7d6:	2a0a      	cmp	r2, #10
 801f7d8:	d03c      	beq.n	801f854 <traceIF_BufCharPrint+0xe0>
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<LF>")
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if (buf[cpt] == (CRC_CHAR_t)0x1A)
 801f7da:	2a1a      	cmp	r2, #26
 801f7dc:	d056      	beq.n	801f88c <traceIF_BufCharPrint+0x118>
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<CTRL-Z>")
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if ((buf[cpt] >= (CRC_CHAR_t)0x20) && (buf[cpt] <= (CRC_CHAR_t)0x7E))
 801f7de:	f1a2 0320 	sub.w	r3, r2, #32
 801f7e2:	b2db      	uxtb	r3, r3
 801f7e4:	2b5e      	cmp	r3, #94	; 0x5e
 801f7e6:	d870      	bhi.n	801f8ca <traceIF_BufCharPrint+0x156>
    {
      /* printable CRC_CHAR_t */
      TRACE_PRINT(chan, level, "%c", buf[cpt])
 801f7e8:	4d55      	ldr	r5, [pc, #340]	; (801f940 <traceIF_BufCharPrint+0x1cc>)
 801f7ea:	eb05 2506 	add.w	r5, r5, r6, lsl #8
 801f7ee:	4955      	ldr	r1, [pc, #340]	; (801f944 <traceIF_BufCharPrint+0x1d0>)
 801f7f0:	4628      	mov	r0, r5
 801f7f2:	f006 fa3d 	bl	8025c70 <sprintf>
 801f7f6:	4628      	mov	r0, r5
 801f7f8:	f7ff fc8b 	bl	801f112 <crs_strlen>
 801f7fc:	b283      	uxth	r3, r0
 801f7fe:	462a      	mov	r2, r5
 801f800:	4639      	mov	r1, r7
 801f802:	4630      	mov	r0, r6
 801f804:	f7ff fcc8 	bl	801f198 <traceIF_itmPrint>
 801f808:	4628      	mov	r0, r5
 801f80a:	f7ff fc82 	bl	801f112 <crs_strlen>
 801f80e:	b283      	uxth	r3, r0
 801f810:	462a      	mov	r2, r5
 801f812:	4639      	mov	r1, r7
 801f814:	4630      	mov	r0, r6
 801f816:	f7ff fce1 	bl	801f1dc <traceIF_uartPrint>
 801f81a:	e7d1      	b.n	801f7c0 <traceIF_BufCharPrint+0x4c>
      TRACE_PRINT(chan, level, "<CR>")
 801f81c:	4948      	ldr	r1, [pc, #288]	; (801f940 <traceIF_BufCharPrint+0x1cc>)
 801f81e:	0233      	lsls	r3, r6, #8
 801f820:	eb01 2506 	add.w	r5, r1, r6, lsl #8
 801f824:	4a48      	ldr	r2, [pc, #288]	; (801f948 <traceIF_BufCharPrint+0x1d4>)
 801f826:	6810      	ldr	r0, [r2, #0]
 801f828:	50c8      	str	r0, [r1, r3]
 801f82a:	7913      	ldrb	r3, [r2, #4]
 801f82c:	712b      	strb	r3, [r5, #4]
 801f82e:	4628      	mov	r0, r5
 801f830:	f7ff fc6f 	bl	801f112 <crs_strlen>
 801f834:	b283      	uxth	r3, r0
 801f836:	462a      	mov	r2, r5
 801f838:	4639      	mov	r1, r7
 801f83a:	4630      	mov	r0, r6
 801f83c:	f7ff fcac 	bl	801f198 <traceIF_itmPrint>
 801f840:	4628      	mov	r0, r5
 801f842:	f7ff fc66 	bl	801f112 <crs_strlen>
 801f846:	b283      	uxth	r3, r0
 801f848:	462a      	mov	r2, r5
 801f84a:	4639      	mov	r1, r7
 801f84c:	4630      	mov	r0, r6
 801f84e:	f7ff fcc5 	bl	801f1dc <traceIF_uartPrint>
 801f852:	e7b5      	b.n	801f7c0 <traceIF_BufCharPrint+0x4c>
      TRACE_PRINT(chan, level, "<LF>")
 801f854:	493a      	ldr	r1, [pc, #232]	; (801f940 <traceIF_BufCharPrint+0x1cc>)
 801f856:	0233      	lsls	r3, r6, #8
 801f858:	eb01 2506 	add.w	r5, r1, r6, lsl #8
 801f85c:	4a3b      	ldr	r2, [pc, #236]	; (801f94c <traceIF_BufCharPrint+0x1d8>)
 801f85e:	6810      	ldr	r0, [r2, #0]
 801f860:	50c8      	str	r0, [r1, r3]
 801f862:	7913      	ldrb	r3, [r2, #4]
 801f864:	712b      	strb	r3, [r5, #4]
 801f866:	4628      	mov	r0, r5
 801f868:	f7ff fc53 	bl	801f112 <crs_strlen>
 801f86c:	b283      	uxth	r3, r0
 801f86e:	462a      	mov	r2, r5
 801f870:	4639      	mov	r1, r7
 801f872:	4630      	mov	r0, r6
 801f874:	f7ff fc90 	bl	801f198 <traceIF_itmPrint>
 801f878:	4628      	mov	r0, r5
 801f87a:	f7ff fc4a 	bl	801f112 <crs_strlen>
 801f87e:	b283      	uxth	r3, r0
 801f880:	462a      	mov	r2, r5
 801f882:	4639      	mov	r1, r7
 801f884:	4630      	mov	r0, r6
 801f886:	f7ff fca9 	bl	801f1dc <traceIF_uartPrint>
 801f88a:	e799      	b.n	801f7c0 <traceIF_BufCharPrint+0x4c>
      TRACE_PRINT(chan, level, "<CTRL-Z>")
 801f88c:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 801f940 <traceIF_BufCharPrint+0x1cc>
 801f890:	0232      	lsls	r2, r6, #8
 801f892:	eb0c 2506 	add.w	r5, ip, r6, lsl #8
 801f896:	4b2e      	ldr	r3, [pc, #184]	; (801f950 <traceIF_BufCharPrint+0x1dc>)
 801f898:	cb03      	ldmia	r3!, {r0, r1}
 801f89a:	f84c 0002 	str.w	r0, [ip, r2]
 801f89e:	6069      	str	r1, [r5, #4]
 801f8a0:	781b      	ldrb	r3, [r3, #0]
 801f8a2:	722b      	strb	r3, [r5, #8]
 801f8a4:	4628      	mov	r0, r5
 801f8a6:	f7ff fc34 	bl	801f112 <crs_strlen>
 801f8aa:	b283      	uxth	r3, r0
 801f8ac:	462a      	mov	r2, r5
 801f8ae:	4639      	mov	r1, r7
 801f8b0:	4630      	mov	r0, r6
 801f8b2:	f7ff fc71 	bl	801f198 <traceIF_itmPrint>
 801f8b6:	4628      	mov	r0, r5
 801f8b8:	f7ff fc2b 	bl	801f112 <crs_strlen>
 801f8bc:	b283      	uxth	r3, r0
 801f8be:	462a      	mov	r2, r5
 801f8c0:	4639      	mov	r1, r7
 801f8c2:	4630      	mov	r0, r6
 801f8c4:	f7ff fc8a 	bl	801f1dc <traceIF_uartPrint>
 801f8c8:	e77a      	b.n	801f7c0 <traceIF_BufCharPrint+0x4c>
    else
    {
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      /* Special Character - not printable */
      TRACE_PRINT(chan, level, "<SC>")
 801f8ca:	491d      	ldr	r1, [pc, #116]	; (801f940 <traceIF_BufCharPrint+0x1cc>)
 801f8cc:	0233      	lsls	r3, r6, #8
 801f8ce:	eb01 2506 	add.w	r5, r1, r6, lsl #8
 801f8d2:	4a20      	ldr	r2, [pc, #128]	; (801f954 <traceIF_BufCharPrint+0x1e0>)
 801f8d4:	6810      	ldr	r0, [r2, #0]
 801f8d6:	50c8      	str	r0, [r1, r3]
 801f8d8:	7913      	ldrb	r3, [r2, #4]
 801f8da:	712b      	strb	r3, [r5, #4]
 801f8dc:	4628      	mov	r0, r5
 801f8de:	f7ff fc18 	bl	801f112 <crs_strlen>
 801f8e2:	b283      	uxth	r3, r0
 801f8e4:	462a      	mov	r2, r5
 801f8e6:	4639      	mov	r1, r7
 801f8e8:	4630      	mov	r0, r6
 801f8ea:	f7ff fc55 	bl	801f198 <traceIF_itmPrint>
 801f8ee:	4628      	mov	r0, r5
 801f8f0:	f7ff fc0f 	bl	801f112 <crs_strlen>
 801f8f4:	b283      	uxth	r3, r0
 801f8f6:	462a      	mov	r2, r5
 801f8f8:	4639      	mov	r1, r7
 801f8fa:	4630      	mov	r0, r6
 801f8fc:	f7ff fc6e 	bl	801f1dc <traceIF_uartPrint>
 801f900:	e75e      	b.n	801f7c0 <traceIF_BufCharPrint+0x4c>
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
  }

  /* Force to go to next line to prepare next trace */
  TRACE_PRINT(chan, level, "\n\r")
 801f902:	4b0f      	ldr	r3, [pc, #60]	; (801f940 <traceIF_BufCharPrint+0x1cc>)
 801f904:	0231      	lsls	r1, r6, #8
 801f906:	eb03 2406 	add.w	r4, r3, r6, lsl #8
 801f90a:	4a13      	ldr	r2, [pc, #76]	; (801f958 <traceIF_BufCharPrint+0x1e4>)
 801f90c:	8810      	ldrh	r0, [r2, #0]
 801f90e:	7892      	ldrb	r2, [r2, #2]
 801f910:	5258      	strh	r0, [r3, r1]
 801f912:	70a2      	strb	r2, [r4, #2]
 801f914:	4620      	mov	r0, r4
 801f916:	f7ff fbfc 	bl	801f112 <crs_strlen>
 801f91a:	b283      	uxth	r3, r0
 801f91c:	4622      	mov	r2, r4
 801f91e:	4639      	mov	r1, r7
 801f920:	4630      	mov	r0, r6
 801f922:	f7ff fc39 	bl	801f198 <traceIF_itmPrint>
 801f926:	4620      	mov	r0, r4
 801f928:	f7ff fbf3 	bl	801f112 <crs_strlen>
 801f92c:	b283      	uxth	r3, r0
 801f92e:	4622      	mov	r2, r4
 801f930:	4639      	mov	r1, r7
 801f932:	4630      	mov	r0, r6
 801f934:	f7ff fc52 	bl	801f1dc <traceIF_uartPrint>
}
 801f938:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801f93c:	08035184 	.word	0x08035184
 801f940:	200046dc 	.word	0x200046dc
 801f944:	080351ac 	.word	0x080351ac
 801f948:	08035190 	.word	0x08035190
 801f94c:	08035198 	.word	0x08035198
 801f950:	080351a0 	.word	0x080351a0
 801f954:	080351b0 	.word	0x080351b0
 801f958:	0802deec 	.word	0x0802deec

0801f95c <traceIF_BufHexPrint>:
  * @param  buf   - pointer on the trace
  * @param  size  - size of the trace
  * @retval -
  */
void traceIF_BufHexPrint(dbg_channels_t chan, dbg_levels_t level, const CRC_CHAR_t *buf, uint16_t size)
{
 801f95c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f960:	4606      	mov	r6, r0
 801f962:	460f      	mov	r7, r1
 801f964:	4692      	mov	sl, r2
 801f966:	4699      	mov	r9, r3
  for (uint16_t cpt = 0U; cpt < size; cpt++)
 801f968:	2400      	movs	r4, #0
 801f96a:	e001      	b.n	801f970 <traceIF_BufHexPrint+0x14>
 801f96c:	3401      	adds	r4, #1
 801f96e:	b2a4      	uxth	r4, r4
 801f970:	454c      	cmp	r4, r9
 801f972:	d23c      	bcs.n	801f9ee <traceIF_BufHexPrint+0x92>
  {
    /* Print bytes one per one */
    TRACE_PRINT(chan, level, "0x%02x ", (uint8_t) buf[cpt])
 801f974:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 801fa30 <traceIF_BufHexPrint+0xd4>
 801f978:	ea4f 2b06 	mov.w	fp, r6, lsl #8
 801f97c:	eb08 2506 	add.w	r5, r8, r6, lsl #8
 801f980:	f81a 2004 	ldrb.w	r2, [sl, r4]
 801f984:	4928      	ldr	r1, [pc, #160]	; (801fa28 <traceIF_BufHexPrint+0xcc>)
 801f986:	4628      	mov	r0, r5
 801f988:	f006 f972 	bl	8025c70 <sprintf>
 801f98c:	4628      	mov	r0, r5
 801f98e:	f7ff fbc0 	bl	801f112 <crs_strlen>
 801f992:	b283      	uxth	r3, r0
 801f994:	462a      	mov	r2, r5
 801f996:	4639      	mov	r1, r7
 801f998:	4630      	mov	r0, r6
 801f99a:	f7ff fbfd 	bl	801f198 <traceIF_itmPrint>
 801f99e:	4628      	mov	r0, r5
 801f9a0:	f7ff fbb7 	bl	801f112 <crs_strlen>
 801f9a4:	b283      	uxth	r3, r0
 801f9a6:	462a      	mov	r2, r5
 801f9a8:	4639      	mov	r1, r7
 801f9aa:	4630      	mov	r0, r6
 801f9ac:	f7ff fc16 	bl	801f1dc <traceIF_uartPrint>

    /* Print only 16 bytes on same line */
    if ((cpt != 0U) && (((cpt + 1U) % 16U) == 0U))
 801f9b0:	2c00      	cmp	r4, #0
 801f9b2:	d0db      	beq.n	801f96c <traceIF_BufHexPrint+0x10>
 801f9b4:	1c63      	adds	r3, r4, #1
 801f9b6:	f013 0f0f 	tst.w	r3, #15
 801f9ba:	d1d7      	bne.n	801f96c <traceIF_BufHexPrint+0x10>
    {
      /* Force to go to next line to prepare next trace */
      TRACE_PRINT(chan, level, "\n\r")
 801f9bc:	4b1b      	ldr	r3, [pc, #108]	; (801fa2c <traceIF_BufHexPrint+0xd0>)
 801f9be:	881a      	ldrh	r2, [r3, #0]
 801f9c0:	789b      	ldrb	r3, [r3, #2]
 801f9c2:	f828 200b 	strh.w	r2, [r8, fp]
 801f9c6:	70ab      	strb	r3, [r5, #2]
 801f9c8:	4628      	mov	r0, r5
 801f9ca:	f7ff fba2 	bl	801f112 <crs_strlen>
 801f9ce:	b283      	uxth	r3, r0
 801f9d0:	462a      	mov	r2, r5
 801f9d2:	4639      	mov	r1, r7
 801f9d4:	4630      	mov	r0, r6
 801f9d6:	f7ff fbdf 	bl	801f198 <traceIF_itmPrint>
 801f9da:	4628      	mov	r0, r5
 801f9dc:	f7ff fb99 	bl	801f112 <crs_strlen>
 801f9e0:	b283      	uxth	r3, r0
 801f9e2:	462a      	mov	r2, r5
 801f9e4:	4639      	mov	r1, r7
 801f9e6:	4630      	mov	r0, r6
 801f9e8:	f7ff fbf8 	bl	801f1dc <traceIF_uartPrint>
 801f9ec:	e7be      	b.n	801f96c <traceIF_BufHexPrint+0x10>
    }
  }

  /* Force to go to next line to prepare next trace */
  TRACE_PRINT(chan, level, "\n\r")
 801f9ee:	4b10      	ldr	r3, [pc, #64]	; (801fa30 <traceIF_BufHexPrint+0xd4>)
 801f9f0:	0231      	lsls	r1, r6, #8
 801f9f2:	eb03 2406 	add.w	r4, r3, r6, lsl #8
 801f9f6:	4a0d      	ldr	r2, [pc, #52]	; (801fa2c <traceIF_BufHexPrint+0xd0>)
 801f9f8:	8810      	ldrh	r0, [r2, #0]
 801f9fa:	7892      	ldrb	r2, [r2, #2]
 801f9fc:	5258      	strh	r0, [r3, r1]
 801f9fe:	70a2      	strb	r2, [r4, #2]
 801fa00:	4620      	mov	r0, r4
 801fa02:	f7ff fb86 	bl	801f112 <crs_strlen>
 801fa06:	b283      	uxth	r3, r0
 801fa08:	4622      	mov	r2, r4
 801fa0a:	4639      	mov	r1, r7
 801fa0c:	4630      	mov	r0, r6
 801fa0e:	f7ff fbc3 	bl	801f198 <traceIF_itmPrint>
 801fa12:	4620      	mov	r0, r4
 801fa14:	f7ff fb7d 	bl	801f112 <crs_strlen>
 801fa18:	b283      	uxth	r3, r0
 801fa1a:	4622      	mov	r2, r4
 801fa1c:	4639      	mov	r1, r7
 801fa1e:	4630      	mov	r0, r6
 801fa20:	f7ff fbdc 	bl	801f1dc <traceIF_uartPrint>
}
 801fa24:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fa28:	080351b8 	.word	0x080351b8
 801fa2c:	0802deec 	.word	0x0802deec
 801fa30:	200046dc 	.word	0x200046dc

0801fa34 <traceIF_init>:
  *         - before using any other functions of traceIF_*
  * @param  -
  * @retval -
  */
void traceIF_init(void)
{
 801fa34:	b508      	push	{r3, lr}
#if (RTOS_USED == 1)
  /* Multi call protection */
  if (traceIF_uart_mutex == NULL)
 801fa36:	4b05      	ldr	r3, [pc, #20]	; (801fa4c <traceIF_init+0x18>)
 801fa38:	681b      	ldr	r3, [r3, #0]
 801fa3a:	b103      	cbz	r3, 801fa3e <traceIF_init+0xa>
  }
#else
  /* Nothing to do in no RTOS used */
  __NOP();
#endif /* (RTOS_USED == 1) */
}
 801fa3c:	bd08      	pop	{r3, pc}
    traceIF_uart_mutex = rtosalMutexNew(NULL);
 801fa3e:	2000      	movs	r0, #0
 801fa40:	f7ff fa77 	bl	801ef32 <rtosalMutexNew>
 801fa44:	4b01      	ldr	r3, [pc, #4]	; (801fa4c <traceIF_init+0x18>)
 801fa46:	6018      	str	r0, [r3, #0]
}
 801fa48:	e7f8      	b.n	801fa3c <traceIF_init+0x8>
 801fa4a:	bf00      	nop
 801fa4c:	200054dc 	.word	0x200054dc

0801fa50 <traceIF_start>:
            and before using any other functions of traceIF_*
  * @param  -
  * @retval -
  */
void traceIF_start(void)
{
 801fa50:	b508      	push	{r3, lr}
#if (USE_CMD_CONSOLE == 1)
#if (SW_DEBUG_VERSION == 1)
  /* Registration to cmd module to support cmd 'trace' */
  CMD_Declare((uint8_t *)"trace", traceIF_cmd, (uint8_t *)"trace management");
 801fa52:	4a03      	ldr	r2, [pc, #12]	; (801fa60 <traceIF_start+0x10>)
 801fa54:	4903      	ldr	r1, [pc, #12]	; (801fa64 <traceIF_start+0x14>)
 801fa56:	4804      	ldr	r0, [pc, #16]	; (801fa68 <traceIF_start+0x18>)
 801fa58:	f002 fb9a 	bl	8022190 <CMD_Declare>
#endif /* SW_DEBUG_VERSION == 1 */
#endif /* USE_CMD_CONSOLE == 1 */
}
 801fa5c:	bd08      	pop	{r3, pc}
 801fa5e:	bf00      	nop
 801fa60:	080351c0 	.word	0x080351c0
 801fa64:	0801f4c9 	.word	0x0801f4c9
 801fa68:	08034f28 	.word	0x08034f28

0801fa6c <cellular_datacache_init>:
  * @brief  Initialize all cellular entries of Data Cache
  * @param  -
  * @retval -
  */
static void cellular_datacache_init(void)
{
 801fa6c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  static dc_apn_config_t             dc_apn_config;
#if (USE_LOW_POWER == 1)
  static dc_cellular_power_config_t  dc_cellular_power_config;
#endif  /* (USE_LOW_POWER == 1) */

  (void)memset((void *)&dc_cellular_info,         0, sizeof(dc_cellular_info_t));
 801fa70:	f04f 0bf4 	mov.w	fp, #244	; 0xf4
 801fa74:	465a      	mov	r2, fp
 801fa76:	2100      	movs	r1, #0
 801fa78:	4836      	ldr	r0, [pc, #216]	; (801fb54 <cellular_datacache_init+0xe8>)
 801fa7a:	f006 f96c 	bl	8025d56 <memset>
  (void)memset((void *)&dc_ppp_client_info,       0, sizeof(dc_ppp_client_info_t));
 801fa7e:	4b36      	ldr	r3, [pc, #216]	; (801fb58 <cellular_datacache_init+0xec>)
 801fa80:	2400      	movs	r4, #0
 801fa82:	601c      	str	r4, [r3, #0]
 801fa84:	605c      	str	r4, [r3, #4]
 801fa86:	609c      	str	r4, [r3, #8]
 801fa88:	60dc      	str	r4, [r3, #12]
 801fa8a:	611c      	str	r4, [r3, #16]
 801fa8c:	615c      	str	r4, [r3, #20]
  (void)memset((void *)&dc_cellular_data_info,    0, sizeof(dc_cellular_data_info_t));
 801fa8e:	4e33      	ldr	r6, [pc, #204]	; (801fb5c <cellular_datacache_init+0xf0>)
 801fa90:	6034      	str	r4, [r6, #0]
 801fa92:	6074      	str	r4, [r6, #4]
 801fa94:	60b4      	str	r4, [r6, #8]
 801fa96:	60f4      	str	r4, [r6, #12]
  (void)memset((void *)&dc_nifman_info,           0, sizeof(dc_nifman_info_t));
 801fa98:	4d31      	ldr	r5, [pc, #196]	; (801fb60 <cellular_datacache_init+0xf4>)
 801fa9a:	602c      	str	r4, [r5, #0]
 801fa9c:	606c      	str	r4, [r5, #4]
 801fa9e:	60ac      	str	r4, [r5, #8]
 801faa0:	60ec      	str	r4, [r5, #12]
  (void)memset((void *)&dc_nfmc_info,             0, sizeof(dc_nfmc_info_t));
 801faa2:	f04f 092c 	mov.w	r9, #44	; 0x2c
 801faa6:	464a      	mov	r2, r9
 801faa8:	4621      	mov	r1, r4
 801faaa:	482e      	ldr	r0, [pc, #184]	; (801fb64 <cellular_datacache_init+0xf8>)
 801faac:	f006 f953 	bl	8025d56 <memset>
  (void)memset((void *)&dc_sim_info,              0, sizeof(dc_sim_info_t));
 801fab0:	2230      	movs	r2, #48	; 0x30
 801fab2:	4621      	mov	r1, r4
 801fab4:	482c      	ldr	r0, [pc, #176]	; (801fb68 <cellular_datacache_init+0xfc>)
 801fab6:	f006 f94e 	bl	8025d56 <memset>
  (void)memset((void *)&dc_cellular_params,       0, sizeof(dc_cellular_params_t));
 801faba:	f44f 7ad0 	mov.w	sl, #416	; 0x1a0
 801fabe:	4652      	mov	r2, sl
 801fac0:	4621      	mov	r1, r4
 801fac2:	482a      	ldr	r0, [pc, #168]	; (801fb6c <cellular_datacache_init+0x100>)
 801fac4:	f006 f947 	bl	8025d56 <memset>
  (void)memset((void *)&dc_cellular_target_state, 0, sizeof(dc_cellular_target_state_t));
 801fac8:	4f29      	ldr	r7, [pc, #164]	; (801fb70 <cellular_datacache_init+0x104>)
 801faca:	603c      	str	r4, [r7, #0]
 801facc:	607c      	str	r4, [r7, #4]
 801face:	60bc      	str	r4, [r7, #8]
  (void)memset((void *)&dc_apn_config,            0, sizeof(dc_apn_config_t));
 801fad0:	f04f 086c 	mov.w	r8, #108	; 0x6c
 801fad4:	4642      	mov	r2, r8
 801fad6:	4621      	mov	r1, r4
 801fad8:	4826      	ldr	r0, [pc, #152]	; (801fb74 <cellular_datacache_init+0x108>)
 801fada:	f006 f93c 	bl	8025d56 <memset>
#if (USE_LOW_POWER == 1)
  (void)memset((void *)&dc_cellular_power_config, 0, sizeof(dc_cellular_power_config_t));
#endif  /* (USE_LOW_POWER == 1) */

  /* register all all cellular entries of Data Cache */
  DC_CELLULAR_INFO             = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_info,
 801fade:	4c26      	ldr	r4, [pc, #152]	; (801fb78 <cellular_datacache_init+0x10c>)
 801fae0:	465a      	mov	r2, fp
 801fae2:	491c      	ldr	r1, [pc, #112]	; (801fb54 <cellular_datacache_init+0xe8>)
 801fae4:	4620      	mov	r0, r4
 801fae6:	f001 febf 	bl	8021868 <dc_com_register_serv>
 801faea:	4b24      	ldr	r3, [pc, #144]	; (801fb7c <cellular_datacache_init+0x110>)
 801faec:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_info_t));
  DC_CELLULAR_DATA_INFO        = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_data_info,
 801faee:	2210      	movs	r2, #16
 801faf0:	4631      	mov	r1, r6
 801faf2:	4620      	mov	r0, r4
 801faf4:	f001 feb8 	bl	8021868 <dc_com_register_serv>
 801faf8:	4b21      	ldr	r3, [pc, #132]	; (801fb80 <cellular_datacache_init+0x114>)
 801fafa:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_data_info_t));
  DC_CELLULAR_NIFMAN_INFO      = dc_com_register_serv(&dc_com_db, (void *)&dc_nifman_info,
 801fafc:	2210      	movs	r2, #16
 801fafe:	4629      	mov	r1, r5
 801fb00:	4620      	mov	r0, r4
 801fb02:	f001 feb1 	bl	8021868 <dc_com_register_serv>
 801fb06:	4b1f      	ldr	r3, [pc, #124]	; (801fb84 <cellular_datacache_init+0x118>)
 801fb08:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_nifman_info_t));
  DC_CELLULAR_NFMC_INFO        = dc_com_register_serv(&dc_com_db, (void *)&dc_nfmc_info,
 801fb0a:	464a      	mov	r2, r9
 801fb0c:	4915      	ldr	r1, [pc, #84]	; (801fb64 <cellular_datacache_init+0xf8>)
 801fb0e:	4620      	mov	r0, r4
 801fb10:	f001 feaa 	bl	8021868 <dc_com_register_serv>
 801fb14:	4b1c      	ldr	r3, [pc, #112]	; (801fb88 <cellular_datacache_init+0x11c>)
 801fb16:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_nfmc_info_t));
  DC_CELLULAR_SIM_INFO         = dc_com_register_serv(&dc_com_db, (void *)&dc_sim_info,
 801fb18:	2230      	movs	r2, #48	; 0x30
 801fb1a:	4913      	ldr	r1, [pc, #76]	; (801fb68 <cellular_datacache_init+0xfc>)
 801fb1c:	4620      	mov	r0, r4
 801fb1e:	f001 fea3 	bl	8021868 <dc_com_register_serv>
 801fb22:	4b1a      	ldr	r3, [pc, #104]	; (801fb8c <cellular_datacache_init+0x120>)
 801fb24:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_sim_info_t));
  DC_CELLULAR_CONFIG           = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_params,
 801fb26:	4652      	mov	r2, sl
 801fb28:	4910      	ldr	r1, [pc, #64]	; (801fb6c <cellular_datacache_init+0x100>)
 801fb2a:	4620      	mov	r0, r4
 801fb2c:	f001 fe9c 	bl	8021868 <dc_com_register_serv>
 801fb30:	4b17      	ldr	r3, [pc, #92]	; (801fb90 <cellular_datacache_init+0x124>)
 801fb32:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_params_t));
  DC_CELLULAR_TARGET_STATE_CMD = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_target_state,
 801fb34:	220c      	movs	r2, #12
 801fb36:	4639      	mov	r1, r7
 801fb38:	4620      	mov	r0, r4
 801fb3a:	f001 fe95 	bl	8021868 <dc_com_register_serv>
 801fb3e:	4b15      	ldr	r3, [pc, #84]	; (801fb94 <cellular_datacache_init+0x128>)
 801fb40:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_target_state_t));
  DC_CELLULAR_APN_CONFIG       = dc_com_register_serv(&dc_com_db, (void *)&dc_apn_config,
 801fb42:	4642      	mov	r2, r8
 801fb44:	490b      	ldr	r1, [pc, #44]	; (801fb74 <cellular_datacache_init+0x108>)
 801fb46:	4620      	mov	r0, r4
 801fb48:	f001 fe8e 	bl	8021868 <dc_com_register_serv>
 801fb4c:	4b12      	ldr	r3, [pc, #72]	; (801fb98 <cellular_datacache_init+0x12c>)
 801fb4e:	8018      	strh	r0, [r3, #0]
#endif  /* (USE_LOW_POWER == 1) */
#if (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP)
  DC_PPP_CLIENT_INFO           = dc_com_register_serv(&dc_com_db, (void *)&dc_ppp_client_info,
                                                      (uint16_t)sizeof(dc_ppp_client_info_t));
#endif   /* (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP) */
}
 801fb50:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fb54:	2000555c 	.word	0x2000555c
 801fb58:	20005838 	.word	0x20005838
 801fb5c:	2000554c 	.word	0x2000554c
 801fb60:	20005828 	.word	0x20005828
 801fb64:	200057fc 	.word	0x200057fc
 801fb68:	20005850 	.word	0x20005850
 801fb6c:	20005650 	.word	0x20005650
 801fb70:	200057f0 	.word	0x200057f0
 801fb74:	200054e0 	.word	0x200054e0
 801fb78:	200058b0 	.word	0x200058b0
 801fb7c:	20000236 	.word	0x20000236
 801fb80:	20000234 	.word	0x20000234
 801fb84:	2000023a 	.word	0x2000023a
 801fb88:	20000238 	.word	0x20000238
 801fb8c:	2000023c 	.word	0x2000023c
 801fb90:	20000232 	.word	0x20000232
 801fb94:	2000023e 	.word	0x2000023e
 801fb98:	20000230 	.word	0x20000230

0801fb9c <cellular_init>:
  * @brief  Initialize cellular features
  * @param  -
  * @retval -
  */
void cellular_init(void)
{
 801fb9c:	b508      	push	{r3, lr}
#if (USE_PRINTF == 0U)
  /* Error Handler in the modules below may use trace print */
  /* Recall traceIF_init() in case StartDefaultTask is not used or is redefined */
  traceIF_init();
 801fb9e:	f7ff ff49 	bl	801fa34 <traceIF_init>
  /* Recall stackAnalysis_init() in case StartDefaultTask is not used or is redefined */
  stackAnalysis_init();
#endif /* USE_STACK_ANALYSIS == 1 */

  /* Data Cache initialization */
  (void)dc_com_init(&dc_com_db);
 801fba2:	4805      	ldr	r0, [pc, #20]	; (801fbb8 <cellular_init+0x1c>)
 801fba4:	f001 ff2e 	bl	8021a04 <dc_com_init>

  /* cellular entries of Data Cache initialization */
  cellular_datacache_init();
 801fba8:	f7ff ff60 	bl	801fa6c <cellular_datacache_init>

  /* communication interface initialization */
  (void)com_init();
 801fbac:	f000 f816 	bl	801fbdc <com_init>

  /* cellular service initialization */
  (void)CST_cellular_service_init();
 801fbb0:	f7fc fde2 	bl	801c778 <CST_cellular_service_init>

#if (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP)
  /* if LWIP is used, PPP component initialization */
  (void)ppposif_client_init();
#endif  /* (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP) */
}
 801fbb4:	bd08      	pop	{r3, pc}
 801fbb6:	bf00      	nop
 801fbb8:	200058b0 	.word	0x200058b0

0801fbbc <cellular_start>:
  * @brief  Start cellular features with boot modem and network registration
  * @param  -
  * @retval -
  */
void cellular_start(void)
{
 801fbbc:	b508      	push	{r3, lr}
#if (USE_PRINTF == 0U)
  traceIF_start();
 801fbbe:	f7ff ff47 	bl	801fa50 <traceIF_start>

#if (USE_STACK_ANALYSIS == 1)
  stackAnalysis_start();
#endif /* USE_STACK_ANALYSIS == 1 */

  dc_com_start(&dc_com_db);
 801fbc2:	4805      	ldr	r0, [pc, #20]	; (801fbd8 <cellular_start+0x1c>)
 801fbc4:	f001 ff32 	bl	8021a2c <dc_com_start>

#if (USE_LOW_POWER == 1)
  CSP_Start();
#endif  /* (USE_LOW_POWER == 1) */
  (void)com_start();
 801fbc8:	f000 f814 	bl	801fbf4 <com_start>
#if defined(AT_TEST)
  at_modem_start();
#endif   /* defined(AT_TEST) */

#if !defined(AT_TEST)
  (void)CST_cellular_service_start();
 801fbcc:	f7fc fe02 	bl	801c7d4 <CST_cellular_service_start>
#endif  /* !defined(AT_TEST) */

#if !defined(AT_TEST)
  (void)CST_radio_on();
 801fbd0:	f7fc fc7c 	bl	801c4cc <CST_radio_on>
#endif   /*  !defined(AT_TEST) */
}
 801fbd4:	bd08      	pop	{r3, pc}
 801fbd6:	bf00      	nop
 801fbd8:	200058b0 	.word	0x200058b0

0801fbdc <com_init>:
  *         - before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_init(void)
{
 801fbdc:	b510      	push	{r4, lr}
  bool init_socket, init_icc, result;

  /* Init socket services */
  init_socket = com_sockets_init();
 801fbde:	f000 f9c7 	bl	801ff70 <com_sockets_init>
 801fbe2:	4604      	mov	r4, r0

  /* Init icc services */
#if (USE_COM_ICC == 1)
  init_icc    = com_icc_init();
 801fbe4:	f000 f8a8 	bl	801fd38 <com_icc_init>
#else /* USE_COM_ICC == 0 */
  init_icc    = true;
#endif /* USE_COM_ICC == 1 */

  result = true;
  if ((init_socket == false)
 801fbe8:	b114      	cbz	r4, 801fbf0 <com_init+0x14>
      || (init_icc == false))
 801fbea:	b910      	cbnz	r0, 801fbf2 <com_init+0x16>
  {
    result = false;
 801fbec:	2000      	movs	r0, #0
 801fbee:	e000      	b.n	801fbf2 <com_init+0x16>
 801fbf0:	2000      	movs	r0, #0
  }

  return (result);
}
 801fbf2:	bd10      	pop	{r4, pc}

0801fbf4 <com_start>:
            and before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false start ok/nok
  */
bool com_start(void)
{
 801fbf4:	b508      	push	{r3, lr}
  bool result;

  result = true;

  /* Start socket services */
  com_sockets_start();
 801fbf6:	f000 f9c5 	bl	801ff84 <com_sockets_start>

#if (USE_COM_ICC == 1)
  /* Start icc services */
  com_icc_start();
 801fbfa:	f000 f8c7 	bl	801fd8c <com_icc_start>
#endif /* USE_COM_ICC == 1 */

  return (result);
}
 801fbfe:	2001      	movs	r0, #1
 801fc00:	bd08      	pop	{r3, pc}
	...

0801fc04 <com_icc_init_icc_desc>:
  * @note   Supported values: COM_PROTO_CSIM : communication with ICC using AT+CSIM command
  *                           COM_PROTO_NDLC : communication with ICC using NDLC command
  * @retval -
  */
static void com_icc_init_icc_desc(uint8_t icc_index, uint8_t protocol)
{
 801fc04:	b570      	push	{r4, r5, r6, lr}
 801fc06:	4604      	mov	r4, r0
 801fc08:	460d      	mov	r5, r1
  /* Protect Icc descriptor access */
  (void)rtosalMutexAcquire(ComIccMutexHandle, RTOSAL_WAIT_FOREVER);
 801fc0a:	4e0a      	ldr	r6, [pc, #40]	; (801fc34 <com_icc_init_icc_desc+0x30>)
 801fc0c:	f04f 31ff 	mov.w	r1, #4294967295
 801fc10:	6830      	ldr	r0, [r6, #0]
 801fc12:	f7ff f998 	bl	801ef46 <rtosalMutexAcquire>

  com_icc_desc[icc_index].state     = COM_ICC_INVALID;
 801fc16:	4808      	ldr	r0, [pc, #32]	; (801fc38 <com_icc_init_icc_desc+0x34>)
 801fc18:	2200      	movs	r2, #0
 801fc1a:	f800 2034 	strb.w	r2, [r0, r4, lsl #3]
  com_icc_desc[icc_index].protocol  = protocol;
 801fc1e:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
 801fc22:	7045      	strb	r5, [r0, #1]
  com_icc_desc[icc_index].handle    = COM_HANDLE_INVALID_ID;
 801fc24:	f04f 33ff 	mov.w	r3, #4294967295
 801fc28:	6043      	str	r3, [r0, #4]

  /* Access to Icc descriptor finished */
  (void)rtosalMutexRelease(ComIccMutexHandle);
 801fc2a:	6830      	ldr	r0, [r6, #0]
 801fc2c:	f7ff f98f 	bl	801ef4e <rtosalMutexRelease>
}
 801fc30:	bd70      	pop	{r4, r5, r6, pc}
 801fc32:	bf00      	nop
 801fc34:	20005880 	.word	0x20005880
 801fc38:	20005884 	.word	0x20005884

0801fc3c <com_icc_datacache_cb>:
{
 801fc3c:	b510      	push	{r4, lr}
 801fc3e:	b0c0      	sub	sp, #256	; 0x100
  if (dc_event_id == DC_CELLULAR_SIM_INFO)
 801fc40:	4b35      	ldr	r3, [pc, #212]	; (801fd18 <com_icc_datacache_cb+0xdc>)
 801fc42:	8819      	ldrh	r1, [r3, #0]
 801fc44:	4288      	cmp	r0, r1
 801fc46:	d006      	beq.n	801fc56 <com_icc_datacache_cb+0x1a>
  else if (dc_event_id == DC_CELLULAR_INFO)
 801fc48:	4b34      	ldr	r3, [pc, #208]	; (801fd1c <com_icc_datacache_cb+0xe0>)
 801fc4a:	8819      	ldrh	r1, [r3, #0]
 801fc4c:	4288      	cmp	r0, r1
 801fc4e:	d046      	beq.n	801fcde <com_icc_datacache_cb+0xa2>
    __NOP();
 801fc50:	bf00      	nop
}
 801fc52:	b040      	add	sp, #256	; 0x100
 801fc54:	bd10      	pop	{r4, pc}
    com_icc_is_available[0] = false;
 801fc56:	2300      	movs	r3, #0
 801fc58:	4a31      	ldr	r2, [pc, #196]	; (801fd20 <com_icc_datacache_cb+0xe4>)
 801fc5a:	7013      	strb	r3, [r2, #0]
    com_icc_is_power_on[0] = false;
 801fc5c:	4a31      	ldr	r2, [pc, #196]	; (801fd24 <com_icc_datacache_cb+0xe8>)
 801fc5e:	7013      	strb	r3, [r2, #0]
    com_icc_is_initialized[0] = false;
 801fc60:	4a31      	ldr	r2, [pc, #196]	; (801fd28 <com_icc_datacache_cb+0xec>)
 801fc62:	7013      	strb	r3, [r2, #0]
    if (dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&dc_sim_rt_info, sizeof(dc_sim_rt_info))
 801fc64:	2330      	movs	r3, #48	; 0x30
 801fc66:	aa03      	add	r2, sp, #12
 801fc68:	4830      	ldr	r0, [pc, #192]	; (801fd2c <com_icc_datacache_cb+0xf0>)
 801fc6a:	f001 fead 	bl	80219c8 <dc_com_read>
 801fc6e:	2800      	cmp	r0, #0
 801fc70:	d0ef      	beq.n	801fc52 <com_icc_datacache_cb+0x16>
      PRINT_DBG("sim state: rt_state:%d index_slot:%d sim_status:%d",
 801fc72:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 801fc76:	f503 7280 	add.w	r2, r3, #256	; 0x100
 801fc7a:	446a      	add	r2, sp
 801fc7c:	f812 2cc9 	ldrb.w	r2, [r2, #-201]
 801fc80:	4c2b      	ldr	r4, [pc, #172]	; (801fd30 <com_icc_datacache_cb+0xf4>)
 801fc82:	9200      	str	r2, [sp, #0]
 801fc84:	f89d 2014 	ldrb.w	r2, [sp, #20]
 801fc88:	492a      	ldr	r1, [pc, #168]	; (801fd34 <com_icc_datacache_cb+0xf8>)
 801fc8a:	4620      	mov	r0, r4
 801fc8c:	f005 fff0 	bl	8025c70 <sprintf>
 801fc90:	4620      	mov	r0, r4
 801fc92:	f7ff fa3e 	bl	801f112 <crs_strlen>
 801fc96:	b283      	uxth	r3, r0
 801fc98:	4622      	mov	r2, r4
 801fc9a:	2102      	movs	r1, #2
 801fc9c:	2003      	movs	r0, #3
 801fc9e:	f7ff fa7b 	bl	801f198 <traceIF_itmPrint>
 801fca2:	4620      	mov	r0, r4
 801fca4:	f7ff fa35 	bl	801f112 <crs_strlen>
 801fca8:	b283      	uxth	r3, r0
 801fcaa:	4622      	mov	r2, r4
 801fcac:	2102      	movs	r1, #2
 801fcae:	2003      	movs	r0, #3
 801fcb0:	f7ff fa94 	bl	801f1dc <traceIF_uartPrint>
      if (dc_sim_rt_info.rt_state == DC_SERVICE_ON)
 801fcb4:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801fcb8:	2b07      	cmp	r3, #7
 801fcba:	d1ca      	bne.n	801fc52 <com_icc_datacache_cb+0x16>
        if (dc_sim_rt_info.sim_status[dc_sim_rt_info.index_slot] == DC_SIM_OK)
 801fcbc:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 801fcc0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801fcc4:	446b      	add	r3, sp
 801fcc6:	f813 3cc9 	ldrb.w	r3, [r3, #-201]
 801fcca:	2b00      	cmp	r3, #0
 801fccc:	d1c1      	bne.n	801fc52 <com_icc_datacache_cb+0x16>
          com_icc_is_available[0]   = true;
 801fcce:	2301      	movs	r3, #1
 801fcd0:	4a13      	ldr	r2, [pc, #76]	; (801fd20 <com_icc_datacache_cb+0xe4>)
 801fcd2:	7013      	strb	r3, [r2, #0]
          com_icc_is_initialized[0] = true;
 801fcd4:	4a14      	ldr	r2, [pc, #80]	; (801fd28 <com_icc_datacache_cb+0xec>)
 801fcd6:	7013      	strb	r3, [r2, #0]
          com_icc_is_power_on[0]    = true;
 801fcd8:	4a12      	ldr	r2, [pc, #72]	; (801fd24 <com_icc_datacache_cb+0xe8>)
 801fcda:	7013      	strb	r3, [r2, #0]
 801fcdc:	e7b9      	b.n	801fc52 <com_icc_datacache_cb+0x16>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&dc_cellular_info, sizeof(dc_cellular_info));
 801fcde:	23f4      	movs	r3, #244	; 0xf4
 801fce0:	aa03      	add	r2, sp, #12
 801fce2:	4812      	ldr	r0, [pc, #72]	; (801fd2c <com_icc_datacache_cb+0xf0>)
 801fce4:	f001 fe70 	bl	80219c8 <dc_com_read>
    if (dc_cellular_info.modem_state == DC_MODEM_STATE_OFF)
 801fce8:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801fcec:	b163      	cbz	r3, 801fd08 <com_icc_datacache_cb+0xcc>
    else if (dc_cellular_info.modem_state == DC_MODEM_STATE_POWERED_ON)
 801fcee:	2b01      	cmp	r3, #1
 801fcf0:	d00d      	beq.n	801fd0e <com_icc_datacache_cb+0xd2>
      __NOP();
 801fcf2:	bf00      	nop
 801fcf4:	e7ad      	b.n	801fc52 <com_icc_datacache_cb+0x16>
        com_icc_is_available[i]   = false;
 801fcf6:	2200      	movs	r2, #0
 801fcf8:	4909      	ldr	r1, [pc, #36]	; (801fd20 <com_icc_datacache_cb+0xe4>)
 801fcfa:	54ca      	strb	r2, [r1, r3]
        com_icc_is_initialized[i] = false;
 801fcfc:	490a      	ldr	r1, [pc, #40]	; (801fd28 <com_icc_datacache_cb+0xec>)
 801fcfe:	54ca      	strb	r2, [r1, r3]
        com_icc_is_power_on[i]    = false;
 801fd00:	4908      	ldr	r1, [pc, #32]	; (801fd24 <com_icc_datacache_cb+0xe8>)
 801fd02:	54ca      	strb	r2, [r1, r3]
      for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801fd04:	3301      	adds	r3, #1
 801fd06:	b2db      	uxtb	r3, r3
 801fd08:	2b01      	cmp	r3, #1
 801fd0a:	d9f4      	bls.n	801fcf6 <com_icc_datacache_cb+0xba>
 801fd0c:	e7a1      	b.n	801fc52 <com_icc_datacache_cb+0x16>
      com_icc_is_available[1]   = true;
 801fd0e:	4b04      	ldr	r3, [pc, #16]	; (801fd20 <com_icc_datacache_cb+0xe4>)
 801fd10:	2201      	movs	r2, #1
 801fd12:	705a      	strb	r2, [r3, #1]
 801fd14:	e79d      	b.n	801fc52 <com_icc_datacache_cb+0x16>
 801fd16:	bf00      	nop
 801fd18:	2000023c 	.word	0x2000023c
 801fd1c:	20000236 	.word	0x20000236
 801fd20:	20005894 	.word	0x20005894
 801fd24:	2000589c 	.word	0x2000589c
 801fd28:	20005898 	.word	0x20005898
 801fd2c:	200058b0 	.word	0x200058b0
 801fd30:	200049dc 	.word	0x200049dc
 801fd34:	08035278 	.word	0x08035278

0801fd38 <com_icc_init>:
  *         - before using any other functions of com_icc*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_icc_init(void)
{
 801fd38:	b510      	push	{r4, lr}
  bool result = true;

  /* Initialize ICC availability */
  for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801fd3a:	2300      	movs	r3, #0
 801fd3c:	e008      	b.n	801fd50 <com_icc_init+0x18>
  {
    com_icc_is_available[i]   = false;
 801fd3e:	2200      	movs	r2, #0
 801fd40:	490e      	ldr	r1, [pc, #56]	; (801fd7c <com_icc_init+0x44>)
 801fd42:	54ca      	strb	r2, [r1, r3]
    com_icc_is_initialized[i] = false;
 801fd44:	490e      	ldr	r1, [pc, #56]	; (801fd80 <com_icc_init+0x48>)
 801fd46:	54ca      	strb	r2, [r1, r3]
    com_icc_is_power_on[i]    = false;
 801fd48:	490e      	ldr	r1, [pc, #56]	; (801fd84 <com_icc_init+0x4c>)
 801fd4a:	54ca      	strb	r2, [r1, r3]
  for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801fd4c:	3301      	adds	r3, #1
 801fd4e:	b2db      	uxtb	r3, r3
 801fd50:	2b01      	cmp	r3, #1
 801fd52:	d9f4      	bls.n	801fd3e <com_icc_init+0x6>
  }

  /* Initialize Mutex to protect ICC handle descriptor access */
  ComIccMutexHandle = rtosalMutexNew(NULL);
 801fd54:	2000      	movs	r0, #0
 801fd56:	f7ff f8ec 	bl	801ef32 <rtosalMutexNew>
 801fd5a:	4b0b      	ldr	r3, [pc, #44]	; (801fd88 <com_icc_init+0x50>)
 801fd5c:	6018      	str	r0, [r3, #0]
  if (ComIccMutexHandle != NULL)
 801fd5e:	b160      	cbz	r0, 801fd7a <com_icc_init+0x42>
  {
    for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801fd60:	2400      	movs	r4, #0
 801fd62:	e007      	b.n	801fd74 <com_icc_init+0x3c>
    {
      com_icc_init_icc_desc(i, ((uint8_t)COM_PROTO_CSIM + i));
 801fd64:	f1a4 016f 	sub.w	r1, r4, #111	; 0x6f
 801fd68:	b2c9      	uxtb	r1, r1
 801fd6a:	4620      	mov	r0, r4
 801fd6c:	f7ff ff4a 	bl	801fc04 <com_icc_init_icc_desc>
    for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801fd70:	3401      	adds	r4, #1
 801fd72:	b2e4      	uxtb	r4, r4
 801fd74:	2c01      	cmp	r4, #1
 801fd76:	d9f5      	bls.n	801fd64 <com_icc_init+0x2c>
  bool result = true;
 801fd78:	2001      	movs	r0, #1
  {
    result = false;
  }

  return (result);
}
 801fd7a:	bd10      	pop	{r4, pc}
 801fd7c:	20005894 	.word	0x20005894
 801fd80:	20005898 	.word	0x20005898
 801fd84:	2000589c 	.word	0x2000589c
 801fd88:	20005880 	.word	0x20005880

0801fd8c <com_icc_start>:
            - and before using any other functions of com_icc_*
  * @param  -
  * @retval -
  */
void com_icc_start(void)
{
 801fd8c:	b508      	push	{r3, lr}
#if (USE_DATACACHE == 1)
  /* Datacache registration for icc status */
  (void)dc_com_register_gen_event_cb(&dc_com_db, com_icc_datacache_cb, (void *)NULL);
 801fd8e:	2200      	movs	r2, #0
 801fd90:	4902      	ldr	r1, [pc, #8]	; (801fd9c <com_icc_start+0x10>)
 801fd92:	4803      	ldr	r0, [pc, #12]	; (801fda0 <com_icc_start+0x14>)
 801fd94:	f001 fd9c 	bl	80218d0 <dc_com_register_gen_event_cb>
#endif /* USE_DATACACHE == 1 */
}
 801fd98:	bd08      	pop	{r3, pc}
 801fd9a:	bf00      	nop
 801fd9c:	0801fc3d 	.word	0x0801fc3d
 801fda0:	200058b0 	.word	0x200058b0

0801fda4 <com_help_cmd>:
  * @param  -
  * @note   -
  * @retval -
  */
static void com_help_cmd(void)
{
 801fda4:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help((uint8_t *)"com");
 801fda6:	481c      	ldr	r0, [pc, #112]	; (801fe18 <com_help_cmd+0x74>)
 801fda8:	f002 fa52 	bl	8022250 <CMD_print_help>
  PRINT_FORCE("comsocket help")
 801fdac:	4c1b      	ldr	r4, [pc, #108]	; (801fe1c <com_help_cmd+0x78>)
 801fdae:	4d1c      	ldr	r5, [pc, #112]	; (801fe20 <com_help_cmd+0x7c>)
 801fdb0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801fdb2:	6020      	str	r0, [r4, #0]
 801fdb4:	6061      	str	r1, [r4, #4]
 801fdb6:	60a2      	str	r2, [r4, #8]
 801fdb8:	60e3      	str	r3, [r4, #12]
 801fdba:	782b      	ldrb	r3, [r5, #0]
 801fdbc:	7423      	strb	r3, [r4, #16]
 801fdbe:	4620      	mov	r0, r4
 801fdc0:	f7ff f9a7 	bl	801f112 <crs_strlen>
 801fdc4:	b283      	uxth	r3, r0
 801fdc6:	4622      	mov	r2, r4
 801fdc8:	2101      	movs	r1, #1
 801fdca:	2003      	movs	r0, #3
 801fdcc:	f7ff f9e4 	bl	801f198 <traceIF_itmPrint>
 801fdd0:	4620      	mov	r0, r4
 801fdd2:	f7ff f99e 	bl	801f112 <crs_strlen>
 801fdd6:	b282      	uxth	r2, r0
 801fdd8:	4621      	mov	r1, r4
 801fdda:	2003      	movs	r0, #3
 801fddc:	f7ff fa16 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("comsocket stat\n\r")
 801fde0:	4d10      	ldr	r5, [pc, #64]	; (801fe24 <com_help_cmd+0x80>)
 801fde2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801fde4:	6020      	str	r0, [r4, #0]
 801fde6:	6061      	str	r1, [r4, #4]
 801fde8:	60a2      	str	r2, [r4, #8]
 801fdea:	60e3      	str	r3, [r4, #12]
 801fdec:	882a      	ldrh	r2, [r5, #0]
 801fdee:	78ab      	ldrb	r3, [r5, #2]
 801fdf0:	8222      	strh	r2, [r4, #16]
 801fdf2:	74a3      	strb	r3, [r4, #18]
 801fdf4:	4620      	mov	r0, r4
 801fdf6:	f7ff f98c 	bl	801f112 <crs_strlen>
 801fdfa:	b283      	uxth	r3, r0
 801fdfc:	4622      	mov	r2, r4
 801fdfe:	2101      	movs	r1, #1
 801fe00:	2003      	movs	r0, #3
 801fe02:	f7ff f9c9 	bl	801f198 <traceIF_itmPrint>
 801fe06:	4620      	mov	r0, r4
 801fe08:	f7ff f983 	bl	801f112 <crs_strlen>
 801fe0c:	b282      	uxth	r2, r0
 801fe0e:	4621      	mov	r1, r4
 801fe10:	2003      	movs	r0, #3
 801fe12:	f7ff f9fb 	bl	801f20c <traceIF_uartPrintForce>
}
 801fe16:	bd38      	pop	{r3, r4, r5, pc}
 801fe18:	080352b8 	.word	0x080352b8
 801fe1c:	200049dc 	.word	0x200049dc
 801fe20:	080352bc 	.word	0x080352bc
 801fe24:	080352d0 	.word	0x080352d0

0801fe28 <com_sockets_cmd>:
  * @param  cmd_line_p - command line
  * @note   command parameters
  * @retval cmd_status_t - status of cmd management
  */
static cmd_status_t com_sockets_cmd(uint8_t *cmd_line_p)
{
 801fe28:	b530      	push	{r4, r5, lr}
 801fe2a:	b08b      	sub	sp, #44	; 0x2c
 801fe2c:	4605      	mov	r5, r0
  uint32_t argc;
  uint8_t  *argv_p[10];
  const uint8_t *cmd_p;

  PRINT_FORCE("")
 801fe2e:	4c3d      	ldr	r4, [pc, #244]	; (801ff24 <com_sockets_cmd+0xfc>)
 801fe30:	4b3d      	ldr	r3, [pc, #244]	; (801ff28 <com_sockets_cmd+0x100>)
 801fe32:	881a      	ldrh	r2, [r3, #0]
 801fe34:	789b      	ldrb	r3, [r3, #2]
 801fe36:	8022      	strh	r2, [r4, #0]
 801fe38:	70a3      	strb	r3, [r4, #2]
 801fe3a:	4620      	mov	r0, r4
 801fe3c:	f7ff f969 	bl	801f112 <crs_strlen>
 801fe40:	b283      	uxth	r3, r0
 801fe42:	4622      	mov	r2, r4
 801fe44:	2101      	movs	r1, #1
 801fe46:	2003      	movs	r0, #3
 801fe48:	f7ff f9a6 	bl	801f198 <traceIF_itmPrint>
 801fe4c:	4620      	mov	r0, r4
 801fe4e:	f7ff f960 	bl	801f112 <crs_strlen>
 801fe52:	b282      	uxth	r2, r0
 801fe54:	4621      	mov	r1, r4
 801fe56:	2003      	movs	r0, #3
 801fe58:	f7ff f9d8 	bl	801f20c <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((COM_SOCKETS_CHAR_t *)cmd_line_p, " \t");
 801fe5c:	4933      	ldr	r1, [pc, #204]	; (801ff2c <com_sockets_cmd+0x104>)
 801fe5e:	4628      	mov	r0, r5
 801fe60:	f005 ff94 	bl	8025d8c <strtok>

  if (cmd_p != NULL)
 801fe64:	b140      	cbz	r0, 801fe78 <com_sockets_cmd+0x50>
 801fe66:	4604      	mov	r4, r0
  {
    if (strncmp((const COM_SOCKETS_CHAR_t *)cmd_p,
 801fe68:	f7e0 f9c4 	bl	80001f4 <strlen>
 801fe6c:	4602      	mov	r2, r0
 801fe6e:	4930      	ldr	r1, [pc, #192]	; (801ff30 <com_sockets_cmd+0x108>)
 801fe70:	4620      	mov	r0, r4
 801fe72:	f005 ff78 	bl	8025d66 <strncmp>
 801fe76:	b110      	cbz	r0, 801fe7e <com_sockets_cmd+0x56>
        com_help_cmd();
      }
    }
  }
  return CMD_OK;
}
 801fe78:	2000      	movs	r0, #0
 801fe7a:	b00b      	add	sp, #44	; 0x2c
 801fe7c:	bd30      	pop	{r4, r5, pc}
      for (argc = 0U; argc < 10U; argc++)
 801fe7e:	2400      	movs	r4, #0
 801fe80:	2c09      	cmp	r4, #9
 801fe82:	d80b      	bhi.n	801fe9c <com_sockets_cmd+0x74>
        argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 801fe84:	4929      	ldr	r1, [pc, #164]	; (801ff2c <com_sockets_cmd+0x104>)
 801fe86:	2000      	movs	r0, #0
 801fe88:	f005 ff80 	bl	8025d8c <strtok>
 801fe8c:	ab0a      	add	r3, sp, #40	; 0x28
 801fe8e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 801fe92:	f843 0c28 	str.w	r0, [r3, #-40]
        if (argv_p[argc] == NULL)
 801fe96:	b108      	cbz	r0, 801fe9c <com_sockets_cmd+0x74>
      for (argc = 0U; argc < 10U; argc++)
 801fe98:	3401      	adds	r4, #1
 801fe9a:	e7f1      	b.n	801fe80 <com_sockets_cmd+0x58>
      if (argc == 0U)
 801fe9c:	b19c      	cbz	r4, 801fec6 <com_sockets_cmd+0x9e>
      else if (strncmp((COM_SOCKETS_CHAR_t *)argv_p[0],
 801fe9e:	9d00      	ldr	r5, [sp, #0]
 801fea0:	4628      	mov	r0, r5
 801fea2:	f7e0 f9a7 	bl	80001f4 <strlen>
 801fea6:	4604      	mov	r4, r0
 801fea8:	4602      	mov	r2, r0
 801feaa:	4922      	ldr	r1, [pc, #136]	; (801ff34 <com_sockets_cmd+0x10c>)
 801feac:	4628      	mov	r0, r5
 801feae:	f005 ff5a 	bl	8025d66 <strncmp>
 801feb2:	b158      	cbz	r0, 801fecc <com_sockets_cmd+0xa4>
      else if (strncmp((COM_SOCKETS_CHAR_t *)argv_p[0],
 801feb4:	4622      	mov	r2, r4
 801feb6:	4920      	ldr	r1, [pc, #128]	; (801ff38 <com_sockets_cmd+0x110>)
 801feb8:	4628      	mov	r0, r5
 801feba:	f005 ff54 	bl	8025d66 <strncmp>
 801febe:	b940      	cbnz	r0, 801fed2 <com_sockets_cmd+0xaa>
        com_sockets_statistic_display();
 801fec0:	f001 fcd1 	bl	8021866 <com_sockets_statistic_display>
 801fec4:	e7d8      	b.n	801fe78 <com_sockets_cmd+0x50>
        com_help_cmd();
 801fec6:	f7ff ff6d 	bl	801fda4 <com_help_cmd>
 801feca:	e7d5      	b.n	801fe78 <com_sockets_cmd+0x50>
        com_help_cmd();
 801fecc:	f7ff ff6a 	bl	801fda4 <com_help_cmd>
 801fed0:	e7d2      	b.n	801fe78 <com_sockets_cmd+0x50>
        PRINT_FORCE("comsocket: Unrecognized command. Usage:")
 801fed2:	4d1a      	ldr	r5, [pc, #104]	; (801ff3c <com_sockets_cmd+0x114>)
 801fed4:	4c13      	ldr	r4, [pc, #76]	; (801ff24 <com_sockets_cmd+0xfc>)
 801fed6:	f105 0e20 	add.w	lr, r5, #32
 801feda:	46ac      	mov	ip, r5
 801fedc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801fee0:	6020      	str	r0, [r4, #0]
 801fee2:	6061      	str	r1, [r4, #4]
 801fee4:	60a2      	str	r2, [r4, #8]
 801fee6:	60e3      	str	r3, [r4, #12]
 801fee8:	4665      	mov	r5, ip
 801feea:	3410      	adds	r4, #16
 801feec:	45f4      	cmp	ip, lr
 801feee:	d1f4      	bne.n	801feda <com_sockets_cmd+0xb2>
 801fef0:	cd03      	ldmia	r5!, {r0, r1}
 801fef2:	6020      	str	r0, [r4, #0]
 801fef4:	6061      	str	r1, [r4, #4]
 801fef6:	882b      	ldrh	r3, [r5, #0]
 801fef8:	8123      	strh	r3, [r4, #8]
 801fefa:	4c0a      	ldr	r4, [pc, #40]	; (801ff24 <com_sockets_cmd+0xfc>)
 801fefc:	4620      	mov	r0, r4
 801fefe:	f7ff f908 	bl	801f112 <crs_strlen>
 801ff02:	b283      	uxth	r3, r0
 801ff04:	4622      	mov	r2, r4
 801ff06:	2101      	movs	r1, #1
 801ff08:	2003      	movs	r0, #3
 801ff0a:	f7ff f945 	bl	801f198 <traceIF_itmPrint>
 801ff0e:	4620      	mov	r0, r4
 801ff10:	f7ff f8ff 	bl	801f112 <crs_strlen>
 801ff14:	b282      	uxth	r2, r0
 801ff16:	4621      	mov	r1, r4
 801ff18:	2003      	movs	r0, #3
 801ff1a:	f7ff f977 	bl	801f20c <traceIF_uartPrintForce>
        com_help_cmd();
 801ff1e:	f7ff ff41 	bl	801fda4 <com_help_cmd>
 801ff22:	e7a9      	b.n	801fe78 <com_sockets_cmd+0x50>
 801ff24:	200049dc 	.word	0x200049dc
 801ff28:	0802deec 	.word	0x0802deec
 801ff2c:	08032b44 	.word	0x08032b44
 801ff30:	080352e4 	.word	0x080352e4
 801ff34:	08032b48 	.word	0x08032b48
 801ff38:	080352f0 	.word	0x080352f0
 801ff3c:	080352f8 	.word	0x080352f8

0801ff40 <com_socket>:
  * @param  type     - connection type
  * @param  protocol - protocol type
  * @retval int32_t  - socket handle or error value
  */
int32_t com_socket(int32_t family, int32_t type, int32_t protocol)
{
 801ff40:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_socket_ip_modem(family, type, protocol);
 801ff42:	f001 fa43 	bl	80213cc <com_socket_ip_modem>
#else
  result = com_socket_lwip_mcu(family, type, protocol);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 801ff46:	bd08      	pop	{r3, pc}

0801ff48 <com_setsockopt>:
  * @param  optlen    - size of the buffer containing the option value
  * @retval int32_t   - ok or error value
  */
int32_t com_setsockopt(int32_t sock, int32_t level, int32_t optname,
                       const void *optval, int32_t optlen)
{
 801ff48:	b510      	push	{r4, lr}
 801ff4a:	b082      	sub	sp, #8
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_setsockopt_ip_modem(sock, level, optname, optval, optlen);
 801ff4c:	9c04      	ldr	r4, [sp, #16]
 801ff4e:	9400      	str	r4, [sp, #0]
 801ff50:	f000 fcb4 	bl	80208bc <com_setsockopt_ip_modem>
#else
  result = com_setsockopt_lwip_mcu(sock, level, optname, optval, optlen);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 801ff54:	b002      	add	sp, #8
 801ff56:	bd10      	pop	{r4, pc}

0801ff58 <com_connect>:
  * @param  addrlen   - addr length
  * @retval int32_t   - ok or error value
  */
int32_t com_connect(int32_t sock,
                    const com_sockaddr_t *addr, int32_t addrlen)
{
 801ff58:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_connect_ip_modem(sock, addr, addrlen);
 801ff5a:	f000 fcef 	bl	802093c <com_connect_ip_modem>
#else
  result = com_connect_lwip_mcu(sock, addr, addrlen);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 801ff5e:	bd08      	pop	{r3, pc}

0801ff60 <com_send>:
  * @retval int32_t   - number of bytes sent or error value
  */
int32_t com_send(int32_t sock,
                 const com_char_t *buf, int32_t len,
                 int32_t flags)
{
 801ff60:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_send_ip_modem(sock, buf, len, flags);
 801ff62:	f000 ffd1 	bl	8020f08 <com_send_ip_modem>
#else
  result = com_send_lwip_mcu(sock, buf, len, flags);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 801ff66:	bd08      	pop	{r3, pc}

0801ff68 <com_closesocket>:
  * @note   Close a socket and release socket handle
  * @param  sock      - socket handle obtained with com_socket
  * @retval int32_t   - ok or error value
  */
int32_t com_closesocket(int32_t sock)
{
 801ff68:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_closesocket_ip_modem(sock);
 801ff6a:	f001 f98f 	bl	802128c <com_closesocket_ip_modem>
#else
  result = com_closesocket_lwip_mcu(sock);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 801ff6e:	bd08      	pop	{r3, pc}

0801ff70 <com_sockets_init>:
  *         - before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_sockets_init(void)
{
 801ff70:	b510      	push	{r4, lr}
  bool result;

  (void)osCDS_cellular_service_init();
 801ff72:	f7fa fce3 	bl	801a93c <osCDS_cellular_service_init>

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_init_ip_modem();
 801ff76:	f001 fc27 	bl	80217c8 <com_init_ip_modem>
 801ff7a:	4604      	mov	r4, r0
#else
  result = com_init_lwip_mcu();
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  com_sockets_statistic_init();
 801ff7c:	f001 fc70 	bl	8021860 <com_sockets_statistic_init>

  return (result);
}
 801ff80:	4620      	mov	r0, r4
 801ff82:	bd10      	pop	{r4, pc}

0801ff84 <com_sockets_start>:
            and before using any other functions of com_*
  * @param  -
  * @retval -
  */
void com_sockets_start(void)
{
 801ff84:	b508      	push	{r3, lr}
#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  com_start_ip_modem();
 801ff86:	f001 fc47 	bl	8021818 <com_start_ip_modem>
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  /* no com_sockets_statistic_start(); */

#if (USE_CMD_CONSOLE == 1)
  CMD_Declare((uint8_t *)"comsocket", com_sockets_cmd, (uint8_t *)"com socket commands");
 801ff8a:	4a03      	ldr	r2, [pc, #12]	; (801ff98 <com_sockets_start+0x14>)
 801ff8c:	4903      	ldr	r1, [pc, #12]	; (801ff9c <com_sockets_start+0x18>)
 801ff8e:	4804      	ldr	r0, [pc, #16]	; (801ffa0 <com_sockets_start+0x1c>)
 801ff90:	f002 f8fe 	bl	8022190 <CMD_Declare>
#endif /* USE_CMD_CONSOLE == 1 */
}
 801ff94:	bd08      	pop	{r3, pc}
 801ff96:	bf00      	nop
 801ff98:	08035324 	.word	0x08035324
 801ff9c:	0801fe29 	.word	0x0801fe29
 801ffa0:	080352e4 	.word	0x080352e4

0801ffa4 <com_ip_modem_find_socket>:
  */
static socket_desc_t *com_ip_modem_find_socket(int32_t sock, bool local)
{
  socket_desc_t *socket_desc;

  if (sock >= 0)
 801ffa4:	1e02      	subs	r2, r0, #0
 801ffa6:	db0f      	blt.n	801ffc8 <com_ip_modem_find_socket+0x24>
{
 801ffa8:	b410      	push	{r4}
  {
    bool found;

    socket_desc = socket_desc_list;
 801ffaa:	4b0a      	ldr	r3, [pc, #40]	; (801ffd4 <com_ip_modem_find_socket+0x30>)
 801ffac:	6818      	ldr	r0, [r3, #0]
    found = false;
 801ffae:	2400      	movs	r4, #0

    /* Search the socket descriptor */
    while ((socket_desc != NULL)
 801ffb0:	e000      	b.n	801ffb4 <com_ip_modem_find_socket+0x10>
        found = true;
      }
      else
      {
        /* Not the searched one ... Next */
        socket_desc = socket_desc->next;
 801ffb2:	6a40      	ldr	r0, [r0, #36]	; 0x24
           && (found != true))
 801ffb4:	b150      	cbz	r0, 801ffcc <com_ip_modem_find_socket+0x28>
 801ffb6:	b94c      	cbnz	r4, 801ffcc <com_ip_modem_find_socket+0x28>
      if ((socket_desc->id == sock)
 801ffb8:	6883      	ldr	r3, [r0, #8]
 801ffba:	4293      	cmp	r3, r2
 801ffbc:	d1f9      	bne.n	801ffb2 <com_ip_modem_find_socket+0xe>
          && (socket_desc->local == local))
 801ffbe:	7843      	ldrb	r3, [r0, #1]
 801ffc0:	428b      	cmp	r3, r1
 801ffc2:	d1f6      	bne.n	801ffb2 <com_ip_modem_find_socket+0xe>
        found = true;
 801ffc4:	2401      	movs	r4, #1
 801ffc6:	e7f5      	b.n	801ffb4 <com_ip_modem_find_socket+0x10>
      }
    }
  }
  else
  {
    socket_desc = NULL;
 801ffc8:	2000      	movs	r0, #0
  }

  /* If found == false then socket_desc = NULL */
  return socket_desc;
}
 801ffca:	4770      	bx	lr
 801ffcc:	f85d 4b04 	ldr.w	r4, [sp], #4
 801ffd0:	4770      	bx	lr
 801ffd2:	bf00      	nop
 801ffd4:	200058a8 	.word	0x200058a8

0801ffd8 <com_convert_sockaddr_to_ipaddr_port>:
  */
static void com_convert_sockaddr_to_ipaddr_port(const com_sockaddr_in_t *sockaddr_in,
                                                com_ip_addr_t *ip_addr,
                                                uint16_t *port)
{
  ip_addr->addr = sockaddr_in->sin_addr.s_addr;
 801ffd8:	6843      	ldr	r3, [r0, #4]
 801ffda:	600b      	str	r3, [r1, #0]
  *port = COM_NTOHS(sockaddr_in->sin_port);
 801ffdc:	8843      	ldrh	r3, [r0, #2]
 801ffde:	ba5b      	rev16	r3, r3
 801ffe0:	8013      	strh	r3, [r2, #0]
}
 801ffe2:	4770      	bx	lr

0801ffe4 <com_ip_modem_is_network_up>:
  * @retval true/false network is up/down
  */
static bool com_ip_modem_is_network_up(void)
{
  return (com_sockets_network_is_up);
}
 801ffe4:	4b01      	ldr	r3, [pc, #4]	; (801ffec <com_ip_modem_is_network_up+0x8>)
 801ffe6:	7818      	ldrb	r0, [r3, #0]
 801ffe8:	4770      	bx	lr
 801ffea:	bf00      	nop
 801ffec:	200058a6 	.word	0x200058a6

0801fff0 <com_ip_modem_new_local_port>:
  * @note   -
  * @retval new local port value in [COM_LOCAL_PORT_BEGIN, COM_LOCAL_PORT_END]
  *         or 0U if impossible to find a free port
  */
static uint16_t com_ip_modem_new_local_port(void)
{
 801fff0:	b410      	push	{r4}
  uint16_t iter;
  uint16_t result;
  socket_desc_t *socket_desc;

  local_port_ok = false;
  iter = 0U;
 801fff2:	f04f 0c00 	mov.w	ip, #0
  local_port_ok = false;
 801fff6:	4664      	mov	r4, ip

  while ((local_port_ok != true)
 801fff8:	e010      	b.n	802001c <com_ip_modem_new_local_port+0x2c>
    /* Test the next local port value */
    com_local_port++;
    iter++;
    if (com_local_port == COM_LOCAL_PORT_END)
    {
      com_local_port = COM_LOCAL_PORT_BEGIN;
 801fffa:	4b17      	ldr	r3, [pc, #92]	; (8020058 <com_ip_modem_new_local_port+0x68>)
 801fffc:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8020000:	801a      	strh	r2, [r3, #0]
 8020002:	e01d      	b.n	8020040 <com_ip_modem_new_local_port+0x50>
        /* Local port already used */
        found = true;
      }
      else
      {
        socket_desc = socket_desc->next;
 8020004:	6a5b      	ldr	r3, [r3, #36]	; 0x24
           && (found != true))
 8020006:	b13b      	cbz	r3, 8020018 <com_ip_modem_new_local_port+0x28>
 8020008:	b930      	cbnz	r0, 8020018 <com_ip_modem_new_local_port+0x28>
      if (socket_desc->local_port == com_local_port)
 802000a:	8999      	ldrh	r1, [r3, #12]
 802000c:	4a12      	ldr	r2, [pc, #72]	; (8020058 <com_ip_modem_new_local_port+0x68>)
 802000e:	8812      	ldrh	r2, [r2, #0]
 8020010:	4291      	cmp	r1, r2
 8020012:	d1f7      	bne.n	8020004 <com_ip_modem_new_local_port+0x14>
        found = true;
 8020014:	2001      	movs	r0, #1
 8020016:	e7f6      	b.n	8020006 <com_ip_modem_new_local_port+0x16>
      }
    }

    if (found == false)
 8020018:	b900      	cbnz	r0, 802001c <com_ip_modem_new_local_port+0x2c>
    {
      /* Local port is unused */
      local_port_ok = true;
 802001a:	2401      	movs	r4, #1
         && (iter < (COM_LOCAL_PORT_END - COM_LOCAL_PORT_BEGIN)))
 802001c:	b9a4      	cbnz	r4, 8020048 <com_ip_modem_new_local_port+0x58>
 802001e:	f643 73fe 	movw	r3, #16382	; 0x3ffe
 8020022:	459c      	cmp	ip, r3
 8020024:	d810      	bhi.n	8020048 <com_ip_modem_new_local_port+0x58>
    com_local_port++;
 8020026:	4a0c      	ldr	r2, [pc, #48]	; (8020058 <com_ip_modem_new_local_port+0x68>)
 8020028:	8813      	ldrh	r3, [r2, #0]
 802002a:	3301      	adds	r3, #1
 802002c:	b29b      	uxth	r3, r3
 802002e:	8013      	strh	r3, [r2, #0]
    iter++;
 8020030:	f10c 0c01 	add.w	ip, ip, #1
 8020034:	fa1f fc8c 	uxth.w	ip, ip
    if (com_local_port == COM_LOCAL_PORT_END)
 8020038:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802003c:	4293      	cmp	r3, r2
 802003e:	d0dc      	beq.n	801fffa <com_ip_modem_new_local_port+0xa>
    socket_desc = socket_desc_list;
 8020040:	4b06      	ldr	r3, [pc, #24]	; (802005c <com_ip_modem_new_local_port+0x6c>)
 8020042:	681b      	ldr	r3, [r3, #0]
    found = false;
 8020044:	4620      	mov	r0, r4
    while ((socket_desc != NULL)
 8020046:	e7de      	b.n	8020006 <com_ip_modem_new_local_port+0x16>
    }
    /* Continue to search a free value */
  }
  if (local_port_ok != true)
 8020048:	b114      	cbz	r4, 8020050 <com_ip_modem_new_local_port+0x60>
  {
    result = 0U;
  }
  else
  {
    result = com_local_port;
 802004a:	4b03      	ldr	r3, [pc, #12]	; (8020058 <com_ip_modem_new_local_port+0x68>)
 802004c:	8818      	ldrh	r0, [r3, #0]
 802004e:	e000      	b.n	8020052 <com_ip_modem_new_local_port+0x62>
    result = 0U;
 8020050:	2000      	movs	r0, #0
  }

  return result;
}
 8020052:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020056:	4770      	bx	lr
 8020058:	200058a4 	.word	0x200058a4
 802005c:	200058a8 	.word	0x200058a8

08020060 <com_ip_modem_wakeup_request>:
    PRINT_INFO("Inactivity: WakeUp request NOK")
  }

  (void)rtosalMutexRelease(ComTimerInactivityMutexHandle);
#else /* USE_LOW_POWER == 0 */
  __NOP();
 8020060:	bf00      	nop
#endif /* USE_LOW_POWER == 1 */
}
 8020062:	4770      	bx	lr

08020064 <com_ip_modem_closing_cb>:
  * @param  sock - socket handle
  * @note   -
  * @retval -
  */
static void com_ip_modem_closing_cb(socket_handle_t sock)
{
 8020064:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020066:	b083      	sub	sp, #12
 8020068:	4606      	mov	r6, r0
  PRINT_DBG("callback socket closing called")
 802006a:	4c75      	ldr	r4, [pc, #468]	; (8020240 <com_ip_modem_closing_cb+0x1dc>)
 802006c:	4d75      	ldr	r5, [pc, #468]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 802006e:	f104 0720 	add.w	r7, r4, #32
 8020072:	46a4      	mov	ip, r4
 8020074:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020078:	6028      	str	r0, [r5, #0]
 802007a:	6069      	str	r1, [r5, #4]
 802007c:	60aa      	str	r2, [r5, #8]
 802007e:	60eb      	str	r3, [r5, #12]
 8020080:	4664      	mov	r4, ip
 8020082:	3510      	adds	r5, #16
 8020084:	45bc      	cmp	ip, r7
 8020086:	d1f4      	bne.n	8020072 <com_ip_modem_closing_cb+0xe>
 8020088:	cc03      	ldmia	r4!, {r0, r1}
 802008a:	6028      	str	r0, [r5, #0]
 802008c:	6069      	str	r1, [r5, #4]
 802008e:	7823      	ldrb	r3, [r4, #0]
 8020090:	722b      	strb	r3, [r5, #8]
 8020092:	4c6c      	ldr	r4, [pc, #432]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 8020094:	4620      	mov	r0, r4
 8020096:	f7ff f83c 	bl	801f112 <crs_strlen>
 802009a:	b283      	uxth	r3, r0
 802009c:	4622      	mov	r2, r4
 802009e:	2102      	movs	r1, #2
 80200a0:	2003      	movs	r0, #3
 80200a2:	f7ff f879 	bl	801f198 <traceIF_itmPrint>
 80200a6:	4620      	mov	r0, r4
 80200a8:	f7ff f833 	bl	801f112 <crs_strlen>
 80200ac:	b283      	uxth	r3, r0
 80200ae:	4622      	mov	r2, r4
 80200b0:	2102      	movs	r1, #2
 80200b2:	2003      	movs	r0, #3
 80200b4:	f7ff f892 	bl	801f1dc <traceIF_uartPrint>

  com_socket_msg_t msg_queue;
  socket_desc_t    *socket_desc;

  msg_queue = 0U;
  socket_desc = com_ip_modem_find_socket(sock, false);
 80200b8:	2100      	movs	r1, #0
 80200ba:	4630      	mov	r0, r6
 80200bc:	f7ff ff72 	bl	801ffa4 <com_ip_modem_find_socket>

  if (socket_desc != NULL)
 80200c0:	4606      	mov	r6, r0
 80200c2:	2800      	cmp	r0, #0
 80200c4:	f000 8093 	beq.w	80201ee <com_ip_modem_closing_cb+0x18a>
  {
    PRINT_INFO("cb socket closing called: close rqt")
 80200c8:	4c5f      	ldr	r4, [pc, #380]	; (8020248 <com_ip_modem_closing_cb+0x1e4>)
 80200ca:	4d5e      	ldr	r5, [pc, #376]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 80200cc:	f104 0720 	add.w	r7, r4, #32
 80200d0:	46a4      	mov	ip, r4
 80200d2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80200d6:	6028      	str	r0, [r5, #0]
 80200d8:	6069      	str	r1, [r5, #4]
 80200da:	60aa      	str	r2, [r5, #8]
 80200dc:	60eb      	str	r3, [r5, #12]
 80200de:	4664      	mov	r4, ip
 80200e0:	3510      	adds	r5, #16
 80200e2:	45bc      	cmp	ip, r7
 80200e4:	d1f4      	bne.n	80200d0 <com_ip_modem_closing_cb+0x6c>
 80200e6:	cc07      	ldmia	r4!, {r0, r1, r2}
 80200e8:	6028      	str	r0, [r5, #0]
 80200ea:	6069      	str	r1, [r5, #4]
 80200ec:	60aa      	str	r2, [r5, #8]
 80200ee:	8823      	ldrh	r3, [r4, #0]
 80200f0:	81ab      	strh	r3, [r5, #12]
 80200f2:	4c54      	ldr	r4, [pc, #336]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 80200f4:	4620      	mov	r0, r4
 80200f6:	f7ff f80c 	bl	801f112 <crs_strlen>
 80200fa:	b283      	uxth	r3, r0
 80200fc:	4622      	mov	r2, r4
 80200fe:	2101      	movs	r1, #1
 8020100:	2003      	movs	r0, #3
 8020102:	f7ff f849 	bl	801f198 <traceIF_itmPrint>
 8020106:	4620      	mov	r0, r4
 8020108:	f7ff f803 	bl	801f112 <crs_strlen>
 802010c:	b283      	uxth	r3, r0
 802010e:	4622      	mov	r2, r4
 8020110:	2101      	movs	r1, #1
 8020112:	2003      	movs	r0, #3
 8020114:	f7ff f862 	bl	801f1dc <traceIF_uartPrint>
    if (socket_desc->closing == false)
 8020118:	78b3      	ldrb	r3, [r6, #2]
 802011a:	b133      	cbz	r3, 802012a <com_ip_modem_closing_cb+0xc6>
    {
      socket_desc->closing = true;
      PRINT_INFO("cb socket closing: close rqt")
    }
    if ((socket_desc->state == COM_SOCKET_WAITING_RSP)
 802011c:	7833      	ldrb	r3, [r6, #0]
        || (socket_desc->state == COM_SOCKET_WAITING_FROM))
 802011e:	3b05      	subs	r3, #5
 8020120:	b2db      	uxtb	r3, r3
    if ((socket_desc->state == COM_SOCKET_WAITING_RSP)
 8020122:	2b01      	cmp	r3, #1
 8020124:	d92a      	bls.n	802017c <com_ip_modem_closing_cb+0x118>
  }
  else
  {
    PRINT_ERR("cb socket closing called: unknown socket")
  }
}
 8020126:	b003      	add	sp, #12
 8020128:	bdf0      	pop	{r4, r5, r6, r7, pc}
      socket_desc->closing = true;
 802012a:	2301      	movs	r3, #1
 802012c:	70b3      	strb	r3, [r6, #2]
      PRINT_INFO("cb socket closing: close rqt")
 802012e:	4f47      	ldr	r7, [pc, #284]	; (802024c <com_ip_modem_closing_cb+0x1e8>)
 8020130:	f107 0c20 	add.w	ip, r7, #32
 8020134:	463d      	mov	r5, r7
 8020136:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020138:	6020      	str	r0, [r4, #0]
 802013a:	6061      	str	r1, [r4, #4]
 802013c:	60a2      	str	r2, [r4, #8]
 802013e:	60e3      	str	r3, [r4, #12]
 8020140:	462f      	mov	r7, r5
 8020142:	3410      	adds	r4, #16
 8020144:	4565      	cmp	r5, ip
 8020146:	d1f5      	bne.n	8020134 <com_ip_modem_closing_cb+0xd0>
 8020148:	6828      	ldr	r0, [r5, #0]
 802014a:	6020      	str	r0, [r4, #0]
 802014c:	88aa      	ldrh	r2, [r5, #4]
 802014e:	79ab      	ldrb	r3, [r5, #6]
 8020150:	80a2      	strh	r2, [r4, #4]
 8020152:	71a3      	strb	r3, [r4, #6]
 8020154:	4c3b      	ldr	r4, [pc, #236]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 8020156:	4620      	mov	r0, r4
 8020158:	f7fe ffdb 	bl	801f112 <crs_strlen>
 802015c:	b283      	uxth	r3, r0
 802015e:	4622      	mov	r2, r4
 8020160:	2101      	movs	r1, #1
 8020162:	2003      	movs	r0, #3
 8020164:	f7ff f818 	bl	801f198 <traceIF_itmPrint>
 8020168:	4620      	mov	r0, r4
 802016a:	f7fe ffd2 	bl	801f112 <crs_strlen>
 802016e:	b283      	uxth	r3, r0
 8020170:	4622      	mov	r2, r4
 8020172:	2101      	movs	r1, #1
 8020174:	2003      	movs	r0, #3
 8020176:	f7ff f831 	bl	801f1dc <traceIF_uartPrint>
 802017a:	e7cf      	b.n	802011c <com_ip_modem_closing_cb+0xb8>
      PRINT_ERR("!!! cb socket %ld closing called: data_expected !!!", socket_desc->id)
 802017c:	4c31      	ldr	r4, [pc, #196]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 802017e:	68b2      	ldr	r2, [r6, #8]
 8020180:	4933      	ldr	r1, [pc, #204]	; (8020250 <com_ip_modem_closing_cb+0x1ec>)
 8020182:	4620      	mov	r0, r4
 8020184:	f005 fd74 	bl	8025c70 <sprintf>
 8020188:	4620      	mov	r0, r4
 802018a:	f7fe ffc2 	bl	801f112 <crs_strlen>
 802018e:	b283      	uxth	r3, r0
 8020190:	4622      	mov	r2, r4
 8020192:	2110      	movs	r1, #16
 8020194:	2003      	movs	r0, #3
 8020196:	f7fe ffff 	bl	801f198 <traceIF_itmPrint>
 802019a:	4620      	mov	r0, r4
 802019c:	f7fe ffb9 	bl	801f112 <crs_strlen>
 80201a0:	b283      	uxth	r3, r0
 80201a2:	4622      	mov	r2, r4
 80201a4:	2110      	movs	r1, #16
 80201a6:	2003      	movs	r0, #3
 80201a8:	f7ff f818 	bl	801f1dc <traceIF_uartPrint>
      PRINT_DBG("cb socket %ld MSGput %lu queue %p", socket_desc->id, msg_queue, socket_desc->queue)
 80201ac:	4d29      	ldr	r5, [pc, #164]	; (8020254 <com_ip_modem_closing_cb+0x1f0>)
 80201ae:	68b2      	ldr	r2, [r6, #8]
 80201b0:	69f3      	ldr	r3, [r6, #28]
 80201b2:	9300      	str	r3, [sp, #0]
 80201b4:	462b      	mov	r3, r5
 80201b6:	4928      	ldr	r1, [pc, #160]	; (8020258 <com_ip_modem_closing_cb+0x1f4>)
 80201b8:	4620      	mov	r0, r4
 80201ba:	f005 fd59 	bl	8025c70 <sprintf>
 80201be:	4620      	mov	r0, r4
 80201c0:	f7fe ffa7 	bl	801f112 <crs_strlen>
 80201c4:	b283      	uxth	r3, r0
 80201c6:	4622      	mov	r2, r4
 80201c8:	2102      	movs	r1, #2
 80201ca:	2003      	movs	r0, #3
 80201cc:	f7fe ffe4 	bl	801f198 <traceIF_itmPrint>
 80201d0:	4620      	mov	r0, r4
 80201d2:	f7fe ff9e 	bl	801f112 <crs_strlen>
 80201d6:	b283      	uxth	r3, r0
 80201d8:	4622      	mov	r2, r4
 80201da:	2102      	movs	r1, #2
 80201dc:	2003      	movs	r0, #3
 80201de:	f7fe fffd 	bl	801f1dc <traceIF_uartPrint>
      (void)rtosalMessageQueuePut(socket_desc->queue, msg_queue, 0U);
 80201e2:	2200      	movs	r2, #0
 80201e4:	4629      	mov	r1, r5
 80201e6:	69f0      	ldr	r0, [r6, #28]
 80201e8:	f7fe fec1 	bl	801ef6e <rtosalMessageQueuePut>
 80201ec:	e79b      	b.n	8020126 <com_ip_modem_closing_cb+0xc2>
    PRINT_ERR("cb socket closing called: unknown socket")
 80201ee:	4d1b      	ldr	r5, [pc, #108]	; (802025c <com_ip_modem_closing_cb+0x1f8>)
 80201f0:	4c14      	ldr	r4, [pc, #80]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 80201f2:	f105 0630 	add.w	r6, r5, #48	; 0x30
 80201f6:	46ac      	mov	ip, r5
 80201f8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80201fc:	6020      	str	r0, [r4, #0]
 80201fe:	6061      	str	r1, [r4, #4]
 8020200:	60a2      	str	r2, [r4, #8]
 8020202:	60e3      	str	r3, [r4, #12]
 8020204:	4665      	mov	r5, ip
 8020206:	3410      	adds	r4, #16
 8020208:	45b4      	cmp	ip, r6
 802020a:	d1f4      	bne.n	80201f6 <com_ip_modem_closing_cb+0x192>
 802020c:	cd03      	ldmia	r5!, {r0, r1}
 802020e:	6020      	str	r0, [r4, #0]
 8020210:	6061      	str	r1, [r4, #4]
 8020212:	782b      	ldrb	r3, [r5, #0]
 8020214:	7223      	strb	r3, [r4, #8]
 8020216:	4c0b      	ldr	r4, [pc, #44]	; (8020244 <com_ip_modem_closing_cb+0x1e0>)
 8020218:	4620      	mov	r0, r4
 802021a:	f7fe ff7a 	bl	801f112 <crs_strlen>
 802021e:	b283      	uxth	r3, r0
 8020220:	4622      	mov	r2, r4
 8020222:	2110      	movs	r1, #16
 8020224:	2003      	movs	r0, #3
 8020226:	f7fe ffb7 	bl	801f198 <traceIF_itmPrint>
 802022a:	4620      	mov	r0, r4
 802022c:	f7fe ff71 	bl	801f112 <crs_strlen>
 8020230:	b283      	uxth	r3, r0
 8020232:	4622      	mov	r2, r4
 8020234:	2110      	movs	r1, #16
 8020236:	2003      	movs	r0, #3
 8020238:	f7fe ffd0 	bl	801f1dc <traceIF_uartPrint>
}
 802023c:	e773      	b.n	8020126 <com_ip_modem_closing_cb+0xc2>
 802023e:	bf00      	nop
 8020240:	08035338 	.word	0x08035338
 8020244:	200049dc 	.word	0x200049dc
 8020248:	08035364 	.word	0x08035364
 802024c:	08035394 	.word	0x08035394
 8020250:	080353bc 	.word	0x080353bc
 8020254:	00020001 	.word	0x00020001
 8020258:	08035400 	.word	0x08035400
 802025c:	0803542c 	.word	0x0803542c

08020260 <com_ip_modem_data_ready_cb>:
{
 8020260:	b530      	push	{r4, r5, lr}
 8020262:	b083      	sub	sp, #12
  socket_desc = com_ip_modem_find_socket(sock, false);
 8020264:	2100      	movs	r1, #0
 8020266:	f7ff fe9d 	bl	801ffa4 <com_ip_modem_find_socket>
  if (socket_desc != NULL)
 802026a:	2800      	cmp	r0, #0
 802026c:	f000 80c2 	beq.w	80203f4 <com_ip_modem_data_ready_cb+0x194>
 8020270:	4604      	mov	r4, r0
    if (socket_desc->closing != true)
 8020272:	7883      	ldrb	r3, [r0, #2]
 8020274:	2b00      	cmp	r3, #0
 8020276:	f040 8092 	bne.w	802039e <com_ip_modem_data_ready_cb+0x13e>
      if (socket_desc->state == COM_SOCKET_WAITING_RSP)
 802027a:	7802      	ldrb	r2, [r0, #0]
 802027c:	2a05      	cmp	r2, #5
 802027e:	d01a      	beq.n	80202b6 <com_ip_modem_data_ready_cb+0x56>
      else if (socket_desc->state == COM_SOCKET_WAITING_FROM)
 8020280:	2a06      	cmp	r2, #6
 8020282:	d052      	beq.n	802032a <com_ip_modem_data_ready_cb+0xca>
        PRINT_INFO("cb socket data ready called: socket_state:%i NOK",
 8020284:	4c6f      	ldr	r4, [pc, #444]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 8020286:	4970      	ldr	r1, [pc, #448]	; (8020448 <com_ip_modem_data_ready_cb+0x1e8>)
 8020288:	4620      	mov	r0, r4
 802028a:	f005 fcf1 	bl	8025c70 <sprintf>
 802028e:	4620      	mov	r0, r4
 8020290:	f7fe ff3f 	bl	801f112 <crs_strlen>
 8020294:	b283      	uxth	r3, r0
 8020296:	4622      	mov	r2, r4
 8020298:	2101      	movs	r1, #1
 802029a:	2003      	movs	r0, #3
 802029c:	f7fe ff7c 	bl	801f198 <traceIF_itmPrint>
 80202a0:	4620      	mov	r0, r4
 80202a2:	f7fe ff36 	bl	801f112 <crs_strlen>
 80202a6:	b283      	uxth	r3, r0
 80202a8:	4622      	mov	r2, r4
 80202aa:	2101      	movs	r1, #1
 80202ac:	2003      	movs	r0, #3
 80202ae:	f7fe ff95 	bl	801f1dc <traceIF_uartPrint>
}
 80202b2:	b003      	add	sp, #12
 80202b4:	bd30      	pop	{r4, r5, pc}
        PRINT_INFO("cb socket %ld data ready called: waiting rsp", socket_desc->id)
 80202b6:	4d63      	ldr	r5, [pc, #396]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 80202b8:	6882      	ldr	r2, [r0, #8]
 80202ba:	4964      	ldr	r1, [pc, #400]	; (802044c <com_ip_modem_data_ready_cb+0x1ec>)
 80202bc:	4628      	mov	r0, r5
 80202be:	f005 fcd7 	bl	8025c70 <sprintf>
 80202c2:	4628      	mov	r0, r5
 80202c4:	f7fe ff25 	bl	801f112 <crs_strlen>
 80202c8:	b283      	uxth	r3, r0
 80202ca:	462a      	mov	r2, r5
 80202cc:	2101      	movs	r1, #1
 80202ce:	2003      	movs	r0, #3
 80202d0:	f7fe ff62 	bl	801f198 <traceIF_itmPrint>
 80202d4:	4628      	mov	r0, r5
 80202d6:	f7fe ff1c 	bl	801f112 <crs_strlen>
 80202da:	b283      	uxth	r3, r0
 80202dc:	462a      	mov	r2, r5
 80202de:	2101      	movs	r1, #1
 80202e0:	2003      	movs	r0, #3
 80202e2:	f7fe ff7b 	bl	801f1dc <traceIF_uartPrint>
        PRINT_DBG("cb socket %ld MSGput %lu queue %p", socket_desc->id, msg_queue, socket_desc->queue)
 80202e6:	68a2      	ldr	r2, [r4, #8]
 80202e8:	69e3      	ldr	r3, [r4, #28]
 80202ea:	9300      	str	r3, [sp, #0]
 80202ec:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80202f0:	4957      	ldr	r1, [pc, #348]	; (8020450 <com_ip_modem_data_ready_cb+0x1f0>)
 80202f2:	4628      	mov	r0, r5
 80202f4:	f005 fcbc 	bl	8025c70 <sprintf>
 80202f8:	4628      	mov	r0, r5
 80202fa:	f7fe ff0a 	bl	801f112 <crs_strlen>
 80202fe:	b283      	uxth	r3, r0
 8020300:	462a      	mov	r2, r5
 8020302:	2102      	movs	r1, #2
 8020304:	2003      	movs	r0, #3
 8020306:	f7fe ff47 	bl	801f198 <traceIF_itmPrint>
 802030a:	4628      	mov	r0, r5
 802030c:	f7fe ff01 	bl	801f112 <crs_strlen>
 8020310:	b283      	uxth	r3, r0
 8020312:	462a      	mov	r2, r5
 8020314:	2102      	movs	r1, #2
 8020316:	2003      	movs	r0, #3
 8020318:	f7fe ff60 	bl	801f1dc <traceIF_uartPrint>
        (void)rtosalMessageQueuePut(socket_desc->queue, msg_queue, 0U);
 802031c:	2200      	movs	r2, #0
 802031e:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8020322:	69e0      	ldr	r0, [r4, #28]
 8020324:	f7fe fe23 	bl	801ef6e <rtosalMessageQueuePut>
 8020328:	e7c3      	b.n	80202b2 <com_ip_modem_data_ready_cb+0x52>
        PRINT_INFO("cb socket %ld data ready called: waiting from", socket_desc->id)
 802032a:	4d46      	ldr	r5, [pc, #280]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 802032c:	6882      	ldr	r2, [r0, #8]
 802032e:	4949      	ldr	r1, [pc, #292]	; (8020454 <com_ip_modem_data_ready_cb+0x1f4>)
 8020330:	4628      	mov	r0, r5
 8020332:	f005 fc9d 	bl	8025c70 <sprintf>
 8020336:	4628      	mov	r0, r5
 8020338:	f7fe feeb 	bl	801f112 <crs_strlen>
 802033c:	b283      	uxth	r3, r0
 802033e:	462a      	mov	r2, r5
 8020340:	2101      	movs	r1, #1
 8020342:	2003      	movs	r0, #3
 8020344:	f7fe ff28 	bl	801f198 <traceIF_itmPrint>
 8020348:	4628      	mov	r0, r5
 802034a:	f7fe fee2 	bl	801f112 <crs_strlen>
 802034e:	b283      	uxth	r3, r0
 8020350:	462a      	mov	r2, r5
 8020352:	2101      	movs	r1, #1
 8020354:	2003      	movs	r0, #3
 8020356:	f7fe ff41 	bl	801f1dc <traceIF_uartPrint>
        PRINT_DBG("cb socket %ld MSGput %lu queue %p", socket_desc->id, msg_queue, socket_desc->queue)
 802035a:	68a2      	ldr	r2, [r4, #8]
 802035c:	69e3      	ldr	r3, [r4, #28]
 802035e:	9300      	str	r3, [sp, #0]
 8020360:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8020364:	493a      	ldr	r1, [pc, #232]	; (8020450 <com_ip_modem_data_ready_cb+0x1f0>)
 8020366:	4628      	mov	r0, r5
 8020368:	f005 fc82 	bl	8025c70 <sprintf>
 802036c:	4628      	mov	r0, r5
 802036e:	f7fe fed0 	bl	801f112 <crs_strlen>
 8020372:	b283      	uxth	r3, r0
 8020374:	462a      	mov	r2, r5
 8020376:	2102      	movs	r1, #2
 8020378:	2003      	movs	r0, #3
 802037a:	f7fe ff0d 	bl	801f198 <traceIF_itmPrint>
 802037e:	4628      	mov	r0, r5
 8020380:	f7fe fec7 	bl	801f112 <crs_strlen>
 8020384:	b283      	uxth	r3, r0
 8020386:	462a      	mov	r2, r5
 8020388:	2102      	movs	r1, #2
 802038a:	2003      	movs	r0, #3
 802038c:	f7fe ff26 	bl	801f1dc <traceIF_uartPrint>
        (void)rtosalMessageQueuePut(socket_desc->queue, msg_queue, 0U);
 8020390:	2200      	movs	r2, #0
 8020392:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8020396:	69e0      	ldr	r0, [r4, #28]
 8020398:	f7fe fde9 	bl	801ef6e <rtosalMessageQueuePut>
 802039c:	e789      	b.n	80202b2 <com_ip_modem_data_ready_cb+0x52>
      PRINT_ERR("cb socket data ready called: socket is closing")
 802039e:	4d2e      	ldr	r5, [pc, #184]	; (8020458 <com_ip_modem_data_ready_cb+0x1f8>)
 80203a0:	4c28      	ldr	r4, [pc, #160]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 80203a2:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80203a6:	46ac      	mov	ip, r5
 80203a8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80203ac:	6020      	str	r0, [r4, #0]
 80203ae:	6061      	str	r1, [r4, #4]
 80203b0:	60a2      	str	r2, [r4, #8]
 80203b2:	60e3      	str	r3, [r4, #12]
 80203b4:	4665      	mov	r5, ip
 80203b6:	3410      	adds	r4, #16
 80203b8:	45f4      	cmp	ip, lr
 80203ba:	d1f4      	bne.n	80203a6 <com_ip_modem_data_ready_cb+0x146>
 80203bc:	cd07      	ldmia	r5!, {r0, r1, r2}
 80203be:	6020      	str	r0, [r4, #0]
 80203c0:	6061      	str	r1, [r4, #4]
 80203c2:	60a2      	str	r2, [r4, #8]
 80203c4:	882a      	ldrh	r2, [r5, #0]
 80203c6:	78ab      	ldrb	r3, [r5, #2]
 80203c8:	81a2      	strh	r2, [r4, #12]
 80203ca:	73a3      	strb	r3, [r4, #14]
 80203cc:	4c1d      	ldr	r4, [pc, #116]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 80203ce:	4620      	mov	r0, r4
 80203d0:	f7fe fe9f 	bl	801f112 <crs_strlen>
 80203d4:	b283      	uxth	r3, r0
 80203d6:	4622      	mov	r2, r4
 80203d8:	2110      	movs	r1, #16
 80203da:	2003      	movs	r0, #3
 80203dc:	f7fe fedc 	bl	801f198 <traceIF_itmPrint>
 80203e0:	4620      	mov	r0, r4
 80203e2:	f7fe fe96 	bl	801f112 <crs_strlen>
 80203e6:	b283      	uxth	r3, r0
 80203e8:	4622      	mov	r2, r4
 80203ea:	2110      	movs	r1, #16
 80203ec:	2003      	movs	r0, #3
 80203ee:	f7fe fef5 	bl	801f1dc <traceIF_uartPrint>
 80203f2:	e75e      	b.n	80202b2 <com_ip_modem_data_ready_cb+0x52>
    PRINT_ERR("cb socket data ready called: unknown socket")
 80203f4:	4d19      	ldr	r5, [pc, #100]	; (802045c <com_ip_modem_data_ready_cb+0x1fc>)
 80203f6:	4c13      	ldr	r4, [pc, #76]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 80203f8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80203fc:	46ac      	mov	ip, r5
 80203fe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020402:	6020      	str	r0, [r4, #0]
 8020404:	6061      	str	r1, [r4, #4]
 8020406:	60a2      	str	r2, [r4, #8]
 8020408:	60e3      	str	r3, [r4, #12]
 802040a:	4665      	mov	r5, ip
 802040c:	3410      	adds	r4, #16
 802040e:	45f4      	cmp	ip, lr
 8020410:	d1f4      	bne.n	80203fc <com_ip_modem_data_ready_cb+0x19c>
 8020412:	cd07      	ldmia	r5!, {r0, r1, r2}
 8020414:	6020      	str	r0, [r4, #0]
 8020416:	6061      	str	r1, [r4, #4]
 8020418:	60a2      	str	r2, [r4, #8]
 802041a:	4c0a      	ldr	r4, [pc, #40]	; (8020444 <com_ip_modem_data_ready_cb+0x1e4>)
 802041c:	4620      	mov	r0, r4
 802041e:	f7fe fe78 	bl	801f112 <crs_strlen>
 8020422:	b283      	uxth	r3, r0
 8020424:	4622      	mov	r2, r4
 8020426:	2110      	movs	r1, #16
 8020428:	2003      	movs	r0, #3
 802042a:	f7fe feb5 	bl	801f198 <traceIF_itmPrint>
 802042e:	4620      	mov	r0, r4
 8020430:	f7fe fe6f 	bl	801f112 <crs_strlen>
 8020434:	b283      	uxth	r3, r0
 8020436:	4622      	mov	r2, r4
 8020438:	2110      	movs	r1, #16
 802043a:	2003      	movs	r0, #3
 802043c:	f7fe fece 	bl	801f1dc <traceIF_uartPrint>
}
 8020440:	e737      	b.n	80202b2 <com_ip_modem_data_ready_cb+0x52>
 8020442:	bf00      	nop
 8020444:	200049dc 	.word	0x200049dc
 8020448:	080354d8 	.word	0x080354d8
 802044c:	08035468 	.word	0x08035468
 8020450:	08035400 	.word	0x08035400
 8020454:	080354a0 	.word	0x080354a0
 8020458:	08035514 	.word	0x08035514
 802045c:	08035554 	.word	0x08035554

08020460 <com_ip_modem_init_socket_desc>:
  socket_desc->state            = COM_SOCKET_INVALID;
 8020460:	2300      	movs	r3, #0
 8020462:	7003      	strb	r3, [r0, #0]
  socket_desc->local            = false;
 8020464:	7043      	strb	r3, [r0, #1]
  socket_desc->closing          = false;
 8020466:	7083      	strb	r3, [r0, #2]
  socket_desc->id               = COM_SOCKET_INVALID_ID;
 8020468:	f04f 32ff 	mov.w	r2, #4294967295
 802046c:	6082      	str	r2, [r0, #8]
  socket_desc->local_port       = 0U;
 802046e:	8183      	strh	r3, [r0, #12]
  socket_desc->remote_port      = 0U;
 8020470:	81c3      	strh	r3, [r0, #14]
  socket_desc->remote_addr.addr = 0U;
 8020472:	6103      	str	r3, [r0, #16]
  (void)memset((void *)&socket_desc->remote_addr, 0, sizeof(socket_desc->remote_addr));
 8020474:	6103      	str	r3, [r0, #16]
  socket_desc->rcv_timeout      = RTOSAL_WAIT_FOREVER;
 8020476:	6182      	str	r2, [r0, #24]
  socket_desc->snd_timeout      = RTOSAL_WAIT_FOREVER;
 8020478:	6142      	str	r2, [r0, #20]
  socket_desc->error            = COM_SOCKETS_ERR_OK;
 802047a:	6043      	str	r3, [r0, #4]
}
 802047c:	4770      	bx	lr

0802047e <com_ip_modem_create_socket_desc>:
{
 802047e:	b538      	push	{r3, r4, r5, lr}
  socket_desc = (socket_desc_t *)pvPortMalloc(sizeof(socket_desc_t));
 8020480:	2028      	movs	r0, #40	; 0x28
 8020482:	f003 fb27 	bl	8023ad4 <pvPortMalloc>
  if (socket_desc != NULL)
 8020486:	4604      	mov	r4, r0
 8020488:	b158      	cbz	r0, 80204a2 <com_ip_modem_create_socket_desc+0x24>
    socket_desc->queue = rtosalMessageQueueNew(NULL, 4U);
 802048a:	2104      	movs	r1, #4
 802048c:	2000      	movs	r0, #0
 802048e:	f7fe fd62 	bl	801ef56 <rtosalMessageQueueNew>
 8020492:	4605      	mov	r5, r0
 8020494:	61e0      	str	r0, [r4, #28]
    if (socket_desc->queue == NULL)
 8020496:	b130      	cbz	r0, 80204a6 <com_ip_modem_create_socket_desc+0x28>
      socket_desc->next = NULL;
 8020498:	2300      	movs	r3, #0
 802049a:	6263      	str	r3, [r4, #36]	; 0x24
      com_ip_modem_init_socket_desc(socket_desc);
 802049c:	4620      	mov	r0, r4
 802049e:	f7ff ffdf 	bl	8020460 <com_ip_modem_init_socket_desc>
}
 80204a2:	4620      	mov	r0, r4
 80204a4:	bd38      	pop	{r3, r4, r5, pc}
      vPortFree(socket_desc);
 80204a6:	4620      	mov	r0, r4
 80204a8:	f003 fb8c 	bl	8023bc4 <vPortFree>
      socket_desc = NULL;
 80204ac:	462c      	mov	r4, r5
 80204ae:	e7f8      	b.n	80204a2 <com_ip_modem_create_socket_desc+0x24>

080204b0 <com_ip_modem_provide_socket_desc>:
{
 80204b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80204b4:	4606      	mov	r6, r0
  (void)rtosalMutexAcquire(ComSocketsMutexHandle, RTOSAL_WAIT_FOREVER);
 80204b6:	f04f 31ff 	mov.w	r1, #4294967295
 80204ba:	4b2e      	ldr	r3, [pc, #184]	; (8020574 <com_ip_modem_provide_socket_desc+0xc4>)
 80204bc:	6818      	ldr	r0, [r3, #0]
 80204be:	f7fe fd42 	bl	801ef46 <rtosalMutexAcquire>
  socket_desc = socket_desc_list;
 80204c2:	4b2d      	ldr	r3, [pc, #180]	; (8020578 <com_ip_modem_provide_socket_desc+0xc8>)
 80204c4:	681d      	ldr	r5, [r3, #0]
  if (local == true)
 80204c6:	b996      	cbnz	r6, 80204ee <com_ip_modem_provide_socket_desc+0x3e>
  i = 0U;
 80204c8:	2400      	movs	r4, #0
  if ((found == true) && (i < COM_SOCKET_LOCAL_ID_NB))
 80204ca:	b1bc      	cbz	r4, 80204fc <com_ip_modem_provide_socket_desc+0x4c>
  (void)rtosalMutexRelease(ComSocketsMutexHandle);
 80204cc:	4b29      	ldr	r3, [pc, #164]	; (8020574 <com_ip_modem_provide_socket_desc+0xc4>)
 80204ce:	6818      	ldr	r0, [r3, #0]
 80204d0:	f7fe fd3d 	bl	801ef4e <rtosalMutexRelease>
}
 80204d4:	4628      	mov	r0, r5
 80204d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        i++;
 80204da:	3401      	adds	r4, #1
 80204dc:	b2e4      	uxtb	r4, r4
    while ((i < COM_SOCKET_LOCAL_ID_NB) && (found == false))
 80204de:	b94c      	cbnz	r4, 80204f4 <com_ip_modem_provide_socket_desc+0x44>
 80204e0:	b942      	cbnz	r2, 80204f4 <com_ip_modem_provide_socket_desc+0x44>
      if (socket_local_id[i] == false)
 80204e2:	4b26      	ldr	r3, [pc, #152]	; (802057c <com_ip_modem_provide_socket_desc+0xcc>)
 80204e4:	5d1b      	ldrb	r3, [r3, r4]
 80204e6:	2b00      	cmp	r3, #0
 80204e8:	d1f7      	bne.n	80204da <com_ip_modem_provide_socket_desc+0x2a>
        found = true; /* an unused local id has been found */
 80204ea:	4632      	mov	r2, r6
 80204ec:	e7f7      	b.n	80204de <com_ip_modem_provide_socket_desc+0x2e>
  i = 0U;
 80204ee:	2400      	movs	r4, #0
  found = false;
 80204f0:	4622      	mov	r2, r4
 80204f2:	e7f4      	b.n	80204de <com_ip_modem_provide_socket_desc+0x2e>
  if ((found == true) && (i < COM_SOCKET_LOCAL_ID_NB))
 80204f4:	2a00      	cmp	r2, #0
 80204f6:	d0e9      	beq.n	80204cc <com_ip_modem_provide_socket_desc+0x1c>
 80204f8:	e7e7      	b.n	80204ca <com_ip_modem_provide_socket_desc+0x1a>
      socket_desc = socket_desc->next; /* Check next descriptor */
 80204fa:	461d      	mov	r5, r3
    while ((socket_desc->state != COM_SOCKET_INVALID)
 80204fc:	782a      	ldrb	r2, [r5, #0]
           && (socket_desc->next != NULL))
 80204fe:	b112      	cbz	r2, 8020506 <com_ip_modem_provide_socket_desc+0x56>
 8020500:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8020502:	2b00      	cmp	r3, #0
 8020504:	d1f9      	bne.n	80204fa <com_ip_modem_provide_socket_desc+0x4a>
    if (socket_desc->state != COM_SOCKET_INVALID)
 8020506:	b94a      	cbnz	r2, 802051c <com_ip_modem_provide_socket_desc+0x6c>
      socket_desc->state = COM_SOCKET_CREATING;
 8020508:	2301      	movs	r3, #1
 802050a:	702b      	strb	r3, [r5, #0]
      socket_desc->local = local;
 802050c:	706e      	strb	r6, [r5, #1]
      if (local == true)
 802050e:	2e00      	cmp	r6, #0
 8020510:	d0dc      	beq.n	80204cc <com_ip_modem_provide_socket_desc+0x1c>
        socket_desc->id = (int32_t)i;
 8020512:	60ac      	str	r4, [r5, #8]
        socket_local_id[i] = true;
 8020514:	4b19      	ldr	r3, [pc, #100]	; (802057c <com_ip_modem_provide_socket_desc+0xcc>)
 8020516:	2201      	movs	r2, #1
 8020518:	551a      	strb	r2, [r3, r4]
 802051a:	e7d7      	b.n	80204cc <com_ip_modem_provide_socket_desc+0x1c>
      socket_desc = com_ip_modem_create_socket_desc();
 802051c:	f7ff ffaf 	bl	802047e <com_ip_modem_create_socket_desc>
      if (socket_desc != NULL)
 8020520:	4607      	mov	r7, r0
 8020522:	b320      	cbz	r0, 802056e <com_ip_modem_provide_socket_desc+0xbe>
        PRINT_DBG("socket desc created %ld queue %p", socket_desc->id, socket_desc->queue)
 8020524:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8020584 <com_ip_modem_provide_socket_desc+0xd4>
 8020528:	69c3      	ldr	r3, [r0, #28]
 802052a:	6882      	ldr	r2, [r0, #8]
 802052c:	4914      	ldr	r1, [pc, #80]	; (8020580 <com_ip_modem_provide_socket_desc+0xd0>)
 802052e:	4640      	mov	r0, r8
 8020530:	f005 fb9e 	bl	8025c70 <sprintf>
 8020534:	4640      	mov	r0, r8
 8020536:	f7fe fdec 	bl	801f112 <crs_strlen>
 802053a:	b283      	uxth	r3, r0
 802053c:	4642      	mov	r2, r8
 802053e:	2102      	movs	r1, #2
 8020540:	2003      	movs	r0, #3
 8020542:	f7fe fe29 	bl	801f198 <traceIF_itmPrint>
 8020546:	4640      	mov	r0, r8
 8020548:	f7fe fde3 	bl	801f112 <crs_strlen>
 802054c:	b283      	uxth	r3, r0
 802054e:	4642      	mov	r2, r8
 8020550:	2102      	movs	r1, #2
 8020552:	2003      	movs	r0, #3
 8020554:	f7fe fe42 	bl	801f1dc <traceIF_uartPrint>
        socket_desc->state = COM_SOCKET_CREATING;
 8020558:	2301      	movs	r3, #1
 802055a:	703b      	strb	r3, [r7, #0]
        socket_desc->local = local;
 802055c:	707e      	strb	r6, [r7, #1]
        if (local == true)
 802055e:	b11e      	cbz	r6, 8020568 <com_ip_modem_provide_socket_desc+0xb8>
          socket_desc->id = (int32_t)i;
 8020560:	60bc      	str	r4, [r7, #8]
          socket_local_id[i] = true;
 8020562:	4b06      	ldr	r3, [pc, #24]	; (802057c <com_ip_modem_provide_socket_desc+0xcc>)
 8020564:	2201      	movs	r2, #1
 8020566:	551a      	strb	r2, [r3, r4]
        socket_desc_previous->next = socket_desc;
 8020568:	626f      	str	r7, [r5, #36]	; 0x24
      socket_desc = com_ip_modem_create_socket_desc();
 802056a:	463d      	mov	r5, r7
 802056c:	e7ae      	b.n	80204cc <com_ip_modem_provide_socket_desc+0x1c>
 802056e:	4605      	mov	r5, r0
 8020570:	e7ac      	b.n	80204cc <com_ip_modem_provide_socket_desc+0x1c>
 8020572:	bf00      	nop
 8020574:	200058a0 	.word	0x200058a0
 8020578:	200058a8 	.word	0x200058a8
 802057c:	200058ac 	.word	0x200058ac
 8020580:	08035590 	.word	0x08035590
 8020584:	200049dc 	.word	0x200049dc

08020588 <com_ip_modem_delete_socket_desc>:
{
 8020588:	b538      	push	{r3, r4, r5, lr}
 802058a:	4604      	mov	r4, r0
 802058c:	460d      	mov	r5, r1
  (void)rtosalMutexAcquire(ComSocketsMutexHandle, RTOSAL_WAIT_FOREVER);
 802058e:	f04f 31ff 	mov.w	r1, #4294967295
 8020592:	4b10      	ldr	r3, [pc, #64]	; (80205d4 <com_ip_modem_delete_socket_desc+0x4c>)
 8020594:	6818      	ldr	r0, [r3, #0]
 8020596:	f7fe fcd6 	bl	801ef46 <rtosalMutexAcquire>
  socket_desc = socket_desc_list;
 802059a:	4b0f      	ldr	r3, [pc, #60]	; (80205d8 <com_ip_modem_delete_socket_desc+0x50>)
 802059c:	6818      	ldr	r0, [r3, #0]
  found = false;
 802059e:	2200      	movs	r2, #0
  while ((socket_desc != NULL)
 80205a0:	e000      	b.n	80205a4 <com_ip_modem_delete_socket_desc+0x1c>
      socket_desc = socket_desc->next;
 80205a2:	6a40      	ldr	r0, [r0, #36]	; 0x24
         && (found != true))
 80205a4:	b140      	cbz	r0, 80205b8 <com_ip_modem_delete_socket_desc+0x30>
 80205a6:	b93a      	cbnz	r2, 80205b8 <com_ip_modem_delete_socket_desc+0x30>
    if ((socket_desc->id == sock)
 80205a8:	6883      	ldr	r3, [r0, #8]
 80205aa:	42a3      	cmp	r3, r4
 80205ac:	d1f9      	bne.n	80205a2 <com_ip_modem_delete_socket_desc+0x1a>
        && (socket_desc->local == local))
 80205ae:	7843      	ldrb	r3, [r0, #1]
 80205b0:	42ab      	cmp	r3, r5
 80205b2:	d1f6      	bne.n	80205a2 <com_ip_modem_delete_socket_desc+0x1a>
      found = true;
 80205b4:	2201      	movs	r2, #1
 80205b6:	e7f5      	b.n	80205a4 <com_ip_modem_delete_socket_desc+0x1c>
  if (found == true)
 80205b8:	b922      	cbnz	r2, 80205c4 <com_ip_modem_delete_socket_desc+0x3c>
  (void)rtosalMutexRelease(ComSocketsMutexHandle);
 80205ba:	4b06      	ldr	r3, [pc, #24]	; (80205d4 <com_ip_modem_delete_socket_desc+0x4c>)
 80205bc:	6818      	ldr	r0, [r3, #0]
 80205be:	f7fe fcc6 	bl	801ef4e <rtosalMutexRelease>
}
 80205c2:	bd38      	pop	{r3, r4, r5, pc}
    com_ip_modem_init_socket_desc(socket_desc);
 80205c4:	f7ff ff4c 	bl	8020460 <com_ip_modem_init_socket_desc>
    if (local == true)
 80205c8:	2d00      	cmp	r5, #0
 80205ca:	d0f6      	beq.n	80205ba <com_ip_modem_delete_socket_desc+0x32>
      socket_local_id[sock] = false;
 80205cc:	4b03      	ldr	r3, [pc, #12]	; (80205dc <com_ip_modem_delete_socket_desc+0x54>)
 80205ce:	2200      	movs	r2, #0
 80205d0:	551a      	strb	r2, [r3, r4]
 80205d2:	e7f2      	b.n	80205ba <com_ip_modem_delete_socket_desc+0x32>
 80205d4:	200058a0 	.word	0x200058a0
 80205d8:	200058a8 	.word	0x200058a8
 80205dc:	200058ac 	.word	0x200058ac

080205e0 <com_convert_ipaddr_port_to_sockaddr>:
  sockaddr_in->sin_len         = (uint8_t)sizeof(com_sockaddr_in_t);
 80205e0:	2310      	movs	r3, #16
 80205e2:	7013      	strb	r3, [r2, #0]
  sockaddr_in->sin_family      = COM_AF_INET;
 80205e4:	2302      	movs	r3, #2
 80205e6:	7053      	strb	r3, [r2, #1]
  sockaddr_in->sin_addr.s_addr = ip_addr->addr;
 80205e8:	6803      	ldr	r3, [r0, #0]
 80205ea:	6053      	str	r3, [r2, #4]
  sockaddr_in->sin_port        = COM_HTONS(port);
 80205ec:	ba49      	rev16	r1, r1
 80205ee:	8051      	strh	r1, [r2, #2]
  (void) memset(sockaddr_in->sin_zero, 0, COM_SIN_ZERO_LEN);
 80205f0:	2300      	movs	r3, #0
 80205f2:	6093      	str	r3, [r2, #8]
 80205f4:	60d3      	str	r3, [r2, #12]
}
 80205f6:	4770      	bx	lr

080205f8 <com_translate_ip_address>:
  if (addrlen == (int32_t)sizeof(com_sockaddr_in_t))
 80205f8:	2910      	cmp	r1, #16
 80205fa:	d001      	beq.n	8020600 <com_translate_ip_address+0x8>
  result = false;
 80205fc:	2000      	movs	r0, #0
}
 80205fe:	4770      	bx	lr
{
 8020600:	b530      	push	{r4, r5, lr}
 8020602:	b083      	sub	sp, #12
 8020604:	4604      	mov	r4, r0
 8020606:	4615      	mov	r5, r2
    if ((addr != NULL)
 8020608:	b328      	cbz	r0, 8020656 <com_translate_ip_address+0x5e>
        && (socket_addr != NULL))
 802060a:	b332      	cbz	r2, 802065a <com_translate_ip_address+0x62>
      if (addr->sa_family == (uint8_t)COM_AF_INET)
 802060c:	7843      	ldrb	r3, [r0, #1]
 802060e:	2b02      	cmp	r3, #2
 8020610:	d002      	beq.n	8020618 <com_translate_ip_address+0x20>
  result = false;
 8020612:	2000      	movs	r0, #0
}
 8020614:	b003      	add	sp, #12
 8020616:	bd30      	pop	{r4, r5, pc}
        socket_addr->ip_type = CS_IPAT_IPV4;
 8020618:	2301      	movs	r3, #1
 802061a:	7013      	strb	r3, [r2, #0]
        if (p_sockaddr_in->sin_addr.s_addr == COM_INADDR_ANY)
 802061c:	6842      	ldr	r2, [r0, #4]
 802061e:	b96a      	cbnz	r2, 802063c <com_translate_ip_address+0x44>
          (void)memcpy(&socket_addr->ip_value[0], "0.0.0.0", strlen("0.0.0.0"));
 8020620:	4b0f      	ldr	r3, [pc, #60]	; (8020660 <com_translate_ip_address+0x68>)
 8020622:	6818      	ldr	r0, [r3, #0]
 8020624:	f8c5 0001 	str.w	r0, [r5, #1]
 8020628:	889a      	ldrh	r2, [r3, #4]
 802062a:	799b      	ldrb	r3, [r3, #6]
 802062c:	f8a5 2005 	strh.w	r2, [r5, #5]
 8020630:	71eb      	strb	r3, [r5, #7]
        socket_addr->port = COM_NTOHS(((const com_sockaddr_in_t *)addr)->sin_port);
 8020632:	8863      	ldrh	r3, [r4, #2]
 8020634:	ba5b      	rev16	r3, r3
 8020636:	856b      	strh	r3, [r5, #42]	; 0x2a
        result = true;
 8020638:	2001      	movs	r0, #1
 802063a:	e7eb      	b.n	8020614 <com_translate_ip_address+0x1c>
          (void)sprintf((CSIP_CHAR_t *)socket_addr->ip_value,
 802063c:	0e13      	lsrs	r3, r2, #24
 802063e:	9301      	str	r3, [sp, #4]
 8020640:	f3c2 4307 	ubfx	r3, r2, #16, #8
 8020644:	9300      	str	r3, [sp, #0]
 8020646:	f3c2 2307 	ubfx	r3, r2, #8, #8
 802064a:	b2d2      	uxtb	r2, r2
 802064c:	4905      	ldr	r1, [pc, #20]	; (8020664 <com_translate_ip_address+0x6c>)
 802064e:	1c68      	adds	r0, r5, #1
 8020650:	f005 fb0e 	bl	8025c70 <sprintf>
 8020654:	e7ed      	b.n	8020632 <com_translate_ip_address+0x3a>
  result = false;
 8020656:	2000      	movs	r0, #0
 8020658:	e7dc      	b.n	8020614 <com_translate_ip_address+0x1c>
 802065a:	2000      	movs	r0, #0
 802065c:	e7da      	b.n	8020614 <com_translate_ip_address+0x1c>
 802065e:	bf00      	nop
 8020660:	0802ac84 	.word	0x0802ac84
 8020664:	080355bc 	.word	0x080355bc

08020668 <com_ip_modem_connect_udp_service>:
{
 8020668:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (socket_desc->state == COM_SOCKET_CREATED)
 802066a:	7803      	ldrb	r3, [r0, #0]
 802066c:	2b02      	cmp	r3, #2
 802066e:	d004      	beq.n	802067a <com_ip_modem_connect_udp_service+0x12>
  else if (socket_desc->state == COM_SOCKET_CONNECTED)
 8020670:	2b03      	cmp	r3, #3
 8020672:	f040 80bb 	bne.w	80207ec <com_ip_modem_connect_udp_service+0x184>
    result = COM_SOCKETS_ERR_OK;
 8020676:	2000      	movs	r0, #0
}
 8020678:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802067a:	4604      	mov	r4, r0
    if (socket_desc->local_port == 0U)
 802067c:	8983      	ldrh	r3, [r0, #12]
 802067e:	b92b      	cbnz	r3, 802068c <com_ip_modem_connect_udp_service+0x24>
      socket_desc->local_port = com_ip_modem_new_local_port();
 8020680:	f7ff fcb6 	bl	801fff0 <com_ip_modem_new_local_port>
 8020684:	81a0      	strh	r0, [r4, #12]
      if (socket_desc->local_port == 0U)
 8020686:	2800      	cmp	r0, #0
 8020688:	f000 80d6 	beq.w	8020838 <com_ip_modem_connect_udp_service+0x1d0>
      com_ip_modem_wakeup_request();
 802068c:	f7ff fce8 	bl	8020060 <com_ip_modem_wakeup_request>
      if (osCDS_socket_bind(socket_desc->id,
 8020690:	89a1      	ldrh	r1, [r4, #12]
 8020692:	68a0      	ldr	r0, [r4, #8]
 8020694:	f7fa f8b2 	bl	801a7fc <osCDS_socket_bind>
 8020698:	2800      	cmp	r0, #0
 802069a:	d17c      	bne.n	8020796 <com_ip_modem_connect_udp_service+0x12e>
        PRINT_INFO("socket internal bind ok")
 802069c:	4e68      	ldr	r6, [pc, #416]	; (8020840 <com_ip_modem_connect_udp_service+0x1d8>)
 802069e:	4d69      	ldr	r5, [pc, #420]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 80206a0:	f106 0720 	add.w	r7, r6, #32
 80206a4:	46b4      	mov	ip, r6
 80206a6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80206aa:	6028      	str	r0, [r5, #0]
 80206ac:	6069      	str	r1, [r5, #4]
 80206ae:	60aa      	str	r2, [r5, #8]
 80206b0:	60eb      	str	r3, [r5, #12]
 80206b2:	4666      	mov	r6, ip
 80206b4:	3510      	adds	r5, #16
 80206b6:	45bc      	cmp	ip, r7
 80206b8:	d1f4      	bne.n	80206a4 <com_ip_modem_connect_udp_service+0x3c>
 80206ba:	f8bc 3000 	ldrh.w	r3, [ip]
 80206be:	802b      	strh	r3, [r5, #0]
 80206c0:	4d60      	ldr	r5, [pc, #384]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 80206c2:	4628      	mov	r0, r5
 80206c4:	f7fe fd25 	bl	801f112 <crs_strlen>
 80206c8:	b283      	uxth	r3, r0
 80206ca:	462a      	mov	r2, r5
 80206cc:	2101      	movs	r1, #1
 80206ce:	2003      	movs	r0, #3
 80206d0:	f7fe fd62 	bl	801f198 <traceIF_itmPrint>
 80206d4:	4628      	mov	r0, r5
 80206d6:	f7fe fd1c 	bl	801f112 <crs_strlen>
 80206da:	b283      	uxth	r3, r0
 80206dc:	462a      	mov	r2, r5
 80206de:	2101      	movs	r1, #1
 80206e0:	2003      	movs	r0, #3
 80206e2:	f7fe fd7b 	bl	801f1dc <traceIF_uartPrint>
        if (osCDS_socket_connect(socket_desc->id,
 80206e6:	2300      	movs	r3, #0
 80206e8:	4a57      	ldr	r2, [pc, #348]	; (8020848 <com_ip_modem_connect_udp_service+0x1e0>)
 80206ea:	2101      	movs	r1, #1
 80206ec:	68a0      	ldr	r0, [r4, #8]
 80206ee:	f7fa f8a1 	bl	801a834 <osCDS_socket_connect>
 80206f2:	bb38      	cbnz	r0, 8020744 <com_ip_modem_connect_udp_service+0xdc>
          PRINT_INFO("socket internal connect ok")
 80206f4:	4f55      	ldr	r7, [pc, #340]	; (802084c <com_ip_modem_connect_udp_service+0x1e4>)
 80206f6:	f107 0c20 	add.w	ip, r7, #32
 80206fa:	463e      	mov	r6, r7
 80206fc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80206fe:	6028      	str	r0, [r5, #0]
 8020700:	6069      	str	r1, [r5, #4]
 8020702:	60aa      	str	r2, [r5, #8]
 8020704:	60eb      	str	r3, [r5, #12]
 8020706:	4637      	mov	r7, r6
 8020708:	3510      	adds	r5, #16
 802070a:	4566      	cmp	r6, ip
 802070c:	d1f5      	bne.n	80206fa <com_ip_modem_connect_udp_service+0x92>
 802070e:	6830      	ldr	r0, [r6, #0]
 8020710:	6028      	str	r0, [r5, #0]
 8020712:	7933      	ldrb	r3, [r6, #4]
 8020714:	712b      	strb	r3, [r5, #4]
 8020716:	4d4b      	ldr	r5, [pc, #300]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 8020718:	4628      	mov	r0, r5
 802071a:	f7fe fcfa 	bl	801f112 <crs_strlen>
 802071e:	b283      	uxth	r3, r0
 8020720:	462a      	mov	r2, r5
 8020722:	2101      	movs	r1, #1
 8020724:	2003      	movs	r0, #3
 8020726:	f7fe fd37 	bl	801f198 <traceIF_itmPrint>
 802072a:	4628      	mov	r0, r5
 802072c:	f7fe fcf1 	bl	801f112 <crs_strlen>
 8020730:	b283      	uxth	r3, r0
 8020732:	462a      	mov	r2, r5
 8020734:	2101      	movs	r1, #1
 8020736:	2003      	movs	r0, #3
 8020738:	f7fe fd50 	bl	801f1dc <traceIF_uartPrint>
          socket_desc->state = COM_SOCKET_CONNECTED;
 802073c:	2303      	movs	r3, #3
 802073e:	7023      	strb	r3, [r4, #0]
          result = COM_SOCKETS_ERR_OK;
 8020740:	2000      	movs	r0, #0
 8020742:	e799      	b.n	8020678 <com_ip_modem_connect_udp_service+0x10>
          PRINT_ERR("socket internal connect NOK at low level")
 8020744:	4d42      	ldr	r5, [pc, #264]	; (8020850 <com_ip_modem_connect_udp_service+0x1e8>)
 8020746:	4c3f      	ldr	r4, [pc, #252]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 8020748:	f105 0730 	add.w	r7, r5, #48	; 0x30
 802074c:	462e      	mov	r6, r5
 802074e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020750:	6020      	str	r0, [r4, #0]
 8020752:	6061      	str	r1, [r4, #4]
 8020754:	60a2      	str	r2, [r4, #8]
 8020756:	60e3      	str	r3, [r4, #12]
 8020758:	4635      	mov	r5, r6
 802075a:	3410      	adds	r4, #16
 802075c:	42be      	cmp	r6, r7
 802075e:	d1f5      	bne.n	802074c <com_ip_modem_connect_udp_service+0xe4>
 8020760:	cd03      	ldmia	r5!, {r0, r1}
 8020762:	6020      	str	r0, [r4, #0]
 8020764:	6061      	str	r1, [r4, #4]
 8020766:	782b      	ldrb	r3, [r5, #0]
 8020768:	7223      	strb	r3, [r4, #8]
 802076a:	4c36      	ldr	r4, [pc, #216]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 802076c:	4620      	mov	r0, r4
 802076e:	f7fe fcd0 	bl	801f112 <crs_strlen>
 8020772:	b283      	uxth	r3, r0
 8020774:	4622      	mov	r2, r4
 8020776:	2110      	movs	r1, #16
 8020778:	2003      	movs	r0, #3
 802077a:	f7fe fd0d 	bl	801f198 <traceIF_itmPrint>
 802077e:	4620      	mov	r0, r4
 8020780:	f7fe fcc7 	bl	801f112 <crs_strlen>
 8020784:	b283      	uxth	r3, r0
 8020786:	4622      	mov	r2, r4
 8020788:	2110      	movs	r1, #16
 802078a:	2003      	movs	r0, #3
 802078c:	f7fe fd26 	bl	801f1dc <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_GENERAL;
 8020790:	f04f 30ff 	mov.w	r0, #4294967295
 8020794:	e770      	b.n	8020678 <com_ip_modem_connect_udp_service+0x10>
        PRINT_ERR("socket internal bind NOK at low level")
 8020796:	4d2f      	ldr	r5, [pc, #188]	; (8020854 <com_ip_modem_connect_udp_service+0x1ec>)
 8020798:	4c2a      	ldr	r4, [pc, #168]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 802079a:	f105 0630 	add.w	r6, r5, #48	; 0x30
 802079e:	46ac      	mov	ip, r5
 80207a0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80207a4:	6020      	str	r0, [r4, #0]
 80207a6:	6061      	str	r1, [r4, #4]
 80207a8:	60a2      	str	r2, [r4, #8]
 80207aa:	60e3      	str	r3, [r4, #12]
 80207ac:	4665      	mov	r5, ip
 80207ae:	3410      	adds	r4, #16
 80207b0:	45b4      	cmp	ip, r6
 80207b2:	d1f4      	bne.n	802079e <com_ip_modem_connect_udp_service+0x136>
 80207b4:	f8dc 0000 	ldr.w	r0, [ip]
 80207b8:	6020      	str	r0, [r4, #0]
 80207ba:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80207be:	80a3      	strh	r3, [r4, #4]
 80207c0:	4c20      	ldr	r4, [pc, #128]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 80207c2:	4620      	mov	r0, r4
 80207c4:	f7fe fca5 	bl	801f112 <crs_strlen>
 80207c8:	b283      	uxth	r3, r0
 80207ca:	4622      	mov	r2, r4
 80207cc:	2110      	movs	r1, #16
 80207ce:	2003      	movs	r0, #3
 80207d0:	f7fe fce2 	bl	801f198 <traceIF_itmPrint>
 80207d4:	4620      	mov	r0, r4
 80207d6:	f7fe fc9c 	bl	801f112 <crs_strlen>
 80207da:	b283      	uxth	r3, r0
 80207dc:	4622      	mov	r2, r4
 80207de:	2110      	movs	r1, #16
 80207e0:	2003      	movs	r0, #3
 80207e2:	f7fe fcfb 	bl	801f1dc <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_GENERAL;
 80207e6:	f04f 30ff 	mov.w	r0, #4294967295
      com_ip_modem_idlemode_request(false);
 80207ea:	e745      	b.n	8020678 <com_ip_modem_connect_udp_service+0x10>
    PRINT_ERR("socket internal connect - err state")
 80207ec:	4e1a      	ldr	r6, [pc, #104]	; (8020858 <com_ip_modem_connect_udp_service+0x1f0>)
 80207ee:	4d15      	ldr	r5, [pc, #84]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 80207f0:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80207f4:	4634      	mov	r4, r6
 80207f6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80207f8:	6028      	str	r0, [r5, #0]
 80207fa:	6069      	str	r1, [r5, #4]
 80207fc:	60aa      	str	r2, [r5, #8]
 80207fe:	60eb      	str	r3, [r5, #12]
 8020800:	4626      	mov	r6, r4
 8020802:	3510      	adds	r5, #16
 8020804:	42bc      	cmp	r4, r7
 8020806:	d1f5      	bne.n	80207f4 <com_ip_modem_connect_udp_service+0x18c>
 8020808:	6820      	ldr	r0, [r4, #0]
 802080a:	6028      	str	r0, [r5, #0]
 802080c:	4c0d      	ldr	r4, [pc, #52]	; (8020844 <com_ip_modem_connect_udp_service+0x1dc>)
 802080e:	4620      	mov	r0, r4
 8020810:	f7fe fc7f 	bl	801f112 <crs_strlen>
 8020814:	b283      	uxth	r3, r0
 8020816:	4622      	mov	r2, r4
 8020818:	2110      	movs	r1, #16
 802081a:	2003      	movs	r0, #3
 802081c:	f7fe fcbc 	bl	801f198 <traceIF_itmPrint>
 8020820:	4620      	mov	r0, r4
 8020822:	f7fe fc76 	bl	801f112 <crs_strlen>
 8020826:	b283      	uxth	r3, r0
 8020828:	4622      	mov	r2, r4
 802082a:	2110      	movs	r1, #16
 802082c:	2003      	movs	r0, #3
 802082e:	f7fe fcd5 	bl	801f1dc <traceIF_uartPrint>
  result = COM_SOCKETS_ERR_STATE;
 8020832:	f06f 000c 	mvn.w	r0, #12
 8020836:	e71f      	b.n	8020678 <com_ip_modem_connect_udp_service+0x10>
        result = COM_SOCKETS_ERR_LOCKED;
 8020838:	f06f 0006 	mvn.w	r0, #6
 802083c:	e71c      	b.n	8020678 <com_ip_modem_connect_udp_service+0x10>
 802083e:	bf00      	nop
 8020840:	080355d4 	.word	0x080355d4
 8020844:	200049dc 	.word	0x200049dc
 8020848:	0802ac84 	.word	0x0802ac84
 802084c:	080355f8 	.word	0x080355f8
 8020850:	08035620 	.word	0x08035620
 8020854:	0803565c 	.word	0x0803565c
 8020858:	08035694 	.word	0x08035694

0802085c <com_socket_datacache_cb>:
                                    const void *private_gui_data)
{
  UNUSED(private_gui_data);

  /* Used to know Network status */
  if (dc_event_id == DC_COM_NIFMAN_INFO)
 802085c:	4b14      	ldr	r3, [pc, #80]	; (80208b0 <com_socket_datacache_cb+0x54>)
 802085e:	8819      	ldrh	r1, [r3, #0]
 8020860:	4288      	cmp	r0, r1
 8020862:	d000      	beq.n	8020866 <com_socket_datacache_cb+0xa>
 8020864:	4770      	bx	lr
{
 8020866:	b500      	push	{lr}
 8020868:	b085      	sub	sp, #20
  {
    dc_nifman_info_t  dc_nifman_rt_info;

    if (dc_com_read(&dc_com_db, DC_COM_NIFMAN_INFO,
 802086a:	2310      	movs	r3, #16
 802086c:	466a      	mov	r2, sp
 802086e:	4811      	ldr	r0, [pc, #68]	; (80208b4 <com_socket_datacache_cb+0x58>)
 8020870:	f001 f8aa 	bl	80219c8 <dc_com_read>
 8020874:	b130      	cbz	r0, 8020884 <com_socket_datacache_cb+0x28>
                    (void *)&dc_nifman_rt_info,
                    sizeof(dc_nifman_rt_info))
        == DC_COM_OK)
    {
      if (dc_nifman_rt_info.rt_state == DC_SERVICE_ON)
 8020876:	f89d 3008 	ldrb.w	r3, [sp, #8]
 802087a:	2b07      	cmp	r3, #7
 802087c:	d005      	beq.n	802088a <com_socket_datacache_cb+0x2e>
        }
      }
      else
      {
        /* Filtering multiple same notification */
        if (com_ip_modem_is_network_up() == true)
 802087e:	f7ff fbb1 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020882:	b968      	cbnz	r0, 80208a0 <com_socket_datacache_cb+0x44>
  }
  else
  {
    /* Nothing to do */
  }
}
 8020884:	b005      	add	sp, #20
 8020886:	f85d fb04 	ldr.w	pc, [sp], #4
        if (com_ip_modem_is_network_up() == false)
 802088a:	f7ff fbab 	bl	801ffe4 <com_ip_modem_is_network_up>
 802088e:	2800      	cmp	r0, #0
 8020890:	d1f8      	bne.n	8020884 <com_socket_datacache_cb+0x28>
          com_sockets_network_is_up = true;
 8020892:	4b09      	ldr	r3, [pc, #36]	; (80208b8 <com_socket_datacache_cb+0x5c>)
 8020894:	2201      	movs	r2, #1
 8020896:	701a      	strb	r2, [r3, #0]
          com_sockets_statistic_update(COM_SOCKET_STAT_NWK_UP);
 8020898:	200a      	movs	r0, #10
 802089a:	f000 ffe3 	bl	8021864 <com_sockets_statistic_update>
 802089e:	e7f1      	b.n	8020884 <com_socket_datacache_cb+0x28>
          com_sockets_network_is_up = false;
 80208a0:	4b05      	ldr	r3, [pc, #20]	; (80208b8 <com_socket_datacache_cb+0x5c>)
 80208a2:	2200      	movs	r2, #0
 80208a4:	701a      	strb	r2, [r3, #0]
          com_sockets_statistic_update(COM_SOCKET_STAT_NWK_DWN);
 80208a6:	200b      	movs	r0, #11
 80208a8:	f000 ffdc 	bl	8021864 <com_sockets_statistic_update>
}
 80208ac:	e7ea      	b.n	8020884 <com_socket_datacache_cb+0x28>
 80208ae:	bf00      	nop
 80208b0:	2000023a 	.word	0x2000023a
 80208b4:	200058b0 	.word	0x200058b0
 80208b8:	200058a6 	.word	0x200058a6

080208bc <com_setsockopt_ip_modem>:
  * @param  optlen    - size of the buffer containing the option value
  * @retval int32_t   - ok or error value
  */
int32_t com_setsockopt_ip_modem(int32_t sock, int32_t level, int32_t optname,
                                const void *optval, int32_t optlen)
{
 80208bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80208c0:	4688      	mov	r8, r1
 80208c2:	4617      	mov	r7, r2
 80208c4:	461c      	mov	r4, r3
 80208c6:	9e06      	ldr	r6, [sp, #24]
  int32_t result;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;
  socket_desc = com_ip_modem_find_socket(sock, false);
 80208c8:	2100      	movs	r1, #0
 80208ca:	f7ff fb6b 	bl	801ffa4 <com_ip_modem_find_socket>

  if (socket_desc != NULL)
 80208ce:	4605      	mov	r5, r0
 80208d0:	b358      	cbz	r0, 802092a <com_setsockopt_ip_modem+0x6e>
  {
    if ((optval != NULL)
 80208d2:	b36c      	cbz	r4, 8020930 <com_setsockopt_ip_modem+0x74>
        && (optlen > 0))
 80208d4:	2e00      	cmp	r6, #0
 80208d6:	dd2e      	ble.n	8020936 <com_setsockopt_ip_modem+0x7a>
    {
      com_ip_modem_wakeup_request();
 80208d8:	f7ff fbc2 	bl	8020060 <com_ip_modem_wakeup_request>
      if (level == COM_SOL_SOCKET)
 80208dc:	f640 73ff 	movw	r3, #4095	; 0xfff
 80208e0:	4598      	cmp	r8, r3
 80208e2:	d005      	beq.n	80208f0 <com_setsockopt_ip_modem+0x34>
  result = COM_SOCKETS_ERR_PARAMETER;
 80208e4:	f06f 0002 	mvn.w	r0, #2
  else
  {
    result = COM_SOCKETS_ERR_DESCRIPTOR;
  }

  SOCKET_SET_ERROR(socket_desc, result);
 80208e8:	b105      	cbz	r5, 80208ec <com_setsockopt_ip_modem+0x30>
 80208ea:	6068      	str	r0, [r5, #4]
  return result;
}
 80208ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        switch (optname)
 80208f0:	f241 0305 	movw	r3, #4101	; 0x1005
 80208f4:	429f      	cmp	r7, r3
 80208f6:	d006      	beq.n	8020906 <com_setsockopt_ip_modem+0x4a>
 80208f8:	f241 0306 	movw	r3, #4102	; 0x1006
 80208fc:	429f      	cmp	r7, r3
 80208fe:	d008      	beq.n	8020912 <com_setsockopt_ip_modem+0x56>
 8020900:	f06f 0002 	mvn.w	r0, #2
 8020904:	e7f0      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
            if ((uint32_t)optlen <= sizeof(socket_desc->rcv_timeout))
 8020906:	2e04      	cmp	r6, #4
 8020908:	d809      	bhi.n	802091e <com_setsockopt_ip_modem+0x62>
              socket_desc->snd_timeout = *(const uint32_t *)optval;
 802090a:	6823      	ldr	r3, [r4, #0]
 802090c:	616b      	str	r3, [r5, #20]
              result = COM_SOCKETS_ERR_OK;
 802090e:	2000      	movs	r0, #0
 8020910:	e7ea      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
            if ((uint32_t)optlen <= sizeof(socket_desc->rcv_timeout))
 8020912:	2e04      	cmp	r6, #4
 8020914:	d806      	bhi.n	8020924 <com_setsockopt_ip_modem+0x68>
              socket_desc->rcv_timeout = *(const uint32_t *)optval;
 8020916:	6823      	ldr	r3, [r4, #0]
 8020918:	61ab      	str	r3, [r5, #24]
              result = COM_SOCKETS_ERR_OK;
 802091a:	2000      	movs	r0, #0
 802091c:	e7e4      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
  result = COM_SOCKETS_ERR_PARAMETER;
 802091e:	f06f 0002 	mvn.w	r0, #2
 8020922:	e7e1      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
 8020924:	f06f 0002 	mvn.w	r0, #2
      com_ip_modem_idlemode_request(false);
 8020928:	e7de      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
    result = COM_SOCKETS_ERR_DESCRIPTOR;
 802092a:	f06f 0001 	mvn.w	r0, #1
 802092e:	e7db      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020930:	f06f 0002 	mvn.w	r0, #2
 8020934:	e7d8      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>
 8020936:	f06f 0002 	mvn.w	r0, #2
 802093a:	e7d5      	b.n	80208e8 <com_setsockopt_ip_modem+0x2c>

0802093c <com_connect_ip_modem>:
  * @param  addrlen   - addr length
  * @retval int32_t   - ok or error value
  */
int32_t com_connect_ip_modem(int32_t sock,
                             const com_sockaddr_t *addr, int32_t addrlen)
{
 802093c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802093e:	b08f      	sub	sp, #60	; 0x3c
 8020940:	460f      	mov	r7, r1
 8020942:	4615      	mov	r5, r2
  socket_addr_t socket_addr;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;

  socket_desc = com_ip_modem_find_socket(sock, false);
 8020944:	2100      	movs	r1, #0
 8020946:	f7ff fb2d 	bl	801ffa4 <com_ip_modem_find_socket>

  /* Check parameters validity */
  if (socket_desc != NULL)
 802094a:	4604      	mov	r4, r0
 802094c:	2800      	cmp	r0, #0
 802094e:	f000 80ca 	beq.w	8020ae6 <com_connect_ip_modem+0x1aa>
  {
    if (com_translate_ip_address(addr, addrlen,
 8020952:	aa03      	add	r2, sp, #12
 8020954:	4629      	mov	r1, r5
 8020956:	4638      	mov	r0, r7
 8020958:	f7ff fe4e 	bl	80205f8 <com_translate_ip_address>
 802095c:	2800      	cmp	r0, #0
 802095e:	f000 80c5 	beq.w	8020aec <com_connect_ip_modem+0x1b0>
  }

  /* If parameters are valid continue the treatment */
  if (result == COM_SOCKETS_ERR_OK)
  {
    if (socket_desc->type == (uint8_t)COM_SOCK_STREAM)
 8020962:	78e3      	ldrb	r3, [r4, #3]
 8020964:	2b01      	cmp	r3, #1
 8020966:	f040 80b0 	bne.w	8020aca <com_connect_ip_modem+0x18e>
    {
      if (socket_desc->state == COM_SOCKET_CREATED)
 802096a:	7823      	ldrb	r3, [r4, #0]
 802096c:	2b02      	cmp	r3, #2
 802096e:	f040 8081 	bne.w	8020a74 <com_connect_ip_modem+0x138>
      {
        /* Check Network status */
        if (com_ip_modem_is_network_up() == true)
 8020972:	f7ff fb37 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020976:	2800      	cmp	r0, #0
 8020978:	d051      	beq.n	8020a1e <com_connect_ip_modem+0xe2>
        {
          com_ip_modem_wakeup_request();
 802097a:	f7ff fb71 	bl	8020060 <com_ip_modem_wakeup_request>
          if (osCDS_socket_connect(socket_desc->id,
 802097e:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 8020982:	f10d 020d 	add.w	r2, sp, #13
 8020986:	f89d 100c 	ldrb.w	r1, [sp, #12]
 802098a:	68a0      	ldr	r0, [r4, #8]
 802098c:	f7f9 ff52 	bl	801a834 <osCDS_socket_connect>
 8020990:	bb00      	cbnz	r0, 80209d4 <com_connect_ip_modem+0x98>
                                   socket_addr.port)
              == CELLULAR_OK)
          {
            /* result already set to the correct value COM_SOCKETS_ERR_OK */
            /* result = COM_SOCKETS_ERR_OK; */
            PRINT_INFO("socket connect ok")
 8020992:	4d5f      	ldr	r5, [pc, #380]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 8020994:	4e5f      	ldr	r6, [pc, #380]	; (8020b14 <com_connect_ip_modem+0x1d8>)
 8020996:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020998:	6028      	str	r0, [r5, #0]
 802099a:	6069      	str	r1, [r5, #4]
 802099c:	60aa      	str	r2, [r5, #8]
 802099e:	60eb      	str	r3, [r5, #12]
 80209a0:	ce07      	ldmia	r6!, {r0, r1, r2}
 80209a2:	6128      	str	r0, [r5, #16]
 80209a4:	6169      	str	r1, [r5, #20]
 80209a6:	61aa      	str	r2, [r5, #24]
 80209a8:	4628      	mov	r0, r5
 80209aa:	f7fe fbb2 	bl	801f112 <crs_strlen>
 80209ae:	b283      	uxth	r3, r0
 80209b0:	462a      	mov	r2, r5
 80209b2:	2101      	movs	r1, #1
 80209b4:	2003      	movs	r0, #3
 80209b6:	f7fe fbef 	bl	801f198 <traceIF_itmPrint>
 80209ba:	4628      	mov	r0, r5
 80209bc:	f7fe fba9 	bl	801f112 <crs_strlen>
 80209c0:	b283      	uxth	r3, r0
 80209c2:	462a      	mov	r2, r5
 80209c4:	2101      	movs	r1, #1
 80209c6:	2003      	movs	r0, #3
 80209c8:	f7fe fc08 	bl	801f1dc <traceIF_uartPrint>
            socket_desc->state = COM_SOCKET_CONNECTED;
 80209cc:	2303      	movs	r3, #3
 80209ce:	7023      	strb	r3, [r4, #0]
      result = COM_SOCKETS_ERR_OK;
 80209d0:	2500      	movs	r5, #0
 80209d2:	e07e      	b.n	8020ad2 <com_connect_ip_modem+0x196>
          }
          else
          {
            result = COM_SOCKETS_ERR_GENERAL;
            PRINT_ERR("socket connect NOK at low level")
 80209d4:	f8df c148 	ldr.w	ip, [pc, #328]	; 8020b20 <com_connect_ip_modem+0x1e4>
 80209d8:	4e4d      	ldr	r6, [pc, #308]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 80209da:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 80209de:	4665      	mov	r5, ip
 80209e0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80209e2:	6030      	str	r0, [r6, #0]
 80209e4:	6071      	str	r1, [r6, #4]
 80209e6:	60b2      	str	r2, [r6, #8]
 80209e8:	60f3      	str	r3, [r6, #12]
 80209ea:	46ac      	mov	ip, r5
 80209ec:	3610      	adds	r6, #16
 80209ee:	4575      	cmp	r5, lr
 80209f0:	d1f5      	bne.n	80209de <com_connect_ip_modem+0xa2>
 80209f2:	4d47      	ldr	r5, [pc, #284]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 80209f4:	4628      	mov	r0, r5
 80209f6:	f7fe fb8c 	bl	801f112 <crs_strlen>
 80209fa:	b283      	uxth	r3, r0
 80209fc:	462a      	mov	r2, r5
 80209fe:	2110      	movs	r1, #16
 8020a00:	2003      	movs	r0, #3
 8020a02:	f7fe fbc9 	bl	801f198 <traceIF_itmPrint>
 8020a06:	4628      	mov	r0, r5
 8020a08:	f7fe fb83 	bl	801f112 <crs_strlen>
 8020a0c:	b283      	uxth	r3, r0
 8020a0e:	462a      	mov	r2, r5
 8020a10:	2110      	movs	r1, #16
 8020a12:	2003      	movs	r0, #3
 8020a14:	f7fe fbe2 	bl	801f1dc <traceIF_uartPrint>
            result = COM_SOCKETS_ERR_GENERAL;
 8020a18:	f04f 35ff 	mov.w	r5, #4294967295
          }
          com_ip_modem_idlemode_request(false);
 8020a1c:	e059      	b.n	8020ad2 <com_connect_ip_modem+0x196>
        }
        else
        {
          result = COM_SOCKETS_ERR_NONETWORK;
          PRINT_ERR("socket connect NOK no network")
 8020a1e:	4e3e      	ldr	r6, [pc, #248]	; (8020b18 <com_connect_ip_modem+0x1dc>)
 8020a20:	4d3b      	ldr	r5, [pc, #236]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 8020a22:	f106 0e20 	add.w	lr, r6, #32
 8020a26:	46b4      	mov	ip, r6
 8020a28:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020a2c:	6028      	str	r0, [r5, #0]
 8020a2e:	6069      	str	r1, [r5, #4]
 8020a30:	60aa      	str	r2, [r5, #8]
 8020a32:	60eb      	str	r3, [r5, #12]
 8020a34:	4666      	mov	r6, ip
 8020a36:	3510      	adds	r5, #16
 8020a38:	45f4      	cmp	ip, lr
 8020a3a:	d1f4      	bne.n	8020a26 <com_connect_ip_modem+0xea>
 8020a3c:	ce07      	ldmia	r6!, {r0, r1, r2}
 8020a3e:	6028      	str	r0, [r5, #0]
 8020a40:	6069      	str	r1, [r5, #4]
 8020a42:	60aa      	str	r2, [r5, #8]
 8020a44:	8833      	ldrh	r3, [r6, #0]
 8020a46:	81ab      	strh	r3, [r5, #12]
 8020a48:	4d31      	ldr	r5, [pc, #196]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 8020a4a:	4628      	mov	r0, r5
 8020a4c:	f7fe fb61 	bl	801f112 <crs_strlen>
 8020a50:	b283      	uxth	r3, r0
 8020a52:	462a      	mov	r2, r5
 8020a54:	2110      	movs	r1, #16
 8020a56:	2003      	movs	r0, #3
 8020a58:	f7fe fb9e 	bl	801f198 <traceIF_itmPrint>
 8020a5c:	4628      	mov	r0, r5
 8020a5e:	f7fe fb58 	bl	801f112 <crs_strlen>
 8020a62:	b283      	uxth	r3, r0
 8020a64:	462a      	mov	r2, r5
 8020a66:	2110      	movs	r1, #16
 8020a68:	2003      	movs	r0, #3
 8020a6a:	f7fe fbb7 	bl	801f1dc <traceIF_uartPrint>
          result = COM_SOCKETS_ERR_NONETWORK;
 8020a6e:	f06f 050a 	mvn.w	r5, #10
 8020a72:	e02e      	b.n	8020ad2 <com_connect_ip_modem+0x196>
        }
      }
      else
      {
        result = COM_SOCKETS_ERR_STATE;
        PRINT_ERR("socket connect NOK err state")
 8020a74:	4e29      	ldr	r6, [pc, #164]	; (8020b1c <com_connect_ip_modem+0x1e0>)
 8020a76:	4d26      	ldr	r5, [pc, #152]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 8020a78:	f106 0e20 	add.w	lr, r6, #32
 8020a7c:	46b4      	mov	ip, r6
 8020a7e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020a82:	6028      	str	r0, [r5, #0]
 8020a84:	6069      	str	r1, [r5, #4]
 8020a86:	60aa      	str	r2, [r5, #8]
 8020a88:	60eb      	str	r3, [r5, #12]
 8020a8a:	4666      	mov	r6, ip
 8020a8c:	3510      	adds	r5, #16
 8020a8e:	45f4      	cmp	ip, lr
 8020a90:	d1f4      	bne.n	8020a7c <com_connect_ip_modem+0x140>
 8020a92:	ce07      	ldmia	r6!, {r0, r1, r2}
 8020a94:	6028      	str	r0, [r5, #0]
 8020a96:	6069      	str	r1, [r5, #4]
 8020a98:	60aa      	str	r2, [r5, #8]
 8020a9a:	7833      	ldrb	r3, [r6, #0]
 8020a9c:	732b      	strb	r3, [r5, #12]
 8020a9e:	4d1c      	ldr	r5, [pc, #112]	; (8020b10 <com_connect_ip_modem+0x1d4>)
 8020aa0:	4628      	mov	r0, r5
 8020aa2:	f7fe fb36 	bl	801f112 <crs_strlen>
 8020aa6:	b283      	uxth	r3, r0
 8020aa8:	462a      	mov	r2, r5
 8020aaa:	2110      	movs	r1, #16
 8020aac:	2003      	movs	r0, #3
 8020aae:	f7fe fb73 	bl	801f198 <traceIF_itmPrint>
 8020ab2:	4628      	mov	r0, r5
 8020ab4:	f7fe fb2d 	bl	801f112 <crs_strlen>
 8020ab8:	b283      	uxth	r3, r0
 8020aba:	462a      	mov	r2, r5
 8020abc:	2110      	movs	r1, #16
 8020abe:	2003      	movs	r0, #3
 8020ac0:	f7fe fb8c 	bl	801f1dc <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_STATE;
 8020ac4:	f06f 050c 	mvn.w	r5, #12
 8020ac8:	e003      	b.n	8020ad2 <com_connect_ip_modem+0x196>
        PRINT_ERR("socket connect NOK err state")
      }
#else /* UDP_SERVICES_SUPPORTED == 1U */
      /* A specific udp service connection is done
         in order to be able to use sendto/recvfrom services */
      result = com_ip_modem_connect_udp_service(socket_desc);
 8020aca:	4620      	mov	r0, r4
 8020acc:	f7ff fdcc 	bl	8020668 <com_ip_modem_connect_udp_service>
 8020ad0:	4605      	mov	r5, r0
#endif /* UDP_SERVICES_SUPPORTED == 0U */
    }
  }
  if (socket_desc != NULL)
 8020ad2:	b124      	cbz	r4, 8020ade <com_connect_ip_modem+0x1a2>
  {
    /* if com_translate_ip_address == FALSE, result already set to COM_SOCKETS_ERR_PARAMETER */
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8020ad4:	b96d      	cbnz	r5, 8020af2 <com_connect_ip_modem+0x1b6>
 8020ad6:	2002      	movs	r0, #2
 8020ad8:	f000 fec4 	bl	8021864 <com_sockets_statistic_update>
                                 COM_SOCKET_STAT_CNT_OK : COM_SOCKET_STAT_CNT_NOK);
    SOCKET_SET_ERROR(socket_desc, result);
 8020adc:	6065      	str	r5, [r4, #4]
  }

  if (result == COM_SOCKETS_ERR_OK)
 8020ade:	b155      	cbz	r5, 8020af6 <com_connect_ip_modem+0x1ba>
    socket_desc->remote_addr.addr = remote_addr.addr;
    socket_desc->remote_port = remote_port;
  }

  return result;
}
 8020ae0:	4628      	mov	r0, r5
 8020ae2:	b00f      	add	sp, #60	; 0x3c
 8020ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  result = COM_SOCKETS_ERR_PARAMETER;
 8020ae6:	f06f 0502 	mvn.w	r5, #2
 8020aea:	e7f2      	b.n	8020ad2 <com_connect_ip_modem+0x196>
 8020aec:	f06f 0502 	mvn.w	r5, #2
 8020af0:	e7ef      	b.n	8020ad2 <com_connect_ip_modem+0x196>
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8020af2:	2003      	movs	r0, #3
 8020af4:	e7f0      	b.n	8020ad8 <com_connect_ip_modem+0x19c>
    com_convert_sockaddr_to_ipaddr_port((const com_sockaddr_in_t *)addr,
 8020af6:	f10d 0206 	add.w	r2, sp, #6
 8020afa:	a902      	add	r1, sp, #8
 8020afc:	4638      	mov	r0, r7
 8020afe:	f7ff fa6b 	bl	801ffd8 <com_convert_sockaddr_to_ipaddr_port>
    socket_desc->remote_addr.addr = remote_addr.addr;
 8020b02:	9b02      	ldr	r3, [sp, #8]
 8020b04:	6123      	str	r3, [r4, #16]
    socket_desc->remote_port = remote_port;
 8020b06:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8020b0a:	81e3      	strh	r3, [r4, #14]
  return result;
 8020b0c:	e7e8      	b.n	8020ae0 <com_connect_ip_modem+0x1a4>
 8020b0e:	bf00      	nop
 8020b10:	200049dc 	.word	0x200049dc
 8020b14:	080356c8 	.word	0x080356c8
 8020b18:	08035714 	.word	0x08035714
 8020b1c:	08035744 	.word	0x08035744
 8020b20:	080356e4 	.word	0x080356e4

08020b24 <com_sendto_ip_modem>:
  */
int32_t com_sendto_ip_modem(int32_t sock,
                            const com_char_t *buf, int32_t len,
                            int32_t flags,
                            const com_sockaddr_t *to, int32_t tolen)
{
 8020b24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020b28:	b092      	sub	sp, #72	; 0x48
 8020b2a:	4606      	mov	r6, r0
 8020b2c:	460c      	mov	r4, r1
 8020b2e:	4690      	mov	r8, r2
 8020b30:	461d      	mov	r5, r3
  socket_desc_t *socket_desc;
  int32_t result;

  result = COM_SOCKETS_ERR_PARAMETER;
  socket_desc = com_ip_modem_find_socket(sock, false);
 8020b32:	2100      	movs	r1, #0
 8020b34:	f7ff fa36 	bl	801ffa4 <com_ip_modem_find_socket>

  if ((socket_desc != NULL)
 8020b38:	4607      	mov	r7, r0
 8020b3a:	2800      	cmp	r0, #0
 8020b3c:	f000 81d2 	beq.w	8020ee4 <com_sendto_ip_modem+0x3c0>
      && (buf != NULL)
 8020b40:	2c00      	cmp	r4, #0
 8020b42:	f000 81d7 	beq.w	8020ef4 <com_sendto_ip_modem+0x3d0>
      && (len > 0))
 8020b46:	f1b8 0f00 	cmp.w	r8, #0
 8020b4a:	f340 81d6 	ble.w	8020efa <com_sendto_ip_modem+0x3d6>
  {
    if (socket_desc->type == (uint8_t)COM_SOCK_STREAM)
 8020b4e:	78c3      	ldrb	r3, [r0, #3]
 8020b50:	2b01      	cmp	r3, #1
 8020b52:	d00d      	beq.n	8020b70 <com_sendto_ip_modem+0x4c>
      {
        bool is_network_up;
        socket_addr_t socket_addr;

        /* Check remote addr is valid */
        if ((to != NULL) && (tolen != 0))
 8020b54:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8020b56:	b10b      	cbz	r3, 8020b5c <com_sendto_ip_modem+0x38>
 8020b58:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8020b5a:	bb4b      	cbnz	r3, 8020bb0 <com_sendto_ip_modem+0x8c>
          /* else result = COM_SOCKETS_ERR_PARAMETER */
        }
        /* No address provided by connect previously done */
        /* a send translate to sendto */
        /* Use IPaddress of connect */
        else if ((to == NULL) && (tolen == 0)
 8020b5c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8020b5e:	b383      	cbz	r3, 8020bc2 <com_sendto_ip_modem+0x9e>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020b60:	f06f 0602 	mvn.w	r6, #2
      }
#endif /* UDP_SERVICE_SUPPORTED == 0U */
    }
  }

  if (result >= 0)
 8020b64:	2e00      	cmp	r6, #0
 8020b66:	f2c0 81bf 	blt.w	8020ee8 <com_sendto_ip_modem+0x3c4>
  {
    SOCKET_SET_ERROR(socket_desc, COM_SOCKETS_ERR_OK);
 8020b6a:	2300      	movs	r3, #0
 8020b6c:	607b      	str	r3, [r7, #4]
 8020b6e:	e1bd      	b.n	8020eec <com_sendto_ip_modem+0x3c8>
      result = com_send_ip_modem(sock, buf, len, flags);
 8020b70:	462b      	mov	r3, r5
 8020b72:	4642      	mov	r2, r8
 8020b74:	4621      	mov	r1, r4
 8020b76:	4630      	mov	r0, r6
 8020b78:	f000 f9c6 	bl	8020f08 <com_send_ip_modem>
 8020b7c:	4606      	mov	r6, r0
      PRINT_INFO("send data %s", buf)
 8020b7e:	4db9      	ldr	r5, [pc, #740]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020b80:	4622      	mov	r2, r4
 8020b82:	49b9      	ldr	r1, [pc, #740]	; (8020e68 <com_sendto_ip_modem+0x344>)
 8020b84:	4628      	mov	r0, r5
 8020b86:	f005 f873 	bl	8025c70 <sprintf>
 8020b8a:	4628      	mov	r0, r5
 8020b8c:	f7fe fac1 	bl	801f112 <crs_strlen>
 8020b90:	b283      	uxth	r3, r0
 8020b92:	462a      	mov	r2, r5
 8020b94:	2101      	movs	r1, #1
 8020b96:	2003      	movs	r0, #3
 8020b98:	f7fe fafe 	bl	801f198 <traceIF_itmPrint>
 8020b9c:	4628      	mov	r0, r5
 8020b9e:	f7fe fab8 	bl	801f112 <crs_strlen>
 8020ba2:	b283      	uxth	r3, r0
 8020ba4:	462a      	mov	r2, r5
 8020ba6:	2101      	movs	r1, #1
 8020ba8:	2003      	movs	r0, #3
 8020baa:	f7fe fb17 	bl	801f1dc <traceIF_uartPrint>
 8020bae:	e7d9      	b.n	8020b64 <com_sendto_ip_modem+0x40>
          if (com_translate_ip_address(to, tolen,
 8020bb0:	aa07      	add	r2, sp, #28
 8020bb2:	4619      	mov	r1, r3
 8020bb4:	981a      	ldr	r0, [sp, #104]	; 0x68
 8020bb6:	f7ff fd1f 	bl	80205f8 <com_translate_ip_address>
 8020bba:	b9d0      	cbnz	r0, 8020bf2 <com_sendto_ip_modem+0xce>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020bbc:	f06f 0602 	mvn.w	r6, #2
 8020bc0:	e7d0      	b.n	8020b64 <com_sendto_ip_modem+0x40>
        else if ((to == NULL) && (tolen == 0)
 8020bc2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8020bc4:	2b00      	cmp	r3, #0
 8020bc6:	f040 818a 	bne.w	8020ede <com_sendto_ip_modem+0x3ba>
                 && (socket_desc->remote_addr.addr != 0U))
 8020bca:	693b      	ldr	r3, [r7, #16]
 8020bcc:	b913      	cbnz	r3, 8020bd4 <com_sendto_ip_modem+0xb0>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020bce:	f06f 0602 	mvn.w	r6, #2
        }
 8020bd2:	e7c7      	b.n	8020b64 <com_sendto_ip_modem+0x40>
          remote_addr.addr = socket_desc->remote_addr.addr;
 8020bd4:	9302      	str	r3, [sp, #8]
          com_convert_ipaddr_port_to_sockaddr(&remote_addr,
 8020bd6:	aa03      	add	r2, sp, #12
 8020bd8:	89f9      	ldrh	r1, [r7, #14]
 8020bda:	a802      	add	r0, sp, #8
 8020bdc:	f7ff fd00 	bl	80205e0 <com_convert_ipaddr_port_to_sockaddr>
          if (com_translate_ip_address((com_sockaddr_t *)&sockaddr_in,
 8020be0:	aa07      	add	r2, sp, #28
 8020be2:	2110      	movs	r1, #16
 8020be4:	a803      	add	r0, sp, #12
 8020be6:	f7ff fd07 	bl	80205f8 <com_translate_ip_address>
 8020bea:	b910      	cbnz	r0, 8020bf2 <com_sendto_ip_modem+0xce>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020bec:	f06f 0602 	mvn.w	r6, #2
 8020bf0:	e7b8      	b.n	8020b64 <com_sendto_ip_modem+0x40>
          result = com_ip_modem_connect_udp_service(socket_desc);
 8020bf2:	4638      	mov	r0, r7
 8020bf4:	f7ff fd38 	bl	8020668 <com_ip_modem_connect_udp_service>
          if ((result == COM_SOCKETS_ERR_OK)
 8020bf8:	4606      	mov	r6, r0
 8020bfa:	b920      	cbnz	r0, 8020c06 <com_sendto_ip_modem+0xe2>
              && (socket_desc->closing == false)
 8020bfc:	78bb      	ldrb	r3, [r7, #2]
 8020bfe:	b913      	cbnz	r3, 8020c06 <com_sendto_ip_modem+0xe2>
              && (socket_desc->state == COM_SOCKET_CONNECTED))
 8020c00:	783b      	ldrb	r3, [r7, #0]
 8020c02:	2b03      	cmp	r3, #3
 8020c04:	d00a      	beq.n	8020c1c <com_sendto_ip_modem+0xf8>
            if (socket_desc->closing == true)
 8020c06:	78bb      	ldrb	r3, [r7, #2]
 8020c08:	2b00      	cmp	r3, #0
 8020c0a:	f040 813b 	bne.w	8020e84 <com_sendto_ip_modem+0x360>
          com_sockets_statistic_update((result >= 0) ? \
 8020c0e:	2e00      	cmp	r6, #0
 8020c10:	f2c0 8163 	blt.w	8020eda <com_sendto_ip_modem+0x3b6>
 8020c14:	2004      	movs	r0, #4
 8020c16:	f000 fe25 	bl	8021864 <com_sockets_statistic_update>
 8020c1a:	e7a3      	b.n	8020b64 <com_sendto_ip_modem+0x40>
            if (com_ip_modem_is_network_up() == false)
 8020c1c:	f7ff f9e2 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020c20:	bb48      	cbnz	r0, 8020c76 <com_sendto_ip_modem+0x152>
              PRINT_ERR("sndto data NOK no network")
 8020c22:	4e92      	ldr	r6, [pc, #584]	; (8020e6c <com_sendto_ip_modem+0x348>)
 8020c24:	4c8f      	ldr	r4, [pc, #572]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020c26:	f106 0c20 	add.w	ip, r6, #32
 8020c2a:	4635      	mov	r5, r6
 8020c2c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020c2e:	6020      	str	r0, [r4, #0]
 8020c30:	6061      	str	r1, [r4, #4]
 8020c32:	60a2      	str	r2, [r4, #8]
 8020c34:	60e3      	str	r3, [r4, #12]
 8020c36:	462e      	mov	r6, r5
 8020c38:	3410      	adds	r4, #16
 8020c3a:	4565      	cmp	r5, ip
 8020c3c:	d1f5      	bne.n	8020c2a <com_sendto_ip_modem+0x106>
 8020c3e:	ce03      	ldmia	r6!, {r0, r1}
 8020c40:	6020      	str	r0, [r4, #0]
 8020c42:	6061      	str	r1, [r4, #4]
 8020c44:	8833      	ldrh	r3, [r6, #0]
 8020c46:	8123      	strh	r3, [r4, #8]
 8020c48:	4c86      	ldr	r4, [pc, #536]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020c4a:	4620      	mov	r0, r4
 8020c4c:	f7fe fa61 	bl	801f112 <crs_strlen>
 8020c50:	b283      	uxth	r3, r0
 8020c52:	4622      	mov	r2, r4
 8020c54:	2110      	movs	r1, #16
 8020c56:	2003      	movs	r0, #3
 8020c58:	f7fe fa9e 	bl	801f198 <traceIF_itmPrint>
 8020c5c:	4620      	mov	r0, r4
 8020c5e:	f7fe fa58 	bl	801f112 <crs_strlen>
 8020c62:	b283      	uxth	r3, r0
 8020c64:	4622      	mov	r2, r4
 8020c66:	2110      	movs	r1, #16
 8020c68:	2003      	movs	r0, #3
 8020c6a:	f7fe fab7 	bl	801f1dc <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_NONETWORK;
 8020c6e:	f06f 060a 	mvn.w	r6, #10
          com_sockets_statistic_update((result >= 0) ? \
 8020c72:	2005      	movs	r0, #5
 8020c74:	e7cf      	b.n	8020c16 <com_sendto_ip_modem+0xf2>
              socket_desc->state = COM_SOCKET_SENDING;
 8020c76:	2304      	movs	r3, #4
 8020c78:	703b      	strb	r3, [r7, #0]
              com_ip_modem_wakeup_request();
 8020c7a:	f7ff f9f1 	bl	8020060 <com_ip_modem_wakeup_request>
              if (flags == COM_MSG_DONTWAIT)
 8020c7e:	2d01      	cmp	r5, #1
 8020c80:	d005      	beq.n	8020c8e <com_sendto_ip_modem+0x16a>
                is_network_up = com_ip_modem_is_network_up();
 8020c82:	f7ff f9af 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020c86:	4682      	mov	sl, r0
              length_send = 0U;
 8020c88:	f04f 0900 	mov.w	r9, #0
                while ((length_send != (uint32_t)len)
 8020c8c:	e08a      	b.n	8020da4 <com_sendto_ip_modem+0x280>
                length_to_send = COM_MIN((uint32_t)len, COM_MODEM_MAX_TX_DATA_SIZE);
 8020c8e:	f240 26c6 	movw	r6, #710	; 0x2c6
 8020c92:	4546      	cmp	r6, r8
 8020c94:	bf28      	it	cs
 8020c96:	4646      	movcs	r6, r8
                if (osCDS_socket_sendto(socket_desc->id,
 8020c98:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
 8020c9c:	9301      	str	r3, [sp, #4]
 8020c9e:	f10d 031d 	add.w	r3, sp, #29
 8020ca2:	9300      	str	r3, [sp, #0]
 8020ca4:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8020ca8:	4632      	mov	r2, r6
 8020caa:	4621      	mov	r1, r4
 8020cac:	68b8      	ldr	r0, [r7, #8]
 8020cae:	f7f9 fe03 	bl	801a8b8 <osCDS_socket_sendto>
 8020cb2:	bb38      	cbnz	r0, 8020d04 <com_sendto_ip_modem+0x1e0>
                  PRINT_INFO("sndto data DONTWAIT ok")
 8020cb4:	4d6e      	ldr	r5, [pc, #440]	; (8020e70 <com_sendto_ip_modem+0x34c>)
 8020cb6:	4c6b      	ldr	r4, [pc, #428]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020cb8:	f105 0e20 	add.w	lr, r5, #32
 8020cbc:	46ac      	mov	ip, r5
 8020cbe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020cc2:	6020      	str	r0, [r4, #0]
 8020cc4:	6061      	str	r1, [r4, #4]
 8020cc6:	60a2      	str	r2, [r4, #8]
 8020cc8:	60e3      	str	r3, [r4, #12]
 8020cca:	4665      	mov	r5, ip
 8020ccc:	3410      	adds	r4, #16
 8020cce:	45f4      	cmp	ip, lr
 8020cd0:	d1f4      	bne.n	8020cbc <com_sendto_ip_modem+0x198>
 8020cd2:	f89c 3000 	ldrb.w	r3, [ip]
 8020cd6:	7023      	strb	r3, [r4, #0]
 8020cd8:	4c62      	ldr	r4, [pc, #392]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020cda:	4620      	mov	r0, r4
 8020cdc:	f7fe fa19 	bl	801f112 <crs_strlen>
 8020ce0:	b283      	uxth	r3, r0
 8020ce2:	4622      	mov	r2, r4
 8020ce4:	2101      	movs	r1, #1
 8020ce6:	2003      	movs	r0, #3
 8020ce8:	f7fe fa56 	bl	801f198 <traceIF_itmPrint>
 8020cec:	4620      	mov	r0, r4
 8020cee:	f7fe fa10 	bl	801f112 <crs_strlen>
 8020cf2:	b283      	uxth	r3, r0
 8020cf4:	4622      	mov	r2, r4
 8020cf6:	2101      	movs	r1, #1
 8020cf8:	2003      	movs	r0, #3
 8020cfa:	f7fe fa6f 	bl	801f1dc <traceIF_uartPrint>
                socket_desc->state = COM_SOCKET_CONNECTED;
 8020cfe:	2303      	movs	r3, #3
 8020d00:	703b      	strb	r3, [r7, #0]
 8020d02:	e784      	b.n	8020c0e <com_sendto_ip_modem+0xea>
                  PRINT_ERR("sndto data DONTWAIT NOK at low level")
 8020d04:	4d5b      	ldr	r5, [pc, #364]	; (8020e74 <com_sendto_ip_modem+0x350>)
 8020d06:	4c57      	ldr	r4, [pc, #348]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020d08:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8020d0c:	462e      	mov	r6, r5
 8020d0e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020d10:	6020      	str	r0, [r4, #0]
 8020d12:	6061      	str	r1, [r4, #4]
 8020d14:	60a2      	str	r2, [r4, #8]
 8020d16:	60e3      	str	r3, [r4, #12]
 8020d18:	4635      	mov	r5, r6
 8020d1a:	3410      	adds	r4, #16
 8020d1c:	4566      	cmp	r6, ip
 8020d1e:	d1f5      	bne.n	8020d0c <com_sendto_ip_modem+0x1e8>
 8020d20:	6830      	ldr	r0, [r6, #0]
 8020d22:	6020      	str	r0, [r4, #0]
 8020d24:	7933      	ldrb	r3, [r6, #4]
 8020d26:	7123      	strb	r3, [r4, #4]
 8020d28:	4c4e      	ldr	r4, [pc, #312]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020d2a:	4620      	mov	r0, r4
 8020d2c:	f7fe f9f1 	bl	801f112 <crs_strlen>
 8020d30:	b283      	uxth	r3, r0
 8020d32:	4622      	mov	r2, r4
 8020d34:	2110      	movs	r1, #16
 8020d36:	2003      	movs	r0, #3
 8020d38:	f7fe fa2e 	bl	801f198 <traceIF_itmPrint>
 8020d3c:	4620      	mov	r0, r4
 8020d3e:	f7fe f9e8 	bl	801f112 <crs_strlen>
 8020d42:	b283      	uxth	r3, r0
 8020d44:	4622      	mov	r2, r4
 8020d46:	2110      	movs	r1, #16
 8020d48:	2003      	movs	r0, #3
 8020d4a:	f7fe fa47 	bl	801f1dc <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_GENERAL;
 8020d4e:	f04f 36ff 	mov.w	r6, #4294967295
 8020d52:	e7d4      	b.n	8020cfe <com_sendto_ip_modem+0x1da>
                    socket_desc->state = COM_SOCKET_CONNECTED;
 8020d54:	2303      	movs	r3, #3
 8020d56:	703b      	strb	r3, [r7, #0]
                    PRINT_ERR("sndto data NOK at low level")
 8020d58:	4e47      	ldr	r6, [pc, #284]	; (8020e78 <com_sendto_ip_modem+0x354>)
 8020d5a:	4d42      	ldr	r5, [pc, #264]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020d5c:	f106 0e20 	add.w	lr, r6, #32
 8020d60:	46b4      	mov	ip, r6
 8020d62:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020d66:	6028      	str	r0, [r5, #0]
 8020d68:	6069      	str	r1, [r5, #4]
 8020d6a:	60aa      	str	r2, [r5, #8]
 8020d6c:	60eb      	str	r3, [r5, #12]
 8020d6e:	4666      	mov	r6, ip
 8020d70:	3510      	adds	r5, #16
 8020d72:	45f4      	cmp	ip, lr
 8020d74:	d1f4      	bne.n	8020d60 <com_sendto_ip_modem+0x23c>
 8020d76:	ce07      	ldmia	r6!, {r0, r1, r2}
 8020d78:	6028      	str	r0, [r5, #0]
 8020d7a:	6069      	str	r1, [r5, #4]
 8020d7c:	60aa      	str	r2, [r5, #8]
 8020d7e:	4d39      	ldr	r5, [pc, #228]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020d80:	4628      	mov	r0, r5
 8020d82:	f7fe f9c6 	bl	801f112 <crs_strlen>
 8020d86:	b283      	uxth	r3, r0
 8020d88:	462a      	mov	r2, r5
 8020d8a:	2110      	movs	r1, #16
 8020d8c:	2003      	movs	r0, #3
 8020d8e:	f7fe fa03 	bl	801f198 <traceIF_itmPrint>
 8020d92:	4628      	mov	r0, r5
 8020d94:	f7fe f9bd 	bl	801f112 <crs_strlen>
 8020d98:	b283      	uxth	r3, r0
 8020d9a:	462a      	mov	r2, r5
 8020d9c:	2110      	movs	r1, #16
 8020d9e:	2003      	movs	r0, #3
 8020da0:	f7fe fa1c 	bl	801f1dc <traceIF_uartPrint>
                       && (socket_desc->state == COM_SOCKET_SENDING))
 8020da4:	45c8      	cmp	r8, r9
 8020da6:	d059      	beq.n	8020e5c <com_sendto_ip_modem+0x338>
                       && (socket_desc->closing == false)
 8020da8:	78bb      	ldrb	r3, [r7, #2]
 8020daa:	2b00      	cmp	r3, #0
 8020dac:	d156      	bne.n	8020e5c <com_sendto_ip_modem+0x338>
                       && (is_network_up == true)
 8020dae:	f1ba 0f00 	cmp.w	sl, #0
 8020db2:	d053      	beq.n	8020e5c <com_sendto_ip_modem+0x338>
                       && (socket_desc->state == COM_SOCKET_SENDING))
 8020db4:	783b      	ldrb	r3, [r7, #0]
 8020db6:	2b04      	cmp	r3, #4
 8020db8:	d150      	bne.n	8020e5c <com_sendto_ip_modem+0x338>
                  length_to_send = COM_MIN((((uint32_t)len) - length_send),
 8020dba:	eba8 0509 	sub.w	r5, r8, r9
 8020dbe:	f240 23c6 	movw	r3, #710	; 0x2c6
 8020dc2:	429d      	cmp	r5, r3
 8020dc4:	bf28      	it	cs
 8020dc6:	461d      	movcs	r5, r3
                  com_ip_modem_wakeup_request();
 8020dc8:	f7ff f94a 	bl	8020060 <com_ip_modem_wakeup_request>
                  if (osCDS_socket_sendto(socket_desc->id,
 8020dcc:	68b8      	ldr	r0, [r7, #8]
 8020dce:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
 8020dd2:	9301      	str	r3, [sp, #4]
 8020dd4:	f10d 031d 	add.w	r3, sp, #29
 8020dd8:	9300      	str	r3, [sp, #0]
 8020dda:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8020dde:	462a      	mov	r2, r5
 8020de0:	eb04 0109 	add.w	r1, r4, r9
 8020de4:	f7f9 fd68 	bl	801a8b8 <osCDS_socket_sendto>
 8020de8:	2800      	cmp	r0, #0
 8020dea:	d1b3      	bne.n	8020d54 <com_sendto_ip_modem+0x230>
                    length_send += length_to_send;
 8020dec:	44a9      	add	r9, r5
                    PRINT_INFO("send data = %s", buf)
 8020dee:	4d1d      	ldr	r5, [pc, #116]	; (8020e64 <com_sendto_ip_modem+0x340>)
 8020df0:	4622      	mov	r2, r4
 8020df2:	4922      	ldr	r1, [pc, #136]	; (8020e7c <com_sendto_ip_modem+0x358>)
 8020df4:	4628      	mov	r0, r5
 8020df6:	f004 ff3b 	bl	8025c70 <sprintf>
 8020dfa:	4628      	mov	r0, r5
 8020dfc:	f7fe f989 	bl	801f112 <crs_strlen>
 8020e00:	b283      	uxth	r3, r0
 8020e02:	462a      	mov	r2, r5
 8020e04:	2101      	movs	r1, #1
 8020e06:	2003      	movs	r0, #3
 8020e08:	f7fe f9c6 	bl	801f198 <traceIF_itmPrint>
 8020e0c:	4628      	mov	r0, r5
 8020e0e:	f7fe f980 	bl	801f112 <crs_strlen>
 8020e12:	b283      	uxth	r3, r0
 8020e14:	462a      	mov	r2, r5
 8020e16:	2101      	movs	r1, #1
 8020e18:	2003      	movs	r0, #3
 8020e1a:	f7fe f9df 	bl	801f1dc <traceIF_uartPrint>
                    PRINT_INFO("sndto data ok")
 8020e1e:	4e18      	ldr	r6, [pc, #96]	; (8020e80 <com_sendto_ip_modem+0x35c>)
 8020e20:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020e22:	6028      	str	r0, [r5, #0]
 8020e24:	6069      	str	r1, [r5, #4]
 8020e26:	60aa      	str	r2, [r5, #8]
 8020e28:	60eb      	str	r3, [r5, #12]
 8020e2a:	ce03      	ldmia	r6!, {r0, r1}
 8020e2c:	6128      	str	r0, [r5, #16]
 8020e2e:	6169      	str	r1, [r5, #20]
 8020e30:	4628      	mov	r0, r5
 8020e32:	f7fe f96e 	bl	801f112 <crs_strlen>
 8020e36:	b283      	uxth	r3, r0
 8020e38:	462a      	mov	r2, r5
 8020e3a:	2101      	movs	r1, #1
 8020e3c:	2003      	movs	r0, #3
 8020e3e:	f7fe f9ab 	bl	801f198 <traceIF_itmPrint>
 8020e42:	4628      	mov	r0, r5
 8020e44:	f7fe f965 	bl	801f112 <crs_strlen>
 8020e48:	b283      	uxth	r3, r0
 8020e4a:	462a      	mov	r2, r5
 8020e4c:	2101      	movs	r1, #1
 8020e4e:	2003      	movs	r0, #3
 8020e50:	f7fe f9c4 	bl	801f1dc <traceIF_uartPrint>
                    is_network_up = com_ip_modem_is_network_up();
 8020e54:	f7ff f8c6 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020e58:	4682      	mov	sl, r0
 8020e5a:	e7a3      	b.n	8020da4 <com_sendto_ip_modem+0x280>
                socket_desc->state = COM_SOCKET_CONNECTED;
 8020e5c:	2303      	movs	r3, #3
 8020e5e:	703b      	strb	r3, [r7, #0]
                result = (int32_t)length_send;
 8020e60:	464e      	mov	r6, r9
              com_ip_modem_idlemode_request(false);
 8020e62:	e6d4      	b.n	8020c0e <com_sendto_ip_modem+0xea>
 8020e64:	200049dc 	.word	0x200049dc
 8020e68:	08035774 	.word	0x08035774
 8020e6c:	0803578c 	.word	0x0803578c
 8020e70:	080357b8 	.word	0x080357b8
 8020e74:	080357dc 	.word	0x080357dc
 8020e78:	08035848 	.word	0x08035848
 8020e7c:	08035814 	.word	0x08035814
 8020e80:	08035830 	.word	0x08035830
              PRINT_ERR("sndto data NOK socket closing")
 8020e84:	4d1e      	ldr	r5, [pc, #120]	; (8020f00 <com_sendto_ip_modem+0x3dc>)
 8020e86:	4c1f      	ldr	r4, [pc, #124]	; (8020f04 <com_sendto_ip_modem+0x3e0>)
 8020e88:	f105 0c20 	add.w	ip, r5, #32
 8020e8c:	462e      	mov	r6, r5
 8020e8e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020e90:	6020      	str	r0, [r4, #0]
 8020e92:	6061      	str	r1, [r4, #4]
 8020e94:	60a2      	str	r2, [r4, #8]
 8020e96:	60e3      	str	r3, [r4, #12]
 8020e98:	4635      	mov	r5, r6
 8020e9a:	3410      	adds	r4, #16
 8020e9c:	4566      	cmp	r6, ip
 8020e9e:	d1f5      	bne.n	8020e8c <com_sendto_ip_modem+0x368>
 8020ea0:	cd07      	ldmia	r5!, {r0, r1, r2}
 8020ea2:	6020      	str	r0, [r4, #0]
 8020ea4:	6061      	str	r1, [r4, #4]
 8020ea6:	60a2      	str	r2, [r4, #8]
 8020ea8:	882b      	ldrh	r3, [r5, #0]
 8020eaa:	81a3      	strh	r3, [r4, #12]
 8020eac:	4c15      	ldr	r4, [pc, #84]	; (8020f04 <com_sendto_ip_modem+0x3e0>)
 8020eae:	4620      	mov	r0, r4
 8020eb0:	f7fe f92f 	bl	801f112 <crs_strlen>
 8020eb4:	b283      	uxth	r3, r0
 8020eb6:	4622      	mov	r2, r4
 8020eb8:	2110      	movs	r1, #16
 8020eba:	2003      	movs	r0, #3
 8020ebc:	f7fe f96c 	bl	801f198 <traceIF_itmPrint>
 8020ec0:	4620      	mov	r0, r4
 8020ec2:	f7fe f926 	bl	801f112 <crs_strlen>
 8020ec6:	b283      	uxth	r3, r0
 8020ec8:	4622      	mov	r2, r4
 8020eca:	2110      	movs	r1, #16
 8020ecc:	2003      	movs	r0, #3
 8020ece:	f7fe f985 	bl	801f1dc <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_CLOSING;
 8020ed2:	f06f 0605 	mvn.w	r6, #5
          com_sockets_statistic_update((result >= 0) ? \
 8020ed6:	2005      	movs	r0, #5
 8020ed8:	e69d      	b.n	8020c16 <com_sendto_ip_modem+0xf2>
 8020eda:	2005      	movs	r0, #5
 8020edc:	e69b      	b.n	8020c16 <com_sendto_ip_modem+0xf2>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020ede:	f06f 0602 	mvn.w	r6, #2
 8020ee2:	e63f      	b.n	8020b64 <com_sendto_ip_modem+0x40>
 8020ee4:	f06f 0602 	mvn.w	r6, #2
  }
  else
  {
    SOCKET_SET_ERROR(socket_desc, result);
 8020ee8:	b107      	cbz	r7, 8020eec <com_sendto_ip_modem+0x3c8>
 8020eea:	607e      	str	r6, [r7, #4]
  }

  return (result);
}
 8020eec:	4630      	mov	r0, r6
 8020eee:	b012      	add	sp, #72	; 0x48
 8020ef0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  result = COM_SOCKETS_ERR_PARAMETER;
 8020ef4:	f06f 0602 	mvn.w	r6, #2
 8020ef8:	e7f6      	b.n	8020ee8 <com_sendto_ip_modem+0x3c4>
 8020efa:	f06f 0602 	mvn.w	r6, #2
 8020efe:	e7f3      	b.n	8020ee8 <com_sendto_ip_modem+0x3c4>
 8020f00:	08035874 	.word	0x08035874
 8020f04:	200049dc 	.word	0x200049dc

08020f08 <com_send_ip_modem>:
{
 8020f08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020f0c:	b082      	sub	sp, #8
 8020f0e:	4680      	mov	r8, r0
 8020f10:	460f      	mov	r7, r1
 8020f12:	4616      	mov	r6, r2
 8020f14:	461d      	mov	r5, r3
  socket_desc = com_ip_modem_find_socket(sock, false);
 8020f16:	2100      	movs	r1, #0
 8020f18:	f7ff f844 	bl	801ffa4 <com_ip_modem_find_socket>
  if ((socket_desc != NULL)
 8020f1c:	4604      	mov	r4, r0
 8020f1e:	2800      	cmp	r0, #0
 8020f20:	f000 8195 	beq.w	802124e <com_send_ip_modem+0x346>
      && (buf != NULL)
 8020f24:	2f00      	cmp	r7, #0
 8020f26:	f000 819a 	beq.w	802125e <com_send_ip_modem+0x356>
      && (len > 0))
 8020f2a:	2e00      	cmp	r6, #0
 8020f2c:	f340 819a 	ble.w	8021264 <com_send_ip_modem+0x35c>
    if (socket_desc->state == COM_SOCKET_CONNECTED)
 8020f30:	7803      	ldrb	r3, [r0, #0]
 8020f32:	2b03      	cmp	r3, #3
 8020f34:	f040 8147 	bne.w	80211c6 <com_send_ip_modem+0x2be>
      if (socket_desc->closing == false)
 8020f38:	7883      	ldrb	r3, [r0, #2]
 8020f3a:	2b00      	cmp	r3, #0
 8020f3c:	f040 811b 	bne.w	8021176 <com_send_ip_modem+0x26e>
        if (com_ip_modem_is_network_up() == false)
 8020f40:	f7ff f850 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020f44:	bb30      	cbnz	r0, 8020f94 <com_send_ip_modem+0x8c>
          PRINT_ERR("snd data NOK no network")
 8020f46:	4fc9      	ldr	r7, [pc, #804]	; (802126c <com_send_ip_modem+0x364>)
 8020f48:	4dc9      	ldr	r5, [pc, #804]	; (8021270 <com_send_ip_modem+0x368>)
 8020f4a:	f107 0c20 	add.w	ip, r7, #32
 8020f4e:	463e      	mov	r6, r7
 8020f50:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020f52:	6028      	str	r0, [r5, #0]
 8020f54:	6069      	str	r1, [r5, #4]
 8020f56:	60aa      	str	r2, [r5, #8]
 8020f58:	60eb      	str	r3, [r5, #12]
 8020f5a:	4637      	mov	r7, r6
 8020f5c:	3510      	adds	r5, #16
 8020f5e:	4566      	cmp	r6, ip
 8020f60:	d1f5      	bne.n	8020f4e <com_send_ip_modem+0x46>
 8020f62:	cf03      	ldmia	r7!, {r0, r1}
 8020f64:	6028      	str	r0, [r5, #0]
 8020f66:	6069      	str	r1, [r5, #4]
 8020f68:	4dc1      	ldr	r5, [pc, #772]	; (8021270 <com_send_ip_modem+0x368>)
 8020f6a:	4628      	mov	r0, r5
 8020f6c:	f7fe f8d1 	bl	801f112 <crs_strlen>
 8020f70:	b283      	uxth	r3, r0
 8020f72:	462a      	mov	r2, r5
 8020f74:	2110      	movs	r1, #16
 8020f76:	2003      	movs	r0, #3
 8020f78:	f7fe f90e 	bl	801f198 <traceIF_itmPrint>
 8020f7c:	4628      	mov	r0, r5
 8020f7e:	f7fe f8c8 	bl	801f112 <crs_strlen>
 8020f82:	b283      	uxth	r3, r0
 8020f84:	462a      	mov	r2, r5
 8020f86:	2110      	movs	r1, #16
 8020f88:	2003      	movs	r0, #3
 8020f8a:	f7fe f927 	bl	801f1dc <traceIF_uartPrint>
          result = COM_SOCKETS_ERR_NONETWORK;
 8020f8e:	f06f 050a 	mvn.w	r5, #10
 8020f92:	e14c      	b.n	802122e <com_send_ip_modem+0x326>
          com_ip_modem_wakeup_request();
 8020f94:	f7ff f864 	bl	8020060 <com_ip_modem_wakeup_request>
          if ((socket_desc->type == (uint8_t)COM_SOCK_DGRAM)
 8020f98:	78e3      	ldrb	r3, [r4, #3]
 8020f9a:	2b02      	cmp	r3, #2
 8020f9c:	d008      	beq.n	8020fb0 <com_send_ip_modem+0xa8>
            socket_desc->state = COM_SOCKET_SENDING;
 8020f9e:	2304      	movs	r3, #4
 8020fa0:	7023      	strb	r3, [r4, #0]
            if (flags == COM_MSG_DONTWAIT)
 8020fa2:	2d01      	cmp	r5, #1
 8020fa4:	d00f      	beq.n	8020fc6 <com_send_ip_modem+0xbe>
              is_network_up = com_ip_modem_is_network_up();
 8020fa6:	f7ff f81d 	bl	801ffe4 <com_ip_modem_is_network_up>
 8020faa:	4680      	mov	r8, r0
            length_send = 0U;
 8020fac:	2500      	movs	r5, #0
              while ((length_send != (uint32_t)len)
 8020fae:	e097      	b.n	80210e0 <com_send_ip_modem+0x1d8>
            result = com_sendto_ip_modem(sock, buf, len, flags, NULL, 0);
 8020fb0:	2300      	movs	r3, #0
 8020fb2:	9301      	str	r3, [sp, #4]
 8020fb4:	9300      	str	r3, [sp, #0]
 8020fb6:	462b      	mov	r3, r5
 8020fb8:	4632      	mov	r2, r6
 8020fba:	4639      	mov	r1, r7
 8020fbc:	4640      	mov	r0, r8
 8020fbe:	f7ff fdb1 	bl	8020b24 <com_sendto_ip_modem>
 8020fc2:	4605      	mov	r5, r0
 8020fc4:	e133      	b.n	802122e <com_send_ip_modem+0x326>
              length_to_send = COM_MIN((uint32_t)len, COM_MODEM_MAX_TX_DATA_SIZE);
 8020fc6:	f240 25c6 	movw	r5, #710	; 0x2c6
 8020fca:	42b5      	cmp	r5, r6
 8020fcc:	bf28      	it	cs
 8020fce:	4635      	movcs	r5, r6
              if (osCDS_socket_send(socket_desc->id,
 8020fd0:	462a      	mov	r2, r5
 8020fd2:	4639      	mov	r1, r7
 8020fd4:	68a0      	ldr	r0, [r4, #8]
 8020fd6:	f7f9 fc51 	bl	801a87c <osCDS_socket_send>
 8020fda:	bb08      	cbnz	r0, 8021020 <com_send_ip_modem+0x118>
                PRINT_INFO("snd data DONTWAIT ok")
 8020fdc:	4ea4      	ldr	r6, [pc, #656]	; (8021270 <com_send_ip_modem+0x368>)
 8020fde:	4fa5      	ldr	r7, [pc, #660]	; (8021274 <com_send_ip_modem+0x36c>)
 8020fe0:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8020fe2:	6030      	str	r0, [r6, #0]
 8020fe4:	6071      	str	r1, [r6, #4]
 8020fe6:	60b2      	str	r2, [r6, #8]
 8020fe8:	60f3      	str	r3, [r6, #12]
 8020fea:	cf07      	ldmia	r7!, {r0, r1, r2}
 8020fec:	6130      	str	r0, [r6, #16]
 8020fee:	6171      	str	r1, [r6, #20]
 8020ff0:	61b2      	str	r2, [r6, #24]
 8020ff2:	883a      	ldrh	r2, [r7, #0]
 8020ff4:	78bb      	ldrb	r3, [r7, #2]
 8020ff6:	83b2      	strh	r2, [r6, #28]
 8020ff8:	77b3      	strb	r3, [r6, #30]
 8020ffa:	4630      	mov	r0, r6
 8020ffc:	f7fe f889 	bl	801f112 <crs_strlen>
 8021000:	b283      	uxth	r3, r0
 8021002:	4632      	mov	r2, r6
 8021004:	2101      	movs	r1, #1
 8021006:	2003      	movs	r0, #3
 8021008:	f7fe f8c6 	bl	801f198 <traceIF_itmPrint>
 802100c:	4630      	mov	r0, r6
 802100e:	f7fe f880 	bl	801f112 <crs_strlen>
 8021012:	b283      	uxth	r3, r0
 8021014:	4632      	mov	r2, r6
 8021016:	2101      	movs	r1, #1
 8021018:	2003      	movs	r0, #3
 802101a:	f7fe f8df 	bl	801f1dc <traceIF_uartPrint>
 802101e:	e026      	b.n	802106e <com_send_ip_modem+0x166>
                PRINT_ERR("snd data DONTWAIT NOK at low level")
 8021020:	4f95      	ldr	r7, [pc, #596]	; (8021278 <com_send_ip_modem+0x370>)
 8021022:	4d93      	ldr	r5, [pc, #588]	; (8021270 <com_send_ip_modem+0x368>)
 8021024:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8021028:	463e      	mov	r6, r7
 802102a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 802102c:	6028      	str	r0, [r5, #0]
 802102e:	6069      	str	r1, [r5, #4]
 8021030:	60aa      	str	r2, [r5, #8]
 8021032:	60eb      	str	r3, [r5, #12]
 8021034:	4637      	mov	r7, r6
 8021036:	3510      	adds	r5, #16
 8021038:	4566      	cmp	r6, ip
 802103a:	d1f5      	bne.n	8021028 <com_send_ip_modem+0x120>
 802103c:	8832      	ldrh	r2, [r6, #0]
 802103e:	78b3      	ldrb	r3, [r6, #2]
 8021040:	802a      	strh	r2, [r5, #0]
 8021042:	70ab      	strb	r3, [r5, #2]
 8021044:	4d8a      	ldr	r5, [pc, #552]	; (8021270 <com_send_ip_modem+0x368>)
 8021046:	4628      	mov	r0, r5
 8021048:	f7fe f863 	bl	801f112 <crs_strlen>
 802104c:	b283      	uxth	r3, r0
 802104e:	462a      	mov	r2, r5
 8021050:	2110      	movs	r1, #16
 8021052:	2003      	movs	r0, #3
 8021054:	f7fe f8a0 	bl	801f198 <traceIF_itmPrint>
 8021058:	4628      	mov	r0, r5
 802105a:	f7fe f85a 	bl	801f112 <crs_strlen>
 802105e:	b283      	uxth	r3, r0
 8021060:	462a      	mov	r2, r5
 8021062:	2110      	movs	r1, #16
 8021064:	2003      	movs	r0, #3
 8021066:	f7fe f8b9 	bl	801f1dc <traceIF_uartPrint>
            result = COM_SOCKETS_ERR_GENERAL;
 802106a:	f04f 35ff 	mov.w	r5, #4294967295
              socket_desc->state = COM_SOCKET_CONNECTED;
 802106e:	2303      	movs	r3, #3
 8021070:	7023      	strb	r3, [r4, #0]
 8021072:	e0dc      	b.n	802122e <com_send_ip_modem+0x326>
                  socket_desc->state = COM_SOCKET_CONNECTED;
 8021074:	2303      	movs	r3, #3
 8021076:	7023      	strb	r3, [r4, #0]
                  PRINT_ERR("snd data NOK at low level")
 8021078:	f8df c208 	ldr.w	ip, [pc, #520]	; 8021284 <com_send_ip_modem+0x37c>
 802107c:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8021270 <com_send_ip_modem+0x368>
 8021080:	f10c 0a20 	add.w	sl, ip, #32
 8021084:	46e6      	mov	lr, ip
 8021086:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 802108a:	f8c9 0000 	str.w	r0, [r9]
 802108e:	f8c9 1004 	str.w	r1, [r9, #4]
 8021092:	f8c9 2008 	str.w	r2, [r9, #8]
 8021096:	f8c9 300c 	str.w	r3, [r9, #12]
 802109a:	46f4      	mov	ip, lr
 802109c:	f109 0910 	add.w	r9, r9, #16
 80210a0:	45d6      	cmp	lr, sl
 80210a2:	d1ef      	bne.n	8021084 <com_send_ip_modem+0x17c>
 80210a4:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 80210a8:	f8c9 0000 	str.w	r0, [r9]
 80210ac:	f8c9 1004 	str.w	r1, [r9, #4]
 80210b0:	f8bc 3000 	ldrh.w	r3, [ip]
 80210b4:	f8a9 3008 	strh.w	r3, [r9, #8]
 80210b8:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8021270 <com_send_ip_modem+0x368>
 80210bc:	4648      	mov	r0, r9
 80210be:	f7fe f828 	bl	801f112 <crs_strlen>
 80210c2:	b283      	uxth	r3, r0
 80210c4:	464a      	mov	r2, r9
 80210c6:	2110      	movs	r1, #16
 80210c8:	2003      	movs	r0, #3
 80210ca:	f7fe f865 	bl	801f198 <traceIF_itmPrint>
 80210ce:	4648      	mov	r0, r9
 80210d0:	f7fe f81f 	bl	801f112 <crs_strlen>
 80210d4:	b283      	uxth	r3, r0
 80210d6:	464a      	mov	r2, r9
 80210d8:	2110      	movs	r1, #16
 80210da:	2003      	movs	r0, #3
 80210dc:	f7fe f87e 	bl	801f1dc <traceIF_uartPrint>
                     && (socket_desc->state == COM_SOCKET_SENDING))
 80210e0:	42ae      	cmp	r6, r5
 80210e2:	d045      	beq.n	8021170 <com_send_ip_modem+0x268>
                     && (socket_desc->closing == false)
 80210e4:	78a3      	ldrb	r3, [r4, #2]
 80210e6:	2b00      	cmp	r3, #0
 80210e8:	d142      	bne.n	8021170 <com_send_ip_modem+0x268>
                     && (is_network_up == true)
 80210ea:	f1b8 0f00 	cmp.w	r8, #0
 80210ee:	d03f      	beq.n	8021170 <com_send_ip_modem+0x268>
                     && (socket_desc->state == COM_SOCKET_SENDING))
 80210f0:	7823      	ldrb	r3, [r4, #0]
 80210f2:	2b04      	cmp	r3, #4
 80210f4:	d13c      	bne.n	8021170 <com_send_ip_modem+0x268>
                length_to_send = COM_MIN((((uint32_t)len) - length_send),
 80210f6:	eba6 0905 	sub.w	r9, r6, r5
 80210fa:	f240 23c6 	movw	r3, #710	; 0x2c6
 80210fe:	4599      	cmp	r9, r3
 8021100:	bf28      	it	cs
 8021102:	4699      	movcs	r9, r3
                com_ip_modem_wakeup_request();
 8021104:	f7fe ffac 	bl	8020060 <com_ip_modem_wakeup_request>
                if (osCDS_socket_send(socket_desc->id,
 8021108:	464a      	mov	r2, r9
 802110a:	1979      	adds	r1, r7, r5
 802110c:	68a0      	ldr	r0, [r4, #8]
 802110e:	f7f9 fbb5 	bl	801a87c <osCDS_socket_send>
 8021112:	2800      	cmp	r0, #0
 8021114:	d1ae      	bne.n	8021074 <com_send_ip_modem+0x16c>
                  length_send += length_to_send;
 8021116:	444d      	add	r5, r9
                  PRINT_INFO("snd data ok")
 8021118:	f8df 8154 	ldr.w	r8, [pc, #340]	; 8021270 <com_send_ip_modem+0x368>
 802111c:	f8df c168 	ldr.w	ip, [pc, #360]	; 8021288 <com_send_ip_modem+0x380>
 8021120:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021124:	f8c8 0000 	str.w	r0, [r8]
 8021128:	f8c8 1004 	str.w	r1, [r8, #4]
 802112c:	f8c8 2008 	str.w	r2, [r8, #8]
 8021130:	f8c8 300c 	str.w	r3, [r8, #12]
 8021134:	f8dc 0000 	ldr.w	r0, [ip]
 8021138:	f8c8 0010 	str.w	r0, [r8, #16]
 802113c:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8021140:	f8a8 3014 	strh.w	r3, [r8, #20]
 8021144:	4640      	mov	r0, r8
 8021146:	f7fd ffe4 	bl	801f112 <crs_strlen>
 802114a:	b283      	uxth	r3, r0
 802114c:	4642      	mov	r2, r8
 802114e:	2101      	movs	r1, #1
 8021150:	2003      	movs	r0, #3
 8021152:	f7fe f821 	bl	801f198 <traceIF_itmPrint>
 8021156:	4640      	mov	r0, r8
 8021158:	f7fd ffdb 	bl	801f112 <crs_strlen>
 802115c:	b283      	uxth	r3, r0
 802115e:	4642      	mov	r2, r8
 8021160:	2101      	movs	r1, #1
 8021162:	2003      	movs	r0, #3
 8021164:	f7fe f83a 	bl	801f1dc <traceIF_uartPrint>
                  is_network_up = com_ip_modem_is_network_up();
 8021168:	f7fe ff3c 	bl	801ffe4 <com_ip_modem_is_network_up>
 802116c:	4680      	mov	r8, r0
 802116e:	e7b7      	b.n	80210e0 <com_send_ip_modem+0x1d8>
              socket_desc->state = COM_SOCKET_CONNECTED;
 8021170:	2303      	movs	r3, #3
 8021172:	7023      	strb	r3, [r4, #0]
          com_ip_modem_idlemode_request(false);
 8021174:	e05b      	b.n	802122e <com_send_ip_modem+0x326>
        PRINT_ERR("snd data NOK socket closing")
 8021176:	4e41      	ldr	r6, [pc, #260]	; (802127c <com_send_ip_modem+0x374>)
 8021178:	4d3d      	ldr	r5, [pc, #244]	; (8021270 <com_send_ip_modem+0x368>)
 802117a:	f106 0c20 	add.w	ip, r6, #32
 802117e:	4637      	mov	r7, r6
 8021180:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021182:	6028      	str	r0, [r5, #0]
 8021184:	6069      	str	r1, [r5, #4]
 8021186:	60aa      	str	r2, [r5, #8]
 8021188:	60eb      	str	r3, [r5, #12]
 802118a:	463e      	mov	r6, r7
 802118c:	3510      	adds	r5, #16
 802118e:	4567      	cmp	r7, ip
 8021190:	d1f5      	bne.n	802117e <com_send_ip_modem+0x276>
 8021192:	ce07      	ldmia	r6!, {r0, r1, r2}
 8021194:	6028      	str	r0, [r5, #0]
 8021196:	6069      	str	r1, [r5, #4]
 8021198:	60aa      	str	r2, [r5, #8]
 802119a:	4d35      	ldr	r5, [pc, #212]	; (8021270 <com_send_ip_modem+0x368>)
 802119c:	4628      	mov	r0, r5
 802119e:	f7fd ffb8 	bl	801f112 <crs_strlen>
 80211a2:	b283      	uxth	r3, r0
 80211a4:	462a      	mov	r2, r5
 80211a6:	2110      	movs	r1, #16
 80211a8:	2003      	movs	r0, #3
 80211aa:	f7fd fff5 	bl	801f198 <traceIF_itmPrint>
 80211ae:	4628      	mov	r0, r5
 80211b0:	f7fd ffaf 	bl	801f112 <crs_strlen>
 80211b4:	b283      	uxth	r3, r0
 80211b6:	462a      	mov	r2, r5
 80211b8:	2110      	movs	r1, #16
 80211ba:	2003      	movs	r0, #3
 80211bc:	f7fe f80e 	bl	801f1dc <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_CLOSING;
 80211c0:	f06f 0505 	mvn.w	r5, #5
 80211c4:	e033      	b.n	802122e <com_send_ip_modem+0x326>
      PRINT_ERR("snd data NOK err state")
 80211c6:	4f2e      	ldr	r7, [pc, #184]	; (8021280 <com_send_ip_modem+0x378>)
 80211c8:	4d29      	ldr	r5, [pc, #164]	; (8021270 <com_send_ip_modem+0x368>)
 80211ca:	f107 0c20 	add.w	ip, r7, #32
 80211ce:	463e      	mov	r6, r7
 80211d0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80211d2:	6028      	str	r0, [r5, #0]
 80211d4:	6069      	str	r1, [r5, #4]
 80211d6:	60aa      	str	r2, [r5, #8]
 80211d8:	60eb      	str	r3, [r5, #12]
 80211da:	4637      	mov	r7, r6
 80211dc:	3510      	adds	r5, #16
 80211de:	4566      	cmp	r6, ip
 80211e0:	d1f5      	bne.n	80211ce <com_send_ip_modem+0x2c6>
 80211e2:	6830      	ldr	r0, [r6, #0]
 80211e4:	6028      	str	r0, [r5, #0]
 80211e6:	88b2      	ldrh	r2, [r6, #4]
 80211e8:	79b3      	ldrb	r3, [r6, #6]
 80211ea:	80aa      	strh	r2, [r5, #4]
 80211ec:	71ab      	strb	r3, [r5, #6]
 80211ee:	4d20      	ldr	r5, [pc, #128]	; (8021270 <com_send_ip_modem+0x368>)
 80211f0:	4628      	mov	r0, r5
 80211f2:	f7fd ff8e 	bl	801f112 <crs_strlen>
 80211f6:	b283      	uxth	r3, r0
 80211f8:	462a      	mov	r2, r5
 80211fa:	2110      	movs	r1, #16
 80211fc:	2003      	movs	r0, #3
 80211fe:	f7fd ffcb 	bl	801f198 <traceIF_itmPrint>
 8021202:	4628      	mov	r0, r5
 8021204:	f7fd ff85 	bl	801f112 <crs_strlen>
 8021208:	b283      	uxth	r3, r0
 802120a:	462a      	mov	r2, r5
 802120c:	2110      	movs	r1, #16
 802120e:	2003      	movs	r0, #3
 8021210:	f7fd ffe4 	bl	801f1dc <traceIF_uartPrint>
      if (socket_desc->state < COM_SOCKET_CONNECTED)
 8021214:	7823      	ldrb	r3, [r4, #0]
 8021216:	2b02      	cmp	r3, #2
 8021218:	d907      	bls.n	802122a <com_send_ip_modem+0x322>
                 COM_SOCKETS_ERR_CLOSING : COM_SOCKETS_ERR_INPROGRESS;
 802121a:	2b07      	cmp	r3, #7
 802121c:	d002      	beq.n	8021224 <com_send_ip_modem+0x31c>
 802121e:	f06f 0508 	mvn.w	r5, #8
 8021222:	e004      	b.n	802122e <com_send_ip_modem+0x326>
 8021224:	f06f 0505 	mvn.w	r5, #5
 8021228:	e001      	b.n	802122e <com_send_ip_modem+0x326>
        result = COM_SOCKETS_ERR_STATE;
 802122a:	f06f 050c 	mvn.w	r5, #12
    if ((socket_desc->type == (uint8_t)COM_SOCK_STREAM)
 802122e:	78e3      	ldrb	r3, [r4, #3]
 8021230:	2b01      	cmp	r3, #1
 8021232:	d004      	beq.n	802123e <com_send_ip_modem+0x336>
  if (result >= 0)
 8021234:	2d00      	cmp	r5, #0
 8021236:	db0c      	blt.n	8021252 <com_send_ip_modem+0x34a>
    SOCKET_SET_ERROR(socket_desc, COM_SOCKETS_ERR_OK);
 8021238:	2300      	movs	r3, #0
 802123a:	6063      	str	r3, [r4, #4]
 802123c:	e00b      	b.n	8021256 <com_send_ip_modem+0x34e>
      com_sockets_statistic_update((result >= 0) ? \
 802123e:	2d00      	cmp	r5, #0
 8021240:	db03      	blt.n	802124a <com_send_ip_modem+0x342>
 8021242:	2004      	movs	r0, #4
 8021244:	f000 fb0e 	bl	8021864 <com_sockets_statistic_update>
 8021248:	e7f4      	b.n	8021234 <com_send_ip_modem+0x32c>
 802124a:	2005      	movs	r0, #5
 802124c:	e7fa      	b.n	8021244 <com_send_ip_modem+0x33c>
  result = COM_SOCKETS_ERR_PARAMETER;
 802124e:	f06f 0502 	mvn.w	r5, #2
    SOCKET_SET_ERROR(socket_desc, result);
 8021252:	b104      	cbz	r4, 8021256 <com_send_ip_modem+0x34e>
 8021254:	6065      	str	r5, [r4, #4]
}
 8021256:	4628      	mov	r0, r5
 8021258:	b002      	add	sp, #8
 802125a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  result = COM_SOCKETS_ERR_PARAMETER;
 802125e:	f06f 0502 	mvn.w	r5, #2
 8021262:	e7f6      	b.n	8021252 <com_send_ip_modem+0x34a>
 8021264:	f06f 0502 	mvn.w	r5, #2
 8021268:	e7f3      	b.n	8021252 <com_send_ip_modem+0x34a>
 802126a:	bf00      	nop
 802126c:	080358a4 	.word	0x080358a4
 8021270:	200049dc 	.word	0x200049dc
 8021274:	080358cc 	.word	0x080358cc
 8021278:	080358ec 	.word	0x080358ec
 802127c:	08035964 	.word	0x08035964
 8021280:	08035990 	.word	0x08035990
 8021284:	08035938 	.word	0x08035938
 8021288:	08035920 	.word	0x08035920

0802128c <com_closesocket_ip_modem>:
  *         socket must be considered as not closed and handle as not released
  * @param  sock      - socket handle obtained with com_socket
  * @retval int32_t   - ok or error value
  */
int32_t com_closesocket_ip_modem(int32_t sock)
{
 802128c:	b570      	push	{r4, r5, r6, lr}
 802128e:	4604      	mov	r4, r0
  int32_t result;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;
  socket_desc = com_ip_modem_find_socket(sock, false);
 8021290:	2100      	movs	r1, #0
 8021292:	f7fe fe87 	bl	801ffa4 <com_ip_modem_find_socket>

  if (socket_desc != NULL)
 8021296:	2800      	cmp	r0, #0
 8021298:	f000 808d 	beq.w	80213b6 <com_closesocket_ip_modem+0x12a>
  {
    /* If socket is currently under process refused to close it */
    if ((socket_desc->state == COM_SOCKET_SENDING)
 802129c:	7803      	ldrb	r3, [r0, #0]
        || (socket_desc->state == COM_SOCKET_WAITING_RSP))
 802129e:	3b04      	subs	r3, #4
 80212a0:	b2db      	uxtb	r3, r3
    if ((socket_desc->state == COM_SOCKET_SENDING)
 80212a2:	2b01      	cmp	r3, #1
 80212a4:	d92b      	bls.n	80212fe <com_closesocket_ip_modem+0x72>
      result = COM_SOCKETS_ERR_INPROGRESS;
    }
    else
    {
      result = COM_SOCKETS_ERR_GENERAL;
      com_ip_modem_wakeup_request();
 80212a6:	f7fe fedb 	bl	8020060 <com_ip_modem_wakeup_request>
      if (osCDS_socket_close(sock, 0U)
 80212aa:	2100      	movs	r1, #0
 80212ac:	4620      	mov	r0, r4
 80212ae:	f7f9 fb2f 	bl	801a910 <osCDS_socket_close>
 80212b2:	2800      	cmp	r0, #0
 80212b4:	d153      	bne.n	802135e <com_closesocket_ip_modem+0xd2>
          == CELLULAR_OK)
      {
        com_ip_modem_delete_socket_desc(sock, false);
 80212b6:	2100      	movs	r1, #0
 80212b8:	4620      	mov	r0, r4
 80212ba:	f7ff f965 	bl	8020588 <com_ip_modem_delete_socket_desc>
        result = COM_SOCKETS_ERR_OK;
        PRINT_INFO("close socket ok")
 80212be:	4c3f      	ldr	r4, [pc, #252]	; (80213bc <com_closesocket_ip_modem+0x130>)
 80212c0:	4d3f      	ldr	r5, [pc, #252]	; (80213c0 <com_closesocket_ip_modem+0x134>)
 80212c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80212c4:	6020      	str	r0, [r4, #0]
 80212c6:	6061      	str	r1, [r4, #4]
 80212c8:	60a2      	str	r2, [r4, #8]
 80212ca:	60e3      	str	r3, [r4, #12]
 80212cc:	cd03      	ldmia	r5!, {r0, r1}
 80212ce:	6120      	str	r0, [r4, #16]
 80212d0:	6161      	str	r1, [r4, #20]
 80212d2:	882b      	ldrh	r3, [r5, #0]
 80212d4:	8323      	strh	r3, [r4, #24]
 80212d6:	4620      	mov	r0, r4
 80212d8:	f7fd ff1b 	bl	801f112 <crs_strlen>
 80212dc:	b283      	uxth	r3, r0
 80212de:	4622      	mov	r2, r4
 80212e0:	2101      	movs	r1, #1
 80212e2:	2003      	movs	r0, #3
 80212e4:	f7fd ff58 	bl	801f198 <traceIF_itmPrint>
 80212e8:	4620      	mov	r0, r4
 80212ea:	f7fd ff12 	bl	801f112 <crs_strlen>
 80212ee:	b283      	uxth	r3, r0
 80212f0:	4622      	mov	r2, r4
 80212f2:	2101      	movs	r1, #1
 80212f4:	2003      	movs	r0, #3
 80212f6:	f7fd ff71 	bl	801f1dc <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_OK;
 80212fa:	2400      	movs	r4, #0
 80212fc:	e056      	b.n	80213ac <com_closesocket_ip_modem+0x120>
      PRINT_ERR("close socket NOK err state")
 80212fe:	4c31      	ldr	r4, [pc, #196]	; (80213c4 <com_closesocket_ip_modem+0x138>)
 8021300:	4d2e      	ldr	r5, [pc, #184]	; (80213bc <com_closesocket_ip_modem+0x130>)
 8021302:	f104 0620 	add.w	r6, r4, #32
 8021306:	46a4      	mov	ip, r4
 8021308:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 802130c:	6028      	str	r0, [r5, #0]
 802130e:	6069      	str	r1, [r5, #4]
 8021310:	60aa      	str	r2, [r5, #8]
 8021312:	60eb      	str	r3, [r5, #12]
 8021314:	4664      	mov	r4, ip
 8021316:	3510      	adds	r5, #16
 8021318:	45b4      	cmp	ip, r6
 802131a:	d1f4      	bne.n	8021306 <com_closesocket_ip_modem+0x7a>
 802131c:	cc03      	ldmia	r4!, {r0, r1}
 802131e:	6028      	str	r0, [r5, #0]
 8021320:	6069      	str	r1, [r5, #4]
 8021322:	8822      	ldrh	r2, [r4, #0]
 8021324:	78a3      	ldrb	r3, [r4, #2]
 8021326:	812a      	strh	r2, [r5, #8]
 8021328:	72ab      	strb	r3, [r5, #10]
 802132a:	4c24      	ldr	r4, [pc, #144]	; (80213bc <com_closesocket_ip_modem+0x130>)
 802132c:	4620      	mov	r0, r4
 802132e:	f7fd fef0 	bl	801f112 <crs_strlen>
 8021332:	b283      	uxth	r3, r0
 8021334:	4622      	mov	r2, r4
 8021336:	2110      	movs	r1, #16
 8021338:	2003      	movs	r0, #3
 802133a:	f7fd ff2d 	bl	801f198 <traceIF_itmPrint>
 802133e:	4620      	mov	r0, r4
 8021340:	f7fd fee7 	bl	801f112 <crs_strlen>
 8021344:	b283      	uxth	r3, r0
 8021346:	4622      	mov	r2, r4
 8021348:	2110      	movs	r1, #16
 802134a:	2003      	movs	r0, #3
 802134c:	f7fd ff46 	bl	801f1dc <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_INPROGRESS;
 8021350:	f06f 0408 	mvn.w	r4, #8
      {
        PRINT_INFO("close socket NOK low level")
      }
      com_ip_modem_idlemode_request(true);
    }
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8021354:	2009      	movs	r0, #9
 8021356:	f000 fa85 	bl	8021864 <com_sockets_statistic_update>
                                 COM_SOCKET_STAT_CLS_OK : COM_SOCKET_STAT_CLS_NOK);
  }


  return (result);
}
 802135a:	4620      	mov	r0, r4
 802135c:	bd70      	pop	{r4, r5, r6, pc}
        PRINT_INFO("close socket NOK low level")
 802135e:	4e1a      	ldr	r6, [pc, #104]	; (80213c8 <com_closesocket_ip_modem+0x13c>)
 8021360:	4c16      	ldr	r4, [pc, #88]	; (80213bc <com_closesocket_ip_modem+0x130>)
 8021362:	f106 0c20 	add.w	ip, r6, #32
 8021366:	4635      	mov	r5, r6
 8021368:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802136a:	6020      	str	r0, [r4, #0]
 802136c:	6061      	str	r1, [r4, #4]
 802136e:	60a2      	str	r2, [r4, #8]
 8021370:	60e3      	str	r3, [r4, #12]
 8021372:	462e      	mov	r6, r5
 8021374:	3410      	adds	r4, #16
 8021376:	4565      	cmp	r5, ip
 8021378:	d1f5      	bne.n	8021366 <com_closesocket_ip_modem+0xda>
 802137a:	6828      	ldr	r0, [r5, #0]
 802137c:	6020      	str	r0, [r4, #0]
 802137e:	792b      	ldrb	r3, [r5, #4]
 8021380:	7123      	strb	r3, [r4, #4]
 8021382:	4c0e      	ldr	r4, [pc, #56]	; (80213bc <com_closesocket_ip_modem+0x130>)
 8021384:	4620      	mov	r0, r4
 8021386:	f7fd fec4 	bl	801f112 <crs_strlen>
 802138a:	b283      	uxth	r3, r0
 802138c:	4622      	mov	r2, r4
 802138e:	2101      	movs	r1, #1
 8021390:	2003      	movs	r0, #3
 8021392:	f7fd ff01 	bl	801f198 <traceIF_itmPrint>
 8021396:	4620      	mov	r0, r4
 8021398:	f7fd febb 	bl	801f112 <crs_strlen>
 802139c:	b283      	uxth	r3, r0
 802139e:	4622      	mov	r2, r4
 80213a0:	2101      	movs	r1, #1
 80213a2:	2003      	movs	r0, #3
 80213a4:	f7fd ff1a 	bl	801f1dc <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_GENERAL;
 80213a8:	f04f 34ff 	mov.w	r4, #4294967295
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 80213ac:	b90c      	cbnz	r4, 80213b2 <com_closesocket_ip_modem+0x126>
 80213ae:	2008      	movs	r0, #8
 80213b0:	e7d1      	b.n	8021356 <com_closesocket_ip_modem+0xca>
 80213b2:	2009      	movs	r0, #9
 80213b4:	e7cf      	b.n	8021356 <com_closesocket_ip_modem+0xca>
  result = COM_SOCKETS_ERR_PARAMETER;
 80213b6:	f06f 0402 	mvn.w	r4, #2
  return (result);
 80213ba:	e7ce      	b.n	802135a <com_closesocket_ip_modem+0xce>
 80213bc:	200049dc 	.word	0x200049dc
 80213c0:	080359e4 	.word	0x080359e4
 80213c4:	080359b8 	.word	0x080359b8
 80213c8:	08035a00 	.word	0x08035a00

080213cc <com_socket_ip_modem>:
{
 80213cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80213d0:	460c      	mov	r4, r1
  if (family == COM_AF_INET)
 80213d2:	2802      	cmp	r0, #2
 80213d4:	d005      	beq.n	80213e2 <com_socket_ip_modem+0x16>
  else if (family == COM_AF_INET6)
 80213d6:	bbb0      	cbnz	r0, 8021446 <com_socket_ip_modem+0x7a>
    IPaddrType = CS_IPAT_IPV6; /* To avoid a warning */
 80213d8:	f04f 0802 	mov.w	r8, #2
    result = COM_SOCKETS_ERR_UNSUPPORTED;
 80213dc:	f06f 060b 	mvn.w	r6, #11
 80213e0:	e002      	b.n	80213e8 <com_socket_ip_modem+0x1c>
    IPaddrType = CS_IPAT_IPV4;
 80213e2:	f04f 0801 	mov.w	r8, #1
  result = COM_SOCKETS_ERR_OK;
 80213e6:	2600      	movs	r6, #0
  if ((type == COM_SOCK_STREAM)
 80213e8:	2c01      	cmp	r4, #1
 80213ea:	d031      	beq.n	8021450 <com_socket_ip_modem+0x84>
  else if ((type == COM_SOCK_DGRAM)
 80213ec:	2c02      	cmp	r4, #2
 80213ee:	d036      	beq.n	802145e <com_socket_ip_modem+0x92>
    result = COM_SOCKETS_ERR_UNSUPPORTED;
 80213f0:	f06f 060b 	mvn.w	r6, #11
    PRINT_ERR("create socket NOK parameter NOK")
 80213f4:	4dba      	ldr	r5, [pc, #744]	; (80216e0 <com_socket_ip_modem+0x314>)
 80213f6:	4cbb      	ldr	r4, [pc, #748]	; (80216e4 <com_socket_ip_modem+0x318>)
 80213f8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80213fc:	46ac      	mov	ip, r5
 80213fe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021402:	6020      	str	r0, [r4, #0]
 8021404:	6061      	str	r1, [r4, #4]
 8021406:	60a2      	str	r2, [r4, #8]
 8021408:	60e3      	str	r3, [r4, #12]
 802140a:	4665      	mov	r5, ip
 802140c:	3410      	adds	r4, #16
 802140e:	45f4      	cmp	ip, lr
 8021410:	d1f4      	bne.n	80213fc <com_socket_ip_modem+0x30>
 8021412:	4cb4      	ldr	r4, [pc, #720]	; (80216e4 <com_socket_ip_modem+0x318>)
 8021414:	4620      	mov	r0, r4
 8021416:	f7fd fe7c 	bl	801f112 <crs_strlen>
 802141a:	b283      	uxth	r3, r0
 802141c:	4622      	mov	r2, r4
 802141e:	2110      	movs	r1, #16
 8021420:	2003      	movs	r0, #3
 8021422:	f7fd feb9 	bl	801f198 <traceIF_itmPrint>
 8021426:	4620      	mov	r0, r4
 8021428:	f7fd fe73 	bl	801f112 <crs_strlen>
 802142c:	b283      	uxth	r3, r0
 802142e:	4622      	mov	r2, r4
 8021430:	2110      	movs	r1, #16
 8021432:	2003      	movs	r0, #3
 8021434:	f7fd fed2 	bl	801f1dc <traceIF_uartPrint>
  sock = COM_SOCKET_INVALID_ID;
 8021438:	f04f 35ff 	mov.w	r5, #4294967295
  return ((result == COM_SOCKETS_ERR_OK) ? sock : result);
 802143c:	b906      	cbnz	r6, 8021440 <com_socket_ip_modem+0x74>
 802143e:	462e      	mov	r6, r5
}
 8021440:	4630      	mov	r0, r6
 8021442:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    IPaddrType = CS_IPAT_INVALID; /* To avoid a warning */
 8021446:	f04f 0800 	mov.w	r8, #0
    result = COM_SOCKETS_ERR_PARAMETER;
 802144a:	f06f 0602 	mvn.w	r6, #2
 802144e:	e7cb      	b.n	80213e8 <com_socket_ip_modem+0x1c>
      && ((protocol == COM_IPPROTO_TCP)
 8021450:	2a06      	cmp	r2, #6
 8021452:	d00d      	beq.n	8021470 <com_socket_ip_modem+0xa4>
          || (protocol == COM_IPPROTO_IP)))
 8021454:	2a00      	cmp	r2, #0
 8021456:	d1c9      	bne.n	80213ec <com_socket_ip_modem+0x20>
    TransportProtocol = CS_TCP_PROTOCOL;
 8021458:	f04f 0900 	mov.w	r9, #0
 802145c:	e00a      	b.n	8021474 <com_socket_ip_modem+0xa8>
           && ((protocol == COM_IPPROTO_UDP)
 802145e:	2a02      	cmp	r2, #2
 8021460:	f000 80c0 	beq.w	80215e4 <com_socket_ip_modem+0x218>
               || (protocol == COM_IPPROTO_IP)))
 8021464:	2a00      	cmp	r2, #0
 8021466:	f040 81a6 	bne.w	80217b6 <com_socket_ip_modem+0x3ea>
    TransportProtocol = CS_UDP_PROTOCOL;
 802146a:	f04f 0901 	mov.w	r9, #1
 802146e:	e001      	b.n	8021474 <com_socket_ip_modem+0xa8>
    TransportProtocol = CS_TCP_PROTOCOL;
 8021470:	f04f 0900 	mov.w	r9, #0
  if (result == COM_SOCKETS_ERR_OK)
 8021474:	2e00      	cmp	r6, #0
 8021476:	d1bd      	bne.n	80213f4 <com_socket_ip_modem+0x28>
    PRINT_DBG("socket create request")
 8021478:	4d9a      	ldr	r5, [pc, #616]	; (80216e4 <com_socket_ip_modem+0x318>)
 802147a:	4f9b      	ldr	r7, [pc, #620]	; (80216e8 <com_socket_ip_modem+0x31c>)
 802147c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 802147e:	6028      	str	r0, [r5, #0]
 8021480:	6069      	str	r1, [r5, #4]
 8021482:	60aa      	str	r2, [r5, #8]
 8021484:	60eb      	str	r3, [r5, #12]
 8021486:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021488:	6128      	str	r0, [r5, #16]
 802148a:	6169      	str	r1, [r5, #20]
 802148c:	61aa      	str	r2, [r5, #24]
 802148e:	61eb      	str	r3, [r5, #28]
 8021490:	4628      	mov	r0, r5
 8021492:	f7fd fe3e 	bl	801f112 <crs_strlen>
 8021496:	b283      	uxth	r3, r0
 8021498:	462a      	mov	r2, r5
 802149a:	2102      	movs	r1, #2
 802149c:	2003      	movs	r0, #3
 802149e:	f7fd fe7b 	bl	801f198 <traceIF_itmPrint>
 80214a2:	4628      	mov	r0, r5
 80214a4:	f7fd fe35 	bl	801f112 <crs_strlen>
 80214a8:	b283      	uxth	r3, r0
 80214aa:	462a      	mov	r2, r5
 80214ac:	2102      	movs	r1, #2
 80214ae:	2003      	movs	r0, #3
 80214b0:	f7fd fe94 	bl	801f1dc <traceIF_uartPrint>
    com_ip_modem_wakeup_request();
 80214b4:	f7fe fdd4 	bl	8020060 <com_ip_modem_wakeup_request>
    sock = osCDS_socket_create(IPaddrType,
 80214b8:	220b      	movs	r2, #11
 80214ba:	4649      	mov	r1, r9
 80214bc:	4640      	mov	r0, r8
 80214be:	f7f9 f967 	bl	801a790 <osCDS_socket_create>
 80214c2:	4605      	mov	r5, r0
    if (sock != CS_INVALID_SOCKET_HANDLE)
 80214c4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80214c8:	f000 8149 	beq.w	802175e <com_socket_ip_modem+0x392>
      PRINT_INFO("create socket ok low level")
 80214cc:	f8df e234 	ldr.w	lr, [pc, #564]	; 8021704 <com_socket_ip_modem+0x338>
 80214d0:	4f84      	ldr	r7, [pc, #528]	; (80216e4 <com_socket_ip_modem+0x318>)
 80214d2:	f10e 0820 	add.w	r8, lr, #32
 80214d6:	46f4      	mov	ip, lr
 80214d8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80214dc:	6038      	str	r0, [r7, #0]
 80214de:	6079      	str	r1, [r7, #4]
 80214e0:	60ba      	str	r2, [r7, #8]
 80214e2:	60fb      	str	r3, [r7, #12]
 80214e4:	46e6      	mov	lr, ip
 80214e6:	3710      	adds	r7, #16
 80214e8:	45c4      	cmp	ip, r8
 80214ea:	d1f4      	bne.n	80214d6 <com_socket_ip_modem+0x10a>
 80214ec:	f8dc 0000 	ldr.w	r0, [ip]
 80214f0:	6038      	str	r0, [r7, #0]
 80214f2:	f89c 3004 	ldrb.w	r3, [ip, #4]
 80214f6:	713b      	strb	r3, [r7, #4]
 80214f8:	4f7a      	ldr	r7, [pc, #488]	; (80216e4 <com_socket_ip_modem+0x318>)
 80214fa:	4638      	mov	r0, r7
 80214fc:	f7fd fe09 	bl	801f112 <crs_strlen>
 8021500:	b283      	uxth	r3, r0
 8021502:	463a      	mov	r2, r7
 8021504:	2101      	movs	r1, #1
 8021506:	2003      	movs	r0, #3
 8021508:	f7fd fe46 	bl	801f198 <traceIF_itmPrint>
 802150c:	4638      	mov	r0, r7
 802150e:	f7fd fe00 	bl	801f112 <crs_strlen>
 8021512:	b283      	uxth	r3, r0
 8021514:	463a      	mov	r2, r7
 8021516:	2101      	movs	r1, #1
 8021518:	2003      	movs	r0, #3
 802151a:	f7fd fe5f 	bl	801f1dc <traceIF_uartPrint>
      socket_desc = com_ip_modem_provide_socket_desc(false);
 802151e:	2000      	movs	r0, #0
 8021520:	f7fe ffc6 	bl	80204b0 <com_ip_modem_provide_socket_desc>
      if (socket_desc == NULL)
 8021524:	2800      	cmp	r0, #0
 8021526:	d060      	beq.n	80215ea <com_socket_ip_modem+0x21e>
        socket_desc->id    = sock;
 8021528:	6085      	str	r5, [r0, #8]
        socket_desc->type  = (uint8_t)type;
 802152a:	70c4      	strb	r4, [r0, #3]
        socket_desc->state = COM_SOCKET_CREATED;
 802152c:	2202      	movs	r2, #2
 802152e:	7002      	strb	r2, [r0, #0]
        if (osCDS_socket_set_callbacks(sock,
 8021530:	4b6e      	ldr	r3, [pc, #440]	; (80216ec <com_socket_ip_modem+0x320>)
 8021532:	2200      	movs	r2, #0
 8021534:	496e      	ldr	r1, [pc, #440]	; (80216f0 <com_socket_ip_modem+0x324>)
 8021536:	4628      	mov	r0, r5
 8021538:	f7f9 f942 	bl	801a7c0 <osCDS_socket_set_callbacks>
 802153c:	2800      	cmp	r0, #0
 802153e:	f000 8134 	beq.w	80217aa <com_socket_ip_modem+0x3de>
          PRINT_ERR("rqt close socket issue at creation")
 8021542:	4f6c      	ldr	r7, [pc, #432]	; (80216f4 <com_socket_ip_modem+0x328>)
 8021544:	4c67      	ldr	r4, [pc, #412]	; (80216e4 <com_socket_ip_modem+0x318>)
 8021546:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 802154a:	463e      	mov	r6, r7
 802154c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 802154e:	6020      	str	r0, [r4, #0]
 8021550:	6061      	str	r1, [r4, #4]
 8021552:	60a2      	str	r2, [r4, #8]
 8021554:	60e3      	str	r3, [r4, #12]
 8021556:	4637      	mov	r7, r6
 8021558:	3410      	adds	r4, #16
 802155a:	4566      	cmp	r6, ip
 802155c:	d1f5      	bne.n	802154a <com_socket_ip_modem+0x17e>
 802155e:	8832      	ldrh	r2, [r6, #0]
 8021560:	78b3      	ldrb	r3, [r6, #2]
 8021562:	8022      	strh	r2, [r4, #0]
 8021564:	70a3      	strb	r3, [r4, #2]
 8021566:	4c5f      	ldr	r4, [pc, #380]	; (80216e4 <com_socket_ip_modem+0x318>)
 8021568:	4620      	mov	r0, r4
 802156a:	f7fd fdd2 	bl	801f112 <crs_strlen>
 802156e:	b283      	uxth	r3, r0
 8021570:	4622      	mov	r2, r4
 8021572:	2110      	movs	r1, #16
 8021574:	2003      	movs	r0, #3
 8021576:	f7fd fe0f 	bl	801f198 <traceIF_itmPrint>
 802157a:	4620      	mov	r0, r4
 802157c:	f7fd fdc9 	bl	801f112 <crs_strlen>
 8021580:	b283      	uxth	r3, r0
 8021582:	4622      	mov	r2, r4
 8021584:	2110      	movs	r1, #16
 8021586:	2003      	movs	r0, #3
 8021588:	f7fd fe28 	bl	801f1dc <traceIF_uartPrint>
          if (com_closesocket_ip_modem(sock)
 802158c:	4628      	mov	r0, r5
 802158e:	f7ff fe7d 	bl	802128c <com_closesocket_ip_modem>
 8021592:	2800      	cmp	r0, #0
 8021594:	f040 80b8 	bne.w	8021708 <com_socket_ip_modem+0x33c>
            PRINT_INFO("close socket ok low level")
 8021598:	4f57      	ldr	r7, [pc, #348]	; (80216f8 <com_socket_ip_modem+0x32c>)
 802159a:	4626      	mov	r6, r4
 802159c:	f107 0c20 	add.w	ip, r7, #32
 80215a0:	463c      	mov	r4, r7
 80215a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80215a4:	6030      	str	r0, [r6, #0]
 80215a6:	6071      	str	r1, [r6, #4]
 80215a8:	60b2      	str	r2, [r6, #8]
 80215aa:	60f3      	str	r3, [r6, #12]
 80215ac:	4627      	mov	r7, r4
 80215ae:	3610      	adds	r6, #16
 80215b0:	4564      	cmp	r4, ip
 80215b2:	d1f5      	bne.n	80215a0 <com_socket_ip_modem+0x1d4>
 80215b4:	6820      	ldr	r0, [r4, #0]
 80215b6:	6030      	str	r0, [r6, #0]
 80215b8:	4c4a      	ldr	r4, [pc, #296]	; (80216e4 <com_socket_ip_modem+0x318>)
 80215ba:	4620      	mov	r0, r4
 80215bc:	f7fd fda9 	bl	801f112 <crs_strlen>
 80215c0:	b283      	uxth	r3, r0
 80215c2:	4622      	mov	r2, r4
 80215c4:	2101      	movs	r1, #1
 80215c6:	2003      	movs	r0, #3
 80215c8:	f7fd fde6 	bl	801f198 <traceIF_itmPrint>
 80215cc:	4620      	mov	r0, r4
 80215ce:	f7fd fda0 	bl	801f112 <crs_strlen>
 80215d2:	b283      	uxth	r3, r0
 80215d4:	4622      	mov	r2, r4
 80215d6:	2101      	movs	r1, #1
 80215d8:	2003      	movs	r0, #3
 80215da:	f7fd fdff 	bl	801f1dc <traceIF_uartPrint>
    result = COM_SOCKETS_ERR_GENERAL;
 80215de:	f04f 36ff 	mov.w	r6, #4294967295
 80215e2:	e0e2      	b.n	80217aa <com_socket_ip_modem+0x3de>
    TransportProtocol = CS_UDP_PROTOCOL;
 80215e4:	f04f 0901 	mov.w	r9, #1
 80215e8:	e744      	b.n	8021474 <com_socket_ip_modem+0xa8>
        PRINT_ERR("create socket NOK no memory")
 80215ea:	4f44      	ldr	r7, [pc, #272]	; (80216fc <com_socket_ip_modem+0x330>)
 80215ec:	4c3d      	ldr	r4, [pc, #244]	; (80216e4 <com_socket_ip_modem+0x318>)
 80215ee:	f107 0c20 	add.w	ip, r7, #32
 80215f2:	463e      	mov	r6, r7
 80215f4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80215f6:	6020      	str	r0, [r4, #0]
 80215f8:	6061      	str	r1, [r4, #4]
 80215fa:	60a2      	str	r2, [r4, #8]
 80215fc:	60e3      	str	r3, [r4, #12]
 80215fe:	4637      	mov	r7, r6
 8021600:	3410      	adds	r4, #16
 8021602:	4566      	cmp	r6, ip
 8021604:	d1f5      	bne.n	80215f2 <com_socket_ip_modem+0x226>
 8021606:	cf07      	ldmia	r7!, {r0, r1, r2}
 8021608:	6020      	str	r0, [r4, #0]
 802160a:	6061      	str	r1, [r4, #4]
 802160c:	60a2      	str	r2, [r4, #8]
 802160e:	4c35      	ldr	r4, [pc, #212]	; (80216e4 <com_socket_ip_modem+0x318>)
 8021610:	4620      	mov	r0, r4
 8021612:	f7fd fd7e 	bl	801f112 <crs_strlen>
 8021616:	b283      	uxth	r3, r0
 8021618:	4622      	mov	r2, r4
 802161a:	2110      	movs	r1, #16
 802161c:	2003      	movs	r0, #3
 802161e:	f7fd fdbb 	bl	801f198 <traceIF_itmPrint>
 8021622:	4620      	mov	r0, r4
 8021624:	f7fd fd75 	bl	801f112 <crs_strlen>
 8021628:	b283      	uxth	r3, r0
 802162a:	4622      	mov	r2, r4
 802162c:	2110      	movs	r1, #16
 802162e:	2003      	movs	r0, #3
 8021630:	f7fd fdd4 	bl	801f1dc <traceIF_uartPrint>
        if (osCDS_socket_close(sock, 0U)
 8021634:	2100      	movs	r1, #0
 8021636:	4628      	mov	r0, r5
 8021638:	f7f9 f96a 	bl	801a910 <osCDS_socket_close>
 802163c:	bb28      	cbnz	r0, 802168a <com_socket_ip_modem+0x2be>
          PRINT_INFO("close socket ok low level")
 802163e:	4f2e      	ldr	r7, [pc, #184]	; (80216f8 <com_socket_ip_modem+0x32c>)
 8021640:	4626      	mov	r6, r4
 8021642:	f107 0c20 	add.w	ip, r7, #32
 8021646:	463c      	mov	r4, r7
 8021648:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802164a:	6030      	str	r0, [r6, #0]
 802164c:	6071      	str	r1, [r6, #4]
 802164e:	60b2      	str	r2, [r6, #8]
 8021650:	60f3      	str	r3, [r6, #12]
 8021652:	4627      	mov	r7, r4
 8021654:	3610      	adds	r6, #16
 8021656:	4564      	cmp	r4, ip
 8021658:	d1f5      	bne.n	8021646 <com_socket_ip_modem+0x27a>
 802165a:	6820      	ldr	r0, [r4, #0]
 802165c:	6030      	str	r0, [r6, #0]
 802165e:	4c21      	ldr	r4, [pc, #132]	; (80216e4 <com_socket_ip_modem+0x318>)
 8021660:	4620      	mov	r0, r4
 8021662:	f7fd fd56 	bl	801f112 <crs_strlen>
 8021666:	b283      	uxth	r3, r0
 8021668:	4622      	mov	r2, r4
 802166a:	2101      	movs	r1, #1
 802166c:	2003      	movs	r0, #3
 802166e:	f7fd fd93 	bl	801f198 <traceIF_itmPrint>
 8021672:	4620      	mov	r0, r4
 8021674:	f7fd fd4d 	bl	801f112 <crs_strlen>
 8021678:	b283      	uxth	r3, r0
 802167a:	4622      	mov	r2, r4
 802167c:	2101      	movs	r1, #1
 802167e:	2003      	movs	r0, #3
 8021680:	f7fd fdac 	bl	801f1dc <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_NOMEMORY;
 8021684:	f06f 0604 	mvn.w	r6, #4
 8021688:	e08f      	b.n	80217aa <com_socket_ip_modem+0x3de>
          PRINT_ERR("close socket NOK low level")
 802168a:	4e1d      	ldr	r6, [pc, #116]	; (8021700 <com_socket_ip_modem+0x334>)
 802168c:	4c15      	ldr	r4, [pc, #84]	; (80216e4 <com_socket_ip_modem+0x318>)
 802168e:	f106 0c20 	add.w	ip, r6, #32
 8021692:	4637      	mov	r7, r6
 8021694:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021696:	6020      	str	r0, [r4, #0]
 8021698:	6061      	str	r1, [r4, #4]
 802169a:	60a2      	str	r2, [r4, #8]
 802169c:	60e3      	str	r3, [r4, #12]
 802169e:	463e      	mov	r6, r7
 80216a0:	3410      	adds	r4, #16
 80216a2:	4567      	cmp	r7, ip
 80216a4:	d1f5      	bne.n	8021692 <com_socket_ip_modem+0x2c6>
 80216a6:	ce03      	ldmia	r6!, {r0, r1}
 80216a8:	6020      	str	r0, [r4, #0]
 80216aa:	6061      	str	r1, [r4, #4]
 80216ac:	8832      	ldrh	r2, [r6, #0]
 80216ae:	78b3      	ldrb	r3, [r6, #2]
 80216b0:	8122      	strh	r2, [r4, #8]
 80216b2:	72a3      	strb	r3, [r4, #10]
 80216b4:	4c0b      	ldr	r4, [pc, #44]	; (80216e4 <com_socket_ip_modem+0x318>)
 80216b6:	4620      	mov	r0, r4
 80216b8:	f7fd fd2b 	bl	801f112 <crs_strlen>
 80216bc:	b283      	uxth	r3, r0
 80216be:	4622      	mov	r2, r4
 80216c0:	2110      	movs	r1, #16
 80216c2:	2003      	movs	r0, #3
 80216c4:	f7fd fd68 	bl	801f198 <traceIF_itmPrint>
 80216c8:	4620      	mov	r0, r4
 80216ca:	f7fd fd22 	bl	801f112 <crs_strlen>
 80216ce:	b283      	uxth	r3, r0
 80216d0:	4622      	mov	r2, r4
 80216d2:	2110      	movs	r1, #16
 80216d4:	2003      	movs	r0, #3
 80216d6:	f7fd fd81 	bl	801f1dc <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_NOMEMORY;
 80216da:	f06f 0604 	mvn.w	r6, #4
 80216de:	e064      	b.n	80217aa <com_socket_ip_modem+0x3de>
 80216e0:	08035b4c 	.word	0x08035b4c
 80216e4:	200049dc 	.word	0x200049dc
 80216e8:	08035a28 	.word	0x08035a28
 80216ec:	08020065 	.word	0x08020065
 80216f0:	08020261 	.word	0x08020261
 80216f4:	08035aec 	.word	0x08035aec
 80216f8:	08035a9c 	.word	0x08035a9c
 80216fc:	08035a70 	.word	0x08035a70
 8021700:	08035ac0 	.word	0x08035ac0
 8021704:	08035a48 	.word	0x08035a48
            PRINT_ERR("close socket NOK low level")
 8021708:	4e2c      	ldr	r6, [pc, #176]	; (80217bc <com_socket_ip_modem+0x3f0>)
 802170a:	4c2d      	ldr	r4, [pc, #180]	; (80217c0 <com_socket_ip_modem+0x3f4>)
 802170c:	f106 0c20 	add.w	ip, r6, #32
 8021710:	4637      	mov	r7, r6
 8021712:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021714:	6020      	str	r0, [r4, #0]
 8021716:	6061      	str	r1, [r4, #4]
 8021718:	60a2      	str	r2, [r4, #8]
 802171a:	60e3      	str	r3, [r4, #12]
 802171c:	463e      	mov	r6, r7
 802171e:	3410      	adds	r4, #16
 8021720:	4567      	cmp	r7, ip
 8021722:	d1f5      	bne.n	8021710 <com_socket_ip_modem+0x344>
 8021724:	ce03      	ldmia	r6!, {r0, r1}
 8021726:	6020      	str	r0, [r4, #0]
 8021728:	6061      	str	r1, [r4, #4]
 802172a:	8832      	ldrh	r2, [r6, #0]
 802172c:	78b3      	ldrb	r3, [r6, #2]
 802172e:	8122      	strh	r2, [r4, #8]
 8021730:	72a3      	strb	r3, [r4, #10]
 8021732:	4c23      	ldr	r4, [pc, #140]	; (80217c0 <com_socket_ip_modem+0x3f4>)
 8021734:	4620      	mov	r0, r4
 8021736:	f7fd fcec 	bl	801f112 <crs_strlen>
 802173a:	b283      	uxth	r3, r0
 802173c:	4622      	mov	r2, r4
 802173e:	2110      	movs	r1, #16
 8021740:	2003      	movs	r0, #3
 8021742:	f7fd fd29 	bl	801f198 <traceIF_itmPrint>
 8021746:	4620      	mov	r0, r4
 8021748:	f7fd fce3 	bl	801f112 <crs_strlen>
 802174c:	b283      	uxth	r3, r0
 802174e:	4622      	mov	r2, r4
 8021750:	2110      	movs	r1, #16
 8021752:	2003      	movs	r0, #3
 8021754:	f7fd fd42 	bl	801f1dc <traceIF_uartPrint>
    result = COM_SOCKETS_ERR_GENERAL;
 8021758:	f04f 36ff 	mov.w	r6, #4294967295
 802175c:	e025      	b.n	80217aa <com_socket_ip_modem+0x3de>
      PRINT_ERR("create socket NOK low level")
 802175e:	4e19      	ldr	r6, [pc, #100]	; (80217c4 <com_socket_ip_modem+0x3f8>)
 8021760:	4c17      	ldr	r4, [pc, #92]	; (80217c0 <com_socket_ip_modem+0x3f4>)
 8021762:	f106 0c20 	add.w	ip, r6, #32
 8021766:	4637      	mov	r7, r6
 8021768:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 802176a:	6020      	str	r0, [r4, #0]
 802176c:	6061      	str	r1, [r4, #4]
 802176e:	60a2      	str	r2, [r4, #8]
 8021770:	60e3      	str	r3, [r4, #12]
 8021772:	463e      	mov	r6, r7
 8021774:	3410      	adds	r4, #16
 8021776:	4567      	cmp	r7, ip
 8021778:	d1f5      	bne.n	8021766 <com_socket_ip_modem+0x39a>
 802177a:	ce07      	ldmia	r6!, {r0, r1, r2}
 802177c:	6020      	str	r0, [r4, #0]
 802177e:	6061      	str	r1, [r4, #4]
 8021780:	60a2      	str	r2, [r4, #8]
 8021782:	4c0f      	ldr	r4, [pc, #60]	; (80217c0 <com_socket_ip_modem+0x3f4>)
 8021784:	4620      	mov	r0, r4
 8021786:	f7fd fcc4 	bl	801f112 <crs_strlen>
 802178a:	b283      	uxth	r3, r0
 802178c:	4622      	mov	r2, r4
 802178e:	2110      	movs	r1, #16
 8021790:	2003      	movs	r0, #3
 8021792:	f7fd fd01 	bl	801f198 <traceIF_itmPrint>
 8021796:	4620      	mov	r0, r4
 8021798:	f7fd fcbb 	bl	801f112 <crs_strlen>
 802179c:	b283      	uxth	r3, r0
 802179e:	4622      	mov	r2, r4
 80217a0:	2110      	movs	r1, #16
 80217a2:	2003      	movs	r0, #3
 80217a4:	f7fd fd1a 	bl	801f1dc <traceIF_uartPrint>
    result = COM_SOCKETS_ERR_GENERAL;
 80217a8:	462e      	mov	r6, r5
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 80217aa:	1e30      	subs	r0, r6, #0
 80217ac:	bf18      	it	ne
 80217ae:	2001      	movne	r0, #1
 80217b0:	f000 f858 	bl	8021864 <com_sockets_statistic_update>
 80217b4:	e642      	b.n	802143c <com_socket_ip_modem+0x70>
    result = COM_SOCKETS_ERR_UNSUPPORTED;
 80217b6:	f06f 060b 	mvn.w	r6, #11
 80217ba:	e61b      	b.n	80213f4 <com_socket_ip_modem+0x28>
 80217bc:	08035ac0 	.word	0x08035ac0
 80217c0:	200049dc 	.word	0x200049dc
 80217c4:	08035b20 	.word	0x08035b20

080217c8 <com_init_ip_modem>:
  *         before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_init_ip_modem(void)
{
 80217c8:	b508      	push	{r3, lr}
  bool result;

  result = false;

  /* Inititalize Network status */
  com_sockets_network_is_up = false; /* Network status update by Datacache see com_socket_datacache_cb() */
 80217ca:	2300      	movs	r3, #0
 80217cc:	4a0d      	ldr	r2, [pc, #52]	; (8021804 <com_init_ip_modem+0x3c>)
 80217ce:	7013      	strb	r3, [r2, #0]

#if (USE_COM_PING == 1)
  ping_socket_id = COM_SOCKET_INVALID_ID;
#endif /* USE_COM_PING == 1 */

  for (uint8_t i = 0U; i < COM_SOCKET_LOCAL_ID_NB; i++)
 80217d0:	b163      	cbz	r3, 80217ec <com_init_ip_modem+0x24>
  {
    socket_local_id[i] = false; /* set socket local id to unused */
  }

  /* Initialize Mutex to protect socket descriptor list access */
  ComSocketsMutexHandle = rtosalMutexNew(NULL);
 80217d2:	2000      	movs	r0, #0
 80217d4:	f7fd fbad 	bl	801ef32 <rtosalMutexNew>
 80217d8:	4b0b      	ldr	r3, [pc, #44]	; (8021808 <com_init_ip_modem+0x40>)
 80217da:	6018      	str	r0, [r3, #0]
  if (ComSocketsMutexHandle != NULL)
 80217dc:	b160      	cbz	r0, 80217f8 <com_init_ip_modem+0x30>
  {
    /* Create always the first element of the list */
    socket_desc_list = com_ip_modem_create_socket_desc();
 80217de:	f7fe fe4e 	bl	802047e <com_ip_modem_create_socket_desc>
 80217e2:	4b0a      	ldr	r3, [pc, #40]	; (802180c <com_init_ip_modem+0x44>)
 80217e4:	6018      	str	r0, [r3, #0]
    if (socket_desc_list != NULL)
 80217e6:	b140      	cbz	r0, 80217fa <com_init_ip_modem+0x32>
    {
      result = true;
 80217e8:	2001      	movs	r0, #1
 80217ea:	e006      	b.n	80217fa <com_init_ip_modem+0x32>
    socket_local_id[i] = false; /* set socket local id to unused */
 80217ec:	4a08      	ldr	r2, [pc, #32]	; (8021810 <com_init_ip_modem+0x48>)
 80217ee:	2100      	movs	r1, #0
 80217f0:	54d1      	strb	r1, [r2, r3]
  for (uint8_t i = 0U; i < COM_SOCKET_LOCAL_ID_NB; i++)
 80217f2:	3301      	adds	r3, #1
 80217f4:	b2db      	uxtb	r3, r3
 80217f6:	e7eb      	b.n	80217d0 <com_init_ip_modem+0x8>
  result = false;
 80217f8:	2000      	movs	r0, #0
  }
  com_nb_wake_up = 0U;
#endif /* USE_LOW_POWER == 1 */

#if (UDP_SERVICE_SUPPORTED == 1U)
  com_local_port = 0U; /* com_start_ip in charge to initialize it to a random value */
 80217fa:	4b06      	ldr	r3, [pc, #24]	; (8021814 <com_init_ip_modem+0x4c>)
 80217fc:	2200      	movs	r2, #0
 80217fe:	801a      	strh	r2, [r3, #0]
#endif /* UDP_SERVICE_SUPPORTED == 1U */

  return result;
}
 8021800:	bd08      	pop	{r3, pc}
 8021802:	bf00      	nop
 8021804:	200058a6 	.word	0x200058a6
 8021808:	200058a0 	.word	0x200058a0
 802180c:	200058a8 	.word	0x200058a8
 8021810:	200058ac 	.word	0x200058ac
 8021814:	200058a4 	.word	0x200058a4

08021818 <com_start_ip_modem>:
  *         and before using any other functions of com_*
  * @param  -
  * @retval -
  */
void com_start_ip_modem(void)
{
 8021818:	b500      	push	{lr}
 802181a:	b083      	sub	sp, #12
#if (USE_DATACACHE == 1)
  /* Datacache registration for netwok on/off status */
  (void)dc_com_register_gen_event_cb(&dc_com_db, com_socket_datacache_cb, (void *)NULL);
 802181c:	2200      	movs	r2, #0
 802181e:	490c      	ldr	r1, [pc, #48]	; (8021850 <com_start_ip_modem+0x38>)
 8021820:	480c      	ldr	r0, [pc, #48]	; (8021854 <com_start_ip_modem+0x3c>)
 8021822:	f000 f855 	bl	80218d0 <dc_com_register_gen_event_cb>

#if (UDP_SERVICE_SUPPORTED == 1U)
  uint32_t random;

  /* Initialize local port to a random value */
  if (HAL_OK != HAL_RNG_GenerateRandomNumber(&hrng, &random))
 8021826:	a901      	add	r1, sp, #4
 8021828:	480b      	ldr	r0, [pc, #44]	; (8021858 <com_start_ip_modem+0x40>)
 802182a:	f7e7 fe7c 	bl	8009526 <HAL_RNG_GenerateRandomNumber>
 802182e:	b958      	cbnz	r0, 8021848 <com_start_ip_modem+0x30>
  {
    random = (uint32_t)rand();
  }
  random = random & ~COM_LOCAL_PORT_BEGIN;
 8021830:	9b01      	ldr	r3, [sp, #4]
 8021832:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8021836:	9301      	str	r3, [sp, #4]
  random = random + COM_LOCAL_PORT_BEGIN;
 8021838:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 802183c:	9301      	str	r3, [sp, #4]
  com_local_port = (uint16_t)(random);
 802183e:	4a07      	ldr	r2, [pc, #28]	; (802185c <com_start_ip_modem+0x44>)
 8021840:	8013      	strh	r3, [r2, #0]
#endif /* UDP_SERVICE_SUPPORTED == 1U */
}
 8021842:	b003      	add	sp, #12
 8021844:	f85d fb04 	ldr.w	pc, [sp], #4
    random = (uint32_t)rand();
 8021848:	f004 f934 	bl	8025ab4 <rand>
 802184c:	9001      	str	r0, [sp, #4]
 802184e:	e7ef      	b.n	8021830 <com_start_ip_modem+0x18>
 8021850:	0802085d 	.word	0x0802085d
 8021854:	200058b0 	.word	0x200058b0
 8021858:	20000a20 	.word	0x20000a20
 802185c:	200058a4 	.word	0x200058a4

08021860 <com_sockets_statistic_init>:
  * @retval -
  */
void com_sockets_statistic_init(void)
{
  /* Nothing to do */
  __NOP();
 8021860:	bf00      	nop
}
 8021862:	4770      	bx	lr

08021864 <com_sockets_statistic_update>:
  */
void com_sockets_statistic_update(com_sockets_stat_update_t stat)
{
  UNUSED(stat);
  /* Nothing to do */
}
 8021864:	4770      	bx	lr

08021866 <com_sockets_statistic_display>:
  * @retval -
  */
void com_sockets_statistic_display(void)
{
  /* Nothing to do */
}
 8021866:	4770      	bx	lr

08021868 <dc_com_register_serv>:
  * @note                     this structure must be a persistent variable.
  * @param size             - size of p_data structure.
  * @retval dc_com_res_id_t - returns the identifier of the registered Data Cache entry
  */
dc_com_res_id_t dc_com_register_serv(dc_com_db_t *p_dc_db, void *p_data, uint16_t size)
{
 8021868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  dc_com_res_id_t res_id;
  dc_base_rt_info_t *p_base_rt;

  if ((p_dc_db != NULL) &&
 802186c:	b340      	cbz	r0, 80218c0 <dc_com_register_serv+0x58>
 802186e:	460e      	mov	r6, r1
 8021870:	4614      	mov	r4, r2
 8021872:	4607      	mov	r7, r0
      (p_dc_db->serv_number < DC_COM_ENTRY_MAX_NB) &&
 8021874:	8843      	ldrh	r3, [r0, #2]
  if ((p_dc_db != NULL) &&
 8021876:	2b13      	cmp	r3, #19
 8021878:	d824      	bhi.n	80218c4 <dc_com_register_serv+0x5c>
      (p_dc_db->serv_number < DC_COM_ENTRY_MAX_NB) &&
 802187a:	2a0b      	cmp	r2, #11
 802187c:	d801      	bhi.n	8021882 <dc_com_register_serv+0x1a>
    p_dc_db->serv_number++;
    (void)rtosalMutexRelease(dc_common_mutex);
  }
  else
  {
    res_id = DC_COM_INVALID_ENTRY;
 802187e:	25ff      	movs	r5, #255	; 0xff
 8021880:	e021      	b.n	80218c6 <dc_com_register_serv+0x5e>
    (void)rtosalMutexAcquire(dc_common_mutex, RTOSAL_WAIT_FOREVER);
 8021882:	f8df 8048 	ldr.w	r8, [pc, #72]	; 80218cc <dc_com_register_serv+0x64>
 8021886:	f04f 31ff 	mov.w	r1, #4294967295
 802188a:	f8d8 0000 	ldr.w	r0, [r8]
 802188e:	f7fd fb5a 	bl	801ef46 <rtosalMutexAcquire>
    res_id = p_dc_db->serv_number;
 8021892:	887d      	ldrh	r5, [r7, #2]
    p_dc_db->p_dc_db[res_id]   = p_data;
 8021894:	f105 031e 	add.w	r3, r5, #30
 8021898:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 802189c:	605e      	str	r6, [r3, #4]
    p_dc_db->dc_db_len[res_id] = size;
 802189e:	f105 0364 	add.w	r3, r5, #100	; 0x64
 80218a2:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 80218a6:	809c      	strh	r4, [r3, #4]
    p_base_rt->header.res_id = res_id;
 80218a8:	8035      	strh	r5, [r6, #0]
    p_base_rt->header.size   = size;
 80218aa:	6074      	str	r4, [r6, #4]
    p_base_rt->rt_state      = DC_SERVICE_OFF;
 80218ac:	2303      	movs	r3, #3
 80218ae:	7233      	strb	r3, [r6, #8]
    p_dc_db->serv_number++;
 80218b0:	887b      	ldrh	r3, [r7, #2]
 80218b2:	3301      	adds	r3, #1
 80218b4:	807b      	strh	r3, [r7, #2]
    (void)rtosalMutexRelease(dc_common_mutex);
 80218b6:	f8d8 0000 	ldr.w	r0, [r8]
 80218ba:	f7fd fb48 	bl	801ef4e <rtosalMutexRelease>
 80218be:	e002      	b.n	80218c6 <dc_com_register_serv+0x5e>
    res_id = DC_COM_INVALID_ENTRY;
 80218c0:	25ff      	movs	r5, #255	; 0xff
 80218c2:	e000      	b.n	80218c6 <dc_com_register_serv+0x5e>
 80218c4:	25ff      	movs	r5, #255	; 0xff
  }

  return res_id;
}
 80218c6:	4628      	mov	r0, r5
 80218c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80218cc:	200059a4 	.word	0x200059a4

080218d0 <dc_com_register_gen_event_cb>:
  *                           DC_COM_INVALID_ENTRY in case of error
  */
dc_com_reg_id_t dc_com_register_gen_event_cb(dc_com_db_t *p_dc_db,
                                             dc_com_gen_event_callback_t notif_cb,
                                             const void *p_private_data)
{
 80218d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  dc_com_reg_id_t consumer_id;

  if ((p_dc_db != NULL) && (notif_cb != NULL)  && (p_dc_db->consumer_number < DC_COM_MAX_NB_SUBSCRIBER))
 80218d4:	b328      	cbz	r0, 8021922 <dc_com_register_gen_event_cb+0x52>
 80218d6:	460c      	mov	r4, r1
 80218d8:	4617      	mov	r7, r2
 80218da:	4606      	mov	r6, r0
 80218dc:	b319      	cbz	r1, 8021926 <dc_com_register_gen_event_cb+0x56>
 80218de:	7803      	ldrb	r3, [r0, #0]
 80218e0:	2b09      	cmp	r3, #9
 80218e2:	d903      	bls.n	80218ec <dc_com_register_gen_event_cb+0x1c>
    p_dc_db->consumer_number++;
    (void)rtosalMutexRelease(dc_common_mutex);
  }
  else
  {
    consumer_id = DC_COM_INVALID_ENTRY;
 80218e4:	25ff      	movs	r5, #255	; 0xff
  }

  return consumer_id;
}
 80218e6:	4628      	mov	r0, r5
 80218e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)rtosalMutexAcquire(dc_common_mutex, RTOSAL_WAIT_FOREVER);
 80218ec:	f8df 803c 	ldr.w	r8, [pc, #60]	; 802192c <dc_com_register_gen_event_cb+0x5c>
 80218f0:	f04f 31ff 	mov.w	r1, #4294967295
 80218f4:	f8d8 0000 	ldr.w	r0, [r8]
 80218f8:	f7fd fb25 	bl	801ef46 <rtosalMutexAcquire>
    consumer_id = p_dc_db->consumer_number;
 80218fc:	7835      	ldrb	r5, [r6, #0]
    p_dc_db->consumer_info[consumer_id].consumer_reg_id       = consumer_id;
 80218fe:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8021902:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8021906:	711d      	strb	r5, [r3, #4]
    p_dc_db->consumer_info[consumer_id].notif_cb          = notif_cb;
 8021908:	609c      	str	r4, [r3, #8]
    p_dc_db->consumer_info[consumer_id].private_consumer_data = p_private_data;
 802190a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 802190e:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8021912:	60df      	str	r7, [r3, #12]
    p_dc_db->consumer_number++;
 8021914:	1c6b      	adds	r3, r5, #1
 8021916:	7033      	strb	r3, [r6, #0]
    (void)rtosalMutexRelease(dc_common_mutex);
 8021918:	f8d8 0000 	ldr.w	r0, [r8]
 802191c:	f7fd fb17 	bl	801ef4e <rtosalMutexRelease>
 8021920:	e7e1      	b.n	80218e6 <dc_com_register_gen_event_cb+0x16>
    consumer_id = DC_COM_INVALID_ENTRY;
 8021922:	25ff      	movs	r5, #255	; 0xff
 8021924:	e7df      	b.n	80218e6 <dc_com_register_gen_event_cb+0x16>
 8021926:	25ff      	movs	r5, #255	; 0xff
 8021928:	e7dd      	b.n	80218e6 <dc_com_register_gen_event_cb+0x16>
 802192a:	bf00      	nop
 802192c:	200059a4 	.word	0x200059a4

08021930 <dc_com_write>:
  dc_com_reg_id_t reg_id;
  dc_base_rt_info_t *dc_base_rt_info;
  dc_com_status_t res;
  const dc_com_db_t *com_db = (dc_com_db_t *)p_dc;

  if ((p_dc != NULL) && (res_id < com_db->serv_number) && (com_db->dc_db_len[res_id] >= len))
 8021930:	2800      	cmp	r0, #0
 8021932:	d041      	beq.n	80219b8 <dc_com_write+0x88>
{
 8021934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021938:	460d      	mov	r5, r1
 802193a:	4617      	mov	r7, r2
 802193c:	461c      	mov	r4, r3
 802193e:	4606      	mov	r6, r0
  if ((p_dc != NULL) && (res_id < com_db->serv_number) && (com_db->dc_db_len[res_id] >= len))
 8021940:	8843      	ldrh	r3, [r0, #2]
 8021942:	428b      	cmp	r3, r1
 8021944:	d93a      	bls.n	80219bc <dc_com_write+0x8c>
 8021946:	f101 0364 	add.w	r3, r1, #100	; 0x64
 802194a:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 802194e:	889b      	ldrh	r3, [r3, #4]
 8021950:	42a3      	cmp	r3, r4
 8021952:	d201      	bcs.n	8021958 <dc_com_write+0x28>
    (void)rtosalMutexRelease(dc_common_mutex);
    res = DC_COM_OK;
  }
  else
  {
    res = DC_COM_ERROR;
 8021954:	2000      	movs	r0, #0
 8021956:	e032      	b.n	80219be <dc_com_write+0x8e>
    (void)rtosalMutexAcquire(dc_common_mutex, RTOSAL_WAIT_FOREVER);
 8021958:	f04f 31ff 	mov.w	r1, #4294967295
 802195c:	4b19      	ldr	r3, [pc, #100]	; (80219c4 <dc_com_write+0x94>)
 802195e:	6818      	ldr	r0, [r3, #0]
 8021960:	f7fd faf1 	bl	801ef46 <rtosalMutexAcquire>
    (void)memcpy((void *)(com_db->p_dc_db[res_id]), p_data, (uint32_t)len);
 8021964:	f105 081e 	add.w	r8, r5, #30
 8021968:	eb06 0888 	add.w	r8, r6, r8, lsl #2
 802196c:	4622      	mov	r2, r4
 802196e:	4639      	mov	r1, r7
 8021970:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8021974:	f004 facc 	bl	8025f10 <memcpy>
    dc_base_rt_info = (dc_base_rt_info_t *)(com_db->p_dc_db[res_id]);
 8021978:	f8d8 3004 	ldr.w	r3, [r8, #4]
    dc_base_rt_info->header.res_id = res_id;
 802197c:	801d      	strh	r5, [r3, #0]
    dc_base_rt_info->header.size   = len;
 802197e:	605c      	str	r4, [r3, #4]
    for (reg_id = 0U; reg_id < p_dc->consumer_number; reg_id++)
 8021980:	2400      	movs	r4, #0
 8021982:	e001      	b.n	8021988 <dc_com_write+0x58>
 8021984:	3401      	adds	r4, #1
 8021986:	b2e4      	uxtb	r4, r4
 8021988:	7833      	ldrb	r3, [r6, #0]
 802198a:	42a3      	cmp	r3, r4
 802198c:	d90e      	bls.n	80219ac <dc_com_write+0x7c>
      if (consumer_info->notif_cb != NULL)
 802198e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8021992:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8021996:	689a      	ldr	r2, [r3, #8]
 8021998:	2a00      	cmp	r2, #0
 802199a:	d0f3      	beq.n	8021984 <dc_com_write+0x54>
        consumer_info->notif_cb((dc_com_event_id_t)res_id, consumer_info->private_consumer_data);
 802199c:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80219a0:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80219a4:	68d9      	ldr	r1, [r3, #12]
 80219a6:	b2e8      	uxtb	r0, r5
 80219a8:	4790      	blx	r2
 80219aa:	e7eb      	b.n	8021984 <dc_com_write+0x54>
    (void)rtosalMutexRelease(dc_common_mutex);
 80219ac:	4b05      	ldr	r3, [pc, #20]	; (80219c4 <dc_com_write+0x94>)
 80219ae:	6818      	ldr	r0, [r3, #0]
 80219b0:	f7fd facd 	bl	801ef4e <rtosalMutexRelease>
    res = DC_COM_OK;
 80219b4:	2001      	movs	r0, #1
 80219b6:	e002      	b.n	80219be <dc_com_write+0x8e>
    res = DC_COM_ERROR;
 80219b8:	2000      	movs	r0, #0
  }

  return res;
}
 80219ba:	4770      	bx	lr
    res = DC_COM_ERROR;
 80219bc:	2000      	movs	r0, #0
}
 80219be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80219c2:	bf00      	nop
 80219c4:	200059a4 	.word	0x200059a4

080219c8 <dc_com_read>:
  * @param  p_data          - data to read
  * @param  len             - length of p_data to read
  * @retval dc_com_status_t - return status with DC_COM_OK or DC_COM_ERROR
  */
dc_com_status_t dc_com_read(dc_com_db_t *p_dc, dc_com_res_id_t res_id, void *p_data, uint32_t len)
{
 80219c8:	b510      	push	{r4, lr}
 80219ca:	4604      	mov	r4, r0
 80219cc:	4610      	mov	r0, r2
 80219ce:	461a      	mov	r2, r3
  dc_com_status_t res;

  if ((p_dc != NULL) && (res_id < p_dc->serv_number) && (p_dc->dc_db_len[res_id] >= len))
 80219d0:	b154      	cbz	r4, 80219e8 <dc_com_read+0x20>
 80219d2:	4623      	mov	r3, r4
 80219d4:	8864      	ldrh	r4, [r4, #2]
 80219d6:	428c      	cmp	r4, r1
 80219d8:	d906      	bls.n	80219e8 <dc_com_read+0x20>
 80219da:	f101 0464 	add.w	r4, r1, #100	; 0x64
 80219de:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 80219e2:	88a4      	ldrh	r4, [r4, #4]
 80219e4:	4294      	cmp	r4, r2
 80219e6:	d204      	bcs.n	80219f2 <dc_com_read+0x2a>
    (void)memcpy(p_data, (void *)p_dc->p_dc_db[res_id], (uint32_t)len);
    res = DC_COM_OK;
  }
  else
  {
    (void)memset(p_data, 0, (uint32_t)len); /* p_data->rt_state == 0 is DC_SERVICE_UNAVAIL */
 80219e8:	2100      	movs	r1, #0
 80219ea:	f004 f9b4 	bl	8025d56 <memset>
    res = DC_COM_ERROR;
 80219ee:	2000      	movs	r0, #0
  }
  return res;
}
 80219f0:	bd10      	pop	{r4, pc}
    (void)memcpy(p_data, (void *)p_dc->p_dc_db[res_id], (uint32_t)len);
 80219f2:	311e      	adds	r1, #30
 80219f4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80219f8:	6859      	ldr	r1, [r3, #4]
 80219fa:	f004 fa89 	bl	8025f10 <memcpy>
    res = DC_COM_OK;
 80219fe:	2001      	movs	r0, #1
 8021a00:	e7f6      	b.n	80219f0 <dc_com_read+0x28>
	...

08021a04 <dc_com_init>:
  * @brief  Initialize the Data Cache module.
  * @param  p_dc - data base reference (Must be set to &dc_com_db)
  * @retval -
  */
void dc_com_init(dc_com_db_t *p_dc)
{
 8021a04:	b508      	push	{r3, lr}
  (void)memset(p_dc, 0, sizeof(dc_com_db_t));
 8021a06:	22f4      	movs	r2, #244	; 0xf4
 8021a08:	2100      	movs	r1, #0
 8021a0a:	f004 f9a4 	bl	8025d56 <memset>

  dc_common_mutex = rtosalMutexNew(NULL);
 8021a0e:	2000      	movs	r0, #0
 8021a10:	f7fd fa8f 	bl	801ef32 <rtosalMutexNew>
 8021a14:	4b04      	ldr	r3, [pc, #16]	; (8021a28 <dc_com_init+0x24>)
 8021a16:	6018      	str	r0, [r3, #0]
  if (dc_common_mutex == NULL)
 8021a18:	b100      	cbz	r0, 8021a1c <dc_com_init+0x18>
  {
    ERROR_Handler(DBG_CHAN_DATA_CACHE, 1, ERROR_FATAL);
  }
}
 8021a1a:	bd08      	pop	{r3, pc}
    ERROR_Handler(DBG_CHAN_DATA_CACHE, 1, ERROR_FATAL);
 8021a1c:	2203      	movs	r2, #3
 8021a1e:	2101      	movs	r1, #1
 8021a20:	2009      	movs	r0, #9
 8021a22:	f7fc fb93 	bl	801e14c <ERROR_Handler>
}
 8021a26:	e7f8      	b.n	8021a1a <dc_com_init+0x16>
 8021a28:	200059a4 	.word	0x200059a4

08021a2c <dc_com_start>:
  */
void dc_com_start(dc_com_db_t *p_dc)
{
  UNUSED(p_dc);
  /* Nothing to do */
  __NOP();
 8021a2c:	bf00      	nop
}
 8021a2e:	4770      	bx	lr

08021a30 <CMD_GetLine>:
  * @brief board reset command management
  * @param  p_Cmd_p command (not used because not parameter for this command)
  * @retval -
  */
static void CMD_GetLine(uint8_t *command_line, uint32_t max_size)
{
 8021a30:	b538      	push	{r3, r4, r5, lr}
 8021a32:	4605      	mov	r5, r0
 8021a34:	460c      	mov	r4, r1
  uint32_t size;
  (void)rtosalSemaphoreAcquire(CMD_rcvSemaphore, RTOSAL_WAIT_FOREVER);
 8021a36:	f04f 31ff 	mov.w	r1, #4294967295
 8021a3a:	4b09      	ldr	r3, [pc, #36]	; (8021a60 <CMD_GetLine+0x30>)
 8021a3c:	6818      	ldr	r0, [r3, #0]
 8021a3e:	f7fd fa70 	bl	801ef22 <rtosalSemaphoreAcquire>

  size = crs_strlen(CMD_current_cmd) + 1U;
 8021a42:	4b08      	ldr	r3, [pc, #32]	; (8021a64 <CMD_GetLine+0x34>)
 8021a44:	6818      	ldr	r0, [r3, #0]
 8021a46:	f7fd fb64 	bl	801f112 <crs_strlen>
 8021a4a:	1c43      	adds	r3, r0, #1
  if (max_size < size)
 8021a4c:	42a3      	cmp	r3, r4
 8021a4e:	d800      	bhi.n	8021a52 <CMD_GetLine+0x22>
  size = crs_strlen(CMD_current_cmd) + 1U;
 8021a50:	461c      	mov	r4, r3
  {
    size = max_size;
  }

  (void)memcpy((CRC_CHAR_t *)command_line, (CRC_CHAR_t *)CMD_current_cmd, size);
 8021a52:	4622      	mov	r2, r4
 8021a54:	4b03      	ldr	r3, [pc, #12]	; (8021a64 <CMD_GetLine+0x34>)
 8021a56:	6819      	ldr	r1, [r3, #0]
 8021a58:	4628      	mov	r0, r5
 8021a5a:	f004 fa59 	bl	8025f10 <memcpy>
}
 8021a5e:	bd38      	pop	{r3, r4, r5, pc}
 8021a60:	20005c08 	.word	0x20005c08
 8021a64:	20005c00 	.word	0x20005c00

08021a68 <CMD_BoardReset>:
  * @brief board reset command management
  * @param  p_Cmd_p command (not used because not parameter for this command)
  * @retval -
  */
static void CMD_BoardReset(uint8_t *p_Cmd_p)
{
 8021a68:	b508      	push	{r3, lr}
  UNUSED(p_Cmd_p);
  PRINT_FORCE("Board reset requested !\r\n");
 8021a6a:	4c17      	ldr	r4, [pc, #92]	; (8021ac8 <CMD_BoardReset+0x60>)
 8021a6c:	4d17      	ldr	r5, [pc, #92]	; (8021acc <CMD_BoardReset+0x64>)
 8021a6e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021a70:	6020      	str	r0, [r4, #0]
 8021a72:	6061      	str	r1, [r4, #4]
 8021a74:	60a2      	str	r2, [r4, #8]
 8021a76:	60e3      	str	r3, [r4, #12]
 8021a78:	cd03      	ldmia	r5!, {r0, r1}
 8021a7a:	6120      	str	r0, [r4, #16]
 8021a7c:	6161      	str	r1, [r4, #20]
 8021a7e:	882b      	ldrh	r3, [r5, #0]
 8021a80:	8323      	strh	r3, [r4, #24]
 8021a82:	4620      	mov	r0, r4
 8021a84:	f7fd fb45 	bl	801f112 <crs_strlen>
 8021a88:	b283      	uxth	r3, r0
 8021a8a:	4622      	mov	r2, r4
 8021a8c:	2101      	movs	r1, #1
 8021a8e:	200a      	movs	r0, #10
 8021a90:	f7fd fb82 	bl	801f198 <traceIF_itmPrint>
 8021a94:	4620      	mov	r0, r4
 8021a96:	f7fd fb3c 	bl	801f112 <crs_strlen>
 8021a9a:	b282      	uxth	r2, r0
 8021a9c:	4621      	mov	r1, r4
 8021a9e:	200a      	movs	r0, #10
 8021aa0:	f7fd fbb4 	bl	801f20c <traceIF_uartPrintForce>
  (void)rtosalDelay(1000);
 8021aa4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8021aa8:	f7fd fa8b 	bl	801efc2 <rtosalDelay>
 8021aac:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8021ab0:	4907      	ldr	r1, [pc, #28]	; (8021ad0 <CMD_BoardReset+0x68>)
 8021ab2:	68ca      	ldr	r2, [r1, #12]
 8021ab4:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8021ab8:	4b06      	ldr	r3, [pc, #24]	; (8021ad4 <CMD_BoardReset+0x6c>)
 8021aba:	4313      	orrs	r3, r2
 8021abc:	60cb      	str	r3, [r1, #12]
 8021abe:	f3bf 8f4f 	dsb	sy
    __NOP();
 8021ac2:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8021ac4:	e7fd      	b.n	8021ac2 <CMD_BoardReset+0x5a>
 8021ac6:	bf00      	nop
 8021ac8:	200050dc 	.word	0x200050dc
 8021acc:	08035b7c 	.word	0x08035b7c
 8021ad0:	e000ed00 	.word	0xe000ed00
 8021ad4:	05fa0004 	.word	0x05fa0004

08021ad8 <CMD_Help>:
  * @note  display all recorded component (component command header and description)
  * @param  -
  * @retval return value
  */
static cmd_status_t CMD_Help(uint8_t *p_Cmd_p)
{
 8021ad8:	b570      	push	{r4, r5, r6, lr}
 8021ada:	b086      	sub	sp, #24
  UNUSED(p_Cmd_p);
  uint32_t i;
  uint32_t align_offset;
  uint32_t cmd_size;
  PRINT_FORCE("***** help *****\r\n");
 8021adc:	4c48      	ldr	r4, [pc, #288]	; (8021c00 <CMD_Help+0x128>)
 8021ade:	4d49      	ldr	r5, [pc, #292]	; (8021c04 <CMD_Help+0x12c>)
 8021ae0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021ae2:	6020      	str	r0, [r4, #0]
 8021ae4:	6061      	str	r1, [r4, #4]
 8021ae6:	60a2      	str	r2, [r4, #8]
 8021ae8:	60e3      	str	r3, [r4, #12]
 8021aea:	882a      	ldrh	r2, [r5, #0]
 8021aec:	78ab      	ldrb	r3, [r5, #2]
 8021aee:	8222      	strh	r2, [r4, #16]
 8021af0:	74a3      	strb	r3, [r4, #18]
 8021af2:	4620      	mov	r0, r4
 8021af4:	f7fd fb0d 	bl	801f112 <crs_strlen>
 8021af8:	b283      	uxth	r3, r0
 8021afa:	4622      	mov	r2, r4
 8021afc:	2101      	movs	r1, #1
 8021afe:	200a      	movs	r0, #10
 8021b00:	f7fd fb4a 	bl	801f198 <traceIF_itmPrint>
 8021b04:	4620      	mov	r0, r4
 8021b06:	f7fd fb04 	bl	801f112 <crs_strlen>
 8021b0a:	b282      	uxth	r2, r0
 8021b0c:	4621      	mov	r1, r4
 8021b0e:	200a      	movs	r0, #10
 8021b10:	f7fd fb7c 	bl	801f20c <traceIF_uartPrintForce>

  PRINT_FORCE("\r\nList of commands\r\n")
 8021b14:	4d3c      	ldr	r5, [pc, #240]	; (8021c08 <CMD_Help+0x130>)
 8021b16:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021b18:	6020      	str	r0, [r4, #0]
 8021b1a:	6061      	str	r1, [r4, #4]
 8021b1c:	60a2      	str	r2, [r4, #8]
 8021b1e:	60e3      	str	r3, [r4, #12]
 8021b20:	6828      	ldr	r0, [r5, #0]
 8021b22:	6120      	str	r0, [r4, #16]
 8021b24:	792b      	ldrb	r3, [r5, #4]
 8021b26:	7523      	strb	r3, [r4, #20]
 8021b28:	4620      	mov	r0, r4
 8021b2a:	f7fd faf2 	bl	801f112 <crs_strlen>
 8021b2e:	b283      	uxth	r3, r0
 8021b30:	4622      	mov	r2, r4
 8021b32:	2101      	movs	r1, #1
 8021b34:	200a      	movs	r0, #10
 8021b36:	f7fd fb2f 	bl	801f198 <traceIF_itmPrint>
 8021b3a:	4620      	mov	r0, r4
 8021b3c:	f7fd fae9 	bl	801f112 <crs_strlen>
 8021b40:	b282      	uxth	r2, r0
 8021b42:	4621      	mov	r1, r4
 8021b44:	200a      	movs	r0, #10
 8021b46:	f7fd fb61 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("----------------\r\n")
 8021b4a:	4d30      	ldr	r5, [pc, #192]	; (8021c0c <CMD_Help+0x134>)
 8021b4c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021b4e:	6020      	str	r0, [r4, #0]
 8021b50:	6061      	str	r1, [r4, #4]
 8021b52:	60a2      	str	r2, [r4, #8]
 8021b54:	60e3      	str	r3, [r4, #12]
 8021b56:	882a      	ldrh	r2, [r5, #0]
 8021b58:	78ab      	ldrb	r3, [r5, #2]
 8021b5a:	8222      	strh	r2, [r4, #16]
 8021b5c:	74a3      	strb	r3, [r4, #18]
 8021b5e:	4620      	mov	r0, r4
 8021b60:	f7fd fad7 	bl	801f112 <crs_strlen>
 8021b64:	b283      	uxth	r3, r0
 8021b66:	4622      	mov	r2, r4
 8021b68:	2101      	movs	r1, #1
 8021b6a:	200a      	movs	r0, #10
 8021b6c:	f7fd fb14 	bl	801f198 <traceIF_itmPrint>
 8021b70:	4620      	mov	r0, r4
 8021b72:	f7fd face 	bl	801f112 <crs_strlen>
 8021b76:	b282      	uxth	r2, r0
 8021b78:	4621      	mov	r1, r4
 8021b7a:	200a      	movs	r0, #10
 8021b7c:	f7fd fb46 	bl	801f20c <traceIF_uartPrintForce>
  uint8_t   CMD_CmdAlignOffsetString[CMD_COMMAND_ALIGN_COLUMN];

  /* display registered commands  */
  for (i = 0U; i < CMD_NbCmd ; i++)
 8021b80:	2400      	movs	r4, #0
 8021b82:	e020      	b.n	8021bc6 <CMD_Help+0xee>
    {
      /* alignment of the component descriptions */
      (void)memset(CMD_CmdAlignOffsetString, (int32_t)' ', align_offset);
      CMD_CmdAlignOffsetString[align_offset] = 0U;
    }
    PRINT_FORCE("%s%s %s\r\n", CMD_a_cmd_list[i].CmdName, CMD_CmdAlignOffsetString, CMD_a_cmd_list[i].CmdLabel);
 8021b84:	4a22      	ldr	r2, [pc, #136]	; (8021c10 <CMD_Help+0x138>)
 8021b86:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 8021b8a:	eb02 0381 	add.w	r3, r2, r1, lsl #2
 8021b8e:	4d1c      	ldr	r5, [pc, #112]	; (8021c00 <CMD_Help+0x128>)
 8021b90:	685b      	ldr	r3, [r3, #4]
 8021b92:	9300      	str	r3, [sp, #0]
 8021b94:	ab02      	add	r3, sp, #8
 8021b96:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8021b9a:	491e      	ldr	r1, [pc, #120]	; (8021c14 <CMD_Help+0x13c>)
 8021b9c:	4628      	mov	r0, r5
 8021b9e:	f004 f867 	bl	8025c70 <sprintf>
 8021ba2:	4628      	mov	r0, r5
 8021ba4:	f7fd fab5 	bl	801f112 <crs_strlen>
 8021ba8:	b283      	uxth	r3, r0
 8021baa:	462a      	mov	r2, r5
 8021bac:	2101      	movs	r1, #1
 8021bae:	200a      	movs	r0, #10
 8021bb0:	f7fd faf2 	bl	801f198 <traceIF_itmPrint>
 8021bb4:	4628      	mov	r0, r5
 8021bb6:	f7fd faac 	bl	801f112 <crs_strlen>
 8021bba:	b282      	uxth	r2, r0
 8021bbc:	4629      	mov	r1, r5
 8021bbe:	200a      	movs	r0, #10
 8021bc0:	f7fd fb24 	bl	801f20c <traceIF_uartPrintForce>
  for (i = 0U; i < CMD_NbCmd ; i++)
 8021bc4:	3401      	adds	r4, #1
 8021bc6:	4b14      	ldr	r3, [pc, #80]	; (8021c18 <CMD_Help+0x140>)
 8021bc8:	681b      	ldr	r3, [r3, #0]
 8021bca:	42a3      	cmp	r3, r4
 8021bcc:	d926      	bls.n	8021c1c <CMD_Help+0x144>
    cmd_size = (uint32_t)crs_strlen(CMD_a_cmd_list[i].CmdName);
 8021bce:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8021bd2:	4a0f      	ldr	r2, [pc, #60]	; (8021c10 <CMD_Help+0x138>)
 8021bd4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8021bd8:	f7fd fa9b 	bl	801f112 <crs_strlen>
    align_offset = CMD_COMMAND_ALIGN_COLUMN - cmd_size;
 8021bdc:	f1c0 0510 	rsb	r5, r0, #16
    if ((align_offset < CMD_COMMAND_ALIGN_COLUMN))
 8021be0:	2d0f      	cmp	r5, #15
 8021be2:	d8cf      	bhi.n	8021b84 <CMD_Help+0xac>
      (void)memset(CMD_CmdAlignOffsetString, (int32_t)' ', align_offset);
 8021be4:	462a      	mov	r2, r5
 8021be6:	2120      	movs	r1, #32
 8021be8:	a802      	add	r0, sp, #8
 8021bea:	f004 f8b4 	bl	8025d56 <memset>
      CMD_CmdAlignOffsetString[align_offset] = 0U;
 8021bee:	f105 0318 	add.w	r3, r5, #24
 8021bf2:	eb0d 0503 	add.w	r5, sp, r3
 8021bf6:	2300      	movs	r3, #0
 8021bf8:	f805 3c10 	strb.w	r3, [r5, #-16]
 8021bfc:	e7c2      	b.n	8021b84 <CMD_Help+0xac>
 8021bfe:	bf00      	nop
 8021c00:	200050dc 	.word	0x200050dc
 8021c04:	08035b98 	.word	0x08035b98
 8021c08:	08035bac 	.word	0x08035bac
 8021c0c:	08035bc4 	.word	0x08035bc4
 8021c10:	20005ae8 	.word	0x20005ae8
 8021c14:	08035bd8 	.word	0x08035bd8
 8021c18:	20005adc 	.word	0x20005adc
  }

  /* display general syntax of the commands */
  PRINT_FORCE("\r\nHelp syntax\r\n");
 8021c1c:	4ccb      	ldr	r4, [pc, #812]	; (8021f4c <CMD_Help+0x474>)
 8021c1e:	4dcc      	ldr	r5, [pc, #816]	; (8021f50 <CMD_Help+0x478>)
 8021c20:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021c22:	6020      	str	r0, [r4, #0]
 8021c24:	6061      	str	r1, [r4, #4]
 8021c26:	60a2      	str	r2, [r4, #8]
 8021c28:	60e3      	str	r3, [r4, #12]
 8021c2a:	4620      	mov	r0, r4
 8021c2c:	f7fd fa71 	bl	801f112 <crs_strlen>
 8021c30:	b283      	uxth	r3, r0
 8021c32:	4622      	mov	r2, r4
 8021c34:	2101      	movs	r1, #1
 8021c36:	200a      	movs	r0, #10
 8021c38:	f7fd faae 	bl	801f198 <traceIF_itmPrint>
 8021c3c:	4620      	mov	r0, r4
 8021c3e:	f7fd fa68 	bl	801f112 <crs_strlen>
 8021c42:	b282      	uxth	r2, r0
 8021c44:	4621      	mov	r1, r4
 8021c46:	200a      	movs	r0, #10
 8021c48:	f7fd fae0 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("-----------\r\n");
 8021c4c:	4bc1      	ldr	r3, [pc, #772]	; (8021f54 <CMD_Help+0x47c>)
 8021c4e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8021c50:	6020      	str	r0, [r4, #0]
 8021c52:	6061      	str	r1, [r4, #4]
 8021c54:	60a2      	str	r2, [r4, #8]
 8021c56:	881b      	ldrh	r3, [r3, #0]
 8021c58:	81a3      	strh	r3, [r4, #12]
 8021c5a:	4620      	mov	r0, r4
 8021c5c:	f7fd fa59 	bl	801f112 <crs_strlen>
 8021c60:	b283      	uxth	r3, r0
 8021c62:	4622      	mov	r2, r4
 8021c64:	2101      	movs	r1, #1
 8021c66:	200a      	movs	r0, #10
 8021c68:	f7fd fa96 	bl	801f198 <traceIF_itmPrint>
 8021c6c:	4620      	mov	r0, r4
 8021c6e:	f7fd fa50 	bl	801f112 <crs_strlen>
 8021c72:	b282      	uxth	r2, r0
 8021c74:	4621      	mov	r1, r4
 8021c76:	200a      	movs	r0, #10
 8021c78:	f7fd fac8 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("warning: case sensitive commands\r\n");
 8021c7c:	4eb6      	ldr	r6, [pc, #728]	; (8021f58 <CMD_Help+0x480>)
 8021c7e:	f106 0c20 	add.w	ip, r6, #32
 8021c82:	4635      	mov	r5, r6
 8021c84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021c86:	6020      	str	r0, [r4, #0]
 8021c88:	6061      	str	r1, [r4, #4]
 8021c8a:	60a2      	str	r2, [r4, #8]
 8021c8c:	60e3      	str	r3, [r4, #12]
 8021c8e:	462e      	mov	r6, r5
 8021c90:	3410      	adds	r4, #16
 8021c92:	4565      	cmp	r5, ip
 8021c94:	d1f5      	bne.n	8021c82 <CMD_Help+0x1aa>
 8021c96:	882a      	ldrh	r2, [r5, #0]
 8021c98:	78ab      	ldrb	r3, [r5, #2]
 8021c9a:	8022      	strh	r2, [r4, #0]
 8021c9c:	70a3      	strb	r3, [r4, #2]
 8021c9e:	4cab      	ldr	r4, [pc, #684]	; (8021f4c <CMD_Help+0x474>)
 8021ca0:	4620      	mov	r0, r4
 8021ca2:	f7fd fa36 	bl	801f112 <crs_strlen>
 8021ca6:	b283      	uxth	r3, r0
 8021ca8:	4622      	mov	r2, r4
 8021caa:	2101      	movs	r1, #1
 8021cac:	200a      	movs	r0, #10
 8021cae:	f7fd fa73 	bl	801f198 <traceIF_itmPrint>
 8021cb2:	4620      	mov	r0, r4
 8021cb4:	f7fd fa2d 	bl	801f112 <crs_strlen>
 8021cb8:	b282      	uxth	r2, r0
 8021cba:	4621      	mov	r1, r4
 8021cbc:	200a      	movs	r0, #10
 8021cbe:	f7fd faa5 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("[optional parameter]\r\n");
 8021cc2:	4da6      	ldr	r5, [pc, #664]	; (8021f5c <CMD_Help+0x484>)
 8021cc4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021cc6:	6020      	str	r0, [r4, #0]
 8021cc8:	6061      	str	r1, [r4, #4]
 8021cca:	60a2      	str	r2, [r4, #8]
 8021ccc:	60e3      	str	r3, [r4, #12]
 8021cce:	6828      	ldr	r0, [r5, #0]
 8021cd0:	6120      	str	r0, [r4, #16]
 8021cd2:	88aa      	ldrh	r2, [r5, #4]
 8021cd4:	79ab      	ldrb	r3, [r5, #6]
 8021cd6:	82a2      	strh	r2, [r4, #20]
 8021cd8:	75a3      	strb	r3, [r4, #22]
 8021cda:	4620      	mov	r0, r4
 8021cdc:	f7fd fa19 	bl	801f112 <crs_strlen>
 8021ce0:	b283      	uxth	r3, r0
 8021ce2:	4622      	mov	r2, r4
 8021ce4:	2101      	movs	r1, #1
 8021ce6:	200a      	movs	r0, #10
 8021ce8:	f7fd fa56 	bl	801f198 <traceIF_itmPrint>
 8021cec:	4620      	mov	r0, r4
 8021cee:	f7fd fa10 	bl	801f112 <crs_strlen>
 8021cf2:	b282      	uxth	r2, r0
 8021cf4:	4621      	mov	r1, r4
 8021cf6:	200a      	movs	r0, #10
 8021cf8:	f7fd fa88 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("<parameter value>\r\n");
 8021cfc:	4d98      	ldr	r5, [pc, #608]	; (8021f60 <CMD_Help+0x488>)
 8021cfe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021d00:	6020      	str	r0, [r4, #0]
 8021d02:	6061      	str	r1, [r4, #4]
 8021d04:	60a2      	str	r2, [r4, #8]
 8021d06:	60e3      	str	r3, [r4, #12]
 8021d08:	6828      	ldr	r0, [r5, #0]
 8021d0a:	6120      	str	r0, [r4, #16]
 8021d0c:	4620      	mov	r0, r4
 8021d0e:	f7fd fa00 	bl	801f112 <crs_strlen>
 8021d12:	b283      	uxth	r3, r0
 8021d14:	4622      	mov	r2, r4
 8021d16:	2101      	movs	r1, #1
 8021d18:	200a      	movs	r0, #10
 8021d1a:	f7fd fa3d 	bl	801f198 <traceIF_itmPrint>
 8021d1e:	4620      	mov	r0, r4
 8021d20:	f7fd f9f7 	bl	801f112 <crs_strlen>
 8021d24:	b282      	uxth	r2, r0
 8021d26:	4621      	mov	r1, r4
 8021d28:	200a      	movs	r0, #10
 8021d2a:	f7fd fa6f 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("<val_1>|<val_2>|...|<val_n>: parameter value list\r\n");
 8021d2e:	4e8d      	ldr	r6, [pc, #564]	; (8021f64 <CMD_Help+0x48c>)
 8021d30:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8021d34:	4635      	mov	r5, r6
 8021d36:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021d38:	6020      	str	r0, [r4, #0]
 8021d3a:	6061      	str	r1, [r4, #4]
 8021d3c:	60a2      	str	r2, [r4, #8]
 8021d3e:	60e3      	str	r3, [r4, #12]
 8021d40:	462e      	mov	r6, r5
 8021d42:	3410      	adds	r4, #16
 8021d44:	4565      	cmp	r5, ip
 8021d46:	d1f5      	bne.n	8021d34 <CMD_Help+0x25c>
 8021d48:	6828      	ldr	r0, [r5, #0]
 8021d4a:	6020      	str	r0, [r4, #0]
 8021d4c:	4c7f      	ldr	r4, [pc, #508]	; (8021f4c <CMD_Help+0x474>)
 8021d4e:	4620      	mov	r0, r4
 8021d50:	f7fd f9df 	bl	801f112 <crs_strlen>
 8021d54:	b283      	uxth	r3, r0
 8021d56:	4622      	mov	r2, r4
 8021d58:	2101      	movs	r1, #1
 8021d5a:	200a      	movs	r0, #10
 8021d5c:	f7fd fa1c 	bl	801f198 <traceIF_itmPrint>
 8021d60:	4620      	mov	r0, r4
 8021d62:	f7fd f9d6 	bl	801f112 <crs_strlen>
 8021d66:	b282      	uxth	r2, r0
 8021d68:	4621      	mov	r1, r4
 8021d6a:	200a      	movs	r0, #10
 8021d6c:	f7fd fa4e 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("(command description)\r\n");
 8021d70:	4d7d      	ldr	r5, [pc, #500]	; (8021f68 <CMD_Help+0x490>)
 8021d72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021d74:	6020      	str	r0, [r4, #0]
 8021d76:	6061      	str	r1, [r4, #4]
 8021d78:	60a2      	str	r2, [r4, #8]
 8021d7a:	60e3      	str	r3, [r4, #12]
 8021d7c:	cd03      	ldmia	r5!, {r0, r1}
 8021d7e:	6120      	str	r0, [r4, #16]
 8021d80:	6161      	str	r1, [r4, #20]
 8021d82:	4620      	mov	r0, r4
 8021d84:	f7fd f9c5 	bl	801f112 <crs_strlen>
 8021d88:	b283      	uxth	r3, r0
 8021d8a:	4622      	mov	r2, r4
 8021d8c:	2101      	movs	r1, #1
 8021d8e:	200a      	movs	r0, #10
 8021d90:	f7fd fa02 	bl	801f198 <traceIF_itmPrint>
 8021d94:	4620      	mov	r0, r4
 8021d96:	f7fd f9bc 	bl	801f112 <crs_strlen>
 8021d9a:	b282      	uxth	r2, r0
 8021d9c:	4621      	mov	r1, r4
 8021d9e:	200a      	movs	r0, #10
 8021da0:	f7fd fa34 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("return key: last command re-execution\r\n");
 8021da4:	4e71      	ldr	r6, [pc, #452]	; (8021f6c <CMD_Help+0x494>)
 8021da6:	f106 0c20 	add.w	ip, r6, #32
 8021daa:	4635      	mov	r5, r6
 8021dac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021dae:	6020      	str	r0, [r4, #0]
 8021db0:	6061      	str	r1, [r4, #4]
 8021db2:	60a2      	str	r2, [r4, #8]
 8021db4:	60e3      	str	r3, [r4, #12]
 8021db6:	462e      	mov	r6, r5
 8021db8:	3410      	adds	r4, #16
 8021dba:	4565      	cmp	r5, ip
 8021dbc:	d1f5      	bne.n	8021daa <CMD_Help+0x2d2>
 8021dbe:	ce03      	ldmia	r6!, {r0, r1}
 8021dc0:	6020      	str	r0, [r4, #0]
 8021dc2:	6061      	str	r1, [r4, #4]
 8021dc4:	4c61      	ldr	r4, [pc, #388]	; (8021f4c <CMD_Help+0x474>)
 8021dc6:	4620      	mov	r0, r4
 8021dc8:	f7fd f9a3 	bl	801f112 <crs_strlen>
 8021dcc:	b283      	uxth	r3, r0
 8021dce:	4622      	mov	r2, r4
 8021dd0:	2101      	movs	r1, #1
 8021dd2:	200a      	movs	r0, #10
 8021dd4:	f7fd f9e0 	bl	801f198 <traceIF_itmPrint>
 8021dd8:	4620      	mov	r0, r4
 8021dda:	f7fd f99a 	bl	801f112 <crs_strlen>
 8021dde:	b282      	uxth	r2, r0
 8021de0:	4621      	mov	r1, r4
 8021de2:	200a      	movs	r0, #10
 8021de4:	f7fd fa12 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("#: comment line\r\n");
 8021de8:	4d61      	ldr	r5, [pc, #388]	; (8021f70 <CMD_Help+0x498>)
 8021dea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021dec:	6020      	str	r0, [r4, #0]
 8021dee:	6061      	str	r1, [r4, #4]
 8021df0:	60a2      	str	r2, [r4, #8]
 8021df2:	60e3      	str	r3, [r4, #12]
 8021df4:	882b      	ldrh	r3, [r5, #0]
 8021df6:	8223      	strh	r3, [r4, #16]
 8021df8:	4620      	mov	r0, r4
 8021dfa:	f7fd f98a 	bl	801f112 <crs_strlen>
 8021dfe:	b283      	uxth	r3, r0
 8021e00:	4622      	mov	r2, r4
 8021e02:	2101      	movs	r1, #1
 8021e04:	200a      	movs	r0, #10
 8021e06:	f7fd f9c7 	bl	801f198 <traceIF_itmPrint>
 8021e0a:	4620      	mov	r0, r4
 8021e0c:	f7fd f981 	bl	801f112 <crs_strlen>
 8021e10:	b282      	uxth	r2, r0
 8021e12:	4621      	mov	r1, r4
 8021e14:	200a      	movs	r0, #10
 8021e16:	f7fd f9f9 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\r\nAdvice\r\n");
 8021e1a:	4b56      	ldr	r3, [pc, #344]	; (8021f74 <CMD_Help+0x49c>)
 8021e1c:	cb03      	ldmia	r3!, {r0, r1}
 8021e1e:	6020      	str	r0, [r4, #0]
 8021e20:	6061      	str	r1, [r4, #4]
 8021e22:	881a      	ldrh	r2, [r3, #0]
 8021e24:	789b      	ldrb	r3, [r3, #2]
 8021e26:	8122      	strh	r2, [r4, #8]
 8021e28:	72a3      	strb	r3, [r4, #10]
 8021e2a:	4620      	mov	r0, r4
 8021e2c:	f7fd f971 	bl	801f112 <crs_strlen>
 8021e30:	b283      	uxth	r3, r0
 8021e32:	4622      	mov	r2, r4
 8021e34:	2101      	movs	r1, #1
 8021e36:	200a      	movs	r0, #10
 8021e38:	f7fd f9ae 	bl	801f198 <traceIF_itmPrint>
 8021e3c:	4620      	mov	r0, r4
 8021e3e:	f7fd f968 	bl	801f112 <crs_strlen>
 8021e42:	b282      	uxth	r2, r0
 8021e44:	4621      	mov	r1, r4
 8021e46:	200a      	movs	r0, #10
 8021e48:	f7fd f9e0 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("-----------\r\n");
 8021e4c:	4b41      	ldr	r3, [pc, #260]	; (8021f54 <CMD_Help+0x47c>)
 8021e4e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8021e50:	6020      	str	r0, [r4, #0]
 8021e52:	6061      	str	r1, [r4, #4]
 8021e54:	60a2      	str	r2, [r4, #8]
 8021e56:	881b      	ldrh	r3, [r3, #0]
 8021e58:	81a3      	strh	r3, [r4, #12]
 8021e5a:	4620      	mov	r0, r4
 8021e5c:	f7fd f959 	bl	801f112 <crs_strlen>
 8021e60:	b283      	uxth	r3, r0
 8021e62:	4622      	mov	r2, r4
 8021e64:	2101      	movs	r1, #1
 8021e66:	200a      	movs	r0, #10
 8021e68:	f7fd f996 	bl	801f198 <traceIF_itmPrint>
 8021e6c:	4620      	mov	r0, r4
 8021e6e:	f7fd f950 	bl	801f112 <crs_strlen>
 8021e72:	b282      	uxth	r2, r0
 8021e74:	4621      	mov	r1, r4
 8021e76:	200a      	movs	r0, #10
 8021e78:	f7fd f9c8 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("to use commands it is advised to use one of the following command to disable traces\r\n");
 8021e7c:	2256      	movs	r2, #86	; 0x56
 8021e7e:	493e      	ldr	r1, [pc, #248]	; (8021f78 <CMD_Help+0x4a0>)
 8021e80:	4620      	mov	r0, r4
 8021e82:	f004 f845 	bl	8025f10 <memcpy>
 8021e86:	4620      	mov	r0, r4
 8021e88:	f7fd f943 	bl	801f112 <crs_strlen>
 8021e8c:	b283      	uxth	r3, r0
 8021e8e:	4622      	mov	r2, r4
 8021e90:	2101      	movs	r1, #1
 8021e92:	200a      	movs	r0, #10
 8021e94:	f7fd f980 	bl	801f198 <traceIF_itmPrint>
 8021e98:	4620      	mov	r0, r4
 8021e9a:	f7fd f93a 	bl	801f112 <crs_strlen>
 8021e9e:	b282      	uxth	r2, r0
 8021ea0:	4621      	mov	r1, r4
 8021ea2:	200a      	movs	r0, #10
 8021ea4:	f7fd f9b2 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("trace off (allows disable all traces)\r\n");
 8021ea8:	4e34      	ldr	r6, [pc, #208]	; (8021f7c <CMD_Help+0x4a4>)
 8021eaa:	f106 0c20 	add.w	ip, r6, #32
 8021eae:	4635      	mov	r5, r6
 8021eb0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021eb2:	6020      	str	r0, [r4, #0]
 8021eb4:	6061      	str	r1, [r4, #4]
 8021eb6:	60a2      	str	r2, [r4, #8]
 8021eb8:	60e3      	str	r3, [r4, #12]
 8021eba:	462e      	mov	r6, r5
 8021ebc:	3410      	adds	r4, #16
 8021ebe:	4565      	cmp	r5, ip
 8021ec0:	d1f5      	bne.n	8021eae <CMD_Help+0x3d6>
 8021ec2:	ce03      	ldmia	r6!, {r0, r1}
 8021ec4:	6020      	str	r0, [r4, #0]
 8021ec6:	6061      	str	r1, [r4, #4]
 8021ec8:	4c20      	ldr	r4, [pc, #128]	; (8021f4c <CMD_Help+0x474>)
 8021eca:	4620      	mov	r0, r4
 8021ecc:	f7fd f921 	bl	801f112 <crs_strlen>
 8021ed0:	b283      	uxth	r3, r0
 8021ed2:	4622      	mov	r2, r4
 8021ed4:	2101      	movs	r1, #1
 8021ed6:	200a      	movs	r0, #10
 8021ed8:	f7fd f95e 	bl	801f198 <traceIF_itmPrint>
 8021edc:	4620      	mov	r0, r4
 8021ede:	f7fd f918 	bl	801f112 <crs_strlen>
 8021ee2:	b282      	uxth	r2, r0
 8021ee4:	4621      	mov	r1, r4
 8021ee6:	200a      	movs	r0, #10
 8021ee8:	f7fd f990 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("cst polling off  (allows to disable modem polling and avoid to display uncomfortable modem traces\r\n");
 8021eec:	2264      	movs	r2, #100	; 0x64
 8021eee:	4924      	ldr	r1, [pc, #144]	; (8021f80 <CMD_Help+0x4a8>)
 8021ef0:	4620      	mov	r0, r4
 8021ef2:	f004 f80d 	bl	8025f10 <memcpy>
 8021ef6:	4620      	mov	r0, r4
 8021ef8:	f7fd f90b 	bl	801f112 <crs_strlen>
 8021efc:	b283      	uxth	r3, r0
 8021efe:	4622      	mov	r2, r4
 8021f00:	2101      	movs	r1, #1
 8021f02:	200a      	movs	r0, #10
 8021f04:	f7fd f948 	bl	801f198 <traceIF_itmPrint>
 8021f08:	4620      	mov	r0, r4
 8021f0a:	f7fd f902 	bl	801f112 <crs_strlen>
 8021f0e:	b282      	uxth	r2, r0
 8021f10:	4621      	mov	r1, r4
 8021f12:	200a      	movs	r0, #10
 8021f14:	f7fd f97a 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("\r\n");
 8021f18:	4b1a      	ldr	r3, [pc, #104]	; (8021f84 <CMD_Help+0x4ac>)
 8021f1a:	881a      	ldrh	r2, [r3, #0]
 8021f1c:	789b      	ldrb	r3, [r3, #2]
 8021f1e:	8022      	strh	r2, [r4, #0]
 8021f20:	70a3      	strb	r3, [r4, #2]
 8021f22:	4620      	mov	r0, r4
 8021f24:	f7fd f8f5 	bl	801f112 <crs_strlen>
 8021f28:	b283      	uxth	r3, r0
 8021f2a:	4622      	mov	r2, r4
 8021f2c:	2101      	movs	r1, #1
 8021f2e:	200a      	movs	r0, #10
 8021f30:	f7fd f932 	bl	801f198 <traceIF_itmPrint>
 8021f34:	4620      	mov	r0, r4
 8021f36:	f7fd f8ec 	bl	801f112 <crs_strlen>
 8021f3a:	b282      	uxth	r2, r0
 8021f3c:	4621      	mov	r1, r4
 8021f3e:	200a      	movs	r0, #10
 8021f40:	f7fd f964 	bl	801f20c <traceIF_uartPrintForce>

  return CMD_OK;
}
 8021f44:	2000      	movs	r0, #0
 8021f46:	b006      	add	sp, #24
 8021f48:	bd70      	pop	{r4, r5, r6, pc}
 8021f4a:	bf00      	nop
 8021f4c:	200050dc 	.word	0x200050dc
 8021f50:	08035be4 	.word	0x08035be4
 8021f54:	08035bf4 	.word	0x08035bf4
 8021f58:	08035c04 	.word	0x08035c04
 8021f5c:	08035c28 	.word	0x08035c28
 8021f60:	08035c40 	.word	0x08035c40
 8021f64:	08035c54 	.word	0x08035c54
 8021f68:	08035c88 	.word	0x08035c88
 8021f6c:	08035ca0 	.word	0x08035ca0
 8021f70:	08035cc8 	.word	0x08035cc8
 8021f74:	08035cdc 	.word	0x08035cdc
 8021f78:	08035ce8 	.word	0x08035ce8
 8021f7c:	08035d40 	.word	0x08035d40
 8021f80:	08035d68 	.word	0x08035d68
 8021f84:	08034950 	.word	0x08034950

08021f88 <CMD_process>:
{
 8021f88:	b530      	push	{r4, r5, lr}
 8021f8a:	b09b      	sub	sp, #108	; 0x6c
  CMD_GetLine(command_line, CMD_MAX_LINE_SIZE);
 8021f8c:	2164      	movs	r1, #100	; 0x64
 8021f8e:	a801      	add	r0, sp, #4
 8021f90:	f7ff fd4e 	bl	8021a30 <CMD_GetLine>
  if (command_line[0] != (uint8_t)'#')
 8021f94:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8021f98:	2b23      	cmp	r3, #35	; 0x23
 8021f9a:	f000 80a7 	beq.w	80220ec <CMD_process+0x164>
    if (command_line[0] == 0U)
 8021f9e:	bb13      	cbnz	r3, 8021fe6 <CMD_process+0x5e>
      if (CMD_LastCommandLine[0] == 0U)
 8021fa0:	4b5e      	ldr	r3, [pc, #376]	; (802211c <CMD_process+0x194>)
 8021fa2:	781b      	ldrb	r3, [r3, #0]
 8021fa4:	b9ab      	cbnz	r3, 8021fd2 <CMD_process+0x4a>
        (void)memcpy((CRC_CHAR_t *)command_line, (CRC_CHAR_t *)"help", crs_strlen((const uint8_t *)"help") + 1U);
 8021fa6:	4c5e      	ldr	r4, [pc, #376]	; (8022120 <CMD_process+0x198>)
 8021fa8:	4620      	mov	r0, r4
 8021faa:	f7fd f8b2 	bl	801f112 <crs_strlen>
 8021fae:	1c42      	adds	r2, r0, #1
 8021fb0:	4621      	mov	r1, r4
 8021fb2:	a801      	add	r0, sp, #4
 8021fb4:	f003 ffac 	bl	8025f10 <memcpy>
    for (i = 0; i < CMD_MAX_LINE_SIZE ;  i++)
 8021fb8:	2400      	movs	r4, #0
 8021fba:	2c63      	cmp	r4, #99	; 0x63
 8021fbc:	d821      	bhi.n	8022002 <CMD_process+0x7a>
      if ((command_line[i] == (uint8_t)' ') || (command_line[i] == (uint8_t)0))
 8021fbe:	f104 0368 	add.w	r3, r4, #104	; 0x68
 8021fc2:	446b      	add	r3, sp
 8021fc4:	f813 3c64 	ldrb.w	r3, [r3, #-100]
 8021fc8:	2b20      	cmp	r3, #32
 8021fca:	d01a      	beq.n	8022002 <CMD_process+0x7a>
 8021fcc:	b1cb      	cbz	r3, 8022002 <CMD_process+0x7a>
    for (i = 0; i < CMD_MAX_LINE_SIZE ;  i++)
 8021fce:	3401      	adds	r4, #1
 8021fd0:	e7f3      	b.n	8021fba <CMD_process+0x32>
                     crs_strlen(CMD_LastCommandLine) + 1U);
 8021fd2:	4c52      	ldr	r4, [pc, #328]	; (802211c <CMD_process+0x194>)
 8021fd4:	4620      	mov	r0, r4
 8021fd6:	f7fd f89c 	bl	801f112 <crs_strlen>
        (void)memcpy((CRC_CHAR_t *)command_line, (CRC_CHAR_t *)CMD_LastCommandLine,
 8021fda:	1c42      	adds	r2, r0, #1
 8021fdc:	4621      	mov	r1, r4
 8021fde:	a801      	add	r0, sp, #4
 8021fe0:	f003 ff96 	bl	8025f10 <memcpy>
 8021fe4:	e7e8      	b.n	8021fb8 <CMD_process+0x30>
      cmd_line_len = crs_strlen(command_line);
 8021fe6:	a801      	add	r0, sp, #4
 8021fe8:	f7fd f893 	bl	801f112 <crs_strlen>
      if (cmd_line_len > 1U)
 8021fec:	2801      	cmp	r0, #1
 8021fee:	d9e3      	bls.n	8021fb8 <CMD_process+0x30>
        (void)memcpy((CRC_CHAR_t *)CMD_LastCommandLine, (CRC_CHAR_t *)command_line, crs_strlen(command_line) + 1U);
 8021ff0:	a801      	add	r0, sp, #4
 8021ff2:	f7fd f88e 	bl	801f112 <crs_strlen>
 8021ff6:	1c42      	adds	r2, r0, #1
 8021ff8:	a901      	add	r1, sp, #4
 8021ffa:	4848      	ldr	r0, [pc, #288]	; (802211c <CMD_process+0x194>)
 8021ffc:	f003 ff88 	bl	8025f10 <memcpy>
 8022000:	e7da      	b.n	8021fb8 <CMD_process+0x30>
    if (memcmp((CRC_CHAR_t *)"reset", (CRC_CHAR_t *)command_line, cmd_size) == 0)
 8022002:	4622      	mov	r2, r4
 8022004:	a901      	add	r1, sp, #4
 8022006:	4847      	ldr	r0, [pc, #284]	; (8022124 <CMD_process+0x19c>)
 8022008:	f003 fe95 	bl	8025d36 <memcmp>
 802200c:	b190      	cbz	r0, 8022034 <CMD_process+0xac>
    else if (i != CMD_MAX_LINE_SIZE)
 802200e:	2c64      	cmp	r4, #100	; 0x64
 8022010:	d06a      	beq.n	80220e8 <CMD_process+0x160>
      for (i = 0U; i < CMD_NbCmd ; i++)
 8022012:	2500      	movs	r5, #0
 8022014:	4b44      	ldr	r3, [pc, #272]	; (8022128 <CMD_process+0x1a0>)
 8022016:	681b      	ldr	r3, [r3, #0]
 8022018:	42ab      	cmp	r3, r5
 802201a:	d92d      	bls.n	8022078 <CMD_process+0xf0>
        if (memcmp((CRC_CHAR_t *)CMD_a_cmd_list[i].CmdName, (CRC_CHAR_t *)command_line, cmd_size) == 0)
 802201c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8022020:	4622      	mov	r2, r4
 8022022:	a901      	add	r1, sp, #4
 8022024:	4841      	ldr	r0, [pc, #260]	; (802212c <CMD_process+0x1a4>)
 8022026:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 802202a:	f003 fe84 	bl	8025d36 <memcmp>
 802202e:	b120      	cbz	r0, 802203a <CMD_process+0xb2>
      for (i = 0U; i < CMD_NbCmd ; i++)
 8022030:	3501      	adds	r5, #1
 8022032:	e7ef      	b.n	8022014 <CMD_process+0x8c>
      CMD_BoardReset((uint8_t *)command_line);
 8022034:	a801      	add	r0, sp, #4
 8022036:	f7ff fd17 	bl	8021a68 <CMD_BoardReset>
          PRINT_FORCE("\r\n")
 802203a:	4c3d      	ldr	r4, [pc, #244]	; (8022130 <CMD_process+0x1a8>)
 802203c:	4b3d      	ldr	r3, [pc, #244]	; (8022134 <CMD_process+0x1ac>)
 802203e:	881a      	ldrh	r2, [r3, #0]
 8022040:	789b      	ldrb	r3, [r3, #2]
 8022042:	8022      	strh	r2, [r4, #0]
 8022044:	70a3      	strb	r3, [r4, #2]
 8022046:	4620      	mov	r0, r4
 8022048:	f7fd f863 	bl	801f112 <crs_strlen>
 802204c:	b283      	uxth	r3, r0
 802204e:	4622      	mov	r2, r4
 8022050:	2101      	movs	r1, #1
 8022052:	200a      	movs	r0, #10
 8022054:	f7fd f8a0 	bl	801f198 <traceIF_itmPrint>
 8022058:	4620      	mov	r0, r4
 802205a:	f7fd f85a 	bl	801f112 <crs_strlen>
 802205e:	b282      	uxth	r2, r0
 8022060:	4621      	mov	r1, r4
 8022062:	200a      	movs	r0, #10
 8022064:	f7fd f8d2 	bl	801f20c <traceIF_uartPrintForce>
          (void)CMD_a_cmd_list[i].CmdHandler((uint8_t *)command_line);
 8022068:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 802206c:	4b2f      	ldr	r3, [pc, #188]	; (802212c <CMD_process+0x1a4>)
 802206e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8022072:	689b      	ldr	r3, [r3, #8]
 8022074:	a801      	add	r0, sp, #4
 8022076:	4798      	blx	r3
      if (i >= CMD_NbCmd)
 8022078:	4b2b      	ldr	r3, [pc, #172]	; (8022128 <CMD_process+0x1a0>)
 802207a:	681b      	ldr	r3, [r3, #0]
 802207c:	42ab      	cmp	r3, r5
 802207e:	d918      	bls.n	80220b2 <CMD_process+0x12a>
  PRINT_FORCE("%s", (CRC_CHAR_t *)cmd_prompt)
 8022080:	4c2b      	ldr	r4, [pc, #172]	; (8022130 <CMD_process+0x1a8>)
 8022082:	4b2d      	ldr	r3, [pc, #180]	; (8022138 <CMD_process+0x1b0>)
 8022084:	881a      	ldrh	r2, [r3, #0]
 8022086:	789b      	ldrb	r3, [r3, #2]
 8022088:	8022      	strh	r2, [r4, #0]
 802208a:	70a3      	strb	r3, [r4, #2]
 802208c:	4620      	mov	r0, r4
 802208e:	f7fd f840 	bl	801f112 <crs_strlen>
 8022092:	b283      	uxth	r3, r0
 8022094:	4622      	mov	r2, r4
 8022096:	2101      	movs	r1, #1
 8022098:	200a      	movs	r0, #10
 802209a:	f7fd f87d 	bl	801f198 <traceIF_itmPrint>
 802209e:	4620      	mov	r0, r4
 80220a0:	f7fd f837 	bl	801f112 <crs_strlen>
 80220a4:	b282      	uxth	r2, r0
 80220a6:	4621      	mov	r1, r4
 80220a8:	200a      	movs	r0, #10
 80220aa:	f7fd f8af 	bl	801f20c <traceIF_uartPrintForce>
}
 80220ae:	b01b      	add	sp, #108	; 0x6c
 80220b0:	bd30      	pop	{r4, r5, pc}
        PRINT_FORCE("\r\nCMD : unknown command : %s\r\n", command_line)
 80220b2:	4c1f      	ldr	r4, [pc, #124]	; (8022130 <CMD_process+0x1a8>)
 80220b4:	aa01      	add	r2, sp, #4
 80220b6:	4921      	ldr	r1, [pc, #132]	; (802213c <CMD_process+0x1b4>)
 80220b8:	4620      	mov	r0, r4
 80220ba:	f003 fdd9 	bl	8025c70 <sprintf>
 80220be:	4620      	mov	r0, r4
 80220c0:	f7fd f827 	bl	801f112 <crs_strlen>
 80220c4:	b283      	uxth	r3, r0
 80220c6:	4622      	mov	r2, r4
 80220c8:	2101      	movs	r1, #1
 80220ca:	200a      	movs	r0, #10
 80220cc:	f7fd f864 	bl	801f198 <traceIF_itmPrint>
 80220d0:	4620      	mov	r0, r4
 80220d2:	f7fd f81e 	bl	801f112 <crs_strlen>
 80220d6:	b282      	uxth	r2, r0
 80220d8:	4621      	mov	r1, r4
 80220da:	200a      	movs	r0, #10
 80220dc:	f7fd f896 	bl	801f20c <traceIF_uartPrintForce>
        (void)CMD_Help(command_line);
 80220e0:	a801      	add	r0, sp, #4
 80220e2:	f7ff fcf9 	bl	8021ad8 <CMD_Help>
 80220e6:	e7cb      	b.n	8022080 <CMD_process+0xf8>
      __NOP(); /* Nothing to do */
 80220e8:	bf00      	nop
 80220ea:	e7c9      	b.n	8022080 <CMD_process+0xf8>
    PRINT_FORCE("\r\n")
 80220ec:	4c10      	ldr	r4, [pc, #64]	; (8022130 <CMD_process+0x1a8>)
 80220ee:	4b11      	ldr	r3, [pc, #68]	; (8022134 <CMD_process+0x1ac>)
 80220f0:	881a      	ldrh	r2, [r3, #0]
 80220f2:	789b      	ldrb	r3, [r3, #2]
 80220f4:	8022      	strh	r2, [r4, #0]
 80220f6:	70a3      	strb	r3, [r4, #2]
 80220f8:	4620      	mov	r0, r4
 80220fa:	f7fd f80a 	bl	801f112 <crs_strlen>
 80220fe:	b283      	uxth	r3, r0
 8022100:	4622      	mov	r2, r4
 8022102:	2101      	movs	r1, #1
 8022104:	200a      	movs	r0, #10
 8022106:	f7fd f847 	bl	801f198 <traceIF_itmPrint>
 802210a:	4620      	mov	r0, r4
 802210c:	f7fd f801 	bl	801f112 <crs_strlen>
 8022110:	b282      	uxth	r2, r0
 8022112:	4621      	mov	r1, r4
 8022114:	200a      	movs	r0, #10
 8022116:	f7fd f879 	bl	801f20c <traceIF_uartPrintForce>
 802211a:	e7b1      	b.n	8022080 <CMD_process+0xf8>
 802211c:	20005a78 	.word	0x20005a78
 8022120:	08032b48 	.word	0x08032b48
 8022124:	08035dcc 	.word	0x08035dcc
 8022128:	20005adc 	.word	0x20005adc
 802212c:	20005ae8 	.word	0x20005ae8
 8022130:	200050dc 	.word	0x200050dc
 8022134:	08034950 	.word	0x08034950
 8022138:	08035df4 	.word	0x08035df4
 802213c:	08035dd4 	.word	0x08035dd4

08022140 <cmd_thread>:
  * @brief thread core of the command management
  * @param  argument (not used)
  * @retval -
  */
static void cmd_thread(const void *argument)
{
 8022140:	b508      	push	{r3, lr}
  for (;;)
  {
    CMD_process();
 8022142:	f7ff ff21 	bl	8021f88 <CMD_process>
  for (;;)
 8022146:	e7fc      	b.n	8022142 <cmd_thread+0x2>

08022148 <CMD_GetValue>:
  * @param  string_p   (IN) acscii value to convert
  * @param  value_p    (OUT) converted uint32_t value
  * @retval return value
  */
uint32_t CMD_GetValue(uint8_t *string_p, uint32_t *value_p)
{
 8022148:	b538      	push	{r3, r4, r5, lr}
 802214a:	460d      	mov	r5, r1
  uint32_t ret;
  uint8_t digit8;
  uint32_t digit;
  ret = 0U;

  if (string_p == NULL)
 802214c:	b170      	cbz	r0, 802216c <CMD_GetValue+0x24>
 802214e:	4604      	mov	r4, r0
    ret = 1U;
    *value_p = 0U;
  }
  else
  {
    if (memcmp((CRC_CHAR_t *)string_p, "0x", 2U) == 0)
 8022150:	2202      	movs	r2, #2
 8022152:	490e      	ldr	r1, [pc, #56]	; (802218c <CMD_GetValue+0x44>)
 8022154:	f003 fdef 	bl	8025d36 <memcmp>
 8022158:	b160      	cbz	r0, 8022174 <CMD_GetValue+0x2c>
    {
      *value_p = (uint32_t)crs_atoi_hex(&string_p[2]);
    }
    else
    {
      digit8 = (*string_p - (uint8_t)'0');
 802215a:	7823      	ldrb	r3, [r4, #0]
 802215c:	3b30      	subs	r3, #48	; 0x30
 802215e:	b2db      	uxtb	r3, r3
      digit  = (uint32_t)digit8;
      if (digit <= 9U)
 8022160:	2b09      	cmp	r3, #9
 8022162:	d90d      	bls.n	8022180 <CMD_GetValue+0x38>
        *value_p = (uint32_t)crs_atoi(string_p);
      }
      else
      {
        ret = 1U;
        *value_p = 0U;
 8022164:	2300      	movs	r3, #0
 8022166:	602b      	str	r3, [r5, #0]
        ret = 1U;
 8022168:	2001      	movs	r0, #1
      }
    }
  }
  return ret;
}
 802216a:	bd38      	pop	{r3, r4, r5, pc}
    *value_p = 0U;
 802216c:	2300      	movs	r3, #0
 802216e:	600b      	str	r3, [r1, #0]
    ret = 1U;
 8022170:	2001      	movs	r0, #1
 8022172:	e7fa      	b.n	802216a <CMD_GetValue+0x22>
      *value_p = (uint32_t)crs_atoi_hex(&string_p[2]);
 8022174:	1ca0      	adds	r0, r4, #2
 8022176:	f7fc ffac 	bl	801f0d2 <crs_atoi_hex>
 802217a:	6028      	str	r0, [r5, #0]
  ret = 0U;
 802217c:	2000      	movs	r0, #0
 802217e:	e7f4      	b.n	802216a <CMD_GetValue+0x22>
        *value_p = (uint32_t)crs_atoi(string_p);
 8022180:	4620      	mov	r0, r4
 8022182:	f7fc ff81 	bl	801f088 <crs_atoi>
 8022186:	6028      	str	r0, [r5, #0]
  ret = 0U;
 8022188:	2000      	movs	r0, #0
 802218a:	e7ee      	b.n	802216a <CMD_GetValue+0x22>
 802218c:	08035df8 	.word	0x08035df8

08022190 <CMD_Declare>:
  * @param  cmd_handler    callback of the component to manage the command
  * @param  cmd_label_p    description of the component to display at the help  command
  * @retval -
  */
void CMD_Declare(uint8_t *cmd_name_p, CMD_HandlerCmd cmd_handler, uint8_t *cmd_label_p)
{
 8022190:	b510      	push	{r4, lr}
  if (CMD_NbCmd >= CMD_MAX_CMD)
 8022192:	4b0c      	ldr	r3, [pc, #48]	; (80221c4 <CMD_Declare+0x34>)
 8022194:	681b      	ldr	r3, [r3, #0]
 8022196:	2b16      	cmp	r3, #22
 8022198:	d80e      	bhi.n	80221b8 <CMD_Declare+0x28>
    /* too many recorded components */
    ERROR_Handler(DBG_CHAN_UTILITIES, 10, ERROR_WARNING);
  }
  else
  {
    CMD_a_cmd_list[CMD_NbCmd].CmdName    = cmd_name_p;
 802219a:	4c0b      	ldr	r4, [pc, #44]	; (80221c8 <CMD_Declare+0x38>)
 802219c:	eb03 0e43 	add.w	lr, r3, r3, lsl #1
 80221a0:	eb04 0c8e 	add.w	ip, r4, lr, lsl #2
 80221a4:	f844 002e 	str.w	r0, [r4, lr, lsl #2]
    CMD_a_cmd_list[CMD_NbCmd].CmdLabel   = cmd_label_p;
 80221a8:	f8cc 2004 	str.w	r2, [ip, #4]
    CMD_a_cmd_list[CMD_NbCmd].CmdHandler = cmd_handler;
 80221ac:	f8cc 1008 	str.w	r1, [ip, #8]

    CMD_NbCmd++;
 80221b0:	3301      	adds	r3, #1
 80221b2:	4a04      	ldr	r2, [pc, #16]	; (80221c4 <CMD_Declare+0x34>)
 80221b4:	6013      	str	r3, [r2, #0]
  }
}
 80221b6:	bd10      	pop	{r4, pc}
    ERROR_Handler(DBG_CHAN_UTILITIES, 10, ERROR_WARNING);
 80221b8:	2202      	movs	r2, #2
 80221ba:	210a      	movs	r1, #10
 80221bc:	4608      	mov	r0, r1
 80221be:	f7fb ffc5 	bl	801e14c <ERROR_Handler>
 80221c2:	e7f8      	b.n	80221b6 <CMD_Declare+0x26>
 80221c4:	20005adc 	.word	0x20005adc
 80221c8:	20005ae8 	.word	0x20005ae8

080221cc <CMD_RxCpltCallback>:
  * @brief console UART receive IT Callback
  * @param  uart_handle_p       console UART handle
  * @retval -
  */
void CMD_RxCpltCallback(UART_HandleTypeDef *uart_handle_p)
{
 80221cc:	b538      	push	{r3, r4, r5, lr}
  static UART_HandleTypeDef *CMD_CurrentUart;

  CMD_CurrentUart = uart_handle_p;
 80221ce:	4b19      	ldr	r3, [pc, #100]	; (8022234 <CMD_RxCpltCallback+0x68>)
 80221d0:	6018      	str	r0, [r3, #0]
  uint8_t rec_char;
  uint8_t *temp;

  /* store the received char */
  rec_char = CMD_ReceivedChar;
 80221d2:	4919      	ldr	r1, [pc, #100]	; (8022238 <CMD_RxCpltCallback+0x6c>)
 80221d4:	780c      	ldrb	r4, [r1, #0]

  /* rearm the IT  receveive for the next char */
  if (HAL_UART_Receive_IT(CMD_CurrentUart, (uint8_t *)&CMD_ReceivedChar, 1U) != HAL_OK)
 80221d6:	2201      	movs	r2, #1
 80221d8:	f7e7 ff5a 	bl	800a090 <HAL_UART_Receive_IT>
 80221dc:	b100      	cbz	r0, 80221e0 <CMD_RxCpltCallback+0x14>
  {
    __NOP(); /* Nothing to do */
 80221de:	bf00      	nop
  }

  /* ignore '\n' char */
  if (rec_char != (uint8_t)'\n')
 80221e0:	2c0a      	cmp	r4, #10
 80221e2:	d016      	beq.n	8022212 <CMD_RxCpltCallback+0x46>
  {
    if ((rec_char == (uint8_t)'\r') || (CMD_CurrentPos >= (CMD_MAX_LINE_SIZE - 1U)))
 80221e4:	2c0d      	cmp	r4, #13
 80221e6:	d003      	beq.n	80221f0 <CMD_RxCpltCallback+0x24>
 80221e8:	4b14      	ldr	r3, [pc, #80]	; (802223c <CMD_RxCpltCallback+0x70>)
 80221ea:	681b      	ldr	r3, [r3, #0]
 80221ec:	2b62      	cmp	r3, #98	; 0x62
 80221ee:	d911      	bls.n	8022214 <CMD_RxCpltCallback+0x48>
    {
      /* end of line reached: switch between reveived buffer and receiving buffer */
      CMD_current_rcv_line[CMD_CurrentPos] = 0;
 80221f0:	4813      	ldr	r0, [pc, #76]	; (8022240 <CMD_RxCpltCallback+0x74>)
 80221f2:	6803      	ldr	r3, [r0, #0]
 80221f4:	4a11      	ldr	r2, [pc, #68]	; (802223c <CMD_RxCpltCallback+0x70>)
 80221f6:	6814      	ldr	r4, [r2, #0]
 80221f8:	2100      	movs	r1, #0
 80221fa:	5519      	strb	r1, [r3, r4]
      temp = CMD_completed_line;
 80221fc:	4c11      	ldr	r4, [pc, #68]	; (8022244 <CMD_RxCpltCallback+0x78>)
 80221fe:	6825      	ldr	r5, [r4, #0]
      CMD_completed_line = CMD_current_rcv_line;
 8022200:	6023      	str	r3, [r4, #0]
      CMD_current_cmd    = CMD_completed_line;
 8022202:	4c11      	ldr	r4, [pc, #68]	; (8022248 <CMD_RxCpltCallback+0x7c>)
 8022204:	6023      	str	r3, [r4, #0]
      CMD_current_rcv_line = temp;
 8022206:	6005      	str	r5, [r0, #0]
      CMD_CurrentPos = 0;
 8022208:	6011      	str	r1, [r2, #0]
      (void)rtosalSemaphoreRelease(CMD_rcvSemaphore);
 802220a:	4b10      	ldr	r3, [pc, #64]	; (802224c <CMD_RxCpltCallback+0x80>)
 802220c:	6818      	ldr	r0, [r3, #0]
 802220e:	f7fc fe8c 	bl	801ef2a <rtosalSemaphoreRelease>
        CMD_current_rcv_line[CMD_CurrentPos] = rec_char;
        CMD_CurrentPos++;
      }
    }
  }
}
 8022212:	bd38      	pop	{r3, r4, r5, pc}
      if (rec_char == (uint8_t)'\b')
 8022214:	2c08      	cmp	r4, #8
 8022216:	d006      	beq.n	8022226 <CMD_RxCpltCallback+0x5a>
        CMD_current_rcv_line[CMD_CurrentPos] = rec_char;
 8022218:	4a09      	ldr	r2, [pc, #36]	; (8022240 <CMD_RxCpltCallback+0x74>)
 802221a:	6812      	ldr	r2, [r2, #0]
 802221c:	54d4      	strb	r4, [r2, r3]
        CMD_CurrentPos++;
 802221e:	3301      	adds	r3, #1
 8022220:	4a06      	ldr	r2, [pc, #24]	; (802223c <CMD_RxCpltCallback+0x70>)
 8022222:	6013      	str	r3, [r2, #0]
}
 8022224:	e7f5      	b.n	8022212 <CMD_RxCpltCallback+0x46>
        if (CMD_CurrentPos > 0U)
 8022226:	2b00      	cmp	r3, #0
 8022228:	d0f3      	beq.n	8022212 <CMD_RxCpltCallback+0x46>
          CMD_CurrentPos--;
 802222a:	3b01      	subs	r3, #1
 802222c:	4a03      	ldr	r2, [pc, #12]	; (802223c <CMD_RxCpltCallback+0x70>)
 802222e:	6013      	str	r3, [r2, #0]
 8022230:	e7ef      	b.n	8022212 <CMD_RxCpltCallback+0x46>
 8022232:	bf00      	nop
 8022234:	20005a74 	.word	0x20005a74
 8022238:	20005ae0 	.word	0x20005ae0
 802223c:	20005a70 	.word	0x20005a70
 8022240:	20005c04 	.word	0x20005c04
 8022244:	20005bfc 	.word	0x20005bfc
 8022248:	20005c00 	.word	0x20005c00
 802224c:	20005c08 	.word	0x20005c08

08022250 <CMD_print_help>:
  * @brief display component help
  * @param  label   component description
  * @retval -
  */
void CMD_print_help(uint8_t *label)
{
 8022250:	b510      	push	{r4, lr}
 8022252:	4602      	mov	r2, r0
  PRINT_FORCE("***** %s help *****\r\n", label);
 8022254:	4c0b      	ldr	r4, [pc, #44]	; (8022284 <CMD_print_help+0x34>)
 8022256:	490c      	ldr	r1, [pc, #48]	; (8022288 <CMD_print_help+0x38>)
 8022258:	4620      	mov	r0, r4
 802225a:	f003 fd09 	bl	8025c70 <sprintf>
 802225e:	4620      	mov	r0, r4
 8022260:	f7fc ff57 	bl	801f112 <crs_strlen>
 8022264:	b283      	uxth	r3, r0
 8022266:	4622      	mov	r2, r4
 8022268:	2101      	movs	r1, #1
 802226a:	200a      	movs	r0, #10
 802226c:	f7fc ff94 	bl	801f198 <traceIF_itmPrint>
 8022270:	4620      	mov	r0, r4
 8022272:	f7fc ff4e 	bl	801f112 <crs_strlen>
 8022276:	b282      	uxth	r2, r0
 8022278:	4621      	mov	r1, r4
 802227a:	200a      	movs	r0, #10
 802227c:	f7fc ffc6 	bl	801f20c <traceIF_uartPrintForce>
}
 8022280:	bd10      	pop	{r4, pc}
 8022282:	bf00      	nop
 8022284:	200050dc 	.word	0x200050dc
 8022288:	08035dfc 	.word	0x08035dfc

0802228c <CMD_init>:
  * @brief  module initialization
  * @param  -
  * @retval -
  */
void CMD_init(void)
{
 802228c:	b510      	push	{r4, lr}
 802228e:	b082      	sub	sp, #8
#if (USE_LINK_UART == 1)
  static uint8_t   CMD_LinkCommandLine[2][CMD_MAX_LINE_SIZE];
#endif  /* (USE_LINK_UART == 1) */
  static osThreadId CMD_ThreadId;

  CMD_NbCmd           = 0U;
 8022290:	2400      	movs	r4, #0
 8022292:	4b1a      	ldr	r3, [pc, #104]	; (80222fc <CMD_init+0x70>)
 8022294:	601c      	str	r4, [r3, #0]

  CMD_CommandLine[0][0] = 0;
 8022296:	4b1a      	ldr	r3, [pc, #104]	; (8022300 <CMD_init+0x74>)
 8022298:	701c      	strb	r4, [r3, #0]
  CMD_CommandLine[1][0] = 0;
 802229a:	f883 4064 	strb.w	r4, [r3, #100]	; 0x64
  CMD_current_rcv_line  = CMD_CommandLine[0];
 802229e:	4a19      	ldr	r2, [pc, #100]	; (8022304 <CMD_init+0x78>)
 80222a0:	6013      	str	r3, [r2, #0]
  CMD_current_cmd       = CMD_CommandLine[1];
 80222a2:	3364      	adds	r3, #100	; 0x64
 80222a4:	4a18      	ldr	r2, [pc, #96]	; (8022308 <CMD_init+0x7c>)
 80222a6:	6013      	str	r3, [r2, #0]
  CMD_completed_line    = CMD_CommandLine[1];
 80222a8:	4a18      	ldr	r2, [pc, #96]	; (802230c <CMD_init+0x80>)
 80222aa:	6013      	str	r3, [r2, #0]
  CMD_CurrentPos        = 0;
 80222ac:	4b18      	ldr	r3, [pc, #96]	; (8022310 <CMD_init+0x84>)
 80222ae:	601c      	str	r4, [r3, #0]
#if (USE_LINK_UART == 1)
  CMD_link_current_rcv_line = CMD_LinkCommandLine[0];
  CMD_link_completed_line   = CMD_LinkCommandLine[1];
#endif  /* (USE_LINK_UART == 1) */

  CMD_Declare((uint8_t *)"help", CMD_Help, (uint8_t *)"help command");
 80222b0:	4a18      	ldr	r2, [pc, #96]	; (8022314 <CMD_init+0x88>)
 80222b2:	4919      	ldr	r1, [pc, #100]	; (8022318 <CMD_init+0x8c>)
 80222b4:	4819      	ldr	r0, [pc, #100]	; (802231c <CMD_init+0x90>)
 80222b6:	f7ff ff6b 	bl	8022190 <CMD_Declare>
#if (USE_LINK_UART == 1)
  CMD_Declare((uint8_t *)"uartcmd", CMD_UartCmd, "send command to link uart");
#endif  /* (USE_LINK_UART == 1) */

  CMD_LastCommandLine[0] = 0;
 80222ba:	4b19      	ldr	r3, [pc, #100]	; (8022320 <CMD_init+0x94>)
 80222bc:	701c      	strb	r4, [r3, #0]

  CMD_rcvSemaphore = rtosalSemaphoreNew(NULL, 1);
 80222be:	2101      	movs	r1, #1
 80222c0:	4620      	mov	r0, r4
 80222c2:	f7fc fe24 	bl	801ef0e <rtosalSemaphoreNew>
 80222c6:	4b17      	ldr	r3, [pc, #92]	; (8022324 <CMD_init+0x98>)
 80222c8:	6018      	str	r0, [r3, #0]
  (void)rtosalSemaphoreAcquire(CMD_rcvSemaphore, RTOSAL_WAIT_FOREVER);
 80222ca:	f04f 31ff 	mov.w	r1, #4294967295
 80222ce:	f7fc fe28 	bl	801ef22 <rtosalSemaphoreAcquire>

  CMD_ThreadId = rtosalThreadNew((const rtosal_char_t *)"CMD_THREAD_DEF", cmd_thread, CMD_THREAD_PRIO,
 80222d2:	9400      	str	r4, [sp, #0]
 80222d4:	f44f 7316 	mov.w	r3, #600	; 0x258
 80222d8:	f04f 32ff 	mov.w	r2, #4294967295
 80222dc:	4912      	ldr	r1, [pc, #72]	; (8022328 <CMD_init+0x9c>)
 80222de:	4813      	ldr	r0, [pc, #76]	; (802232c <CMD_init+0xa0>)
 80222e0:	f7fc fe05 	bl	801eeee <rtosalThreadNew>
 80222e4:	4b12      	ldr	r3, [pc, #72]	; (8022330 <CMD_init+0xa4>)
 80222e6:	6018      	str	r0, [r3, #0]
                                 USED_CMD_THREAD_STACK_SIZE, NULL);
  if (CMD_ThreadId == NULL)
 80222e8:	b108      	cbz	r0, 80222ee <CMD_init+0x62>
  {
#if (USE_STACK_ANALYSIS == 1U)
    (void)stackAnalysis_addStackSizeByHandle(CMD_ThreadId, USED_CMD_THREAD_STACK_SIZE);
#endif /* USE_STACK_ANALYSIS == 1 */
  }
}
 80222ea:	b002      	add	sp, #8
 80222ec:	bd10      	pop	{r4, pc}
    ERROR_Handler(DBG_CHAN_UTILITIES, 2, ERROR_FATAL);
 80222ee:	2203      	movs	r2, #3
 80222f0:	2102      	movs	r1, #2
 80222f2:	200a      	movs	r0, #10
 80222f4:	f7fb ff2a 	bl	801e14c <ERROR_Handler>
}
 80222f8:	e7f7      	b.n	80222ea <CMD_init+0x5e>
 80222fa:	bf00      	nop
 80222fc:	20005adc 	.word	0x20005adc
 8022300:	200059a8 	.word	0x200059a8
 8022304:	20005c04 	.word	0x20005c04
 8022308:	20005c00 	.word	0x20005c00
 802230c:	20005bfc 	.word	0x20005bfc
 8022310:	20005a70 	.word	0x20005a70
 8022314:	08035e14 	.word	0x08035e14
 8022318:	08021ad9 	.word	0x08021ad9
 802231c:	08032b48 	.word	0x08032b48
 8022320:	20005a78 	.word	0x20005a78
 8022324:	20005c08 	.word	0x20005c08
 8022328:	08022141 	.word	0x08022141
 802232c:	08035e24 	.word	0x08035e24
 8022330:	20005ae4 	.word	0x20005ae4

08022334 <CMD_start>:
  * @brief  module start
  * @param  -
  * @retval -
  */
void CMD_start(void)
{
 8022334:	b508      	push	{r3, lr}
  HAL_StatusTypeDef ret;

  CMD_CommandLine[0][0] = 0;
 8022336:	4b08      	ldr	r3, [pc, #32]	; (8022358 <CMD_start+0x24>)
 8022338:	2200      	movs	r2, #0
 802233a:	701a      	strb	r2, [r3, #0]
  CMD_CommandLine[1][0] = 0;
 802233c:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
 8022340:	e002      	b.n	8022348 <CMD_start+0x14>
    ret = HAL_UART_Receive_IT(&TRACE_INTERFACE_UART_HANDLE, &CMD_ReceivedChar, 1U);
    if (ret == HAL_OK)
    {
      break;
    }
    (void)rtosalDelay(10);
 8022342:	200a      	movs	r0, #10
 8022344:	f7fc fe3d 	bl	801efc2 <rtosalDelay>
    ret = HAL_UART_Receive_IT(&TRACE_INTERFACE_UART_HANDLE, &CMD_ReceivedChar, 1U);
 8022348:	2201      	movs	r2, #1
 802234a:	4904      	ldr	r1, [pc, #16]	; (802235c <CMD_start+0x28>)
 802234c:	4804      	ldr	r0, [pc, #16]	; (8022360 <CMD_start+0x2c>)
 802234e:	f7e7 fe9f 	bl	800a090 <HAL_UART_Receive_IT>
    if (ret == HAL_OK)
 8022352:	2800      	cmp	r0, #0
 8022354:	d1f5      	bne.n	8022342 <CMD_start+0xe>
  }
}
 8022356:	bd08      	pop	{r3, pc}
 8022358:	200059a8 	.word	0x200059a8
 802235c:	20005ae0 	.word	0x20005ae0
 8022360:	20000c04 	.word	0x20000c04

08022364 <mems_init_sensors>:
#endif /* USE_STACK_ANALYSIS == 1 */
  }
}

static void mems_init_sensors(void)
{
 8022364:	b508      	push	{r3, lr}
  if (PSENSOR_OK == BSP_PSENSOR_Init())
  {
    mems_init_status |= FLAG_MEMS_PRESSURE;
  }
#elif defined (USE_STM32L462E_CELL01) /* USE B-L462E-CELL1 MEMS */
  if (TSENSOR_OK == BSP_TSENSOR_Init())
 8022366:	f7df fdc9 	bl	8001efc <BSP_TSENSOR_Init>
 802236a:	b920      	cbnz	r0, 8022376 <mems_init_sensors+0x12>
  {
    mems_init_status |= FLAG_MEMS_TEMPERATURE;
 802236c:	4a0a      	ldr	r2, [pc, #40]	; (8022398 <mems_init_sensors+0x34>)
 802236e:	7813      	ldrb	r3, [r2, #0]
 8022370:	f043 0310 	orr.w	r3, r3, #16
 8022374:	7013      	strb	r3, [r2, #0]
  }
  if (HSENSOR_OK == BSP_HSENSOR_Init())
 8022376:	f7df fd81 	bl	8001e7c <BSP_HSENSOR_Init>
 802237a:	b920      	cbnz	r0, 8022386 <mems_init_sensors+0x22>
  {
    mems_init_status |= FLAG_MEMS_HUMIDTY;
 802237c:	4a06      	ldr	r2, [pc, #24]	; (8022398 <mems_init_sensors+0x34>)
 802237e:	7813      	ldrb	r3, [r2, #0]
 8022380:	f043 0308 	orr.w	r3, r3, #8
 8022384:	7013      	strb	r3, [r2, #0]
  }
  if (PSENSOR_OK == BSP_PSENSOR_Init())
 8022386:	f7df fd99 	bl	8001ebc <BSP_PSENSOR_Init>
 802238a:	b920      	cbnz	r0, 8022396 <mems_init_sensors+0x32>
  {
    mems_init_status |= FLAG_MEMS_PRESSURE;
 802238c:	4a02      	ldr	r2, [pc, #8]	; (8022398 <mems_init_sensors+0x34>)
 802238e:	7813      	ldrb	r3, [r2, #0]
 8022390:	f043 0320 	orr.w	r3, r3, #32
 8022394:	7013      	strb	r3, [r2, #0]
    BSP_MOTION_SENSOR_Enable(GYRO_INSTANCE, MOTION_GYRO);
    BSP_MOTION_SENSOR_SetOutputDataRate(GYRO_INSTANCE, MOTION_GYRO, 833);
  }
#endif /* USE_STM32L496G_DISCO */
#endif /* USE_DC_MEMS */
}
 8022396:	bd08      	pop	{r3, pc}
 8022398:	20005c94 	.word	0x20005c94

0802239c <mems_get_pressure_datas>:
    success = 1U;
  }
#elif defined (USE_STM32L475E_IOT01)|| defined (USE_STM32L462E_CELL01) /* USE B-L475E-IOT1 MEMS */
  static float_t PRESSURE_Value; /*!< Pressure Value */
  dc_pressure_info_t        pressure_info;
  if (mems_init_status & FLAG_MEMS_PRESSURE)
 802239c:	4b1c      	ldr	r3, [pc, #112]	; (8022410 <mems_get_pressure_datas+0x74>)
 802239e:	7818      	ldrb	r0, [r3, #0]
 80223a0:	f010 0020 	ands.w	r0, r0, #32
 80223a4:	d100      	bne.n	80223a8 <mems_get_pressure_datas+0xc>
    success = 1U;
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
  return (success);
}
 80223a6:	4770      	bx	lr
{
 80223a8:	b530      	push	{r4, r5, lr}
 80223aa:	b085      	sub	sp, #20
    PRESSURE_Value = BSP_PSENSOR_ReadPressure();
 80223ac:	f7df fd9c 	bl	8001ee8 <BSP_PSENSOR_ReadPressure>
 80223b0:	ee10 0a10 	vmov	r0, s0
 80223b4:	4d17      	ldr	r5, [pc, #92]	; (8022414 <mems_get_pressure_datas+0x78>)
 80223b6:	ed85 0a00 	vstr	s0, [r5]
    PRINT_DBG("### PRESSURE_Value = %f\n\r", PRESSURE_Value)
 80223ba:	f7de f8dd 	bl	8000578 <__aeabi_f2d>
 80223be:	4602      	mov	r2, r0
 80223c0:	460b      	mov	r3, r1
 80223c2:	4c15      	ldr	r4, [pc, #84]	; (8022418 <mems_get_pressure_datas+0x7c>)
 80223c4:	4915      	ldr	r1, [pc, #84]	; (802241c <mems_get_pressure_datas+0x80>)
 80223c6:	4620      	mov	r0, r4
 80223c8:	f003 fc52 	bl	8025c70 <sprintf>
 80223cc:	4620      	mov	r0, r4
 80223ce:	f7fc fea0 	bl	801f112 <crs_strlen>
 80223d2:	b283      	uxth	r3, r0
 80223d4:	4622      	mov	r2, r4
 80223d6:	2102      	movs	r1, #2
 80223d8:	2001      	movs	r0, #1
 80223da:	f7fc fedd 	bl	801f198 <traceIF_itmPrint>
 80223de:	4620      	mov	r0, r4
 80223e0:	f7fc fe97 	bl	801f112 <crs_strlen>
 80223e4:	b283      	uxth	r3, r0
 80223e6:	4622      	mov	r2, r4
 80223e8:	2102      	movs	r1, #2
 80223ea:	2001      	movs	r0, #1
 80223ec:	f7fc fef6 	bl	801f1dc <traceIF_uartPrint>
    pressure_info.rt_state         =  DC_SERVICE_ON;
 80223f0:	2307      	movs	r3, #7
 80223f2:	f88d 3008 	strb.w	r3, [sp, #8]
    pressure_info.pressure         =  PRESSURE_Value;
 80223f6:	682b      	ldr	r3, [r5, #0]
 80223f8:	9303      	str	r3, [sp, #12]
    dc_com_write(&dc_com_db, DC_COM_PRESSURE, (void *)&pressure_info, sizeof(pressure_info));
 80223fa:	2310      	movs	r3, #16
 80223fc:	466a      	mov	r2, sp
 80223fe:	4908      	ldr	r1, [pc, #32]	; (8022420 <mems_get_pressure_datas+0x84>)
 8022400:	8809      	ldrh	r1, [r1, #0]
 8022402:	4808      	ldr	r0, [pc, #32]	; (8022424 <mems_get_pressure_datas+0x88>)
 8022404:	f7ff fa94 	bl	8021930 <dc_com_write>
    success = 1U;
 8022408:	2001      	movs	r0, #1
}
 802240a:	b005      	add	sp, #20
 802240c:	bd30      	pop	{r4, r5, pc}
 802240e:	bf00      	nop
 8022410:	20005c94 	.word	0x20005c94
 8022414:	20005c10 	.word	0x20005c10
 8022418:	200047dc 	.word	0x200047dc
 802241c:	08035e34 	.word	0x08035e34
 8022420:	20000248 	.word	0x20000248
 8022424:	200058b0 	.word	0x200058b0

08022428 <mems_get_humidity_datas>:
    success = 1U;
  }
#elif defined (USE_STM32L475E_IOT01) || defined (USE_STM32L462E_CELL01) /* USE B-L475E-IOT1 MEMS */
  static float_t HUMIDITY_Value;    /*!< Humidity Value */
  dc_humidity_info_t        humidity_info;
  if (mems_init_status & FLAG_MEMS_HUMIDTY)
 8022428:	4b1c      	ldr	r3, [pc, #112]	; (802249c <mems_get_humidity_datas+0x74>)
 802242a:	7818      	ldrb	r0, [r3, #0]
 802242c:	f010 0008 	ands.w	r0, r0, #8
 8022430:	d100      	bne.n	8022434 <mems_get_humidity_datas+0xc>
    success = 1U;
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
  return (success);
}
 8022432:	4770      	bx	lr
{
 8022434:	b530      	push	{r4, r5, lr}
 8022436:	b085      	sub	sp, #20
    HUMIDITY_Value = BSP_HSENSOR_ReadHumidity();
 8022438:	f7df fd36 	bl	8001ea8 <BSP_HSENSOR_ReadHumidity>
 802243c:	ee10 0a10 	vmov	r0, s0
 8022440:	4d17      	ldr	r5, [pc, #92]	; (80224a0 <mems_get_humidity_datas+0x78>)
 8022442:	ed85 0a00 	vstr	s0, [r5]
    PRINT_DBG("### HUMIDITY_Value = %f\n\r", HUMIDITY_Value)
 8022446:	f7de f897 	bl	8000578 <__aeabi_f2d>
 802244a:	4602      	mov	r2, r0
 802244c:	460b      	mov	r3, r1
 802244e:	4c15      	ldr	r4, [pc, #84]	; (80224a4 <mems_get_humidity_datas+0x7c>)
 8022450:	4915      	ldr	r1, [pc, #84]	; (80224a8 <mems_get_humidity_datas+0x80>)
 8022452:	4620      	mov	r0, r4
 8022454:	f003 fc0c 	bl	8025c70 <sprintf>
 8022458:	4620      	mov	r0, r4
 802245a:	f7fc fe5a 	bl	801f112 <crs_strlen>
 802245e:	b283      	uxth	r3, r0
 8022460:	4622      	mov	r2, r4
 8022462:	2102      	movs	r1, #2
 8022464:	2001      	movs	r0, #1
 8022466:	f7fc fe97 	bl	801f198 <traceIF_itmPrint>
 802246a:	4620      	mov	r0, r4
 802246c:	f7fc fe51 	bl	801f112 <crs_strlen>
 8022470:	b283      	uxth	r3, r0
 8022472:	4622      	mov	r2, r4
 8022474:	2102      	movs	r1, #2
 8022476:	2001      	movs	r0, #1
 8022478:	f7fc feb0 	bl	801f1dc <traceIF_uartPrint>
    humidity_info.rt_state         =  DC_SERVICE_ON;
 802247c:	2307      	movs	r3, #7
 802247e:	f88d 3008 	strb.w	r3, [sp, #8]
    humidity_info.humidity         =  HUMIDITY_Value;
 8022482:	682b      	ldr	r3, [r5, #0]
 8022484:	9303      	str	r3, [sp, #12]
    dc_com_write(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8022486:	2310      	movs	r3, #16
 8022488:	466a      	mov	r2, sp
 802248a:	4908      	ldr	r1, [pc, #32]	; (80224ac <mems_get_humidity_datas+0x84>)
 802248c:	8809      	ldrh	r1, [r1, #0]
 802248e:	4808      	ldr	r0, [pc, #32]	; (80224b0 <mems_get_humidity_datas+0x88>)
 8022490:	f7ff fa4e 	bl	8021930 <dc_com_write>
    success = 1U;
 8022494:	2001      	movs	r0, #1
}
 8022496:	b005      	add	sp, #20
 8022498:	bd30      	pop	{r4, r5, pc}
 802249a:	bf00      	nop
 802249c:	20005c94 	.word	0x20005c94
 80224a0:	20005c0c 	.word	0x20005c0c
 80224a4:	200047dc 	.word	0x200047dc
 80224a8:	08035e58 	.word	0x08035e58
 80224ac:	20000244 	.word	0x20000244
 80224b0:	200058b0 	.word	0x200058b0

080224b4 <mems_get_temperature_datas>:
    success = 1U;
  }
#elif defined (USE_STM32L475E_IOT01) || defined (USE_STM32L462E_CELL01)/* USE B-L475E-IOT1 MEMS */
  static float_t TEMPERATURE_Value;    /*!< Temperature Value */
  dc_temperature_info_t     temperature_info;
  if (mems_init_status & FLAG_MEMS_TEMPERATURE)
 80224b4:	4b1c      	ldr	r3, [pc, #112]	; (8022528 <mems_get_temperature_datas+0x74>)
 80224b6:	7818      	ldrb	r0, [r3, #0]
 80224b8:	f010 0010 	ands.w	r0, r0, #16
 80224bc:	d100      	bne.n	80224c0 <mems_get_temperature_datas+0xc>
    success = 1U;
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
  return (success);
}
 80224be:	4770      	bx	lr
{
 80224c0:	b530      	push	{r4, r5, lr}
 80224c2:	b085      	sub	sp, #20
    TEMPERATURE_Value = BSP_TSENSOR_ReadTemp();
 80224c4:	f7df fd2c 	bl	8001f20 <BSP_TSENSOR_ReadTemp>
 80224c8:	ee10 0a10 	vmov	r0, s0
 80224cc:	4d17      	ldr	r5, [pc, #92]	; (802252c <mems_get_temperature_datas+0x78>)
 80224ce:	ed85 0a00 	vstr	s0, [r5]
    PRINT_DBG("### TEMPERATURE_Value = %f\n\r", TEMPERATURE_Value)
 80224d2:	f7de f851 	bl	8000578 <__aeabi_f2d>
 80224d6:	4602      	mov	r2, r0
 80224d8:	460b      	mov	r3, r1
 80224da:	4c15      	ldr	r4, [pc, #84]	; (8022530 <mems_get_temperature_datas+0x7c>)
 80224dc:	4915      	ldr	r1, [pc, #84]	; (8022534 <mems_get_temperature_datas+0x80>)
 80224de:	4620      	mov	r0, r4
 80224e0:	f003 fbc6 	bl	8025c70 <sprintf>
 80224e4:	4620      	mov	r0, r4
 80224e6:	f7fc fe14 	bl	801f112 <crs_strlen>
 80224ea:	b283      	uxth	r3, r0
 80224ec:	4622      	mov	r2, r4
 80224ee:	2102      	movs	r1, #2
 80224f0:	2001      	movs	r0, #1
 80224f2:	f7fc fe51 	bl	801f198 <traceIF_itmPrint>
 80224f6:	4620      	mov	r0, r4
 80224f8:	f7fc fe0b 	bl	801f112 <crs_strlen>
 80224fc:	b283      	uxth	r3, r0
 80224fe:	4622      	mov	r2, r4
 8022500:	2102      	movs	r1, #2
 8022502:	2001      	movs	r0, #1
 8022504:	f7fc fe6a 	bl	801f1dc <traceIF_uartPrint>
    temperature_info.rt_state         =  DC_SERVICE_ON;
 8022508:	2307      	movs	r3, #7
 802250a:	f88d 3008 	strb.w	r3, [sp, #8]
    temperature_info.temperature      =  TEMPERATURE_Value;
 802250e:	682b      	ldr	r3, [r5, #0]
 8022510:	9303      	str	r3, [sp, #12]
    dc_com_write(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8022512:	2310      	movs	r3, #16
 8022514:	466a      	mov	r2, sp
 8022516:	4908      	ldr	r1, [pc, #32]	; (8022538 <mems_get_temperature_datas+0x84>)
 8022518:	8809      	ldrh	r1, [r1, #0]
 802251a:	4808      	ldr	r0, [pc, #32]	; (802253c <mems_get_temperature_datas+0x88>)
 802251c:	f7ff fa08 	bl	8021930 <dc_com_write>
    success = 1U;
 8022520:	2001      	movs	r0, #1
}
 8022522:	b005      	add	sp, #20
 8022524:	bd30      	pop	{r4, r5, pc}
 8022526:	bf00      	nop
 8022528:	20005c94 	.word	0x20005c94
 802252c:	20005c14 	.word	0x20005c14
 8022530:	200047dc 	.word	0x200047dc
 8022534:	08035e7c 	.word	0x08035e7c
 8022538:	2000024a 	.word	0x2000024a
 802253c:	200058b0 	.word	0x200058b0

08022540 <StartMemsDclibTask>:
{
 8022540:	b508      	push	{r3, lr}
  mems_init_sensors();
 8022542:	f7ff ff0f 	bl	8022364 <mems_init_sensors>
  (void)rtosalDelay(1000U);
 8022546:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802254a:	f7fc fd3a 	bl	801efc2 <rtosalDelay>
 802254e:	e009      	b.n	8022564 <StartMemsDclibTask+0x24>
      if (mems_get_pressure_datas() != 1U)
 8022550:	f7ff ff24 	bl	802239c <mems_get_pressure_datas>
      if (mems_get_humidity_datas() != 1U)
 8022554:	f7ff ff68 	bl	8022428 <mems_get_humidity_datas>
      if (mems_get_temperature_datas() != 1U)
 8022558:	f7ff ffac 	bl	80224b4 <mems_get_temperature_datas>
    (void)rtosalDelay(mems_polling_period);
 802255c:	4b04      	ldr	r3, [pc, #16]	; (8022570 <StartMemsDclibTask+0x30>)
 802255e:	6818      	ldr	r0, [r3, #0]
 8022560:	f7fc fd2f 	bl	801efc2 <rtosalDelay>
    if (mems_state == 0U)
 8022564:	4b03      	ldr	r3, [pc, #12]	; (8022574 <StartMemsDclibTask+0x34>)
 8022566:	681b      	ldr	r3, [r3, #0]
 8022568:	2b00      	cmp	r3, #0
 802256a:	d0f1      	beq.n	8022550 <StartMemsDclibTask+0x10>
 802256c:	e7f6      	b.n	802255c <StartMemsDclibTask+0x1c>
 802256e:	bf00      	nop
 8022570:	20005c98 	.word	0x20005c98
 8022574:	20005c9c 	.word	0x20005c9c

08022578 <mems_cmd_help>:
{
 8022578:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help(mems_cmd_label);
 802257a:	4d7c      	ldr	r5, [pc, #496]	; (802276c <mems_cmd_help+0x1f4>)
 802257c:	4628      	mov	r0, r5
 802257e:	f7ff fe67 	bl	8022250 <CMD_print_help>
  PRINT_FORCE("%s help", mems_cmd_label);
 8022582:	4c7b      	ldr	r4, [pc, #492]	; (8022770 <mems_cmd_help+0x1f8>)
 8022584:	462a      	mov	r2, r5
 8022586:	497b      	ldr	r1, [pc, #492]	; (8022774 <mems_cmd_help+0x1fc>)
 8022588:	4620      	mov	r0, r4
 802258a:	f003 fb71 	bl	8025c70 <sprintf>
 802258e:	4620      	mov	r0, r4
 8022590:	f7fc fdbf 	bl	801f112 <crs_strlen>
 8022594:	b283      	uxth	r3, r0
 8022596:	4622      	mov	r2, r4
 8022598:	2101      	movs	r1, #1
 802259a:	4608      	mov	r0, r1
 802259c:	f7fc fdfc 	bl	801f198 <traceIF_itmPrint>
 80225a0:	4620      	mov	r0, r4
 80225a2:	f7fc fdb6 	bl	801f112 <crs_strlen>
 80225a6:	b282      	uxth	r2, r0
 80225a8:	4621      	mov	r1, r4
 80225aa:	2001      	movs	r0, #1
 80225ac:	f7fc fe2e 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s state (state of mems software component)", mems_cmd_label);
 80225b0:	462a      	mov	r2, r5
 80225b2:	4971      	ldr	r1, [pc, #452]	; (8022778 <mems_cmd_help+0x200>)
 80225b4:	4620      	mov	r0, r4
 80225b6:	f003 fb5b 	bl	8025c70 <sprintf>
 80225ba:	4620      	mov	r0, r4
 80225bc:	f7fc fda9 	bl	801f112 <crs_strlen>
 80225c0:	b283      	uxth	r3, r0
 80225c2:	4622      	mov	r2, r4
 80225c4:	2101      	movs	r1, #1
 80225c6:	4608      	mov	r0, r1
 80225c8:	f7fc fde6 	bl	801f198 <traceIF_itmPrint>
 80225cc:	4620      	mov	r0, r4
 80225ce:	f7fc fda0 	bl	801f112 <crs_strlen>
 80225d2:	b282      	uxth	r2, r0
 80225d4:	4621      	mov	r1, r4
 80225d6:	2001      	movs	r0, #1
 80225d8:	f7fc fe18 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s disable (disable mems process)", mems_cmd_label);
 80225dc:	462a      	mov	r2, r5
 80225de:	4967      	ldr	r1, [pc, #412]	; (802277c <mems_cmd_help+0x204>)
 80225e0:	4620      	mov	r0, r4
 80225e2:	f003 fb45 	bl	8025c70 <sprintf>
 80225e6:	4620      	mov	r0, r4
 80225e8:	f7fc fd93 	bl	801f112 <crs_strlen>
 80225ec:	b283      	uxth	r3, r0
 80225ee:	4622      	mov	r2, r4
 80225f0:	2101      	movs	r1, #1
 80225f2:	4608      	mov	r0, r1
 80225f4:	f7fc fdd0 	bl	801f198 <traceIF_itmPrint>
 80225f8:	4620      	mov	r0, r4
 80225fa:	f7fc fd8a 	bl	801f112 <crs_strlen>
 80225fe:	b282      	uxth	r2, r0
 8022600:	4621      	mov	r1, r4
 8022602:	2001      	movs	r0, #1
 8022604:	f7fc fe02 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s enable (enable mems process)", mems_cmd_label);
 8022608:	462a      	mov	r2, r5
 802260a:	495d      	ldr	r1, [pc, #372]	; (8022780 <mems_cmd_help+0x208>)
 802260c:	4620      	mov	r0, r4
 802260e:	f003 fb2f 	bl	8025c70 <sprintf>
 8022612:	4620      	mov	r0, r4
 8022614:	f7fc fd7d 	bl	801f112 <crs_strlen>
 8022618:	b283      	uxth	r3, r0
 802261a:	4622      	mov	r2, r4
 802261c:	2101      	movs	r1, #1
 802261e:	4608      	mov	r0, r1
 8022620:	f7fc fdba 	bl	801f198 <traceIF_itmPrint>
 8022624:	4620      	mov	r0, r4
 8022626:	f7fc fd74 	bl	801f112 <crs_strlen>
 802262a:	b282      	uxth	r2, r0
 802262c:	4621      	mov	r1, r4
 802262e:	2001      	movs	r0, #1
 8022630:	f7fc fdec 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s period [<ms>] (set/get mems process period)", mems_cmd_label);
 8022634:	462a      	mov	r2, r5
 8022636:	4953      	ldr	r1, [pc, #332]	; (8022784 <mems_cmd_help+0x20c>)
 8022638:	4620      	mov	r0, r4
 802263a:	f003 fb19 	bl	8025c70 <sprintf>
 802263e:	4620      	mov	r0, r4
 8022640:	f7fc fd67 	bl	801f112 <crs_strlen>
 8022644:	b283      	uxth	r3, r0
 8022646:	4622      	mov	r2, r4
 8022648:	2101      	movs	r1, #1
 802264a:	4608      	mov	r0, r1
 802264c:	f7fc fda4 	bl	801f198 <traceIF_itmPrint>
 8022650:	4620      	mov	r0, r4
 8022652:	f7fc fd5e 	bl	801f112 <crs_strlen>
 8022656:	b282      	uxth	r2, r0
 8022658:	4621      	mov	r1, r4
 802265a:	2001      	movs	r0, #1
 802265c:	f7fc fdd6 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s pressure (get current pressure value)", mems_cmd_label);
 8022660:	462a      	mov	r2, r5
 8022662:	4949      	ldr	r1, [pc, #292]	; (8022788 <mems_cmd_help+0x210>)
 8022664:	4620      	mov	r0, r4
 8022666:	f003 fb03 	bl	8025c70 <sprintf>
 802266a:	4620      	mov	r0, r4
 802266c:	f7fc fd51 	bl	801f112 <crs_strlen>
 8022670:	b283      	uxth	r3, r0
 8022672:	4622      	mov	r2, r4
 8022674:	2101      	movs	r1, #1
 8022676:	4608      	mov	r0, r1
 8022678:	f7fc fd8e 	bl	801f198 <traceIF_itmPrint>
 802267c:	4620      	mov	r0, r4
 802267e:	f7fc fd48 	bl	801f112 <crs_strlen>
 8022682:	b282      	uxth	r2, r0
 8022684:	4621      	mov	r1, r4
 8022686:	2001      	movs	r0, #1
 8022688:	f7fc fdc0 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s pressure <ppp>  (set pressure value and disable mems process)", mems_cmd_label);
 802268c:	462a      	mov	r2, r5
 802268e:	493f      	ldr	r1, [pc, #252]	; (802278c <mems_cmd_help+0x214>)
 8022690:	4620      	mov	r0, r4
 8022692:	f003 faed 	bl	8025c70 <sprintf>
 8022696:	4620      	mov	r0, r4
 8022698:	f7fc fd3b 	bl	801f112 <crs_strlen>
 802269c:	b283      	uxth	r3, r0
 802269e:	4622      	mov	r2, r4
 80226a0:	2101      	movs	r1, #1
 80226a2:	4608      	mov	r0, r1
 80226a4:	f7fc fd78 	bl	801f198 <traceIF_itmPrint>
 80226a8:	4620      	mov	r0, r4
 80226aa:	f7fc fd32 	bl	801f112 <crs_strlen>
 80226ae:	b282      	uxth	r2, r0
 80226b0:	4621      	mov	r1, r4
 80226b2:	2001      	movs	r0, #1
 80226b4:	f7fc fdaa 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s temperature (get current temperature value)", mems_cmd_label);
 80226b8:	462a      	mov	r2, r5
 80226ba:	4935      	ldr	r1, [pc, #212]	; (8022790 <mems_cmd_help+0x218>)
 80226bc:	4620      	mov	r0, r4
 80226be:	f003 fad7 	bl	8025c70 <sprintf>
 80226c2:	4620      	mov	r0, r4
 80226c4:	f7fc fd25 	bl	801f112 <crs_strlen>
 80226c8:	b283      	uxth	r3, r0
 80226ca:	4622      	mov	r2, r4
 80226cc:	2101      	movs	r1, #1
 80226ce:	4608      	mov	r0, r1
 80226d0:	f7fc fd62 	bl	801f198 <traceIF_itmPrint>
 80226d4:	4620      	mov	r0, r4
 80226d6:	f7fc fd1c 	bl	801f112 <crs_strlen>
 80226da:	b282      	uxth	r2, r0
 80226dc:	4621      	mov	r1, r4
 80226de:	2001      	movs	r0, #1
 80226e0:	f7fc fd94 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s temperature <ttt> (set temperature value and disable mems process)", mems_cmd_label);
 80226e4:	462a      	mov	r2, r5
 80226e6:	492b      	ldr	r1, [pc, #172]	; (8022794 <mems_cmd_help+0x21c>)
 80226e8:	4620      	mov	r0, r4
 80226ea:	f003 fac1 	bl	8025c70 <sprintf>
 80226ee:	4620      	mov	r0, r4
 80226f0:	f7fc fd0f 	bl	801f112 <crs_strlen>
 80226f4:	b283      	uxth	r3, r0
 80226f6:	4622      	mov	r2, r4
 80226f8:	2101      	movs	r1, #1
 80226fa:	4608      	mov	r0, r1
 80226fc:	f7fc fd4c 	bl	801f198 <traceIF_itmPrint>
 8022700:	4620      	mov	r0, r4
 8022702:	f7fc fd06 	bl	801f112 <crs_strlen>
 8022706:	b282      	uxth	r2, r0
 8022708:	4621      	mov	r1, r4
 802270a:	2001      	movs	r0, #1
 802270c:	f7fc fd7e 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s humidity (get current humidity value)", mems_cmd_label);
 8022710:	462a      	mov	r2, r5
 8022712:	4921      	ldr	r1, [pc, #132]	; (8022798 <mems_cmd_help+0x220>)
 8022714:	4620      	mov	r0, r4
 8022716:	f003 faab 	bl	8025c70 <sprintf>
 802271a:	4620      	mov	r0, r4
 802271c:	f7fc fcf9 	bl	801f112 <crs_strlen>
 8022720:	b283      	uxth	r3, r0
 8022722:	4622      	mov	r2, r4
 8022724:	2101      	movs	r1, #1
 8022726:	4608      	mov	r0, r1
 8022728:	f7fc fd36 	bl	801f198 <traceIF_itmPrint>
 802272c:	4620      	mov	r0, r4
 802272e:	f7fc fcf0 	bl	801f112 <crs_strlen>
 8022732:	b282      	uxth	r2, r0
 8022734:	4621      	mov	r1, r4
 8022736:	2001      	movs	r0, #1
 8022738:	f7fc fd68 	bl	801f20c <traceIF_uartPrintForce>
  PRINT_FORCE("%s humidity <hhh> (set humidity value and disable mems process)", mems_cmd_label);
 802273c:	462a      	mov	r2, r5
 802273e:	4917      	ldr	r1, [pc, #92]	; (802279c <mems_cmd_help+0x224>)
 8022740:	4620      	mov	r0, r4
 8022742:	f003 fa95 	bl	8025c70 <sprintf>
 8022746:	4620      	mov	r0, r4
 8022748:	f7fc fce3 	bl	801f112 <crs_strlen>
 802274c:	b283      	uxth	r3, r0
 802274e:	4622      	mov	r2, r4
 8022750:	2101      	movs	r1, #1
 8022752:	4608      	mov	r0, r1
 8022754:	f7fc fd20 	bl	801f198 <traceIF_itmPrint>
 8022758:	4620      	mov	r0, r4
 802275a:	f7fc fcda 	bl	801f112 <crs_strlen>
 802275e:	b282      	uxth	r2, r0
 8022760:	4621      	mov	r1, r4
 8022762:	2001      	movs	r0, #1
 8022764:	f7fc fd52 	bl	801f20c <traceIF_uartPrintForce>
}
 8022768:	bd38      	pop	{r3, r4, r5, pc}
 802276a:	bf00      	nop
 802276c:	08035ea0 	.word	0x08035ea0
 8022770:	200047dc 	.word	0x200047dc
 8022774:	0803283c 	.word	0x0803283c
 8022778:	08035ea8 	.word	0x08035ea8
 802277c:	08035ed8 	.word	0x08035ed8
 8022780:	08035efc 	.word	0x08035efc
 8022784:	08035f20 	.word	0x08035f20
 8022788:	08035f54 	.word	0x08035f54
 802278c:	08035f80 	.word	0x08035f80
 8022790:	08035fc4 	.word	0x08035fc4
 8022794:	08035ff8 	.word	0x08035ff8
 8022798:	08036040 	.word	0x08036040
 802279c:	0803606c 	.word	0x0803606c

080227a0 <mems_cmd>:
{
 80227a0:	b570      	push	{r4, r5, r6, lr}
 80227a2:	b096      	sub	sp, #88	; 0x58
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 80227a4:	49b1      	ldr	r1, [pc, #708]	; (8022a6c <mems_cmd+0x2cc>)
 80227a6:	f003 faf1 	bl	8025d8c <strtok>
  if (cmd_p == NULL)
 80227aa:	b160      	cbz	r0, 80227c6 <mems_cmd+0x26>
 80227ac:	4605      	mov	r5, r0
  else if (memcmp((CRC_CHAR_t *)cmd_p, (CRC_CHAR_t *)mems_cmd_label, crs_strlen(cmd_p)) == 0)
 80227ae:	f7fc fcb0 	bl	801f112 <crs_strlen>
 80227b2:	4602      	mov	r2, r0
 80227b4:	49ae      	ldr	r1, [pc, #696]	; (8022a70 <mems_cmd+0x2d0>)
 80227b6:	4628      	mov	r0, r5
 80227b8:	f003 fabd 	bl	8025d36 <memcmp>
 80227bc:	b1f0      	cbz	r0, 80227fc <mems_cmd+0x5c>
    __NOP();
 80227be:	bf00      	nop
}
 80227c0:	2000      	movs	r0, #0
 80227c2:	b016      	add	sp, #88	; 0x58
 80227c4:	bd70      	pop	{r4, r5, r6, pc}
    PRINT_FORCE("bad command\n\r");
 80227c6:	4cab      	ldr	r4, [pc, #684]	; (8022a74 <mems_cmd+0x2d4>)
 80227c8:	4dab      	ldr	r5, [pc, #684]	; (8022a78 <mems_cmd+0x2d8>)
 80227ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80227cc:	6020      	str	r0, [r4, #0]
 80227ce:	6061      	str	r1, [r4, #4]
 80227d0:	60a2      	str	r2, [r4, #8]
 80227d2:	60e3      	str	r3, [r4, #12]
 80227d4:	4620      	mov	r0, r4
 80227d6:	f7fc fc9c 	bl	801f112 <crs_strlen>
 80227da:	b283      	uxth	r3, r0
 80227dc:	4622      	mov	r2, r4
 80227de:	2101      	movs	r1, #1
 80227e0:	4608      	mov	r0, r1
 80227e2:	f7fc fcd9 	bl	801f198 <traceIF_itmPrint>
 80227e6:	4620      	mov	r0, r4
 80227e8:	f7fc fc93 	bl	801f112 <crs_strlen>
 80227ec:	b282      	uxth	r2, r0
 80227ee:	4621      	mov	r1, r4
 80227f0:	2001      	movs	r0, #1
 80227f2:	f7fc fd0b 	bl	801f20c <traceIF_uartPrintForce>
    mems_cmd_help();
 80227f6:	f7ff febf 	bl	8022578 <mems_cmd_help>
 80227fa:	e7e1      	b.n	80227c0 <mems_cmd+0x20>
    for (argc = 0U ; argc < 10U ; argc++)
 80227fc:	2400      	movs	r4, #0
 80227fe:	2c09      	cmp	r4, #9
 8022800:	d80b      	bhi.n	802281a <mems_cmd+0x7a>
      argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 8022802:	499a      	ldr	r1, [pc, #616]	; (8022a6c <mems_cmd+0x2cc>)
 8022804:	2000      	movs	r0, #0
 8022806:	f003 fac1 	bl	8025d8c <strtok>
 802280a:	ab16      	add	r3, sp, #88	; 0x58
 802280c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8022810:	f843 0c28 	str.w	r0, [r3, #-40]
      if (argv_p[argc] == NULL)
 8022814:	b108      	cbz	r0, 802281a <mems_cmd+0x7a>
    for (argc = 0U ; argc < 10U ; argc++)
 8022816:	3401      	adds	r4, #1
 8022818:	e7f1      	b.n	80227fe <mems_cmd+0x5e>
    if (argc == 0U)
 802281a:	b914      	cbnz	r4, 8022822 <mems_cmd+0x82>
      mems_cmd_help();
 802281c:	f7ff feac 	bl	8022578 <mems_cmd_help>
 8022820:	e7ce      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "help", crs_strlen(argv_p[0])) == 0)
 8022822:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8022824:	4630      	mov	r0, r6
 8022826:	f7fc fc74 	bl	801f112 <crs_strlen>
 802282a:	4602      	mov	r2, r0
 802282c:	4993      	ldr	r1, [pc, #588]	; (8022a7c <mems_cmd+0x2dc>)
 802282e:	4630      	mov	r0, r6
 8022830:	f003 fa81 	bl	8025d36 <memcmp>
 8022834:	b910      	cbnz	r0, 802283c <mems_cmd+0x9c>
      mems_cmd_help();
 8022836:	f7ff fe9f 	bl	8022578 <mems_cmd_help>
 802283a:	e7c1      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "state", crs_strlen(argv_p[0])) == 0)
 802283c:	4630      	mov	r0, r6
 802283e:	f7fc fc68 	bl	801f112 <crs_strlen>
 8022842:	4602      	mov	r2, r0
 8022844:	498e      	ldr	r1, [pc, #568]	; (8022a80 <mems_cmd+0x2e0>)
 8022846:	4630      	mov	r0, r6
 8022848:	f003 fa75 	bl	8025d36 <memcmp>
 802284c:	2800      	cmp	r0, #0
 802284e:	d14f      	bne.n	80228f0 <mems_cmd+0x150>
      if (mems_state == 1U)
 8022850:	4b8c      	ldr	r3, [pc, #560]	; (8022a84 <mems_cmd+0x2e4>)
 8022852:	681b      	ldr	r3, [r3, #0]
 8022854:	2b01      	cmp	r3, #1
 8022856:	d032      	beq.n	80228be <mems_cmd+0x11e>
        PRINT_FORCE("mems enabled");
 8022858:	4c86      	ldr	r4, [pc, #536]	; (8022a74 <mems_cmd+0x2d4>)
 802285a:	4b8b      	ldr	r3, [pc, #556]	; (8022a88 <mems_cmd+0x2e8>)
 802285c:	cb07      	ldmia	r3!, {r0, r1, r2}
 802285e:	6020      	str	r0, [r4, #0]
 8022860:	6061      	str	r1, [r4, #4]
 8022862:	60a2      	str	r2, [r4, #8]
 8022864:	881a      	ldrh	r2, [r3, #0]
 8022866:	789b      	ldrb	r3, [r3, #2]
 8022868:	81a2      	strh	r2, [r4, #12]
 802286a:	73a3      	strb	r3, [r4, #14]
 802286c:	4620      	mov	r0, r4
 802286e:	f7fc fc50 	bl	801f112 <crs_strlen>
 8022872:	b283      	uxth	r3, r0
 8022874:	4622      	mov	r2, r4
 8022876:	2101      	movs	r1, #1
 8022878:	4608      	mov	r0, r1
 802287a:	f7fc fc8d 	bl	801f198 <traceIF_itmPrint>
 802287e:	4620      	mov	r0, r4
 8022880:	f7fc fc47 	bl	801f112 <crs_strlen>
 8022884:	b282      	uxth	r2, r0
 8022886:	4621      	mov	r1, r4
 8022888:	2001      	movs	r0, #1
 802288a:	f7fc fcbf 	bl	801f20c <traceIF_uartPrintForce>
        PRINT_FORCE("polling period: %ld", mems_polling_period);
 802288e:	4b7f      	ldr	r3, [pc, #508]	; (8022a8c <mems_cmd+0x2ec>)
 8022890:	681a      	ldr	r2, [r3, #0]
 8022892:	497f      	ldr	r1, [pc, #508]	; (8022a90 <mems_cmd+0x2f0>)
 8022894:	4620      	mov	r0, r4
 8022896:	f003 f9eb 	bl	8025c70 <sprintf>
 802289a:	4620      	mov	r0, r4
 802289c:	f7fc fc39 	bl	801f112 <crs_strlen>
 80228a0:	b283      	uxth	r3, r0
 80228a2:	4622      	mov	r2, r4
 80228a4:	2101      	movs	r1, #1
 80228a6:	4608      	mov	r0, r1
 80228a8:	f7fc fc76 	bl	801f198 <traceIF_itmPrint>
 80228ac:	4620      	mov	r0, r4
 80228ae:	f7fc fc30 	bl	801f112 <crs_strlen>
 80228b2:	b282      	uxth	r2, r0
 80228b4:	4621      	mov	r1, r4
 80228b6:	2001      	movs	r0, #1
 80228b8:	f7fc fca8 	bl	801f20c <traceIF_uartPrintForce>
 80228bc:	e780      	b.n	80227c0 <mems_cmd+0x20>
        PRINT_FORCE("mems disabled");
 80228be:	4c6d      	ldr	r4, [pc, #436]	; (8022a74 <mems_cmd+0x2d4>)
 80228c0:	4d74      	ldr	r5, [pc, #464]	; (8022a94 <mems_cmd+0x2f4>)
 80228c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80228c4:	6020      	str	r0, [r4, #0]
 80228c6:	6061      	str	r1, [r4, #4]
 80228c8:	60a2      	str	r2, [r4, #8]
 80228ca:	60e3      	str	r3, [r4, #12]
 80228cc:	4620      	mov	r0, r4
 80228ce:	f7fc fc20 	bl	801f112 <crs_strlen>
 80228d2:	b283      	uxth	r3, r0
 80228d4:	4622      	mov	r2, r4
 80228d6:	2101      	movs	r1, #1
 80228d8:	4608      	mov	r0, r1
 80228da:	f7fc fc5d 	bl	801f198 <traceIF_itmPrint>
 80228de:	4620      	mov	r0, r4
 80228e0:	f7fc fc17 	bl	801f112 <crs_strlen>
 80228e4:	b282      	uxth	r2, r0
 80228e6:	4621      	mov	r1, r4
 80228e8:	2001      	movs	r0, #1
 80228ea:	f7fc fc8f 	bl	801f20c <traceIF_uartPrintForce>
 80228ee:	e767      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "enable", crs_strlen(argv_p[0])) == 0)
 80228f0:	4630      	mov	r0, r6
 80228f2:	f7fc fc0e 	bl	801f112 <crs_strlen>
 80228f6:	4602      	mov	r2, r0
 80228f8:	4967      	ldr	r1, [pc, #412]	; (8022a98 <mems_cmd+0x2f8>)
 80228fa:	4630      	mov	r0, r6
 80228fc:	f003 fa1b 	bl	8025d36 <memcmp>
 8022900:	b9f0      	cbnz	r0, 8022940 <mems_cmd+0x1a0>
      mems_state = 0U;
 8022902:	4b60      	ldr	r3, [pc, #384]	; (8022a84 <mems_cmd+0x2e4>)
 8022904:	2200      	movs	r2, #0
 8022906:	601a      	str	r2, [r3, #0]
      PRINT_FORCE("mems enabled");
 8022908:	4c5a      	ldr	r4, [pc, #360]	; (8022a74 <mems_cmd+0x2d4>)
 802290a:	4b5f      	ldr	r3, [pc, #380]	; (8022a88 <mems_cmd+0x2e8>)
 802290c:	cb07      	ldmia	r3!, {r0, r1, r2}
 802290e:	6020      	str	r0, [r4, #0]
 8022910:	6061      	str	r1, [r4, #4]
 8022912:	60a2      	str	r2, [r4, #8]
 8022914:	881a      	ldrh	r2, [r3, #0]
 8022916:	789b      	ldrb	r3, [r3, #2]
 8022918:	81a2      	strh	r2, [r4, #12]
 802291a:	73a3      	strb	r3, [r4, #14]
 802291c:	4620      	mov	r0, r4
 802291e:	f7fc fbf8 	bl	801f112 <crs_strlen>
 8022922:	b283      	uxth	r3, r0
 8022924:	4622      	mov	r2, r4
 8022926:	2101      	movs	r1, #1
 8022928:	4608      	mov	r0, r1
 802292a:	f7fc fc35 	bl	801f198 <traceIF_itmPrint>
 802292e:	4620      	mov	r0, r4
 8022930:	f7fc fbef 	bl	801f112 <crs_strlen>
 8022934:	b282      	uxth	r2, r0
 8022936:	4621      	mov	r1, r4
 8022938:	2001      	movs	r0, #1
 802293a:	f7fc fc67 	bl	801f20c <traceIF_uartPrintForce>
 802293e:	e73f      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "disable", crs_strlen(argv_p[0])) == 0)
 8022940:	4630      	mov	r0, r6
 8022942:	f7fc fbe6 	bl	801f112 <crs_strlen>
 8022946:	4602      	mov	r2, r0
 8022948:	4954      	ldr	r1, [pc, #336]	; (8022a9c <mems_cmd+0x2fc>)
 802294a:	4630      	mov	r0, r6
 802294c:	f003 f9f3 	bl	8025d36 <memcmp>
 8022950:	b9d8      	cbnz	r0, 802298a <mems_cmd+0x1ea>
      mems_state = 1U;
 8022952:	2601      	movs	r6, #1
 8022954:	4b4b      	ldr	r3, [pc, #300]	; (8022a84 <mems_cmd+0x2e4>)
 8022956:	601e      	str	r6, [r3, #0]
      PRINT_FORCE("mems disabled");
 8022958:	4c46      	ldr	r4, [pc, #280]	; (8022a74 <mems_cmd+0x2d4>)
 802295a:	4d4e      	ldr	r5, [pc, #312]	; (8022a94 <mems_cmd+0x2f4>)
 802295c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802295e:	6020      	str	r0, [r4, #0]
 8022960:	6061      	str	r1, [r4, #4]
 8022962:	60a2      	str	r2, [r4, #8]
 8022964:	60e3      	str	r3, [r4, #12]
 8022966:	4620      	mov	r0, r4
 8022968:	f7fc fbd3 	bl	801f112 <crs_strlen>
 802296c:	b283      	uxth	r3, r0
 802296e:	4622      	mov	r2, r4
 8022970:	4631      	mov	r1, r6
 8022972:	4630      	mov	r0, r6
 8022974:	f7fc fc10 	bl	801f198 <traceIF_itmPrint>
 8022978:	4620      	mov	r0, r4
 802297a:	f7fc fbca 	bl	801f112 <crs_strlen>
 802297e:	b282      	uxth	r2, r0
 8022980:	4621      	mov	r1, r4
 8022982:	4630      	mov	r0, r6
 8022984:	f7fc fc42 	bl	801f20c <traceIF_uartPrintForce>
 8022988:	e71a      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "period", crs_strlen(argv_p[0])) == 0)
 802298a:	4630      	mov	r0, r6
 802298c:	f7fc fbc1 	bl	801f112 <crs_strlen>
 8022990:	4602      	mov	r2, r0
 8022992:	4943      	ldr	r1, [pc, #268]	; (8022aa0 <mems_cmd+0x300>)
 8022994:	4630      	mov	r0, r6
 8022996:	f003 f9ce 	bl	8025d36 <memcmp>
 802299a:	bb00      	cbnz	r0, 80229de <mems_cmd+0x23e>
      if (argc == 2U)
 802299c:	2c02      	cmp	r4, #2
 802299e:	d018      	beq.n	80229d2 <mems_cmd+0x232>
        PRINT_FORCE("mems polling period: %ld", mems_polling_period);
 80229a0:	4c34      	ldr	r4, [pc, #208]	; (8022a74 <mems_cmd+0x2d4>)
 80229a2:	4b3a      	ldr	r3, [pc, #232]	; (8022a8c <mems_cmd+0x2ec>)
 80229a4:	681a      	ldr	r2, [r3, #0]
 80229a6:	493f      	ldr	r1, [pc, #252]	; (8022aa4 <mems_cmd+0x304>)
 80229a8:	4620      	mov	r0, r4
 80229aa:	f003 f961 	bl	8025c70 <sprintf>
 80229ae:	4620      	mov	r0, r4
 80229b0:	f7fc fbaf 	bl	801f112 <crs_strlen>
 80229b4:	b283      	uxth	r3, r0
 80229b6:	4622      	mov	r2, r4
 80229b8:	2101      	movs	r1, #1
 80229ba:	4608      	mov	r0, r1
 80229bc:	f7fc fbec 	bl	801f198 <traceIF_itmPrint>
 80229c0:	4620      	mov	r0, r4
 80229c2:	f7fc fba6 	bl	801f112 <crs_strlen>
 80229c6:	b282      	uxth	r2, r0
 80229c8:	4621      	mov	r1, r4
 80229ca:	2001      	movs	r0, #1
 80229cc:	f7fc fc1e 	bl	801f20c <traceIF_uartPrintForce>
 80229d0:	e6f6      	b.n	80227c0 <mems_cmd+0x20>
        mems_polling_period = (uint32_t)crs_atoi(argv_p[1]);
 80229d2:	980d      	ldr	r0, [sp, #52]	; 0x34
 80229d4:	f7fc fb58 	bl	801f088 <crs_atoi>
 80229d8:	4b2c      	ldr	r3, [pc, #176]	; (8022a8c <mems_cmd+0x2ec>)
 80229da:	6018      	str	r0, [r3, #0]
 80229dc:	e6f0      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "pressure", crs_strlen(argv_p[0])) == 0)
 80229de:	4630      	mov	r0, r6
 80229e0:	f7fc fb97 	bl	801f112 <crs_strlen>
 80229e4:	4602      	mov	r2, r0
 80229e6:	4930      	ldr	r1, [pc, #192]	; (8022aa8 <mems_cmd+0x308>)
 80229e8:	4630      	mov	r0, r6
 80229ea:	f003 f9a4 	bl	8025d36 <memcmp>
 80229ee:	2800      	cmp	r0, #0
 80229f0:	d17e      	bne.n	8022af0 <mems_cmd+0x350>
      if (argc == 2U)
 80229f2:	2c02      	cmp	r4, #2
 80229f4:	d022      	beq.n	8022a3c <mems_cmd+0x29c>
      (void)dc_com_read(&dc_com_db, DC_COM_PRESSURE, (void *)&pressure_info, sizeof(pressure_info));
 80229f6:	2310      	movs	r3, #16
 80229f8:	aa08      	add	r2, sp, #32
 80229fa:	492c      	ldr	r1, [pc, #176]	; (8022aac <mems_cmd+0x30c>)
 80229fc:	8809      	ldrh	r1, [r1, #0]
 80229fe:	482c      	ldr	r0, [pc, #176]	; (8022ab0 <mems_cmd+0x310>)
 8022a00:	f7fe ffe2 	bl	80219c8 <dc_com_read>
      if (pressure_info.rt_state ==  DC_SERVICE_ON)
 8022a04:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8022a08:	2b07      	cmp	r3, #7
 8022a0a:	d055      	beq.n	8022ab8 <mems_cmd+0x318>
        PRINT_FORCE("%s invalid", argv_p[0]);
 8022a0c:	4c19      	ldr	r4, [pc, #100]	; (8022a74 <mems_cmd+0x2d4>)
 8022a0e:	4632      	mov	r2, r6
 8022a10:	4928      	ldr	r1, [pc, #160]	; (8022ab4 <mems_cmd+0x314>)
 8022a12:	4620      	mov	r0, r4
 8022a14:	f003 f92c 	bl	8025c70 <sprintf>
 8022a18:	4620      	mov	r0, r4
 8022a1a:	f7fc fb7a 	bl	801f112 <crs_strlen>
 8022a1e:	b283      	uxth	r3, r0
 8022a20:	4622      	mov	r2, r4
 8022a22:	2101      	movs	r1, #1
 8022a24:	4608      	mov	r0, r1
 8022a26:	f7fc fbb7 	bl	801f198 <traceIF_itmPrint>
 8022a2a:	4620      	mov	r0, r4
 8022a2c:	f7fc fb71 	bl	801f112 <crs_strlen>
 8022a30:	b282      	uxth	r2, r0
 8022a32:	4621      	mov	r1, r4
 8022a34:	2001      	movs	r0, #1
 8022a36:	f7fc fbe9 	bl	801f20c <traceIF_uartPrintForce>
 8022a3a:	e6c1      	b.n	80227c0 <mems_cmd+0x20>
        PRESSURE_Value = (float_t)crs_atoi(argv_p[1]);
 8022a3c:	980d      	ldr	r0, [sp, #52]	; 0x34
 8022a3e:	f7fc fb23 	bl	801f088 <crs_atoi>
 8022a42:	ee07 0a90 	vmov	s15, r0
 8022a46:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        pressure_info.rt_state         =  DC_SERVICE_ON;
 8022a4a:	2307      	movs	r3, #7
 8022a4c:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
        pressure_info.pressure         =  PRESSURE_Value;
 8022a50:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
        mems_state = 1U;
 8022a54:	4b0b      	ldr	r3, [pc, #44]	; (8022a84 <mems_cmd+0x2e4>)
 8022a56:	2201      	movs	r2, #1
 8022a58:	601a      	str	r2, [r3, #0]
        (void)dc_com_write(&dc_com_db, DC_COM_PRESSURE, (void *)&pressure_info, sizeof(pressure_info));
 8022a5a:	2310      	movs	r3, #16
 8022a5c:	aa08      	add	r2, sp, #32
 8022a5e:	4913      	ldr	r1, [pc, #76]	; (8022aac <mems_cmd+0x30c>)
 8022a60:	8809      	ldrh	r1, [r1, #0]
 8022a62:	4813      	ldr	r0, [pc, #76]	; (8022ab0 <mems_cmd+0x310>)
 8022a64:	f7fe ff64 	bl	8021930 <dc_com_write>
 8022a68:	e7c5      	b.n	80229f6 <mems_cmd+0x256>
 8022a6a:	bf00      	nop
 8022a6c:	08032b44 	.word	0x08032b44
 8022a70:	08035ea0 	.word	0x08035ea0
 8022a74:	200047dc 	.word	0x200047dc
 8022a78:	080360b0 	.word	0x080360b0
 8022a7c:	08032b48 	.word	0x08032b48
 8022a80:	08032ed4 	.word	0x08032ed4
 8022a84:	20005c9c 	.word	0x20005c9c
 8022a88:	080360d0 	.word	0x080360d0
 8022a8c:	20005c98 	.word	0x20005c98
 8022a90:	080360e0 	.word	0x080360e0
 8022a94:	080360c0 	.word	0x080360c0
 8022a98:	080350d8 	.word	0x080350d8
 8022a9c:	080350fc 	.word	0x080350fc
 8022aa0:	080360f8 	.word	0x080360f8
 8022aa4:	08036100 	.word	0x08036100
 8022aa8:	0803611c 	.word	0x0803611c
 8022aac:	20000248 	.word	0x20000248
 8022ab0:	200058b0 	.word	0x200058b0
 8022ab4:	08036138 	.word	0x08036138
        PRINT_FORCE("pressure: %f", pressure_info.pressure);
 8022ab8:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8022aba:	f7dd fd5d 	bl	8000578 <__aeabi_f2d>
 8022abe:	4602      	mov	r2, r0
 8022ac0:	460b      	mov	r3, r1
 8022ac2:	4c7c      	ldr	r4, [pc, #496]	; (8022cb4 <mems_cmd+0x514>)
 8022ac4:	497c      	ldr	r1, [pc, #496]	; (8022cb8 <mems_cmd+0x518>)
 8022ac6:	4620      	mov	r0, r4
 8022ac8:	f003 f8d2 	bl	8025c70 <sprintf>
 8022acc:	4620      	mov	r0, r4
 8022ace:	f7fc fb20 	bl	801f112 <crs_strlen>
 8022ad2:	b283      	uxth	r3, r0
 8022ad4:	4622      	mov	r2, r4
 8022ad6:	2101      	movs	r1, #1
 8022ad8:	4608      	mov	r0, r1
 8022ada:	f7fc fb5d 	bl	801f198 <traceIF_itmPrint>
 8022ade:	4620      	mov	r0, r4
 8022ae0:	f7fc fb17 	bl	801f112 <crs_strlen>
 8022ae4:	b282      	uxth	r2, r0
 8022ae6:	4621      	mov	r1, r4
 8022ae8:	2001      	movs	r0, #1
 8022aea:	f7fc fb8f 	bl	801f20c <traceIF_uartPrintForce>
 8022aee:	e667      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "humidity", crs_strlen(argv_p[0])) == 0)
 8022af0:	4630      	mov	r0, r6
 8022af2:	f7fc fb0e 	bl	801f112 <crs_strlen>
 8022af6:	4602      	mov	r2, r0
 8022af8:	4970      	ldr	r1, [pc, #448]	; (8022cbc <mems_cmd+0x51c>)
 8022afa:	4630      	mov	r0, r6
 8022afc:	f003 f91b 	bl	8025d36 <memcmp>
 8022b00:	2800      	cmp	r0, #0
 8022b02:	d159      	bne.n	8022bb8 <mems_cmd+0x418>
      if (argc == 2U)
 8022b04:	2c02      	cmp	r4, #2
 8022b06:	d023      	beq.n	8022b50 <mems_cmd+0x3b0>
      (void)dc_com_read(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8022b08:	2310      	movs	r3, #16
 8022b0a:	eb0d 0203 	add.w	r2, sp, r3
 8022b0e:	496c      	ldr	r1, [pc, #432]	; (8022cc0 <mems_cmd+0x520>)
 8022b10:	8809      	ldrh	r1, [r1, #0]
 8022b12:	486c      	ldr	r0, [pc, #432]	; (8022cc4 <mems_cmd+0x524>)
 8022b14:	f7fe ff58 	bl	80219c8 <dc_com_read>
      if (humidity_info.rt_state ==  DC_SERVICE_ON)
 8022b18:	f89d 3018 	ldrb.w	r3, [sp, #24]
 8022b1c:	2b07      	cmp	r3, #7
 8022b1e:	d02f      	beq.n	8022b80 <mems_cmd+0x3e0>
        PRINT_FORCE("%s invalid", argv_p[0]);
 8022b20:	4c64      	ldr	r4, [pc, #400]	; (8022cb4 <mems_cmd+0x514>)
 8022b22:	4632      	mov	r2, r6
 8022b24:	4968      	ldr	r1, [pc, #416]	; (8022cc8 <mems_cmd+0x528>)
 8022b26:	4620      	mov	r0, r4
 8022b28:	f003 f8a2 	bl	8025c70 <sprintf>
 8022b2c:	4620      	mov	r0, r4
 8022b2e:	f7fc faf0 	bl	801f112 <crs_strlen>
 8022b32:	b283      	uxth	r3, r0
 8022b34:	4622      	mov	r2, r4
 8022b36:	2101      	movs	r1, #1
 8022b38:	4608      	mov	r0, r1
 8022b3a:	f7fc fb2d 	bl	801f198 <traceIF_itmPrint>
 8022b3e:	4620      	mov	r0, r4
 8022b40:	f7fc fae7 	bl	801f112 <crs_strlen>
 8022b44:	b282      	uxth	r2, r0
 8022b46:	4621      	mov	r1, r4
 8022b48:	2001      	movs	r0, #1
 8022b4a:	f7fc fb5f 	bl	801f20c <traceIF_uartPrintForce>
 8022b4e:	e637      	b.n	80227c0 <mems_cmd+0x20>
        HUMIDITY_Value = (float_t)crs_atoi(argv_p[1]);
 8022b50:	980d      	ldr	r0, [sp, #52]	; 0x34
 8022b52:	f7fc fa99 	bl	801f088 <crs_atoi>
 8022b56:	ee07 0a90 	vmov	s15, r0
 8022b5a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        humidity_info.rt_state         =  DC_SERVICE_ON;
 8022b5e:	2307      	movs	r3, #7
 8022b60:	f88d 3018 	strb.w	r3, [sp, #24]
        humidity_info.humidity         =  HUMIDITY_Value;
 8022b64:	edcd 7a07 	vstr	s15, [sp, #28]
        mems_state = 1U;
 8022b68:	4b58      	ldr	r3, [pc, #352]	; (8022ccc <mems_cmd+0x52c>)
 8022b6a:	2201      	movs	r2, #1
 8022b6c:	601a      	str	r2, [r3, #0]
        (void)dc_com_write(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8022b6e:	2310      	movs	r3, #16
 8022b70:	eb0d 0203 	add.w	r2, sp, r3
 8022b74:	4952      	ldr	r1, [pc, #328]	; (8022cc0 <mems_cmd+0x520>)
 8022b76:	8809      	ldrh	r1, [r1, #0]
 8022b78:	4852      	ldr	r0, [pc, #328]	; (8022cc4 <mems_cmd+0x524>)
 8022b7a:	f7fe fed9 	bl	8021930 <dc_com_write>
 8022b7e:	e7c3      	b.n	8022b08 <mems_cmd+0x368>
        PRINT_FORCE("humidity: %f", humidity_info.humidity);
 8022b80:	9807      	ldr	r0, [sp, #28]
 8022b82:	f7dd fcf9 	bl	8000578 <__aeabi_f2d>
 8022b86:	4602      	mov	r2, r0
 8022b88:	460b      	mov	r3, r1
 8022b8a:	4c4a      	ldr	r4, [pc, #296]	; (8022cb4 <mems_cmd+0x514>)
 8022b8c:	4950      	ldr	r1, [pc, #320]	; (8022cd0 <mems_cmd+0x530>)
 8022b8e:	4620      	mov	r0, r4
 8022b90:	f003 f86e 	bl	8025c70 <sprintf>
 8022b94:	4620      	mov	r0, r4
 8022b96:	f7fc fabc 	bl	801f112 <crs_strlen>
 8022b9a:	b283      	uxth	r3, r0
 8022b9c:	4622      	mov	r2, r4
 8022b9e:	2101      	movs	r1, #1
 8022ba0:	4608      	mov	r0, r1
 8022ba2:	f7fc faf9 	bl	801f198 <traceIF_itmPrint>
 8022ba6:	4620      	mov	r0, r4
 8022ba8:	f7fc fab3 	bl	801f112 <crs_strlen>
 8022bac:	b282      	uxth	r2, r0
 8022bae:	4621      	mov	r1, r4
 8022bb0:	2001      	movs	r0, #1
 8022bb2:	f7fc fb2b 	bl	801f20c <traceIF_uartPrintForce>
 8022bb6:	e603      	b.n	80227c0 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "temperature", crs_strlen(argv_p[0])) == 0)
 8022bb8:	4630      	mov	r0, r6
 8022bba:	f7fc faaa 	bl	801f112 <crs_strlen>
 8022bbe:	4602      	mov	r2, r0
 8022bc0:	4944      	ldr	r1, [pc, #272]	; (8022cd4 <mems_cmd+0x534>)
 8022bc2:	4630      	mov	r0, r6
 8022bc4:	f003 f8b7 	bl	8025d36 <memcmp>
 8022bc8:	2800      	cmp	r0, #0
 8022bca:	d157      	bne.n	8022c7c <mems_cmd+0x4dc>
      if (argc == 2U)
 8022bcc:	2c02      	cmp	r4, #2
 8022bce:	d022      	beq.n	8022c16 <mems_cmd+0x476>
      (void)dc_com_read(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8022bd0:	2310      	movs	r3, #16
 8022bd2:	466a      	mov	r2, sp
 8022bd4:	4940      	ldr	r1, [pc, #256]	; (8022cd8 <mems_cmd+0x538>)
 8022bd6:	8809      	ldrh	r1, [r1, #0]
 8022bd8:	483a      	ldr	r0, [pc, #232]	; (8022cc4 <mems_cmd+0x524>)
 8022bda:	f7fe fef5 	bl	80219c8 <dc_com_read>
      if (temperature_info.rt_state ==  DC_SERVICE_ON)
 8022bde:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8022be2:	2b07      	cmp	r3, #7
 8022be4:	d02e      	beq.n	8022c44 <mems_cmd+0x4a4>
        PRINT_FORCE("%s invalid", argv_p[0]);
 8022be6:	4c33      	ldr	r4, [pc, #204]	; (8022cb4 <mems_cmd+0x514>)
 8022be8:	4632      	mov	r2, r6
 8022bea:	4937      	ldr	r1, [pc, #220]	; (8022cc8 <mems_cmd+0x528>)
 8022bec:	4620      	mov	r0, r4
 8022bee:	f003 f83f 	bl	8025c70 <sprintf>
 8022bf2:	4620      	mov	r0, r4
 8022bf4:	f7fc fa8d 	bl	801f112 <crs_strlen>
 8022bf8:	b283      	uxth	r3, r0
 8022bfa:	4622      	mov	r2, r4
 8022bfc:	2101      	movs	r1, #1
 8022bfe:	4608      	mov	r0, r1
 8022c00:	f7fc faca 	bl	801f198 <traceIF_itmPrint>
 8022c04:	4620      	mov	r0, r4
 8022c06:	f7fc fa84 	bl	801f112 <crs_strlen>
 8022c0a:	b282      	uxth	r2, r0
 8022c0c:	4621      	mov	r1, r4
 8022c0e:	2001      	movs	r0, #1
 8022c10:	f7fc fafc 	bl	801f20c <traceIF_uartPrintForce>
 8022c14:	e5d4      	b.n	80227c0 <mems_cmd+0x20>
        TEMPERATURE_Value = (float_t)crs_atoi(argv_p[1]);
 8022c16:	980d      	ldr	r0, [sp, #52]	; 0x34
 8022c18:	f7fc fa36 	bl	801f088 <crs_atoi>
 8022c1c:	ee07 0a90 	vmov	s15, r0
 8022c20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        temperature_info.rt_state         =  DC_SERVICE_ON;
 8022c24:	2307      	movs	r3, #7
 8022c26:	f88d 3008 	strb.w	r3, [sp, #8]
        temperature_info.temperature      =  TEMPERATURE_Value;
 8022c2a:	edcd 7a03 	vstr	s15, [sp, #12]
        mems_state = 1U;
 8022c2e:	4b27      	ldr	r3, [pc, #156]	; (8022ccc <mems_cmd+0x52c>)
 8022c30:	2201      	movs	r2, #1
 8022c32:	601a      	str	r2, [r3, #0]
        (void)dc_com_write(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8022c34:	2310      	movs	r3, #16
 8022c36:	466a      	mov	r2, sp
 8022c38:	4927      	ldr	r1, [pc, #156]	; (8022cd8 <mems_cmd+0x538>)
 8022c3a:	8809      	ldrh	r1, [r1, #0]
 8022c3c:	4821      	ldr	r0, [pc, #132]	; (8022cc4 <mems_cmd+0x524>)
 8022c3e:	f7fe fe77 	bl	8021930 <dc_com_write>
 8022c42:	e7c5      	b.n	8022bd0 <mems_cmd+0x430>
        PRINT_FORCE("temperature: %f", temperature_info.temperature);
 8022c44:	9803      	ldr	r0, [sp, #12]
 8022c46:	f7dd fc97 	bl	8000578 <__aeabi_f2d>
 8022c4a:	4602      	mov	r2, r0
 8022c4c:	460b      	mov	r3, r1
 8022c4e:	4c19      	ldr	r4, [pc, #100]	; (8022cb4 <mems_cmd+0x514>)
 8022c50:	4922      	ldr	r1, [pc, #136]	; (8022cdc <mems_cmd+0x53c>)
 8022c52:	4620      	mov	r0, r4
 8022c54:	f003 f80c 	bl	8025c70 <sprintf>
 8022c58:	4620      	mov	r0, r4
 8022c5a:	f7fc fa5a 	bl	801f112 <crs_strlen>
 8022c5e:	b283      	uxth	r3, r0
 8022c60:	4622      	mov	r2, r4
 8022c62:	2101      	movs	r1, #1
 8022c64:	4608      	mov	r0, r1
 8022c66:	f7fc fa97 	bl	801f198 <traceIF_itmPrint>
 8022c6a:	4620      	mov	r0, r4
 8022c6c:	f7fc fa51 	bl	801f112 <crs_strlen>
 8022c70:	b282      	uxth	r2, r0
 8022c72:	4621      	mov	r1, r4
 8022c74:	2001      	movs	r0, #1
 8022c76:	f7fc fac9 	bl	801f20c <traceIF_uartPrintForce>
 8022c7a:	e5a1      	b.n	80227c0 <mems_cmd+0x20>
      PRINT_FORCE("%s bad command %s\n\r", cmd_p, argv_p[0]);
 8022c7c:	4c0d      	ldr	r4, [pc, #52]	; (8022cb4 <mems_cmd+0x514>)
 8022c7e:	4633      	mov	r3, r6
 8022c80:	462a      	mov	r2, r5
 8022c82:	4917      	ldr	r1, [pc, #92]	; (8022ce0 <mems_cmd+0x540>)
 8022c84:	4620      	mov	r0, r4
 8022c86:	f002 fff3 	bl	8025c70 <sprintf>
 8022c8a:	4620      	mov	r0, r4
 8022c8c:	f7fc fa41 	bl	801f112 <crs_strlen>
 8022c90:	b283      	uxth	r3, r0
 8022c92:	4622      	mov	r2, r4
 8022c94:	2101      	movs	r1, #1
 8022c96:	4608      	mov	r0, r1
 8022c98:	f7fc fa7e 	bl	801f198 <traceIF_itmPrint>
 8022c9c:	4620      	mov	r0, r4
 8022c9e:	f7fc fa38 	bl	801f112 <crs_strlen>
 8022ca2:	b282      	uxth	r2, r0
 8022ca4:	4621      	mov	r1, r4
 8022ca6:	2001      	movs	r0, #1
 8022ca8:	f7fc fab0 	bl	801f20c <traceIF_uartPrintForce>
      mems_cmd_help();
 8022cac:	f7ff fc64 	bl	8022578 <mems_cmd_help>
 8022cb0:	e586      	b.n	80227c0 <mems_cmd+0x20>
 8022cb2:	bf00      	nop
 8022cb4:	200047dc 	.word	0x200047dc
 8022cb8:	08036128 	.word	0x08036128
 8022cbc:	08036148 	.word	0x08036148
 8022cc0:	20000244 	.word	0x20000244
 8022cc4:	200058b0 	.word	0x200058b0
 8022cc8:	08036138 	.word	0x08036138
 8022ccc:	20005c9c 	.word	0x20005c9c
 8022cd0:	08036154 	.word	0x08036154
 8022cd4:	08036164 	.word	0x08036164
 8022cd8:	2000024a 	.word	0x2000024a
 8022cdc:	08036170 	.word	0x08036170
 8022ce0:	08036184 	.word	0x08036184

08022ce4 <dc_mems_init>:
{
 8022ce4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  mems_state = 0U;
 8022ce8:	2300      	movs	r3, #0
 8022cea:	4a30      	ldr	r2, [pc, #192]	; (8022dac <dc_mems_init+0xc8>)
 8022cec:	6013      	str	r3, [r2, #0]
  mems_polling_period = MEMS_POLLING_PERIOD;
 8022cee:	4a30      	ldr	r2, [pc, #192]	; (8022db0 <dc_mems_init+0xcc>)
 8022cf0:	f242 7110 	movw	r1, #10000	; 0x2710
 8022cf4:	6011      	str	r1, [r2, #0]
  (void)memset((void *)&dc_pressure_info,      0, sizeof(dc_pressure_info_t));
 8022cf6:	492f      	ldr	r1, [pc, #188]	; (8022db4 <dc_mems_init+0xd0>)
 8022cf8:	600b      	str	r3, [r1, #0]
 8022cfa:	604b      	str	r3, [r1, #4]
 8022cfc:	608b      	str	r3, [r1, #8]
 8022cfe:	60cb      	str	r3, [r1, #12]
  (void)memset((void *)&dc_humidity_info,      0, sizeof(dc_humidity_info_t));
 8022d00:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 8022de0 <dc_mems_init+0xfc>
 8022d04:	f8c9 3000 	str.w	r3, [r9]
 8022d08:	f8c9 3004 	str.w	r3, [r9, #4]
 8022d0c:	f8c9 3008 	str.w	r3, [r9, #8]
 8022d10:	f8c9 300c 	str.w	r3, [r9, #12]
  (void)memset((void *)&dc_temperature_info,   0, sizeof(dc_temperature_info_t));
 8022d14:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8022de4 <dc_mems_init+0x100>
 8022d18:	f8c8 3000 	str.w	r3, [r8]
 8022d1c:	f8c8 3004 	str.w	r3, [r8, #4]
 8022d20:	f8c8 3008 	str.w	r3, [r8, #8]
 8022d24:	f8c8 300c 	str.w	r3, [r8, #12]
  (void)memset((void *)&dc_accelerometer_info, 0, sizeof(dc_accelerometer_info_t));
 8022d28:	4e23      	ldr	r6, [pc, #140]	; (8022db8 <dc_mems_init+0xd4>)
 8022d2a:	6033      	str	r3, [r6, #0]
 8022d2c:	6073      	str	r3, [r6, #4]
 8022d2e:	60b3      	str	r3, [r6, #8]
 8022d30:	60f3      	str	r3, [r6, #12]
 8022d32:	6133      	str	r3, [r6, #16]
 8022d34:	6173      	str	r3, [r6, #20]
  (void)memset((void *)&dc_gyroscope_info,     0, sizeof(dc_gyroscope_info_t));
 8022d36:	4d21      	ldr	r5, [pc, #132]	; (8022dbc <dc_mems_init+0xd8>)
 8022d38:	602b      	str	r3, [r5, #0]
 8022d3a:	606b      	str	r3, [r5, #4]
 8022d3c:	60ab      	str	r3, [r5, #8]
 8022d3e:	60eb      	str	r3, [r5, #12]
 8022d40:	612b      	str	r3, [r5, #16]
 8022d42:	616b      	str	r3, [r5, #20]
  (void)memset((void *)&dc_magnetometer_info,  0, sizeof(dc_magnetometer_info_t));
 8022d44:	4c1e      	ldr	r4, [pc, #120]	; (8022dc0 <dc_mems_init+0xdc>)
 8022d46:	6023      	str	r3, [r4, #0]
 8022d48:	6063      	str	r3, [r4, #4]
 8022d4a:	60a3      	str	r3, [r4, #8]
 8022d4c:	60e3      	str	r3, [r4, #12]
 8022d4e:	6123      	str	r3, [r4, #16]
 8022d50:	6163      	str	r3, [r4, #20]
  DC_COM_PRESSURE       = dc_com_register_serv(&dc_com_db, (void *)&dc_pressure_info,
 8022d52:	4f1c      	ldr	r7, [pc, #112]	; (8022dc4 <dc_mems_init+0xe0>)
 8022d54:	2210      	movs	r2, #16
 8022d56:	4638      	mov	r0, r7
 8022d58:	f7fe fd86 	bl	8021868 <dc_com_register_serv>
 8022d5c:	4b1a      	ldr	r3, [pc, #104]	; (8022dc8 <dc_mems_init+0xe4>)
 8022d5e:	8018      	strh	r0, [r3, #0]
  DC_COM_HUMIDITY       = dc_com_register_serv(&dc_com_db, (void *)&dc_humidity_info,
 8022d60:	2210      	movs	r2, #16
 8022d62:	4649      	mov	r1, r9
 8022d64:	4638      	mov	r0, r7
 8022d66:	f7fe fd7f 	bl	8021868 <dc_com_register_serv>
 8022d6a:	4b18      	ldr	r3, [pc, #96]	; (8022dcc <dc_mems_init+0xe8>)
 8022d6c:	8018      	strh	r0, [r3, #0]
  DC_COM_TEMPERATURE    = dc_com_register_serv(&dc_com_db, (void *)&dc_temperature_info,
 8022d6e:	2210      	movs	r2, #16
 8022d70:	4641      	mov	r1, r8
 8022d72:	4638      	mov	r0, r7
 8022d74:	f7fe fd78 	bl	8021868 <dc_com_register_serv>
 8022d78:	4b15      	ldr	r3, [pc, #84]	; (8022dd0 <dc_mems_init+0xec>)
 8022d7a:	8018      	strh	r0, [r3, #0]
  DC_COM_ACCELEROMETER  = dc_com_register_serv(&dc_com_db, (void *)&dc_accelerometer_info,
 8022d7c:	2218      	movs	r2, #24
 8022d7e:	4631      	mov	r1, r6
 8022d80:	4638      	mov	r0, r7
 8022d82:	f7fe fd71 	bl	8021868 <dc_com_register_serv>
 8022d86:	4b13      	ldr	r3, [pc, #76]	; (8022dd4 <dc_mems_init+0xf0>)
 8022d88:	8018      	strh	r0, [r3, #0]
  DC_COM_GYROSCOPE      = dc_com_register_serv(&dc_com_db, (void *)&dc_gyroscope_info,
 8022d8a:	2218      	movs	r2, #24
 8022d8c:	4629      	mov	r1, r5
 8022d8e:	4638      	mov	r0, r7
 8022d90:	f7fe fd6a 	bl	8021868 <dc_com_register_serv>
 8022d94:	4b10      	ldr	r3, [pc, #64]	; (8022dd8 <dc_mems_init+0xf4>)
 8022d96:	8018      	strh	r0, [r3, #0]
  DC_COM_MAGNETOMETER   = dc_com_register_serv(&dc_com_db, (void *)&dc_magnetometer_info,
 8022d98:	2218      	movs	r2, #24
 8022d9a:	4621      	mov	r1, r4
 8022d9c:	4638      	mov	r0, r7
 8022d9e:	f7fe fd63 	bl	8021868 <dc_com_register_serv>
 8022da2:	4b0e      	ldr	r3, [pc, #56]	; (8022ddc <dc_mems_init+0xf8>)
 8022da4:	8018      	strh	r0, [r3, #0]
}
 8022da6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022daa:	bf00      	nop
 8022dac:	20005c9c 	.word	0x20005c9c
 8022db0:	20005c98 	.word	0x20005c98
 8022db4:	20005c70 	.word	0x20005c70
 8022db8:	20005c18 	.word	0x20005c18
 8022dbc:	20005c30 	.word	0x20005c30
 8022dc0:	20005c58 	.word	0x20005c58
 8022dc4:	200058b0 	.word	0x200058b0
 8022dc8:	20000248 	.word	0x20000248
 8022dcc:	20000244 	.word	0x20000244
 8022dd0:	2000024a 	.word	0x2000024a
 8022dd4:	20000240 	.word	0x20000240
 8022dd8:	20000242 	.word	0x20000242
 8022ddc:	20000246 	.word	0x20000246
 8022de0:	20005c48 	.word	0x20005c48
 8022de4:	20005c80 	.word	0x20005c80

08022de8 <dc_mems_start>:
{
 8022de8:	b500      	push	{lr}
 8022dea:	b083      	sub	sp, #12
  CMD_Declare(mems_cmd_label, mems_cmd, (uint8_t *)"mems management");
 8022dec:	4a0c      	ldr	r2, [pc, #48]	; (8022e20 <dc_mems_start+0x38>)
 8022dee:	490d      	ldr	r1, [pc, #52]	; (8022e24 <dc_mems_start+0x3c>)
 8022df0:	480d      	ldr	r0, [pc, #52]	; (8022e28 <dc_mems_start+0x40>)
 8022df2:	f7ff f9cd 	bl	8022190 <CMD_Declare>
  memsDclibTaskTaskId = rtosalThreadNew((const rtosal_char_t *)"memsDclibTask", (os_pthread)StartMemsDclibTask,
 8022df6:	2200      	movs	r2, #0
 8022df8:	9200      	str	r2, [sp, #0]
 8022dfa:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8022dfe:	490b      	ldr	r1, [pc, #44]	; (8022e2c <dc_mems_start+0x44>)
 8022e00:	480b      	ldr	r0, [pc, #44]	; (8022e30 <dc_mems_start+0x48>)
 8022e02:	f7fc f874 	bl	801eeee <rtosalThreadNew>
 8022e06:	4b0b      	ldr	r3, [pc, #44]	; (8022e34 <dc_mems_start+0x4c>)
 8022e08:	6018      	str	r0, [r3, #0]
  if (memsDclibTaskTaskId == NULL)
 8022e0a:	b110      	cbz	r0, 8022e12 <dc_mems_start+0x2a>
}
 8022e0c:	b003      	add	sp, #12
 8022e0e:	f85d fb04 	ldr.w	pc, [sp], #4
    ERROR_Handler(DBG_CHAN_MAIN, 11, ERROR_FATAL);
 8022e12:	2203      	movs	r2, #3
 8022e14:	210b      	movs	r1, #11
 8022e16:	2001      	movs	r0, #1
 8022e18:	f7fb f998 	bl	801e14c <ERROR_Handler>
}
 8022e1c:	e7f6      	b.n	8022e0c <dc_mems_start+0x24>
 8022e1e:	bf00      	nop
 8022e20:	0803619c 	.word	0x0803619c
 8022e24:	080227a1 	.word	0x080227a1
 8022e28:	08035ea0 	.word	0x08035ea0
 8022e2c:	08022541 	.word	0x08022541
 8022e30:	080361ac 	.word	0x080361ac
 8022e34:	20005c90 	.word	0x20005c90

08022e38 <custom_log_mems>:
} logBuffer_t;

static logBuffer_t logBuffer;

static bool custom_log_mems()
{
 8022e38:	b530      	push	{r4, r5, lr}
 8022e3a:	b09d      	sub	sp, #116	; 0x74
	dc_humidity_info_t		humidity_info;
	char 					mems_string[64];
	int						mems_string_len;

	// read the MEM data
	(void)dc_com_read(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8022e3c:	4c1c      	ldr	r4, [pc, #112]	; (8022eb0 <custom_log_mems+0x78>)
 8022e3e:	2310      	movs	r3, #16
 8022e40:	aa18      	add	r2, sp, #96	; 0x60
 8022e42:	491c      	ldr	r1, [pc, #112]	; (8022eb4 <custom_log_mems+0x7c>)
 8022e44:	8809      	ldrh	r1, [r1, #0]
 8022e46:	4620      	mov	r0, r4
 8022e48:	f7fe fdbe 	bl	80219c8 <dc_com_read>
    (void)dc_com_read(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8022e4c:	2310      	movs	r3, #16
 8022e4e:	aa14      	add	r2, sp, #80	; 0x50
 8022e50:	4919      	ldr	r1, [pc, #100]	; (8022eb8 <custom_log_mems+0x80>)
 8022e52:	8809      	ldrh	r1, [r1, #0]
 8022e54:	4620      	mov	r0, r4
 8022e56:	f7fe fdb7 	bl	80219c8 <dc_com_read>

	// convert to string the temperature and humidity
    mems_string_len= sprintf(mems_string,"time=%d;temperature=%f;humidity=%f",xTaskGetTickCount(),temperature_info.temperature, humidity_info.humidity);
 8022e5a:	f002 f849 	bl	8024ef0 <xTaskGetTickCount>
 8022e5e:	4604      	mov	r4, r0
 8022e60:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8022e62:	f7dd fb89 	bl	8000578 <__aeabi_f2d>
 8022e66:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8022e6a:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8022e6c:	f7dd fb84 	bl	8000578 <__aeabi_f2d>
 8022e70:	e9cd 0100 	strd	r0, r1, [sp]
 8022e74:	4622      	mov	r2, r4
 8022e76:	4911      	ldr	r1, [pc, #68]	; (8022ebc <custom_log_mems+0x84>)
 8022e78:	a804      	add	r0, sp, #16
 8022e7a:	f002 fef9 	bl	8025c70 <sprintf>
 8022e7e:	4604      	mov	r4, r0

	// append in logBuffer as string
	if ((logBuffer.data_len + mems_string_len) <= (sizeof(logBuffer.data)))
 8022e80:	4b0f      	ldr	r3, [pc, #60]	; (8022ec0 <custom_log_mems+0x88>)
 8022e82:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
 8022e86:	1903      	adds	r3, r0, r4
 8022e88:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8022e8c:	d902      	bls.n	8022e94 <custom_log_mems+0x5c>
		memcpy(&logBuffer.data[logBuffer.data_len], (const void *)mems_string, mems_string_len);
		logBuffer.data_len += mems_string_len;
	}
	else
	{
		return false;
 8022e8e:	2000      	movs	r0, #0
	}
	return true;
}
 8022e90:	b01d      	add	sp, #116	; 0x74
 8022e92:	bd30      	pop	{r4, r5, pc}
		memcpy(&logBuffer.data[logBuffer.data_len], (const void *)mems_string, mems_string_len);
 8022e94:	4d0a      	ldr	r5, [pc, #40]	; (8022ec0 <custom_log_mems+0x88>)
 8022e96:	4622      	mov	r2, r4
 8022e98:	a904      	add	r1, sp, #16
 8022e9a:	4428      	add	r0, r5
 8022e9c:	f003 f838 	bl	8025f10 <memcpy>
		logBuffer.data_len += mems_string_len;
 8022ea0:	f8d5 3400 	ldr.w	r3, [r5, #1024]	; 0x400
 8022ea4:	4423      	add	r3, r4
 8022ea6:	f8c5 3400 	str.w	r3, [r5, #1024]	; 0x400
	return true;
 8022eaa:	2001      	movs	r0, #1
 8022eac:	e7f0      	b.n	8022e90 <custom_log_mems+0x58>
 8022eae:	bf00      	nop
 8022eb0:	200058b0 	.word	0x200058b0
 8022eb4:	2000024a 	.word	0x2000024a
 8022eb8:	20000244 	.word	0x20000244
 8022ebc:	080361bc 	.word	0x080361bc
 8022ec0:	20005cac 	.word	0x20005cac

08022ec4 <custom_client_thread>:
  * @param  p_argument - parameter osThread
  * @note   Unused parameter
  * @retval -
  */
static void custom_client_thread(void *p_argument)
{
 8022ec4:	b500      	push	{lr}
 8022ec6:	b083      	sub	sp, #12
  UNUSED(p_argument);

    /* Add below code of your application */
    /* Example : */
    /* Wait network is up to do something */
	uint32_t msg_queue = 0U;
 8022ec8:	2300      	movs	r3, #0
 8022eca:	9301      	str	r3, [sp, #4]
	(void)rtosalMessageQueueGet(custom_client_queue, &msg_queue, RTOSAL_WAIT_FOREVER);
 8022ecc:	f04f 32ff 	mov.w	r2, #4294967295
 8022ed0:	a901      	add	r1, sp, #4
 8022ed2:	4b05      	ldr	r3, [pc, #20]	; (8022ee8 <custom_client_thread+0x24>)
 8022ed4:	6818      	ldr	r0, [r3, #0]
 8022ed6:	f7fc f84e 	bl	801ef76 <rtosalMessageQueueGet>
    const TickType_t xDelay = 1000 / portTICK_PERIOD_MS;

    for( ;; )
    {
        // Perform action here: log the mems
        custom_log_mems();
 8022eda:	f7ff ffad 	bl	8022e38 <custom_log_mems>

        // Wait for the next cycle.
        vTaskDelay( xDelay );
 8022ede:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8022ee2:	f002 f91b 	bl	802511c <vTaskDelay>
    for( ;; )
 8022ee6:	e7f8      	b.n	8022eda <custom_client_thread+0x16>
 8022ee8:	20005ca8 	.word	0x20005ca8

08022eec <custom_connect_and_send_data>:
{
 8022eec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022ef0:	b088      	sub	sp, #32
 8022ef2:	4607      	mov	r7, r0
 8022ef4:	460e      	mov	r6, r1
	  int32_t 	timeout = 20000;
 8022ef6:	f644 6320 	movw	r3, #20000	; 0x4e20
 8022efa:	9307      	str	r3, [sp, #28]
	  PRINT_INFO("socket creation in progress...\n\r")
 8022efc:	4ccb      	ldr	r4, [pc, #812]	; (802322c <custom_connect_and_send_data+0x340>)
 8022efe:	4dcc      	ldr	r5, [pc, #816]	; (8023230 <custom_connect_and_send_data+0x344>)
 8022f00:	f104 0e20 	add.w	lr, r4, #32
 8022f04:	46a4      	mov	ip, r4
 8022f06:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8022f0a:	6028      	str	r0, [r5, #0]
 8022f0c:	6069      	str	r1, [r5, #4]
 8022f0e:	60aa      	str	r2, [r5, #8]
 8022f10:	60eb      	str	r3, [r5, #12]
 8022f12:	4664      	mov	r4, ip
 8022f14:	3510      	adds	r5, #16
 8022f16:	45f4      	cmp	ip, lr
 8022f18:	d1f4      	bne.n	8022f04 <custom_connect_and_send_data+0x18>
 8022f1a:	cc03      	ldmia	r4!, {r0, r1}
 8022f1c:	6028      	str	r0, [r5, #0]
 8022f1e:	6069      	str	r1, [r5, #4]
 8022f20:	8823      	ldrh	r3, [r4, #0]
 8022f22:	812b      	strh	r3, [r5, #8]
 8022f24:	4cc2      	ldr	r4, [pc, #776]	; (8023230 <custom_connect_and_send_data+0x344>)
 8022f26:	4620      	mov	r0, r4
 8022f28:	f7fc f8f3 	bl	801f112 <crs_strlen>
 8022f2c:	b283      	uxth	r3, r0
 8022f2e:	4622      	mov	r2, r4
 8022f30:	2101      	movs	r1, #1
 8022f32:	2004      	movs	r0, #4
 8022f34:	f7fc f930 	bl	801f198 <traceIF_itmPrint>
 8022f38:	4620      	mov	r0, r4
 8022f3a:	f7fc f8ea 	bl	801f112 <crs_strlen>
 8022f3e:	b283      	uxth	r3, r0
 8022f40:	4622      	mov	r2, r4
 8022f42:	2101      	movs	r1, #1
 8022f44:	2004      	movs	r0, #4
 8022f46:	f7fc f949 	bl	801f1dc <traceIF_uartPrint>
	  id = com_socket(COM_AF_INET, COM_SOCK_STREAM, COM_IPPROTO_TCP);
 8022f4a:	2206      	movs	r2, #6
 8022f4c:	2101      	movs	r1, #1
 8022f4e:	2002      	movs	r0, #2
 8022f50:	f7fc fff6 	bl	801ff40 <com_socket>
      if (id >= 0) /* no invalid value defined in network library */
 8022f54:	f1b0 0800 	subs.w	r8, r0, #0
 8022f58:	f2c0 8144 	blt.w	80231e4 <custom_connect_and_send_data+0x2f8>
    	  PRINT_INFO("socket create OK")
 8022f5c:	4db5      	ldr	r5, [pc, #724]	; (8023234 <custom_connect_and_send_data+0x348>)
 8022f5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022f60:	6020      	str	r0, [r4, #0]
 8022f62:	6061      	str	r1, [r4, #4]
 8022f64:	60a2      	str	r2, [r4, #8]
 8022f66:	60e3      	str	r3, [r4, #12]
 8022f68:	cd03      	ldmia	r5!, {r0, r1}
 8022f6a:	6120      	str	r0, [r4, #16]
 8022f6c:	6161      	str	r1, [r4, #20]
 8022f6e:	882b      	ldrh	r3, [r5, #0]
 8022f70:	8323      	strh	r3, [r4, #24]
 8022f72:	4620      	mov	r0, r4
 8022f74:	f7fc f8cd 	bl	801f112 <crs_strlen>
 8022f78:	b283      	uxth	r3, r0
 8022f7a:	4622      	mov	r2, r4
 8022f7c:	2101      	movs	r1, #1
 8022f7e:	2004      	movs	r0, #4
 8022f80:	f7fc f90a 	bl	801f198 <traceIF_itmPrint>
 8022f84:	4620      	mov	r0, r4
 8022f86:	f7fc f8c4 	bl	801f112 <crs_strlen>
 8022f8a:	b283      	uxth	r3, r0
 8022f8c:	4622      	mov	r2, r4
 8022f8e:	2101      	movs	r1, #1
 8022f90:	2004      	movs	r0, #4
 8022f92:	f7fc f923 	bl	801f1dc <traceIF_uartPrint>
		if (com_setsockopt(id, COM_SOL_SOCKET, COM_SO_RCVTIMEO, &timeout, (int32_t)sizeof(timeout)) == COM_SOCKETS_ERR_OK)
 8022f96:	2304      	movs	r3, #4
 8022f98:	9300      	str	r3, [sp, #0]
 8022f9a:	ab07      	add	r3, sp, #28
 8022f9c:	f241 0206 	movw	r2, #4102	; 0x1006
 8022fa0:	f640 71ff 	movw	r1, #4095	; 0xfff
 8022fa4:	4640      	mov	r0, r8
 8022fa6:	f7fc ffcf 	bl	801ff48 <com_setsockopt>
 8022faa:	2800      	cmp	r0, #0
 8022fac:	f040 80f1 	bne.w	8023192 <custom_connect_and_send_data+0x2a6>
	          if (com_setsockopt(id, COM_SOL_SOCKET, COM_SO_SNDTIMEO, &timeout, (int32_t)sizeof(timeout)) == COM_SOCKETS_ERR_OK)
 8022fb0:	2304      	movs	r3, #4
 8022fb2:	9300      	str	r3, [sp, #0]
 8022fb4:	ab07      	add	r3, sp, #28
 8022fb6:	f241 0205 	movw	r2, #4101	; 0x1005
 8022fba:	f640 71ff 	movw	r1, #4095	; 0xfff
 8022fbe:	4640      	mov	r0, r8
 8022fc0:	f7fc ffc2 	bl	801ff48 <com_setsockopt>
 8022fc4:	2800      	cmp	r0, #0
 8022fc6:	f040 80bc 	bne.w	8023142 <custom_connect_and_send_data+0x256>
                address.sin_family      = (uint8_t)COM_AF_INET;
 8022fca:	2302      	movs	r3, #2
 8022fcc:	f88d 300d 	strb.w	r3, [sp, #13]
                address.sin_addr.s_addr = COM_HTONL(SERVER_LOG_IP);
 8022fd0:	4b99      	ldr	r3, [pc, #612]	; (8023238 <custom_connect_and_send_data+0x34c>)
 8022fd2:	9304      	str	r3, [sp, #16]
                address.sin_port        = COM_HTONS(SERVER_LOG_PORT);
 8022fd4:	f648 0313 	movw	r3, #34835	; 0x8813
 8022fd8:	f8ad 300e 	strh.w	r3, [sp, #14]
                if (com_connect(id, (com_sockaddr_t const *)&address, (int32_t)sizeof(com_sockaddr_in_t))
 8022fdc:	2210      	movs	r2, #16
 8022fde:	a903      	add	r1, sp, #12
 8022fe0:	4640      	mov	r0, r8
 8022fe2:	f7fc ffb9 	bl	801ff58 <com_connect>
 8022fe6:	2800      	cmp	r0, #0
 8022fe8:	f040 808a 	bne.w	8023100 <custom_connect_and_send_data+0x214>
                	PRINT_INFO("Send data in progress....\n\r");
 8022fec:	f8df c268 	ldr.w	ip, [pc, #616]	; 8023258 <custom_connect_and_send_data+0x36c>
 8022ff0:	f10c 0e20 	add.w	lr, ip, #32
 8022ff4:	4665      	mov	r5, ip
 8022ff6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022ff8:	6020      	str	r0, [r4, #0]
 8022ffa:	6061      	str	r1, [r4, #4]
 8022ffc:	60a2      	str	r2, [r4, #8]
 8022ffe:	60e3      	str	r3, [r4, #12]
 8023000:	46ac      	mov	ip, r5
 8023002:	3410      	adds	r4, #16
 8023004:	4575      	cmp	r5, lr
 8023006:	d1f5      	bne.n	8022ff4 <custom_connect_and_send_data+0x108>
 8023008:	6828      	ldr	r0, [r5, #0]
 802300a:	6020      	str	r0, [r4, #0]
 802300c:	792b      	ldrb	r3, [r5, #4]
 802300e:	7123      	strb	r3, [r4, #4]
 8023010:	4c87      	ldr	r4, [pc, #540]	; (8023230 <custom_connect_and_send_data+0x344>)
 8023012:	4620      	mov	r0, r4
 8023014:	f7fc f87d 	bl	801f112 <crs_strlen>
 8023018:	b283      	uxth	r3, r0
 802301a:	4622      	mov	r2, r4
 802301c:	2101      	movs	r1, #1
 802301e:	2004      	movs	r0, #4
 8023020:	f7fc f8ba 	bl	801f198 <traceIF_itmPrint>
 8023024:	4620      	mov	r0, r4
 8023026:	f7fc f874 	bl	801f112 <crs_strlen>
 802302a:	b283      	uxth	r3, r0
 802302c:	4622      	mov	r2, r4
 802302e:	2101      	movs	r1, #1
 8023030:	2004      	movs	r0, #4
 8023032:	f7fc f8d3 	bl	801f1dc <traceIF_uartPrint>
                	PRINT_INFO("%s\n\r", buffer_addr);
 8023036:	463a      	mov	r2, r7
 8023038:	4980      	ldr	r1, [pc, #512]	; (802323c <custom_connect_and_send_data+0x350>)
 802303a:	4620      	mov	r0, r4
 802303c:	f002 fe18 	bl	8025c70 <sprintf>
 8023040:	4620      	mov	r0, r4
 8023042:	f7fc f866 	bl	801f112 <crs_strlen>
 8023046:	b283      	uxth	r3, r0
 8023048:	4622      	mov	r2, r4
 802304a:	2101      	movs	r1, #1
 802304c:	2004      	movs	r0, #4
 802304e:	f7fc f8a3 	bl	801f198 <traceIF_itmPrint>
 8023052:	4620      	mov	r0, r4
 8023054:	f7fc f85d 	bl	801f112 <crs_strlen>
 8023058:	b283      	uxth	r3, r0
 802305a:	4622      	mov	r2, r4
 802305c:	2101      	movs	r1, #1
 802305e:	2004      	movs	r0, #4
 8023060:	f7fc f8bc 	bl	801f1dc <traceIF_uartPrint>
                	ret = com_send(id, (const com_char_t *)buffer_addr, buffer_len, COM_MSG_WAIT);
 8023064:	2300      	movs	r3, #0
 8023066:	4632      	mov	r2, r6
 8023068:	4639      	mov	r1, r7
 802306a:	4640      	mov	r0, r8
 802306c:	f7fc ff78 	bl	801ff60 <com_send>
                	if (ret == buffer_len)
 8023070:	4286      	cmp	r6, r0
 8023072:	d025      	beq.n	80230c0 <custom_connect_and_send_data+0x1d4>
	  result = false;
 8023074:	2400      	movs	r4, #0
					if (com_closesocket(id) == COM_SOCKETS_ERR_OK)
 8023076:	4640      	mov	r0, r8
 8023078:	f7fc ff76 	bl	801ff68 <com_closesocket>
 802307c:	bb10      	cbnz	r0, 80230c4 <custom_connect_and_send_data+0x1d8>
						PRINT_INFO("socket close OK\n\r")
 802307e:	4d6c      	ldr	r5, [pc, #432]	; (8023230 <custom_connect_and_send_data+0x344>)
 8023080:	4e6f      	ldr	r6, [pc, #444]	; (8023240 <custom_connect_and_send_data+0x354>)
 8023082:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8023084:	6028      	str	r0, [r5, #0]
 8023086:	6069      	str	r1, [r5, #4]
 8023088:	60aa      	str	r2, [r5, #8]
 802308a:	60eb      	str	r3, [r5, #12]
 802308c:	ce03      	ldmia	r6!, {r0, r1}
 802308e:	6128      	str	r0, [r5, #16]
 8023090:	6169      	str	r1, [r5, #20]
 8023092:	8832      	ldrh	r2, [r6, #0]
 8023094:	78b3      	ldrb	r3, [r6, #2]
 8023096:	832a      	strh	r2, [r5, #24]
 8023098:	76ab      	strb	r3, [r5, #26]
 802309a:	4628      	mov	r0, r5
 802309c:	f7fc f839 	bl	801f112 <crs_strlen>
 80230a0:	b283      	uxth	r3, r0
 80230a2:	462a      	mov	r2, r5
 80230a4:	2101      	movs	r1, #1
 80230a6:	2004      	movs	r0, #4
 80230a8:	f7fc f876 	bl	801f198 <traceIF_itmPrint>
 80230ac:	4628      	mov	r0, r5
 80230ae:	f7fc f830 	bl	801f112 <crs_strlen>
 80230b2:	b283      	uxth	r3, r0
 80230b4:	462a      	mov	r2, r5
 80230b6:	2101      	movs	r1, #1
 80230b8:	2004      	movs	r0, #4
 80230ba:	f7fc f88f 	bl	801f1dc <traceIF_uartPrint>
 80230be:	e0b1      	b.n	8023224 <custom_connect_and_send_data+0x338>
						result = true;
 80230c0:	2401      	movs	r4, #1
 80230c2:	e7d8      	b.n	8023076 <custom_connect_and_send_data+0x18a>
						PRINT_INFO("socket close NOK\n\r")
 80230c4:	4d5a      	ldr	r5, [pc, #360]	; (8023230 <custom_connect_and_send_data+0x344>)
 80230c6:	4e5f      	ldr	r6, [pc, #380]	; (8023244 <custom_connect_and_send_data+0x358>)
 80230c8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80230ca:	6028      	str	r0, [r5, #0]
 80230cc:	6069      	str	r1, [r5, #4]
 80230ce:	60aa      	str	r2, [r5, #8]
 80230d0:	60eb      	str	r3, [r5, #12]
 80230d2:	ce07      	ldmia	r6!, {r0, r1, r2}
 80230d4:	6128      	str	r0, [r5, #16]
 80230d6:	6169      	str	r1, [r5, #20]
 80230d8:	61aa      	str	r2, [r5, #24]
 80230da:	4628      	mov	r0, r5
 80230dc:	f7fc f819 	bl	801f112 <crs_strlen>
 80230e0:	b283      	uxth	r3, r0
 80230e2:	462a      	mov	r2, r5
 80230e4:	2101      	movs	r1, #1
 80230e6:	2004      	movs	r0, #4
 80230e8:	f7fc f856 	bl	801f198 <traceIF_itmPrint>
 80230ec:	4628      	mov	r0, r5
 80230ee:	f7fc f810 	bl	801f112 <crs_strlen>
 80230f2:	b283      	uxth	r3, r0
 80230f4:	462a      	mov	r2, r5
 80230f6:	2101      	movs	r1, #1
 80230f8:	2004      	movs	r0, #4
 80230fa:	f7fc f86f 	bl	801f1dc <traceIF_uartPrint>
 80230fe:	e091      	b.n	8023224 <custom_connect_and_send_data+0x338>
                	PRINT_INFO("socket connect NOK\n\r")
 8023100:	4c4b      	ldr	r4, [pc, #300]	; (8023230 <custom_connect_and_send_data+0x344>)
 8023102:	4d51      	ldr	r5, [pc, #324]	; (8023248 <custom_connect_and_send_data+0x35c>)
 8023104:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023106:	6020      	str	r0, [r4, #0]
 8023108:	6061      	str	r1, [r4, #4]
 802310a:	60a2      	str	r2, [r4, #8]
 802310c:	60e3      	str	r3, [r4, #12]
 802310e:	cd07      	ldmia	r5!, {r0, r1, r2}
 8023110:	6120      	str	r0, [r4, #16]
 8023112:	6161      	str	r1, [r4, #20]
 8023114:	61a2      	str	r2, [r4, #24]
 8023116:	882b      	ldrh	r3, [r5, #0]
 8023118:	83a3      	strh	r3, [r4, #28]
 802311a:	4620      	mov	r0, r4
 802311c:	f7fb fff9 	bl	801f112 <crs_strlen>
 8023120:	b283      	uxth	r3, r0
 8023122:	4622      	mov	r2, r4
 8023124:	2101      	movs	r1, #1
 8023126:	2004      	movs	r0, #4
 8023128:	f7fc f836 	bl	801f198 <traceIF_itmPrint>
 802312c:	4620      	mov	r0, r4
 802312e:	f7fb fff0 	bl	801f112 <crs_strlen>
 8023132:	b283      	uxth	r3, r0
 8023134:	4622      	mov	r2, r4
 8023136:	2101      	movs	r1, #1
 8023138:	2004      	movs	r0, #4
 802313a:	f7fc f84f 	bl	801f1dc <traceIF_uartPrint>
	  result = false;
 802313e:	2400      	movs	r4, #0
 8023140:	e070      	b.n	8023224 <custom_connect_and_send_data+0x338>
	        	  PRINT_INFO("socket setsockopt SNDTIMEO NOK\n\r")
 8023142:	4d42      	ldr	r5, [pc, #264]	; (802324c <custom_connect_and_send_data+0x360>)
 8023144:	4c3a      	ldr	r4, [pc, #232]	; (8023230 <custom_connect_and_send_data+0x344>)
 8023146:	f105 0720 	add.w	r7, r5, #32
 802314a:	462e      	mov	r6, r5
 802314c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 802314e:	6020      	str	r0, [r4, #0]
 8023150:	6061      	str	r1, [r4, #4]
 8023152:	60a2      	str	r2, [r4, #8]
 8023154:	60e3      	str	r3, [r4, #12]
 8023156:	4635      	mov	r5, r6
 8023158:	3410      	adds	r4, #16
 802315a:	42be      	cmp	r6, r7
 802315c:	d1f5      	bne.n	802314a <custom_connect_and_send_data+0x25e>
 802315e:	cd03      	ldmia	r5!, {r0, r1}
 8023160:	6020      	str	r0, [r4, #0]
 8023162:	6061      	str	r1, [r4, #4]
 8023164:	882b      	ldrh	r3, [r5, #0]
 8023166:	8123      	strh	r3, [r4, #8]
 8023168:	4c31      	ldr	r4, [pc, #196]	; (8023230 <custom_connect_and_send_data+0x344>)
 802316a:	4620      	mov	r0, r4
 802316c:	f7fb ffd1 	bl	801f112 <crs_strlen>
 8023170:	b283      	uxth	r3, r0
 8023172:	4622      	mov	r2, r4
 8023174:	2101      	movs	r1, #1
 8023176:	2004      	movs	r0, #4
 8023178:	f7fc f80e 	bl	801f198 <traceIF_itmPrint>
 802317c:	4620      	mov	r0, r4
 802317e:	f7fb ffc8 	bl	801f112 <crs_strlen>
 8023182:	b283      	uxth	r3, r0
 8023184:	4622      	mov	r2, r4
 8023186:	2101      	movs	r1, #1
 8023188:	2004      	movs	r0, #4
 802318a:	f7fc f827 	bl	801f1dc <traceIF_uartPrint>
	  result = false;
 802318e:	2400      	movs	r4, #0
 8023190:	e048      	b.n	8023224 <custom_connect_and_send_data+0x338>
			PRINT_INFO("socket setsockopt RCVTIMEO NOK\n\r")
 8023192:	4d2f      	ldr	r5, [pc, #188]	; (8023250 <custom_connect_and_send_data+0x364>)
 8023194:	4c26      	ldr	r4, [pc, #152]	; (8023230 <custom_connect_and_send_data+0x344>)
 8023196:	f105 0620 	add.w	r6, r5, #32
 802319a:	46ac      	mov	ip, r5
 802319c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80231a0:	6020      	str	r0, [r4, #0]
 80231a2:	6061      	str	r1, [r4, #4]
 80231a4:	60a2      	str	r2, [r4, #8]
 80231a6:	60e3      	str	r3, [r4, #12]
 80231a8:	4665      	mov	r5, ip
 80231aa:	3410      	adds	r4, #16
 80231ac:	45b4      	cmp	ip, r6
 80231ae:	d1f4      	bne.n	802319a <custom_connect_and_send_data+0x2ae>
 80231b0:	cd03      	ldmia	r5!, {r0, r1}
 80231b2:	6020      	str	r0, [r4, #0]
 80231b4:	6061      	str	r1, [r4, #4]
 80231b6:	882b      	ldrh	r3, [r5, #0]
 80231b8:	8123      	strh	r3, [r4, #8]
 80231ba:	4c1d      	ldr	r4, [pc, #116]	; (8023230 <custom_connect_and_send_data+0x344>)
 80231bc:	4620      	mov	r0, r4
 80231be:	f7fb ffa8 	bl	801f112 <crs_strlen>
 80231c2:	b283      	uxth	r3, r0
 80231c4:	4622      	mov	r2, r4
 80231c6:	2101      	movs	r1, #1
 80231c8:	2004      	movs	r0, #4
 80231ca:	f7fb ffe5 	bl	801f198 <traceIF_itmPrint>
 80231ce:	4620      	mov	r0, r4
 80231d0:	f7fb ff9f 	bl	801f112 <crs_strlen>
 80231d4:	b283      	uxth	r3, r0
 80231d6:	4622      	mov	r2, r4
 80231d8:	2101      	movs	r1, #1
 80231da:	2004      	movs	r0, #4
 80231dc:	f7fb fffe 	bl	801f1dc <traceIF_uartPrint>
	  result = false;
 80231e0:	2400      	movs	r4, #0
 80231e2:	e01f      	b.n	8023224 <custom_connect_and_send_data+0x338>
    	  PRINT_INFO("socket create NOK\n\r")
 80231e4:	4c12      	ldr	r4, [pc, #72]	; (8023230 <custom_connect_and_send_data+0x344>)
 80231e6:	4d1b      	ldr	r5, [pc, #108]	; (8023254 <custom_connect_and_send_data+0x368>)
 80231e8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80231ea:	6020      	str	r0, [r4, #0]
 80231ec:	6061      	str	r1, [r4, #4]
 80231ee:	60a2      	str	r2, [r4, #8]
 80231f0:	60e3      	str	r3, [r4, #12]
 80231f2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80231f4:	6120      	str	r0, [r4, #16]
 80231f6:	6161      	str	r1, [r4, #20]
 80231f8:	61a2      	str	r2, [r4, #24]
 80231fa:	782b      	ldrb	r3, [r5, #0]
 80231fc:	7723      	strb	r3, [r4, #28]
 80231fe:	4620      	mov	r0, r4
 8023200:	f7fb ff87 	bl	801f112 <crs_strlen>
 8023204:	b283      	uxth	r3, r0
 8023206:	4622      	mov	r2, r4
 8023208:	2101      	movs	r1, #1
 802320a:	2004      	movs	r0, #4
 802320c:	f7fb ffc4 	bl	801f198 <traceIF_itmPrint>
 8023210:	4620      	mov	r0, r4
 8023212:	f7fb ff7e 	bl	801f112 <crs_strlen>
 8023216:	b283      	uxth	r3, r0
 8023218:	4622      	mov	r2, r4
 802321a:	2101      	movs	r1, #1
 802321c:	2004      	movs	r0, #4
 802321e:	f7fb ffdd 	bl	801f1dc <traceIF_uartPrint>
	  result = false;
 8023222:	2400      	movs	r4, #0
}
 8023224:	4620      	mov	r0, r4
 8023226:	b008      	add	sp, #32
 8023228:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802322c:	080361e0 	.word	0x080361e0
 8023230:	20004adc 	.word	0x20004adc
 8023234:	0803620c 	.word	0x0803620c
 8023238:	9298b523 	.word	0x9298b523
 802323c:	08036250 	.word	0x08036250
 8023240:	08036260 	.word	0x08036260
 8023244:	0803627c 	.word	0x0803627c
 8023248:	08036298 	.word	0x08036298
 802324c:	080362b8 	.word	0x080362b8
 8023250:	080362e4 	.word	0x080362e4
 8023254:	08036310 	.word	0x08036310
 8023258:	08036228 	.word	0x08036228

0802325c <custom_client_cmd_help>:
{
 802325c:	b570      	push	{r4, r5, r6, lr}
  if ((cmd_p != NULL)
 802325e:	2800      	cmp	r0, #0
 8023260:	d038      	beq.n	80232d4 <custom_client_cmd_help+0x78>
 8023262:	4602      	mov	r2, r0
      && (arg_p != NULL))
 8023264:	2900      	cmp	r1, #0
 8023266:	d037      	beq.n	80232d8 <custom_client_cmd_help+0x7c>
    PRINT_APP("%s bad parameter %s !!!\n\r", cmd_p, arg_p)
 8023268:	4c1c      	ldr	r4, [pc, #112]	; (80232dc <custom_client_cmd_help+0x80>)
 802326a:	460b      	mov	r3, r1
 802326c:	491c      	ldr	r1, [pc, #112]	; (80232e0 <custom_client_cmd_help+0x84>)
 802326e:	4620      	mov	r0, r4
 8023270:	f002 fcfe 	bl	8025c70 <sprintf>
 8023274:	4620      	mov	r0, r4
 8023276:	f7fb ff4c 	bl	801f112 <crs_strlen>
 802327a:	b283      	uxth	r3, r0
 802327c:	4622      	mov	r2, r4
 802327e:	2101      	movs	r1, #1
 8023280:	2004      	movs	r0, #4
 8023282:	f7fb ff89 	bl	801f198 <traceIF_itmPrint>
 8023286:	4620      	mov	r0, r4
 8023288:	f7fb ff43 	bl	801f112 <crs_strlen>
 802328c:	b282      	uxth	r2, r0
 802328e:	4621      	mov	r1, r4
 8023290:	2004      	movs	r0, #4
 8023292:	f7fb ffbb 	bl	801f20c <traceIF_uartPrintForce>
    result = CMD_SYNTAX_ERROR;
 8023296:	2601      	movs	r6, #1
  CMD_print_help(custom_client_cmd_label);
 8023298:	4d12      	ldr	r5, [pc, #72]	; (80232e4 <custom_client_cmd_help+0x88>)
 802329a:	4628      	mov	r0, r5
 802329c:	f7fe ffd8 	bl	8022250 <CMD_print_help>
  PRINT_APP("%s help       : display all commands supported by %s\n\r",
 80232a0:	4c0e      	ldr	r4, [pc, #56]	; (80232dc <custom_client_cmd_help+0x80>)
 80232a2:	462b      	mov	r3, r5
 80232a4:	462a      	mov	r2, r5
 80232a6:	4910      	ldr	r1, [pc, #64]	; (80232e8 <custom_client_cmd_help+0x8c>)
 80232a8:	4620      	mov	r0, r4
 80232aa:	f002 fce1 	bl	8025c70 <sprintf>
 80232ae:	4620      	mov	r0, r4
 80232b0:	f7fb ff2f 	bl	801f112 <crs_strlen>
 80232b4:	b283      	uxth	r3, r0
 80232b6:	4622      	mov	r2, r4
 80232b8:	2101      	movs	r1, #1
 80232ba:	2004      	movs	r0, #4
 80232bc:	f7fb ff6c 	bl	801f198 <traceIF_itmPrint>
 80232c0:	4620      	mov	r0, r4
 80232c2:	f7fb ff26 	bl	801f112 <crs_strlen>
 80232c6:	b282      	uxth	r2, r0
 80232c8:	4621      	mov	r1, r4
 80232ca:	2004      	movs	r0, #4
 80232cc:	f7fb ff9e 	bl	801f20c <traceIF_uartPrintForce>
}
 80232d0:	4630      	mov	r0, r6
 80232d2:	bd70      	pop	{r4, r5, r6, pc}
    result = CMD_OK;
 80232d4:	2600      	movs	r6, #0
 80232d6:	e7df      	b.n	8023298 <custom_client_cmd_help+0x3c>
 80232d8:	2600      	movs	r6, #0
 80232da:	e7dd      	b.n	8023298 <custom_client_cmd_help+0x3c>
 80232dc:	20004adc 	.word	0x20004adc
 80232e0:	08036330 	.word	0x08036330
 80232e4:	0803634c 	.word	0x0803634c
 80232e8:	08036354 	.word	0x08036354

080232ec <custom_client_cmd>:
{
 80232ec:	b530      	push	{r4, r5, lr}
 80232ee:	b08b      	sub	sp, #44	; 0x2c
 80232f0:	4605      	mov	r5, r0
  PRINT_APP("\n\r")
 80232f2:	4c36      	ldr	r4, [pc, #216]	; (80233cc <custom_client_cmd+0xe0>)
 80232f4:	4b36      	ldr	r3, [pc, #216]	; (80233d0 <custom_client_cmd+0xe4>)
 80232f6:	881a      	ldrh	r2, [r3, #0]
 80232f8:	789b      	ldrb	r3, [r3, #2]
 80232fa:	8022      	strh	r2, [r4, #0]
 80232fc:	70a3      	strb	r3, [r4, #2]
 80232fe:	4620      	mov	r0, r4
 8023300:	f7fb ff07 	bl	801f112 <crs_strlen>
 8023304:	b283      	uxth	r3, r0
 8023306:	4622      	mov	r2, r4
 8023308:	2101      	movs	r1, #1
 802330a:	2004      	movs	r0, #4
 802330c:	f7fb ff44 	bl	801f198 <traceIF_itmPrint>
 8023310:	4620      	mov	r0, r4
 8023312:	f7fb fefe 	bl	801f112 <crs_strlen>
 8023316:	b282      	uxth	r2, r0
 8023318:	4621      	mov	r1, r4
 802331a:	2004      	movs	r0, #4
 802331c:	f7fb ff76 	bl	801f20c <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8023320:	492c      	ldr	r1, [pc, #176]	; (80233d4 <custom_client_cmd+0xe8>)
 8023322:	4628      	mov	r0, r5
 8023324:	f002 fd32 	bl	8025d8c <strtok>
 8023328:	4605      	mov	r5, r0
             crs_strlen(cmd_p))
 802332a:	f7fb fef2 	bl	801f112 <crs_strlen>
 802332e:	4602      	mov	r2, r0
  if (memcmp((CRC_CHAR_t *)cmd_p,
 8023330:	4929      	ldr	r1, [pc, #164]	; (80233d8 <custom_client_cmd+0xec>)
 8023332:	4628      	mov	r0, r5
 8023334:	f002 fcff 	bl	8025d36 <memcmp>
 8023338:	b110      	cbz	r0, 8023340 <custom_client_cmd+0x54>
  cmd_status = CMD_OK;
 802333a:	2000      	movs	r0, #0
}
 802333c:	b00b      	add	sp, #44	; 0x2c
 802333e:	bd30      	pop	{r4, r5, pc}
    for (argc = 0U; argc < 10U; argc++)
 8023340:	2400      	movs	r4, #0
 8023342:	2c09      	cmp	r4, #9
 8023344:	d80b      	bhi.n	802335e <custom_client_cmd+0x72>
      argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 8023346:	4923      	ldr	r1, [pc, #140]	; (80233d4 <custom_client_cmd+0xe8>)
 8023348:	2000      	movs	r0, #0
 802334a:	f002 fd1f 	bl	8025d8c <strtok>
 802334e:	ab0a      	add	r3, sp, #40	; 0x28
 8023350:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8023354:	f843 0c28 	str.w	r0, [r3, #-40]
      if (argv_p[argc] == NULL)
 8023358:	b108      	cbz	r0, 802335e <custom_client_cmd+0x72>
    for (argc = 0U; argc < 10U; argc++)
 802335a:	3401      	adds	r4, #1
 802335c:	e7f1      	b.n	8023342 <custom_client_cmd+0x56>
    if (argc == 0U)
 802335e:	b90c      	cbnz	r4, 8023364 <custom_client_cmd+0x78>
  cmd_status = CMD_OK;
 8023360:	2000      	movs	r0, #0
 8023362:	e7eb      	b.n	802333c <custom_client_cmd+0x50>
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8023364:	9c00      	ldr	r4, [sp, #0]
                    crs_strlen(argv_p[0])) == 0)
 8023366:	4620      	mov	r0, r4
 8023368:	f7fb fed3 	bl	801f112 <crs_strlen>
 802336c:	4602      	mov	r2, r0
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 802336e:	491b      	ldr	r1, [pc, #108]	; (80233dc <custom_client_cmd+0xf0>)
 8023370:	4620      	mov	r0, r4
 8023372:	f002 fce0 	bl	8025d36 <memcmp>
 8023376:	b188      	cbz	r0, 802339c <custom_client_cmd+0xb0>
                    crs_strlen(argv_p[0])) == 0)
 8023378:	4620      	mov	r0, r4
 802337a:	f7fb feca 	bl	801f112 <crs_strlen>
 802337e:	4602      	mov	r2, r0
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8023380:	4917      	ldr	r1, [pc, #92]	; (80233e0 <custom_client_cmd+0xf4>)
 8023382:	4620      	mov	r0, r4
 8023384:	f002 fcd7 	bl	8025d36 <memcmp>
 8023388:	b9d0      	cbnz	r0, 80233c0 <custom_client_cmd+0xd4>
      cmd_status = custom_client_cmd_help(NULL, NULL);
 802338a:	2100      	movs	r1, #0
 802338c:	4608      	mov	r0, r1
 802338e:	f7ff ff65 	bl	802325c <custom_client_cmd_help>
 8023392:	e7d3      	b.n	802333c <custom_client_cmd+0x50>
			vTaskDelay( xDelay );
 8023394:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8023398:	f001 fec0 	bl	802511c <vTaskDelay>
			if (custom_connect_and_send_data(logBuffer.data, logBuffer.data_len)== true)
 802339c:	4811      	ldr	r0, [pc, #68]	; (80233e4 <custom_client_cmd+0xf8>)
 802339e:	f8d0 1400 	ldr.w	r1, [r0, #1024]	; 0x400
 80233a2:	f7ff fda3 	bl	8022eec <custom_connect_and_send_data>
 80233a6:	2800      	cmp	r0, #0
 80233a8:	d0f4      	beq.n	8023394 <custom_client_cmd+0xa8>
				memset(logBuffer.data, 0, sizeof(logBuffer.data));
 80233aa:	4c0e      	ldr	r4, [pc, #56]	; (80233e4 <custom_client_cmd+0xf8>)
 80233ac:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80233b0:	2100      	movs	r1, #0
 80233b2:	4620      	mov	r0, r4
 80233b4:	f002 fccf 	bl	8025d56 <memset>
				logBuffer.data_len=0;
 80233b8:	2300      	movs	r3, #0
 80233ba:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
 80233be:	e7e9      	b.n	8023394 <custom_client_cmd+0xa8>
      cmd_status = custom_client_cmd_help(cmd_p, argv_p[0]);
 80233c0:	4621      	mov	r1, r4
 80233c2:	4628      	mov	r0, r5
 80233c4:	f7ff ff4a 	bl	802325c <custom_client_cmd_help>
 80233c8:	e7b8      	b.n	802333c <custom_client_cmd+0x50>
 80233ca:	bf00      	nop
 80233cc:	20004adc 	.word	0x20004adc
 80233d0:	0802deec 	.word	0x0802deec
 80233d4:	08032b44 	.word	0x08032b44
 80233d8:	0803634c 	.word	0x0803634c
 80233dc:	08032c24 	.word	0x08032c24
 80233e0:	08032b48 	.word	0x08032b48
 80233e4:	20005cac 	.word	0x20005cac

080233e8 <custom_client_notif_cb>:
  if (dc_event_id == DC_CELLULAR_NIFMAN_INFO)
 80233e8:	b283      	uxth	r3, r0
 80233ea:	4a2e      	ldr	r2, [pc, #184]	; (80234a4 <custom_client_notif_cb+0xbc>)
 80233ec:	8811      	ldrh	r1, [r2, #0]
 80233ee:	428b      	cmp	r3, r1
 80233f0:	d000      	beq.n	80233f4 <custom_client_notif_cb+0xc>
 80233f2:	4770      	bx	lr
{
 80233f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80233f6:	b085      	sub	sp, #20
 80233f8:	4604      	mov	r4, r0
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_NIFMAN_INFO,
 80233fa:	2310      	movs	r3, #16
 80233fc:	466a      	mov	r2, sp
 80233fe:	482a      	ldr	r0, [pc, #168]	; (80234a8 <custom_client_notif_cb+0xc0>)
 8023400:	f7fe fae2 	bl	80219c8 <dc_com_read>
    if (dc_nifman_info.rt_state == DC_SERVICE_ON)
 8023404:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8023408:	2b07      	cmp	r3, #7
 802340a:	d022      	beq.n	8023452 <custom_client_notif_cb+0x6a>
      custom_client_modem_is_attached = false;
 802340c:	4b27      	ldr	r3, [pc, #156]	; (80234ac <custom_client_notif_cb+0xc4>)
 802340e:	2200      	movs	r2, #0
 8023410:	701a      	strb	r2, [r3, #0]
      PRINT_APP("CustomClt: Network is DOWN\n\r")
 8023412:	4c27      	ldr	r4, [pc, #156]	; (80234b0 <custom_client_notif_cb+0xc8>)
 8023414:	4d27      	ldr	r5, [pc, #156]	; (80234b4 <custom_client_notif_cb+0xcc>)
 8023416:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023418:	6020      	str	r0, [r4, #0]
 802341a:	6061      	str	r1, [r4, #4]
 802341c:	60a2      	str	r2, [r4, #8]
 802341e:	60e3      	str	r3, [r4, #12]
 8023420:	cd07      	ldmia	r5!, {r0, r1, r2}
 8023422:	6120      	str	r0, [r4, #16]
 8023424:	6161      	str	r1, [r4, #20]
 8023426:	61a2      	str	r2, [r4, #24]
 8023428:	782b      	ldrb	r3, [r5, #0]
 802342a:	7723      	strb	r3, [r4, #28]
 802342c:	4620      	mov	r0, r4
 802342e:	f7fb fe70 	bl	801f112 <crs_strlen>
 8023432:	b283      	uxth	r3, r0
 8023434:	4622      	mov	r2, r4
 8023436:	2101      	movs	r1, #1
 8023438:	2004      	movs	r0, #4
 802343a:	f7fb fead 	bl	801f198 <traceIF_itmPrint>
 802343e:	4620      	mov	r0, r4
 8023440:	f7fb fe67 	bl	801f112 <crs_strlen>
 8023444:	b282      	uxth	r2, r0
 8023446:	4621      	mov	r1, r4
 8023448:	2004      	movs	r0, #4
 802344a:	f7fb fedf 	bl	801f20c <traceIF_uartPrintForce>
}
 802344e:	b005      	add	sp, #20
 8023450:	bdf0      	pop	{r4, r5, r6, r7, pc}
      custom_client_modem_is_attached = true;
 8023452:	2701      	movs	r7, #1
 8023454:	4b15      	ldr	r3, [pc, #84]	; (80234ac <custom_client_notif_cb+0xc4>)
 8023456:	701f      	strb	r7, [r3, #0]
      PRINT_APP("CustomClt: Network is UP\n\r")
 8023458:	4d15      	ldr	r5, [pc, #84]	; (80234b0 <custom_client_notif_cb+0xc8>)
 802345a:	4e17      	ldr	r6, [pc, #92]	; (80234b8 <custom_client_notif_cb+0xd0>)
 802345c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 802345e:	6028      	str	r0, [r5, #0]
 8023460:	6069      	str	r1, [r5, #4]
 8023462:	60aa      	str	r2, [r5, #8]
 8023464:	60eb      	str	r3, [r5, #12]
 8023466:	ce03      	ldmia	r6!, {r0, r1}
 8023468:	6128      	str	r0, [r5, #16]
 802346a:	6169      	str	r1, [r5, #20]
 802346c:	8832      	ldrh	r2, [r6, #0]
 802346e:	78b3      	ldrb	r3, [r6, #2]
 8023470:	832a      	strh	r2, [r5, #24]
 8023472:	76ab      	strb	r3, [r5, #26]
 8023474:	4628      	mov	r0, r5
 8023476:	f7fb fe4c 	bl	801f112 <crs_strlen>
 802347a:	b283      	uxth	r3, r0
 802347c:	462a      	mov	r2, r5
 802347e:	4639      	mov	r1, r7
 8023480:	2004      	movs	r0, #4
 8023482:	f7fb fe89 	bl	801f198 <traceIF_itmPrint>
 8023486:	4628      	mov	r0, r5
 8023488:	f7fb fe43 	bl	801f112 <crs_strlen>
 802348c:	b282      	uxth	r2, r0
 802348e:	4629      	mov	r1, r5
 8023490:	2004      	movs	r0, #4
 8023492:	f7fb febb 	bl	801f20c <traceIF_uartPrintForce>
      (void)rtosalMessageQueuePut(custom_client_queue, (uint32_t)dc_event_id, 0U);
 8023496:	2200      	movs	r2, #0
 8023498:	4621      	mov	r1, r4
 802349a:	4b08      	ldr	r3, [pc, #32]	; (80234bc <custom_client_notif_cb+0xd4>)
 802349c:	6818      	ldr	r0, [r3, #0]
 802349e:	f7fb fd66 	bl	801ef6e <rtosalMessageQueuePut>
 80234a2:	e7d4      	b.n	802344e <custom_client_notif_cb+0x66>
 80234a4:	2000023a 	.word	0x2000023a
 80234a8:	200058b0 	.word	0x200058b0
 80234ac:	20005ca4 	.word	0x20005ca4
 80234b0:	20004adc 	.word	0x20004adc
 80234b4:	080363a8 	.word	0x080363a8
 80234b8:	0803638c 	.word	0x0803638c
 80234bc:	20005ca8 	.word	0x20005ca8

080234c0 <custom_client_init>:
  * @note   Custom Client initialization
  * @param  -
  * @retval -
  */
void custom_client_init(void)
{
 80234c0:	b508      	push	{r3, lr}
  /* Custom Client static initialization */

  /* Example: */
  custom_client_modem_is_attached = false;
 80234c2:	2000      	movs	r0, #0
 80234c4:	4b07      	ldr	r3, [pc, #28]	; (80234e4 <custom_client_init+0x24>)
 80234c6:	7018      	strb	r0, [r3, #0]

  /* CustomClient queue creation */
  custom_client_queue = rtosalMessageQueueNew(NULL, 1U);
 80234c8:	2101      	movs	r1, #1
 80234ca:	f7fb fd44 	bl	801ef56 <rtosalMessageQueueNew>
 80234ce:	4b06      	ldr	r3, [pc, #24]	; (80234e8 <custom_client_init+0x28>)
 80234d0:	6018      	str	r0, [r3, #0]
  if (custom_client_queue == NULL)
 80234d2:	b100      	cbz	r0, 80234d6 <custom_client_init+0x16>
  {
    ERROR_Handler(DBG_CHAN_CUSTOMCLIENT, 1, ERROR_FATAL);
  }
}
 80234d4:	bd08      	pop	{r3, pc}
    ERROR_Handler(DBG_CHAN_CUSTOMCLIENT, 1, ERROR_FATAL);
 80234d6:	2203      	movs	r2, #3
 80234d8:	2101      	movs	r1, #1
 80234da:	2004      	movs	r0, #4
 80234dc:	f7fa fe36 	bl	801e14c <ERROR_Handler>
}
 80234e0:	e7f8      	b.n	80234d4 <custom_client_init+0x14>
 80234e2:	bf00      	nop
 80234e4:	20005ca4 	.word	0x20005ca4
 80234e8:	20005ca8 	.word	0x20005ca8

080234ec <custom_client_start>:
  * @note   Custom Client start
  * @param  -
  * @retval -
  */
void custom_client_start(void)
{
 80234ec:	b500      	push	{lr}
 80234ee:	b083      	sub	sp, #12

  /* Cellular is now initialized
    Registration to other components is now possible */

  /* Registration to datacache */
  (void)dc_com_register_gen_event_cb(&dc_com_db, custom_client_notif_cb, (void *) NULL);
 80234f0:	2200      	movs	r2, #0
 80234f2:	490e      	ldr	r1, [pc, #56]	; (802352c <custom_client_start+0x40>)
 80234f4:	480e      	ldr	r0, [pc, #56]	; (8023530 <custom_client_start+0x44>)
 80234f6:	f7fe f9eb 	bl	80218d0 <dc_com_register_gen_event_cb>

#if ((USE_CMD_CONSOLE == 1)  && (CUSTOM_CLIENT_CMD != 0U))
  CMD_Declare(custom_client_cmd_label, custom_client_cmd, (uint8_t *)"customclient commands");
 80234fa:	4a0e      	ldr	r2, [pc, #56]	; (8023534 <custom_client_start+0x48>)
 80234fc:	490e      	ldr	r1, [pc, #56]	; (8023538 <custom_client_start+0x4c>)
 80234fe:	480f      	ldr	r0, [pc, #60]	; (802353c <custom_client_start+0x50>)
 8023500:	f7fe fe46 	bl	8022190 <CMD_Declare>
#endif /* (USE_CMD_CONSOLE == 1) && (CUSTOM_CLIENT_CMD != 0U) */

  /* Create CustomClient thread  */
  CustomClient_TaskHandle = rtosalThreadNew((const rtosal_char_t *)"CustomCltThread", (os_pthread)custom_client_thread,
 8023504:	2200      	movs	r2, #0
 8023506:	9200      	str	r2, [sp, #0]
 8023508:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 802350c:	490c      	ldr	r1, [pc, #48]	; (8023540 <custom_client_start+0x54>)
 802350e:	480d      	ldr	r0, [pc, #52]	; (8023544 <custom_client_start+0x58>)
 8023510:	f7fb fced 	bl	801eeee <rtosalThreadNew>
 8023514:	4b0c      	ldr	r3, [pc, #48]	; (8023548 <custom_client_start+0x5c>)
 8023516:	6018      	str	r0, [r3, #0]
                                            CUSTOMCLIENT_THREAD_PRIO, CUSTOMCLIENT_THREAD_STACK_SIZE, NULL);

  if (CustomClient_TaskHandle == NULL)
 8023518:	b110      	cbz	r0, 8023520 <custom_client_start+0x34>
  {
#if (USE_STACK_ANALYSIS == 1)
    (void)stackAnalysis_addStackSizeByHandle(CustomClient_TaskHandle, CUSTOMCLIENT_THREAD_STACK_SIZE);
#endif /* USE_STACK_ANALYSIS == 1 */
  }
}
 802351a:	b003      	add	sp, #12
 802351c:	f85d fb04 	ldr.w	pc, [sp], #4
    ERROR_Handler(DBG_CHAN_CUSTOMCLIENT, 2, ERROR_FATAL);
 8023520:	2203      	movs	r2, #3
 8023522:	2102      	movs	r1, #2
 8023524:	2004      	movs	r0, #4
 8023526:	f7fa fe11 	bl	801e14c <ERROR_Handler>
}
 802352a:	e7f6      	b.n	802351a <custom_client_start+0x2e>
 802352c:	080233e9 	.word	0x080233e9
 8023530:	200058b0 	.word	0x200058b0
 8023534:	080363c8 	.word	0x080363c8
 8023538:	080232ed 	.word	0x080232ed
 802353c:	0803634c 	.word	0x0803634c
 8023540:	08022ec5 	.word	0x08022ec5
 8023544:	080363e0 	.word	0x080363e0
 8023548:	20005ca0 	.word	0x20005ca0

0802354c <applications_init>:
  * @brief  Initialize the applications
  * @param  -
  * @retval -
  */
static void applications_init(void)
{
 802354c:	b508      	push	{r3, lr}
#if (USE_CUSTOM_CLIENT == 1)
  custom_client_init();
 802354e:	f7ff ffb7 	bl	80234c0 <custom_client_init>
#endif /* (USE_COM_CLIENT == 1)  */

#if (USE_MQTT_CLIENT == 1)
  mqttclient_init();
#endif /* (USE_MQTT_CLIENT == 1) */
}
 8023552:	bd08      	pop	{r3, pc}

08023554 <utilities_init>:
  * @brief  Initialize the utilities
  * @param  -
  * @retval -
  */
static void utilities_init(void)
{
 8023554:	b508      	push	{r3, lr}
  /* call to stackAnalysis_init() must be done earlier */
#if ((USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1))
  dc_mems_init();
 8023556:	f7ff fbc5 	bl	8022ce4 <dc_mems_init>
#endif /* (USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1) */

#if (USE_DC_GENERIC == 1)
  dc_generic_init();
#endif /* (USE_DC_GENERIC == 1) */
}
 802355a:	bd08      	pop	{r3, pc}

0802355c <applications_start>:
  * @brief  Start the applications
  * @param  -
  * @retval -
  */
static void applications_start(void)
{
 802355c:	b508      	push	{r3, lr}
#if (USE_CUSTOM_CLIENT == 1)
  custom_client_start();
 802355e:	f7ff ffc5 	bl	80234ec <custom_client_start>
#endif /* (USE_COM_CLIENT == 1)  */

#if (USE_MQTT_CLIENT == 1)
  mqttclient_start();
#endif /* (USE_MQTT_CLIENT == 1) */
}
 8023562:	bd08      	pop	{r3, pc}

08023564 <utilities_start>:
  * @brief  Start the utilities
  * @param  -
  * @retval -
  */
static void utilities_start(void)
{
 8023564:	b508      	push	{r3, lr}
#if (USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1)
  dc_mems_start();
 8023566:	f7ff fc3f 	bl	8022de8 <dc_mems_start>
#endif /* (USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1) */

#if (USE_DC_GENERIC == 1)
  dc_generic_start();
#endif /* (USE_DC_GENERIC == 1) */
}
 802356a:	bd08      	pop	{r3, pc}

0802356c <StartDefaultTask>:
}


/* StartDefaultTask function */
void StartDefaultTask(void *p_argument)
{
 802356c:	b508      	push	{r3, lr}
  UNUSED(p_argument);

  /* RandomNumberGenerator */
  srand(rtosalGetSysTimerCount());
 802356e:	f7fb fcba 	bl	801eee6 <rtosalGetSysTimerCount>
 8023572:	f002 fa95 	bl	8025aa0 <srand>
  (void)board_buttons_init();
#endif /* USE_BUTTONS == 1 */

#if (USE_LEDS == 1)
  /* Board Leds initialization    */
  (void)board_leds_init();
 8023576:	f7fa fe93 	bl	801e2a0 <board_leds_init>
#endif /* USE_LEDS == 1 */

#if (USE_PRINTF == 0U)
  /* Error Handler in the modules below may use trace print */
  /* Recall traceIF_init() in case MX_FREERTOS_Init is not used or is redefined */
  traceIF_init();
 802357a:	f7fc fa5b 	bl	801fa34 <traceIF_init>
  (void)stackAnalysis_addStackSizeByHandle(xTimerGetTimerDaemonTaskHandle(),
                                           (uint16_t)configTIMER_TASK_STACK_DEPTH);
#endif /* USE_STACK_ANALYSIS == 1 */

#if (USE_CMD_CONSOLE == 1)
  CMD_init();
 802357e:	f7fe fe85 	bl	802228c <CMD_init>

  /* Cellular components statical init */
#if (USE_NETWORK_LIBRARY == 1)
  cellular_net_init();
#else
  cellular_init();
 8023582:	f7fc fb0b 	bl	801fb9c <cellular_init>
#endif /* (USE_NETWORK_LIBRARY == 1) */

  /* Application components statical init  */
  applications_init();
 8023586:	f7ff ffe1 	bl	802354c <applications_init>

  /* Other optional components statical init */
  utilities_init();
 802358a:	f7ff ffe3 	bl	8023554 <utilities_init>
    (void)board_buttons_start();
#endif /* USE_BUTTONS == 1 */

#if (USE_LEDS == 1)
    /* Board Leds start    */
    (void)board_leds_start();
 802358e:	f7fa fe93 	bl	801e2b8 <board_leds_start>

    /* Cellular components start */
#if (USE_NETWORK_LIBRARY == 1)
    cellular_net_start();
#else
    cellular_start();
 8023592:	f7fc fb13 	bl	801fbbc <cellular_start>
#endif /* (USE_NETWORK_LIBRARY == 1) */

    /* Application components start */
    applications_start();
 8023596:	f7ff ffe1 	bl	802355c <applications_start>

    /* Utilities components start */
    utilities_start();
 802359a:	f7ff ffe3 	bl	8023564 <utilities_start>
  }

#if (USE_CMD_CONSOLE == 1)
  CMD_start();
 802359e:	f7fe fec9 	bl	8022334 <CMD_start>
  /* If stack analysis is activated check stack overflow after all init/start */
  (void)stackAnalysis_trace();
#endif /* USE_STACK_ANALYSIS == 1 */
  /* Platform Initialization and Thread Start are done */
  /* No more need of this thread wait a little before to free the memory */
  (void)rtosalDelay(2000U);
 80235a2:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80235a6:	f7fb fd0c 	bl	801efc2 <rtosalDelay>
  vTaskDelete(NULL);
 80235aa:	2000      	movs	r0, #0
 80235ac:	f001 fbe6 	bl	8024d7c <vTaskDelete>
}
 80235b0:	bd08      	pop	{r3, pc}
	...

080235b4 <MX_FREERTOS_Init>:
{
 80235b4:	b500      	push	{lr}
 80235b6:	b083      	sub	sp, #12
  defaultTaskHandle = rtosalThreadNew((const rtosal_char_t *)"StartDefaultThread", (os_pthread)StartDefaultTask,
 80235b8:	2300      	movs	r3, #0
 80235ba:	9300      	str	r3, [sp, #0]
 80235bc:	f44f 73c0 	mov.w	r3, #384	; 0x180
 80235c0:	2201      	movs	r2, #1
 80235c2:	4909      	ldr	r1, [pc, #36]	; (80235e8 <MX_FREERTOS_Init+0x34>)
 80235c4:	4809      	ldr	r0, [pc, #36]	; (80235ec <MX_FREERTOS_Init+0x38>)
 80235c6:	f7fb fc92 	bl	801eeee <rtosalThreadNew>
 80235ca:	4b09      	ldr	r3, [pc, #36]	; (80235f0 <MX_FREERTOS_Init+0x3c>)
 80235cc:	6018      	str	r0, [r3, #0]
  if (defaultTaskHandle == NULL)
 80235ce:	b110      	cbz	r0, 80235d6 <MX_FREERTOS_Init+0x22>
}
 80235d0:	b003      	add	sp, #12
 80235d2:	f85d fb04 	ldr.w	pc, [sp], #4
    traceIF_init();
 80235d6:	f7fc fa2d 	bl	801fa34 <traceIF_init>
    ERROR_Handler(DBG_CHAN_MAIN, 0, ERROR_FATAL);
 80235da:	2203      	movs	r2, #3
 80235dc:	2100      	movs	r1, #0
 80235de:	2001      	movs	r0, #1
 80235e0:	f7fa fdb4 	bl	801e14c <ERROR_Handler>
}
 80235e4:	e7f4      	b.n	80235d0 <MX_FREERTOS_Init+0x1c>
 80235e6:	bf00      	nop
 80235e8:	0802356d 	.word	0x0802356d
 80235ec:	080363f0 	.word	0x080363f0
 80235f0:	200060b0 	.word	0x200060b0

080235f4 <makeFreeRtosPriority>:
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 80235f4:	2884      	cmp	r0, #132	; 0x84
 80235f6:	d001      	beq.n	80235fc <makeFreeRtosPriority+0x8>
    fpriority += (priority - osPriorityIdle);
 80235f8:	3003      	adds	r0, #3
 80235fa:	4770      	bx	lr
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80235fc:	2000      	movs	r0, #0
  }
  
  return fpriority;
}
 80235fe:	4770      	bx	lr

08023600 <inHandlerMode>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8023600:	f3ef 8005 	mrs	r0, IPSR

/* Determine whether we are in thread mode or handler mode. */
static int inHandlerMode (void)
{
  return __get_IPSR() != 0;
}
 8023604:	3800      	subs	r0, #0
 8023606:	bf18      	it	ne
 8023608:	2001      	movne	r0, #1
 802360a:	4770      	bx	lr

0802360c <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 802360c:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 802360e:	f001 fc25 	bl	8024e5c <vTaskStartScheduler>
  
  return osOK;
}
 8023612:	2000      	movs	r0, #0
 8023614:	bd08      	pop	{r3, pc}

08023616 <osKernelSysTick>:
* @param  None
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
 8023616:	b508      	push	{r3, lr}
  if (inHandlerMode()) {
 8023618:	f7ff fff2 	bl	8023600 <inHandlerMode>
 802361c:	b110      	cbz	r0, 8023624 <osKernelSysTick+0xe>
    return xTaskGetTickCountFromISR();
 802361e:	f001 fc6d 	bl	8024efc <xTaskGetTickCountFromISR>
  }
  else {
    return xTaskGetTickCount();
  }
}
 8023622:	bd08      	pop	{r3, pc}
    return xTaskGetTickCount();
 8023624:	f001 fc64 	bl	8024ef0 <xTaskGetTickCount>
 8023628:	e7fb      	b.n	8023622 <osKernelSysTick+0xc>

0802362a <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 802362a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802362c:	b085      	sub	sp, #20
 802362e:	460c      	mov	r4, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8023630:	6845      	ldr	r5, [r0, #4]
 8023632:	6806      	ldr	r6, [r0, #0]
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 8023634:	6907      	ldr	r7, [r0, #16]
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8023636:	f9b0 0008 	ldrsh.w	r0, [r0, #8]
 802363a:	f7ff ffdb 	bl	80235f4 <makeFreeRtosPriority>
 802363e:	ab03      	add	r3, sp, #12
 8023640:	9301      	str	r3, [sp, #4]
 8023642:	9000      	str	r0, [sp, #0]
 8023644:	4623      	mov	r3, r4
 8023646:	b2ba      	uxth	r2, r7
 8023648:	4631      	mov	r1, r6
 802364a:	4628      	mov	r0, r5
 802364c:	f001 fb64 	bl	8024d18 <xTaskCreate>
 8023650:	2801      	cmp	r0, #1
 8023652:	d102      	bne.n	802365a <osThreadCreate+0x30>
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8023654:	9803      	ldr	r0, [sp, #12]
}
 8023656:	b005      	add	sp, #20
 8023658:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 802365a:	2000      	movs	r0, #0
 802365c:	e7fb      	b.n	8023656 <osThreadCreate+0x2c>

0802365e <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 802365e:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8023660:	b900      	cbnz	r0, 8023664 <osDelay+0x6>
 8023662:	2001      	movs	r0, #1
 8023664:	f001 fd5a 	bl	802511c <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8023668:	2000      	movs	r0, #0
 802366a:	bd08      	pop	{r3, pc}

0802366c <osTimerCreate>:
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*/
osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 802366c:	b500      	push	{lr}
 802366e:	b083      	sub	sp, #12
 8023670:	4613      	mov	r3, r2
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TimerCallbackFunction_t)timer_def->ptimer,
                      (StaticTimer_t *)timer_def->controlblock);  
#else
  return xTimerCreate((const char *)"",
 8023672:	2901      	cmp	r1, #1
 8023674:	d009      	beq.n	802368a <osTimerCreate+0x1e>
 8023676:	2200      	movs	r2, #0
                      1, // period should be filled when starting the Timer using osTimerStart
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TimerCallbackFunction_t)timer_def->ptimer);
 8023678:	6801      	ldr	r1, [r0, #0]
  return xTimerCreate((const char *)"",
 802367a:	9100      	str	r1, [sp, #0]
 802367c:	2101      	movs	r1, #1
 802367e:	4804      	ldr	r0, [pc, #16]	; (8023690 <osTimerCreate+0x24>)
 8023680:	f002 f86e 	bl	8025760 <xTimerCreate>
#endif

#else 
	return NULL;
#endif
}
 8023684:	b003      	add	sp, #12
 8023686:	f85d fb04 	ldr.w	pc, [sp], #4
  return xTimerCreate((const char *)"",
 802368a:	2201      	movs	r2, #1
 802368c:	e7f4      	b.n	8023678 <osTimerCreate+0xc>
 802368e:	bf00      	nop
 8023690:	08034f74 	.word	0x08034f74

08023694 <osTimerStart>:
* @param  millisec      time delay value of the timer.
* @retval  status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
{
 8023694:	b530      	push	{r4, r5, lr}
 8023696:	b085      	sub	sp, #20
 8023698:	4604      	mov	r4, r0
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 802369a:	2300      	movs	r3, #0
 802369c:	9303      	str	r3, [sp, #12]
  TickType_t ticks = millisec / portTICK_PERIOD_MS;

  if (ticks == 0)
 802369e:	460d      	mov	r5, r1
 80236a0:	b901      	cbnz	r1, 80236a4 <osTimerStart+0x10>
    ticks = 1;
 80236a2:	2501      	movs	r5, #1
    
  if (inHandlerMode()) 
 80236a4:	f7ff ffac 	bl	8023600 <inHandlerMode>
 80236a8:	b1d0      	cbz	r0, 80236e0 <osTimerStart+0x4c>
  {
    if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
 80236aa:	2300      	movs	r3, #0
 80236ac:	9300      	str	r3, [sp, #0]
 80236ae:	ab03      	add	r3, sp, #12
 80236b0:	462a      	mov	r2, r5
 80236b2:	2109      	movs	r1, #9
 80236b4:	4620      	mov	r0, r4
 80236b6:	f002 f86f 	bl	8025798 <xTimerGenericCommand>
 80236ba:	2801      	cmp	r0, #1
 80236bc:	d002      	beq.n	80236c4 <osTimerStart+0x30>
    {
      result = osErrorOS;
 80236be:	20ff      	movs	r0, #255	; 0xff

#else 
  result = osErrorOS;
#endif
  return result;
}
 80236c0:	b005      	add	sp, #20
 80236c2:	bd30      	pop	{r4, r5, pc}
      portEND_SWITCHING_ISR(taskWoken);     
 80236c4:	9b03      	ldr	r3, [sp, #12]
 80236c6:	b1c3      	cbz	r3, 80236fa <osTimerStart+0x66>
 80236c8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80236cc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80236d0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80236d4:	f3bf 8f4f 	dsb	sy
 80236d8:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 80236dc:	2000      	movs	r0, #0
 80236de:	e7ef      	b.n	80236c0 <osTimerStart+0x2c>
    if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
 80236e0:	2300      	movs	r3, #0
 80236e2:	9300      	str	r3, [sp, #0]
 80236e4:	462a      	mov	r2, r5
 80236e6:	2104      	movs	r1, #4
 80236e8:	4620      	mov	r0, r4
 80236ea:	f002 f855 	bl	8025798 <xTimerGenericCommand>
 80236ee:	2801      	cmp	r0, #1
 80236f0:	d001      	beq.n	80236f6 <osTimerStart+0x62>
      result = osErrorOS;
 80236f2:	20ff      	movs	r0, #255	; 0xff
  return result;
 80236f4:	e7e4      	b.n	80236c0 <osTimerStart+0x2c>
  osStatus result = osOK;
 80236f6:	2000      	movs	r0, #0
 80236f8:	e7e2      	b.n	80236c0 <osTimerStart+0x2c>
 80236fa:	2000      	movs	r0, #0
 80236fc:	e7e0      	b.n	80236c0 <osTimerStart+0x2c>

080236fe <osTimerStop>:
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStop (osTimerId timer_id)
{
 80236fe:	b510      	push	{r4, lr}
 8023700:	b084      	sub	sp, #16
 8023702:	4604      	mov	r4, r0
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 8023704:	2300      	movs	r3, #0
 8023706:	9303      	str	r3, [sp, #12]

  if (inHandlerMode()) {
 8023708:	f7ff ff7a 	bl	8023600 <inHandlerMode>
 802370c:	b1b0      	cbz	r0, 802373c <osTimerStop+0x3e>
    if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
 802370e:	2200      	movs	r2, #0
 8023710:	9200      	str	r2, [sp, #0]
 8023712:	ab03      	add	r3, sp, #12
 8023714:	2108      	movs	r1, #8
 8023716:	4620      	mov	r0, r4
 8023718:	f002 f83e 	bl	8025798 <xTimerGenericCommand>
 802371c:	2801      	cmp	r0, #1
 802371e:	d11b      	bne.n	8023758 <osTimerStop+0x5a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8023720:	9b03      	ldr	r3, [sp, #12]
 8023722:	b1db      	cbz	r3, 802375c <osTimerStop+0x5e>
 8023724:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023728:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802372c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8023730:	f3bf 8f4f 	dsb	sy
 8023734:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8023738:	2000      	movs	r0, #0
 802373a:	e009      	b.n	8023750 <osTimerStop+0x52>
  }
  else {
    if (xTimerStop(timer_id, 0) != pdPASS) {
 802373c:	2200      	movs	r2, #0
 802373e:	9200      	str	r2, [sp, #0]
 8023740:	4613      	mov	r3, r2
 8023742:	2103      	movs	r1, #3
 8023744:	4620      	mov	r0, r4
 8023746:	f002 f827 	bl	8025798 <xTimerGenericCommand>
 802374a:	2801      	cmp	r0, #1
 802374c:	d002      	beq.n	8023754 <osTimerStop+0x56>
      result = osErrorOS;
 802374e:	20ff      	movs	r0, #255	; 0xff
  }
#else 
  result = osErrorOS;
#endif 
  return result;
}
 8023750:	b004      	add	sp, #16
 8023752:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 8023754:	2000      	movs	r0, #0
 8023756:	e7fb      	b.n	8023750 <osTimerStop+0x52>
      return osErrorOS;
 8023758:	20ff      	movs	r0, #255	; 0xff
 802375a:	e7f9      	b.n	8023750 <osTimerStop+0x52>
  osStatus result = osOK;
 802375c:	2000      	movs	r0, #0
 802375e:	e7f7      	b.n	8023750 <osTimerStop+0x52>

08023760 <osMutexCreate>:
* @param  mutex_def     mutex definition referenced with \ref osMutex.
* @retval  mutex ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
*/
osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
{
 8023760:	b508      	push	{r3, lr}
    return xSemaphoreCreateMutex(); 
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
#else  
    return xSemaphoreCreateMutex(); 
 8023762:	2001      	movs	r0, #1
 8023764:	f000 fe77 	bl	8024456 <xQueueCreateMutex>
#endif
#else
  return NULL;
#endif
}
 8023768:	bd08      	pop	{r3, pc}

0802376a <osMutexWait>:
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
{
 802376a:	b530      	push	{r4, r5, lr}
 802376c:	b083      	sub	sp, #12
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 802376e:	2300      	movs	r3, #0
 8023770:	9301      	str	r3, [sp, #4]
  
  
  if (mutex_id == NULL) {
 8023772:	b310      	cbz	r0, 80237ba <osMutexWait+0x50>
 8023774:	460c      	mov	r4, r1
 8023776:	4605      	mov	r5, r0
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8023778:	f7ff ff42 	bl	8023600 <inHandlerMode>
 802377c:	b1a0      	cbz	r0, 80237a8 <osMutexWait+0x3e>
    if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
 802377e:	aa01      	add	r2, sp, #4
 8023780:	2100      	movs	r1, #0
 8023782:	4628      	mov	r0, r5
 8023784:	f001 f8b3 	bl	80248ee <xQueueReceiveFromISR>
 8023788:	2801      	cmp	r0, #1
 802378a:	d118      	bne.n	80237be <osMutexWait+0x54>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 802378c:	9b01      	ldr	r3, [sp, #4]
 802378e:	b1c3      	cbz	r3, 80237c2 <osMutexWait+0x58>
 8023790:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023794:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023798:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 802379c:	f3bf 8f4f 	dsb	sy
 80237a0:	f3bf 8f6f 	isb	sy
  } 
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 80237a4:	2000      	movs	r0, #0
 80237a6:	e006      	b.n	80237b6 <osMutexWait+0x4c>
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
 80237a8:	4621      	mov	r1, r4
 80237aa:	4628      	mov	r0, r5
 80237ac:	f000 ffcc 	bl	8024748 <xQueueSemaphoreTake>
 80237b0:	2801      	cmp	r0, #1
 80237b2:	d108      	bne.n	80237c6 <osMutexWait+0x5c>
  return osOK;
 80237b4:	2000      	movs	r0, #0
}
 80237b6:	b003      	add	sp, #12
 80237b8:	bd30      	pop	{r4, r5, pc}
    return osErrorParameter;
 80237ba:	2080      	movs	r0, #128	; 0x80
 80237bc:	e7fb      	b.n	80237b6 <osMutexWait+0x4c>
      return osErrorOS;
 80237be:	20ff      	movs	r0, #255	; 0xff
 80237c0:	e7f9      	b.n	80237b6 <osMutexWait+0x4c>
  return osOK;
 80237c2:	2000      	movs	r0, #0
 80237c4:	e7f7      	b.n	80237b6 <osMutexWait+0x4c>
    return osErrorOS;
 80237c6:	20ff      	movs	r0, #255	; 0xff
 80237c8:	e7f5      	b.n	80237b6 <osMutexWait+0x4c>

080237ca <osMutexRelease>:
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexRelease (osMutexId mutex_id)
{
 80237ca:	b510      	push	{r4, lr}
 80237cc:	b082      	sub	sp, #8
 80237ce:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 80237d0:	2300      	movs	r3, #0
 80237d2:	9301      	str	r3, [sp, #4]
  
  if (inHandlerMode()) {
 80237d4:	f7ff ff14 	bl	8023600 <inHandlerMode>
 80237d8:	b198      	cbz	r0, 8023802 <osMutexRelease+0x38>
    if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
 80237da:	a901      	add	r1, sp, #4
 80237dc:	4620      	mov	r0, r4
 80237de:	f000 feab 	bl	8024538 <xQueueGiveFromISR>
 80237e2:	2801      	cmp	r0, #1
 80237e4:	d11a      	bne.n	802381c <osMutexRelease+0x52>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 80237e6:	9b01      	ldr	r3, [sp, #4]
 80237e8:	b1d3      	cbz	r3, 8023820 <osMutexRelease+0x56>
 80237ea:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80237ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80237f2:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80237f6:	f3bf 8f4f 	dsb	sy
 80237fa:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 80237fe:	2000      	movs	r0, #0
 8023800:	e008      	b.n	8023814 <osMutexRelease+0x4a>
  }
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
 8023802:	2300      	movs	r3, #0
 8023804:	461a      	mov	r2, r3
 8023806:	4619      	mov	r1, r3
 8023808:	4620      	mov	r0, r4
 802380a:	f000 fd54 	bl	80242b6 <xQueueGenericSend>
 802380e:	2801      	cmp	r0, #1
 8023810:	d002      	beq.n	8023818 <osMutexRelease+0x4e>
  {
    result = osErrorOS;
 8023812:	20ff      	movs	r0, #255	; 0xff
  }
  return result;
}
 8023814:	b002      	add	sp, #8
 8023816:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 8023818:	2000      	movs	r0, #0
 802381a:	e7fb      	b.n	8023814 <osMutexRelease+0x4a>
      return osErrorOS;
 802381c:	20ff      	movs	r0, #255	; 0xff
 802381e:	e7f9      	b.n	8023814 <osMutexRelease+0x4a>
  osStatus result = osOK;
 8023820:	2000      	movs	r0, #0
 8023822:	e7f7      	b.n	8023814 <osMutexRelease+0x4a>

08023824 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 8023824:	b510      	push	{r4, lr}
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 8023826:	2901      	cmp	r1, #1
 8023828:	d005      	beq.n	8023836 <osSemaphoreCreate+0x12>
    vSemaphoreCreateBinary(sema);
    return sema;
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
 802382a:	4608      	mov	r0, r1
 802382c:	f000 fd25 	bl	802427a <xQueueCreateCountingSemaphore>
 8023830:	4604      	mov	r4, r0
#else
    return NULL;
#endif
  }
#endif
}
 8023832:	4620      	mov	r0, r4
 8023834:	bd10      	pop	{r4, pc}
    vSemaphoreCreateBinary(sema);
 8023836:	2203      	movs	r2, #3
 8023838:	2100      	movs	r1, #0
 802383a:	2001      	movs	r0, #1
 802383c:	f000 fcf9 	bl	8024232 <xQueueGenericCreate>
 8023840:	4604      	mov	r4, r0
 8023842:	2800      	cmp	r0, #0
 8023844:	d0f5      	beq.n	8023832 <osSemaphoreCreate+0xe>
 8023846:	2300      	movs	r3, #0
 8023848:	461a      	mov	r2, r3
 802384a:	4619      	mov	r1, r3
 802384c:	f000 fd33 	bl	80242b6 <xQueueGenericSend>
    return sema;
 8023850:	e7ef      	b.n	8023832 <osSemaphoreCreate+0xe>

08023852 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8023852:	b570      	push	{r4, r5, r6, lr}
 8023854:	b082      	sub	sp, #8
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8023856:	2300      	movs	r3, #0
 8023858:	9301      	str	r3, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 802385a:	b318      	cbz	r0, 80238a4 <osSemaphoreWait+0x52>
 802385c:	460c      	mov	r4, r1
 802385e:	4606      	mov	r6, r0
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8023860:	f7ff fece 	bl	8023600 <inHandlerMode>
 8023864:	4605      	mov	r5, r0
 8023866:	b1a0      	cbz	r0, 8023892 <osSemaphoreWait+0x40>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8023868:	aa01      	add	r2, sp, #4
 802386a:	2100      	movs	r1, #0
 802386c:	4630      	mov	r0, r6
 802386e:	f001 f83e 	bl	80248ee <xQueueReceiveFromISR>
 8023872:	2801      	cmp	r0, #1
 8023874:	d118      	bne.n	80238a8 <osSemaphoreWait+0x56>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 8023876:	9d01      	ldr	r5, [sp, #4]
 8023878:	b18d      	cbz	r5, 802389e <osSemaphoreWait+0x4c>
 802387a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802387e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023882:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8023886:	f3bf 8f4f 	dsb	sy
 802388a:	f3bf 8f6f 	isb	sy
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 802388e:	2500      	movs	r5, #0
 8023890:	e005      	b.n	802389e <osSemaphoreWait+0x4c>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8023892:	4621      	mov	r1, r4
 8023894:	4630      	mov	r0, r6
 8023896:	f000 ff57 	bl	8024748 <xQueueSemaphoreTake>
 802389a:	2801      	cmp	r0, #1
 802389c:	d106      	bne.n	80238ac <osSemaphoreWait+0x5a>
}
 802389e:	4628      	mov	r0, r5
 80238a0:	b002      	add	sp, #8
 80238a2:	bd70      	pop	{r4, r5, r6, pc}
    return osErrorParameter;
 80238a4:	2580      	movs	r5, #128	; 0x80
 80238a6:	e7fa      	b.n	802389e <osSemaphoreWait+0x4c>
      return osErrorOS;
 80238a8:	25ff      	movs	r5, #255	; 0xff
 80238aa:	e7f8      	b.n	802389e <osSemaphoreWait+0x4c>
    return osErrorOS;
 80238ac:	25ff      	movs	r5, #255	; 0xff
 80238ae:	e7f6      	b.n	802389e <osSemaphoreWait+0x4c>

080238b0 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 80238b0:	b510      	push	{r4, lr}
 80238b2:	b082      	sub	sp, #8
 80238b4:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 80238b6:	2300      	movs	r3, #0
 80238b8:	9301      	str	r3, [sp, #4]
  
  
  if (inHandlerMode()) {
 80238ba:	f7ff fea1 	bl	8023600 <inHandlerMode>
 80238be:	b198      	cbz	r0, 80238e8 <osSemaphoreRelease+0x38>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 80238c0:	a901      	add	r1, sp, #4
 80238c2:	4620      	mov	r0, r4
 80238c4:	f000 fe38 	bl	8024538 <xQueueGiveFromISR>
 80238c8:	2801      	cmp	r0, #1
 80238ca:	d11a      	bne.n	8023902 <osSemaphoreRelease+0x52>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 80238cc:	9b01      	ldr	r3, [sp, #4]
 80238ce:	b1d3      	cbz	r3, 8023906 <osSemaphoreRelease+0x56>
 80238d0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80238d4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80238d8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80238dc:	f3bf 8f4f 	dsb	sy
 80238e0:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 80238e4:	2000      	movs	r0, #0
 80238e6:	e008      	b.n	80238fa <osSemaphoreRelease+0x4a>
  }
  else {
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 80238e8:	2300      	movs	r3, #0
 80238ea:	461a      	mov	r2, r3
 80238ec:	4619      	mov	r1, r3
 80238ee:	4620      	mov	r0, r4
 80238f0:	f000 fce1 	bl	80242b6 <xQueueGenericSend>
 80238f4:	2801      	cmp	r0, #1
 80238f6:	d002      	beq.n	80238fe <osSemaphoreRelease+0x4e>
      result = osErrorOS;
 80238f8:	20ff      	movs	r0, #255	; 0xff
    }
  }
  
  return result;
}
 80238fa:	b002      	add	sp, #8
 80238fc:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 80238fe:	2000      	movs	r0, #0
 8023900:	e7fb      	b.n	80238fa <osSemaphoreRelease+0x4a>
      return osErrorOS;
 8023902:	20ff      	movs	r0, #255	; 0xff
 8023904:	e7f9      	b.n	80238fa <osSemaphoreRelease+0x4a>
  osStatus result = osOK;
 8023906:	2000      	movs	r0, #0
 8023908:	e7f7      	b.n	80238fa <osSemaphoreRelease+0x4a>

0802390a <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 802390a:	b508      	push	{r3, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 802390c:	2200      	movs	r2, #0
 802390e:	6841      	ldr	r1, [r0, #4]
 8023910:	6800      	ldr	r0, [r0, #0]
 8023912:	f000 fc8e 	bl	8024232 <xQueueGenericCreate>
#endif
}
 8023916:	bd08      	pop	{r3, pc}

08023918 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8023918:	b530      	push	{r4, r5, lr}
 802391a:	b085      	sub	sp, #20
 802391c:	4604      	mov	r4, r0
 802391e:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 8023920:	2300      	movs	r3, #0
 8023922:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 8023924:	4615      	mov	r5, r2
 8023926:	b902      	cbnz	r2, 802392a <osMessagePut+0x12>
    ticks = 1;
 8023928:	2501      	movs	r5, #1
  }
  
  if (inHandlerMode()) {
 802392a:	f7ff fe69 	bl	8023600 <inHandlerMode>
 802392e:	b1a8      	cbz	r0, 802395c <osMessagePut+0x44>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 8023930:	2300      	movs	r3, #0
 8023932:	aa03      	add	r2, sp, #12
 8023934:	a901      	add	r1, sp, #4
 8023936:	4620      	mov	r0, r4
 8023938:	f000 fd98 	bl	802446c <xQueueGenericSendFromISR>
 802393c:	2801      	cmp	r0, #1
 802393e:	d118      	bne.n	8023972 <osMessagePut+0x5a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8023940:	9b03      	ldr	r3, [sp, #12]
 8023942:	b1c3      	cbz	r3, 8023976 <osMessagePut+0x5e>
 8023944:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023948:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802394c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8023950:	f3bf 8f4f 	dsb	sy
 8023954:	f3bf 8f6f 	isb	sy
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
      return osErrorOS;
    }
  }
  
  return osOK;
 8023958:	2000      	movs	r0, #0
 802395a:	e008      	b.n	802396e <osMessagePut+0x56>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 802395c:	2300      	movs	r3, #0
 802395e:	462a      	mov	r2, r5
 8023960:	a901      	add	r1, sp, #4
 8023962:	4620      	mov	r0, r4
 8023964:	f000 fca7 	bl	80242b6 <xQueueGenericSend>
 8023968:	2801      	cmp	r0, #1
 802396a:	d106      	bne.n	802397a <osMessagePut+0x62>
  return osOK;
 802396c:	2000      	movs	r0, #0
}
 802396e:	b005      	add	sp, #20
 8023970:	bd30      	pop	{r4, r5, pc}
      return osErrorOS;
 8023972:	20ff      	movs	r0, #255	; 0xff
 8023974:	e7fb      	b.n	802396e <osMessagePut+0x56>
  return osOK;
 8023976:	2000      	movs	r0, #0
 8023978:	e7f9      	b.n	802396e <osMessagePut+0x56>
      return osErrorOS;
 802397a:	20ff      	movs	r0, #255	; 0xff
 802397c:	e7f7      	b.n	802396e <osMessagePut+0x56>

0802397e <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 802397e:	b570      	push	{r4, r5, r6, lr}
 8023980:	b084      	sub	sp, #16
 8023982:	4604      	mov	r4, r0
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
 8023984:	9102      	str	r1, [sp, #8]
  event.value.v = 0;
 8023986:	2300      	movs	r3, #0
 8023988:	9301      	str	r3, [sp, #4]
  
  if (queue_id == NULL) {
 802398a:	b1e1      	cbz	r1, 80239c6 <osMessageGet+0x48>
 802398c:	460d      	mov	r5, r1
 802398e:	4616      	mov	r6, r2
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8023990:	2300      	movs	r3, #0
 8023992:	9303      	str	r3, [sp, #12]
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8023994:	f7ff fe34 	bl	8023600 <inHandlerMode>
 8023998:	b300      	cbz	r0, 80239dc <osMessageGet+0x5e>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 802399a:	aa03      	add	r2, sp, #12
 802399c:	a901      	add	r1, sp, #4
 802399e:	4628      	mov	r0, r5
 80239a0:	f000 ffa5 	bl	80248ee <xQueueReceiveFromISR>
 80239a4:	2801      	cmp	r0, #1
 80239a6:	d016      	beq.n	80239d6 <osMessageGet+0x58>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = osOK;
 80239a8:	2300      	movs	r3, #0
 80239aa:	9300      	str	r3, [sp, #0]
    }
    portEND_SWITCHING_ISR(taskWoken);
 80239ac:	9b03      	ldr	r3, [sp, #12]
 80239ae:	b1fb      	cbz	r3, 80239f0 <osMessageGet+0x72>
 80239b0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80239b4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80239b8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80239bc:	f3bf 8f4f 	dsb	sy
 80239c0:	f3bf 8f6f 	isb	sy
 80239c4:	e014      	b.n	80239f0 <osMessageGet+0x72>
    event.status = osErrorParameter;
 80239c6:	2380      	movs	r3, #128	; 0x80
 80239c8:	9300      	str	r3, [sp, #0]
    return event;
 80239ca:	466b      	mov	r3, sp
 80239cc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80239d0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 80239d4:	e011      	b.n	80239fa <osMessageGet+0x7c>
      event.status = osEventMessage;
 80239d6:	2310      	movs	r3, #16
 80239d8:	9300      	str	r3, [sp, #0]
 80239da:	e7e7      	b.n	80239ac <osMessageGet+0x2e>
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 80239dc:	4632      	mov	r2, r6
 80239de:	a901      	add	r1, sp, #4
 80239e0:	4628      	mov	r0, r5
 80239e2:	f000 fe02 	bl	80245ea <xQueueReceive>
 80239e6:	2801      	cmp	r0, #1
 80239e8:	d00a      	beq.n	8023a00 <osMessageGet+0x82>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 80239ea:	b106      	cbz	r6, 80239ee <osMessageGet+0x70>
 80239ec:	2640      	movs	r6, #64	; 0x40
 80239ee:	9600      	str	r6, [sp, #0]
    }
  }
  
  return event;
 80239f0:	466b      	mov	r3, sp
 80239f2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80239f6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 80239fa:	4620      	mov	r0, r4
 80239fc:	b004      	add	sp, #16
 80239fe:	bd70      	pop	{r4, r5, r6, pc}
      event.status = osEventMessage;
 8023a00:	2310      	movs	r3, #16
 8023a02:	9300      	str	r3, [sp, #0]
 8023a04:	e7f4      	b.n	80239f0 <osMessageGet+0x72>
	...

08023a08 <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8023a08:	4a13      	ldr	r2, [pc, #76]	; (8023a58 <prvHeapInit+0x50>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8023a0a:	f012 0f07 	tst.w	r2, #7
 8023a0e:	d01f      	beq.n	8023a50 <prvHeapInit+0x48>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8023a10:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8023a12:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8023a16:	f5c1 433b 	rsb	r3, r1, #47872	; 0xbb00
 8023a1a:	3320      	adds	r3, #32
 8023a1c:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8023a1e:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8023a20:	480e      	ldr	r0, [pc, #56]	; (8023a5c <prvHeapInit+0x54>)
 8023a22:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8023a24:	2100      	movs	r1, #0
 8023a26:	6041      	str	r1, [r0, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8023a28:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8023a2a:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8023a2c:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 8023a30:	480b      	ldr	r0, [pc, #44]	; (8023a60 <prvHeapInit+0x58>)
 8023a32:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
 8023a34:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8023a36:	6019      	str	r1, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8023a38:	1a99      	subs	r1, r3, r2
 8023a3a:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8023a3c:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8023a3e:	4b09      	ldr	r3, [pc, #36]	; (8023a64 <prvHeapInit+0x5c>)
 8023a40:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8023a42:	4b09      	ldr	r3, [pc, #36]	; (8023a68 <prvHeapInit+0x60>)
 8023a44:	6019      	str	r1, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8023a46:	4b09      	ldr	r3, [pc, #36]	; (8023a6c <prvHeapInit+0x64>)
 8023a48:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8023a4c:	601a      	str	r2, [r3, #0]
}
 8023a4e:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8023a50:	f64b 3320 	movw	r3, #47904	; 0xbb20
 8023a54:	e7e4      	b.n	8023a20 <prvHeapInit+0x18>
 8023a56:	bf00      	nop
 8023a58:	200060b8 	.word	0x200060b8
 8023a5c:	20011be4 	.word	0x20011be4
 8023a60:	200060b4 	.word	0x200060b4
 8023a64:	20011be0 	.word	0x20011be0
 8023a68:	20011bdc 	.word	0x20011bdc
 8023a6c:	20011bd8 	.word	0x20011bd8

08023a70 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8023a70:	4b16      	ldr	r3, [pc, #88]	; (8023acc <prvInsertBlockIntoFreeList+0x5c>)
 8023a72:	461a      	mov	r2, r3
 8023a74:	681b      	ldr	r3, [r3, #0]
 8023a76:	4283      	cmp	r3, r0
 8023a78:	d3fb      	bcc.n	8023a72 <prvInsertBlockIntoFreeList+0x2>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8023a7a:	6851      	ldr	r1, [r2, #4]
 8023a7c:	eb02 0c01 	add.w	ip, r2, r1
 8023a80:	4584      	cmp	ip, r0
 8023a82:	d009      	beq.n	8023a98 <prvInsertBlockIntoFreeList+0x28>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8023a84:	6841      	ldr	r1, [r0, #4]
 8023a86:	eb00 0c01 	add.w	ip, r0, r1
 8023a8a:	4563      	cmp	r3, ip
 8023a8c:	d009      	beq.n	8023aa2 <prvInsertBlockIntoFreeList+0x32>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8023a8e:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8023a90:	4290      	cmp	r0, r2
 8023a92:	d019      	beq.n	8023ac8 <prvInsertBlockIntoFreeList+0x58>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8023a94:	6010      	str	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
 8023a96:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8023a98:	6840      	ldr	r0, [r0, #4]
 8023a9a:	4401      	add	r1, r0
 8023a9c:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
 8023a9e:	4610      	mov	r0, r2
 8023aa0:	e7f0      	b.n	8023a84 <prvInsertBlockIntoFreeList+0x14>
{
 8023aa2:	b410      	push	{r4}
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8023aa4:	4c0a      	ldr	r4, [pc, #40]	; (8023ad0 <prvInsertBlockIntoFreeList+0x60>)
 8023aa6:	6824      	ldr	r4, [r4, #0]
 8023aa8:	42a3      	cmp	r3, r4
 8023aaa:	d00b      	beq.n	8023ac4 <prvInsertBlockIntoFreeList+0x54>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8023aac:	685b      	ldr	r3, [r3, #4]
 8023aae:	4419      	add	r1, r3
 8023ab0:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8023ab2:	6813      	ldr	r3, [r2, #0]
 8023ab4:	681b      	ldr	r3, [r3, #0]
 8023ab6:	6003      	str	r3, [r0, #0]
	if( pxIterator != pxBlockToInsert )
 8023ab8:	4290      	cmp	r0, r2
 8023aba:	d000      	beq.n	8023abe <prvInsertBlockIntoFreeList+0x4e>
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8023abc:	6010      	str	r0, [r2, #0]
	}
}
 8023abe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023ac2:	4770      	bx	lr
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8023ac4:	6004      	str	r4, [r0, #0]
 8023ac6:	e7f7      	b.n	8023ab8 <prvInsertBlockIntoFreeList+0x48>
 8023ac8:	4770      	bx	lr
 8023aca:	bf00      	nop
 8023acc:	20011be4 	.word	0x20011be4
 8023ad0:	200060b4 	.word	0x200060b4

08023ad4 <pvPortMalloc>:
{
 8023ad4:	b570      	push	{r4, r5, r6, lr}
 8023ad6:	4605      	mov	r5, r0
	vTaskSuspendAll();
 8023ad8:	f001 fa02 	bl	8024ee0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8023adc:	4b34      	ldr	r3, [pc, #208]	; (8023bb0 <pvPortMalloc+0xdc>)
 8023ade:	681b      	ldr	r3, [r3, #0]
 8023ae0:	b1a3      	cbz	r3, 8023b0c <pvPortMalloc+0x38>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8023ae2:	4b34      	ldr	r3, [pc, #208]	; (8023bb4 <pvPortMalloc+0xe0>)
 8023ae4:	681b      	ldr	r3, [r3, #0]
 8023ae6:	421d      	tst	r5, r3
 8023ae8:	d14a      	bne.n	8023b80 <pvPortMalloc+0xac>
			if( xWantedSize > 0 )
 8023aea:	b135      	cbz	r5, 8023afa <pvPortMalloc+0x26>
				xWantedSize += xHeapStructSize;
 8023aec:	3508      	adds	r5, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8023aee:	f015 0f07 	tst.w	r5, #7
 8023af2:	d002      	beq.n	8023afa <pvPortMalloc+0x26>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8023af4:	f025 0507 	bic.w	r5, r5, #7
 8023af8:	3508      	adds	r5, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8023afa:	2d00      	cmp	r5, #0
 8023afc:	d042      	beq.n	8023b84 <pvPortMalloc+0xb0>
 8023afe:	4b2e      	ldr	r3, [pc, #184]	; (8023bb8 <pvPortMalloc+0xe4>)
 8023b00:	681b      	ldr	r3, [r3, #0]
 8023b02:	42ab      	cmp	r3, r5
 8023b04:	d34d      	bcc.n	8023ba2 <pvPortMalloc+0xce>
				pxBlock = xStart.pxNextFreeBlock;
 8023b06:	4a2d      	ldr	r2, [pc, #180]	; (8023bbc <pvPortMalloc+0xe8>)
 8023b08:	6814      	ldr	r4, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8023b0a:	e004      	b.n	8023b16 <pvPortMalloc+0x42>
			prvHeapInit();
 8023b0c:	f7ff ff7c 	bl	8023a08 <prvHeapInit>
 8023b10:	e7e7      	b.n	8023ae2 <pvPortMalloc+0xe>
					pxPreviousBlock = pxBlock;
 8023b12:	4622      	mov	r2, r4
					pxBlock = pxBlock->pxNextFreeBlock;
 8023b14:	461c      	mov	r4, r3
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8023b16:	6863      	ldr	r3, [r4, #4]
 8023b18:	42ab      	cmp	r3, r5
 8023b1a:	d202      	bcs.n	8023b22 <pvPortMalloc+0x4e>
 8023b1c:	6823      	ldr	r3, [r4, #0]
 8023b1e:	2b00      	cmp	r3, #0
 8023b20:	d1f7      	bne.n	8023b12 <pvPortMalloc+0x3e>
				if( pxBlock != pxEnd )
 8023b22:	4b23      	ldr	r3, [pc, #140]	; (8023bb0 <pvPortMalloc+0xdc>)
 8023b24:	681b      	ldr	r3, [r3, #0]
 8023b26:	42a3      	cmp	r3, r4
 8023b28:	d03d      	beq.n	8023ba6 <pvPortMalloc+0xd2>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8023b2a:	6816      	ldr	r6, [r2, #0]
 8023b2c:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8023b2e:	6823      	ldr	r3, [r4, #0]
 8023b30:	6013      	str	r3, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8023b32:	6863      	ldr	r3, [r4, #4]
 8023b34:	1b5b      	subs	r3, r3, r5
 8023b36:	2b10      	cmp	r3, #16
 8023b38:	d910      	bls.n	8023b5c <pvPortMalloc+0x88>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8023b3a:	1960      	adds	r0, r4, r5
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8023b3c:	f010 0f07 	tst.w	r0, #7
 8023b40:	d008      	beq.n	8023b54 <pvPortMalloc+0x80>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8023b42:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023b46:	f383 8811 	msr	BASEPRI, r3
 8023b4a:	f3bf 8f6f 	isb	sy
 8023b4e:	f3bf 8f4f 	dsb	sy
 8023b52:	e7fe      	b.n	8023b52 <pvPortMalloc+0x7e>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8023b54:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8023b56:	6065      	str	r5, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8023b58:	f7ff ff8a 	bl	8023a70 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8023b5c:	6862      	ldr	r2, [r4, #4]
 8023b5e:	4916      	ldr	r1, [pc, #88]	; (8023bb8 <pvPortMalloc+0xe4>)
 8023b60:	680b      	ldr	r3, [r1, #0]
 8023b62:	1a9b      	subs	r3, r3, r2
 8023b64:	600b      	str	r3, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8023b66:	4916      	ldr	r1, [pc, #88]	; (8023bc0 <pvPortMalloc+0xec>)
 8023b68:	6809      	ldr	r1, [r1, #0]
 8023b6a:	428b      	cmp	r3, r1
 8023b6c:	d201      	bcs.n	8023b72 <pvPortMalloc+0x9e>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8023b6e:	4914      	ldr	r1, [pc, #80]	; (8023bc0 <pvPortMalloc+0xec>)
 8023b70:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8023b72:	4b10      	ldr	r3, [pc, #64]	; (8023bb4 <pvPortMalloc+0xe0>)
 8023b74:	681b      	ldr	r3, [r3, #0]
 8023b76:	4313      	orrs	r3, r2
 8023b78:	6063      	str	r3, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8023b7a:	2300      	movs	r3, #0
 8023b7c:	6023      	str	r3, [r4, #0]
 8023b7e:	e002      	b.n	8023b86 <pvPortMalloc+0xb2>
void *pvReturn = NULL;
 8023b80:	2600      	movs	r6, #0
 8023b82:	e000      	b.n	8023b86 <pvPortMalloc+0xb2>
 8023b84:	2600      	movs	r6, #0
	( void ) xTaskResumeAll();
 8023b86:	f001 fa4d 	bl	8025024 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8023b8a:	f016 0f07 	tst.w	r6, #7
 8023b8e:	d00c      	beq.n	8023baa <pvPortMalloc+0xd6>
 8023b90:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023b94:	f383 8811 	msr	BASEPRI, r3
 8023b98:	f3bf 8f6f 	isb	sy
 8023b9c:	f3bf 8f4f 	dsb	sy
 8023ba0:	e7fe      	b.n	8023ba0 <pvPortMalloc+0xcc>
void *pvReturn = NULL;
 8023ba2:	2600      	movs	r6, #0
 8023ba4:	e7ef      	b.n	8023b86 <pvPortMalloc+0xb2>
 8023ba6:	2600      	movs	r6, #0
 8023ba8:	e7ed      	b.n	8023b86 <pvPortMalloc+0xb2>
}
 8023baa:	4630      	mov	r0, r6
 8023bac:	bd70      	pop	{r4, r5, r6, pc}
 8023bae:	bf00      	nop
 8023bb0:	200060b4 	.word	0x200060b4
 8023bb4:	20011bd8 	.word	0x20011bd8
 8023bb8:	20011bdc 	.word	0x20011bdc
 8023bbc:	20011be4 	.word	0x20011be4
 8023bc0:	20011be0 	.word	0x20011be0

08023bc4 <vPortFree>:
	if( pv != NULL )
 8023bc4:	b380      	cbz	r0, 8023c28 <vPortFree+0x64>
{
 8023bc6:	b538      	push	{r3, r4, r5, lr}
 8023bc8:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 8023bca:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8023bce:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8023bd2:	4a16      	ldr	r2, [pc, #88]	; (8023c2c <vPortFree+0x68>)
 8023bd4:	6812      	ldr	r2, [r2, #0]
 8023bd6:	4213      	tst	r3, r2
 8023bd8:	d108      	bne.n	8023bec <vPortFree+0x28>
 8023bda:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023bde:	f383 8811 	msr	BASEPRI, r3
 8023be2:	f3bf 8f6f 	isb	sy
 8023be6:	f3bf 8f4f 	dsb	sy
 8023bea:	e7fe      	b.n	8023bea <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8023bec:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8023bf0:	b141      	cbz	r1, 8023c04 <vPortFree+0x40>
 8023bf2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023bf6:	f383 8811 	msr	BASEPRI, r3
 8023bfa:	f3bf 8f6f 	isb	sy
 8023bfe:	f3bf 8f4f 	dsb	sy
 8023c02:	e7fe      	b.n	8023c02 <vPortFree+0x3e>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8023c04:	ea23 0302 	bic.w	r3, r3, r2
 8023c08:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8023c0c:	f001 f968 	bl	8024ee0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8023c10:	f854 1c04 	ldr.w	r1, [r4, #-4]
 8023c14:	4a06      	ldr	r2, [pc, #24]	; (8023c30 <vPortFree+0x6c>)
 8023c16:	6813      	ldr	r3, [r2, #0]
 8023c18:	440b      	add	r3, r1
 8023c1a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8023c1c:	4628      	mov	r0, r5
 8023c1e:	f7ff ff27 	bl	8023a70 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 8023c22:	f001 f9ff 	bl	8025024 <xTaskResumeAll>
}
 8023c26:	bd38      	pop	{r3, r4, r5, pc}
 8023c28:	4770      	bx	lr
 8023c2a:	bf00      	nop
 8023c2c:	20011bd8 	.word	0x20011bd8
 8023c30:	20011bdc 	.word	0x20011bdc

08023c34 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8023c34:	f100 0308 	add.w	r3, r0, #8
 8023c38:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8023c3a:	f04f 32ff 	mov.w	r2, #4294967295
 8023c3e:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8023c40:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8023c42:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8023c44:	2300      	movs	r3, #0
 8023c46:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8023c48:	4770      	bx	lr

08023c4a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8023c4a:	2300      	movs	r3, #0
 8023c4c:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8023c4e:	4770      	bx	lr

08023c50 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8023c50:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8023c52:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8023c54:	689a      	ldr	r2, [r3, #8]
 8023c56:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8023c58:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8023c5a:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 8023c5c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8023c5e:	6803      	ldr	r3, [r0, #0]
 8023c60:	3301      	adds	r3, #1
 8023c62:	6003      	str	r3, [r0, #0]
}
 8023c64:	4770      	bx	lr

08023c66 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8023c66:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8023c68:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8023c6a:	f1b5 3fff 	cmp.w	r5, #4294967295
 8023c6e:	d011      	beq.n	8023c94 <vListInsert+0x2e>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8023c70:	f100 0308 	add.w	r3, r0, #8
 8023c74:	461c      	mov	r4, r3
 8023c76:	685b      	ldr	r3, [r3, #4]
 8023c78:	681a      	ldr	r2, [r3, #0]
 8023c7a:	42aa      	cmp	r2, r5
 8023c7c:	d9fa      	bls.n	8023c74 <vListInsert+0xe>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8023c7e:	6863      	ldr	r3, [r4, #4]
 8023c80:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8023c82:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8023c84:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8023c86:	6061      	str	r1, [r4, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 8023c88:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8023c8a:	6803      	ldr	r3, [r0, #0]
 8023c8c:	3301      	adds	r3, #1
 8023c8e:	6003      	str	r3, [r0, #0]
}
 8023c90:	bc30      	pop	{r4, r5}
 8023c92:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8023c94:	6904      	ldr	r4, [r0, #16]
 8023c96:	e7f2      	b.n	8023c7e <vListInsert+0x18>

08023c98 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8023c98:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8023c9a:	6841      	ldr	r1, [r0, #4]
 8023c9c:	6882      	ldr	r2, [r0, #8]
 8023c9e:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8023ca0:	6841      	ldr	r1, [r0, #4]
 8023ca2:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8023ca4:	685a      	ldr	r2, [r3, #4]
 8023ca6:	4282      	cmp	r2, r0
 8023ca8:	d006      	beq.n	8023cb8 <uxListRemove+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8023caa:	2200      	movs	r2, #0
 8023cac:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8023cae:	681a      	ldr	r2, [r3, #0]
 8023cb0:	3a01      	subs	r2, #1
 8023cb2:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8023cb4:	6818      	ldr	r0, [r3, #0]
}
 8023cb6:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8023cb8:	6882      	ldr	r2, [r0, #8]
 8023cba:	605a      	str	r2, [r3, #4]
 8023cbc:	e7f5      	b.n	8023caa <uxListRemove+0x12>
	...

08023cc0 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8023cc0:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8023cc2:	2300      	movs	r3, #0
 8023cc4:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8023cc6:	4b0d      	ldr	r3, [pc, #52]	; (8023cfc <prvTaskExitError+0x3c>)
 8023cc8:	681b      	ldr	r3, [r3, #0]
 8023cca:	f1b3 3fff 	cmp.w	r3, #4294967295
 8023cce:	d008      	beq.n	8023ce2 <prvTaskExitError+0x22>
 8023cd0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023cd4:	f383 8811 	msr	BASEPRI, r3
 8023cd8:	f3bf 8f6f 	isb	sy
 8023cdc:	f3bf 8f4f 	dsb	sy
 8023ce0:	e7fe      	b.n	8023ce0 <prvTaskExitError+0x20>
 8023ce2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023ce6:	f383 8811 	msr	BASEPRI, r3
 8023cea:	f3bf 8f6f 	isb	sy
 8023cee:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8023cf2:	9b01      	ldr	r3, [sp, #4]
 8023cf4:	2b00      	cmp	r3, #0
 8023cf6:	d0fc      	beq.n	8023cf2 <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8023cf8:	b002      	add	sp, #8
 8023cfa:	4770      	bx	lr
 8023cfc:	2000024c 	.word	0x2000024c

08023d00 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8023d00:	4808      	ldr	r0, [pc, #32]	; (8023d24 <prvPortStartFirstTask+0x24>)
 8023d02:	6800      	ldr	r0, [r0, #0]
 8023d04:	6800      	ldr	r0, [r0, #0]
 8023d06:	f380 8808 	msr	MSP, r0
 8023d0a:	f04f 0000 	mov.w	r0, #0
 8023d0e:	f380 8814 	msr	CONTROL, r0
 8023d12:	b662      	cpsie	i
 8023d14:	b661      	cpsie	f
 8023d16:	f3bf 8f4f 	dsb	sy
 8023d1a:	f3bf 8f6f 	isb	sy
 8023d1e:	df00      	svc	0
 8023d20:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8023d22:	0000      	.short	0x0000
 8023d24:	e000ed08 	.word	0xe000ed08

08023d28 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8023d28:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8023d38 <vPortEnableVFP+0x10>
 8023d2c:	6801      	ldr	r1, [r0, #0]
 8023d2e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8023d32:	6001      	str	r1, [r0, #0]
 8023d34:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 8023d36:	0000      	.short	0x0000
 8023d38:	e000ed88 	.word	0xe000ed88

08023d3c <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8023d3c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8023d40:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8023d44:	f021 0101 	bic.w	r1, r1, #1
 8023d48:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8023d4c:	4b05      	ldr	r3, [pc, #20]	; (8023d64 <pxPortInitialiseStack+0x28>)
 8023d4e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8023d52:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8023d56:	f06f 0302 	mvn.w	r3, #2
 8023d5a:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8023d5e:	3844      	subs	r0, #68	; 0x44
 8023d60:	4770      	bx	lr
 8023d62:	bf00      	nop
 8023d64:	08023cc1 	.word	0x08023cc1
	...

08023d70 <SVC_Handler>:
	__asm volatile (
 8023d70:	4b07      	ldr	r3, [pc, #28]	; (8023d90 <pxCurrentTCBConst2>)
 8023d72:	6819      	ldr	r1, [r3, #0]
 8023d74:	6808      	ldr	r0, [r1, #0]
 8023d76:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023d7a:	f380 8809 	msr	PSP, r0
 8023d7e:	f3bf 8f6f 	isb	sy
 8023d82:	f04f 0000 	mov.w	r0, #0
 8023d86:	f380 8811 	msr	BASEPRI, r0
 8023d8a:	4770      	bx	lr
 8023d8c:	f3af 8000 	nop.w

08023d90 <pxCurrentTCBConst2>:
 8023d90:	20011c34 	.word	0x20011c34

08023d94 <vPortEnterCritical>:
 8023d94:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023d98:	f383 8811 	msr	BASEPRI, r3
 8023d9c:	f3bf 8f6f 	isb	sy
 8023da0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8023da4:	4a0b      	ldr	r2, [pc, #44]	; (8023dd4 <vPortEnterCritical+0x40>)
 8023da6:	6813      	ldr	r3, [r2, #0]
 8023da8:	3301      	adds	r3, #1
 8023daa:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8023dac:	2b01      	cmp	r3, #1
 8023dae:	d000      	beq.n	8023db2 <vPortEnterCritical+0x1e>
}
 8023db0:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8023db2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023db6:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
 8023dba:	f013 0fff 	tst.w	r3, #255	; 0xff
 8023dbe:	d0f7      	beq.n	8023db0 <vPortEnterCritical+0x1c>
 8023dc0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023dc4:	f383 8811 	msr	BASEPRI, r3
 8023dc8:	f3bf 8f6f 	isb	sy
 8023dcc:	f3bf 8f4f 	dsb	sy
 8023dd0:	e7fe      	b.n	8023dd0 <vPortEnterCritical+0x3c>
 8023dd2:	bf00      	nop
 8023dd4:	2000024c 	.word	0x2000024c

08023dd8 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8023dd8:	4b09      	ldr	r3, [pc, #36]	; (8023e00 <vPortExitCritical+0x28>)
 8023dda:	681b      	ldr	r3, [r3, #0]
 8023ddc:	b943      	cbnz	r3, 8023df0 <vPortExitCritical+0x18>
 8023dde:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023de2:	f383 8811 	msr	BASEPRI, r3
 8023de6:	f3bf 8f6f 	isb	sy
 8023dea:	f3bf 8f4f 	dsb	sy
 8023dee:	e7fe      	b.n	8023dee <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8023df0:	3b01      	subs	r3, #1
 8023df2:	4a03      	ldr	r2, [pc, #12]	; (8023e00 <vPortExitCritical+0x28>)
 8023df4:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8023df6:	b90b      	cbnz	r3, 8023dfc <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8023df8:	f383 8811 	msr	BASEPRI, r3
}
 8023dfc:	4770      	bx	lr
 8023dfe:	bf00      	nop
 8023e00:	2000024c 	.word	0x2000024c
	...

08023e10 <PendSV_Handler>:
	__asm volatile
 8023e10:	f3ef 8009 	mrs	r0, PSP
 8023e14:	f3bf 8f6f 	isb	sy
 8023e18:	4b15      	ldr	r3, [pc, #84]	; (8023e70 <pxCurrentTCBConst>)
 8023e1a:	681a      	ldr	r2, [r3, #0]
 8023e1c:	f01e 0f10 	tst.w	lr, #16
 8023e20:	bf08      	it	eq
 8023e22:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8023e26:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023e2a:	6010      	str	r0, [r2, #0]
 8023e2c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8023e30:	f04f 0050 	mov.w	r0, #80	; 0x50
 8023e34:	f380 8811 	msr	BASEPRI, r0
 8023e38:	f3bf 8f4f 	dsb	sy
 8023e3c:	f3bf 8f6f 	isb	sy
 8023e40:	f001 f992 	bl	8025168 <vTaskSwitchContext>
 8023e44:	f04f 0000 	mov.w	r0, #0
 8023e48:	f380 8811 	msr	BASEPRI, r0
 8023e4c:	bc09      	pop	{r0, r3}
 8023e4e:	6819      	ldr	r1, [r3, #0]
 8023e50:	6808      	ldr	r0, [r1, #0]
 8023e52:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023e56:	f01e 0f10 	tst.w	lr, #16
 8023e5a:	bf08      	it	eq
 8023e5c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8023e60:	f380 8809 	msr	PSP, r0
 8023e64:	f3bf 8f6f 	isb	sy
 8023e68:	4770      	bx	lr
 8023e6a:	bf00      	nop
 8023e6c:	f3af 8000 	nop.w

08023e70 <pxCurrentTCBConst>:
 8023e70:	20011c34 	.word	0x20011c34

08023e74 <xPortSysTickHandler>:
{
 8023e74:	b508      	push	{r3, lr}
	__asm volatile
 8023e76:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023e7a:	f383 8811 	msr	BASEPRI, r3
 8023e7e:	f3bf 8f6f 	isb	sy
 8023e82:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8023e86:	f001 f841 	bl	8024f0c <xTaskIncrementTick>
 8023e8a:	b128      	cbz	r0, 8023e98 <xPortSysTickHandler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8023e8c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023e90:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023e94:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
 8023e98:	2300      	movs	r3, #0
 8023e9a:	f383 8811 	msr	BASEPRI, r3
}
 8023e9e:	bd08      	pop	{r3, pc}

08023ea0 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8023ea0:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8023ea4:	2300      	movs	r3, #0
 8023ea6:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8023ea8:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8023eaa:	4b05      	ldr	r3, [pc, #20]	; (8023ec0 <vPortSetupTimerInterrupt+0x20>)
 8023eac:	681b      	ldr	r3, [r3, #0]
 8023eae:	4905      	ldr	r1, [pc, #20]	; (8023ec4 <vPortSetupTimerInterrupt+0x24>)
 8023eb0:	fba1 1303 	umull	r1, r3, r1, r3
 8023eb4:	099b      	lsrs	r3, r3, #6
 8023eb6:	3b01      	subs	r3, #1
 8023eb8:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8023eba:	2307      	movs	r3, #7
 8023ebc:	6113      	str	r3, [r2, #16]
}
 8023ebe:	4770      	bx	lr
 8023ec0:	20000034 	.word	0x20000034
 8023ec4:	10624dd3 	.word	0x10624dd3

08023ec8 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8023ec8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023ecc:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 8023ed0:	4b3d      	ldr	r3, [pc, #244]	; (8023fc8 <xPortStartScheduler+0x100>)
 8023ed2:	429a      	cmp	r2, r3
 8023ed4:	d01c      	beq.n	8023f10 <xPortStartScheduler+0x48>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8023ed6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8023eda:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 8023ede:	4b3b      	ldr	r3, [pc, #236]	; (8023fcc <xPortStartScheduler+0x104>)
 8023ee0:	429a      	cmp	r2, r3
 8023ee2:	d01e      	beq.n	8023f22 <xPortStartScheduler+0x5a>
{
 8023ee4:	b530      	push	{r4, r5, lr}
 8023ee6:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8023ee8:	4b39      	ldr	r3, [pc, #228]	; (8023fd0 <xPortStartScheduler+0x108>)
 8023eea:	781a      	ldrb	r2, [r3, #0]
 8023eec:	b2d2      	uxtb	r2, r2
 8023eee:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8023ef0:	22ff      	movs	r2, #255	; 0xff
 8023ef2:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8023ef4:	781b      	ldrb	r3, [r3, #0]
 8023ef6:	b2db      	uxtb	r3, r3
 8023ef8:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8023efc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8023f00:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8023f04:	4a33      	ldr	r2, [pc, #204]	; (8023fd4 <xPortStartScheduler+0x10c>)
 8023f06:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8023f08:	4b33      	ldr	r3, [pc, #204]	; (8023fd8 <xPortStartScheduler+0x110>)
 8023f0a:	2207      	movs	r2, #7
 8023f0c:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8023f0e:	e01b      	b.n	8023f48 <xPortStartScheduler+0x80>
	__asm volatile
 8023f10:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023f14:	f383 8811 	msr	BASEPRI, r3
 8023f18:	f3bf 8f6f 	isb	sy
 8023f1c:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8023f20:	e7fe      	b.n	8023f20 <xPortStartScheduler+0x58>
 8023f22:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023f26:	f383 8811 	msr	BASEPRI, r3
 8023f2a:	f3bf 8f6f 	isb	sy
 8023f2e:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8023f32:	e7fe      	b.n	8023f32 <xPortStartScheduler+0x6a>
			ulMaxPRIGROUPValue--;
 8023f34:	4a28      	ldr	r2, [pc, #160]	; (8023fd8 <xPortStartScheduler+0x110>)
 8023f36:	6813      	ldr	r3, [r2, #0]
 8023f38:	3b01      	subs	r3, #1
 8023f3a:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8023f3c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8023f40:	005b      	lsls	r3, r3, #1
 8023f42:	b2db      	uxtb	r3, r3
 8023f44:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8023f48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8023f4c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8023f50:	d1f0      	bne.n	8023f34 <xPortStartScheduler+0x6c>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8023f52:	4b21      	ldr	r3, [pc, #132]	; (8023fd8 <xPortStartScheduler+0x110>)
 8023f54:	681b      	ldr	r3, [r3, #0]
 8023f56:	2b03      	cmp	r3, #3
 8023f58:	d008      	beq.n	8023f6c <xPortStartScheduler+0xa4>
 8023f5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023f5e:	f383 8811 	msr	BASEPRI, r3
 8023f62:	f3bf 8f6f 	isb	sy
 8023f66:	f3bf 8f4f 	dsb	sy
 8023f6a:	e7fe      	b.n	8023f6a <xPortStartScheduler+0xa2>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8023f6c:	021b      	lsls	r3, r3, #8
 8023f6e:	4a1a      	ldr	r2, [pc, #104]	; (8023fd8 <xPortStartScheduler+0x110>)
 8023f70:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8023f72:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8023f76:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8023f78:	9b01      	ldr	r3, [sp, #4]
 8023f7a:	b2db      	uxtb	r3, r3
 8023f7c:	4a14      	ldr	r2, [pc, #80]	; (8023fd0 <xPortStartScheduler+0x108>)
 8023f7e:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8023f80:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
 8023f84:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 8023f88:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8023f8c:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8023f90:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 8023f94:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 8023f98:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
 8023f9c:	f7ff ff80 	bl	8023ea0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8023fa0:	2500      	movs	r5, #0
 8023fa2:	4b0e      	ldr	r3, [pc, #56]	; (8023fdc <xPortStartScheduler+0x114>)
 8023fa4:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
 8023fa6:	f7ff febf 	bl	8023d28 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8023faa:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
 8023fae:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8023fb2:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
 8023fb6:	f7ff fea3 	bl	8023d00 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8023fba:	f001 f8d5 	bl	8025168 <vTaskSwitchContext>
	prvTaskExitError();
 8023fbe:	f7ff fe7f 	bl	8023cc0 <prvTaskExitError>
}
 8023fc2:	4628      	mov	r0, r5
 8023fc4:	b003      	add	sp, #12
 8023fc6:	bd30      	pop	{r4, r5, pc}
 8023fc8:	410fc271 	.word	0x410fc271
 8023fcc:	410fc270 	.word	0x410fc270
 8023fd0:	e000e400 	.word	0xe000e400
 8023fd4:	20011bec 	.word	0x20011bec
 8023fd8:	20011bf0 	.word	0x20011bf0
 8023fdc:	2000024c 	.word	0x2000024c

08023fe0 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8023fe0:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8023fe4:	2b0f      	cmp	r3, #15
 8023fe6:	d90f      	bls.n	8024008 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8023fe8:	4a11      	ldr	r2, [pc, #68]	; (8024030 <vPortValidateInterruptPriority+0x50>)
 8023fea:	5c9b      	ldrb	r3, [r3, r2]
 8023fec:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8023fee:	4a11      	ldr	r2, [pc, #68]	; (8024034 <vPortValidateInterruptPriority+0x54>)
 8023ff0:	7812      	ldrb	r2, [r2, #0]
 8023ff2:	429a      	cmp	r2, r3
 8023ff4:	d908      	bls.n	8024008 <vPortValidateInterruptPriority+0x28>
 8023ff6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023ffa:	f383 8811 	msr	BASEPRI, r3
 8023ffe:	f3bf 8f6f 	isb	sy
 8024002:	f3bf 8f4f 	dsb	sy
 8024006:	e7fe      	b.n	8024006 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8024008:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802400c:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 8024010:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8024014:	4a08      	ldr	r2, [pc, #32]	; (8024038 <vPortValidateInterruptPriority+0x58>)
 8024016:	6812      	ldr	r2, [r2, #0]
 8024018:	4293      	cmp	r3, r2
 802401a:	d908      	bls.n	802402e <vPortValidateInterruptPriority+0x4e>
 802401c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024020:	f383 8811 	msr	BASEPRI, r3
 8024024:	f3bf 8f6f 	isb	sy
 8024028:	f3bf 8f4f 	dsb	sy
 802402c:	e7fe      	b.n	802402c <vPortValidateInterruptPriority+0x4c>
	}
 802402e:	4770      	bx	lr
 8024030:	e000e3f0 	.word	0xe000e3f0
 8024034:	20011bec 	.word	0x20011bec
 8024038:	20011bf0 	.word	0x20011bf0

0802403c <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 802403c:	4603      	mov	r3, r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 802403e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8024040:	b118      	cbz	r0, 802404a <prvGetDisinheritPriorityAfterTimeout+0xe>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8024042:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8024044:	6818      	ldr	r0, [r3, #0]
 8024046:	f1c0 0007 	rsb	r0, r0, #7
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
		}

		return uxHighestPriorityOfWaitingTasks;
	}
 802404a:	4770      	bx	lr

0802404c <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 802404c:	b510      	push	{r4, lr}
 802404e:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8024050:	f7ff fea0 	bl	8023d94 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8024054:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8024056:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024058:	429a      	cmp	r2, r3
 802405a:	d004      	beq.n	8024066 <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 802405c:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
 802405e:	f7ff febb 	bl	8023dd8 <vPortExitCritical>

	return xReturn;
}
 8024062:	4620      	mov	r0, r4
 8024064:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 8024066:	2401      	movs	r4, #1
 8024068:	e7f9      	b.n	802405e <prvIsQueueFull+0x12>

0802406a <prvIsQueueEmpty>:
{
 802406a:	b510      	push	{r4, lr}
 802406c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 802406e:	f7ff fe91 	bl	8023d94 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8024072:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024074:	b923      	cbnz	r3, 8024080 <prvIsQueueEmpty+0x16>
			xReturn = pdTRUE;
 8024076:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 8024078:	f7ff feae 	bl	8023dd8 <vPortExitCritical>
}
 802407c:	4620      	mov	r0, r4
 802407e:	bd10      	pop	{r4, pc}
			xReturn = pdFALSE;
 8024080:	2400      	movs	r4, #0
 8024082:	e7f9      	b.n	8024078 <prvIsQueueEmpty+0xe>

08024084 <prvCopyDataToQueue>:
{
 8024084:	b570      	push	{r4, r5, r6, lr}
 8024086:	4604      	mov	r4, r0
 8024088:	4615      	mov	r5, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 802408a:	6b86      	ldr	r6, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 802408c:	6c02      	ldr	r2, [r0, #64]	; 0x40
 802408e:	b95a      	cbnz	r2, 80240a8 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8024090:	6803      	ldr	r3, [r0, #0]
 8024092:	b11b      	cbz	r3, 802409c <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
 8024094:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8024096:	3601      	adds	r6, #1
 8024098:	63a6      	str	r6, [r4, #56]	; 0x38
}
 802409a:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 802409c:	6880      	ldr	r0, [r0, #8]
 802409e:	f001 f9e9 	bl	8025474 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 80240a2:	2300      	movs	r3, #0
 80240a4:	60a3      	str	r3, [r4, #8]
 80240a6:	e7f6      	b.n	8024096 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 80240a8:	b96d      	cbnz	r5, 80240c6 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80240aa:	6840      	ldr	r0, [r0, #4]
 80240ac:	f001 ff30 	bl	8025f10 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80240b0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80240b2:	6863      	ldr	r3, [r4, #4]
 80240b4:	4413      	add	r3, r2
 80240b6:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80240b8:	68a2      	ldr	r2, [r4, #8]
 80240ba:	4293      	cmp	r3, r2
 80240bc:	d319      	bcc.n	80240f2 <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80240be:	6823      	ldr	r3, [r4, #0]
 80240c0:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
 80240c2:	4628      	mov	r0, r5
 80240c4:	e7e7      	b.n	8024096 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 80240c6:	68c0      	ldr	r0, [r0, #12]
 80240c8:	f001 ff22 	bl	8025f10 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80240cc:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80240ce:	4251      	negs	r1, r2
 80240d0:	68e3      	ldr	r3, [r4, #12]
 80240d2:	1a9b      	subs	r3, r3, r2
 80240d4:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80240d6:	6822      	ldr	r2, [r4, #0]
 80240d8:	4293      	cmp	r3, r2
 80240da:	d202      	bcs.n	80240e2 <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 80240dc:	68a3      	ldr	r3, [r4, #8]
 80240de:	440b      	add	r3, r1
 80240e0:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 80240e2:	2d02      	cmp	r5, #2
 80240e4:	d001      	beq.n	80240ea <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 80240e6:	2000      	movs	r0, #0
 80240e8:	e7d5      	b.n	8024096 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80240ea:	b126      	cbz	r6, 80240f6 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 80240ec:	3e01      	subs	r6, #1
BaseType_t xReturn = pdFALSE;
 80240ee:	2000      	movs	r0, #0
 80240f0:	e7d1      	b.n	8024096 <prvCopyDataToQueue+0x12>
 80240f2:	4628      	mov	r0, r5
 80240f4:	e7cf      	b.n	8024096 <prvCopyDataToQueue+0x12>
 80240f6:	2000      	movs	r0, #0
 80240f8:	e7cd      	b.n	8024096 <prvCopyDataToQueue+0x12>

080240fa <prvCopyDataFromQueue>:
{
 80240fa:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80240fc:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80240fe:	b16a      	cbz	r2, 802411c <prvCopyDataFromQueue+0x22>
{
 8024100:	b510      	push	{r4, lr}
 8024102:	4608      	mov	r0, r1
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8024104:	68d9      	ldr	r1, [r3, #12]
 8024106:	4411      	add	r1, r2
 8024108:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 802410a:	689c      	ldr	r4, [r3, #8]
 802410c:	42a1      	cmp	r1, r4
 802410e:	d301      	bcc.n	8024114 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8024110:	6819      	ldr	r1, [r3, #0]
 8024112:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8024114:	68d9      	ldr	r1, [r3, #12]
 8024116:	f001 fefb 	bl	8025f10 <memcpy>
}
 802411a:	bd10      	pop	{r4, pc}
 802411c:	4770      	bx	lr

0802411e <prvUnlockQueue>:
{
 802411e:	b538      	push	{r3, r4, r5, lr}
 8024120:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 8024122:	f7ff fe37 	bl	8023d94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8024126:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 802412a:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 802412c:	e001      	b.n	8024132 <prvUnlockQueue+0x14>
			--cTxLock;
 802412e:	3c01      	subs	r4, #1
 8024130:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8024132:	2c00      	cmp	r4, #0
 8024134:	dd0a      	ble.n	802414c <prvUnlockQueue+0x2e>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8024136:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8024138:	b143      	cbz	r3, 802414c <prvUnlockQueue+0x2e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 802413a:	f105 0024 	add.w	r0, r5, #36	; 0x24
 802413e:	f001 f893 	bl	8025268 <xTaskRemoveFromEventList>
 8024142:	2800      	cmp	r0, #0
 8024144:	d0f3      	beq.n	802412e <prvUnlockQueue+0x10>
						vTaskMissedYield();
 8024146:	f001 f923 	bl	8025390 <vTaskMissedYield>
 802414a:	e7f0      	b.n	802412e <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
 802414c:	23ff      	movs	r3, #255	; 0xff
 802414e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
 8024152:	f7ff fe41 	bl	8023dd8 <vPortExitCritical>
	taskENTER_CRITICAL();
 8024156:	f7ff fe1d 	bl	8023d94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 802415a:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 802415e:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8024160:	e001      	b.n	8024166 <prvUnlockQueue+0x48>
				--cRxLock;
 8024162:	3c01      	subs	r4, #1
 8024164:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8024166:	2c00      	cmp	r4, #0
 8024168:	dd0a      	ble.n	8024180 <prvUnlockQueue+0x62>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 802416a:	692b      	ldr	r3, [r5, #16]
 802416c:	b143      	cbz	r3, 8024180 <prvUnlockQueue+0x62>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 802416e:	f105 0010 	add.w	r0, r5, #16
 8024172:	f001 f879 	bl	8025268 <xTaskRemoveFromEventList>
 8024176:	2800      	cmp	r0, #0
 8024178:	d0f3      	beq.n	8024162 <prvUnlockQueue+0x44>
					vTaskMissedYield();
 802417a:	f001 f909 	bl	8025390 <vTaskMissedYield>
 802417e:	e7f0      	b.n	8024162 <prvUnlockQueue+0x44>
		pxQueue->cRxLock = queueUNLOCKED;
 8024180:	23ff      	movs	r3, #255	; 0xff
 8024182:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
 8024186:	f7ff fe27 	bl	8023dd8 <vPortExitCritical>
}
 802418a:	bd38      	pop	{r3, r4, r5, pc}

0802418c <xQueueGenericReset>:
{
 802418c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 802418e:	b1e0      	cbz	r0, 80241ca <xQueueGenericReset+0x3e>
 8024190:	460d      	mov	r5, r1
 8024192:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8024194:	f7ff fdfe 	bl	8023d94 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8024198:	6823      	ldr	r3, [r4, #0]
 802419a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 802419c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802419e:	fb01 3002 	mla	r0, r1, r2, r3
 80241a2:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80241a4:	2000      	movs	r0, #0
 80241a6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80241a8:	6063      	str	r3, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80241aa:	3a01      	subs	r2, #1
 80241ac:	fb02 3301 	mla	r3, r2, r1, r3
 80241b0:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 80241b2:	23ff      	movs	r3, #255	; 0xff
 80241b4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 80241b8:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 80241bc:	b9fd      	cbnz	r5, 80241fe <xQueueGenericReset+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80241be:	6923      	ldr	r3, [r4, #16]
 80241c0:	b963      	cbnz	r3, 80241dc <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
 80241c2:	f7ff fe09 	bl	8023dd8 <vPortExitCritical>
}
 80241c6:	2001      	movs	r0, #1
 80241c8:	bd38      	pop	{r3, r4, r5, pc}
 80241ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80241ce:	f383 8811 	msr	BASEPRI, r3
 80241d2:	f3bf 8f6f 	isb	sy
 80241d6:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80241da:	e7fe      	b.n	80241da <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80241dc:	f104 0010 	add.w	r0, r4, #16
 80241e0:	f001 f842 	bl	8025268 <xTaskRemoveFromEventList>
 80241e4:	2800      	cmp	r0, #0
 80241e6:	d0ec      	beq.n	80241c2 <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 80241e8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80241ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80241f0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80241f4:	f3bf 8f4f 	dsb	sy
 80241f8:	f3bf 8f6f 	isb	sy
 80241fc:	e7e1      	b.n	80241c2 <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80241fe:	f104 0010 	add.w	r0, r4, #16
 8024202:	f7ff fd17 	bl	8023c34 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8024206:	f104 0024 	add.w	r0, r4, #36	; 0x24
 802420a:	f7ff fd13 	bl	8023c34 <vListInitialise>
 802420e:	e7d8      	b.n	80241c2 <xQueueGenericReset+0x36>

08024210 <prvInitialiseNewQueue>:
{
 8024210:	b538      	push	{r3, r4, r5, lr}
 8024212:	461d      	mov	r5, r3
 8024214:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
 8024216:	460b      	mov	r3, r1
 8024218:	b949      	cbnz	r1, 802422e <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 802421a:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 802421c:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 802421e:	6423      	str	r3, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8024220:	2101      	movs	r1, #1
 8024222:	4620      	mov	r0, r4
 8024224:	f7ff ffb2 	bl	802418c <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 8024228:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
}
 802422c:	bd38      	pop	{r3, r4, r5, pc}
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 802422e:	6022      	str	r2, [r4, #0]
 8024230:	e7f4      	b.n	802421c <prvInitialiseNewQueue+0xc>

08024232 <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8024232:	b940      	cbnz	r0, 8024246 <xQueueGenericCreate+0x14>
 8024234:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024238:	f383 8811 	msr	BASEPRI, r3
 802423c:	f3bf 8f6f 	isb	sy
 8024240:	f3bf 8f4f 	dsb	sy
 8024244:	e7fe      	b.n	8024244 <xQueueGenericCreate+0x12>
	{
 8024246:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024248:	b083      	sub	sp, #12
 802424a:	460c      	mov	r4, r1
 802424c:	4615      	mov	r5, r2
 802424e:	4606      	mov	r6, r0
		if( uxItemSize == ( UBaseType_t ) 0 )
 8024250:	b189      	cbz	r1, 8024276 <xQueueGenericCreate+0x44>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8024252:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8024256:	3050      	adds	r0, #80	; 0x50
 8024258:	f7ff fc3c 	bl	8023ad4 <pvPortMalloc>
		if( pxNewQueue != NULL )
 802425c:	4607      	mov	r7, r0
 802425e:	b138      	cbz	r0, 8024270 <xQueueGenericCreate+0x3e>
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8024260:	9000      	str	r0, [sp, #0]
 8024262:	462b      	mov	r3, r5
 8024264:	f100 0250 	add.w	r2, r0, #80	; 0x50
 8024268:	4621      	mov	r1, r4
 802426a:	4630      	mov	r0, r6
 802426c:	f7ff ffd0 	bl	8024210 <prvInitialiseNewQueue>
	}
 8024270:	4638      	mov	r0, r7
 8024272:	b003      	add	sp, #12
 8024274:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xQueueSizeInBytes = ( size_t ) 0;
 8024276:	4608      	mov	r0, r1
 8024278:	e7ed      	b.n	8024256 <xQueueGenericCreate+0x24>

0802427a <xQueueCreateCountingSemaphore>:
		configASSERT( uxMaxCount != 0 );
 802427a:	b940      	cbnz	r0, 802428e <xQueueCreateCountingSemaphore+0x14>
 802427c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024280:	f383 8811 	msr	BASEPRI, r3
 8024284:	f3bf 8f6f 	isb	sy
 8024288:	f3bf 8f4f 	dsb	sy
 802428c:	e7fe      	b.n	802428c <xQueueCreateCountingSemaphore+0x12>
	{
 802428e:	b510      	push	{r4, lr}
 8024290:	460c      	mov	r4, r1
		configASSERT( uxInitialCount <= uxMaxCount );
 8024292:	4288      	cmp	r0, r1
 8024294:	d208      	bcs.n	80242a8 <xQueueCreateCountingSemaphore+0x2e>
 8024296:	f04f 0350 	mov.w	r3, #80	; 0x50
 802429a:	f383 8811 	msr	BASEPRI, r3
 802429e:	f3bf 8f6f 	isb	sy
 80242a2:	f3bf 8f4f 	dsb	sy
 80242a6:	e7fe      	b.n	80242a6 <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80242a8:	2202      	movs	r2, #2
 80242aa:	2100      	movs	r1, #0
 80242ac:	f7ff ffc1 	bl	8024232 <xQueueGenericCreate>
		if( xHandle != NULL )
 80242b0:	b100      	cbz	r0, 80242b4 <xQueueCreateCountingSemaphore+0x3a>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80242b2:	6384      	str	r4, [r0, #56]	; 0x38
	}
 80242b4:	bd10      	pop	{r4, pc}

080242b6 <xQueueGenericSend>:
{
 80242b6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80242b8:	b085      	sub	sp, #20
 80242ba:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 80242bc:	b188      	cbz	r0, 80242e2 <xQueueGenericSend+0x2c>
 80242be:	460f      	mov	r7, r1
 80242c0:	461d      	mov	r5, r3
 80242c2:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80242c4:	b1b1      	cbz	r1, 80242f4 <xQueueGenericSend+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80242c6:	2d02      	cmp	r5, #2
 80242c8:	d120      	bne.n	802430c <xQueueGenericSend+0x56>
 80242ca:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80242cc:	2b01      	cmp	r3, #1
 80242ce:	d01d      	beq.n	802430c <xQueueGenericSend+0x56>
 80242d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80242d4:	f383 8811 	msr	BASEPRI, r3
 80242d8:	f3bf 8f6f 	isb	sy
 80242dc:	f3bf 8f4f 	dsb	sy
 80242e0:	e7fe      	b.n	80242e0 <xQueueGenericSend+0x2a>
 80242e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80242e6:	f383 8811 	msr	BASEPRI, r3
 80242ea:	f3bf 8f6f 	isb	sy
 80242ee:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80242f2:	e7fe      	b.n	80242f2 <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80242f4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80242f6:	2b00      	cmp	r3, #0
 80242f8:	d0e5      	beq.n	80242c6 <xQueueGenericSend+0x10>
 80242fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80242fe:	f383 8811 	msr	BASEPRI, r3
 8024302:	f3bf 8f6f 	isb	sy
 8024306:	f3bf 8f4f 	dsb	sy
 802430a:	e7fe      	b.n	802430a <xQueueGenericSend+0x54>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 802430c:	f001 f846 	bl	802539c <xTaskGetSchedulerState>
 8024310:	4606      	mov	r6, r0
 8024312:	b958      	cbnz	r0, 802432c <xQueueGenericSend+0x76>
 8024314:	9b01      	ldr	r3, [sp, #4]
 8024316:	2b00      	cmp	r3, #0
 8024318:	d048      	beq.n	80243ac <xQueueGenericSend+0xf6>
 802431a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802431e:	f383 8811 	msr	BASEPRI, r3
 8024322:	f3bf 8f6f 	isb	sy
 8024326:	f3bf 8f4f 	dsb	sy
 802432a:	e7fe      	b.n	802432a <xQueueGenericSend+0x74>
 802432c:	2600      	movs	r6, #0
 802432e:	e03d      	b.n	80243ac <xQueueGenericSend+0xf6>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8024330:	462a      	mov	r2, r5
 8024332:	4639      	mov	r1, r7
 8024334:	4620      	mov	r0, r4
 8024336:	f7ff fea5 	bl	8024084 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 802433a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802433c:	b97b      	cbnz	r3, 802435e <xQueueGenericSend+0xa8>
					else if( xYieldRequired != pdFALSE )
 802433e:	b148      	cbz	r0, 8024354 <xQueueGenericSend+0x9e>
						queueYIELD_IF_USING_PREEMPTION();
 8024340:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024344:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024348:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 802434c:	f3bf 8f4f 	dsb	sy
 8024350:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8024354:	f7ff fd40 	bl	8023dd8 <vPortExitCritical>
				return pdPASS;
 8024358:	2001      	movs	r0, #1
}
 802435a:	b005      	add	sp, #20
 802435c:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 802435e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8024362:	f000 ff81 	bl	8025268 <xTaskRemoveFromEventList>
 8024366:	2800      	cmp	r0, #0
 8024368:	d0f4      	beq.n	8024354 <xQueueGenericSend+0x9e>
							queueYIELD_IF_USING_PREEMPTION();
 802436a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802436e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024372:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024376:	f3bf 8f4f 	dsb	sy
 802437a:	f3bf 8f6f 	isb	sy
 802437e:	e7e9      	b.n	8024354 <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
 8024380:	f7ff fd2a 	bl	8023dd8 <vPortExitCritical>
					return errQUEUE_FULL;
 8024384:	2000      	movs	r0, #0
 8024386:	e7e8      	b.n	802435a <xQueueGenericSend+0xa4>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8024388:	a802      	add	r0, sp, #8
 802438a:	f000 ffb3 	bl	80252f4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 802438e:	2601      	movs	r6, #1
 8024390:	e019      	b.n	80243c6 <xQueueGenericSend+0x110>
		prvLockQueue( pxQueue );
 8024392:	2300      	movs	r3, #0
 8024394:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8024398:	e021      	b.n	80243de <xQueueGenericSend+0x128>
 802439a:	2300      	movs	r3, #0
 802439c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80243a0:	e023      	b.n	80243ea <xQueueGenericSend+0x134>
				prvUnlockQueue( pxQueue );
 80243a2:	4620      	mov	r0, r4
 80243a4:	f7ff febb 	bl	802411e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80243a8:	f000 fe3c 	bl	8025024 <xTaskResumeAll>
		taskENTER_CRITICAL();
 80243ac:	f7ff fcf2 	bl	8023d94 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80243b0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80243b2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80243b4:	429a      	cmp	r2, r3
 80243b6:	d3bb      	bcc.n	8024330 <xQueueGenericSend+0x7a>
 80243b8:	2d02      	cmp	r5, #2
 80243ba:	d0b9      	beq.n	8024330 <xQueueGenericSend+0x7a>
				if( xTicksToWait == ( TickType_t ) 0 )
 80243bc:	9b01      	ldr	r3, [sp, #4]
 80243be:	2b00      	cmp	r3, #0
 80243c0:	d0de      	beq.n	8024380 <xQueueGenericSend+0xca>
				else if( xEntryTimeSet == pdFALSE )
 80243c2:	2e00      	cmp	r6, #0
 80243c4:	d0e0      	beq.n	8024388 <xQueueGenericSend+0xd2>
		taskEXIT_CRITICAL();
 80243c6:	f7ff fd07 	bl	8023dd8 <vPortExitCritical>
		vTaskSuspendAll();
 80243ca:	f000 fd89 	bl	8024ee0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80243ce:	f7ff fce1 	bl	8023d94 <vPortEnterCritical>
 80243d2:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 80243d6:	b252      	sxtb	r2, r2
 80243d8:	f1b2 3fff 	cmp.w	r2, #4294967295
 80243dc:	d0d9      	beq.n	8024392 <xQueueGenericSend+0xdc>
 80243de:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 80243e2:	b252      	sxtb	r2, r2
 80243e4:	f1b2 3fff 	cmp.w	r2, #4294967295
 80243e8:	d0d7      	beq.n	802439a <xQueueGenericSend+0xe4>
 80243ea:	f7ff fcf5 	bl	8023dd8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80243ee:	a901      	add	r1, sp, #4
 80243f0:	a802      	add	r0, sp, #8
 80243f2:	f000 ff8b 	bl	802530c <xTaskCheckForTimeOut>
 80243f6:	b9d8      	cbnz	r0, 8024430 <xQueueGenericSend+0x17a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80243f8:	4620      	mov	r0, r4
 80243fa:	f7ff fe27 	bl	802404c <prvIsQueueFull>
 80243fe:	2800      	cmp	r0, #0
 8024400:	d0cf      	beq.n	80243a2 <xQueueGenericSend+0xec>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8024402:	9901      	ldr	r1, [sp, #4]
 8024404:	f104 0010 	add.w	r0, r4, #16
 8024408:	f000 fefa 	bl	8025200 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 802440c:	4620      	mov	r0, r4
 802440e:	f7ff fe86 	bl	802411e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8024412:	f000 fe07 	bl	8025024 <xTaskResumeAll>
 8024416:	2800      	cmp	r0, #0
 8024418:	d1c8      	bne.n	80243ac <xQueueGenericSend+0xf6>
					portYIELD_WITHIN_API();
 802441a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802441e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024422:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024426:	f3bf 8f4f 	dsb	sy
 802442a:	f3bf 8f6f 	isb	sy
 802442e:	e7bd      	b.n	80243ac <xQueueGenericSend+0xf6>
			prvUnlockQueue( pxQueue );
 8024430:	4620      	mov	r0, r4
 8024432:	f7ff fe74 	bl	802411e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8024436:	f000 fdf5 	bl	8025024 <xTaskResumeAll>
			return errQUEUE_FULL;
 802443a:	2000      	movs	r0, #0
 802443c:	e78d      	b.n	802435a <xQueueGenericSend+0xa4>

0802443e <prvInitialiseMutex>:
		if( pxNewQueue != NULL )
 802443e:	b148      	cbz	r0, 8024454 <prvInitialiseMutex+0x16>
	{
 8024440:	b508      	push	{r3, lr}
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8024442:	2100      	movs	r1, #0
 8024444:	6081      	str	r1, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8024446:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 8024448:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 802444a:	460b      	mov	r3, r1
 802444c:	460a      	mov	r2, r1
 802444e:	f7ff ff32 	bl	80242b6 <xQueueGenericSend>
	}
 8024452:	bd08      	pop	{r3, pc}
 8024454:	4770      	bx	lr

08024456 <xQueueCreateMutex>:
	{
 8024456:	b510      	push	{r4, lr}
 8024458:	4602      	mov	r2, r0
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 802445a:	2100      	movs	r1, #0
 802445c:	2001      	movs	r0, #1
 802445e:	f7ff fee8 	bl	8024232 <xQueueGenericCreate>
 8024462:	4604      	mov	r4, r0
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 8024464:	f7ff ffeb 	bl	802443e <prvInitialiseMutex>
	}
 8024468:	4620      	mov	r0, r4
 802446a:	bd10      	pop	{r4, pc}

0802446c <xQueueGenericSendFromISR>:
{
 802446c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8024470:	b190      	cbz	r0, 8024498 <xQueueGenericSendFromISR+0x2c>
 8024472:	460f      	mov	r7, r1
 8024474:	4616      	mov	r6, r2
 8024476:	461c      	mov	r4, r3
 8024478:	4605      	mov	r5, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 802447a:	b1b1      	cbz	r1, 80244aa <xQueueGenericSendFromISR+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 802447c:	2c02      	cmp	r4, #2
 802447e:	d120      	bne.n	80244c2 <xQueueGenericSendFromISR+0x56>
 8024480:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8024482:	2b01      	cmp	r3, #1
 8024484:	d01d      	beq.n	80244c2 <xQueueGenericSendFromISR+0x56>
 8024486:	f04f 0350 	mov.w	r3, #80	; 0x50
 802448a:	f383 8811 	msr	BASEPRI, r3
 802448e:	f3bf 8f6f 	isb	sy
 8024492:	f3bf 8f4f 	dsb	sy
 8024496:	e7fe      	b.n	8024496 <xQueueGenericSendFromISR+0x2a>
 8024498:	f04f 0350 	mov.w	r3, #80	; 0x50
 802449c:	f383 8811 	msr	BASEPRI, r3
 80244a0:	f3bf 8f6f 	isb	sy
 80244a4:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80244a8:	e7fe      	b.n	80244a8 <xQueueGenericSendFromISR+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80244aa:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80244ac:	2b00      	cmp	r3, #0
 80244ae:	d0e5      	beq.n	802447c <xQueueGenericSendFromISR+0x10>
 80244b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80244b4:	f383 8811 	msr	BASEPRI, r3
 80244b8:	f3bf 8f6f 	isb	sy
 80244bc:	f3bf 8f4f 	dsb	sy
 80244c0:	e7fe      	b.n	80244c0 <xQueueGenericSendFromISR+0x54>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80244c2:	f7ff fd8d 	bl	8023fe0 <vPortValidateInterruptPriority>
	__asm volatile
 80244c6:	f3ef 8811 	mrs	r8, BASEPRI
 80244ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80244ce:	f383 8811 	msr	BASEPRI, r3
 80244d2:	f3bf 8f6f 	isb	sy
 80244d6:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80244da:	6baa      	ldr	r2, [r5, #56]	; 0x38
 80244dc:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80244de:	429a      	cmp	r2, r3
 80244e0:	d306      	bcc.n	80244f0 <xQueueGenericSendFromISR+0x84>
 80244e2:	2c02      	cmp	r4, #2
 80244e4:	d004      	beq.n	80244f0 <xQueueGenericSendFromISR+0x84>
			xReturn = errQUEUE_FULL;
 80244e6:	2000      	movs	r0, #0
	__asm volatile
 80244e8:	f388 8811 	msr	BASEPRI, r8
}
 80244ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			const int8_t cTxLock = pxQueue->cTxLock;
 80244f0:	f895 9045 	ldrb.w	r9, [r5, #69]	; 0x45
 80244f4:	fa4f f989 	sxtb.w	r9, r9
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80244f8:	4622      	mov	r2, r4
 80244fa:	4639      	mov	r1, r7
 80244fc:	4628      	mov	r0, r5
 80244fe:	f7ff fdc1 	bl	8024084 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8024502:	f1b9 3fff 	cmp.w	r9, #4294967295
 8024506:	d006      	beq.n	8024516 <xQueueGenericSendFromISR+0xaa>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8024508:	f109 0301 	add.w	r3, r9, #1
 802450c:	b25b      	sxtb	r3, r3
 802450e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
			xReturn = pdPASS;
 8024512:	2001      	movs	r0, #1
 8024514:	e7e8      	b.n	80244e8 <xQueueGenericSendFromISR+0x7c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8024516:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8024518:	b90b      	cbnz	r3, 802451e <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
 802451a:	2001      	movs	r0, #1
 802451c:	e7e4      	b.n	80244e8 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 802451e:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8024522:	f000 fea1 	bl	8025268 <xTaskRemoveFromEventList>
 8024526:	b118      	cbz	r0, 8024530 <xQueueGenericSendFromISR+0xc4>
							if( pxHigherPriorityTaskWoken != NULL )
 8024528:	b126      	cbz	r6, 8024534 <xQueueGenericSendFromISR+0xc8>
								*pxHigherPriorityTaskWoken = pdTRUE;
 802452a:	2001      	movs	r0, #1
 802452c:	6030      	str	r0, [r6, #0]
 802452e:	e7db      	b.n	80244e8 <xQueueGenericSendFromISR+0x7c>
			xReturn = pdPASS;
 8024530:	2001      	movs	r0, #1
 8024532:	e7d9      	b.n	80244e8 <xQueueGenericSendFromISR+0x7c>
 8024534:	2001      	movs	r0, #1
 8024536:	e7d7      	b.n	80244e8 <xQueueGenericSendFromISR+0x7c>

08024538 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 8024538:	b168      	cbz	r0, 8024556 <xQueueGiveFromISR+0x1e>
{
 802453a:	b570      	push	{r4, r5, r6, lr}
 802453c:	460c      	mov	r4, r1
 802453e:	4605      	mov	r5, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 8024540:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8024542:	b18b      	cbz	r3, 8024568 <xQueueGiveFromISR+0x30>
	__asm volatile
 8024544:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024548:	f383 8811 	msr	BASEPRI, r3
 802454c:	f3bf 8f6f 	isb	sy
 8024550:	f3bf 8f4f 	dsb	sy
 8024554:	e7fe      	b.n	8024554 <xQueueGiveFromISR+0x1c>
 8024556:	f04f 0350 	mov.w	r3, #80	; 0x50
 802455a:	f383 8811 	msr	BASEPRI, r3
 802455e:	f3bf 8f6f 	isb	sy
 8024562:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8024566:	e7fe      	b.n	8024566 <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8024568:	6803      	ldr	r3, [r0, #0]
 802456a:	b1eb      	cbz	r3, 80245a8 <xQueueGiveFromISR+0x70>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 802456c:	f7ff fd38 	bl	8023fe0 <vPortValidateInterruptPriority>
	__asm volatile
 8024570:	f3ef 8611 	mrs	r6, BASEPRI
 8024574:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024578:	f383 8811 	msr	BASEPRI, r3
 802457c:	f3bf 8f6f 	isb	sy
 8024580:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8024584:	6baa      	ldr	r2, [r5, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8024586:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8024588:	4293      	cmp	r3, r2
 802458a:	d926      	bls.n	80245da <xQueueGiveFromISR+0xa2>
			const int8_t cTxLock = pxQueue->cTxLock;
 802458c:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 8024590:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8024592:	3201      	adds	r2, #1
 8024594:	63aa      	str	r2, [r5, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8024596:	f1b3 3fff 	cmp.w	r3, #4294967295
 802459a:	d011      	beq.n	80245c0 <xQueueGiveFromISR+0x88>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 802459c:	3301      	adds	r3, #1
 802459e:	b25b      	sxtb	r3, r3
 80245a0:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
			xReturn = pdPASS;
 80245a4:	2001      	movs	r0, #1
 80245a6:	e019      	b.n	80245dc <xQueueGiveFromISR+0xa4>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 80245a8:	6883      	ldr	r3, [r0, #8]
 80245aa:	2b00      	cmp	r3, #0
 80245ac:	d0de      	beq.n	802456c <xQueueGiveFromISR+0x34>
	__asm volatile
 80245ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80245b2:	f383 8811 	msr	BASEPRI, r3
 80245b6:	f3bf 8f6f 	isb	sy
 80245ba:	f3bf 8f4f 	dsb	sy
 80245be:	e7fe      	b.n	80245be <xQueueGiveFromISR+0x86>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80245c0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80245c2:	b90b      	cbnz	r3, 80245c8 <xQueueGiveFromISR+0x90>
			xReturn = pdPASS;
 80245c4:	2001      	movs	r0, #1
 80245c6:	e009      	b.n	80245dc <xQueueGiveFromISR+0xa4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80245c8:	f105 0024 	add.w	r0, r5, #36	; 0x24
 80245cc:	f000 fe4c 	bl	8025268 <xTaskRemoveFromEventList>
 80245d0:	b138      	cbz	r0, 80245e2 <xQueueGiveFromISR+0xaa>
							if( pxHigherPriorityTaskWoken != NULL )
 80245d2:	b144      	cbz	r4, 80245e6 <xQueueGiveFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80245d4:	2001      	movs	r0, #1
 80245d6:	6020      	str	r0, [r4, #0]
 80245d8:	e000      	b.n	80245dc <xQueueGiveFromISR+0xa4>
			xReturn = errQUEUE_FULL;
 80245da:	2000      	movs	r0, #0
	__asm volatile
 80245dc:	f386 8811 	msr	BASEPRI, r6
}
 80245e0:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdPASS;
 80245e2:	2001      	movs	r0, #1
 80245e4:	e7fa      	b.n	80245dc <xQueueGiveFromISR+0xa4>
 80245e6:	2001      	movs	r0, #1
 80245e8:	e7f8      	b.n	80245dc <xQueueGiveFromISR+0xa4>

080245ea <xQueueReceive>:
{
 80245ea:	b5f0      	push	{r4, r5, r6, r7, lr}
 80245ec:	b085      	sub	sp, #20
 80245ee:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 80245f0:	b190      	cbz	r0, 8024618 <xQueueReceive+0x2e>
 80245f2:	460f      	mov	r7, r1
 80245f4:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80245f6:	b1c1      	cbz	r1, 802462a <xQueueReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80245f8:	f000 fed0 	bl	802539c <xTaskGetSchedulerState>
 80245fc:	4606      	mov	r6, r0
 80245fe:	bb00      	cbnz	r0, 8024642 <xQueueReceive+0x58>
 8024600:	9b01      	ldr	r3, [sp, #4]
 8024602:	2b00      	cmp	r3, #0
 8024604:	d05e      	beq.n	80246c4 <xQueueReceive+0xda>
	__asm volatile
 8024606:	f04f 0350 	mov.w	r3, #80	; 0x50
 802460a:	f383 8811 	msr	BASEPRI, r3
 802460e:	f3bf 8f6f 	isb	sy
 8024612:	f3bf 8f4f 	dsb	sy
 8024616:	e7fe      	b.n	8024616 <xQueueReceive+0x2c>
 8024618:	f04f 0350 	mov.w	r3, #80	; 0x50
 802461c:	f383 8811 	msr	BASEPRI, r3
 8024620:	f3bf 8f6f 	isb	sy
 8024624:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8024628:	e7fe      	b.n	8024628 <xQueueReceive+0x3e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 802462a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 802462c:	2b00      	cmp	r3, #0
 802462e:	d0e3      	beq.n	80245f8 <xQueueReceive+0xe>
 8024630:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024634:	f383 8811 	msr	BASEPRI, r3
 8024638:	f3bf 8f6f 	isb	sy
 802463c:	f3bf 8f4f 	dsb	sy
 8024640:	e7fe      	b.n	8024640 <xQueueReceive+0x56>
 8024642:	2600      	movs	r6, #0
 8024644:	e03e      	b.n	80246c4 <xQueueReceive+0xda>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8024646:	4639      	mov	r1, r7
 8024648:	4620      	mov	r0, r4
 802464a:	f7ff fd56 	bl	80240fa <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 802464e:	3d01      	subs	r5, #1
 8024650:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8024652:	6923      	ldr	r3, [r4, #16]
 8024654:	b923      	cbnz	r3, 8024660 <xQueueReceive+0x76>
				taskEXIT_CRITICAL();
 8024656:	f7ff fbbf 	bl	8023dd8 <vPortExitCritical>
				return pdPASS;
 802465a:	2001      	movs	r0, #1
}
 802465c:	b005      	add	sp, #20
 802465e:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8024660:	f104 0010 	add.w	r0, r4, #16
 8024664:	f000 fe00 	bl	8025268 <xTaskRemoveFromEventList>
 8024668:	2800      	cmp	r0, #0
 802466a:	d0f4      	beq.n	8024656 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
 802466c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024670:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024674:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024678:	f3bf 8f4f 	dsb	sy
 802467c:	f3bf 8f6f 	isb	sy
 8024680:	e7e9      	b.n	8024656 <xQueueReceive+0x6c>
					taskEXIT_CRITICAL();
 8024682:	f7ff fba9 	bl	8023dd8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8024686:	2000      	movs	r0, #0
 8024688:	e7e8      	b.n	802465c <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
 802468a:	a802      	add	r0, sp, #8
 802468c:	f000 fe32 	bl	80252f4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8024690:	2601      	movs	r6, #1
 8024692:	e021      	b.n	80246d8 <xQueueReceive+0xee>
		prvLockQueue( pxQueue );
 8024694:	2300      	movs	r3, #0
 8024696:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 802469a:	e029      	b.n	80246f0 <xQueueReceive+0x106>
 802469c:	2300      	movs	r3, #0
 802469e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80246a2:	e02b      	b.n	80246fc <xQueueReceive+0x112>
				prvUnlockQueue( pxQueue );
 80246a4:	4620      	mov	r0, r4
 80246a6:	f7ff fd3a 	bl	802411e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80246aa:	f000 fcbb 	bl	8025024 <xTaskResumeAll>
 80246ae:	e009      	b.n	80246c4 <xQueueReceive+0xda>
			prvUnlockQueue( pxQueue );
 80246b0:	4620      	mov	r0, r4
 80246b2:	f7ff fd34 	bl	802411e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80246b6:	f000 fcb5 	bl	8025024 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80246ba:	4620      	mov	r0, r4
 80246bc:	f7ff fcd5 	bl	802406a <prvIsQueueEmpty>
 80246c0:	2800      	cmp	r0, #0
 80246c2:	d13f      	bne.n	8024744 <xQueueReceive+0x15a>
		taskENTER_CRITICAL();
 80246c4:	f7ff fb66 	bl	8023d94 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80246c8:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80246ca:	2d00      	cmp	r5, #0
 80246cc:	d1bb      	bne.n	8024646 <xQueueReceive+0x5c>
				if( xTicksToWait == ( TickType_t ) 0 )
 80246ce:	9b01      	ldr	r3, [sp, #4]
 80246d0:	2b00      	cmp	r3, #0
 80246d2:	d0d6      	beq.n	8024682 <xQueueReceive+0x98>
				else if( xEntryTimeSet == pdFALSE )
 80246d4:	2e00      	cmp	r6, #0
 80246d6:	d0d8      	beq.n	802468a <xQueueReceive+0xa0>
		taskEXIT_CRITICAL();
 80246d8:	f7ff fb7e 	bl	8023dd8 <vPortExitCritical>
		vTaskSuspendAll();
 80246dc:	f000 fc00 	bl	8024ee0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80246e0:	f7ff fb58 	bl	8023d94 <vPortEnterCritical>
 80246e4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80246e8:	b25b      	sxtb	r3, r3
 80246ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 80246ee:	d0d1      	beq.n	8024694 <xQueueReceive+0xaa>
 80246f0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80246f4:	b25b      	sxtb	r3, r3
 80246f6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80246fa:	d0cf      	beq.n	802469c <xQueueReceive+0xb2>
 80246fc:	f7ff fb6c 	bl	8023dd8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8024700:	a901      	add	r1, sp, #4
 8024702:	a802      	add	r0, sp, #8
 8024704:	f000 fe02 	bl	802530c <xTaskCheckForTimeOut>
 8024708:	2800      	cmp	r0, #0
 802470a:	d1d1      	bne.n	80246b0 <xQueueReceive+0xc6>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 802470c:	4620      	mov	r0, r4
 802470e:	f7ff fcac 	bl	802406a <prvIsQueueEmpty>
 8024712:	2800      	cmp	r0, #0
 8024714:	d0c6      	beq.n	80246a4 <xQueueReceive+0xba>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8024716:	9901      	ldr	r1, [sp, #4]
 8024718:	f104 0024 	add.w	r0, r4, #36	; 0x24
 802471c:	f000 fd70 	bl	8025200 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8024720:	4620      	mov	r0, r4
 8024722:	f7ff fcfc 	bl	802411e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8024726:	f000 fc7d 	bl	8025024 <xTaskResumeAll>
 802472a:	2800      	cmp	r0, #0
 802472c:	d1ca      	bne.n	80246c4 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
 802472e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024732:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024736:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 802473a:	f3bf 8f4f 	dsb	sy
 802473e:	f3bf 8f6f 	isb	sy
 8024742:	e7bf      	b.n	80246c4 <xQueueReceive+0xda>
				return errQUEUE_EMPTY;
 8024744:	2000      	movs	r0, #0
 8024746:	e789      	b.n	802465c <xQueueReceive+0x72>

08024748 <xQueueSemaphoreTake>:
{
 8024748:	b570      	push	{r4, r5, r6, lr}
 802474a:	b084      	sub	sp, #16
 802474c:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 802474e:	b158      	cbz	r0, 8024768 <xQueueSemaphoreTake+0x20>
 8024750:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 8024752:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8024754:	b18b      	cbz	r3, 802477a <xQueueSemaphoreTake+0x32>
 8024756:	f04f 0350 	mov.w	r3, #80	; 0x50
 802475a:	f383 8811 	msr	BASEPRI, r3
 802475e:	f3bf 8f6f 	isb	sy
 8024762:	f3bf 8f4f 	dsb	sy
 8024766:	e7fe      	b.n	8024766 <xQueueSemaphoreTake+0x1e>
 8024768:	f04f 0350 	mov.w	r3, #80	; 0x50
 802476c:	f383 8811 	msr	BASEPRI, r3
 8024770:	f3bf 8f6f 	isb	sy
 8024774:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8024778:	e7fe      	b.n	8024778 <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 802477a:	f000 fe0f 	bl	802539c <xTaskGetSchedulerState>
 802477e:	4605      	mov	r5, r0
 8024780:	b950      	cbnz	r0, 8024798 <xQueueSemaphoreTake+0x50>
 8024782:	9b01      	ldr	r3, [sp, #4]
 8024784:	b15b      	cbz	r3, 802479e <xQueueSemaphoreTake+0x56>
 8024786:	f04f 0350 	mov.w	r3, #80	; 0x50
 802478a:	f383 8811 	msr	BASEPRI, r3
 802478e:	f3bf 8f6f 	isb	sy
 8024792:	f3bf 8f4f 	dsb	sy
 8024796:	e7fe      	b.n	8024796 <xQueueSemaphoreTake+0x4e>
 8024798:	2600      	movs	r6, #0
 802479a:	4635      	mov	r5, r6
 802479c:	e055      	b.n	802484a <xQueueSemaphoreTake+0x102>
 802479e:	4606      	mov	r6, r0
 80247a0:	e053      	b.n	802484a <xQueueSemaphoreTake+0x102>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 80247a2:	3b01      	subs	r3, #1
 80247a4:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80247a6:	6823      	ldr	r3, [r4, #0]
 80247a8:	b13b      	cbz	r3, 80247ba <xQueueSemaphoreTake+0x72>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80247aa:	6923      	ldr	r3, [r4, #16]
 80247ac:	b94b      	cbnz	r3, 80247c2 <xQueueSemaphoreTake+0x7a>
				taskEXIT_CRITICAL();
 80247ae:	f7ff fb13 	bl	8023dd8 <vPortExitCritical>
				return pdPASS;
 80247b2:	2601      	movs	r6, #1
}
 80247b4:	4630      	mov	r0, r6
 80247b6:	b004      	add	sp, #16
 80247b8:	bd70      	pop	{r4, r5, r6, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 80247ba:	f000 ff13 	bl	80255e4 <pvTaskIncrementMutexHeldCount>
 80247be:	60a0      	str	r0, [r4, #8]
 80247c0:	e7f3      	b.n	80247aa <xQueueSemaphoreTake+0x62>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80247c2:	f104 0010 	add.w	r0, r4, #16
 80247c6:	f000 fd4f 	bl	8025268 <xTaskRemoveFromEventList>
 80247ca:	2800      	cmp	r0, #0
 80247cc:	d0ef      	beq.n	80247ae <xQueueSemaphoreTake+0x66>
						queueYIELD_IF_USING_PREEMPTION();
 80247ce:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80247d2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80247d6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80247da:	f3bf 8f4f 	dsb	sy
 80247de:	f3bf 8f6f 	isb	sy
 80247e2:	e7e4      	b.n	80247ae <xQueueSemaphoreTake+0x66>
						configASSERT( xInheritanceOccurred == pdFALSE );
 80247e4:	b146      	cbz	r6, 80247f8 <xQueueSemaphoreTake+0xb0>
 80247e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80247ea:	f383 8811 	msr	BASEPRI, r3
 80247ee:	f3bf 8f6f 	isb	sy
 80247f2:	f3bf 8f4f 	dsb	sy
 80247f6:	e7fe      	b.n	80247f6 <xQueueSemaphoreTake+0xae>
					taskEXIT_CRITICAL();
 80247f8:	f7ff faee 	bl	8023dd8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80247fc:	e7da      	b.n	80247b4 <xQueueSemaphoreTake+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80247fe:	a802      	add	r0, sp, #8
 8024800:	f000 fd78 	bl	80252f4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8024804:	2501      	movs	r5, #1
 8024806:	e02a      	b.n	802485e <xQueueSemaphoreTake+0x116>
		prvLockQueue( pxQueue );
 8024808:	2300      	movs	r3, #0
 802480a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 802480e:	e032      	b.n	8024876 <xQueueSemaphoreTake+0x12e>
 8024810:	2300      	movs	r3, #0
 8024812:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8024816:	e034      	b.n	8024882 <xQueueSemaphoreTake+0x13a>
						taskENTER_CRITICAL();
 8024818:	f7ff fabc 	bl	8023d94 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 802481c:	68a0      	ldr	r0, [r4, #8]
 802481e:	f000 fdcd 	bl	80253bc <xTaskPriorityInherit>
 8024822:	4606      	mov	r6, r0
						taskEXIT_CRITICAL();
 8024824:	f7ff fad8 	bl	8023dd8 <vPortExitCritical>
 8024828:	e03b      	b.n	80248a2 <xQueueSemaphoreTake+0x15a>
				prvUnlockQueue( pxQueue );
 802482a:	4620      	mov	r0, r4
 802482c:	f7ff fc77 	bl	802411e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8024830:	f000 fbf8 	bl	8025024 <xTaskResumeAll>
 8024834:	e009      	b.n	802484a <xQueueSemaphoreTake+0x102>
			prvUnlockQueue( pxQueue );
 8024836:	4620      	mov	r0, r4
 8024838:	f7ff fc71 	bl	802411e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 802483c:	f000 fbf2 	bl	8025024 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8024840:	4620      	mov	r0, r4
 8024842:	f7ff fc12 	bl	802406a <prvIsQueueEmpty>
 8024846:	2800      	cmp	r0, #0
 8024848:	d142      	bne.n	80248d0 <xQueueSemaphoreTake+0x188>
		taskENTER_CRITICAL();
 802484a:	f7ff faa3 	bl	8023d94 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 802484e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8024850:	2b00      	cmp	r3, #0
 8024852:	d1a6      	bne.n	80247a2 <xQueueSemaphoreTake+0x5a>
				if( xTicksToWait == ( TickType_t ) 0 )
 8024854:	9b01      	ldr	r3, [sp, #4]
 8024856:	2b00      	cmp	r3, #0
 8024858:	d0c4      	beq.n	80247e4 <xQueueSemaphoreTake+0x9c>
				else if( xEntryTimeSet == pdFALSE )
 802485a:	2d00      	cmp	r5, #0
 802485c:	d0cf      	beq.n	80247fe <xQueueSemaphoreTake+0xb6>
		taskEXIT_CRITICAL();
 802485e:	f7ff fabb 	bl	8023dd8 <vPortExitCritical>
		vTaskSuspendAll();
 8024862:	f000 fb3d 	bl	8024ee0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8024866:	f7ff fa95 	bl	8023d94 <vPortEnterCritical>
 802486a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 802486e:	b25b      	sxtb	r3, r3
 8024870:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024874:	d0c8      	beq.n	8024808 <xQueueSemaphoreTake+0xc0>
 8024876:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 802487a:	b25b      	sxtb	r3, r3
 802487c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024880:	d0c6      	beq.n	8024810 <xQueueSemaphoreTake+0xc8>
 8024882:	f7ff faa9 	bl	8023dd8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8024886:	a901      	add	r1, sp, #4
 8024888:	a802      	add	r0, sp, #8
 802488a:	f000 fd3f 	bl	802530c <xTaskCheckForTimeOut>
 802488e:	2800      	cmp	r0, #0
 8024890:	d1d1      	bne.n	8024836 <xQueueSemaphoreTake+0xee>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8024892:	4620      	mov	r0, r4
 8024894:	f7ff fbe9 	bl	802406a <prvIsQueueEmpty>
 8024898:	2800      	cmp	r0, #0
 802489a:	d0c6      	beq.n	802482a <xQueueSemaphoreTake+0xe2>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 802489c:	6823      	ldr	r3, [r4, #0]
 802489e:	2b00      	cmp	r3, #0
 80248a0:	d0ba      	beq.n	8024818 <xQueueSemaphoreTake+0xd0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80248a2:	9901      	ldr	r1, [sp, #4]
 80248a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80248a8:	f000 fcaa 	bl	8025200 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80248ac:	4620      	mov	r0, r4
 80248ae:	f7ff fc36 	bl	802411e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80248b2:	f000 fbb7 	bl	8025024 <xTaskResumeAll>
 80248b6:	2800      	cmp	r0, #0
 80248b8:	d1c7      	bne.n	802484a <xQueueSemaphoreTake+0x102>
					portYIELD_WITHIN_API();
 80248ba:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80248be:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80248c2:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80248c6:	f3bf 8f4f 	dsb	sy
 80248ca:	f3bf 8f6f 	isb	sy
 80248ce:	e7bc      	b.n	802484a <xQueueSemaphoreTake+0x102>
					if( xInheritanceOccurred != pdFALSE )
 80248d0:	b90e      	cbnz	r6, 80248d6 <xQueueSemaphoreTake+0x18e>
				return errQUEUE_EMPTY;
 80248d2:	2600      	movs	r6, #0
 80248d4:	e76e      	b.n	80247b4 <xQueueSemaphoreTake+0x6c>
						taskENTER_CRITICAL();
 80248d6:	f7ff fa5d 	bl	8023d94 <vPortEnterCritical>
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 80248da:	4620      	mov	r0, r4
 80248dc:	f7ff fbae 	bl	802403c <prvGetDisinheritPriorityAfterTimeout>
 80248e0:	4601      	mov	r1, r0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 80248e2:	68a0      	ldr	r0, [r4, #8]
 80248e4:	f000 fe1e 	bl	8025524 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 80248e8:	f7ff fa76 	bl	8023dd8 <vPortExitCritical>
 80248ec:	e7f1      	b.n	80248d2 <xQueueSemaphoreTake+0x18a>

080248ee <xQueueReceiveFromISR>:
{
 80248ee:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 80248f2:	b1b0      	cbz	r0, 8024922 <xQueueReceiveFromISR+0x34>
 80248f4:	460d      	mov	r5, r1
 80248f6:	4690      	mov	r8, r2
 80248f8:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80248fa:	b1d9      	cbz	r1, 8024934 <xQueueReceiveFromISR+0x46>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80248fc:	f7ff fb70 	bl	8023fe0 <vPortValidateInterruptPriority>
	__asm volatile
 8024900:	f3ef 8711 	mrs	r7, BASEPRI
 8024904:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024908:	f383 8811 	msr	BASEPRI, r3
 802490c:	f3bf 8f6f 	isb	sy
 8024910:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8024914:	6ba6      	ldr	r6, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8024916:	b9ce      	cbnz	r6, 802494c <xQueueReceiveFromISR+0x5e>
			xReturn = pdFAIL;
 8024918:	2000      	movs	r0, #0
	__asm volatile
 802491a:	f387 8811 	msr	BASEPRI, r7
}
 802491e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile
 8024922:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024926:	f383 8811 	msr	BASEPRI, r3
 802492a:	f3bf 8f6f 	isb	sy
 802492e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8024932:	e7fe      	b.n	8024932 <xQueueReceiveFromISR+0x44>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8024934:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8024936:	2b00      	cmp	r3, #0
 8024938:	d0e0      	beq.n	80248fc <xQueueReceiveFromISR+0xe>
 802493a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802493e:	f383 8811 	msr	BASEPRI, r3
 8024942:	f3bf 8f6f 	isb	sy
 8024946:	f3bf 8f4f 	dsb	sy
 802494a:	e7fe      	b.n	802494a <xQueueReceiveFromISR+0x5c>
			const int8_t cRxLock = pxQueue->cRxLock;
 802494c:	f894 9044 	ldrb.w	r9, [r4, #68]	; 0x44
 8024950:	fa4f f989 	sxtb.w	r9, r9
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8024954:	4629      	mov	r1, r5
 8024956:	4620      	mov	r0, r4
 8024958:	f7ff fbcf 	bl	80240fa <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 802495c:	1e73      	subs	r3, r6, #1
 802495e:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 8024960:	f1b9 3fff 	cmp.w	r9, #4294967295
 8024964:	d006      	beq.n	8024974 <xQueueReceiveFromISR+0x86>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8024966:	f109 0301 	add.w	r3, r9, #1
 802496a:	b25b      	sxtb	r3, r3
 802496c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
			xReturn = pdPASS;
 8024970:	2001      	movs	r0, #1
 8024972:	e7d2      	b.n	802491a <xQueueReceiveFromISR+0x2c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8024974:	6923      	ldr	r3, [r4, #16]
 8024976:	b90b      	cbnz	r3, 802497c <xQueueReceiveFromISR+0x8e>
			xReturn = pdPASS;
 8024978:	2001      	movs	r0, #1
 802497a:	e7ce      	b.n	802491a <xQueueReceiveFromISR+0x2c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 802497c:	f104 0010 	add.w	r0, r4, #16
 8024980:	f000 fc72 	bl	8025268 <xTaskRemoveFromEventList>
 8024984:	b130      	cbz	r0, 8024994 <xQueueReceiveFromISR+0xa6>
						if( pxHigherPriorityTaskWoken != NULL )
 8024986:	f1b8 0f00 	cmp.w	r8, #0
 802498a:	d005      	beq.n	8024998 <xQueueReceiveFromISR+0xaa>
							*pxHigherPriorityTaskWoken = pdTRUE;
 802498c:	2001      	movs	r0, #1
 802498e:	f8c8 0000 	str.w	r0, [r8]
 8024992:	e7c2      	b.n	802491a <xQueueReceiveFromISR+0x2c>
			xReturn = pdPASS;
 8024994:	2001      	movs	r0, #1
 8024996:	e7c0      	b.n	802491a <xQueueReceiveFromISR+0x2c>
 8024998:	2001      	movs	r0, #1
 802499a:	e7be      	b.n	802491a <xQueueReceiveFromISR+0x2c>

0802499c <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 802499c:	2300      	movs	r3, #0
 802499e:	2b07      	cmp	r3, #7
 80249a0:	d80c      	bhi.n	80249bc <vQueueAddToRegistry+0x20>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 80249a2:	4a07      	ldr	r2, [pc, #28]	; (80249c0 <vQueueAddToRegistry+0x24>)
 80249a4:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 80249a8:	b10a      	cbz	r2, 80249ae <vQueueAddToRegistry+0x12>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80249aa:	3301      	adds	r3, #1
 80249ac:	e7f7      	b.n	802499e <vQueueAddToRegistry+0x2>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 80249ae:	4a04      	ldr	r2, [pc, #16]	; (80249c0 <vQueueAddToRegistry+0x24>)
 80249b0:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 80249b4:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 80249b8:	6050      	str	r0, [r2, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 80249ba:	4770      	bx	lr
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80249bc:	4770      	bx	lr
 80249be:	bf00      	nop
 80249c0:	20011bf4 	.word	0x20011bf4

080249c4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 80249c4:	b570      	push	{r4, r5, r6, lr}
 80249c6:	4604      	mov	r4, r0
 80249c8:	460d      	mov	r5, r1
 80249ca:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80249cc:	f7ff f9e2 	bl	8023d94 <vPortEnterCritical>
 80249d0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80249d4:	b25b      	sxtb	r3, r3
 80249d6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80249da:	d00d      	beq.n	80249f8 <vQueueWaitForMessageRestricted+0x34>
 80249dc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80249e0:	b25b      	sxtb	r3, r3
 80249e2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80249e6:	d00b      	beq.n	8024a00 <vQueueWaitForMessageRestricted+0x3c>
 80249e8:	f7ff f9f6 	bl	8023dd8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 80249ec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80249ee:	b15b      	cbz	r3, 8024a08 <vQueueWaitForMessageRestricted+0x44>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 80249f0:	4620      	mov	r0, r4
 80249f2:	f7ff fb94 	bl	802411e <prvUnlockQueue>
	}
 80249f6:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
 80249f8:	2300      	movs	r3, #0
 80249fa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80249fe:	e7ed      	b.n	80249dc <vQueueWaitForMessageRestricted+0x18>
 8024a00:	2300      	movs	r3, #0
 8024a02:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8024a06:	e7ef      	b.n	80249e8 <vQueueWaitForMessageRestricted+0x24>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8024a08:	4632      	mov	r2, r6
 8024a0a:	4629      	mov	r1, r5
 8024a0c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8024a10:	f000 fc0e 	bl	8025230 <vTaskPlaceOnEventListRestricted>
 8024a14:	e7ec      	b.n	80249f0 <vQueueWaitForMessageRestricted+0x2c>
	...

08024a18 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8024a18:	4b08      	ldr	r3, [pc, #32]	; (8024a3c <prvResetNextTaskUnblockTime+0x24>)
 8024a1a:	681b      	ldr	r3, [r3, #0]
 8024a1c:	681b      	ldr	r3, [r3, #0]
 8024a1e:	b923      	cbnz	r3, 8024a2a <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8024a20:	4b07      	ldr	r3, [pc, #28]	; (8024a40 <prvResetNextTaskUnblockTime+0x28>)
 8024a22:	f04f 32ff 	mov.w	r2, #4294967295
 8024a26:	601a      	str	r2, [r3, #0]
 8024a28:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024a2a:	4b04      	ldr	r3, [pc, #16]	; (8024a3c <prvResetNextTaskUnblockTime+0x24>)
 8024a2c:	681b      	ldr	r3, [r3, #0]
 8024a2e:	68db      	ldr	r3, [r3, #12]
 8024a30:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8024a32:	685a      	ldr	r2, [r3, #4]
 8024a34:	4b02      	ldr	r3, [pc, #8]	; (8024a40 <prvResetNextTaskUnblockTime+0x28>)
 8024a36:	601a      	str	r2, [r3, #0]
	}
}
 8024a38:	4770      	bx	lr
 8024a3a:	bf00      	nop
 8024a3c:	20011c38 	.word	0x20011c38
 8024a40:	20011d10 	.word	0x20011d10

08024a44 <prvDeleteTCB>:
	{
 8024a44:	b510      	push	{r4, lr}
 8024a46:	4604      	mov	r4, r0
			vPortFree( pxTCB->pxStack );
 8024a48:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8024a4a:	f7ff f8bb 	bl	8023bc4 <vPortFree>
			vPortFree( pxTCB );
 8024a4e:	4620      	mov	r0, r4
 8024a50:	f7ff f8b8 	bl	8023bc4 <vPortFree>
	}
 8024a54:	bd10      	pop	{r4, pc}

08024a56 <prvInitialiseNewTask>:
{
 8024a56:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024a5a:	4680      	mov	r8, r0
 8024a5c:	460d      	mov	r5, r1
 8024a5e:	4617      	mov	r7, r2
 8024a60:	4699      	mov	r9, r3
 8024a62:	9e08      	ldr	r6, [sp, #32]
 8024a64:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 8024a68:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8024a6a:	0092      	lsls	r2, r2, #2
 8024a6c:	21a5      	movs	r1, #165	; 0xa5
 8024a6e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8024a70:	f001 f971 	bl	8025d56 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8024a74:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8024a76:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
 8024a7a:	3a01      	subs	r2, #1
 8024a7c:	eb03 0782 	add.w	r7, r3, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8024a80:	f027 0707 	bic.w	r7, r7, #7
	if( pcName != NULL )
 8024a84:	b3a5      	cbz	r5, 8024af0 <prvInitialiseNewTask+0x9a>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8024a86:	f04f 0c00 	mov.w	ip, #0
 8024a8a:	f1bc 0f0f 	cmp.w	ip, #15
 8024a8e:	d809      	bhi.n	8024aa4 <prvInitialiseNewTask+0x4e>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8024a90:	f815 300c 	ldrb.w	r3, [r5, ip]
 8024a94:	eb04 020c 	add.w	r2, r4, ip
 8024a98:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 8024a9c:	b113      	cbz	r3, 8024aa4 <prvInitialiseNewTask+0x4e>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8024a9e:	f10c 0c01 	add.w	ip, ip, #1
 8024aa2:	e7f2      	b.n	8024a8a <prvInitialiseNewTask+0x34>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8024aa4:	2300      	movs	r3, #0
 8024aa6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8024aaa:	2e06      	cmp	r6, #6
 8024aac:	d900      	bls.n	8024ab0 <prvInitialiseNewTask+0x5a>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8024aae:	2606      	movs	r6, #6
	pxNewTCB->uxPriority = uxPriority;
 8024ab0:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8024ab2:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8024ab4:	2500      	movs	r5, #0
 8024ab6:	6525      	str	r5, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8024ab8:	1d20      	adds	r0, r4, #4
 8024aba:	f7ff f8c6 	bl	8023c4a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8024abe:	f104 0018 	add.w	r0, r4, #24
 8024ac2:	f7ff f8c2 	bl	8023c4a <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8024ac6:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8024ac8:	f1c6 0607 	rsb	r6, r6, #7
 8024acc:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8024ace:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 8024ad0:	6565      	str	r5, [r4, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8024ad2:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8024ad6:	464a      	mov	r2, r9
 8024ad8:	4641      	mov	r1, r8
 8024ada:	4638      	mov	r0, r7
 8024adc:	f7ff f92e 	bl	8023d3c <pxPortInitialiseStack>
 8024ae0:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8024ae2:	f1ba 0f00 	cmp.w	sl, #0
 8024ae6:	d001      	beq.n	8024aec <prvInitialiseNewTask+0x96>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8024ae8:	f8ca 4000 	str.w	r4, [sl]
}
 8024aec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8024af0:	2300      	movs	r3, #0
 8024af2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8024af6:	e7d8      	b.n	8024aaa <prvInitialiseNewTask+0x54>

08024af8 <prvInitialiseTaskLists>:
{
 8024af8:	b538      	push	{r3, r4, r5, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8024afa:	2400      	movs	r4, #0
 8024afc:	e007      	b.n	8024b0e <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8024afe:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8024b02:	0093      	lsls	r3, r2, #2
 8024b04:	480e      	ldr	r0, [pc, #56]	; (8024b40 <prvInitialiseTaskLists+0x48>)
 8024b06:	4418      	add	r0, r3
 8024b08:	f7ff f894 	bl	8023c34 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8024b0c:	3401      	adds	r4, #1
 8024b0e:	2c06      	cmp	r4, #6
 8024b10:	d9f5      	bls.n	8024afe <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 8024b12:	4d0c      	ldr	r5, [pc, #48]	; (8024b44 <prvInitialiseTaskLists+0x4c>)
 8024b14:	4628      	mov	r0, r5
 8024b16:	f7ff f88d 	bl	8023c34 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8024b1a:	4c0b      	ldr	r4, [pc, #44]	; (8024b48 <prvInitialiseTaskLists+0x50>)
 8024b1c:	4620      	mov	r0, r4
 8024b1e:	f7ff f889 	bl	8023c34 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8024b22:	480a      	ldr	r0, [pc, #40]	; (8024b4c <prvInitialiseTaskLists+0x54>)
 8024b24:	f7ff f886 	bl	8023c34 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8024b28:	4809      	ldr	r0, [pc, #36]	; (8024b50 <prvInitialiseTaskLists+0x58>)
 8024b2a:	f7ff f883 	bl	8023c34 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8024b2e:	4809      	ldr	r0, [pc, #36]	; (8024b54 <prvInitialiseTaskLists+0x5c>)
 8024b30:	f7ff f880 	bl	8023c34 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8024b34:	4b08      	ldr	r3, [pc, #32]	; (8024b58 <prvInitialiseTaskLists+0x60>)
 8024b36:	601d      	str	r5, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8024b38:	4b08      	ldr	r3, [pc, #32]	; (8024b5c <prvInitialiseTaskLists+0x64>)
 8024b3a:	601c      	str	r4, [r3, #0]
}
 8024b3c:	bd38      	pop	{r3, r4, r5, pc}
 8024b3e:	bf00      	nop
 8024b40:	20011c40 	.word	0x20011c40
 8024b44:	20011ce4 	.word	0x20011ce4
 8024b48:	20011cf8 	.word	0x20011cf8
 8024b4c:	20011d18 	.word	0x20011d18
 8024b50:	20011d44 	.word	0x20011d44
 8024b54:	20011d30 	.word	0x20011d30
 8024b58:	20011c38 	.word	0x20011c38
 8024b5c:	20011c3c 	.word	0x20011c3c

08024b60 <prvAddNewTaskToReadyList>:
{
 8024b60:	b510      	push	{r4, lr}
 8024b62:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8024b64:	f7ff f916 	bl	8023d94 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8024b68:	4a22      	ldr	r2, [pc, #136]	; (8024bf4 <prvAddNewTaskToReadyList+0x94>)
 8024b6a:	6813      	ldr	r3, [r2, #0]
 8024b6c:	3301      	adds	r3, #1
 8024b6e:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8024b70:	4b21      	ldr	r3, [pc, #132]	; (8024bf8 <prvAddNewTaskToReadyList+0x98>)
 8024b72:	681b      	ldr	r3, [r3, #0]
 8024b74:	b15b      	cbz	r3, 8024b8e <prvAddNewTaskToReadyList+0x2e>
			if( xSchedulerRunning == pdFALSE )
 8024b76:	4b21      	ldr	r3, [pc, #132]	; (8024bfc <prvAddNewTaskToReadyList+0x9c>)
 8024b78:	681b      	ldr	r3, [r3, #0]
 8024b7a:	b96b      	cbnz	r3, 8024b98 <prvAddNewTaskToReadyList+0x38>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8024b7c:	4b1e      	ldr	r3, [pc, #120]	; (8024bf8 <prvAddNewTaskToReadyList+0x98>)
 8024b7e:	681b      	ldr	r3, [r3, #0]
 8024b80:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024b82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8024b84:	429a      	cmp	r2, r3
 8024b86:	d807      	bhi.n	8024b98 <prvAddNewTaskToReadyList+0x38>
					pxCurrentTCB = pxNewTCB;
 8024b88:	4b1b      	ldr	r3, [pc, #108]	; (8024bf8 <prvAddNewTaskToReadyList+0x98>)
 8024b8a:	601c      	str	r4, [r3, #0]
 8024b8c:	e004      	b.n	8024b98 <prvAddNewTaskToReadyList+0x38>
			pxCurrentTCB = pxNewTCB;
 8024b8e:	4b1a      	ldr	r3, [pc, #104]	; (8024bf8 <prvAddNewTaskToReadyList+0x98>)
 8024b90:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8024b92:	6813      	ldr	r3, [r2, #0]
 8024b94:	2b01      	cmp	r3, #1
 8024b96:	d029      	beq.n	8024bec <prvAddNewTaskToReadyList+0x8c>
		uxTaskNumber++;
 8024b98:	4a19      	ldr	r2, [pc, #100]	; (8024c00 <prvAddNewTaskToReadyList+0xa0>)
 8024b9a:	6813      	ldr	r3, [r2, #0]
 8024b9c:	3301      	adds	r3, #1
 8024b9e:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8024ba0:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8024ba2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8024ba4:	2301      	movs	r3, #1
 8024ba6:	4083      	lsls	r3, r0
 8024ba8:	4a16      	ldr	r2, [pc, #88]	; (8024c04 <prvAddNewTaskToReadyList+0xa4>)
 8024baa:	6811      	ldr	r1, [r2, #0]
 8024bac:	430b      	orrs	r3, r1
 8024bae:	6013      	str	r3, [r2, #0]
 8024bb0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8024bb4:	1d21      	adds	r1, r4, #4
 8024bb6:	4b14      	ldr	r3, [pc, #80]	; (8024c08 <prvAddNewTaskToReadyList+0xa8>)
 8024bb8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8024bbc:	f7ff f848 	bl	8023c50 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8024bc0:	f7ff f90a 	bl	8023dd8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8024bc4:	4b0d      	ldr	r3, [pc, #52]	; (8024bfc <prvAddNewTaskToReadyList+0x9c>)
 8024bc6:	681b      	ldr	r3, [r3, #0]
 8024bc8:	b17b      	cbz	r3, 8024bea <prvAddNewTaskToReadyList+0x8a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8024bca:	4b0b      	ldr	r3, [pc, #44]	; (8024bf8 <prvAddNewTaskToReadyList+0x98>)
 8024bcc:	681b      	ldr	r3, [r3, #0]
 8024bce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024bd0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8024bd2:	429a      	cmp	r2, r3
 8024bd4:	d209      	bcs.n	8024bea <prvAddNewTaskToReadyList+0x8a>
			taskYIELD_IF_USING_PREEMPTION();
 8024bd6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024bda:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024bde:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024be2:	f3bf 8f4f 	dsb	sy
 8024be6:	f3bf 8f6f 	isb	sy
}
 8024bea:	bd10      	pop	{r4, pc}
				prvInitialiseTaskLists();
 8024bec:	f7ff ff84 	bl	8024af8 <prvInitialiseTaskLists>
 8024bf0:	e7d2      	b.n	8024b98 <prvAddNewTaskToReadyList+0x38>
 8024bf2:	bf00      	nop
 8024bf4:	20011ccc 	.word	0x20011ccc
 8024bf8:	20011c34 	.word	0x20011c34
 8024bfc:	20011d2c 	.word	0x20011d2c
 8024c00:	20011cdc 	.word	0x20011cdc
 8024c04:	20011ce0 	.word	0x20011ce0
 8024c08:	20011c40 	.word	0x20011c40

08024c0c <prvCheckTasksWaitingTermination>:
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8024c0c:	4b0f      	ldr	r3, [pc, #60]	; (8024c4c <prvCheckTasksWaitingTermination+0x40>)
 8024c0e:	681b      	ldr	r3, [r3, #0]
 8024c10:	b1d3      	cbz	r3, 8024c48 <prvCheckTasksWaitingTermination+0x3c>
{
 8024c12:	b510      	push	{r4, lr}
			taskENTER_CRITICAL();
 8024c14:	f7ff f8be 	bl	8023d94 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024c18:	4b0d      	ldr	r3, [pc, #52]	; (8024c50 <prvCheckTasksWaitingTermination+0x44>)
 8024c1a:	68db      	ldr	r3, [r3, #12]
 8024c1c:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8024c1e:	1d20      	adds	r0, r4, #4
 8024c20:	f7ff f83a 	bl	8023c98 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8024c24:	4a0b      	ldr	r2, [pc, #44]	; (8024c54 <prvCheckTasksWaitingTermination+0x48>)
 8024c26:	6813      	ldr	r3, [r2, #0]
 8024c28:	3b01      	subs	r3, #1
 8024c2a:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 8024c2c:	4a07      	ldr	r2, [pc, #28]	; (8024c4c <prvCheckTasksWaitingTermination+0x40>)
 8024c2e:	6813      	ldr	r3, [r2, #0]
 8024c30:	3b01      	subs	r3, #1
 8024c32:	6013      	str	r3, [r2, #0]
			taskEXIT_CRITICAL();
 8024c34:	f7ff f8d0 	bl	8023dd8 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 8024c38:	4620      	mov	r0, r4
 8024c3a:	f7ff ff03 	bl	8024a44 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8024c3e:	4b03      	ldr	r3, [pc, #12]	; (8024c4c <prvCheckTasksWaitingTermination+0x40>)
 8024c40:	681b      	ldr	r3, [r3, #0]
 8024c42:	2b00      	cmp	r3, #0
 8024c44:	d1e6      	bne.n	8024c14 <prvCheckTasksWaitingTermination+0x8>
}
 8024c46:	bd10      	pop	{r4, pc}
 8024c48:	4770      	bx	lr
 8024c4a:	bf00      	nop
 8024c4c:	20011cd0 	.word	0x20011cd0
 8024c50:	20011d44 	.word	0x20011d44
 8024c54:	20011ccc 	.word	0x20011ccc

08024c58 <prvIdleTask>:
{
 8024c58:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 8024c5a:	f7ff ffd7 	bl	8024c0c <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8024c5e:	4b07      	ldr	r3, [pc, #28]	; (8024c7c <prvIdleTask+0x24>)
 8024c60:	681b      	ldr	r3, [r3, #0]
 8024c62:	2b01      	cmp	r3, #1
 8024c64:	d9f9      	bls.n	8024c5a <prvIdleTask+0x2>
				taskYIELD();
 8024c66:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024c6a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024c6e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024c72:	f3bf 8f4f 	dsb	sy
 8024c76:	f3bf 8f6f 	isb	sy
 8024c7a:	e7ee      	b.n	8024c5a <prvIdleTask+0x2>
 8024c7c:	20011c40 	.word	0x20011c40

08024c80 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8024c80:	b570      	push	{r4, r5, r6, lr}
 8024c82:	4604      	mov	r4, r0
 8024c84:	460d      	mov	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8024c86:	4b1d      	ldr	r3, [pc, #116]	; (8024cfc <prvAddCurrentTaskToDelayedList+0x7c>)
 8024c88:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8024c8a:	4b1d      	ldr	r3, [pc, #116]	; (8024d00 <prvAddCurrentTaskToDelayedList+0x80>)
 8024c8c:	6818      	ldr	r0, [r3, #0]
 8024c8e:	3004      	adds	r0, #4
 8024c90:	f7ff f802 	bl	8023c98 <uxListRemove>
 8024c94:	b948      	cbnz	r0, 8024caa <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8024c96:	4b1a      	ldr	r3, [pc, #104]	; (8024d00 <prvAddCurrentTaskToDelayedList+0x80>)
 8024c98:	681b      	ldr	r3, [r3, #0]
 8024c9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024c9c:	2201      	movs	r2, #1
 8024c9e:	409a      	lsls	r2, r3
 8024ca0:	4918      	ldr	r1, [pc, #96]	; (8024d04 <prvAddCurrentTaskToDelayedList+0x84>)
 8024ca2:	680b      	ldr	r3, [r1, #0]
 8024ca4:	ea23 0302 	bic.w	r3, r3, r2
 8024ca8:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8024caa:	f1b4 3fff 	cmp.w	r4, #4294967295
 8024cae:	d00d      	beq.n	8024ccc <prvAddCurrentTaskToDelayedList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8024cb0:	4434      	add	r4, r6

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8024cb2:	4b13      	ldr	r3, [pc, #76]	; (8024d00 <prvAddCurrentTaskToDelayedList+0x80>)
 8024cb4:	681b      	ldr	r3, [r3, #0]
 8024cb6:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8024cb8:	42a6      	cmp	r6, r4
 8024cba:	d910      	bls.n	8024cde <prvAddCurrentTaskToDelayedList+0x5e>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8024cbc:	4b12      	ldr	r3, [pc, #72]	; (8024d08 <prvAddCurrentTaskToDelayedList+0x88>)
 8024cbe:	6818      	ldr	r0, [r3, #0]
 8024cc0:	4b0f      	ldr	r3, [pc, #60]	; (8024d00 <prvAddCurrentTaskToDelayedList+0x80>)
 8024cc2:	6819      	ldr	r1, [r3, #0]
 8024cc4:	3104      	adds	r1, #4
 8024cc6:	f7fe ffce 	bl	8023c66 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8024cca:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8024ccc:	2d00      	cmp	r5, #0
 8024cce:	d0ef      	beq.n	8024cb0 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8024cd0:	4b0b      	ldr	r3, [pc, #44]	; (8024d00 <prvAddCurrentTaskToDelayedList+0x80>)
 8024cd2:	6819      	ldr	r1, [r3, #0]
 8024cd4:	3104      	adds	r1, #4
 8024cd6:	480d      	ldr	r0, [pc, #52]	; (8024d0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8024cd8:	f7fe ffba 	bl	8023c50 <vListInsertEnd>
 8024cdc:	e7f5      	b.n	8024cca <prvAddCurrentTaskToDelayedList+0x4a>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8024cde:	4b0c      	ldr	r3, [pc, #48]	; (8024d10 <prvAddCurrentTaskToDelayedList+0x90>)
 8024ce0:	6818      	ldr	r0, [r3, #0]
 8024ce2:	4b07      	ldr	r3, [pc, #28]	; (8024d00 <prvAddCurrentTaskToDelayedList+0x80>)
 8024ce4:	6819      	ldr	r1, [r3, #0]
 8024ce6:	3104      	adds	r1, #4
 8024ce8:	f7fe ffbd 	bl	8023c66 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8024cec:	4b09      	ldr	r3, [pc, #36]	; (8024d14 <prvAddCurrentTaskToDelayedList+0x94>)
 8024cee:	681b      	ldr	r3, [r3, #0]
 8024cf0:	42a3      	cmp	r3, r4
 8024cf2:	d9ea      	bls.n	8024cca <prvAddCurrentTaskToDelayedList+0x4a>
					xNextTaskUnblockTime = xTimeToWake;
 8024cf4:	4b07      	ldr	r3, [pc, #28]	; (8024d14 <prvAddCurrentTaskToDelayedList+0x94>)
 8024cf6:	601c      	str	r4, [r3, #0]
}
 8024cf8:	e7e7      	b.n	8024cca <prvAddCurrentTaskToDelayedList+0x4a>
 8024cfa:	bf00      	nop
 8024cfc:	20011d58 	.word	0x20011d58
 8024d00:	20011c34 	.word	0x20011c34
 8024d04:	20011ce0 	.word	0x20011ce0
 8024d08:	20011c3c 	.word	0x20011c3c
 8024d0c:	20011d30 	.word	0x20011d30
 8024d10:	20011c38 	.word	0x20011c38
 8024d14:	20011d10 	.word	0x20011d10

08024d18 <xTaskCreate>:
	{
 8024d18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8024d1c:	b085      	sub	sp, #20
 8024d1e:	4607      	mov	r7, r0
 8024d20:	4688      	mov	r8, r1
 8024d22:	4614      	mov	r4, r2
 8024d24:	461e      	mov	r6, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8024d26:	0090      	lsls	r0, r2, #2
 8024d28:	f7fe fed4 	bl	8023ad4 <pvPortMalloc>
			if( pxStack != NULL )
 8024d2c:	b1f0      	cbz	r0, 8024d6c <xTaskCreate+0x54>
 8024d2e:	4681      	mov	r9, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8024d30:	205c      	movs	r0, #92	; 0x5c
 8024d32:	f7fe fecf 	bl	8023ad4 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8024d36:	4605      	mov	r5, r0
 8024d38:	b1a0      	cbz	r0, 8024d64 <xTaskCreate+0x4c>
					pxNewTCB->pxStack = pxStack;
 8024d3a:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
 8024d3e:	b1d5      	cbz	r5, 8024d76 <xTaskCreate+0x5e>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8024d40:	2300      	movs	r3, #0
 8024d42:	9303      	str	r3, [sp, #12]
 8024d44:	9502      	str	r5, [sp, #8]
 8024d46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8024d48:	9301      	str	r3, [sp, #4]
 8024d4a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024d4c:	9300      	str	r3, [sp, #0]
 8024d4e:	4633      	mov	r3, r6
 8024d50:	4622      	mov	r2, r4
 8024d52:	4641      	mov	r1, r8
 8024d54:	4638      	mov	r0, r7
 8024d56:	f7ff fe7e 	bl	8024a56 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8024d5a:	4628      	mov	r0, r5
 8024d5c:	f7ff ff00 	bl	8024b60 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8024d60:	2001      	movs	r0, #1
 8024d62:	e005      	b.n	8024d70 <xTaskCreate+0x58>
					vPortFree( pxStack );
 8024d64:	4648      	mov	r0, r9
 8024d66:	f7fe ff2d 	bl	8023bc4 <vPortFree>
 8024d6a:	e7e8      	b.n	8024d3e <xTaskCreate+0x26>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8024d6c:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8024d70:	b005      	add	sp, #20
 8024d72:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8024d76:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 8024d7a:	e7f9      	b.n	8024d70 <xTaskCreate+0x58>

08024d7c <vTaskDelete>:
	{
 8024d7c:	b538      	push	{r3, r4, r5, lr}
 8024d7e:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 8024d80:	f7ff f808 	bl	8023d94 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8024d84:	2c00      	cmp	r4, #0
 8024d86:	d034      	beq.n	8024df2 <vTaskDelete+0x76>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8024d88:	1d25      	adds	r5, r4, #4
 8024d8a:	4628      	mov	r0, r5
 8024d8c:	f7fe ff84 	bl	8023c98 <uxListRemove>
 8024d90:	b970      	cbnz	r0, 8024db0 <vTaskDelete+0x34>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8024d92:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8024d94:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8024d98:	009b      	lsls	r3, r3, #2
 8024d9a:	4927      	ldr	r1, [pc, #156]	; (8024e38 <vTaskDelete+0xbc>)
 8024d9c:	58cb      	ldr	r3, [r1, r3]
 8024d9e:	b93b      	cbnz	r3, 8024db0 <vTaskDelete+0x34>
 8024da0:	2301      	movs	r3, #1
 8024da2:	fa03 f202 	lsl.w	r2, r3, r2
 8024da6:	4925      	ldr	r1, [pc, #148]	; (8024e3c <vTaskDelete+0xc0>)
 8024da8:	680b      	ldr	r3, [r1, #0]
 8024daa:	ea23 0302 	bic.w	r3, r3, r2
 8024dae:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8024db0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8024db2:	b11b      	cbz	r3, 8024dbc <vTaskDelete+0x40>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8024db4:	f104 0018 	add.w	r0, r4, #24
 8024db8:	f7fe ff6e 	bl	8023c98 <uxListRemove>
			uxTaskNumber++;
 8024dbc:	4a20      	ldr	r2, [pc, #128]	; (8024e40 <vTaskDelete+0xc4>)
 8024dbe:	6813      	ldr	r3, [r2, #0]
 8024dc0:	3301      	adds	r3, #1
 8024dc2:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 8024dc4:	4b1f      	ldr	r3, [pc, #124]	; (8024e44 <vTaskDelete+0xc8>)
 8024dc6:	681b      	ldr	r3, [r3, #0]
 8024dc8:	42a3      	cmp	r3, r4
 8024dca:	d015      	beq.n	8024df8 <vTaskDelete+0x7c>
				--uxCurrentNumberOfTasks;
 8024dcc:	4a1e      	ldr	r2, [pc, #120]	; (8024e48 <vTaskDelete+0xcc>)
 8024dce:	6813      	ldr	r3, [r2, #0]
 8024dd0:	3b01      	subs	r3, #1
 8024dd2:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 8024dd4:	4620      	mov	r0, r4
 8024dd6:	f7ff fe35 	bl	8024a44 <prvDeleteTCB>
				prvResetNextTaskUnblockTime();
 8024dda:	f7ff fe1d 	bl	8024a18 <prvResetNextTaskUnblockTime>
		taskEXIT_CRITICAL();
 8024dde:	f7fe fffb 	bl	8023dd8 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8024de2:	4b1a      	ldr	r3, [pc, #104]	; (8024e4c <vTaskDelete+0xd0>)
 8024de4:	681b      	ldr	r3, [r3, #0]
 8024de6:	b11b      	cbz	r3, 8024df0 <vTaskDelete+0x74>
			if( pxTCB == pxCurrentTCB )
 8024de8:	4b16      	ldr	r3, [pc, #88]	; (8024e44 <vTaskDelete+0xc8>)
 8024dea:	681b      	ldr	r3, [r3, #0]
 8024dec:	42a3      	cmp	r3, r4
 8024dee:	d00c      	beq.n	8024e0a <vTaskDelete+0x8e>
	}
 8024df0:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8024df2:	4b14      	ldr	r3, [pc, #80]	; (8024e44 <vTaskDelete+0xc8>)
 8024df4:	681c      	ldr	r4, [r3, #0]
 8024df6:	e7c7      	b.n	8024d88 <vTaskDelete+0xc>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8024df8:	4629      	mov	r1, r5
 8024dfa:	4815      	ldr	r0, [pc, #84]	; (8024e50 <vTaskDelete+0xd4>)
 8024dfc:	f7fe ff28 	bl	8023c50 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 8024e00:	4a14      	ldr	r2, [pc, #80]	; (8024e54 <vTaskDelete+0xd8>)
 8024e02:	6813      	ldr	r3, [r2, #0]
 8024e04:	3301      	adds	r3, #1
 8024e06:	6013      	str	r3, [r2, #0]
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 8024e08:	e7e9      	b.n	8024dde <vTaskDelete+0x62>
				configASSERT( uxSchedulerSuspended == 0 );
 8024e0a:	4b13      	ldr	r3, [pc, #76]	; (8024e58 <vTaskDelete+0xdc>)
 8024e0c:	681b      	ldr	r3, [r3, #0]
 8024e0e:	b143      	cbz	r3, 8024e22 <vTaskDelete+0xa6>
 8024e10:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e14:	f383 8811 	msr	BASEPRI, r3
 8024e18:	f3bf 8f6f 	isb	sy
 8024e1c:	f3bf 8f4f 	dsb	sy
 8024e20:	e7fe      	b.n	8024e20 <vTaskDelete+0xa4>
				portYIELD_WITHIN_API();
 8024e22:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024e26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024e2a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024e2e:	f3bf 8f4f 	dsb	sy
 8024e32:	f3bf 8f6f 	isb	sy
	}
 8024e36:	e7db      	b.n	8024df0 <vTaskDelete+0x74>
 8024e38:	20011c40 	.word	0x20011c40
 8024e3c:	20011ce0 	.word	0x20011ce0
 8024e40:	20011cdc 	.word	0x20011cdc
 8024e44:	20011c34 	.word	0x20011c34
 8024e48:	20011ccc 	.word	0x20011ccc
 8024e4c:	20011d2c 	.word	0x20011d2c
 8024e50:	20011d44 	.word	0x20011d44
 8024e54:	20011cd0 	.word	0x20011cd0
 8024e58:	20011cd8 	.word	0x20011cd8

08024e5c <vTaskStartScheduler>:
{
 8024e5c:	b500      	push	{lr}
 8024e5e:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 8024e60:	4b19      	ldr	r3, [pc, #100]	; (8024ec8 <vTaskStartScheduler+0x6c>)
 8024e62:	9301      	str	r3, [sp, #4]
 8024e64:	2300      	movs	r3, #0
 8024e66:	9300      	str	r3, [sp, #0]
 8024e68:	2280      	movs	r2, #128	; 0x80
 8024e6a:	4918      	ldr	r1, [pc, #96]	; (8024ecc <vTaskStartScheduler+0x70>)
 8024e6c:	4818      	ldr	r0, [pc, #96]	; (8024ed0 <vTaskStartScheduler+0x74>)
 8024e6e:	f7ff ff53 	bl	8024d18 <xTaskCreate>
		if( xReturn == pdPASS )
 8024e72:	2801      	cmp	r0, #1
 8024e74:	d007      	beq.n	8024e86 <vTaskStartScheduler+0x2a>
	if( xReturn == pdPASS )
 8024e76:	2801      	cmp	r0, #1
 8024e78:	d008      	beq.n	8024e8c <vTaskStartScheduler+0x30>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8024e7a:	f1b0 3fff 	cmp.w	r0, #4294967295
 8024e7e:	d01a      	beq.n	8024eb6 <vTaskStartScheduler+0x5a>
}
 8024e80:	b003      	add	sp, #12
 8024e82:	f85d fb04 	ldr.w	pc, [sp], #4
			xReturn = xTimerCreateTimerTask();
 8024e86:	f000 fc43 	bl	8025710 <xTimerCreateTimerTask>
 8024e8a:	e7f4      	b.n	8024e76 <vTaskStartScheduler+0x1a>
 8024e8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e90:	f383 8811 	msr	BASEPRI, r3
 8024e94:	f3bf 8f6f 	isb	sy
 8024e98:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8024e9c:	4b0d      	ldr	r3, [pc, #52]	; (8024ed4 <vTaskStartScheduler+0x78>)
 8024e9e:	f04f 32ff 	mov.w	r2, #4294967295
 8024ea2:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8024ea4:	4b0c      	ldr	r3, [pc, #48]	; (8024ed8 <vTaskStartScheduler+0x7c>)
 8024ea6:	2201      	movs	r2, #1
 8024ea8:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8024eaa:	4b0c      	ldr	r3, [pc, #48]	; (8024edc <vTaskStartScheduler+0x80>)
 8024eac:	2200      	movs	r2, #0
 8024eae:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8024eb0:	f7ff f80a 	bl	8023ec8 <xPortStartScheduler>
 8024eb4:	e7e4      	b.n	8024e80 <vTaskStartScheduler+0x24>
 8024eb6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024eba:	f383 8811 	msr	BASEPRI, r3
 8024ebe:	f3bf 8f6f 	isb	sy
 8024ec2:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8024ec6:	e7fe      	b.n	8024ec6 <vTaskStartScheduler+0x6a>
 8024ec8:	20011d0c 	.word	0x20011d0c
 8024ecc:	08036404 	.word	0x08036404
 8024ed0:	08024c59 	.word	0x08024c59
 8024ed4:	20011d10 	.word	0x20011d10
 8024ed8:	20011d2c 	.word	0x20011d2c
 8024edc:	20011d58 	.word	0x20011d58

08024ee0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8024ee0:	4a02      	ldr	r2, [pc, #8]	; (8024eec <vTaskSuspendAll+0xc>)
 8024ee2:	6813      	ldr	r3, [r2, #0]
 8024ee4:	3301      	adds	r3, #1
 8024ee6:	6013      	str	r3, [r2, #0]
}
 8024ee8:	4770      	bx	lr
 8024eea:	bf00      	nop
 8024eec:	20011cd8 	.word	0x20011cd8

08024ef0 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8024ef0:	4b01      	ldr	r3, [pc, #4]	; (8024ef8 <xTaskGetTickCount+0x8>)
 8024ef2:	6818      	ldr	r0, [r3, #0]
}
 8024ef4:	4770      	bx	lr
 8024ef6:	bf00      	nop
 8024ef8:	20011d58 	.word	0x20011d58

08024efc <xTaskGetTickCountFromISR>:
{
 8024efc:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8024efe:	f7ff f86f 	bl	8023fe0 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8024f02:	4b01      	ldr	r3, [pc, #4]	; (8024f08 <xTaskGetTickCountFromISR+0xc>)
 8024f04:	6818      	ldr	r0, [r3, #0]
}
 8024f06:	bd08      	pop	{r3, pc}
 8024f08:	20011d58 	.word	0x20011d58

08024f0c <xTaskIncrementTick>:
{
 8024f0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8024f0e:	4b3a      	ldr	r3, [pc, #232]	; (8024ff8 <xTaskIncrementTick+0xec>)
 8024f10:	681b      	ldr	r3, [r3, #0]
 8024f12:	2b00      	cmp	r3, #0
 8024f14:	d164      	bne.n	8024fe0 <xTaskIncrementTick+0xd4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8024f16:	4b39      	ldr	r3, [pc, #228]	; (8024ffc <xTaskIncrementTick+0xf0>)
 8024f18:	681d      	ldr	r5, [r3, #0]
 8024f1a:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8024f1c:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8024f1e:	b9c5      	cbnz	r5, 8024f52 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8024f20:	4b37      	ldr	r3, [pc, #220]	; (8025000 <xTaskIncrementTick+0xf4>)
 8024f22:	681b      	ldr	r3, [r3, #0]
 8024f24:	681b      	ldr	r3, [r3, #0]
 8024f26:	b143      	cbz	r3, 8024f3a <xTaskIncrementTick+0x2e>
 8024f28:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024f2c:	f383 8811 	msr	BASEPRI, r3
 8024f30:	f3bf 8f6f 	isb	sy
 8024f34:	f3bf 8f4f 	dsb	sy
 8024f38:	e7fe      	b.n	8024f38 <xTaskIncrementTick+0x2c>
 8024f3a:	4a31      	ldr	r2, [pc, #196]	; (8025000 <xTaskIncrementTick+0xf4>)
 8024f3c:	6811      	ldr	r1, [r2, #0]
 8024f3e:	4b31      	ldr	r3, [pc, #196]	; (8025004 <xTaskIncrementTick+0xf8>)
 8024f40:	6818      	ldr	r0, [r3, #0]
 8024f42:	6010      	str	r0, [r2, #0]
 8024f44:	6019      	str	r1, [r3, #0]
 8024f46:	4a30      	ldr	r2, [pc, #192]	; (8025008 <xTaskIncrementTick+0xfc>)
 8024f48:	6813      	ldr	r3, [r2, #0]
 8024f4a:	3301      	adds	r3, #1
 8024f4c:	6013      	str	r3, [r2, #0]
 8024f4e:	f7ff fd63 	bl	8024a18 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8024f52:	4b2e      	ldr	r3, [pc, #184]	; (802500c <xTaskIncrementTick+0x100>)
 8024f54:	681b      	ldr	r3, [r3, #0]
 8024f56:	42ab      	cmp	r3, r5
 8024f58:	d938      	bls.n	8024fcc <xTaskIncrementTick+0xc0>
BaseType_t xSwitchRequired = pdFALSE;
 8024f5a:	2700      	movs	r7, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8024f5c:	4b2c      	ldr	r3, [pc, #176]	; (8025010 <xTaskIncrementTick+0x104>)
 8024f5e:	681b      	ldr	r3, [r3, #0]
 8024f60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024f62:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8024f66:	009a      	lsls	r2, r3, #2
 8024f68:	4b2a      	ldr	r3, [pc, #168]	; (8025014 <xTaskIncrementTick+0x108>)
 8024f6a:	589b      	ldr	r3, [r3, r2]
 8024f6c:	2b01      	cmp	r3, #1
 8024f6e:	d93c      	bls.n	8024fea <xTaskIncrementTick+0xde>
				xSwitchRequired = pdTRUE;
 8024f70:	2701      	movs	r7, #1
 8024f72:	e03a      	b.n	8024fea <xTaskIncrementTick+0xde>
							xSwitchRequired = pdTRUE;
 8024f74:	2701      	movs	r7, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8024f76:	4b22      	ldr	r3, [pc, #136]	; (8025000 <xTaskIncrementTick+0xf4>)
 8024f78:	681b      	ldr	r3, [r3, #0]
 8024f7a:	681b      	ldr	r3, [r3, #0]
 8024f7c:	b343      	cbz	r3, 8024fd0 <xTaskIncrementTick+0xc4>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024f7e:	4b20      	ldr	r3, [pc, #128]	; (8025000 <xTaskIncrementTick+0xf4>)
 8024f80:	681b      	ldr	r3, [r3, #0]
 8024f82:	68db      	ldr	r3, [r3, #12]
 8024f84:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8024f86:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
 8024f88:	429d      	cmp	r5, r3
 8024f8a:	d326      	bcc.n	8024fda <xTaskIncrementTick+0xce>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8024f8c:	1d26      	adds	r6, r4, #4
 8024f8e:	4630      	mov	r0, r6
 8024f90:	f7fe fe82 	bl	8023c98 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8024f94:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8024f96:	b11b      	cbz	r3, 8024fa0 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8024f98:	f104 0018 	add.w	r0, r4, #24
 8024f9c:	f7fe fe7c 	bl	8023c98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8024fa0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8024fa2:	2201      	movs	r2, #1
 8024fa4:	409a      	lsls	r2, r3
 8024fa6:	491c      	ldr	r1, [pc, #112]	; (8025018 <xTaskIncrementTick+0x10c>)
 8024fa8:	6808      	ldr	r0, [r1, #0]
 8024faa:	4302      	orrs	r2, r0
 8024fac:	600a      	str	r2, [r1, #0]
 8024fae:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8024fb2:	009a      	lsls	r2, r3, #2
 8024fb4:	4631      	mov	r1, r6
 8024fb6:	4817      	ldr	r0, [pc, #92]	; (8025014 <xTaskIncrementTick+0x108>)
 8024fb8:	4410      	add	r0, r2
 8024fba:	f7fe fe49 	bl	8023c50 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8024fbe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8024fc0:	4b13      	ldr	r3, [pc, #76]	; (8025010 <xTaskIncrementTick+0x104>)
 8024fc2:	681b      	ldr	r3, [r3, #0]
 8024fc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024fc6:	429a      	cmp	r2, r3
 8024fc8:	d2d4      	bcs.n	8024f74 <xTaskIncrementTick+0x68>
 8024fca:	e7d4      	b.n	8024f76 <xTaskIncrementTick+0x6a>
BaseType_t xSwitchRequired = pdFALSE;
 8024fcc:	2700      	movs	r7, #0
 8024fce:	e7d2      	b.n	8024f76 <xTaskIncrementTick+0x6a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8024fd0:	4b0e      	ldr	r3, [pc, #56]	; (802500c <xTaskIncrementTick+0x100>)
 8024fd2:	f04f 32ff 	mov.w	r2, #4294967295
 8024fd6:	601a      	str	r2, [r3, #0]
					break;
 8024fd8:	e7c0      	b.n	8024f5c <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 8024fda:	4a0c      	ldr	r2, [pc, #48]	; (802500c <xTaskIncrementTick+0x100>)
 8024fdc:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8024fde:	e7bd      	b.n	8024f5c <xTaskIncrementTick+0x50>
		++uxPendedTicks;
 8024fe0:	4a0e      	ldr	r2, [pc, #56]	; (802501c <xTaskIncrementTick+0x110>)
 8024fe2:	6813      	ldr	r3, [r2, #0]
 8024fe4:	3301      	adds	r3, #1
 8024fe6:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8024fe8:	2700      	movs	r7, #0
		if( xYieldPending != pdFALSE )
 8024fea:	4b0d      	ldr	r3, [pc, #52]	; (8025020 <xTaskIncrementTick+0x114>)
 8024fec:	681b      	ldr	r3, [r3, #0]
 8024fee:	b103      	cbz	r3, 8024ff2 <xTaskIncrementTick+0xe6>
			xSwitchRequired = pdTRUE;
 8024ff0:	2701      	movs	r7, #1
}
 8024ff2:	4638      	mov	r0, r7
 8024ff4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024ff6:	bf00      	nop
 8024ff8:	20011cd8 	.word	0x20011cd8
 8024ffc:	20011d58 	.word	0x20011d58
 8025000:	20011c38 	.word	0x20011c38
 8025004:	20011c3c 	.word	0x20011c3c
 8025008:	20011d14 	.word	0x20011d14
 802500c:	20011d10 	.word	0x20011d10
 8025010:	20011c34 	.word	0x20011c34
 8025014:	20011c40 	.word	0x20011c40
 8025018:	20011ce0 	.word	0x20011ce0
 802501c:	20011cd4 	.word	0x20011cd4
 8025020:	20011d5c 	.word	0x20011d5c

08025024 <xTaskResumeAll>:
{
 8025024:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended );
 8025026:	4b35      	ldr	r3, [pc, #212]	; (80250fc <xTaskResumeAll+0xd8>)
 8025028:	681b      	ldr	r3, [r3, #0]
 802502a:	b943      	cbnz	r3, 802503e <xTaskResumeAll+0x1a>
 802502c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025030:	f383 8811 	msr	BASEPRI, r3
 8025034:	f3bf 8f6f 	isb	sy
 8025038:	f3bf 8f4f 	dsb	sy
 802503c:	e7fe      	b.n	802503c <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
 802503e:	f7fe fea9 	bl	8023d94 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8025042:	4b2e      	ldr	r3, [pc, #184]	; (80250fc <xTaskResumeAll+0xd8>)
 8025044:	681a      	ldr	r2, [r3, #0]
 8025046:	3a01      	subs	r2, #1
 8025048:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 802504a:	681b      	ldr	r3, [r3, #0]
 802504c:	2b00      	cmp	r3, #0
 802504e:	d14f      	bne.n	80250f0 <xTaskResumeAll+0xcc>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8025050:	4b2b      	ldr	r3, [pc, #172]	; (8025100 <xTaskResumeAll+0xdc>)
 8025052:	681b      	ldr	r3, [r3, #0]
 8025054:	b90b      	cbnz	r3, 802505a <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8025056:	2400      	movs	r4, #0
 8025058:	e04b      	b.n	80250f2 <xTaskResumeAll+0xce>
TCB_t *pxTCB = NULL;
 802505a:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 802505c:	4b29      	ldr	r3, [pc, #164]	; (8025104 <xTaskResumeAll+0xe0>)
 802505e:	681b      	ldr	r3, [r3, #0]
 8025060:	b31b      	cbz	r3, 80250aa <xTaskResumeAll+0x86>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025062:	4b28      	ldr	r3, [pc, #160]	; (8025104 <xTaskResumeAll+0xe0>)
 8025064:	68db      	ldr	r3, [r3, #12]
 8025066:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8025068:	f104 0018 	add.w	r0, r4, #24
 802506c:	f7fe fe14 	bl	8023c98 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8025070:	1d25      	adds	r5, r4, #4
 8025072:	4628      	mov	r0, r5
 8025074:	f7fe fe10 	bl	8023c98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8025078:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802507a:	2301      	movs	r3, #1
 802507c:	4083      	lsls	r3, r0
 802507e:	4a22      	ldr	r2, [pc, #136]	; (8025108 <xTaskResumeAll+0xe4>)
 8025080:	6811      	ldr	r1, [r2, #0]
 8025082:	430b      	orrs	r3, r1
 8025084:	6013      	str	r3, [r2, #0]
 8025086:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802508a:	4629      	mov	r1, r5
 802508c:	4b1f      	ldr	r3, [pc, #124]	; (802510c <xTaskResumeAll+0xe8>)
 802508e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8025092:	f7fe fddd 	bl	8023c50 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8025096:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8025098:	4b1d      	ldr	r3, [pc, #116]	; (8025110 <xTaskResumeAll+0xec>)
 802509a:	681b      	ldr	r3, [r3, #0]
 802509c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802509e:	429a      	cmp	r2, r3
 80250a0:	d3dc      	bcc.n	802505c <xTaskResumeAll+0x38>
						xYieldPending = pdTRUE;
 80250a2:	4b1c      	ldr	r3, [pc, #112]	; (8025114 <xTaskResumeAll+0xf0>)
 80250a4:	2201      	movs	r2, #1
 80250a6:	601a      	str	r2, [r3, #0]
 80250a8:	e7d8      	b.n	802505c <xTaskResumeAll+0x38>
				if( pxTCB != NULL )
 80250aa:	b10c      	cbz	r4, 80250b0 <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
 80250ac:	f7ff fcb4 	bl	8024a18 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80250b0:	4b19      	ldr	r3, [pc, #100]	; (8025118 <xTaskResumeAll+0xf4>)
 80250b2:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80250b4:	b984      	cbnz	r4, 80250d8 <xTaskResumeAll+0xb4>
				if( xYieldPending != pdFALSE )
 80250b6:	4b17      	ldr	r3, [pc, #92]	; (8025114 <xTaskResumeAll+0xf0>)
 80250b8:	681c      	ldr	r4, [r3, #0]
 80250ba:	b1d4      	cbz	r4, 80250f2 <xTaskResumeAll+0xce>
					taskYIELD_IF_USING_PREEMPTION();
 80250bc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80250c0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80250c4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80250c8:	f3bf 8f4f 	dsb	sy
 80250cc:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 80250d0:	2401      	movs	r4, #1
 80250d2:	e00e      	b.n	80250f2 <xTaskResumeAll+0xce>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80250d4:	3c01      	subs	r4, #1
 80250d6:	d007      	beq.n	80250e8 <xTaskResumeAll+0xc4>
							if( xTaskIncrementTick() != pdFALSE )
 80250d8:	f7ff ff18 	bl	8024f0c <xTaskIncrementTick>
 80250dc:	2800      	cmp	r0, #0
 80250de:	d0f9      	beq.n	80250d4 <xTaskResumeAll+0xb0>
								xYieldPending = pdTRUE;
 80250e0:	4b0c      	ldr	r3, [pc, #48]	; (8025114 <xTaskResumeAll+0xf0>)
 80250e2:	2201      	movs	r2, #1
 80250e4:	601a      	str	r2, [r3, #0]
 80250e6:	e7f5      	b.n	80250d4 <xTaskResumeAll+0xb0>
						uxPendedTicks = 0;
 80250e8:	4b0b      	ldr	r3, [pc, #44]	; (8025118 <xTaskResumeAll+0xf4>)
 80250ea:	2200      	movs	r2, #0
 80250ec:	601a      	str	r2, [r3, #0]
 80250ee:	e7e2      	b.n	80250b6 <xTaskResumeAll+0x92>
BaseType_t xAlreadyYielded = pdFALSE;
 80250f0:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80250f2:	f7fe fe71 	bl	8023dd8 <vPortExitCritical>
}
 80250f6:	4620      	mov	r0, r4
 80250f8:	bd38      	pop	{r3, r4, r5, pc}
 80250fa:	bf00      	nop
 80250fc:	20011cd8 	.word	0x20011cd8
 8025100:	20011ccc 	.word	0x20011ccc
 8025104:	20011d18 	.word	0x20011d18
 8025108:	20011ce0 	.word	0x20011ce0
 802510c:	20011c40 	.word	0x20011c40
 8025110:	20011c34 	.word	0x20011c34
 8025114:	20011d5c 	.word	0x20011d5c
 8025118:	20011cd4 	.word	0x20011cd4

0802511c <vTaskDelay>:
	{
 802511c:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 802511e:	b1a8      	cbz	r0, 802514c <vTaskDelay+0x30>
 8025120:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 8025122:	4b10      	ldr	r3, [pc, #64]	; (8025164 <vTaskDelay+0x48>)
 8025124:	681b      	ldr	r3, [r3, #0]
 8025126:	b143      	cbz	r3, 802513a <vTaskDelay+0x1e>
 8025128:	f04f 0350 	mov.w	r3, #80	; 0x50
 802512c:	f383 8811 	msr	BASEPRI, r3
 8025130:	f3bf 8f6f 	isb	sy
 8025134:	f3bf 8f4f 	dsb	sy
 8025138:	e7fe      	b.n	8025138 <vTaskDelay+0x1c>
			vTaskSuspendAll();
 802513a:	f7ff fed1 	bl	8024ee0 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 802513e:	2100      	movs	r1, #0
 8025140:	4620      	mov	r0, r4
 8025142:	f7ff fd9d 	bl	8024c80 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8025146:	f7ff ff6d 	bl	8025024 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 802514a:	b948      	cbnz	r0, 8025160 <vTaskDelay+0x44>
			portYIELD_WITHIN_API();
 802514c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8025150:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025154:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8025158:	f3bf 8f4f 	dsb	sy
 802515c:	f3bf 8f6f 	isb	sy
	}
 8025160:	bd10      	pop	{r4, pc}
 8025162:	bf00      	nop
 8025164:	20011cd8 	.word	0x20011cd8

08025168 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8025168:	4b20      	ldr	r3, [pc, #128]	; (80251ec <vTaskSwitchContext+0x84>)
 802516a:	681b      	ldr	r3, [r3, #0]
 802516c:	b11b      	cbz	r3, 8025176 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 802516e:	4b20      	ldr	r3, [pc, #128]	; (80251f0 <vTaskSwitchContext+0x88>)
 8025170:	2201      	movs	r2, #1
 8025172:	601a      	str	r2, [r3, #0]
 8025174:	4770      	bx	lr
		xYieldPending = pdFALSE;
 8025176:	4b1e      	ldr	r3, [pc, #120]	; (80251f0 <vTaskSwitchContext+0x88>)
 8025178:	2200      	movs	r2, #0
 802517a:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 802517c:	4b1d      	ldr	r3, [pc, #116]	; (80251f4 <vTaskSwitchContext+0x8c>)
 802517e:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8025180:	fab3 f383 	clz	r3, r3
 8025184:	b2db      	uxtb	r3, r3
 8025186:	f1c3 031f 	rsb	r3, r3, #31
 802518a:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 802518e:	008a      	lsls	r2, r1, #2
 8025190:	4919      	ldr	r1, [pc, #100]	; (80251f8 <vTaskSwitchContext+0x90>)
 8025192:	588a      	ldr	r2, [r1, r2]
 8025194:	b942      	cbnz	r2, 80251a8 <vTaskSwitchContext+0x40>
	__asm volatile
 8025196:	f04f 0350 	mov.w	r3, #80	; 0x50
 802519a:	f383 8811 	msr	BASEPRI, r3
 802519e:	f3bf 8f6f 	isb	sy
 80251a2:	f3bf 8f4f 	dsb	sy
 80251a6:	e7fe      	b.n	80251a6 <vTaskSwitchContext+0x3e>
 80251a8:	4913      	ldr	r1, [pc, #76]	; (80251f8 <vTaskSwitchContext+0x90>)
 80251aa:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 80251ae:	0082      	lsls	r2, r0, #2
 80251b0:	440a      	add	r2, r1
 80251b2:	6850      	ldr	r0, [r2, #4]
 80251b4:	6840      	ldr	r0, [r0, #4]
 80251b6:	6050      	str	r0, [r2, #4]
 80251b8:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 80251bc:	ea4f 028c 	mov.w	r2, ip, lsl #2
 80251c0:	3208      	adds	r2, #8
 80251c2:	4411      	add	r1, r2
 80251c4:	4288      	cmp	r0, r1
 80251c6:	d009      	beq.n	80251dc <vTaskSwitchContext+0x74>
 80251c8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80251cc:	009a      	lsls	r2, r3, #2
 80251ce:	4b0a      	ldr	r3, [pc, #40]	; (80251f8 <vTaskSwitchContext+0x90>)
 80251d0:	4413      	add	r3, r2
 80251d2:	685b      	ldr	r3, [r3, #4]
 80251d4:	68da      	ldr	r2, [r3, #12]
 80251d6:	4b09      	ldr	r3, [pc, #36]	; (80251fc <vTaskSwitchContext+0x94>)
 80251d8:	601a      	str	r2, [r3, #0]
}
 80251da:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80251dc:	6840      	ldr	r0, [r0, #4]
 80251de:	4662      	mov	r2, ip
 80251e0:	0091      	lsls	r1, r2, #2
 80251e2:	4a05      	ldr	r2, [pc, #20]	; (80251f8 <vTaskSwitchContext+0x90>)
 80251e4:	440a      	add	r2, r1
 80251e6:	6050      	str	r0, [r2, #4]
 80251e8:	e7ee      	b.n	80251c8 <vTaskSwitchContext+0x60>
 80251ea:	bf00      	nop
 80251ec:	20011cd8 	.word	0x20011cd8
 80251f0:	20011d5c 	.word	0x20011d5c
 80251f4:	20011ce0 	.word	0x20011ce0
 80251f8:	20011c40 	.word	0x20011c40
 80251fc:	20011c34 	.word	0x20011c34

08025200 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 8025200:	b158      	cbz	r0, 802521a <vTaskPlaceOnEventList+0x1a>
{
 8025202:	b510      	push	{r4, lr}
 8025204:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8025206:	4a09      	ldr	r2, [pc, #36]	; (802522c <vTaskPlaceOnEventList+0x2c>)
 8025208:	6811      	ldr	r1, [r2, #0]
 802520a:	3118      	adds	r1, #24
 802520c:	f7fe fd2b 	bl	8023c66 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8025210:	2101      	movs	r1, #1
 8025212:	4620      	mov	r0, r4
 8025214:	f7ff fd34 	bl	8024c80 <prvAddCurrentTaskToDelayedList>
}
 8025218:	bd10      	pop	{r4, pc}
 802521a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802521e:	f383 8811 	msr	BASEPRI, r3
 8025222:	f3bf 8f6f 	isb	sy
 8025226:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 802522a:	e7fe      	b.n	802522a <vTaskPlaceOnEventList+0x2a>
 802522c:	20011c34 	.word	0x20011c34

08025230 <vTaskPlaceOnEventListRestricted>:
	{
 8025230:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 8025232:	b170      	cbz	r0, 8025252 <vTaskPlaceOnEventListRestricted+0x22>
 8025234:	460d      	mov	r5, r1
 8025236:	4614      	mov	r4, r2
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8025238:	4a0a      	ldr	r2, [pc, #40]	; (8025264 <vTaskPlaceOnEventListRestricted+0x34>)
 802523a:	6811      	ldr	r1, [r2, #0]
 802523c:	3118      	adds	r1, #24
 802523e:	f7fe fd07 	bl	8023c50 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 8025242:	b10c      	cbz	r4, 8025248 <vTaskPlaceOnEventListRestricted+0x18>
			xTicksToWait = portMAX_DELAY;
 8025244:	f04f 35ff 	mov.w	r5, #4294967295
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8025248:	4621      	mov	r1, r4
 802524a:	4628      	mov	r0, r5
 802524c:	f7ff fd18 	bl	8024c80 <prvAddCurrentTaskToDelayedList>
	}
 8025250:	bd38      	pop	{r3, r4, r5, pc}
 8025252:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025256:	f383 8811 	msr	BASEPRI, r3
 802525a:	f3bf 8f6f 	isb	sy
 802525e:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 8025262:	e7fe      	b.n	8025262 <vTaskPlaceOnEventListRestricted+0x32>
 8025264:	20011c34 	.word	0x20011c34

08025268 <xTaskRemoveFromEventList>:
{
 8025268:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 802526a:	68c3      	ldr	r3, [r0, #12]
 802526c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 802526e:	b324      	cbz	r4, 80252ba <xTaskRemoveFromEventList+0x52>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8025270:	f104 0518 	add.w	r5, r4, #24
 8025274:	4628      	mov	r0, r5
 8025276:	f7fe fd0f 	bl	8023c98 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 802527a:	4b18      	ldr	r3, [pc, #96]	; (80252dc <xTaskRemoveFromEventList+0x74>)
 802527c:	681b      	ldr	r3, [r3, #0]
 802527e:	bb2b      	cbnz	r3, 80252cc <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8025280:	1d25      	adds	r5, r4, #4
 8025282:	4628      	mov	r0, r5
 8025284:	f7fe fd08 	bl	8023c98 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8025288:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802528a:	2301      	movs	r3, #1
 802528c:	4083      	lsls	r3, r0
 802528e:	4a14      	ldr	r2, [pc, #80]	; (80252e0 <xTaskRemoveFromEventList+0x78>)
 8025290:	6811      	ldr	r1, [r2, #0]
 8025292:	430b      	orrs	r3, r1
 8025294:	6013      	str	r3, [r2, #0]
 8025296:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802529a:	4629      	mov	r1, r5
 802529c:	4b11      	ldr	r3, [pc, #68]	; (80252e4 <xTaskRemoveFromEventList+0x7c>)
 802529e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80252a2:	f7fe fcd5 	bl	8023c50 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80252a6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80252a8:	4b0f      	ldr	r3, [pc, #60]	; (80252e8 <xTaskRemoveFromEventList+0x80>)
 80252aa:	681b      	ldr	r3, [r3, #0]
 80252ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80252ae:	429a      	cmp	r2, r3
 80252b0:	d911      	bls.n	80252d6 <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
 80252b2:	2001      	movs	r0, #1
 80252b4:	4b0d      	ldr	r3, [pc, #52]	; (80252ec <xTaskRemoveFromEventList+0x84>)
 80252b6:	6018      	str	r0, [r3, #0]
}
 80252b8:	bd38      	pop	{r3, r4, r5, pc}
 80252ba:	f04f 0350 	mov.w	r3, #80	; 0x50
 80252be:	f383 8811 	msr	BASEPRI, r3
 80252c2:	f3bf 8f6f 	isb	sy
 80252c6:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 80252ca:	e7fe      	b.n	80252ca <xTaskRemoveFromEventList+0x62>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80252cc:	4629      	mov	r1, r5
 80252ce:	4808      	ldr	r0, [pc, #32]	; (80252f0 <xTaskRemoveFromEventList+0x88>)
 80252d0:	f7fe fcbe 	bl	8023c50 <vListInsertEnd>
 80252d4:	e7e7      	b.n	80252a6 <xTaskRemoveFromEventList+0x3e>
		xReturn = pdFALSE;
 80252d6:	2000      	movs	r0, #0
	return xReturn;
 80252d8:	e7ee      	b.n	80252b8 <xTaskRemoveFromEventList+0x50>
 80252da:	bf00      	nop
 80252dc:	20011cd8 	.word	0x20011cd8
 80252e0:	20011ce0 	.word	0x20011ce0
 80252e4:	20011c40 	.word	0x20011c40
 80252e8:	20011c34 	.word	0x20011c34
 80252ec:	20011d5c 	.word	0x20011d5c
 80252f0:	20011d18 	.word	0x20011d18

080252f4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80252f4:	4b03      	ldr	r3, [pc, #12]	; (8025304 <vTaskInternalSetTimeOutState+0x10>)
 80252f6:	681b      	ldr	r3, [r3, #0]
 80252f8:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80252fa:	4b03      	ldr	r3, [pc, #12]	; (8025308 <vTaskInternalSetTimeOutState+0x14>)
 80252fc:	681b      	ldr	r3, [r3, #0]
 80252fe:	6043      	str	r3, [r0, #4]
}
 8025300:	4770      	bx	lr
 8025302:	bf00      	nop
 8025304:	20011d14 	.word	0x20011d14
 8025308:	20011d58 	.word	0x20011d58

0802530c <xTaskCheckForTimeOut>:
{
 802530c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 802530e:	b1c8      	cbz	r0, 8025344 <xTaskCheckForTimeOut+0x38>
 8025310:	460c      	mov	r4, r1
 8025312:	4605      	mov	r5, r0
	configASSERT( pxTicksToWait );
 8025314:	b1f9      	cbz	r1, 8025356 <xTaskCheckForTimeOut+0x4a>
	taskENTER_CRITICAL();
 8025316:	f7fe fd3d 	bl	8023d94 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 802531a:	4b1b      	ldr	r3, [pc, #108]	; (8025388 <xTaskCheckForTimeOut+0x7c>)
 802531c:	6819      	ldr	r1, [r3, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 802531e:	686b      	ldr	r3, [r5, #4]
 8025320:	1ac8      	subs	r0, r1, r3
			if( *pxTicksToWait == portMAX_DELAY )
 8025322:	6822      	ldr	r2, [r4, #0]
 8025324:	f1b2 3fff 	cmp.w	r2, #4294967295
 8025328:	d026      	beq.n	8025378 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 802532a:	4e18      	ldr	r6, [pc, #96]	; (802538c <xTaskCheckForTimeOut+0x80>)
 802532c:	6836      	ldr	r6, [r6, #0]
 802532e:	682f      	ldr	r7, [r5, #0]
 8025330:	42b7      	cmp	r7, r6
 8025332:	d001      	beq.n	8025338 <xTaskCheckForTimeOut+0x2c>
 8025334:	428b      	cmp	r3, r1
 8025336:	d924      	bls.n	8025382 <xTaskCheckForTimeOut+0x76>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8025338:	4282      	cmp	r2, r0
 802533a:	d815      	bhi.n	8025368 <xTaskCheckForTimeOut+0x5c>
			*pxTicksToWait = 0;
 802533c:	2300      	movs	r3, #0
 802533e:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 8025340:	2401      	movs	r4, #1
 8025342:	e01a      	b.n	802537a <xTaskCheckForTimeOut+0x6e>
 8025344:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025348:	f383 8811 	msr	BASEPRI, r3
 802534c:	f3bf 8f6f 	isb	sy
 8025350:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 8025354:	e7fe      	b.n	8025354 <xTaskCheckForTimeOut+0x48>
 8025356:	f04f 0350 	mov.w	r3, #80	; 0x50
 802535a:	f383 8811 	msr	BASEPRI, r3
 802535e:	f3bf 8f6f 	isb	sy
 8025362:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 8025366:	e7fe      	b.n	8025366 <xTaskCheckForTimeOut+0x5a>
			*pxTicksToWait -= xElapsedTime;
 8025368:	1a5b      	subs	r3, r3, r1
 802536a:	4413      	add	r3, r2
 802536c:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 802536e:	4628      	mov	r0, r5
 8025370:	f7ff ffc0 	bl	80252f4 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 8025374:	2400      	movs	r4, #0
 8025376:	e000      	b.n	802537a <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
 8025378:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 802537a:	f7fe fd2d 	bl	8023dd8 <vPortExitCritical>
}
 802537e:	4620      	mov	r0, r4
 8025380:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 8025382:	2401      	movs	r4, #1
 8025384:	e7f9      	b.n	802537a <xTaskCheckForTimeOut+0x6e>
 8025386:	bf00      	nop
 8025388:	20011d58 	.word	0x20011d58
 802538c:	20011d14 	.word	0x20011d14

08025390 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8025390:	4b01      	ldr	r3, [pc, #4]	; (8025398 <vTaskMissedYield+0x8>)
 8025392:	2201      	movs	r2, #1
 8025394:	601a      	str	r2, [r3, #0]
}
 8025396:	4770      	bx	lr
 8025398:	20011d5c 	.word	0x20011d5c

0802539c <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 802539c:	4b05      	ldr	r3, [pc, #20]	; (80253b4 <xTaskGetSchedulerState+0x18>)
 802539e:	681b      	ldr	r3, [r3, #0]
 80253a0:	b133      	cbz	r3, 80253b0 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80253a2:	4b05      	ldr	r3, [pc, #20]	; (80253b8 <xTaskGetSchedulerState+0x1c>)
 80253a4:	681b      	ldr	r3, [r3, #0]
 80253a6:	b10b      	cbz	r3, 80253ac <xTaskGetSchedulerState+0x10>
				xReturn = taskSCHEDULER_SUSPENDED;
 80253a8:	2000      	movs	r0, #0
	}
 80253aa:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 80253ac:	2002      	movs	r0, #2
 80253ae:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 80253b0:	2001      	movs	r0, #1
 80253b2:	4770      	bx	lr
 80253b4:	20011d2c 	.word	0x20011d2c
 80253b8:	20011cd8 	.word	0x20011cd8

080253bc <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 80253bc:	2800      	cmp	r0, #0
 80253be:	d04f      	beq.n	8025460 <xTaskPriorityInherit+0xa4>
	{
 80253c0:	b538      	push	{r3, r4, r5, lr}
 80253c2:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 80253c4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80253c6:	4a28      	ldr	r2, [pc, #160]	; (8025468 <xTaskPriorityInherit+0xac>)
 80253c8:	6812      	ldr	r2, [r2, #0]
 80253ca:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80253cc:	4293      	cmp	r3, r2
 80253ce:	d23f      	bcs.n	8025450 <xTaskPriorityInherit+0x94>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80253d0:	6982      	ldr	r2, [r0, #24]
 80253d2:	2a00      	cmp	r2, #0
 80253d4:	db05      	blt.n	80253e2 <xTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80253d6:	4a24      	ldr	r2, [pc, #144]	; (8025468 <xTaskPriorityInherit+0xac>)
 80253d8:	6812      	ldr	r2, [r2, #0]
 80253da:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80253dc:	f1c2 0207 	rsb	r2, r2, #7
 80253e0:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80253e2:	6961      	ldr	r1, [r4, #20]
 80253e4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80253e8:	4a20      	ldr	r2, [pc, #128]	; (802546c <xTaskPriorityInherit+0xb0>)
 80253ea:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80253ee:	4299      	cmp	r1, r3
 80253f0:	d005      	beq.n	80253fe <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80253f2:	4b1d      	ldr	r3, [pc, #116]	; (8025468 <xTaskPriorityInherit+0xac>)
 80253f4:	681b      	ldr	r3, [r3, #0]
 80253f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80253f8:	62e3      	str	r3, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
 80253fa:	2001      	movs	r0, #1
	}
 80253fc:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80253fe:	1d25      	adds	r5, r4, #4
 8025400:	4628      	mov	r0, r5
 8025402:	f7fe fc49 	bl	8023c98 <uxListRemove>
 8025406:	b970      	cbnz	r0, 8025426 <xTaskPriorityInherit+0x6a>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 8025408:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 802540a:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 802540e:	009b      	lsls	r3, r3, #2
 8025410:	4916      	ldr	r1, [pc, #88]	; (802546c <xTaskPriorityInherit+0xb0>)
 8025412:	58cb      	ldr	r3, [r1, r3]
 8025414:	b93b      	cbnz	r3, 8025426 <xTaskPriorityInherit+0x6a>
 8025416:	2301      	movs	r3, #1
 8025418:	fa03 f202 	lsl.w	r2, r3, r2
 802541c:	4914      	ldr	r1, [pc, #80]	; (8025470 <xTaskPriorityInherit+0xb4>)
 802541e:	680b      	ldr	r3, [r1, #0]
 8025420:	ea23 0302 	bic.w	r3, r3, r2
 8025424:	600b      	str	r3, [r1, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8025426:	4b10      	ldr	r3, [pc, #64]	; (8025468 <xTaskPriorityInherit+0xac>)
 8025428:	681b      	ldr	r3, [r3, #0]
 802542a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 802542c:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 802542e:	2401      	movs	r4, #1
 8025430:	fa04 f300 	lsl.w	r3, r4, r0
 8025434:	4a0e      	ldr	r2, [pc, #56]	; (8025470 <xTaskPriorityInherit+0xb4>)
 8025436:	6811      	ldr	r1, [r2, #0]
 8025438:	430b      	orrs	r3, r1
 802543a:	6013      	str	r3, [r2, #0]
 802543c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025440:	4629      	mov	r1, r5
 8025442:	4b0a      	ldr	r3, [pc, #40]	; (802546c <xTaskPriorityInherit+0xb0>)
 8025444:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8025448:	f7fe fc02 	bl	8023c50 <vListInsertEnd>
				xReturn = pdTRUE;
 802544c:	4620      	mov	r0, r4
 802544e:	e7d5      	b.n	80253fc <xTaskPriorityInherit+0x40>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8025450:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8025452:	4b05      	ldr	r3, [pc, #20]	; (8025468 <xTaskPriorityInherit+0xac>)
 8025454:	681b      	ldr	r3, [r3, #0]
 8025456:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025458:	429a      	cmp	r2, r3
 802545a:	d303      	bcc.n	8025464 <xTaskPriorityInherit+0xa8>
	BaseType_t xReturn = pdFALSE;
 802545c:	2000      	movs	r0, #0
 802545e:	e7cd      	b.n	80253fc <xTaskPriorityInherit+0x40>
 8025460:	2000      	movs	r0, #0
	}
 8025462:	4770      	bx	lr
					xReturn = pdTRUE;
 8025464:	2001      	movs	r0, #1
		return xReturn;
 8025466:	e7c9      	b.n	80253fc <xTaskPriorityInherit+0x40>
 8025468:	20011c34 	.word	0x20011c34
 802546c:	20011c40 	.word	0x20011c40
 8025470:	20011ce0 	.word	0x20011ce0

08025474 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8025474:	2800      	cmp	r0, #0
 8025476:	d04b      	beq.n	8025510 <xTaskPriorityDisinherit+0x9c>
	{
 8025478:	b538      	push	{r3, r4, r5, lr}
 802547a:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 802547c:	4b26      	ldr	r3, [pc, #152]	; (8025518 <xTaskPriorityDisinherit+0xa4>)
 802547e:	681b      	ldr	r3, [r3, #0]
 8025480:	4283      	cmp	r3, r0
 8025482:	d008      	beq.n	8025496 <xTaskPriorityDisinherit+0x22>
 8025484:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025488:	f383 8811 	msr	BASEPRI, r3
 802548c:	f3bf 8f6f 	isb	sy
 8025490:	f3bf 8f4f 	dsb	sy
 8025494:	e7fe      	b.n	8025494 <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 8025496:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8025498:	b943      	cbnz	r3, 80254ac <xTaskPriorityDisinherit+0x38>
 802549a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802549e:	f383 8811 	msr	BASEPRI, r3
 80254a2:	f3bf 8f6f 	isb	sy
 80254a6:	f3bf 8f4f 	dsb	sy
 80254aa:	e7fe      	b.n	80254aa <xTaskPriorityDisinherit+0x36>
			( pxTCB->uxMutexesHeld )--;
 80254ac:	3b01      	subs	r3, #1
 80254ae:	6503      	str	r3, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80254b0:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80254b2:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 80254b4:	4291      	cmp	r1, r2
 80254b6:	d02d      	beq.n	8025514 <xTaskPriorityDisinherit+0xa0>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80254b8:	b10b      	cbz	r3, 80254be <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 80254ba:	2000      	movs	r0, #0
	}
 80254bc:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80254be:	1d05      	adds	r5, r0, #4
 80254c0:	4628      	mov	r0, r5
 80254c2:	f7fe fbe9 	bl	8023c98 <uxListRemove>
 80254c6:	b968      	cbnz	r0, 80254e4 <xTaskPriorityDisinherit+0x70>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80254c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80254ca:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80254ce:	0092      	lsls	r2, r2, #2
 80254d0:	4912      	ldr	r1, [pc, #72]	; (802551c <xTaskPriorityDisinherit+0xa8>)
 80254d2:	588a      	ldr	r2, [r1, r2]
 80254d4:	b932      	cbnz	r2, 80254e4 <xTaskPriorityDisinherit+0x70>
 80254d6:	2201      	movs	r2, #1
 80254d8:	409a      	lsls	r2, r3
 80254da:	4911      	ldr	r1, [pc, #68]	; (8025520 <xTaskPriorityDisinherit+0xac>)
 80254dc:	680b      	ldr	r3, [r1, #0]
 80254de:	ea23 0302 	bic.w	r3, r3, r2
 80254e2:	600b      	str	r3, [r1, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80254e4:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80254e6:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80254e8:	f1c0 0307 	rsb	r3, r0, #7
 80254ec:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 80254ee:	2401      	movs	r4, #1
 80254f0:	fa04 f300 	lsl.w	r3, r4, r0
 80254f4:	4a0a      	ldr	r2, [pc, #40]	; (8025520 <xTaskPriorityDisinherit+0xac>)
 80254f6:	6811      	ldr	r1, [r2, #0]
 80254f8:	430b      	orrs	r3, r1
 80254fa:	6013      	str	r3, [r2, #0]
 80254fc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025500:	4629      	mov	r1, r5
 8025502:	4b06      	ldr	r3, [pc, #24]	; (802551c <xTaskPriorityDisinherit+0xa8>)
 8025504:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8025508:	f7fe fba2 	bl	8023c50 <vListInsertEnd>
					xReturn = pdTRUE;
 802550c:	4620      	mov	r0, r4
 802550e:	e7d5      	b.n	80254bc <xTaskPriorityDisinherit+0x48>
	BaseType_t xReturn = pdFALSE;
 8025510:	2000      	movs	r0, #0
	}
 8025512:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
 8025514:	2000      	movs	r0, #0
 8025516:	e7d1      	b.n	80254bc <xTaskPriorityDisinherit+0x48>
 8025518:	20011c34 	.word	0x20011c34
 802551c:	20011c40 	.word	0x20011c40
 8025520:	20011ce0 	.word	0x20011ce0

08025524 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 8025524:	2800      	cmp	r0, #0
 8025526:	d055      	beq.n	80255d4 <vTaskPriorityDisinheritAfterTimeout+0xb0>
	{
 8025528:	b538      	push	{r3, r4, r5, lr}
 802552a:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 802552c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 802552e:	b943      	cbnz	r3, 8025542 <vTaskPriorityDisinheritAfterTimeout+0x1e>
 8025530:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025534:	f383 8811 	msr	BASEPRI, r3
 8025538:	f3bf 8f6f 	isb	sy
 802553c:	f3bf 8f4f 	dsb	sy
 8025540:	e7fe      	b.n	8025540 <vTaskPriorityDisinheritAfterTimeout+0x1c>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8025542:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8025544:	428a      	cmp	r2, r1
 8025546:	d200      	bcs.n	802554a <vTaskPriorityDisinheritAfterTimeout+0x26>
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 8025548:	460a      	mov	r2, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
 802554a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802554c:	4291      	cmp	r1, r2
 802554e:	d001      	beq.n	8025554 <vTaskPriorityDisinheritAfterTimeout+0x30>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8025550:	2b01      	cmp	r3, #1
 8025552:	d000      	beq.n	8025556 <vTaskPriorityDisinheritAfterTimeout+0x32>
	}
 8025554:	bd38      	pop	{r3, r4, r5, pc}
					configASSERT( pxTCB != pxCurrentTCB );
 8025556:	4b20      	ldr	r3, [pc, #128]	; (80255d8 <vTaskPriorityDisinheritAfterTimeout+0xb4>)
 8025558:	681b      	ldr	r3, [r3, #0]
 802555a:	42a3      	cmp	r3, r4
 802555c:	d031      	beq.n	80255c2 <vTaskPriorityDisinheritAfterTimeout+0x9e>
					pxTCB->uxPriority = uxPriorityToUse;
 802555e:	62e2      	str	r2, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8025560:	69a3      	ldr	r3, [r4, #24]
 8025562:	2b00      	cmp	r3, #0
 8025564:	db02      	blt.n	802556c <vTaskPriorityDisinheritAfterTimeout+0x48>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025566:	f1c2 0207 	rsb	r2, r2, #7
 802556a:	61a2      	str	r2, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 802556c:	6962      	ldr	r2, [r4, #20]
 802556e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8025572:	4b1a      	ldr	r3, [pc, #104]	; (80255dc <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 8025574:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8025578:	429a      	cmp	r2, r3
 802557a:	d1eb      	bne.n	8025554 <vTaskPriorityDisinheritAfterTimeout+0x30>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 802557c:	1d25      	adds	r5, r4, #4
 802557e:	4628      	mov	r0, r5
 8025580:	f7fe fb8a 	bl	8023c98 <uxListRemove>
 8025584:	b968      	cbnz	r0, 80255a2 <vTaskPriorityDisinheritAfterTimeout+0x7e>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8025586:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8025588:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 802558c:	0092      	lsls	r2, r2, #2
 802558e:	4913      	ldr	r1, [pc, #76]	; (80255dc <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 8025590:	588a      	ldr	r2, [r1, r2]
 8025592:	b932      	cbnz	r2, 80255a2 <vTaskPriorityDisinheritAfterTimeout+0x7e>
 8025594:	2201      	movs	r2, #1
 8025596:	409a      	lsls	r2, r3
 8025598:	4911      	ldr	r1, [pc, #68]	; (80255e0 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
 802559a:	680b      	ldr	r3, [r1, #0]
 802559c:	ea23 0302 	bic.w	r3, r3, r2
 80255a0:	600b      	str	r3, [r1, #0]
						prvAddTaskToReadyList( pxTCB );
 80255a2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80255a4:	2301      	movs	r3, #1
 80255a6:	4083      	lsls	r3, r0
 80255a8:	4a0d      	ldr	r2, [pc, #52]	; (80255e0 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
 80255aa:	6811      	ldr	r1, [r2, #0]
 80255ac:	430b      	orrs	r3, r1
 80255ae:	6013      	str	r3, [r2, #0]
 80255b0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80255b4:	4629      	mov	r1, r5
 80255b6:	4b09      	ldr	r3, [pc, #36]	; (80255dc <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 80255b8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80255bc:	f7fe fb48 	bl	8023c50 <vListInsertEnd>
	}
 80255c0:	e7c8      	b.n	8025554 <vTaskPriorityDisinheritAfterTimeout+0x30>
 80255c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80255c6:	f383 8811 	msr	BASEPRI, r3
 80255ca:	f3bf 8f6f 	isb	sy
 80255ce:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 80255d2:	e7fe      	b.n	80255d2 <vTaskPriorityDisinheritAfterTimeout+0xae>
 80255d4:	4770      	bx	lr
 80255d6:	bf00      	nop
 80255d8:	20011c34 	.word	0x20011c34
 80255dc:	20011c40 	.word	0x20011c40
 80255e0:	20011ce0 	.word	0x20011ce0

080255e4 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 80255e4:	4b05      	ldr	r3, [pc, #20]	; (80255fc <pvTaskIncrementMutexHeldCount+0x18>)
 80255e6:	681b      	ldr	r3, [r3, #0]
 80255e8:	b123      	cbz	r3, 80255f4 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 80255ea:	4b04      	ldr	r3, [pc, #16]	; (80255fc <pvTaskIncrementMutexHeldCount+0x18>)
 80255ec:	681a      	ldr	r2, [r3, #0]
 80255ee:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80255f0:	3301      	adds	r3, #1
 80255f2:	6513      	str	r3, [r2, #80]	; 0x50
		return pxCurrentTCB;
 80255f4:	4b01      	ldr	r3, [pc, #4]	; (80255fc <pvTaskIncrementMutexHeldCount+0x18>)
 80255f6:	6818      	ldr	r0, [r3, #0]
	}
 80255f8:	4770      	bx	lr
 80255fa:	bf00      	nop
 80255fc:	20011c34 	.word	0x20011c34

08025600 <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8025600:	4b06      	ldr	r3, [pc, #24]	; (802561c <prvGetNextExpireTime+0x1c>)
 8025602:	681a      	ldr	r2, [r3, #0]
 8025604:	6813      	ldr	r3, [r2, #0]
 8025606:	b92b      	cbnz	r3, 8025614 <prvGetNextExpireTime+0x14>
 8025608:	2301      	movs	r3, #1
 802560a:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
 802560c:	b923      	cbnz	r3, 8025618 <prvGetNextExpireTime+0x18>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 802560e:	68d3      	ldr	r3, [r2, #12]
 8025610:	6818      	ldr	r0, [r3, #0]
 8025612:	4770      	bx	lr
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8025614:	2300      	movs	r3, #0
 8025616:	e7f8      	b.n	802560a <prvGetNextExpireTime+0xa>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8025618:	2000      	movs	r0, #0
	}

	return xNextExpireTime;
}
 802561a:	4770      	bx	lr
 802561c:	20011d60 	.word	0x20011d60

08025620 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 8025620:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8025622:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8025624:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
 8025626:	4291      	cmp	r1, r2
 8025628:	d80c      	bhi.n	8025644 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 802562a:	1ad2      	subs	r2, r2, r3
 802562c:	6983      	ldr	r3, [r0, #24]
 802562e:	429a      	cmp	r2, r3
 8025630:	d301      	bcc.n	8025636 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8025632:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 8025634:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8025636:	1d01      	adds	r1, r0, #4
 8025638:	4b09      	ldr	r3, [pc, #36]	; (8025660 <prvInsertTimerInActiveList+0x40>)
 802563a:	6818      	ldr	r0, [r3, #0]
 802563c:	f7fe fb13 	bl	8023c66 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8025640:	2000      	movs	r0, #0
 8025642:	e7f7      	b.n	8025634 <prvInsertTimerInActiveList+0x14>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8025644:	429a      	cmp	r2, r3
 8025646:	d201      	bcs.n	802564c <prvInsertTimerInActiveList+0x2c>
 8025648:	4299      	cmp	r1, r3
 802564a:	d206      	bcs.n	802565a <prvInsertTimerInActiveList+0x3a>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 802564c:	1d01      	adds	r1, r0, #4
 802564e:	4b05      	ldr	r3, [pc, #20]	; (8025664 <prvInsertTimerInActiveList+0x44>)
 8025650:	6818      	ldr	r0, [r3, #0]
 8025652:	f7fe fb08 	bl	8023c66 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8025656:	2000      	movs	r0, #0
 8025658:	e7ec      	b.n	8025634 <prvInsertTimerInActiveList+0x14>
			xProcessTimerNow = pdTRUE;
 802565a:	2001      	movs	r0, #1
	return xProcessTimerNow;
 802565c:	e7ea      	b.n	8025634 <prvInsertTimerInActiveList+0x14>
 802565e:	bf00      	nop
 8025660:	20011d64 	.word	0x20011d64
 8025664:	20011d60 	.word	0x20011d60

08025668 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8025668:	b538      	push	{r3, r4, r5, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 802566a:	f7fe fb93 	bl	8023d94 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 802566e:	4b0f      	ldr	r3, [pc, #60]	; (80256ac <prvCheckForValidListAndQueue+0x44>)
 8025670:	681b      	ldr	r3, [r3, #0]
 8025672:	b113      	cbz	r3, 802567a <prvCheckForValidListAndQueue+0x12>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8025674:	f7fe fbb0 	bl	8023dd8 <vPortExitCritical>
}
 8025678:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &xActiveTimerList1 );
 802567a:	4d0d      	ldr	r5, [pc, #52]	; (80256b0 <prvCheckForValidListAndQueue+0x48>)
 802567c:	4628      	mov	r0, r5
 802567e:	f7fe fad9 	bl	8023c34 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8025682:	4c0c      	ldr	r4, [pc, #48]	; (80256b4 <prvCheckForValidListAndQueue+0x4c>)
 8025684:	4620      	mov	r0, r4
 8025686:	f7fe fad5 	bl	8023c34 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 802568a:	4b0b      	ldr	r3, [pc, #44]	; (80256b8 <prvCheckForValidListAndQueue+0x50>)
 802568c:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 802568e:	4b0b      	ldr	r3, [pc, #44]	; (80256bc <prvCheckForValidListAndQueue+0x54>)
 8025690:	601c      	str	r4, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8025692:	2200      	movs	r2, #0
 8025694:	210c      	movs	r1, #12
 8025696:	200a      	movs	r0, #10
 8025698:	f7fe fdcb 	bl	8024232 <xQueueGenericCreate>
 802569c:	4b03      	ldr	r3, [pc, #12]	; (80256ac <prvCheckForValidListAndQueue+0x44>)
 802569e:	6018      	str	r0, [r3, #0]
				if( xTimerQueue != NULL )
 80256a0:	2800      	cmp	r0, #0
 80256a2:	d0e7      	beq.n	8025674 <prvCheckForValidListAndQueue+0xc>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80256a4:	4906      	ldr	r1, [pc, #24]	; (80256c0 <prvCheckForValidListAndQueue+0x58>)
 80256a6:	f7ff f979 	bl	802499c <vQueueAddToRegistry>
 80256aa:	e7e3      	b.n	8025674 <prvCheckForValidListAndQueue+0xc>
 80256ac:	20011d94 	.word	0x20011d94
 80256b0:	20011d68 	.word	0x20011d68
 80256b4:	20011d7c 	.word	0x20011d7c
 80256b8:	20011d60 	.word	0x20011d60
 80256bc:	20011d64 	.word	0x20011d64
 80256c0:	0803640c 	.word	0x0803640c

080256c4 <prvInitialiseNewTimer>:
{
 80256c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80256c8:	9f07      	ldr	r7, [sp, #28]
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 80256ca:	b941      	cbnz	r1, 80256de <prvInitialiseNewTimer+0x1a>
 80256cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80256d0:	f383 8811 	msr	BASEPRI, r3
 80256d4:	f3bf 8f6f 	isb	sy
 80256d8:	f3bf 8f4f 	dsb	sy
 80256dc:	e7fe      	b.n	80256dc <prvInitialiseNewTimer+0x18>
 80256de:	4606      	mov	r6, r0
 80256e0:	4614      	mov	r4, r2
 80256e2:	461d      	mov	r5, r3
 80256e4:	4688      	mov	r8, r1
	if( pxNewTimer != NULL )
 80256e6:	b18f      	cbz	r7, 802570c <prvInitialiseNewTimer+0x48>
		prvCheckForValidListAndQueue();
 80256e8:	f7ff ffbe 	bl	8025668 <prvCheckForValidListAndQueue>
		pxNewTimer->pcTimerName = pcTimerName;
 80256ec:	603e      	str	r6, [r7, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 80256ee:	f8c7 8018 	str.w	r8, [r7, #24]
		pxNewTimer->pvTimerID = pvTimerID;
 80256f2:	61fd      	str	r5, [r7, #28]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 80256f4:	9b06      	ldr	r3, [sp, #24]
 80256f6:	623b      	str	r3, [r7, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 80256f8:	1d38      	adds	r0, r7, #4
 80256fa:	f7fe faa6 	bl	8023c4a <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 80256fe:	b12c      	cbz	r4, 802570c <prvInitialiseNewTimer+0x48>
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8025700:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8025704:	f043 0304 	orr.w	r3, r3, #4
 8025708:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
}
 802570c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08025710 <xTimerCreateTimerTask>:
{
 8025710:	b500      	push	{lr}
 8025712:	b083      	sub	sp, #12
	prvCheckForValidListAndQueue();
 8025714:	f7ff ffa8 	bl	8025668 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8025718:	4b0d      	ldr	r3, [pc, #52]	; (8025750 <xTimerCreateTimerTask+0x40>)
 802571a:	681b      	ldr	r3, [r3, #0]
 802571c:	b15b      	cbz	r3, 8025736 <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(	prvTimerTask,
 802571e:	4b0d      	ldr	r3, [pc, #52]	; (8025754 <xTimerCreateTimerTask+0x44>)
 8025720:	9301      	str	r3, [sp, #4]
 8025722:	2302      	movs	r3, #2
 8025724:	9300      	str	r3, [sp, #0]
 8025726:	2300      	movs	r3, #0
 8025728:	f44f 7280 	mov.w	r2, #256	; 0x100
 802572c:	490a      	ldr	r1, [pc, #40]	; (8025758 <xTimerCreateTimerTask+0x48>)
 802572e:	480b      	ldr	r0, [pc, #44]	; (802575c <xTimerCreateTimerTask+0x4c>)
 8025730:	f7ff faf2 	bl	8024d18 <xTaskCreate>
	configASSERT( xReturn );
 8025734:	b940      	cbnz	r0, 8025748 <xTimerCreateTimerTask+0x38>
 8025736:	f04f 0350 	mov.w	r3, #80	; 0x50
 802573a:	f383 8811 	msr	BASEPRI, r3
 802573e:	f3bf 8f6f 	isb	sy
 8025742:	f3bf 8f4f 	dsb	sy
 8025746:	e7fe      	b.n	8025746 <xTimerCreateTimerTask+0x36>
}
 8025748:	b003      	add	sp, #12
 802574a:	f85d fb04 	ldr.w	pc, [sp], #4
 802574e:	bf00      	nop
 8025750:	20011d94 	.word	0x20011d94
 8025754:	20011d98 	.word	0x20011d98
 8025758:	08036414 	.word	0x08036414
 802575c:	08025a89 	.word	0x08025a89

08025760 <xTimerCreate>:
	{
 8025760:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8025764:	b082      	sub	sp, #8
 8025766:	4604      	mov	r4, r0
 8025768:	4688      	mov	r8, r1
 802576a:	4617      	mov	r7, r2
 802576c:	461d      	mov	r5, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 802576e:	202c      	movs	r0, #44	; 0x2c
 8025770:	f7fe f9b0 	bl	8023ad4 <pvPortMalloc>
		if( pxNewTimer != NULL )
 8025774:	4606      	mov	r6, r0
 8025776:	b158      	cbz	r0, 8025790 <xTimerCreate+0x30>
			pxNewTimer->ucStatus = 0x00;
 8025778:	2300      	movs	r3, #0
 802577a:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 802577e:	9001      	str	r0, [sp, #4]
 8025780:	9b08      	ldr	r3, [sp, #32]
 8025782:	9300      	str	r3, [sp, #0]
 8025784:	462b      	mov	r3, r5
 8025786:	463a      	mov	r2, r7
 8025788:	4641      	mov	r1, r8
 802578a:	4620      	mov	r0, r4
 802578c:	f7ff ff9a 	bl	80256c4 <prvInitialiseNewTimer>
	}
 8025790:	4630      	mov	r0, r6
 8025792:	b002      	add	sp, #8
 8025794:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08025798 <xTimerGenericCommand>:
	configASSERT( xTimer );
 8025798:	b1b8      	cbz	r0, 80257ca <xTimerGenericCommand+0x32>
 802579a:	469c      	mov	ip, r3
 802579c:	4603      	mov	r3, r0
	if( xTimerQueue != NULL )
 802579e:	4818      	ldr	r0, [pc, #96]	; (8025800 <xTimerGenericCommand+0x68>)
 80257a0:	6800      	ldr	r0, [r0, #0]
 80257a2:	b358      	cbz	r0, 80257fc <xTimerGenericCommand+0x64>
{
 80257a4:	b500      	push	{lr}
 80257a6:	b085      	sub	sp, #20
		xMessage.xMessageID = xCommandID;
 80257a8:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80257aa:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 80257ac:	9303      	str	r3, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 80257ae:	2905      	cmp	r1, #5
 80257b0:	dc1c      	bgt.n	80257ec <xTimerGenericCommand+0x54>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80257b2:	f7ff fdf3 	bl	802539c <xTaskGetSchedulerState>
 80257b6:	2802      	cmp	r0, #2
 80257b8:	d010      	beq.n	80257dc <xTimerGenericCommand+0x44>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80257ba:	2300      	movs	r3, #0
 80257bc:	461a      	mov	r2, r3
 80257be:	a901      	add	r1, sp, #4
 80257c0:	480f      	ldr	r0, [pc, #60]	; (8025800 <xTimerGenericCommand+0x68>)
 80257c2:	6800      	ldr	r0, [r0, #0]
 80257c4:	f7fe fd77 	bl	80242b6 <xQueueGenericSend>
 80257c8:	e015      	b.n	80257f6 <xTimerGenericCommand+0x5e>
 80257ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80257ce:	f383 8811 	msr	BASEPRI, r3
 80257d2:	f3bf 8f6f 	isb	sy
 80257d6:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 80257da:	e7fe      	b.n	80257da <xTimerGenericCommand+0x42>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80257dc:	2300      	movs	r3, #0
 80257de:	9a06      	ldr	r2, [sp, #24]
 80257e0:	a901      	add	r1, sp, #4
 80257e2:	4807      	ldr	r0, [pc, #28]	; (8025800 <xTimerGenericCommand+0x68>)
 80257e4:	6800      	ldr	r0, [r0, #0]
 80257e6:	f7fe fd66 	bl	80242b6 <xQueueGenericSend>
 80257ea:	e004      	b.n	80257f6 <xTimerGenericCommand+0x5e>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80257ec:	2300      	movs	r3, #0
 80257ee:	4662      	mov	r2, ip
 80257f0:	a901      	add	r1, sp, #4
 80257f2:	f7fe fe3b 	bl	802446c <xQueueGenericSendFromISR>
}
 80257f6:	b005      	add	sp, #20
 80257f8:	f85d fb04 	ldr.w	pc, [sp], #4
BaseType_t xReturn = pdFAIL;
 80257fc:	2000      	movs	r0, #0
}
 80257fe:	4770      	bx	lr
 8025800:	20011d94 	.word	0x20011d94

08025804 <prvSwitchTimerLists>:
{
 8025804:	b570      	push	{r4, r5, r6, lr}
 8025806:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8025808:	4b1b      	ldr	r3, [pc, #108]	; (8025878 <prvSwitchTimerLists+0x74>)
 802580a:	681b      	ldr	r3, [r3, #0]
 802580c:	681a      	ldr	r2, [r3, #0]
 802580e:	b362      	cbz	r2, 802586a <prvSwitchTimerLists+0x66>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8025810:	68db      	ldr	r3, [r3, #12]
 8025812:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025814:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8025816:	1d25      	adds	r5, r4, #4
 8025818:	4628      	mov	r0, r5
 802581a:	f7fe fa3d 	bl	8023c98 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 802581e:	6a23      	ldr	r3, [r4, #32]
 8025820:	4620      	mov	r0, r4
 8025822:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8025824:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8025828:	f013 0f04 	tst.w	r3, #4
 802582c:	d0ec      	beq.n	8025808 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 802582e:	69a3      	ldr	r3, [r4, #24]
 8025830:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 8025832:	429e      	cmp	r6, r3
 8025834:	d207      	bcs.n	8025846 <prvSwitchTimerLists+0x42>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8025836:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8025838:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 802583a:	4629      	mov	r1, r5
 802583c:	4b0e      	ldr	r3, [pc, #56]	; (8025878 <prvSwitchTimerLists+0x74>)
 802583e:	6818      	ldr	r0, [r3, #0]
 8025840:	f7fe fa11 	bl	8023c66 <vListInsert>
 8025844:	e7e0      	b.n	8025808 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8025846:	2100      	movs	r1, #0
 8025848:	9100      	str	r1, [sp, #0]
 802584a:	460b      	mov	r3, r1
 802584c:	4632      	mov	r2, r6
 802584e:	4620      	mov	r0, r4
 8025850:	f7ff ffa2 	bl	8025798 <xTimerGenericCommand>
				configASSERT( xResult );
 8025854:	2800      	cmp	r0, #0
 8025856:	d1d7      	bne.n	8025808 <prvSwitchTimerLists+0x4>
 8025858:	f04f 0350 	mov.w	r3, #80	; 0x50
 802585c:	f383 8811 	msr	BASEPRI, r3
 8025860:	f3bf 8f6f 	isb	sy
 8025864:	f3bf 8f4f 	dsb	sy
 8025868:	e7fe      	b.n	8025868 <prvSwitchTimerLists+0x64>
	pxCurrentTimerList = pxOverflowTimerList;
 802586a:	4a04      	ldr	r2, [pc, #16]	; (802587c <prvSwitchTimerLists+0x78>)
 802586c:	6810      	ldr	r0, [r2, #0]
 802586e:	4902      	ldr	r1, [pc, #8]	; (8025878 <prvSwitchTimerLists+0x74>)
 8025870:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
 8025872:	6013      	str	r3, [r2, #0]
}
 8025874:	b002      	add	sp, #8
 8025876:	bd70      	pop	{r4, r5, r6, pc}
 8025878:	20011d60 	.word	0x20011d60
 802587c:	20011d64 	.word	0x20011d64

08025880 <prvSampleTimeNow>:
{
 8025880:	b538      	push	{r3, r4, r5, lr}
 8025882:	4605      	mov	r5, r0
	xTimeNow = xTaskGetTickCount();
 8025884:	f7ff fb34 	bl	8024ef0 <xTaskGetTickCount>
 8025888:	4604      	mov	r4, r0
	if( xTimeNow < xLastTime )
 802588a:	4b07      	ldr	r3, [pc, #28]	; (80258a8 <prvSampleTimeNow+0x28>)
 802588c:	681b      	ldr	r3, [r3, #0]
 802588e:	4283      	cmp	r3, r0
 8025890:	d805      	bhi.n	802589e <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
 8025892:	2300      	movs	r3, #0
 8025894:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
 8025896:	4b04      	ldr	r3, [pc, #16]	; (80258a8 <prvSampleTimeNow+0x28>)
 8025898:	601c      	str	r4, [r3, #0]
}
 802589a:	4620      	mov	r0, r4
 802589c:	bd38      	pop	{r3, r4, r5, pc}
		prvSwitchTimerLists();
 802589e:	f7ff ffb1 	bl	8025804 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 80258a2:	2301      	movs	r3, #1
 80258a4:	602b      	str	r3, [r5, #0]
 80258a6:	e7f6      	b.n	8025896 <prvSampleTimeNow+0x16>
 80258a8:	20011d90 	.word	0x20011d90

080258ac <prvProcessExpiredTimer>:
{
 80258ac:	b570      	push	{r4, r5, r6, lr}
 80258ae:	b082      	sub	sp, #8
 80258b0:	4606      	mov	r6, r0
 80258b2:	460d      	mov	r5, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80258b4:	4917      	ldr	r1, [pc, #92]	; (8025914 <prvProcessExpiredTimer+0x68>)
 80258b6:	6809      	ldr	r1, [r1, #0]
 80258b8:	68c9      	ldr	r1, [r1, #12]
 80258ba:	68cc      	ldr	r4, [r1, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80258bc:	1d20      	adds	r0, r4, #4
 80258be:	f7fe f9eb 	bl	8023c98 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80258c2:	f894 c028 	ldrb.w	ip, [r4, #40]	; 0x28
 80258c6:	f01c 0f04 	tst.w	ip, #4
 80258ca:	d108      	bne.n	80258de <prvProcessExpiredTimer+0x32>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80258cc:	f02c 0c01 	bic.w	ip, ip, #1
 80258d0:	f884 c028 	strb.w	ip, [r4, #40]	; 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80258d4:	6a23      	ldr	r3, [r4, #32]
 80258d6:	4620      	mov	r0, r4
 80258d8:	4798      	blx	r3
}
 80258da:	b002      	add	sp, #8
 80258dc:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 80258de:	69a1      	ldr	r1, [r4, #24]
 80258e0:	4633      	mov	r3, r6
 80258e2:	462a      	mov	r2, r5
 80258e4:	4431      	add	r1, r6
 80258e6:	4620      	mov	r0, r4
 80258e8:	f7ff fe9a 	bl	8025620 <prvInsertTimerInActiveList>
 80258ec:	2800      	cmp	r0, #0
 80258ee:	d0f1      	beq.n	80258d4 <prvProcessExpiredTimer+0x28>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80258f0:	2100      	movs	r1, #0
 80258f2:	9100      	str	r1, [sp, #0]
 80258f4:	460b      	mov	r3, r1
 80258f6:	4632      	mov	r2, r6
 80258f8:	4620      	mov	r0, r4
 80258fa:	f7ff ff4d 	bl	8025798 <xTimerGenericCommand>
			configASSERT( xResult );
 80258fe:	2800      	cmp	r0, #0
 8025900:	d1e8      	bne.n	80258d4 <prvProcessExpiredTimer+0x28>
 8025902:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025906:	f383 8811 	msr	BASEPRI, r3
 802590a:	f3bf 8f6f 	isb	sy
 802590e:	f3bf 8f4f 	dsb	sy
 8025912:	e7fe      	b.n	8025912 <prvProcessExpiredTimer+0x66>
 8025914:	20011d60 	.word	0x20011d60

08025918 <prvProcessTimerOrBlockTask>:
{
 8025918:	b570      	push	{r4, r5, r6, lr}
 802591a:	b082      	sub	sp, #8
 802591c:	4606      	mov	r6, r0
 802591e:	460c      	mov	r4, r1
	vTaskSuspendAll();
 8025920:	f7ff fade 	bl	8024ee0 <vTaskSuspendAll>
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8025924:	a801      	add	r0, sp, #4
 8025926:	f7ff ffab 	bl	8025880 <prvSampleTimeNow>
		if( xTimerListsWereSwitched == pdFALSE )
 802592a:	9b01      	ldr	r3, [sp, #4]
 802592c:	bb33      	cbnz	r3, 802597c <prvProcessTimerOrBlockTask+0x64>
 802592e:	4605      	mov	r5, r0
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8025930:	b90c      	cbnz	r4, 8025936 <prvProcessTimerOrBlockTask+0x1e>
 8025932:	42b0      	cmp	r0, r6
 8025934:	d219      	bcs.n	802596a <prvProcessTimerOrBlockTask+0x52>
				if( xListWasEmpty != pdFALSE )
 8025936:	b124      	cbz	r4, 8025942 <prvProcessTimerOrBlockTask+0x2a>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8025938:	4a12      	ldr	r2, [pc, #72]	; (8025984 <prvProcessTimerOrBlockTask+0x6c>)
 802593a:	6812      	ldr	r2, [r2, #0]
 802593c:	6812      	ldr	r2, [r2, #0]
 802593e:	b9da      	cbnz	r2, 8025978 <prvProcessTimerOrBlockTask+0x60>
 8025940:	2401      	movs	r4, #1
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8025942:	4622      	mov	r2, r4
 8025944:	1b71      	subs	r1, r6, r5
 8025946:	4b10      	ldr	r3, [pc, #64]	; (8025988 <prvProcessTimerOrBlockTask+0x70>)
 8025948:	6818      	ldr	r0, [r3, #0]
 802594a:	f7ff f83b 	bl	80249c4 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 802594e:	f7ff fb69 	bl	8025024 <xTaskResumeAll>
 8025952:	b9a8      	cbnz	r0, 8025980 <prvProcessTimerOrBlockTask+0x68>
					portYIELD_WITHIN_API();
 8025954:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8025958:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802595c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8025960:	f3bf 8f4f 	dsb	sy
 8025964:	f3bf 8f6f 	isb	sy
 8025968:	e00a      	b.n	8025980 <prvProcessTimerOrBlockTask+0x68>
				( void ) xTaskResumeAll();
 802596a:	f7ff fb5b 	bl	8025024 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 802596e:	4629      	mov	r1, r5
 8025970:	4630      	mov	r0, r6
 8025972:	f7ff ff9b 	bl	80258ac <prvProcessExpiredTimer>
 8025976:	e003      	b.n	8025980 <prvProcessTimerOrBlockTask+0x68>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8025978:	461c      	mov	r4, r3
 802597a:	e7e2      	b.n	8025942 <prvProcessTimerOrBlockTask+0x2a>
			( void ) xTaskResumeAll();
 802597c:	f7ff fb52 	bl	8025024 <xTaskResumeAll>
}
 8025980:	b002      	add	sp, #8
 8025982:	bd70      	pop	{r4, r5, r6, pc}
 8025984:	20011d64 	.word	0x20011d64
 8025988:	20011d94 	.word	0x20011d94

0802598c <prvProcessReceivedCommands>:
{
 802598c:	b510      	push	{r4, lr}
 802598e:	b086      	sub	sp, #24
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8025990:	2200      	movs	r2, #0
 8025992:	a903      	add	r1, sp, #12
 8025994:	4b3b      	ldr	r3, [pc, #236]	; (8025a84 <prvProcessReceivedCommands+0xf8>)
 8025996:	6818      	ldr	r0, [r3, #0]
 8025998:	f7fe fe27 	bl	80245ea <xQueueReceive>
 802599c:	2800      	cmp	r0, #0
 802599e:	d06e      	beq.n	8025a7e <prvProcessReceivedCommands+0xf2>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 80259a0:	9b03      	ldr	r3, [sp, #12]
 80259a2:	2b00      	cmp	r3, #0
 80259a4:	dbf4      	blt.n	8025990 <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 80259a6:	9c05      	ldr	r4, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 80259a8:	6963      	ldr	r3, [r4, #20]
 80259aa:	b113      	cbz	r3, 80259b2 <prvProcessReceivedCommands+0x26>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80259ac:	1d20      	adds	r0, r4, #4
 80259ae:	f7fe f973 	bl	8023c98 <uxListRemove>
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80259b2:	a802      	add	r0, sp, #8
 80259b4:	f7ff ff64 	bl	8025880 <prvSampleTimeNow>
			switch( xMessage.xMessageID )
 80259b8:	9b03      	ldr	r3, [sp, #12]
 80259ba:	2b09      	cmp	r3, #9
 80259bc:	d8e8      	bhi.n	8025990 <prvProcessReceivedCommands+0x4>
 80259be:	e8df f003 	tbb	[pc, r3]
 80259c2:	0505      	.short	0x0505
 80259c4:	50373005 	.word	0x50373005
 80259c8:	37300505 	.word	0x37300505
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80259cc:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80259d0:	f043 0301 	orr.w	r3, r3, #1
 80259d4:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 80259d8:	9b04      	ldr	r3, [sp, #16]
 80259da:	69a1      	ldr	r1, [r4, #24]
 80259dc:	4602      	mov	r2, r0
 80259de:	4419      	add	r1, r3
 80259e0:	4620      	mov	r0, r4
 80259e2:	f7ff fe1d 	bl	8025620 <prvInsertTimerInActiveList>
 80259e6:	2800      	cmp	r0, #0
 80259e8:	d0d2      	beq.n	8025990 <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80259ea:	6a23      	ldr	r3, [r4, #32]
 80259ec:	4620      	mov	r0, r4
 80259ee:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80259f0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80259f4:	f013 0f04 	tst.w	r3, #4
 80259f8:	d0ca      	beq.n	8025990 <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 80259fa:	69a2      	ldr	r2, [r4, #24]
 80259fc:	2100      	movs	r1, #0
 80259fe:	9100      	str	r1, [sp, #0]
 8025a00:	460b      	mov	r3, r1
 8025a02:	9804      	ldr	r0, [sp, #16]
 8025a04:	4402      	add	r2, r0
 8025a06:	4620      	mov	r0, r4
 8025a08:	f7ff fec6 	bl	8025798 <xTimerGenericCommand>
							configASSERT( xResult );
 8025a0c:	2800      	cmp	r0, #0
 8025a0e:	d1bf      	bne.n	8025990 <prvProcessReceivedCommands+0x4>
 8025a10:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025a14:	f383 8811 	msr	BASEPRI, r3
 8025a18:	f3bf 8f6f 	isb	sy
 8025a1c:	f3bf 8f4f 	dsb	sy
 8025a20:	e7fe      	b.n	8025a20 <prvProcessReceivedCommands+0x94>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8025a22:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8025a26:	f023 0301 	bic.w	r3, r3, #1
 8025a2a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					break;
 8025a2e:	e7af      	b.n	8025990 <prvProcessReceivedCommands+0x4>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8025a30:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8025a34:	f043 0301 	orr.w	r3, r3, #1
 8025a38:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8025a3c:	9904      	ldr	r1, [sp, #16]
 8025a3e:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8025a40:	b131      	cbz	r1, 8025a50 <prvProcessReceivedCommands+0xc4>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8025a42:	4603      	mov	r3, r0
 8025a44:	4602      	mov	r2, r0
 8025a46:	4401      	add	r1, r0
 8025a48:	4620      	mov	r0, r4
 8025a4a:	f7ff fde9 	bl	8025620 <prvInsertTimerInActiveList>
					break;
 8025a4e:	e79f      	b.n	8025990 <prvProcessReceivedCommands+0x4>
 8025a50:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025a54:	f383 8811 	msr	BASEPRI, r3
 8025a58:	f3bf 8f6f 	isb	sy
 8025a5c:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8025a60:	e7fe      	b.n	8025a60 <prvProcessReceivedCommands+0xd4>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8025a62:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8025a66:	f013 0f02 	tst.w	r3, #2
 8025a6a:	d004      	beq.n	8025a76 <prvProcessReceivedCommands+0xea>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8025a6c:	f023 0301 	bic.w	r3, r3, #1
 8025a70:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
 8025a74:	e78c      	b.n	8025990 <prvProcessReceivedCommands+0x4>
							vPortFree( pxTimer );
 8025a76:	4620      	mov	r0, r4
 8025a78:	f7fe f8a4 	bl	8023bc4 <vPortFree>
 8025a7c:	e788      	b.n	8025990 <prvProcessReceivedCommands+0x4>
}
 8025a7e:	b006      	add	sp, #24
 8025a80:	bd10      	pop	{r4, pc}
 8025a82:	bf00      	nop
 8025a84:	20011d94 	.word	0x20011d94

08025a88 <prvTimerTask>:
{
 8025a88:	b500      	push	{lr}
 8025a8a:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8025a8c:	a801      	add	r0, sp, #4
 8025a8e:	f7ff fdb7 	bl	8025600 <prvGetNextExpireTime>
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 8025a92:	9901      	ldr	r1, [sp, #4]
 8025a94:	f7ff ff40 	bl	8025918 <prvProcessTimerOrBlockTask>
		prvProcessReceivedCommands();
 8025a98:	f7ff ff78 	bl	802598c <prvProcessReceivedCommands>
	for( ;; )
 8025a9c:	e7f6      	b.n	8025a8c <prvTimerTask+0x4>
	...

08025aa0 <srand>:
 8025aa0:	4b03      	ldr	r3, [pc, #12]	; (8025ab0 <srand+0x10>)
 8025aa2:	681b      	ldr	r3, [r3, #0]
 8025aa4:	2200      	movs	r2, #0
 8025aa6:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
 8025aaa:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 8025aae:	4770      	bx	lr
 8025ab0:	20000380 	.word	0x20000380

08025ab4 <rand>:
 8025ab4:	4b0a      	ldr	r3, [pc, #40]	; (8025ae0 <rand+0x2c>)
 8025ab6:	480b      	ldr	r0, [pc, #44]	; (8025ae4 <rand+0x30>)
 8025ab8:	6819      	ldr	r1, [r3, #0]
 8025aba:	4a0b      	ldr	r2, [pc, #44]	; (8025ae8 <rand+0x34>)
 8025abc:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
 8025ac0:	b510      	push	{r4, lr}
 8025ac2:	f8d1 409c 	ldr.w	r4, [r1, #156]	; 0x9c
 8025ac6:	4358      	muls	r0, r3
 8025ac8:	fb02 0004 	mla	r0, r2, r4, r0
 8025acc:	fba3 3202 	umull	r3, r2, r3, r2
 8025ad0:	3301      	adds	r3, #1
 8025ad2:	eb40 0002 	adc.w	r0, r0, r2
 8025ad6:	e9c1 3026 	strd	r3, r0, [r1, #152]	; 0x98
 8025ada:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8025ade:	bd10      	pop	{r4, pc}
 8025ae0:	20000380 	.word	0x20000380
 8025ae4:	5851f42d 	.word	0x5851f42d
 8025ae8:	4c957f2d 	.word	0x4c957f2d

08025aec <std>:
 8025aec:	2300      	movs	r3, #0
 8025aee:	b510      	push	{r4, lr}
 8025af0:	4604      	mov	r4, r0
 8025af2:	e9c0 3300 	strd	r3, r3, [r0]
 8025af6:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8025afa:	6083      	str	r3, [r0, #8]
 8025afc:	8181      	strh	r1, [r0, #12]
 8025afe:	6643      	str	r3, [r0, #100]	; 0x64
 8025b00:	81c2      	strh	r2, [r0, #14]
 8025b02:	6183      	str	r3, [r0, #24]
 8025b04:	4619      	mov	r1, r3
 8025b06:	2208      	movs	r2, #8
 8025b08:	305c      	adds	r0, #92	; 0x5c
 8025b0a:	f000 f924 	bl	8025d56 <memset>
 8025b0e:	4b0d      	ldr	r3, [pc, #52]	; (8025b44 <std+0x58>)
 8025b10:	6223      	str	r3, [r4, #32]
 8025b12:	4b0d      	ldr	r3, [pc, #52]	; (8025b48 <std+0x5c>)
 8025b14:	6263      	str	r3, [r4, #36]	; 0x24
 8025b16:	4b0d      	ldr	r3, [pc, #52]	; (8025b4c <std+0x60>)
 8025b18:	62a3      	str	r3, [r4, #40]	; 0x28
 8025b1a:	4b0d      	ldr	r3, [pc, #52]	; (8025b50 <std+0x64>)
 8025b1c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8025b1e:	4b0d      	ldr	r3, [pc, #52]	; (8025b54 <std+0x68>)
 8025b20:	61e4      	str	r4, [r4, #28]
 8025b22:	429c      	cmp	r4, r3
 8025b24:	d006      	beq.n	8025b34 <std+0x48>
 8025b26:	f103 0268 	add.w	r2, r3, #104	; 0x68
 8025b2a:	4294      	cmp	r4, r2
 8025b2c:	d002      	beq.n	8025b34 <std+0x48>
 8025b2e:	33d0      	adds	r3, #208	; 0xd0
 8025b30:	429c      	cmp	r4, r3
 8025b32:	d105      	bne.n	8025b40 <std+0x54>
 8025b34:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8025b38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8025b3c:	f000 b9dc 	b.w	8025ef8 <__retarget_lock_init_recursive>
 8025b40:	bd10      	pop	{r4, pc}
 8025b42:	bf00      	nop
 8025b44:	08025cb1 	.word	0x08025cb1
 8025b48:	08025cd3 	.word	0x08025cd3
 8025b4c:	08025d0b 	.word	0x08025d0b
 8025b50:	08025d2f 	.word	0x08025d2f
 8025b54:	20011d9c 	.word	0x20011d9c

08025b58 <stdio_exit_handler>:
 8025b58:	4a02      	ldr	r2, [pc, #8]	; (8025b64 <stdio_exit_handler+0xc>)
 8025b5a:	4903      	ldr	r1, [pc, #12]	; (8025b68 <stdio_exit_handler+0x10>)
 8025b5c:	4803      	ldr	r0, [pc, #12]	; (8025b6c <stdio_exit_handler+0x14>)
 8025b5e:	f000 b869 	b.w	8025c34 <_fwalk_sglue>
 8025b62:	bf00      	nop
 8025b64:	20000250 	.word	0x20000250
 8025b68:	080279dd 	.word	0x080279dd
 8025b6c:	20000260 	.word	0x20000260

08025b70 <cleanup_stdio>:
 8025b70:	6841      	ldr	r1, [r0, #4]
 8025b72:	4b0c      	ldr	r3, [pc, #48]	; (8025ba4 <cleanup_stdio+0x34>)
 8025b74:	4299      	cmp	r1, r3
 8025b76:	b510      	push	{r4, lr}
 8025b78:	4604      	mov	r4, r0
 8025b7a:	d001      	beq.n	8025b80 <cleanup_stdio+0x10>
 8025b7c:	f001 ff2e 	bl	80279dc <_fclose_r>
 8025b80:	68a1      	ldr	r1, [r4, #8]
 8025b82:	4b09      	ldr	r3, [pc, #36]	; (8025ba8 <cleanup_stdio+0x38>)
 8025b84:	4299      	cmp	r1, r3
 8025b86:	d002      	beq.n	8025b8e <cleanup_stdio+0x1e>
 8025b88:	4620      	mov	r0, r4
 8025b8a:	f001 ff27 	bl	80279dc <_fclose_r>
 8025b8e:	68e1      	ldr	r1, [r4, #12]
 8025b90:	4b06      	ldr	r3, [pc, #24]	; (8025bac <cleanup_stdio+0x3c>)
 8025b92:	4299      	cmp	r1, r3
 8025b94:	d004      	beq.n	8025ba0 <cleanup_stdio+0x30>
 8025b96:	4620      	mov	r0, r4
 8025b98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8025b9c:	f001 bf1e 	b.w	80279dc <_fclose_r>
 8025ba0:	bd10      	pop	{r4, pc}
 8025ba2:	bf00      	nop
 8025ba4:	20011d9c 	.word	0x20011d9c
 8025ba8:	20011e04 	.word	0x20011e04
 8025bac:	20011e6c 	.word	0x20011e6c

08025bb0 <global_stdio_init.part.0>:
 8025bb0:	b510      	push	{r4, lr}
 8025bb2:	4b0b      	ldr	r3, [pc, #44]	; (8025be0 <global_stdio_init.part.0+0x30>)
 8025bb4:	4c0b      	ldr	r4, [pc, #44]	; (8025be4 <global_stdio_init.part.0+0x34>)
 8025bb6:	4a0c      	ldr	r2, [pc, #48]	; (8025be8 <global_stdio_init.part.0+0x38>)
 8025bb8:	601a      	str	r2, [r3, #0]
 8025bba:	4620      	mov	r0, r4
 8025bbc:	2200      	movs	r2, #0
 8025bbe:	2104      	movs	r1, #4
 8025bc0:	f7ff ff94 	bl	8025aec <std>
 8025bc4:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8025bc8:	2201      	movs	r2, #1
 8025bca:	2109      	movs	r1, #9
 8025bcc:	f7ff ff8e 	bl	8025aec <std>
 8025bd0:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8025bd4:	2202      	movs	r2, #2
 8025bd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8025bda:	2112      	movs	r1, #18
 8025bdc:	f7ff bf86 	b.w	8025aec <std>
 8025be0:	20011ed4 	.word	0x20011ed4
 8025be4:	20011d9c 	.word	0x20011d9c
 8025be8:	08025b59 	.word	0x08025b59

08025bec <__sfp_lock_acquire>:
 8025bec:	4801      	ldr	r0, [pc, #4]	; (8025bf4 <__sfp_lock_acquire+0x8>)
 8025bee:	f000 b985 	b.w	8025efc <__retarget_lock_acquire_recursive>
 8025bf2:	bf00      	nop
 8025bf4:	20011ede 	.word	0x20011ede

08025bf8 <__sfp_lock_release>:
 8025bf8:	4801      	ldr	r0, [pc, #4]	; (8025c00 <__sfp_lock_release+0x8>)
 8025bfa:	f000 b980 	b.w	8025efe <__retarget_lock_release_recursive>
 8025bfe:	bf00      	nop
 8025c00:	20011ede 	.word	0x20011ede

08025c04 <__sinit>:
 8025c04:	b510      	push	{r4, lr}
 8025c06:	4604      	mov	r4, r0
 8025c08:	f7ff fff0 	bl	8025bec <__sfp_lock_acquire>
 8025c0c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8025c0e:	b11b      	cbz	r3, 8025c18 <__sinit+0x14>
 8025c10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8025c14:	f7ff bff0 	b.w	8025bf8 <__sfp_lock_release>
 8025c18:	4b04      	ldr	r3, [pc, #16]	; (8025c2c <__sinit+0x28>)
 8025c1a:	6363      	str	r3, [r4, #52]	; 0x34
 8025c1c:	4b04      	ldr	r3, [pc, #16]	; (8025c30 <__sinit+0x2c>)
 8025c1e:	681b      	ldr	r3, [r3, #0]
 8025c20:	2b00      	cmp	r3, #0
 8025c22:	d1f5      	bne.n	8025c10 <__sinit+0xc>
 8025c24:	f7ff ffc4 	bl	8025bb0 <global_stdio_init.part.0>
 8025c28:	e7f2      	b.n	8025c10 <__sinit+0xc>
 8025c2a:	bf00      	nop
 8025c2c:	08025b71 	.word	0x08025b71
 8025c30:	20011ed4 	.word	0x20011ed4

08025c34 <_fwalk_sglue>:
 8025c34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8025c38:	4607      	mov	r7, r0
 8025c3a:	4688      	mov	r8, r1
 8025c3c:	4614      	mov	r4, r2
 8025c3e:	2600      	movs	r6, #0
 8025c40:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8025c44:	f1b9 0901 	subs.w	r9, r9, #1
 8025c48:	d505      	bpl.n	8025c56 <_fwalk_sglue+0x22>
 8025c4a:	6824      	ldr	r4, [r4, #0]
 8025c4c:	2c00      	cmp	r4, #0
 8025c4e:	d1f7      	bne.n	8025c40 <_fwalk_sglue+0xc>
 8025c50:	4630      	mov	r0, r6
 8025c52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025c56:	89ab      	ldrh	r3, [r5, #12]
 8025c58:	2b01      	cmp	r3, #1
 8025c5a:	d907      	bls.n	8025c6c <_fwalk_sglue+0x38>
 8025c5c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8025c60:	3301      	adds	r3, #1
 8025c62:	d003      	beq.n	8025c6c <_fwalk_sglue+0x38>
 8025c64:	4629      	mov	r1, r5
 8025c66:	4638      	mov	r0, r7
 8025c68:	47c0      	blx	r8
 8025c6a:	4306      	orrs	r6, r0
 8025c6c:	3568      	adds	r5, #104	; 0x68
 8025c6e:	e7e9      	b.n	8025c44 <_fwalk_sglue+0x10>

08025c70 <sprintf>:
 8025c70:	b40e      	push	{r1, r2, r3}
 8025c72:	b500      	push	{lr}
 8025c74:	b09c      	sub	sp, #112	; 0x70
 8025c76:	ab1d      	add	r3, sp, #116	; 0x74
 8025c78:	9002      	str	r0, [sp, #8]
 8025c7a:	9006      	str	r0, [sp, #24]
 8025c7c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8025c80:	4809      	ldr	r0, [pc, #36]	; (8025ca8 <sprintf+0x38>)
 8025c82:	9107      	str	r1, [sp, #28]
 8025c84:	9104      	str	r1, [sp, #16]
 8025c86:	4909      	ldr	r1, [pc, #36]	; (8025cac <sprintf+0x3c>)
 8025c88:	f853 2b04 	ldr.w	r2, [r3], #4
 8025c8c:	9105      	str	r1, [sp, #20]
 8025c8e:	6800      	ldr	r0, [r0, #0]
 8025c90:	9301      	str	r3, [sp, #4]
 8025c92:	a902      	add	r1, sp, #8
 8025c94:	f000 fcb4 	bl	8026600 <_svfprintf_r>
 8025c98:	9b02      	ldr	r3, [sp, #8]
 8025c9a:	2200      	movs	r2, #0
 8025c9c:	701a      	strb	r2, [r3, #0]
 8025c9e:	b01c      	add	sp, #112	; 0x70
 8025ca0:	f85d eb04 	ldr.w	lr, [sp], #4
 8025ca4:	b003      	add	sp, #12
 8025ca6:	4770      	bx	lr
 8025ca8:	20000380 	.word	0x20000380
 8025cac:	ffff0208 	.word	0xffff0208

08025cb0 <__sread>:
 8025cb0:	b510      	push	{r4, lr}
 8025cb2:	460c      	mov	r4, r1
 8025cb4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8025cb8:	f000 f8d0 	bl	8025e5c <_read_r>
 8025cbc:	2800      	cmp	r0, #0
 8025cbe:	bfab      	itete	ge
 8025cc0:	6d23      	ldrge	r3, [r4, #80]	; 0x50
 8025cc2:	89a3      	ldrhlt	r3, [r4, #12]
 8025cc4:	181b      	addge	r3, r3, r0
 8025cc6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8025cca:	bfac      	ite	ge
 8025ccc:	6523      	strge	r3, [r4, #80]	; 0x50
 8025cce:	81a3      	strhlt	r3, [r4, #12]
 8025cd0:	bd10      	pop	{r4, pc}

08025cd2 <__swrite>:
 8025cd2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8025cd6:	461f      	mov	r7, r3
 8025cd8:	898b      	ldrh	r3, [r1, #12]
 8025cda:	05db      	lsls	r3, r3, #23
 8025cdc:	4605      	mov	r5, r0
 8025cde:	460c      	mov	r4, r1
 8025ce0:	4616      	mov	r6, r2
 8025ce2:	d505      	bpl.n	8025cf0 <__swrite+0x1e>
 8025ce4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8025ce8:	2302      	movs	r3, #2
 8025cea:	2200      	movs	r2, #0
 8025cec:	f000 f8a4 	bl	8025e38 <_lseek_r>
 8025cf0:	89a3      	ldrh	r3, [r4, #12]
 8025cf2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8025cf6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8025cfa:	81a3      	strh	r3, [r4, #12]
 8025cfc:	4632      	mov	r2, r6
 8025cfe:	463b      	mov	r3, r7
 8025d00:	4628      	mov	r0, r5
 8025d02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8025d06:	f000 b8bb 	b.w	8025e80 <_write_r>

08025d0a <__sseek>:
 8025d0a:	b510      	push	{r4, lr}
 8025d0c:	460c      	mov	r4, r1
 8025d0e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8025d12:	f000 f891 	bl	8025e38 <_lseek_r>
 8025d16:	1c43      	adds	r3, r0, #1
 8025d18:	89a3      	ldrh	r3, [r4, #12]
 8025d1a:	bf15      	itete	ne
 8025d1c:	6520      	strne	r0, [r4, #80]	; 0x50
 8025d1e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8025d22:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8025d26:	81a3      	strheq	r3, [r4, #12]
 8025d28:	bf18      	it	ne
 8025d2a:	81a3      	strhne	r3, [r4, #12]
 8025d2c:	bd10      	pop	{r4, pc}

08025d2e <__sclose>:
 8025d2e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8025d32:	f000 b871 	b.w	8025e18 <_close_r>

08025d36 <memcmp>:
 8025d36:	b510      	push	{r4, lr}
 8025d38:	3901      	subs	r1, #1
 8025d3a:	4402      	add	r2, r0
 8025d3c:	4290      	cmp	r0, r2
 8025d3e:	d101      	bne.n	8025d44 <memcmp+0xe>
 8025d40:	2000      	movs	r0, #0
 8025d42:	e005      	b.n	8025d50 <memcmp+0x1a>
 8025d44:	7803      	ldrb	r3, [r0, #0]
 8025d46:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8025d4a:	42a3      	cmp	r3, r4
 8025d4c:	d001      	beq.n	8025d52 <memcmp+0x1c>
 8025d4e:	1b18      	subs	r0, r3, r4
 8025d50:	bd10      	pop	{r4, pc}
 8025d52:	3001      	adds	r0, #1
 8025d54:	e7f2      	b.n	8025d3c <memcmp+0x6>

08025d56 <memset>:
 8025d56:	4402      	add	r2, r0
 8025d58:	4603      	mov	r3, r0
 8025d5a:	4293      	cmp	r3, r2
 8025d5c:	d100      	bne.n	8025d60 <memset+0xa>
 8025d5e:	4770      	bx	lr
 8025d60:	f803 1b01 	strb.w	r1, [r3], #1
 8025d64:	e7f9      	b.n	8025d5a <memset+0x4>

08025d66 <strncmp>:
 8025d66:	b510      	push	{r4, lr}
 8025d68:	b16a      	cbz	r2, 8025d86 <strncmp+0x20>
 8025d6a:	3901      	subs	r1, #1
 8025d6c:	1884      	adds	r4, r0, r2
 8025d6e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8025d72:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8025d76:	429a      	cmp	r2, r3
 8025d78:	d103      	bne.n	8025d82 <strncmp+0x1c>
 8025d7a:	42a0      	cmp	r0, r4
 8025d7c:	d001      	beq.n	8025d82 <strncmp+0x1c>
 8025d7e:	2a00      	cmp	r2, #0
 8025d80:	d1f5      	bne.n	8025d6e <strncmp+0x8>
 8025d82:	1ad0      	subs	r0, r2, r3
 8025d84:	bd10      	pop	{r4, pc}
 8025d86:	4610      	mov	r0, r2
 8025d88:	e7fc      	b.n	8025d84 <strncmp+0x1e>
	...

08025d8c <strtok>:
 8025d8c:	4b02      	ldr	r3, [pc, #8]	; (8025d98 <strtok+0xc>)
 8025d8e:	681a      	ldr	r2, [r3, #0]
 8025d90:	2301      	movs	r3, #1
 8025d92:	3250      	adds	r2, #80	; 0x50
 8025d94:	f000 b802 	b.w	8025d9c <__strtok_r>
 8025d98:	20000380 	.word	0x20000380

08025d9c <__strtok_r>:
 8025d9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025d9e:	b908      	cbnz	r0, 8025da4 <__strtok_r+0x8>
 8025da0:	6810      	ldr	r0, [r2, #0]
 8025da2:	b188      	cbz	r0, 8025dc8 <__strtok_r+0x2c>
 8025da4:	4604      	mov	r4, r0
 8025da6:	4620      	mov	r0, r4
 8025da8:	f814 5b01 	ldrb.w	r5, [r4], #1
 8025dac:	460f      	mov	r7, r1
 8025dae:	f817 6b01 	ldrb.w	r6, [r7], #1
 8025db2:	b91e      	cbnz	r6, 8025dbc <__strtok_r+0x20>
 8025db4:	b965      	cbnz	r5, 8025dd0 <__strtok_r+0x34>
 8025db6:	6015      	str	r5, [r2, #0]
 8025db8:	4628      	mov	r0, r5
 8025dba:	e005      	b.n	8025dc8 <__strtok_r+0x2c>
 8025dbc:	42b5      	cmp	r5, r6
 8025dbe:	d1f6      	bne.n	8025dae <__strtok_r+0x12>
 8025dc0:	2b00      	cmp	r3, #0
 8025dc2:	d1f0      	bne.n	8025da6 <__strtok_r+0xa>
 8025dc4:	6014      	str	r4, [r2, #0]
 8025dc6:	7003      	strb	r3, [r0, #0]
 8025dc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025dca:	461c      	mov	r4, r3
 8025dcc:	e00c      	b.n	8025de8 <__strtok_r+0x4c>
 8025dce:	b915      	cbnz	r5, 8025dd6 <__strtok_r+0x3a>
 8025dd0:	f814 3b01 	ldrb.w	r3, [r4], #1
 8025dd4:	460e      	mov	r6, r1
 8025dd6:	f816 5b01 	ldrb.w	r5, [r6], #1
 8025dda:	42ab      	cmp	r3, r5
 8025ddc:	d1f7      	bne.n	8025dce <__strtok_r+0x32>
 8025dde:	2b00      	cmp	r3, #0
 8025de0:	d0f3      	beq.n	8025dca <__strtok_r+0x2e>
 8025de2:	2300      	movs	r3, #0
 8025de4:	f804 3c01 	strb.w	r3, [r4, #-1]
 8025de8:	6014      	str	r4, [r2, #0]
 8025dea:	e7ed      	b.n	8025dc8 <__strtok_r+0x2c>

08025dec <strstr>:
 8025dec:	780a      	ldrb	r2, [r1, #0]
 8025dee:	b570      	push	{r4, r5, r6, lr}
 8025df0:	b96a      	cbnz	r2, 8025e0e <strstr+0x22>
 8025df2:	bd70      	pop	{r4, r5, r6, pc}
 8025df4:	429a      	cmp	r2, r3
 8025df6:	d109      	bne.n	8025e0c <strstr+0x20>
 8025df8:	460c      	mov	r4, r1
 8025dfa:	4605      	mov	r5, r0
 8025dfc:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8025e00:	2b00      	cmp	r3, #0
 8025e02:	d0f6      	beq.n	8025df2 <strstr+0x6>
 8025e04:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 8025e08:	429e      	cmp	r6, r3
 8025e0a:	d0f7      	beq.n	8025dfc <strstr+0x10>
 8025e0c:	3001      	adds	r0, #1
 8025e0e:	7803      	ldrb	r3, [r0, #0]
 8025e10:	2b00      	cmp	r3, #0
 8025e12:	d1ef      	bne.n	8025df4 <strstr+0x8>
 8025e14:	4618      	mov	r0, r3
 8025e16:	e7ec      	b.n	8025df2 <strstr+0x6>

08025e18 <_close_r>:
 8025e18:	b538      	push	{r3, r4, r5, lr}
 8025e1a:	4d06      	ldr	r5, [pc, #24]	; (8025e34 <_close_r+0x1c>)
 8025e1c:	2300      	movs	r3, #0
 8025e1e:	4604      	mov	r4, r0
 8025e20:	4608      	mov	r0, r1
 8025e22:	602b      	str	r3, [r5, #0]
 8025e24:	f7db fd04 	bl	8001830 <_close>
 8025e28:	1c43      	adds	r3, r0, #1
 8025e2a:	d102      	bne.n	8025e32 <_close_r+0x1a>
 8025e2c:	682b      	ldr	r3, [r5, #0]
 8025e2e:	b103      	cbz	r3, 8025e32 <_close_r+0x1a>
 8025e30:	6023      	str	r3, [r4, #0]
 8025e32:	bd38      	pop	{r3, r4, r5, pc}
 8025e34:	20011ed8 	.word	0x20011ed8

08025e38 <_lseek_r>:
 8025e38:	b538      	push	{r3, r4, r5, lr}
 8025e3a:	4d07      	ldr	r5, [pc, #28]	; (8025e58 <_lseek_r+0x20>)
 8025e3c:	4604      	mov	r4, r0
 8025e3e:	4608      	mov	r0, r1
 8025e40:	4611      	mov	r1, r2
 8025e42:	2200      	movs	r2, #0
 8025e44:	602a      	str	r2, [r5, #0]
 8025e46:	461a      	mov	r2, r3
 8025e48:	f7db fcfc 	bl	8001844 <_lseek>
 8025e4c:	1c43      	adds	r3, r0, #1
 8025e4e:	d102      	bne.n	8025e56 <_lseek_r+0x1e>
 8025e50:	682b      	ldr	r3, [r5, #0]
 8025e52:	b103      	cbz	r3, 8025e56 <_lseek_r+0x1e>
 8025e54:	6023      	str	r3, [r4, #0]
 8025e56:	bd38      	pop	{r3, r4, r5, pc}
 8025e58:	20011ed8 	.word	0x20011ed8

08025e5c <_read_r>:
 8025e5c:	b538      	push	{r3, r4, r5, lr}
 8025e5e:	4d07      	ldr	r5, [pc, #28]	; (8025e7c <_read_r+0x20>)
 8025e60:	4604      	mov	r4, r0
 8025e62:	4608      	mov	r0, r1
 8025e64:	4611      	mov	r1, r2
 8025e66:	2200      	movs	r2, #0
 8025e68:	602a      	str	r2, [r5, #0]
 8025e6a:	461a      	mov	r2, r3
 8025e6c:	f7db fcc2 	bl	80017f4 <_read>
 8025e70:	1c43      	adds	r3, r0, #1
 8025e72:	d102      	bne.n	8025e7a <_read_r+0x1e>
 8025e74:	682b      	ldr	r3, [r5, #0]
 8025e76:	b103      	cbz	r3, 8025e7a <_read_r+0x1e>
 8025e78:	6023      	str	r3, [r4, #0]
 8025e7a:	bd38      	pop	{r3, r4, r5, pc}
 8025e7c:	20011ed8 	.word	0x20011ed8

08025e80 <_write_r>:
 8025e80:	b538      	push	{r3, r4, r5, lr}
 8025e82:	4d07      	ldr	r5, [pc, #28]	; (8025ea0 <_write_r+0x20>)
 8025e84:	4604      	mov	r4, r0
 8025e86:	4608      	mov	r0, r1
 8025e88:	4611      	mov	r1, r2
 8025e8a:	2200      	movs	r2, #0
 8025e8c:	602a      	str	r2, [r5, #0]
 8025e8e:	461a      	mov	r2, r3
 8025e90:	f7db fcc0 	bl	8001814 <_write>
 8025e94:	1c43      	adds	r3, r0, #1
 8025e96:	d102      	bne.n	8025e9e <_write_r+0x1e>
 8025e98:	682b      	ldr	r3, [r5, #0]
 8025e9a:	b103      	cbz	r3, 8025e9e <_write_r+0x1e>
 8025e9c:	6023      	str	r3, [r4, #0]
 8025e9e:	bd38      	pop	{r3, r4, r5, pc}
 8025ea0:	20011ed8 	.word	0x20011ed8

08025ea4 <__errno>:
 8025ea4:	4b01      	ldr	r3, [pc, #4]	; (8025eac <__errno+0x8>)
 8025ea6:	6818      	ldr	r0, [r3, #0]
 8025ea8:	4770      	bx	lr
 8025eaa:	bf00      	nop
 8025eac:	20000380 	.word	0x20000380

08025eb0 <__libc_init_array>:
 8025eb0:	b570      	push	{r4, r5, r6, lr}
 8025eb2:	4d0d      	ldr	r5, [pc, #52]	; (8025ee8 <__libc_init_array+0x38>)
 8025eb4:	4c0d      	ldr	r4, [pc, #52]	; (8025eec <__libc_init_array+0x3c>)
 8025eb6:	1b64      	subs	r4, r4, r5
 8025eb8:	10a4      	asrs	r4, r4, #2
 8025eba:	2600      	movs	r6, #0
 8025ebc:	42a6      	cmp	r6, r4
 8025ebe:	d109      	bne.n	8025ed4 <__libc_init_array+0x24>
 8025ec0:	4d0b      	ldr	r5, [pc, #44]	; (8025ef0 <__libc_init_array+0x40>)
 8025ec2:	4c0c      	ldr	r4, [pc, #48]	; (8025ef4 <__libc_init_array+0x44>)
 8025ec4:	f004 fbee 	bl	802a6a4 <_init>
 8025ec8:	1b64      	subs	r4, r4, r5
 8025eca:	10a4      	asrs	r4, r4, #2
 8025ecc:	2600      	movs	r6, #0
 8025ece:	42a6      	cmp	r6, r4
 8025ed0:	d105      	bne.n	8025ede <__libc_init_array+0x2e>
 8025ed2:	bd70      	pop	{r4, r5, r6, pc}
 8025ed4:	f855 3b04 	ldr.w	r3, [r5], #4
 8025ed8:	4798      	blx	r3
 8025eda:	3601      	adds	r6, #1
 8025edc:	e7ee      	b.n	8025ebc <__libc_init_array+0xc>
 8025ede:	f855 3b04 	ldr.w	r3, [r5], #4
 8025ee2:	4798      	blx	r3
 8025ee4:	3601      	adds	r6, #1
 8025ee6:	e7f2      	b.n	8025ece <__libc_init_array+0x1e>
 8025ee8:	080367b0 	.word	0x080367b0
 8025eec:	080367b0 	.word	0x080367b0
 8025ef0:	080367b0 	.word	0x080367b0
 8025ef4:	080367b8 	.word	0x080367b8

08025ef8 <__retarget_lock_init_recursive>:
 8025ef8:	4770      	bx	lr

08025efa <__retarget_lock_close_recursive>:
 8025efa:	4770      	bx	lr

08025efc <__retarget_lock_acquire_recursive>:
 8025efc:	4770      	bx	lr

08025efe <__retarget_lock_release_recursive>:
 8025efe:	4770      	bx	lr

08025f00 <strcpy>:
 8025f00:	4603      	mov	r3, r0
 8025f02:	f811 2b01 	ldrb.w	r2, [r1], #1
 8025f06:	f803 2b01 	strb.w	r2, [r3], #1
 8025f0a:	2a00      	cmp	r2, #0
 8025f0c:	d1f9      	bne.n	8025f02 <strcpy+0x2>
 8025f0e:	4770      	bx	lr

08025f10 <memcpy>:
 8025f10:	440a      	add	r2, r1
 8025f12:	4291      	cmp	r1, r2
 8025f14:	f100 33ff 	add.w	r3, r0, #4294967295
 8025f18:	d100      	bne.n	8025f1c <memcpy+0xc>
 8025f1a:	4770      	bx	lr
 8025f1c:	b510      	push	{r4, lr}
 8025f1e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8025f22:	f803 4f01 	strb.w	r4, [r3, #1]!
 8025f26:	4291      	cmp	r1, r2
 8025f28:	d1f9      	bne.n	8025f1e <memcpy+0xe>
 8025f2a:	bd10      	pop	{r4, pc}

08025f2c <register_fini>:
 8025f2c:	4b02      	ldr	r3, [pc, #8]	; (8025f38 <register_fini+0xc>)
 8025f2e:	b113      	cbz	r3, 8025f36 <register_fini+0xa>
 8025f30:	4802      	ldr	r0, [pc, #8]	; (8025f3c <register_fini+0x10>)
 8025f32:	f000 b805 	b.w	8025f40 <atexit>
 8025f36:	4770      	bx	lr
 8025f38:	00000000 	.word	0x00000000
 8025f3c:	08027c4d 	.word	0x08027c4d

08025f40 <atexit>:
 8025f40:	2300      	movs	r3, #0
 8025f42:	4601      	mov	r1, r0
 8025f44:	461a      	mov	r2, r3
 8025f46:	4618      	mov	r0, r3
 8025f48:	f001 bed8 	b.w	8027cfc <__register_exitproc>

08025f4c <_malloc_trim_r>:
 8025f4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8025f50:	4606      	mov	r6, r0
 8025f52:	2008      	movs	r0, #8
 8025f54:	460c      	mov	r4, r1
 8025f56:	f001 fe8d 	bl	8027c74 <sysconf>
 8025f5a:	4f23      	ldr	r7, [pc, #140]	; (8025fe8 <_malloc_trim_r+0x9c>)
 8025f5c:	4680      	mov	r8, r0
 8025f5e:	4630      	mov	r0, r6
 8025f60:	f000 fb42 	bl	80265e8 <__malloc_lock>
 8025f64:	68bb      	ldr	r3, [r7, #8]
 8025f66:	685d      	ldr	r5, [r3, #4]
 8025f68:	f025 0503 	bic.w	r5, r5, #3
 8025f6c:	1b2c      	subs	r4, r5, r4
 8025f6e:	3c11      	subs	r4, #17
 8025f70:	4444      	add	r4, r8
 8025f72:	fbb4 f4f8 	udiv	r4, r4, r8
 8025f76:	3c01      	subs	r4, #1
 8025f78:	fb08 f404 	mul.w	r4, r8, r4
 8025f7c:	45a0      	cmp	r8, r4
 8025f7e:	dd05      	ble.n	8025f8c <_malloc_trim_r+0x40>
 8025f80:	4630      	mov	r0, r6
 8025f82:	f000 fb37 	bl	80265f4 <__malloc_unlock>
 8025f86:	2000      	movs	r0, #0
 8025f88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8025f8c:	2100      	movs	r1, #0
 8025f8e:	4630      	mov	r0, r6
 8025f90:	f001 fe4c 	bl	8027c2c <_sbrk_r>
 8025f94:	68bb      	ldr	r3, [r7, #8]
 8025f96:	442b      	add	r3, r5
 8025f98:	4298      	cmp	r0, r3
 8025f9a:	d1f1      	bne.n	8025f80 <_malloc_trim_r+0x34>
 8025f9c:	4261      	negs	r1, r4
 8025f9e:	4630      	mov	r0, r6
 8025fa0:	f001 fe44 	bl	8027c2c <_sbrk_r>
 8025fa4:	3001      	adds	r0, #1
 8025fa6:	d110      	bne.n	8025fca <_malloc_trim_r+0x7e>
 8025fa8:	2100      	movs	r1, #0
 8025faa:	4630      	mov	r0, r6
 8025fac:	f001 fe3e 	bl	8027c2c <_sbrk_r>
 8025fb0:	68ba      	ldr	r2, [r7, #8]
 8025fb2:	1a83      	subs	r3, r0, r2
 8025fb4:	2b0f      	cmp	r3, #15
 8025fb6:	dde3      	ble.n	8025f80 <_malloc_trim_r+0x34>
 8025fb8:	490c      	ldr	r1, [pc, #48]	; (8025fec <_malloc_trim_r+0xa0>)
 8025fba:	6809      	ldr	r1, [r1, #0]
 8025fbc:	1a40      	subs	r0, r0, r1
 8025fbe:	490c      	ldr	r1, [pc, #48]	; (8025ff0 <_malloc_trim_r+0xa4>)
 8025fc0:	f043 0301 	orr.w	r3, r3, #1
 8025fc4:	6008      	str	r0, [r1, #0]
 8025fc6:	6053      	str	r3, [r2, #4]
 8025fc8:	e7da      	b.n	8025f80 <_malloc_trim_r+0x34>
 8025fca:	68bb      	ldr	r3, [r7, #8]
 8025fcc:	4a08      	ldr	r2, [pc, #32]	; (8025ff0 <_malloc_trim_r+0xa4>)
 8025fce:	1b2d      	subs	r5, r5, r4
 8025fd0:	f045 0501 	orr.w	r5, r5, #1
 8025fd4:	605d      	str	r5, [r3, #4]
 8025fd6:	6813      	ldr	r3, [r2, #0]
 8025fd8:	4630      	mov	r0, r6
 8025fda:	1b1b      	subs	r3, r3, r4
 8025fdc:	6013      	str	r3, [r2, #0]
 8025fde:	f000 fb09 	bl	80265f4 <__malloc_unlock>
 8025fe2:	2001      	movs	r0, #1
 8025fe4:	e7d0      	b.n	8025f88 <_malloc_trim_r+0x3c>
 8025fe6:	bf00      	nop
 8025fe8:	20000388 	.word	0x20000388
 8025fec:	20000790 	.word	0x20000790
 8025ff0:	20011ee4 	.word	0x20011ee4

08025ff4 <_free_r>:
 8025ff4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025ff6:	4605      	mov	r5, r0
 8025ff8:	460f      	mov	r7, r1
 8025ffa:	2900      	cmp	r1, #0
 8025ffc:	f000 80b1 	beq.w	8026162 <_free_r+0x16e>
 8026000:	f000 faf2 	bl	80265e8 <__malloc_lock>
 8026004:	f857 2c04 	ldr.w	r2, [r7, #-4]
 8026008:	4856      	ldr	r0, [pc, #344]	; (8026164 <_free_r+0x170>)
 802600a:	f022 0401 	bic.w	r4, r2, #1
 802600e:	f1a7 0308 	sub.w	r3, r7, #8
 8026012:	eb03 0c04 	add.w	ip, r3, r4
 8026016:	6881      	ldr	r1, [r0, #8]
 8026018:	f8dc 6004 	ldr.w	r6, [ip, #4]
 802601c:	4561      	cmp	r1, ip
 802601e:	f026 0603 	bic.w	r6, r6, #3
 8026022:	f002 0201 	and.w	r2, r2, #1
 8026026:	d11b      	bne.n	8026060 <_free_r+0x6c>
 8026028:	4426      	add	r6, r4
 802602a:	b93a      	cbnz	r2, 802603c <_free_r+0x48>
 802602c:	f857 2c08 	ldr.w	r2, [r7, #-8]
 8026030:	1a9b      	subs	r3, r3, r2
 8026032:	4416      	add	r6, r2
 8026034:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
 8026038:	60ca      	str	r2, [r1, #12]
 802603a:	6091      	str	r1, [r2, #8]
 802603c:	f046 0201 	orr.w	r2, r6, #1
 8026040:	605a      	str	r2, [r3, #4]
 8026042:	6083      	str	r3, [r0, #8]
 8026044:	4b48      	ldr	r3, [pc, #288]	; (8026168 <_free_r+0x174>)
 8026046:	681b      	ldr	r3, [r3, #0]
 8026048:	42b3      	cmp	r3, r6
 802604a:	d804      	bhi.n	8026056 <_free_r+0x62>
 802604c:	4b47      	ldr	r3, [pc, #284]	; (802616c <_free_r+0x178>)
 802604e:	4628      	mov	r0, r5
 8026050:	6819      	ldr	r1, [r3, #0]
 8026052:	f7ff ff7b 	bl	8025f4c <_malloc_trim_r>
 8026056:	4628      	mov	r0, r5
 8026058:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 802605c:	f000 baca 	b.w	80265f4 <__malloc_unlock>
 8026060:	f8cc 6004 	str.w	r6, [ip, #4]
 8026064:	2a00      	cmp	r2, #0
 8026066:	d138      	bne.n	80260da <_free_r+0xe6>
 8026068:	f857 1c08 	ldr.w	r1, [r7, #-8]
 802606c:	1a5b      	subs	r3, r3, r1
 802606e:	440c      	add	r4, r1
 8026070:	6899      	ldr	r1, [r3, #8]
 8026072:	f100 0708 	add.w	r7, r0, #8
 8026076:	42b9      	cmp	r1, r7
 8026078:	d031      	beq.n	80260de <_free_r+0xea>
 802607a:	68df      	ldr	r7, [r3, #12]
 802607c:	60cf      	str	r7, [r1, #12]
 802607e:	60b9      	str	r1, [r7, #8]
 8026080:	eb0c 0106 	add.w	r1, ip, r6
 8026084:	6849      	ldr	r1, [r1, #4]
 8026086:	07c9      	lsls	r1, r1, #31
 8026088:	d40b      	bmi.n	80260a2 <_free_r+0xae>
 802608a:	f8dc 1008 	ldr.w	r1, [ip, #8]
 802608e:	4434      	add	r4, r6
 8026090:	bb3a      	cbnz	r2, 80260e2 <_free_r+0xee>
 8026092:	4e37      	ldr	r6, [pc, #220]	; (8026170 <_free_r+0x17c>)
 8026094:	42b1      	cmp	r1, r6
 8026096:	d124      	bne.n	80260e2 <_free_r+0xee>
 8026098:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802609c:	e9c3 1102 	strd	r1, r1, [r3, #8]
 80260a0:	2201      	movs	r2, #1
 80260a2:	f044 0101 	orr.w	r1, r4, #1
 80260a6:	6059      	str	r1, [r3, #4]
 80260a8:	511c      	str	r4, [r3, r4]
 80260aa:	2a00      	cmp	r2, #0
 80260ac:	d1d3      	bne.n	8026056 <_free_r+0x62>
 80260ae:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 80260b2:	d21b      	bcs.n	80260ec <_free_r+0xf8>
 80260b4:	08e2      	lsrs	r2, r4, #3
 80260b6:	2101      	movs	r1, #1
 80260b8:	0964      	lsrs	r4, r4, #5
 80260ba:	40a1      	lsls	r1, r4
 80260bc:	6844      	ldr	r4, [r0, #4]
 80260be:	3201      	adds	r2, #1
 80260c0:	4321      	orrs	r1, r4
 80260c2:	6041      	str	r1, [r0, #4]
 80260c4:	f850 4032 	ldr.w	r4, [r0, r2, lsl #3]
 80260c8:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 80260cc:	3908      	subs	r1, #8
 80260ce:	e9c3 4102 	strd	r4, r1, [r3, #8]
 80260d2:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
 80260d6:	60e3      	str	r3, [r4, #12]
 80260d8:	e7bd      	b.n	8026056 <_free_r+0x62>
 80260da:	2200      	movs	r2, #0
 80260dc:	e7d0      	b.n	8026080 <_free_r+0x8c>
 80260de:	2201      	movs	r2, #1
 80260e0:	e7ce      	b.n	8026080 <_free_r+0x8c>
 80260e2:	f8dc 600c 	ldr.w	r6, [ip, #12]
 80260e6:	60ce      	str	r6, [r1, #12]
 80260e8:	60b1      	str	r1, [r6, #8]
 80260ea:	e7da      	b.n	80260a2 <_free_r+0xae>
 80260ec:	f5b4 6f20 	cmp.w	r4, #2560	; 0xa00
 80260f0:	ea4f 2254 	mov.w	r2, r4, lsr #9
 80260f4:	d214      	bcs.n	8026120 <_free_r+0x12c>
 80260f6:	09a2      	lsrs	r2, r4, #6
 80260f8:	3238      	adds	r2, #56	; 0x38
 80260fa:	1c51      	adds	r1, r2, #1
 80260fc:	eb00 06c2 	add.w	r6, r0, r2, lsl #3
 8026100:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
 8026104:	428e      	cmp	r6, r1
 8026106:	d125      	bne.n	8026154 <_free_r+0x160>
 8026108:	2401      	movs	r4, #1
 802610a:	1092      	asrs	r2, r2, #2
 802610c:	fa04 f202 	lsl.w	r2, r4, r2
 8026110:	6844      	ldr	r4, [r0, #4]
 8026112:	4322      	orrs	r2, r4
 8026114:	6042      	str	r2, [r0, #4]
 8026116:	e9c3 1602 	strd	r1, r6, [r3, #8]
 802611a:	60b3      	str	r3, [r6, #8]
 802611c:	60cb      	str	r3, [r1, #12]
 802611e:	e79a      	b.n	8026056 <_free_r+0x62>
 8026120:	2a14      	cmp	r2, #20
 8026122:	d801      	bhi.n	8026128 <_free_r+0x134>
 8026124:	325b      	adds	r2, #91	; 0x5b
 8026126:	e7e8      	b.n	80260fa <_free_r+0x106>
 8026128:	2a54      	cmp	r2, #84	; 0x54
 802612a:	d802      	bhi.n	8026132 <_free_r+0x13e>
 802612c:	0b22      	lsrs	r2, r4, #12
 802612e:	326e      	adds	r2, #110	; 0x6e
 8026130:	e7e3      	b.n	80260fa <_free_r+0x106>
 8026132:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8026136:	d802      	bhi.n	802613e <_free_r+0x14a>
 8026138:	0be2      	lsrs	r2, r4, #15
 802613a:	3277      	adds	r2, #119	; 0x77
 802613c:	e7dd      	b.n	80260fa <_free_r+0x106>
 802613e:	f240 5154 	movw	r1, #1364	; 0x554
 8026142:	428a      	cmp	r2, r1
 8026144:	bf9a      	itte	ls
 8026146:	0ca2      	lsrls	r2, r4, #18
 8026148:	327c      	addls	r2, #124	; 0x7c
 802614a:	227e      	movhi	r2, #126	; 0x7e
 802614c:	e7d5      	b.n	80260fa <_free_r+0x106>
 802614e:	6889      	ldr	r1, [r1, #8]
 8026150:	428e      	cmp	r6, r1
 8026152:	d004      	beq.n	802615e <_free_r+0x16a>
 8026154:	684a      	ldr	r2, [r1, #4]
 8026156:	f022 0203 	bic.w	r2, r2, #3
 802615a:	42a2      	cmp	r2, r4
 802615c:	d8f7      	bhi.n	802614e <_free_r+0x15a>
 802615e:	68ce      	ldr	r6, [r1, #12]
 8026160:	e7d9      	b.n	8026116 <_free_r+0x122>
 8026162:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8026164:	20000388 	.word	0x20000388
 8026168:	20000794 	.word	0x20000794
 802616c:	20011f14 	.word	0x20011f14
 8026170:	20000390 	.word	0x20000390

08026174 <_malloc_r>:
 8026174:	f101 030b 	add.w	r3, r1, #11
 8026178:	2b16      	cmp	r3, #22
 802617a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802617e:	4605      	mov	r5, r0
 8026180:	d906      	bls.n	8026190 <_malloc_r+0x1c>
 8026182:	f033 0707 	bics.w	r7, r3, #7
 8026186:	d504      	bpl.n	8026192 <_malloc_r+0x1e>
 8026188:	230c      	movs	r3, #12
 802618a:	602b      	str	r3, [r5, #0]
 802618c:	2400      	movs	r4, #0
 802618e:	e1a3      	b.n	80264d8 <_malloc_r+0x364>
 8026190:	2710      	movs	r7, #16
 8026192:	42b9      	cmp	r1, r7
 8026194:	d8f8      	bhi.n	8026188 <_malloc_r+0x14>
 8026196:	4628      	mov	r0, r5
 8026198:	f000 fa26 	bl	80265e8 <__malloc_lock>
 802619c:	f5b7 7ffc 	cmp.w	r7, #504	; 0x1f8
 80261a0:	4eaf      	ldr	r6, [pc, #700]	; (8026460 <_malloc_r+0x2ec>)
 80261a2:	d237      	bcs.n	8026214 <_malloc_r+0xa0>
 80261a4:	f107 0208 	add.w	r2, r7, #8
 80261a8:	4432      	add	r2, r6
 80261aa:	f1a2 0108 	sub.w	r1, r2, #8
 80261ae:	6854      	ldr	r4, [r2, #4]
 80261b0:	428c      	cmp	r4, r1
 80261b2:	ea4f 03d7 	mov.w	r3, r7, lsr #3
 80261b6:	d102      	bne.n	80261be <_malloc_r+0x4a>
 80261b8:	68d4      	ldr	r4, [r2, #12]
 80261ba:	42a2      	cmp	r2, r4
 80261bc:	d010      	beq.n	80261e0 <_malloc_r+0x6c>
 80261be:	6863      	ldr	r3, [r4, #4]
 80261c0:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 80261c4:	f023 0303 	bic.w	r3, r3, #3
 80261c8:	60ca      	str	r2, [r1, #12]
 80261ca:	4423      	add	r3, r4
 80261cc:	6091      	str	r1, [r2, #8]
 80261ce:	685a      	ldr	r2, [r3, #4]
 80261d0:	f042 0201 	orr.w	r2, r2, #1
 80261d4:	605a      	str	r2, [r3, #4]
 80261d6:	4628      	mov	r0, r5
 80261d8:	f000 fa0c 	bl	80265f4 <__malloc_unlock>
 80261dc:	3408      	adds	r4, #8
 80261de:	e17b      	b.n	80264d8 <_malloc_r+0x364>
 80261e0:	3302      	adds	r3, #2
 80261e2:	6934      	ldr	r4, [r6, #16]
 80261e4:	499f      	ldr	r1, [pc, #636]	; (8026464 <_malloc_r+0x2f0>)
 80261e6:	428c      	cmp	r4, r1
 80261e8:	d077      	beq.n	80262da <_malloc_r+0x166>
 80261ea:	6862      	ldr	r2, [r4, #4]
 80261ec:	f022 0c03 	bic.w	ip, r2, #3
 80261f0:	ebac 0007 	sub.w	r0, ip, r7
 80261f4:	280f      	cmp	r0, #15
 80261f6:	dd48      	ble.n	802628a <_malloc_r+0x116>
 80261f8:	19e2      	adds	r2, r4, r7
 80261fa:	f040 0301 	orr.w	r3, r0, #1
 80261fe:	f047 0701 	orr.w	r7, r7, #1
 8026202:	6067      	str	r7, [r4, #4]
 8026204:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8026208:	e9c2 1102 	strd	r1, r1, [r2, #8]
 802620c:	6053      	str	r3, [r2, #4]
 802620e:	f844 000c 	str.w	r0, [r4, ip]
 8026212:	e7e0      	b.n	80261d6 <_malloc_r+0x62>
 8026214:	0a7b      	lsrs	r3, r7, #9
 8026216:	d02a      	beq.n	802626e <_malloc_r+0xfa>
 8026218:	2b04      	cmp	r3, #4
 802621a:	d812      	bhi.n	8026242 <_malloc_r+0xce>
 802621c:	09bb      	lsrs	r3, r7, #6
 802621e:	3338      	adds	r3, #56	; 0x38
 8026220:	1c5a      	adds	r2, r3, #1
 8026222:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8026226:	f1a2 0c08 	sub.w	ip, r2, #8
 802622a:	6854      	ldr	r4, [r2, #4]
 802622c:	4564      	cmp	r4, ip
 802622e:	d006      	beq.n	802623e <_malloc_r+0xca>
 8026230:	6862      	ldr	r2, [r4, #4]
 8026232:	f022 0203 	bic.w	r2, r2, #3
 8026236:	1bd0      	subs	r0, r2, r7
 8026238:	280f      	cmp	r0, #15
 802623a:	dd1c      	ble.n	8026276 <_malloc_r+0x102>
 802623c:	3b01      	subs	r3, #1
 802623e:	3301      	adds	r3, #1
 8026240:	e7cf      	b.n	80261e2 <_malloc_r+0x6e>
 8026242:	2b14      	cmp	r3, #20
 8026244:	d801      	bhi.n	802624a <_malloc_r+0xd6>
 8026246:	335b      	adds	r3, #91	; 0x5b
 8026248:	e7ea      	b.n	8026220 <_malloc_r+0xac>
 802624a:	2b54      	cmp	r3, #84	; 0x54
 802624c:	d802      	bhi.n	8026254 <_malloc_r+0xe0>
 802624e:	0b3b      	lsrs	r3, r7, #12
 8026250:	336e      	adds	r3, #110	; 0x6e
 8026252:	e7e5      	b.n	8026220 <_malloc_r+0xac>
 8026254:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8026258:	d802      	bhi.n	8026260 <_malloc_r+0xec>
 802625a:	0bfb      	lsrs	r3, r7, #15
 802625c:	3377      	adds	r3, #119	; 0x77
 802625e:	e7df      	b.n	8026220 <_malloc_r+0xac>
 8026260:	f240 5254 	movw	r2, #1364	; 0x554
 8026264:	4293      	cmp	r3, r2
 8026266:	d804      	bhi.n	8026272 <_malloc_r+0xfe>
 8026268:	0cbb      	lsrs	r3, r7, #18
 802626a:	337c      	adds	r3, #124	; 0x7c
 802626c:	e7d8      	b.n	8026220 <_malloc_r+0xac>
 802626e:	233f      	movs	r3, #63	; 0x3f
 8026270:	e7d6      	b.n	8026220 <_malloc_r+0xac>
 8026272:	237e      	movs	r3, #126	; 0x7e
 8026274:	e7d4      	b.n	8026220 <_malloc_r+0xac>
 8026276:	2800      	cmp	r0, #0
 8026278:	68e1      	ldr	r1, [r4, #12]
 802627a:	db04      	blt.n	8026286 <_malloc_r+0x112>
 802627c:	68a3      	ldr	r3, [r4, #8]
 802627e:	60d9      	str	r1, [r3, #12]
 8026280:	608b      	str	r3, [r1, #8]
 8026282:	18a3      	adds	r3, r4, r2
 8026284:	e7a3      	b.n	80261ce <_malloc_r+0x5a>
 8026286:	460c      	mov	r4, r1
 8026288:	e7d0      	b.n	802622c <_malloc_r+0xb8>
 802628a:	2800      	cmp	r0, #0
 802628c:	e9c6 1104 	strd	r1, r1, [r6, #16]
 8026290:	db07      	blt.n	80262a2 <_malloc_r+0x12e>
 8026292:	44a4      	add	ip, r4
 8026294:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8026298:	f043 0301 	orr.w	r3, r3, #1
 802629c:	f8cc 3004 	str.w	r3, [ip, #4]
 80262a0:	e799      	b.n	80261d6 <_malloc_r+0x62>
 80262a2:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
 80262a6:	6870      	ldr	r0, [r6, #4]
 80262a8:	f080 8095 	bcs.w	80263d6 <_malloc_r+0x262>
 80262ac:	ea4f 02dc 	mov.w	r2, ip, lsr #3
 80262b0:	ea4f 1e5c 	mov.w	lr, ip, lsr #5
 80262b4:	f04f 0c01 	mov.w	ip, #1
 80262b8:	3201      	adds	r2, #1
 80262ba:	fa0c fc0e 	lsl.w	ip, ip, lr
 80262be:	ea4c 0000 	orr.w	r0, ip, r0
 80262c2:	6070      	str	r0, [r6, #4]
 80262c4:	f856 c032 	ldr.w	ip, [r6, r2, lsl #3]
 80262c8:	eb06 00c2 	add.w	r0, r6, r2, lsl #3
 80262cc:	3808      	subs	r0, #8
 80262ce:	e9c4 c002 	strd	ip, r0, [r4, #8]
 80262d2:	f846 4032 	str.w	r4, [r6, r2, lsl #3]
 80262d6:	f8cc 400c 	str.w	r4, [ip, #12]
 80262da:	1098      	asrs	r0, r3, #2
 80262dc:	2201      	movs	r2, #1
 80262de:	4082      	lsls	r2, r0
 80262e0:	6870      	ldr	r0, [r6, #4]
 80262e2:	4290      	cmp	r0, r2
 80262e4:	d326      	bcc.n	8026334 <_malloc_r+0x1c0>
 80262e6:	4210      	tst	r0, r2
 80262e8:	d106      	bne.n	80262f8 <_malloc_r+0x184>
 80262ea:	f023 0303 	bic.w	r3, r3, #3
 80262ee:	0052      	lsls	r2, r2, #1
 80262f0:	4210      	tst	r0, r2
 80262f2:	f103 0304 	add.w	r3, r3, #4
 80262f6:	d0fa      	beq.n	80262ee <_malloc_r+0x17a>
 80262f8:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
 80262fc:	46c1      	mov	r9, r8
 80262fe:	469e      	mov	lr, r3
 8026300:	f8d9 400c 	ldr.w	r4, [r9, #12]
 8026304:	454c      	cmp	r4, r9
 8026306:	f040 80b9 	bne.w	802647c <_malloc_r+0x308>
 802630a:	f10e 0e01 	add.w	lr, lr, #1
 802630e:	f01e 0f03 	tst.w	lr, #3
 8026312:	f109 0908 	add.w	r9, r9, #8
 8026316:	d1f3      	bne.n	8026300 <_malloc_r+0x18c>
 8026318:	0798      	lsls	r0, r3, #30
 802631a:	f040 80e3 	bne.w	80264e4 <_malloc_r+0x370>
 802631e:	6873      	ldr	r3, [r6, #4]
 8026320:	ea23 0302 	bic.w	r3, r3, r2
 8026324:	6073      	str	r3, [r6, #4]
 8026326:	6870      	ldr	r0, [r6, #4]
 8026328:	0052      	lsls	r2, r2, #1
 802632a:	4290      	cmp	r0, r2
 802632c:	d302      	bcc.n	8026334 <_malloc_r+0x1c0>
 802632e:	2a00      	cmp	r2, #0
 8026330:	f040 80e5 	bne.w	80264fe <_malloc_r+0x38a>
 8026334:	f8d6 a008 	ldr.w	sl, [r6, #8]
 8026338:	f8da 3004 	ldr.w	r3, [sl, #4]
 802633c:	f023 0903 	bic.w	r9, r3, #3
 8026340:	45b9      	cmp	r9, r7
 8026342:	d304      	bcc.n	802634e <_malloc_r+0x1da>
 8026344:	eba9 0207 	sub.w	r2, r9, r7
 8026348:	2a0f      	cmp	r2, #15
 802634a:	f300 8141 	bgt.w	80265d0 <_malloc_r+0x45c>
 802634e:	4b46      	ldr	r3, [pc, #280]	; (8026468 <_malloc_r+0x2f4>)
 8026350:	6819      	ldr	r1, [r3, #0]
 8026352:	3110      	adds	r1, #16
 8026354:	4439      	add	r1, r7
 8026356:	2008      	movs	r0, #8
 8026358:	9101      	str	r1, [sp, #4]
 802635a:	f001 fc8b 	bl	8027c74 <sysconf>
 802635e:	4a43      	ldr	r2, [pc, #268]	; (802646c <_malloc_r+0x2f8>)
 8026360:	9901      	ldr	r1, [sp, #4]
 8026362:	6813      	ldr	r3, [r2, #0]
 8026364:	3301      	adds	r3, #1
 8026366:	bf1f      	itttt	ne
 8026368:	f101 31ff 	addne.w	r1, r1, #4294967295
 802636c:	1809      	addne	r1, r1, r0
 802636e:	4243      	negne	r3, r0
 8026370:	4019      	andne	r1, r3
 8026372:	4680      	mov	r8, r0
 8026374:	4628      	mov	r0, r5
 8026376:	9101      	str	r1, [sp, #4]
 8026378:	f001 fc58 	bl	8027c2c <_sbrk_r>
 802637c:	1c42      	adds	r2, r0, #1
 802637e:	eb0a 0b09 	add.w	fp, sl, r9
 8026382:	4604      	mov	r4, r0
 8026384:	f000 80f7 	beq.w	8026576 <_malloc_r+0x402>
 8026388:	4583      	cmp	fp, r0
 802638a:	9901      	ldr	r1, [sp, #4]
 802638c:	4a37      	ldr	r2, [pc, #220]	; (802646c <_malloc_r+0x2f8>)
 802638e:	d902      	bls.n	8026396 <_malloc_r+0x222>
 8026390:	45b2      	cmp	sl, r6
 8026392:	f040 80f0 	bne.w	8026576 <_malloc_r+0x402>
 8026396:	4b36      	ldr	r3, [pc, #216]	; (8026470 <_malloc_r+0x2fc>)
 8026398:	6818      	ldr	r0, [r3, #0]
 802639a:	45a3      	cmp	fp, r4
 802639c:	eb00 0e01 	add.w	lr, r0, r1
 80263a0:	f8c3 e000 	str.w	lr, [r3]
 80263a4:	f108 3cff 	add.w	ip, r8, #4294967295
 80263a8:	f040 80ab 	bne.w	8026502 <_malloc_r+0x38e>
 80263ac:	ea1b 0f0c 	tst.w	fp, ip
 80263b0:	f040 80a7 	bne.w	8026502 <_malloc_r+0x38e>
 80263b4:	68b2      	ldr	r2, [r6, #8]
 80263b6:	4449      	add	r1, r9
 80263b8:	f041 0101 	orr.w	r1, r1, #1
 80263bc:	6051      	str	r1, [r2, #4]
 80263be:	4a2d      	ldr	r2, [pc, #180]	; (8026474 <_malloc_r+0x300>)
 80263c0:	681b      	ldr	r3, [r3, #0]
 80263c2:	6811      	ldr	r1, [r2, #0]
 80263c4:	428b      	cmp	r3, r1
 80263c6:	bf88      	it	hi
 80263c8:	6013      	strhi	r3, [r2, #0]
 80263ca:	4a2b      	ldr	r2, [pc, #172]	; (8026478 <_malloc_r+0x304>)
 80263cc:	6811      	ldr	r1, [r2, #0]
 80263ce:	428b      	cmp	r3, r1
 80263d0:	bf88      	it	hi
 80263d2:	6013      	strhi	r3, [r2, #0]
 80263d4:	e0cf      	b.n	8026576 <_malloc_r+0x402>
 80263d6:	f5bc 6f20 	cmp.w	ip, #2560	; 0xa00
 80263da:	ea4f 225c 	mov.w	r2, ip, lsr #9
 80263de:	d218      	bcs.n	8026412 <_malloc_r+0x29e>
 80263e0:	ea4f 129c 	mov.w	r2, ip, lsr #6
 80263e4:	3238      	adds	r2, #56	; 0x38
 80263e6:	f102 0e01 	add.w	lr, r2, #1
 80263ea:	eb06 08c2 	add.w	r8, r6, r2, lsl #3
 80263ee:	f856 e03e 	ldr.w	lr, [r6, lr, lsl #3]
 80263f2:	45f0      	cmp	r8, lr
 80263f4:	d12b      	bne.n	802644e <_malloc_r+0x2da>
 80263f6:	1092      	asrs	r2, r2, #2
 80263f8:	f04f 0c01 	mov.w	ip, #1
 80263fc:	fa0c f202 	lsl.w	r2, ip, r2
 8026400:	4302      	orrs	r2, r0
 8026402:	6072      	str	r2, [r6, #4]
 8026404:	e9c4 e802 	strd	lr, r8, [r4, #8]
 8026408:	f8c8 4008 	str.w	r4, [r8, #8]
 802640c:	f8ce 400c 	str.w	r4, [lr, #12]
 8026410:	e763      	b.n	80262da <_malloc_r+0x166>
 8026412:	2a14      	cmp	r2, #20
 8026414:	d801      	bhi.n	802641a <_malloc_r+0x2a6>
 8026416:	325b      	adds	r2, #91	; 0x5b
 8026418:	e7e5      	b.n	80263e6 <_malloc_r+0x272>
 802641a:	2a54      	cmp	r2, #84	; 0x54
 802641c:	d803      	bhi.n	8026426 <_malloc_r+0x2b2>
 802641e:	ea4f 321c 	mov.w	r2, ip, lsr #12
 8026422:	326e      	adds	r2, #110	; 0x6e
 8026424:	e7df      	b.n	80263e6 <_malloc_r+0x272>
 8026426:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 802642a:	d803      	bhi.n	8026434 <_malloc_r+0x2c0>
 802642c:	ea4f 32dc 	mov.w	r2, ip, lsr #15
 8026430:	3277      	adds	r2, #119	; 0x77
 8026432:	e7d8      	b.n	80263e6 <_malloc_r+0x272>
 8026434:	f240 5e54 	movw	lr, #1364	; 0x554
 8026438:	4572      	cmp	r2, lr
 802643a:	bf9a      	itte	ls
 802643c:	ea4f 429c 	movls.w	r2, ip, lsr #18
 8026440:	327c      	addls	r2, #124	; 0x7c
 8026442:	227e      	movhi	r2, #126	; 0x7e
 8026444:	e7cf      	b.n	80263e6 <_malloc_r+0x272>
 8026446:	f8de e008 	ldr.w	lr, [lr, #8]
 802644a:	45f0      	cmp	r8, lr
 802644c:	d005      	beq.n	802645a <_malloc_r+0x2e6>
 802644e:	f8de 2004 	ldr.w	r2, [lr, #4]
 8026452:	f022 0203 	bic.w	r2, r2, #3
 8026456:	4562      	cmp	r2, ip
 8026458:	d8f5      	bhi.n	8026446 <_malloc_r+0x2d2>
 802645a:	f8de 800c 	ldr.w	r8, [lr, #12]
 802645e:	e7d1      	b.n	8026404 <_malloc_r+0x290>
 8026460:	20000388 	.word	0x20000388
 8026464:	20000390 	.word	0x20000390
 8026468:	20011f14 	.word	0x20011f14
 802646c:	20000790 	.word	0x20000790
 8026470:	20011ee4 	.word	0x20011ee4
 8026474:	20011f0c 	.word	0x20011f0c
 8026478:	20011f10 	.word	0x20011f10
 802647c:	6860      	ldr	r0, [r4, #4]
 802647e:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8026482:	f020 0003 	bic.w	r0, r0, #3
 8026486:	eba0 0a07 	sub.w	sl, r0, r7
 802648a:	f1ba 0f0f 	cmp.w	sl, #15
 802648e:	dd12      	ble.n	80264b6 <_malloc_r+0x342>
 8026490:	68a3      	ldr	r3, [r4, #8]
 8026492:	19e2      	adds	r2, r4, r7
 8026494:	f047 0701 	orr.w	r7, r7, #1
 8026498:	6067      	str	r7, [r4, #4]
 802649a:	f8c3 c00c 	str.w	ip, [r3, #12]
 802649e:	f8cc 3008 	str.w	r3, [ip, #8]
 80264a2:	f04a 0301 	orr.w	r3, sl, #1
 80264a6:	e9c6 2204 	strd	r2, r2, [r6, #16]
 80264aa:	e9c2 1102 	strd	r1, r1, [r2, #8]
 80264ae:	6053      	str	r3, [r2, #4]
 80264b0:	f844 a000 	str.w	sl, [r4, r0]
 80264b4:	e68f      	b.n	80261d6 <_malloc_r+0x62>
 80264b6:	f1ba 0f00 	cmp.w	sl, #0
 80264ba:	db11      	blt.n	80264e0 <_malloc_r+0x36c>
 80264bc:	4420      	add	r0, r4
 80264be:	6843      	ldr	r3, [r0, #4]
 80264c0:	f043 0301 	orr.w	r3, r3, #1
 80264c4:	6043      	str	r3, [r0, #4]
 80264c6:	f854 3f08 	ldr.w	r3, [r4, #8]!
 80264ca:	4628      	mov	r0, r5
 80264cc:	f8c3 c00c 	str.w	ip, [r3, #12]
 80264d0:	f8cc 3008 	str.w	r3, [ip, #8]
 80264d4:	f000 f88e 	bl	80265f4 <__malloc_unlock>
 80264d8:	4620      	mov	r0, r4
 80264da:	b003      	add	sp, #12
 80264dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80264e0:	4664      	mov	r4, ip
 80264e2:	e70f      	b.n	8026304 <_malloc_r+0x190>
 80264e4:	f858 0908 	ldr.w	r0, [r8], #-8
 80264e8:	4540      	cmp	r0, r8
 80264ea:	f103 33ff 	add.w	r3, r3, #4294967295
 80264ee:	f43f af13 	beq.w	8026318 <_malloc_r+0x1a4>
 80264f2:	e718      	b.n	8026326 <_malloc_r+0x1b2>
 80264f4:	3304      	adds	r3, #4
 80264f6:	0052      	lsls	r2, r2, #1
 80264f8:	4210      	tst	r0, r2
 80264fa:	d0fb      	beq.n	80264f4 <_malloc_r+0x380>
 80264fc:	e6fc      	b.n	80262f8 <_malloc_r+0x184>
 80264fe:	4673      	mov	r3, lr
 8026500:	e7fa      	b.n	80264f8 <_malloc_r+0x384>
 8026502:	6810      	ldr	r0, [r2, #0]
 8026504:	3001      	adds	r0, #1
 8026506:	bf1b      	ittet	ne
 8026508:	eba4 0b0b 	subne.w	fp, r4, fp
 802650c:	eb0b 020e 	addne.w	r2, fp, lr
 8026510:	6014      	streq	r4, [r2, #0]
 8026512:	601a      	strne	r2, [r3, #0]
 8026514:	f014 0b07 	ands.w	fp, r4, #7
 8026518:	bf1a      	itte	ne
 802651a:	f1cb 0008 	rsbne	r0, fp, #8
 802651e:	1824      	addne	r4, r4, r0
 8026520:	4658      	moveq	r0, fp
 8026522:	1862      	adds	r2, r4, r1
 8026524:	ea02 010c 	and.w	r1, r2, ip
 8026528:	4480      	add	r8, r0
 802652a:	eba8 0801 	sub.w	r8, r8, r1
 802652e:	ea08 080c 	and.w	r8, r8, ip
 8026532:	4641      	mov	r1, r8
 8026534:	4628      	mov	r0, r5
 8026536:	9201      	str	r2, [sp, #4]
 8026538:	f001 fb78 	bl	8027c2c <_sbrk_r>
 802653c:	1c43      	adds	r3, r0, #1
 802653e:	9a01      	ldr	r2, [sp, #4]
 8026540:	4b28      	ldr	r3, [pc, #160]	; (80265e4 <_malloc_r+0x470>)
 8026542:	d107      	bne.n	8026554 <_malloc_r+0x3e0>
 8026544:	f1bb 0f00 	cmp.w	fp, #0
 8026548:	d023      	beq.n	8026592 <_malloc_r+0x41e>
 802654a:	f1ab 0008 	sub.w	r0, fp, #8
 802654e:	4410      	add	r0, r2
 8026550:	f04f 0800 	mov.w	r8, #0
 8026554:	681a      	ldr	r2, [r3, #0]
 8026556:	60b4      	str	r4, [r6, #8]
 8026558:	1b00      	subs	r0, r0, r4
 802655a:	4440      	add	r0, r8
 802655c:	4442      	add	r2, r8
 802655e:	f040 0001 	orr.w	r0, r0, #1
 8026562:	45b2      	cmp	sl, r6
 8026564:	601a      	str	r2, [r3, #0]
 8026566:	6060      	str	r0, [r4, #4]
 8026568:	f43f af29 	beq.w	80263be <_malloc_r+0x24a>
 802656c:	f1b9 0f0f 	cmp.w	r9, #15
 8026570:	d812      	bhi.n	8026598 <_malloc_r+0x424>
 8026572:	2301      	movs	r3, #1
 8026574:	6063      	str	r3, [r4, #4]
 8026576:	68b3      	ldr	r3, [r6, #8]
 8026578:	685b      	ldr	r3, [r3, #4]
 802657a:	f023 0303 	bic.w	r3, r3, #3
 802657e:	42bb      	cmp	r3, r7
 8026580:	eba3 0207 	sub.w	r2, r3, r7
 8026584:	d301      	bcc.n	802658a <_malloc_r+0x416>
 8026586:	2a0f      	cmp	r2, #15
 8026588:	dc22      	bgt.n	80265d0 <_malloc_r+0x45c>
 802658a:	4628      	mov	r0, r5
 802658c:	f000 f832 	bl	80265f4 <__malloc_unlock>
 8026590:	e5fc      	b.n	802618c <_malloc_r+0x18>
 8026592:	4610      	mov	r0, r2
 8026594:	46d8      	mov	r8, fp
 8026596:	e7dd      	b.n	8026554 <_malloc_r+0x3e0>
 8026598:	f8da 2004 	ldr.w	r2, [sl, #4]
 802659c:	f1a9 090c 	sub.w	r9, r9, #12
 80265a0:	f029 0907 	bic.w	r9, r9, #7
 80265a4:	f002 0201 	and.w	r2, r2, #1
 80265a8:	ea42 0209 	orr.w	r2, r2, r9
 80265ac:	f8ca 2004 	str.w	r2, [sl, #4]
 80265b0:	2105      	movs	r1, #5
 80265b2:	eb0a 0209 	add.w	r2, sl, r9
 80265b6:	f1b9 0f0f 	cmp.w	r9, #15
 80265ba:	e9c2 1101 	strd	r1, r1, [r2, #4]
 80265be:	f67f aefe 	bls.w	80263be <_malloc_r+0x24a>
 80265c2:	f10a 0108 	add.w	r1, sl, #8
 80265c6:	4628      	mov	r0, r5
 80265c8:	f7ff fd14 	bl	8025ff4 <_free_r>
 80265cc:	4b05      	ldr	r3, [pc, #20]	; (80265e4 <_malloc_r+0x470>)
 80265ce:	e6f6      	b.n	80263be <_malloc_r+0x24a>
 80265d0:	68b4      	ldr	r4, [r6, #8]
 80265d2:	f047 0301 	orr.w	r3, r7, #1
 80265d6:	4427      	add	r7, r4
 80265d8:	f042 0201 	orr.w	r2, r2, #1
 80265dc:	6063      	str	r3, [r4, #4]
 80265de:	60b7      	str	r7, [r6, #8]
 80265e0:	607a      	str	r2, [r7, #4]
 80265e2:	e5f8      	b.n	80261d6 <_malloc_r+0x62>
 80265e4:	20011ee4 	.word	0x20011ee4

080265e8 <__malloc_lock>:
 80265e8:	4801      	ldr	r0, [pc, #4]	; (80265f0 <__malloc_lock+0x8>)
 80265ea:	f7ff bc87 	b.w	8025efc <__retarget_lock_acquire_recursive>
 80265ee:	bf00      	nop
 80265f0:	20011edd 	.word	0x20011edd

080265f4 <__malloc_unlock>:
 80265f4:	4801      	ldr	r0, [pc, #4]	; (80265fc <__malloc_unlock+0x8>)
 80265f6:	f7ff bc82 	b.w	8025efe <__retarget_lock_release_recursive>
 80265fa:	bf00      	nop
 80265fc:	20011edd 	.word	0x20011edd

08026600 <_svfprintf_r>:
 8026600:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026604:	ed2d 8b04 	vpush	{d8-d9}
 8026608:	b0cf      	sub	sp, #316	; 0x13c
 802660a:	4689      	mov	r9, r1
 802660c:	9203      	str	r2, [sp, #12]
 802660e:	461d      	mov	r5, r3
 8026610:	4682      	mov	sl, r0
 8026612:	f001 fb07 	bl	8027c24 <_localeconv_r>
 8026616:	6803      	ldr	r3, [r0, #0]
 8026618:	9313      	str	r3, [sp, #76]	; 0x4c
 802661a:	4618      	mov	r0, r3
 802661c:	f7d9 fdea 	bl	80001f4 <strlen>
 8026620:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8026624:	900e      	str	r0, [sp, #56]	; 0x38
 8026626:	0619      	lsls	r1, r3, #24
 8026628:	d51a      	bpl.n	8026660 <_svfprintf_r+0x60>
 802662a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 802662e:	b9bb      	cbnz	r3, 8026660 <_svfprintf_r+0x60>
 8026630:	2140      	movs	r1, #64	; 0x40
 8026632:	4650      	mov	r0, sl
 8026634:	f7ff fd9e 	bl	8026174 <_malloc_r>
 8026638:	f8c9 0000 	str.w	r0, [r9]
 802663c:	f8c9 0010 	str.w	r0, [r9, #16]
 8026640:	b958      	cbnz	r0, 802665a <_svfprintf_r+0x5a>
 8026642:	230c      	movs	r3, #12
 8026644:	f8ca 3000 	str.w	r3, [sl]
 8026648:	f04f 33ff 	mov.w	r3, #4294967295
 802664c:	930b      	str	r3, [sp, #44]	; 0x2c
 802664e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8026650:	b04f      	add	sp, #316	; 0x13c
 8026652:	ecbd 8b04 	vpop	{d8-d9}
 8026656:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802665a:	2340      	movs	r3, #64	; 0x40
 802665c:	f8c9 3014 	str.w	r3, [r9, #20]
 8026660:	ed9f 7b91 	vldr	d7, [pc, #580]	; 80268a8 <_svfprintf_r+0x2a8>
 8026664:	2300      	movs	r3, #0
 8026666:	e9cd 3323 	strd	r3, r3, [sp, #140]	; 0x8c
 802666a:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 802666e:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
 8026672:	ac25      	add	r4, sp, #148	; 0x94
 8026674:	9422      	str	r4, [sp, #136]	; 0x88
 8026676:	9305      	str	r3, [sp, #20]
 8026678:	9309      	str	r3, [sp, #36]	; 0x24
 802667a:	9311      	str	r3, [sp, #68]	; 0x44
 802667c:	9314      	str	r3, [sp, #80]	; 0x50
 802667e:	930b      	str	r3, [sp, #44]	; 0x2c
 8026680:	9b03      	ldr	r3, [sp, #12]
 8026682:	461e      	mov	r6, r3
 8026684:	f813 2b01 	ldrb.w	r2, [r3], #1
 8026688:	b10a      	cbz	r2, 802668e <_svfprintf_r+0x8e>
 802668a:	2a25      	cmp	r2, #37	; 0x25
 802668c:	d1f9      	bne.n	8026682 <_svfprintf_r+0x82>
 802668e:	9b03      	ldr	r3, [sp, #12]
 8026690:	1af7      	subs	r7, r6, r3
 8026692:	d00d      	beq.n	80266b0 <_svfprintf_r+0xb0>
 8026694:	e9c4 3700 	strd	r3, r7, [r4]
 8026698:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802669a:	443b      	add	r3, r7
 802669c:	9324      	str	r3, [sp, #144]	; 0x90
 802669e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80266a0:	3301      	adds	r3, #1
 80266a2:	2b07      	cmp	r3, #7
 80266a4:	9323      	str	r3, [sp, #140]	; 0x8c
 80266a6:	dc78      	bgt.n	802679a <_svfprintf_r+0x19a>
 80266a8:	3408      	adds	r4, #8
 80266aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80266ac:	443b      	add	r3, r7
 80266ae:	930b      	str	r3, [sp, #44]	; 0x2c
 80266b0:	7833      	ldrb	r3, [r6, #0]
 80266b2:	2b00      	cmp	r3, #0
 80266b4:	f001 815a 	beq.w	802796c <_svfprintf_r+0x136c>
 80266b8:	2300      	movs	r3, #0
 80266ba:	3601      	adds	r6, #1
 80266bc:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80266c0:	f04f 38ff 	mov.w	r8, #4294967295
 80266c4:	930f      	str	r3, [sp, #60]	; 0x3c
 80266c6:	469b      	mov	fp, r3
 80266c8:	270a      	movs	r7, #10
 80266ca:	212b      	movs	r1, #43	; 0x2b
 80266cc:	4633      	mov	r3, r6
 80266ce:	f813 2b01 	ldrb.w	r2, [r3], #1
 80266d2:	9207      	str	r2, [sp, #28]
 80266d4:	930a      	str	r3, [sp, #40]	; 0x28
 80266d6:	9b07      	ldr	r3, [sp, #28]
 80266d8:	3b20      	subs	r3, #32
 80266da:	2b5a      	cmp	r3, #90	; 0x5a
 80266dc:	f200 85c6 	bhi.w	802726c <_svfprintf_r+0xc6c>
 80266e0:	e8df f013 	tbh	[pc, r3, lsl #1]
 80266e4:	05c4007e 	.word	0x05c4007e
 80266e8:	008605c4 	.word	0x008605c4
 80266ec:	05c405c4 	.word	0x05c405c4
 80266f0:	006505c4 	.word	0x006505c4
 80266f4:	05c405c4 	.word	0x05c405c4
 80266f8:	00930089 	.word	0x00930089
 80266fc:	009005c4 	.word	0x009005c4
 8026700:	05c40096 	.word	0x05c40096
 8026704:	00b200af 	.word	0x00b200af
 8026708:	00b200b2 	.word	0x00b200b2
 802670c:	00b200b2 	.word	0x00b200b2
 8026710:	00b200b2 	.word	0x00b200b2
 8026714:	00b200b2 	.word	0x00b200b2
 8026718:	05c405c4 	.word	0x05c405c4
 802671c:	05c405c4 	.word	0x05c405c4
 8026720:	05c405c4 	.word	0x05c405c4
 8026724:	012905c4 	.word	0x012905c4
 8026728:	00e605c4 	.word	0x00e605c4
 802672c:	012900f9 	.word	0x012900f9
 8026730:	01290129 	.word	0x01290129
 8026734:	05c405c4 	.word	0x05c405c4
 8026738:	05c405c4 	.word	0x05c405c4
 802673c:	05c400c2 	.word	0x05c400c2
 8026740:	049105c4 	.word	0x049105c4
 8026744:	05c405c4 	.word	0x05c405c4
 8026748:	04db05c4 	.word	0x04db05c4
 802674c:	050105c4 	.word	0x050105c4
 8026750:	05c405c4 	.word	0x05c405c4
 8026754:	05c40523 	.word	0x05c40523
 8026758:	05c405c4 	.word	0x05c405c4
 802675c:	05c405c4 	.word	0x05c405c4
 8026760:	05c405c4 	.word	0x05c405c4
 8026764:	012905c4 	.word	0x012905c4
 8026768:	00e605c4 	.word	0x00e605c4
 802676c:	012900fb 	.word	0x012900fb
 8026770:	01290129 	.word	0x01290129
 8026774:	00fb00c5 	.word	0x00fb00c5
 8026778:	05c400d9 	.word	0x05c400d9
 802677c:	05c400d2 	.word	0x05c400d2
 8026780:	0493046c 	.word	0x0493046c
 8026784:	00d904ca 	.word	0x00d904ca
 8026788:	04db05c4 	.word	0x04db05c4
 802678c:	0503007c 	.word	0x0503007c
 8026790:	05c405c4 	.word	0x05c405c4
 8026794:	05c40542 	.word	0x05c40542
 8026798:	007c      	.short	0x007c
 802679a:	aa22      	add	r2, sp, #136	; 0x88
 802679c:	4649      	mov	r1, r9
 802679e:	4650      	mov	r0, sl
 80267a0:	f002 fe41 	bl	8029426 <__ssprint_r>
 80267a4:	2800      	cmp	r0, #0
 80267a6:	f040 8137 	bne.w	8026a18 <_svfprintf_r+0x418>
 80267aa:	ac25      	add	r4, sp, #148	; 0x94
 80267ac:	e77d      	b.n	80266aa <_svfprintf_r+0xaa>
 80267ae:	4650      	mov	r0, sl
 80267b0:	f001 fa38 	bl	8027c24 <_localeconv_r>
 80267b4:	6843      	ldr	r3, [r0, #4]
 80267b6:	9314      	str	r3, [sp, #80]	; 0x50
 80267b8:	4618      	mov	r0, r3
 80267ba:	f7d9 fd1b 	bl	80001f4 <strlen>
 80267be:	9011      	str	r0, [sp, #68]	; 0x44
 80267c0:	4650      	mov	r0, sl
 80267c2:	f001 fa2f 	bl	8027c24 <_localeconv_r>
 80267c6:	6883      	ldr	r3, [r0, #8]
 80267c8:	9309      	str	r3, [sp, #36]	; 0x24
 80267ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80267cc:	212b      	movs	r1, #43	; 0x2b
 80267ce:	b12b      	cbz	r3, 80267dc <_svfprintf_r+0x1dc>
 80267d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80267d2:	b11b      	cbz	r3, 80267dc <_svfprintf_r+0x1dc>
 80267d4:	781b      	ldrb	r3, [r3, #0]
 80267d6:	b10b      	cbz	r3, 80267dc <_svfprintf_r+0x1dc>
 80267d8:	f44b 6b80 	orr.w	fp, fp, #1024	; 0x400
 80267dc:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80267de:	e775      	b.n	80266cc <_svfprintf_r+0xcc>
 80267e0:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 80267e4:	2b00      	cmp	r3, #0
 80267e6:	d1f9      	bne.n	80267dc <_svfprintf_r+0x1dc>
 80267e8:	2320      	movs	r3, #32
 80267ea:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80267ee:	e7f5      	b.n	80267dc <_svfprintf_r+0x1dc>
 80267f0:	f04b 0b01 	orr.w	fp, fp, #1
 80267f4:	e7f2      	b.n	80267dc <_svfprintf_r+0x1dc>
 80267f6:	f855 3b04 	ldr.w	r3, [r5], #4
 80267fa:	930f      	str	r3, [sp, #60]	; 0x3c
 80267fc:	2b00      	cmp	r3, #0
 80267fe:	daed      	bge.n	80267dc <_svfprintf_r+0x1dc>
 8026800:	425b      	negs	r3, r3
 8026802:	930f      	str	r3, [sp, #60]	; 0x3c
 8026804:	f04b 0b04 	orr.w	fp, fp, #4
 8026808:	e7e8      	b.n	80267dc <_svfprintf_r+0x1dc>
 802680a:	f88d 106b 	strb.w	r1, [sp, #107]	; 0x6b
 802680e:	e7e5      	b.n	80267dc <_svfprintf_r+0x1dc>
 8026810:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026812:	f813 2b01 	ldrb.w	r2, [r3], #1
 8026816:	9207      	str	r2, [sp, #28]
 8026818:	2a2a      	cmp	r2, #42	; 0x2a
 802681a:	d10f      	bne.n	802683c <_svfprintf_r+0x23c>
 802681c:	f855 2b04 	ldr.w	r2, [r5], #4
 8026820:	930a      	str	r3, [sp, #40]	; 0x28
 8026822:	ea42 78e2 	orr.w	r8, r2, r2, asr #31
 8026826:	e7d9      	b.n	80267dc <_svfprintf_r+0x1dc>
 8026828:	fb07 2808 	mla	r8, r7, r8, r2
 802682c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8026830:	9207      	str	r2, [sp, #28]
 8026832:	9a07      	ldr	r2, [sp, #28]
 8026834:	3a30      	subs	r2, #48	; 0x30
 8026836:	2a09      	cmp	r2, #9
 8026838:	d9f6      	bls.n	8026828 <_svfprintf_r+0x228>
 802683a:	e74b      	b.n	80266d4 <_svfprintf_r+0xd4>
 802683c:	f04f 0800 	mov.w	r8, #0
 8026840:	e7f7      	b.n	8026832 <_svfprintf_r+0x232>
 8026842:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 8026846:	e7c9      	b.n	80267dc <_svfprintf_r+0x1dc>
 8026848:	2200      	movs	r2, #0
 802684a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802684c:	920f      	str	r2, [sp, #60]	; 0x3c
 802684e:	9a07      	ldr	r2, [sp, #28]
 8026850:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8026852:	3a30      	subs	r2, #48	; 0x30
 8026854:	fb07 2200 	mla	r2, r7, r0, r2
 8026858:	920f      	str	r2, [sp, #60]	; 0x3c
 802685a:	f813 2b01 	ldrb.w	r2, [r3], #1
 802685e:	9207      	str	r2, [sp, #28]
 8026860:	3a30      	subs	r2, #48	; 0x30
 8026862:	2a09      	cmp	r2, #9
 8026864:	d9f3      	bls.n	802684e <_svfprintf_r+0x24e>
 8026866:	e735      	b.n	80266d4 <_svfprintf_r+0xd4>
 8026868:	f04b 0b08 	orr.w	fp, fp, #8
 802686c:	e7b6      	b.n	80267dc <_svfprintf_r+0x1dc>
 802686e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026870:	781b      	ldrb	r3, [r3, #0]
 8026872:	2b68      	cmp	r3, #104	; 0x68
 8026874:	bf01      	itttt	eq
 8026876:	9b0a      	ldreq	r3, [sp, #40]	; 0x28
 8026878:	3301      	addeq	r3, #1
 802687a:	930a      	streq	r3, [sp, #40]	; 0x28
 802687c:	f44b 7b00 	orreq.w	fp, fp, #512	; 0x200
 8026880:	bf18      	it	ne
 8026882:	f04b 0b40 	orrne.w	fp, fp, #64	; 0x40
 8026886:	e7a9      	b.n	80267dc <_svfprintf_r+0x1dc>
 8026888:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802688a:	781b      	ldrb	r3, [r3, #0]
 802688c:	2b6c      	cmp	r3, #108	; 0x6c
 802688e:	d105      	bne.n	802689c <_svfprintf_r+0x29c>
 8026890:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026892:	3301      	adds	r3, #1
 8026894:	930a      	str	r3, [sp, #40]	; 0x28
 8026896:	f04b 0b20 	orr.w	fp, fp, #32
 802689a:	e79f      	b.n	80267dc <_svfprintf_r+0x1dc>
 802689c:	f04b 0b10 	orr.w	fp, fp, #16
 80268a0:	e79c      	b.n	80267dc <_svfprintf_r+0x1dc>
 80268a2:	bf00      	nop
 80268a4:	f3af 8000 	nop.w
	...
 80268b0:	462a      	mov	r2, r5
 80268b2:	f852 3b04 	ldr.w	r3, [r2], #4
 80268b6:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 80268ba:	2300      	movs	r3, #0
 80268bc:	9206      	str	r2, [sp, #24]
 80268be:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80268c2:	9304      	str	r3, [sp, #16]
 80268c4:	461f      	mov	r7, r3
 80268c6:	461e      	mov	r6, r3
 80268c8:	9308      	str	r3, [sp, #32]
 80268ca:	461d      	mov	r5, r3
 80268cc:	ab35      	add	r3, sp, #212	; 0xd4
 80268ce:	f04f 0801 	mov.w	r8, #1
 80268d2:	9303      	str	r3, [sp, #12]
 80268d4:	e1b9      	b.n	8026c4a <_svfprintf_r+0x64a>
 80268d6:	f04b 0b10 	orr.w	fp, fp, #16
 80268da:	f01b 0f20 	tst.w	fp, #32
 80268de:	d012      	beq.n	8026906 <_svfprintf_r+0x306>
 80268e0:	3507      	adds	r5, #7
 80268e2:	f025 0307 	bic.w	r3, r5, #7
 80268e6:	461a      	mov	r2, r3
 80268e8:	685e      	ldr	r6, [r3, #4]
 80268ea:	f852 5b08 	ldr.w	r5, [r2], #8
 80268ee:	9206      	str	r2, [sp, #24]
 80268f0:	2e00      	cmp	r6, #0
 80268f2:	da06      	bge.n	8026902 <_svfprintf_r+0x302>
 80268f4:	426d      	negs	r5, r5
 80268f6:	f04f 032d 	mov.w	r3, #45	; 0x2d
 80268fa:	eb66 0646 	sbc.w	r6, r6, r6, lsl #1
 80268fe:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8026902:	2301      	movs	r3, #1
 8026904:	e392      	b.n	802702c <_svfprintf_r+0xa2c>
 8026906:	462b      	mov	r3, r5
 8026908:	f01b 0f10 	tst.w	fp, #16
 802690c:	f853 6b04 	ldr.w	r6, [r3], #4
 8026910:	9306      	str	r3, [sp, #24]
 8026912:	d002      	beq.n	802691a <_svfprintf_r+0x31a>
 8026914:	4635      	mov	r5, r6
 8026916:	17f6      	asrs	r6, r6, #31
 8026918:	e7ea      	b.n	80268f0 <_svfprintf_r+0x2f0>
 802691a:	f01b 0f40 	tst.w	fp, #64	; 0x40
 802691e:	d003      	beq.n	8026928 <_svfprintf_r+0x328>
 8026920:	b235      	sxth	r5, r6
 8026922:	f346 36c0 	sbfx	r6, r6, #15, #1
 8026926:	e7e3      	b.n	80268f0 <_svfprintf_r+0x2f0>
 8026928:	f41b 7f00 	tst.w	fp, #512	; 0x200
 802692c:	d0f2      	beq.n	8026914 <_svfprintf_r+0x314>
 802692e:	b275      	sxtb	r5, r6
 8026930:	f346 16c0 	sbfx	r6, r6, #7, #1
 8026934:	e7dc      	b.n	80268f0 <_svfprintf_r+0x2f0>
 8026936:	3507      	adds	r5, #7
 8026938:	f025 0307 	bic.w	r3, r5, #7
 802693c:	ecb3 7b02 	vldmia	r3!, {d7}
 8026940:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8026944:	9306      	str	r3, [sp, #24]
 8026946:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026948:	ee09 3a10 	vmov	s18, r3
 802694c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802694e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026952:	ee09 3a90 	vmov	s19, r3
 8026956:	f04f 32ff 	mov.w	r2, #4294967295
 802695a:	4b34      	ldr	r3, [pc, #208]	; (8026a2c <_svfprintf_r+0x42c>)
 802695c:	ec51 0b19 	vmov	r0, r1, d9
 8026960:	f7da f8fc 	bl	8000b5c <__aeabi_dcmpun>
 8026964:	bb18      	cbnz	r0, 80269ae <_svfprintf_r+0x3ae>
 8026966:	4b31      	ldr	r3, [pc, #196]	; (8026a2c <_svfprintf_r+0x42c>)
 8026968:	ec51 0b19 	vmov	r0, r1, d9
 802696c:	f04f 32ff 	mov.w	r2, #4294967295
 8026970:	f7da f8d6 	bl	8000b20 <__aeabi_dcmple>
 8026974:	b9d8      	cbnz	r0, 80269ae <_svfprintf_r+0x3ae>
 8026976:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 802697a:	2200      	movs	r2, #0
 802697c:	2300      	movs	r3, #0
 802697e:	f7da f8c5 	bl	8000b0c <__aeabi_dcmplt>
 8026982:	b110      	cbz	r0, 802698a <_svfprintf_r+0x38a>
 8026984:	232d      	movs	r3, #45	; 0x2d
 8026986:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 802698a:	4a29      	ldr	r2, [pc, #164]	; (8026a30 <_svfprintf_r+0x430>)
 802698c:	4b29      	ldr	r3, [pc, #164]	; (8026a34 <_svfprintf_r+0x434>)
 802698e:	9907      	ldr	r1, [sp, #28]
 8026990:	2947      	cmp	r1, #71	; 0x47
 8026992:	bfc8      	it	gt
 8026994:	461a      	movgt	r2, r3
 8026996:	2300      	movs	r3, #0
 8026998:	9203      	str	r2, [sp, #12]
 802699a:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
 802699e:	9304      	str	r3, [sp, #16]
 80269a0:	f04f 0803 	mov.w	r8, #3
 80269a4:	461f      	mov	r7, r3
 80269a6:	461e      	mov	r6, r3
 80269a8:	9308      	str	r3, [sp, #32]
 80269aa:	461d      	mov	r5, r3
 80269ac:	e14d      	b.n	8026c4a <_svfprintf_r+0x64a>
 80269ae:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80269b2:	4610      	mov	r0, r2
 80269b4:	4619      	mov	r1, r3
 80269b6:	f7da f8d1 	bl	8000b5c <__aeabi_dcmpun>
 80269ba:	b140      	cbz	r0, 80269ce <_svfprintf_r+0x3ce>
 80269bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80269be:	4a1e      	ldr	r2, [pc, #120]	; (8026a38 <_svfprintf_r+0x438>)
 80269c0:	2b00      	cmp	r3, #0
 80269c2:	bfbc      	itt	lt
 80269c4:	232d      	movlt	r3, #45	; 0x2d
 80269c6:	f88d 306b 	strblt.w	r3, [sp, #107]	; 0x6b
 80269ca:	4b1c      	ldr	r3, [pc, #112]	; (8026a3c <_svfprintf_r+0x43c>)
 80269cc:	e7df      	b.n	802698e <_svfprintf_r+0x38e>
 80269ce:	9b07      	ldr	r3, [sp, #28]
 80269d0:	f023 0320 	bic.w	r3, r3, #32
 80269d4:	2b41      	cmp	r3, #65	; 0x41
 80269d6:	9308      	str	r3, [sp, #32]
 80269d8:	d132      	bne.n	8026a40 <_svfprintf_r+0x440>
 80269da:	2330      	movs	r3, #48	; 0x30
 80269dc:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 80269e0:	9b07      	ldr	r3, [sp, #28]
 80269e2:	2b61      	cmp	r3, #97	; 0x61
 80269e4:	bf0c      	ite	eq
 80269e6:	2378      	moveq	r3, #120	; 0x78
 80269e8:	2358      	movne	r3, #88	; 0x58
 80269ea:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
 80269ee:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 80269f2:	f04b 0b02 	orr.w	fp, fp, #2
 80269f6:	f340 8204 	ble.w	8026e02 <_svfprintf_r+0x802>
 80269fa:	f108 0101 	add.w	r1, r8, #1
 80269fe:	4650      	mov	r0, sl
 8026a00:	f7ff fbb8 	bl	8026174 <_malloc_r>
 8026a04:	9003      	str	r0, [sp, #12]
 8026a06:	2800      	cmp	r0, #0
 8026a08:	f040 81ff 	bne.w	8026e0a <_svfprintf_r+0x80a>
 8026a0c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8026a10:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8026a14:	f8a9 300c 	strh.w	r3, [r9, #12]
 8026a18:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8026a1c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8026a20:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026a22:	bf18      	it	ne
 8026a24:	f04f 33ff 	movne.w	r3, #4294967295
 8026a28:	e610      	b.n	802664c <_svfprintf_r+0x4c>
 8026a2a:	bf00      	nop
 8026a2c:	7fefffff 	.word	0x7fefffff
 8026a30:	0803651d 	.word	0x0803651d
 8026a34:	08036521 	.word	0x08036521
 8026a38:	08036525 	.word	0x08036525
 8026a3c:	08036529 	.word	0x08036529
 8026a40:	f1b8 3fff 	cmp.w	r8, #4294967295
 8026a44:	f000 81e4 	beq.w	8026e10 <_svfprintf_r+0x810>
 8026a48:	9b08      	ldr	r3, [sp, #32]
 8026a4a:	2b47      	cmp	r3, #71	; 0x47
 8026a4c:	f040 81e4 	bne.w	8026e18 <_svfprintf_r+0x818>
 8026a50:	f1b8 0f00 	cmp.w	r8, #0
 8026a54:	f040 81e0 	bne.w	8026e18 <_svfprintf_r+0x818>
 8026a58:	f8cd 8010 	str.w	r8, [sp, #16]
 8026a5c:	f04f 0801 	mov.w	r8, #1
 8026a60:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
 8026a64:	9310      	str	r3, [sp, #64]	; 0x40
 8026a66:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8026a68:	2b00      	cmp	r3, #0
 8026a6a:	f280 81d7 	bge.w	8026e1c <_svfprintf_r+0x81c>
 8026a6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026a70:	ee08 3a10 	vmov	s16, r3
 8026a74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8026a76:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8026a7a:	ee08 3a90 	vmov	s17, r3
 8026a7e:	232d      	movs	r3, #45	; 0x2d
 8026a80:	9318      	str	r3, [sp, #96]	; 0x60
 8026a82:	9b08      	ldr	r3, [sp, #32]
 8026a84:	2b41      	cmp	r3, #65	; 0x41
 8026a86:	f040 81e7 	bne.w	8026e58 <_svfprintf_r+0x858>
 8026a8a:	eeb0 0a48 	vmov.f32	s0, s16
 8026a8e:	eef0 0a68 	vmov.f32	s1, s17
 8026a92:	a81c      	add	r0, sp, #112	; 0x70
 8026a94:	f001 f8fa 	bl	8027c8c <frexp>
 8026a98:	2200      	movs	r2, #0
 8026a9a:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8026a9e:	ec51 0b10 	vmov	r0, r1, d0
 8026aa2:	f7d9 fdc1 	bl	8000628 <__aeabi_dmul>
 8026aa6:	2200      	movs	r2, #0
 8026aa8:	2300      	movs	r3, #0
 8026aaa:	4606      	mov	r6, r0
 8026aac:	460f      	mov	r7, r1
 8026aae:	f7da f823 	bl	8000af8 <__aeabi_dcmpeq>
 8026ab2:	b108      	cbz	r0, 8026ab8 <_svfprintf_r+0x4b8>
 8026ab4:	2301      	movs	r3, #1
 8026ab6:	931c      	str	r3, [sp, #112]	; 0x70
 8026ab8:	4bac      	ldr	r3, [pc, #688]	; (8026d6c <_svfprintf_r+0x76c>)
 8026aba:	4aad      	ldr	r2, [pc, #692]	; (8026d70 <_svfprintf_r+0x770>)
 8026abc:	9907      	ldr	r1, [sp, #28]
 8026abe:	9d03      	ldr	r5, [sp, #12]
 8026ac0:	2961      	cmp	r1, #97	; 0x61
 8026ac2:	bf18      	it	ne
 8026ac4:	461a      	movne	r2, r3
 8026ac6:	f108 33ff 	add.w	r3, r8, #4294967295
 8026aca:	9217      	str	r2, [sp, #92]	; 0x5c
 8026acc:	9305      	str	r3, [sp, #20]
 8026ace:	4ba9      	ldr	r3, [pc, #676]	; (8026d74 <_svfprintf_r+0x774>)
 8026ad0:	2200      	movs	r2, #0
 8026ad2:	4630      	mov	r0, r6
 8026ad4:	4639      	mov	r1, r7
 8026ad6:	f7d9 fda7 	bl	8000628 <__aeabi_dmul>
 8026ada:	460f      	mov	r7, r1
 8026adc:	4606      	mov	r6, r0
 8026ade:	f7da f853 	bl	8000b88 <__aeabi_d2iz>
 8026ae2:	9019      	str	r0, [sp, #100]	; 0x64
 8026ae4:	f7d9 fd36 	bl	8000554 <__aeabi_i2d>
 8026ae8:	4602      	mov	r2, r0
 8026aea:	460b      	mov	r3, r1
 8026aec:	4630      	mov	r0, r6
 8026aee:	4639      	mov	r1, r7
 8026af0:	f7d9 fbe2 	bl	80002b8 <__aeabi_dsub>
 8026af4:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8026af6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8026af8:	5c9b      	ldrb	r3, [r3, r2]
 8026afa:	f805 3b01 	strb.w	r3, [r5], #1
 8026afe:	9b05      	ldr	r3, [sp, #20]
 8026b00:	9312      	str	r3, [sp, #72]	; 0x48
 8026b02:	1c5a      	adds	r2, r3, #1
 8026b04:	4606      	mov	r6, r0
 8026b06:	460f      	mov	r7, r1
 8026b08:	d007      	beq.n	8026b1a <_svfprintf_r+0x51a>
 8026b0a:	3b01      	subs	r3, #1
 8026b0c:	9305      	str	r3, [sp, #20]
 8026b0e:	2200      	movs	r2, #0
 8026b10:	2300      	movs	r3, #0
 8026b12:	f7d9 fff1 	bl	8000af8 <__aeabi_dcmpeq>
 8026b16:	2800      	cmp	r0, #0
 8026b18:	d0d9      	beq.n	8026ace <_svfprintf_r+0x4ce>
 8026b1a:	4b97      	ldr	r3, [pc, #604]	; (8026d78 <_svfprintf_r+0x778>)
 8026b1c:	2200      	movs	r2, #0
 8026b1e:	4630      	mov	r0, r6
 8026b20:	4639      	mov	r1, r7
 8026b22:	f7da f811 	bl	8000b48 <__aeabi_dcmpgt>
 8026b26:	b960      	cbnz	r0, 8026b42 <_svfprintf_r+0x542>
 8026b28:	4b93      	ldr	r3, [pc, #588]	; (8026d78 <_svfprintf_r+0x778>)
 8026b2a:	2200      	movs	r2, #0
 8026b2c:	4630      	mov	r0, r6
 8026b2e:	4639      	mov	r1, r7
 8026b30:	f7d9 ffe2 	bl	8000af8 <__aeabi_dcmpeq>
 8026b34:	2800      	cmp	r0, #0
 8026b36:	f000 818a 	beq.w	8026e4e <_svfprintf_r+0x84e>
 8026b3a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8026b3c:	07de      	lsls	r6, r3, #31
 8026b3e:	f140 8186 	bpl.w	8026e4e <_svfprintf_r+0x84e>
 8026b42:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8026b44:	9520      	str	r5, [sp, #128]	; 0x80
 8026b46:	7bd9      	ldrb	r1, [r3, #15]
 8026b48:	2030      	movs	r0, #48	; 0x30
 8026b4a:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8026b4c:	1e53      	subs	r3, r2, #1
 8026b4e:	9320      	str	r3, [sp, #128]	; 0x80
 8026b50:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 8026b54:	428b      	cmp	r3, r1
 8026b56:	f000 8169 	beq.w	8026e2c <_svfprintf_r+0x82c>
 8026b5a:	2b39      	cmp	r3, #57	; 0x39
 8026b5c:	bf0b      	itete	eq
 8026b5e:	9b17      	ldreq	r3, [sp, #92]	; 0x5c
 8026b60:	3301      	addne	r3, #1
 8026b62:	7a9b      	ldrbeq	r3, [r3, #10]
 8026b64:	b2db      	uxtbne	r3, r3
 8026b66:	f802 3c01 	strb.w	r3, [r2, #-1]
 8026b6a:	9b03      	ldr	r3, [sp, #12]
 8026b6c:	1aeb      	subs	r3, r5, r3
 8026b6e:	9305      	str	r3, [sp, #20]
 8026b70:	9b08      	ldr	r3, [sp, #32]
 8026b72:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8026b74:	2b47      	cmp	r3, #71	; 0x47
 8026b76:	f040 81b9 	bne.w	8026eec <_svfprintf_r+0x8ec>
 8026b7a:	1ce8      	adds	r0, r5, #3
 8026b7c:	db02      	blt.n	8026b84 <_svfprintf_r+0x584>
 8026b7e:	45a8      	cmp	r8, r5
 8026b80:	f280 81d7 	bge.w	8026f32 <_svfprintf_r+0x932>
 8026b84:	9b07      	ldr	r3, [sp, #28]
 8026b86:	3b02      	subs	r3, #2
 8026b88:	9307      	str	r3, [sp, #28]
 8026b8a:	9907      	ldr	r1, [sp, #28]
 8026b8c:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8026b90:	f021 0120 	bic.w	r1, r1, #32
 8026b94:	2941      	cmp	r1, #65	; 0x41
 8026b96:	bf08      	it	eq
 8026b98:	320f      	addeq	r2, #15
 8026b9a:	f105 33ff 	add.w	r3, r5, #4294967295
 8026b9e:	bf06      	itte	eq
 8026ba0:	b2d2      	uxtbeq	r2, r2
 8026ba2:	2101      	moveq	r1, #1
 8026ba4:	2100      	movne	r1, #0
 8026ba6:	2b00      	cmp	r3, #0
 8026ba8:	931c      	str	r3, [sp, #112]	; 0x70
 8026baa:	bfb8      	it	lt
 8026bac:	f1c5 0301 	rsblt	r3, r5, #1
 8026bb0:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 8026bb4:	bfb4      	ite	lt
 8026bb6:	222d      	movlt	r2, #45	; 0x2d
 8026bb8:	222b      	movge	r2, #43	; 0x2b
 8026bba:	2b09      	cmp	r3, #9
 8026bbc:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 8026bc0:	f340 81aa 	ble.w	8026f18 <_svfprintf_r+0x918>
 8026bc4:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 8026bc8:	260a      	movs	r6, #10
 8026bca:	4602      	mov	r2, r0
 8026bcc:	fb93 f5f6 	sdiv	r5, r3, r6
 8026bd0:	fb06 3115 	mls	r1, r6, r5, r3
 8026bd4:	3130      	adds	r1, #48	; 0x30
 8026bd6:	f802 1c01 	strb.w	r1, [r2, #-1]
 8026bda:	4619      	mov	r1, r3
 8026bdc:	2963      	cmp	r1, #99	; 0x63
 8026bde:	f100 30ff 	add.w	r0, r0, #4294967295
 8026be2:	462b      	mov	r3, r5
 8026be4:	dcf1      	bgt.n	8026bca <_svfprintf_r+0x5ca>
 8026be6:	3330      	adds	r3, #48	; 0x30
 8026be8:	1e91      	subs	r1, r2, #2
 8026bea:	f800 3c01 	strb.w	r3, [r0, #-1]
 8026bee:	f10d 0579 	add.w	r5, sp, #121	; 0x79
 8026bf2:	460b      	mov	r3, r1
 8026bf4:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 8026bf8:	4283      	cmp	r3, r0
 8026bfa:	f0c0 8188 	bcc.w	8026f0e <_svfprintf_r+0x90e>
 8026bfe:	f10d 0389 	add.w	r3, sp, #137	; 0x89
 8026c02:	1a9b      	subs	r3, r3, r2
 8026c04:	4281      	cmp	r1, r0
 8026c06:	bf88      	it	hi
 8026c08:	2300      	movhi	r3, #0
 8026c0a:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8026c0e:	441a      	add	r2, r3
 8026c10:	ab1e      	add	r3, sp, #120	; 0x78
 8026c12:	1ad3      	subs	r3, r2, r3
 8026c14:	9a05      	ldr	r2, [sp, #20]
 8026c16:	9315      	str	r3, [sp, #84]	; 0x54
 8026c18:	2a01      	cmp	r2, #1
 8026c1a:	eb03 0802 	add.w	r8, r3, r2
 8026c1e:	dc02      	bgt.n	8026c26 <_svfprintf_r+0x626>
 8026c20:	f01b 0f01 	tst.w	fp, #1
 8026c24:	d001      	beq.n	8026c2a <_svfprintf_r+0x62a>
 8026c26:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026c28:	4498      	add	r8, r3
 8026c2a:	f42b 6380 	bic.w	r3, fp, #1024	; 0x400
 8026c2e:	2600      	movs	r6, #0
 8026c30:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8026c34:	9310      	str	r3, [sp, #64]	; 0x40
 8026c36:	9608      	str	r6, [sp, #32]
 8026c38:	4635      	mov	r5, r6
 8026c3a:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8026c3c:	b113      	cbz	r3, 8026c44 <_svfprintf_r+0x644>
 8026c3e:	232d      	movs	r3, #45	; 0x2d
 8026c40:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8026c44:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
 8026c48:	2700      	movs	r7, #0
 8026c4a:	4547      	cmp	r7, r8
 8026c4c:	463b      	mov	r3, r7
 8026c4e:	bfb8      	it	lt
 8026c50:	4643      	movlt	r3, r8
 8026c52:	9310      	str	r3, [sp, #64]	; 0x40
 8026c54:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8026c58:	b113      	cbz	r3, 8026c60 <_svfprintf_r+0x660>
 8026c5a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8026c5c:	3301      	adds	r3, #1
 8026c5e:	9310      	str	r3, [sp, #64]	; 0x40
 8026c60:	f01b 0302 	ands.w	r3, fp, #2
 8026c64:	9317      	str	r3, [sp, #92]	; 0x5c
 8026c66:	bf1e      	ittt	ne
 8026c68:	9b10      	ldrne	r3, [sp, #64]	; 0x40
 8026c6a:	3302      	addne	r3, #2
 8026c6c:	9310      	strne	r3, [sp, #64]	; 0x40
 8026c6e:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
 8026c72:	9318      	str	r3, [sp, #96]	; 0x60
 8026c74:	d122      	bne.n	8026cbc <_svfprintf_r+0x6bc>
 8026c76:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 8026c7a:	1a9b      	subs	r3, r3, r2
 8026c7c:	2b00      	cmp	r3, #0
 8026c7e:	9312      	str	r3, [sp, #72]	; 0x48
 8026c80:	dd1c      	ble.n	8026cbc <_svfprintf_r+0x6bc>
 8026c82:	9812      	ldr	r0, [sp, #72]	; 0x48
 8026c84:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 8026c88:	2810      	cmp	r0, #16
 8026c8a:	483c      	ldr	r0, [pc, #240]	; (8026d7c <_svfprintf_r+0x77c>)
 8026c8c:	6020      	str	r0, [r4, #0]
 8026c8e:	f102 0201 	add.w	r2, r2, #1
 8026c92:	f104 0108 	add.w	r1, r4, #8
 8026c96:	f300 82f7 	bgt.w	8027288 <_svfprintf_r+0xc88>
 8026c9a:	9812      	ldr	r0, [sp, #72]	; 0x48
 8026c9c:	6060      	str	r0, [r4, #4]
 8026c9e:	4403      	add	r3, r0
 8026ca0:	2a07      	cmp	r2, #7
 8026ca2:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8026ca6:	f340 8304 	ble.w	80272b2 <_svfprintf_r+0xcb2>
 8026caa:	aa22      	add	r2, sp, #136	; 0x88
 8026cac:	4649      	mov	r1, r9
 8026cae:	4650      	mov	r0, sl
 8026cb0:	f002 fbb9 	bl	8029426 <__ssprint_r>
 8026cb4:	2800      	cmp	r0, #0
 8026cb6:	f040 8637 	bne.w	8027928 <_svfprintf_r+0x1328>
 8026cba:	ac25      	add	r4, sp, #148	; 0x94
 8026cbc:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
 8026cc0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8026cc2:	b16a      	cbz	r2, 8026ce0 <_svfprintf_r+0x6e0>
 8026cc4:	f10d 026b 	add.w	r2, sp, #107	; 0x6b
 8026cc8:	6022      	str	r2, [r4, #0]
 8026cca:	2201      	movs	r2, #1
 8026ccc:	4413      	add	r3, r2
 8026cce:	9324      	str	r3, [sp, #144]	; 0x90
 8026cd0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8026cd2:	6062      	str	r2, [r4, #4]
 8026cd4:	4413      	add	r3, r2
 8026cd6:	2b07      	cmp	r3, #7
 8026cd8:	9323      	str	r3, [sp, #140]	; 0x8c
 8026cda:	f300 82ec 	bgt.w	80272b6 <_svfprintf_r+0xcb6>
 8026cde:	3408      	adds	r4, #8
 8026ce0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8026ce2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8026ce4:	b162      	cbz	r2, 8026d00 <_svfprintf_r+0x700>
 8026ce6:	aa1b      	add	r2, sp, #108	; 0x6c
 8026ce8:	6022      	str	r2, [r4, #0]
 8026cea:	2202      	movs	r2, #2
 8026cec:	4413      	add	r3, r2
 8026cee:	9324      	str	r3, [sp, #144]	; 0x90
 8026cf0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8026cf2:	6062      	str	r2, [r4, #4]
 8026cf4:	3301      	adds	r3, #1
 8026cf6:	2b07      	cmp	r3, #7
 8026cf8:	9323      	str	r3, [sp, #140]	; 0x8c
 8026cfa:	f300 82e6 	bgt.w	80272ca <_svfprintf_r+0xcca>
 8026cfe:	3408      	adds	r4, #8
 8026d00:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8026d02:	2b80      	cmp	r3, #128	; 0x80
 8026d04:	d122      	bne.n	8026d4c <_svfprintf_r+0x74c>
 8026d06:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 8026d0a:	1a9b      	subs	r3, r3, r2
 8026d0c:	2b00      	cmp	r3, #0
 8026d0e:	9312      	str	r3, [sp, #72]	; 0x48
 8026d10:	dd1c      	ble.n	8026d4c <_svfprintf_r+0x74c>
 8026d12:	9812      	ldr	r0, [sp, #72]	; 0x48
 8026d14:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 8026d18:	2810      	cmp	r0, #16
 8026d1a:	4819      	ldr	r0, [pc, #100]	; (8026d80 <_svfprintf_r+0x780>)
 8026d1c:	6020      	str	r0, [r4, #0]
 8026d1e:	f102 0201 	add.w	r2, r2, #1
 8026d22:	f104 0108 	add.w	r1, r4, #8
 8026d26:	f300 82da 	bgt.w	80272de <_svfprintf_r+0xcde>
 8026d2a:	9812      	ldr	r0, [sp, #72]	; 0x48
 8026d2c:	6060      	str	r0, [r4, #4]
 8026d2e:	4403      	add	r3, r0
 8026d30:	2a07      	cmp	r2, #7
 8026d32:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8026d36:	f340 82e7 	ble.w	8027308 <_svfprintf_r+0xd08>
 8026d3a:	aa22      	add	r2, sp, #136	; 0x88
 8026d3c:	4649      	mov	r1, r9
 8026d3e:	4650      	mov	r0, sl
 8026d40:	f002 fb71 	bl	8029426 <__ssprint_r>
 8026d44:	2800      	cmp	r0, #0
 8026d46:	f040 85ef 	bne.w	8027928 <_svfprintf_r+0x1328>
 8026d4a:	ac25      	add	r4, sp, #148	; 0x94
 8026d4c:	eba7 0708 	sub.w	r7, r7, r8
 8026d50:	2f00      	cmp	r7, #0
 8026d52:	dd27      	ble.n	8026da4 <_svfprintf_r+0x7a4>
 8026d54:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8026d58:	4809      	ldr	r0, [pc, #36]	; (8026d80 <_svfprintf_r+0x780>)
 8026d5a:	6020      	str	r0, [r4, #0]
 8026d5c:	2f10      	cmp	r7, #16
 8026d5e:	f103 0301 	add.w	r3, r3, #1
 8026d62:	f104 0108 	add.w	r1, r4, #8
 8026d66:	f300 82d1 	bgt.w	802730c <_svfprintf_r+0xd0c>
 8026d6a:	e00b      	b.n	8026d84 <_svfprintf_r+0x784>
 8026d6c:	0803653e 	.word	0x0803653e
 8026d70:	0803652d 	.word	0x0803652d
 8026d74:	40300000 	.word	0x40300000
 8026d78:	3fe00000 	.word	0x3fe00000
 8026d7c:	08036551 	.word	0x08036551
 8026d80:	08036561 	.word	0x08036561
 8026d84:	6067      	str	r7, [r4, #4]
 8026d86:	2b07      	cmp	r3, #7
 8026d88:	4417      	add	r7, r2
 8026d8a:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8026d8e:	f340 82d0 	ble.w	8027332 <_svfprintf_r+0xd32>
 8026d92:	aa22      	add	r2, sp, #136	; 0x88
 8026d94:	4649      	mov	r1, r9
 8026d96:	4650      	mov	r0, sl
 8026d98:	f002 fb45 	bl	8029426 <__ssprint_r>
 8026d9c:	2800      	cmp	r0, #0
 8026d9e:	f040 85c3 	bne.w	8027928 <_svfprintf_r+0x1328>
 8026da2:	ac25      	add	r4, sp, #148	; 0x94
 8026da4:	f41b 7f80 	tst.w	fp, #256	; 0x100
 8026da8:	9f24      	ldr	r7, [sp, #144]	; 0x90
 8026daa:	f040 82c9 	bne.w	8027340 <_svfprintf_r+0xd40>
 8026dae:	9b03      	ldr	r3, [sp, #12]
 8026db0:	e9c4 3800 	strd	r3, r8, [r4]
 8026db4:	4447      	add	r7, r8
 8026db6:	9724      	str	r7, [sp, #144]	; 0x90
 8026db8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8026dba:	3301      	adds	r3, #1
 8026dbc:	2b07      	cmp	r3, #7
 8026dbe:	9323      	str	r3, [sp, #140]	; 0x8c
 8026dc0:	f300 8303 	bgt.w	80273ca <_svfprintf_r+0xdca>
 8026dc4:	3408      	adds	r4, #8
 8026dc6:	f01b 0f04 	tst.w	fp, #4
 8026dca:	f040 858f 	bne.w	80278ec <_svfprintf_r+0x12ec>
 8026dce:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 8026dd2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026dd4:	428a      	cmp	r2, r1
 8026dd6:	bfac      	ite	ge
 8026dd8:	189b      	addge	r3, r3, r2
 8026dda:	185b      	addlt	r3, r3, r1
 8026ddc:	930b      	str	r3, [sp, #44]	; 0x2c
 8026dde:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8026de0:	b13b      	cbz	r3, 8026df2 <_svfprintf_r+0x7f2>
 8026de2:	aa22      	add	r2, sp, #136	; 0x88
 8026de4:	4649      	mov	r1, r9
 8026de6:	4650      	mov	r0, sl
 8026de8:	f002 fb1d 	bl	8029426 <__ssprint_r>
 8026dec:	2800      	cmp	r0, #0
 8026dee:	f040 859b 	bne.w	8027928 <_svfprintf_r+0x1328>
 8026df2:	2300      	movs	r3, #0
 8026df4:	9323      	str	r3, [sp, #140]	; 0x8c
 8026df6:	9b04      	ldr	r3, [sp, #16]
 8026df8:	2b00      	cmp	r3, #0
 8026dfa:	f040 85b1 	bne.w	8027960 <_svfprintf_r+0x1360>
 8026dfe:	ac25      	add	r4, sp, #148	; 0x94
 8026e00:	e0e7      	b.n	8026fd2 <_svfprintf_r+0x9d2>
 8026e02:	ab35      	add	r3, sp, #212	; 0xd4
 8026e04:	9004      	str	r0, [sp, #16]
 8026e06:	9303      	str	r3, [sp, #12]
 8026e08:	e62a      	b.n	8026a60 <_svfprintf_r+0x460>
 8026e0a:	9b03      	ldr	r3, [sp, #12]
 8026e0c:	9304      	str	r3, [sp, #16]
 8026e0e:	e627      	b.n	8026a60 <_svfprintf_r+0x460>
 8026e10:	9004      	str	r0, [sp, #16]
 8026e12:	f04f 0806 	mov.w	r8, #6
 8026e16:	e623      	b.n	8026a60 <_svfprintf_r+0x460>
 8026e18:	9004      	str	r0, [sp, #16]
 8026e1a:	e621      	b.n	8026a60 <_svfprintf_r+0x460>
 8026e1c:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8026e20:	2300      	movs	r3, #0
 8026e22:	eeb0 8a47 	vmov.f32	s16, s14
 8026e26:	eef0 8a67 	vmov.f32	s17, s15
 8026e2a:	e629      	b.n	8026a80 <_svfprintf_r+0x480>
 8026e2c:	f802 0c01 	strb.w	r0, [r2, #-1]
 8026e30:	e68b      	b.n	8026b4a <_svfprintf_r+0x54a>
 8026e32:	f803 0b01 	strb.w	r0, [r3], #1
 8026e36:	1aca      	subs	r2, r1, r3
 8026e38:	2a00      	cmp	r2, #0
 8026e3a:	dafa      	bge.n	8026e32 <_svfprintf_r+0x832>
 8026e3c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8026e3e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8026e40:	3201      	adds	r2, #1
 8026e42:	f103 0301 	add.w	r3, r3, #1
 8026e46:	bfb8      	it	lt
 8026e48:	2300      	movlt	r3, #0
 8026e4a:	441d      	add	r5, r3
 8026e4c:	e68d      	b.n	8026b6a <_svfprintf_r+0x56a>
 8026e4e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8026e50:	462b      	mov	r3, r5
 8026e52:	18a9      	adds	r1, r5, r2
 8026e54:	2030      	movs	r0, #48	; 0x30
 8026e56:	e7ee      	b.n	8026e36 <_svfprintf_r+0x836>
 8026e58:	9b08      	ldr	r3, [sp, #32]
 8026e5a:	2b46      	cmp	r3, #70	; 0x46
 8026e5c:	d005      	beq.n	8026e6a <_svfprintf_r+0x86a>
 8026e5e:	2b45      	cmp	r3, #69	; 0x45
 8026e60:	d11d      	bne.n	8026e9e <_svfprintf_r+0x89e>
 8026e62:	f108 0501 	add.w	r5, r8, #1
 8026e66:	2102      	movs	r1, #2
 8026e68:	e001      	b.n	8026e6e <_svfprintf_r+0x86e>
 8026e6a:	4645      	mov	r5, r8
 8026e6c:	2103      	movs	r1, #3
 8026e6e:	ab20      	add	r3, sp, #128	; 0x80
 8026e70:	9301      	str	r3, [sp, #4]
 8026e72:	ab1d      	add	r3, sp, #116	; 0x74
 8026e74:	9300      	str	r3, [sp, #0]
 8026e76:	462a      	mov	r2, r5
 8026e78:	ab1c      	add	r3, sp, #112	; 0x70
 8026e7a:	4650      	mov	r0, sl
 8026e7c:	eeb0 0a48 	vmov.f32	s0, s16
 8026e80:	eef0 0a68 	vmov.f32	s1, s17
 8026e84:	f001 f804 	bl	8027e90 <_dtoa_r>
 8026e88:	9b08      	ldr	r3, [sp, #32]
 8026e8a:	9003      	str	r0, [sp, #12]
 8026e8c:	2b47      	cmp	r3, #71	; 0x47
 8026e8e:	d108      	bne.n	8026ea2 <_svfprintf_r+0x8a2>
 8026e90:	f01b 0f01 	tst.w	fp, #1
 8026e94:	d105      	bne.n	8026ea2 <_svfprintf_r+0x8a2>
 8026e96:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8026e98:	9a03      	ldr	r2, [sp, #12]
 8026e9a:	1a9b      	subs	r3, r3, r2
 8026e9c:	e667      	b.n	8026b6e <_svfprintf_r+0x56e>
 8026e9e:	4645      	mov	r5, r8
 8026ea0:	e7e1      	b.n	8026e66 <_svfprintf_r+0x866>
 8026ea2:	9b03      	ldr	r3, [sp, #12]
 8026ea4:	195e      	adds	r6, r3, r5
 8026ea6:	9b08      	ldr	r3, [sp, #32]
 8026ea8:	2b46      	cmp	r3, #70	; 0x46
 8026eaa:	d10f      	bne.n	8026ecc <_svfprintf_r+0x8cc>
 8026eac:	9b03      	ldr	r3, [sp, #12]
 8026eae:	781b      	ldrb	r3, [r3, #0]
 8026eb0:	2b30      	cmp	r3, #48	; 0x30
 8026eb2:	d109      	bne.n	8026ec8 <_svfprintf_r+0x8c8>
 8026eb4:	ec51 0b18 	vmov	r0, r1, d8
 8026eb8:	2200      	movs	r2, #0
 8026eba:	2300      	movs	r3, #0
 8026ebc:	f7d9 fe1c 	bl	8000af8 <__aeabi_dcmpeq>
 8026ec0:	b910      	cbnz	r0, 8026ec8 <_svfprintf_r+0x8c8>
 8026ec2:	f1c5 0501 	rsb	r5, r5, #1
 8026ec6:	951c      	str	r5, [sp, #112]	; 0x70
 8026ec8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8026eca:	441e      	add	r6, r3
 8026ecc:	ec51 0b18 	vmov	r0, r1, d8
 8026ed0:	2200      	movs	r2, #0
 8026ed2:	2300      	movs	r3, #0
 8026ed4:	f7d9 fe10 	bl	8000af8 <__aeabi_dcmpeq>
 8026ed8:	b100      	cbz	r0, 8026edc <_svfprintf_r+0x8dc>
 8026eda:	9620      	str	r6, [sp, #128]	; 0x80
 8026edc:	2230      	movs	r2, #48	; 0x30
 8026ede:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8026ee0:	429e      	cmp	r6, r3
 8026ee2:	d9d8      	bls.n	8026e96 <_svfprintf_r+0x896>
 8026ee4:	1c59      	adds	r1, r3, #1
 8026ee6:	9120      	str	r1, [sp, #128]	; 0x80
 8026ee8:	701a      	strb	r2, [r3, #0]
 8026eea:	e7f8      	b.n	8026ede <_svfprintf_r+0x8de>
 8026eec:	9b08      	ldr	r3, [sp, #32]
 8026eee:	2b46      	cmp	r3, #70	; 0x46
 8026ef0:	f47f ae4b 	bne.w	8026b8a <_svfprintf_r+0x58a>
 8026ef4:	f00b 0301 	and.w	r3, fp, #1
 8026ef8:	2d00      	cmp	r5, #0
 8026efa:	ea43 0308 	orr.w	r3, r3, r8
 8026efe:	dd25      	ble.n	8026f4c <_svfprintf_r+0x94c>
 8026f00:	b383      	cbz	r3, 8026f64 <_svfprintf_r+0x964>
 8026f02:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026f04:	18eb      	adds	r3, r5, r3
 8026f06:	4498      	add	r8, r3
 8026f08:	2366      	movs	r3, #102	; 0x66
 8026f0a:	9307      	str	r3, [sp, #28]
 8026f0c:	e030      	b.n	8026f70 <_svfprintf_r+0x970>
 8026f0e:	f813 6b01 	ldrb.w	r6, [r3], #1
 8026f12:	f805 6f01 	strb.w	r6, [r5, #1]!
 8026f16:	e66f      	b.n	8026bf8 <_svfprintf_r+0x5f8>
 8026f18:	b941      	cbnz	r1, 8026f2c <_svfprintf_r+0x92c>
 8026f1a:	2230      	movs	r2, #48	; 0x30
 8026f1c:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 8026f20:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8026f24:	3330      	adds	r3, #48	; 0x30
 8026f26:	f802 3b01 	strb.w	r3, [r2], #1
 8026f2a:	e671      	b.n	8026c10 <_svfprintf_r+0x610>
 8026f2c:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8026f30:	e7f8      	b.n	8026f24 <_svfprintf_r+0x924>
 8026f32:	9b05      	ldr	r3, [sp, #20]
 8026f34:	42ab      	cmp	r3, r5
 8026f36:	dd0d      	ble.n	8026f54 <_svfprintf_r+0x954>
 8026f38:	9b05      	ldr	r3, [sp, #20]
 8026f3a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026f3c:	2d00      	cmp	r5, #0
 8026f3e:	eb03 0802 	add.w	r8, r3, r2
 8026f42:	dc0d      	bgt.n	8026f60 <_svfprintf_r+0x960>
 8026f44:	f1c5 0301 	rsb	r3, r5, #1
 8026f48:	4498      	add	r8, r3
 8026f4a:	e009      	b.n	8026f60 <_svfprintf_r+0x960>
 8026f4c:	b163      	cbz	r3, 8026f68 <_svfprintf_r+0x968>
 8026f4e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026f50:	3301      	adds	r3, #1
 8026f52:	e7d8      	b.n	8026f06 <_svfprintf_r+0x906>
 8026f54:	f01b 0f01 	tst.w	fp, #1
 8026f58:	d01d      	beq.n	8026f96 <_svfprintf_r+0x996>
 8026f5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026f5c:	eb05 0803 	add.w	r8, r5, r3
 8026f60:	2367      	movs	r3, #103	; 0x67
 8026f62:	e7d2      	b.n	8026f0a <_svfprintf_r+0x90a>
 8026f64:	46a8      	mov	r8, r5
 8026f66:	e7cf      	b.n	8026f08 <_svfprintf_r+0x908>
 8026f68:	2366      	movs	r3, #102	; 0x66
 8026f6a:	9307      	str	r3, [sp, #28]
 8026f6c:	f04f 0801 	mov.w	r8, #1
 8026f70:	f41b 6380 	ands.w	r3, fp, #1024	; 0x400
 8026f74:	9308      	str	r3, [sp, #32]
 8026f76:	d01f      	beq.n	8026fb8 <_svfprintf_r+0x9b8>
 8026f78:	2600      	movs	r6, #0
 8026f7a:	2d00      	cmp	r5, #0
 8026f7c:	9608      	str	r6, [sp, #32]
 8026f7e:	f77f ae5c 	ble.w	8026c3a <_svfprintf_r+0x63a>
 8026f82:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8026f84:	781b      	ldrb	r3, [r3, #0]
 8026f86:	2bff      	cmp	r3, #255	; 0xff
 8026f88:	d107      	bne.n	8026f9a <_svfprintf_r+0x99a>
 8026f8a:	9b08      	ldr	r3, [sp, #32]
 8026f8c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8026f8e:	4433      	add	r3, r6
 8026f90:	fb02 8803 	mla	r8, r2, r3, r8
 8026f94:	e651      	b.n	8026c3a <_svfprintf_r+0x63a>
 8026f96:	46a8      	mov	r8, r5
 8026f98:	e7e2      	b.n	8026f60 <_svfprintf_r+0x960>
 8026f9a:	42ab      	cmp	r3, r5
 8026f9c:	daf5      	bge.n	8026f8a <_svfprintf_r+0x98a>
 8026f9e:	1aed      	subs	r5, r5, r3
 8026fa0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8026fa2:	785b      	ldrb	r3, [r3, #1]
 8026fa4:	b133      	cbz	r3, 8026fb4 <_svfprintf_r+0x9b4>
 8026fa6:	9b08      	ldr	r3, [sp, #32]
 8026fa8:	3301      	adds	r3, #1
 8026faa:	9308      	str	r3, [sp, #32]
 8026fac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8026fae:	3301      	adds	r3, #1
 8026fb0:	9309      	str	r3, [sp, #36]	; 0x24
 8026fb2:	e7e6      	b.n	8026f82 <_svfprintf_r+0x982>
 8026fb4:	3601      	adds	r6, #1
 8026fb6:	e7e4      	b.n	8026f82 <_svfprintf_r+0x982>
 8026fb8:	9e08      	ldr	r6, [sp, #32]
 8026fba:	e63e      	b.n	8026c3a <_svfprintf_r+0x63a>
 8026fbc:	1d2b      	adds	r3, r5, #4
 8026fbe:	f01b 0f20 	tst.w	fp, #32
 8026fc2:	9306      	str	r3, [sp, #24]
 8026fc4:	d00a      	beq.n	8026fdc <_svfprintf_r+0x9dc>
 8026fc6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8026fc8:	682b      	ldr	r3, [r5, #0]
 8026fca:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8026fcc:	17d2      	asrs	r2, r2, #31
 8026fce:	e9c3 1200 	strd	r1, r2, [r3]
 8026fd2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026fd4:	9d06      	ldr	r5, [sp, #24]
 8026fd6:	9303      	str	r3, [sp, #12]
 8026fd8:	f7ff bb52 	b.w	8026680 <_svfprintf_r+0x80>
 8026fdc:	f01b 0f10 	tst.w	fp, #16
 8026fe0:	d003      	beq.n	8026fea <_svfprintf_r+0x9ea>
 8026fe2:	682b      	ldr	r3, [r5, #0]
 8026fe4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8026fe6:	601a      	str	r2, [r3, #0]
 8026fe8:	e7f3      	b.n	8026fd2 <_svfprintf_r+0x9d2>
 8026fea:	f01b 0f40 	tst.w	fp, #64	; 0x40
 8026fee:	d003      	beq.n	8026ff8 <_svfprintf_r+0x9f8>
 8026ff0:	682b      	ldr	r3, [r5, #0]
 8026ff2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8026ff4:	801a      	strh	r2, [r3, #0]
 8026ff6:	e7ec      	b.n	8026fd2 <_svfprintf_r+0x9d2>
 8026ff8:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8026ffc:	d0f1      	beq.n	8026fe2 <_svfprintf_r+0x9e2>
 8026ffe:	682b      	ldr	r3, [r5, #0]
 8027000:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8027002:	701a      	strb	r2, [r3, #0]
 8027004:	e7e5      	b.n	8026fd2 <_svfprintf_r+0x9d2>
 8027006:	f04b 0b10 	orr.w	fp, fp, #16
 802700a:	f01b 0320 	ands.w	r3, fp, #32
 802700e:	d020      	beq.n	8027052 <_svfprintf_r+0xa52>
 8027010:	3507      	adds	r5, #7
 8027012:	f025 0307 	bic.w	r3, r5, #7
 8027016:	461a      	mov	r2, r3
 8027018:	685e      	ldr	r6, [r3, #4]
 802701a:	f852 5b08 	ldr.w	r5, [r2], #8
 802701e:	9206      	str	r2, [sp, #24]
 8027020:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8027024:	2300      	movs	r3, #0
 8027026:	2200      	movs	r2, #0
 8027028:	f88d 206b 	strb.w	r2, [sp, #107]	; 0x6b
 802702c:	f1b8 3fff 	cmp.w	r8, #4294967295
 8027030:	f000 84a7 	beq.w	8027982 <_svfprintf_r+0x1382>
 8027034:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
 8027038:	9204      	str	r2, [sp, #16]
 802703a:	ea55 0206 	orrs.w	r2, r5, r6
 802703e:	f040 84a6 	bne.w	802798e <_svfprintf_r+0x138e>
 8027042:	f1b8 0f00 	cmp.w	r8, #0
 8027046:	f000 8107 	beq.w	8027258 <_svfprintf_r+0xc58>
 802704a:	2b01      	cmp	r3, #1
 802704c:	f040 84a2 	bne.w	8027994 <_svfprintf_r+0x1394>
 8027050:	e0a3      	b.n	802719a <_svfprintf_r+0xb9a>
 8027052:	462a      	mov	r2, r5
 8027054:	f01b 0610 	ands.w	r6, fp, #16
 8027058:	f852 5b04 	ldr.w	r5, [r2], #4
 802705c:	9206      	str	r2, [sp, #24]
 802705e:	d001      	beq.n	8027064 <_svfprintf_r+0xa64>
 8027060:	461e      	mov	r6, r3
 8027062:	e7dd      	b.n	8027020 <_svfprintf_r+0xa20>
 8027064:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 8027068:	d001      	beq.n	802706e <_svfprintf_r+0xa6e>
 802706a:	b2ad      	uxth	r5, r5
 802706c:	e7d8      	b.n	8027020 <_svfprintf_r+0xa20>
 802706e:	f41b 7600 	ands.w	r6, fp, #512	; 0x200
 8027072:	d0d5      	beq.n	8027020 <_svfprintf_r+0xa20>
 8027074:	b2ed      	uxtb	r5, r5
 8027076:	e7f3      	b.n	8027060 <_svfprintf_r+0xa60>
 8027078:	462b      	mov	r3, r5
 802707a:	2278      	movs	r2, #120	; 0x78
 802707c:	f853 5b04 	ldr.w	r5, [r3], #4
 8027080:	9306      	str	r3, [sp, #24]
 8027082:	f647 0330 	movw	r3, #30768	; 0x7830
 8027086:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
 802708a:	4bab      	ldr	r3, [pc, #684]	; (8027338 <_svfprintf_r+0xd38>)
 802708c:	9316      	str	r3, [sp, #88]	; 0x58
 802708e:	2600      	movs	r6, #0
 8027090:	f04b 0b02 	orr.w	fp, fp, #2
 8027094:	2302      	movs	r3, #2
 8027096:	9207      	str	r2, [sp, #28]
 8027098:	e7c5      	b.n	8027026 <_svfprintf_r+0xa26>
 802709a:	462b      	mov	r3, r5
 802709c:	f1b8 3fff 	cmp.w	r8, #4294967295
 80270a0:	f853 2b04 	ldr.w	r2, [r3], #4
 80270a4:	9203      	str	r2, [sp, #12]
 80270a6:	f04f 0500 	mov.w	r5, #0
 80270aa:	9306      	str	r3, [sp, #24]
 80270ac:	f88d 506b 	strb.w	r5, [sp, #107]	; 0x6b
 80270b0:	d010      	beq.n	80270d4 <_svfprintf_r+0xad4>
 80270b2:	9803      	ldr	r0, [sp, #12]
 80270b4:	4642      	mov	r2, r8
 80270b6:	4629      	mov	r1, r5
 80270b8:	f7d9 f8aa 	bl	8000210 <memchr>
 80270bc:	9004      	str	r0, [sp, #16]
 80270be:	2800      	cmp	r0, #0
 80270c0:	f000 80e0 	beq.w	8027284 <_svfprintf_r+0xc84>
 80270c4:	9a03      	ldr	r2, [sp, #12]
 80270c6:	9504      	str	r5, [sp, #16]
 80270c8:	eba0 0802 	sub.w	r8, r0, r2
 80270cc:	462f      	mov	r7, r5
 80270ce:	462e      	mov	r6, r5
 80270d0:	9508      	str	r5, [sp, #32]
 80270d2:	e5ba      	b.n	8026c4a <_svfprintf_r+0x64a>
 80270d4:	9803      	ldr	r0, [sp, #12]
 80270d6:	f7d9 f88d 	bl	80001f4 <strlen>
 80270da:	462f      	mov	r7, r5
 80270dc:	4680      	mov	r8, r0
 80270de:	9504      	str	r5, [sp, #16]
 80270e0:	463e      	mov	r6, r7
 80270e2:	463b      	mov	r3, r7
 80270e4:	e460      	b.n	80269a8 <_svfprintf_r+0x3a8>
 80270e6:	f04b 0b10 	orr.w	fp, fp, #16
 80270ea:	f01b 0320 	ands.w	r3, fp, #32
 80270ee:	d009      	beq.n	8027104 <_svfprintf_r+0xb04>
 80270f0:	3507      	adds	r5, #7
 80270f2:	f025 0307 	bic.w	r3, r5, #7
 80270f6:	461a      	mov	r2, r3
 80270f8:	685e      	ldr	r6, [r3, #4]
 80270fa:	f852 5b08 	ldr.w	r5, [r2], #8
 80270fe:	9206      	str	r2, [sp, #24]
 8027100:	2301      	movs	r3, #1
 8027102:	e790      	b.n	8027026 <_svfprintf_r+0xa26>
 8027104:	462a      	mov	r2, r5
 8027106:	f01b 0610 	ands.w	r6, fp, #16
 802710a:	f852 5b04 	ldr.w	r5, [r2], #4
 802710e:	9206      	str	r2, [sp, #24]
 8027110:	d001      	beq.n	8027116 <_svfprintf_r+0xb16>
 8027112:	461e      	mov	r6, r3
 8027114:	e7f4      	b.n	8027100 <_svfprintf_r+0xb00>
 8027116:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 802711a:	d001      	beq.n	8027120 <_svfprintf_r+0xb20>
 802711c:	b2ad      	uxth	r5, r5
 802711e:	e7ef      	b.n	8027100 <_svfprintf_r+0xb00>
 8027120:	f41b 7600 	ands.w	r6, fp, #512	; 0x200
 8027124:	d0ec      	beq.n	8027100 <_svfprintf_r+0xb00>
 8027126:	b2ed      	uxtb	r5, r5
 8027128:	e7f3      	b.n	8027112 <_svfprintf_r+0xb12>
 802712a:	4b84      	ldr	r3, [pc, #528]	; (802733c <_svfprintf_r+0xd3c>)
 802712c:	9316      	str	r3, [sp, #88]	; 0x58
 802712e:	f01b 0320 	ands.w	r3, fp, #32
 8027132:	d01b      	beq.n	802716c <_svfprintf_r+0xb6c>
 8027134:	3507      	adds	r5, #7
 8027136:	f025 0307 	bic.w	r3, r5, #7
 802713a:	461a      	mov	r2, r3
 802713c:	685e      	ldr	r6, [r3, #4]
 802713e:	f852 5b08 	ldr.w	r5, [r2], #8
 8027142:	9206      	str	r2, [sp, #24]
 8027144:	f01b 0f01 	tst.w	fp, #1
 8027148:	d00a      	beq.n	8027160 <_svfprintf_r+0xb60>
 802714a:	ea55 0306 	orrs.w	r3, r5, r6
 802714e:	d007      	beq.n	8027160 <_svfprintf_r+0xb60>
 8027150:	2330      	movs	r3, #48	; 0x30
 8027152:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 8027156:	9b07      	ldr	r3, [sp, #28]
 8027158:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 802715c:	f04b 0b02 	orr.w	fp, fp, #2
 8027160:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8027164:	2302      	movs	r3, #2
 8027166:	e75e      	b.n	8027026 <_svfprintf_r+0xa26>
 8027168:	4b73      	ldr	r3, [pc, #460]	; (8027338 <_svfprintf_r+0xd38>)
 802716a:	e7df      	b.n	802712c <_svfprintf_r+0xb2c>
 802716c:	462a      	mov	r2, r5
 802716e:	f01b 0610 	ands.w	r6, fp, #16
 8027172:	f852 5b04 	ldr.w	r5, [r2], #4
 8027176:	9206      	str	r2, [sp, #24]
 8027178:	d001      	beq.n	802717e <_svfprintf_r+0xb7e>
 802717a:	461e      	mov	r6, r3
 802717c:	e7e2      	b.n	8027144 <_svfprintf_r+0xb44>
 802717e:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 8027182:	d001      	beq.n	8027188 <_svfprintf_r+0xb88>
 8027184:	b2ad      	uxth	r5, r5
 8027186:	e7dd      	b.n	8027144 <_svfprintf_r+0xb44>
 8027188:	f41b 7600 	ands.w	r6, fp, #512	; 0x200
 802718c:	d0da      	beq.n	8027144 <_svfprintf_r+0xb44>
 802718e:	b2ed      	uxtb	r5, r5
 8027190:	e7f3      	b.n	802717a <_svfprintf_r+0xb7a>
 8027192:	2d0a      	cmp	r5, #10
 8027194:	f176 0300 	sbcs.w	r3, r6, #0
 8027198:	d206      	bcs.n	80271a8 <_svfprintf_r+0xba8>
 802719a:	3530      	adds	r5, #48	; 0x30
 802719c:	f88d 5137 	strb.w	r5, [sp, #311]	; 0x137
 80271a0:	f20d 1337 	addw	r3, sp, #311	; 0x137
 80271a4:	f000 bc16 	b.w	80279d4 <_svfprintf_r+0x13d4>
 80271a8:	2300      	movs	r3, #0
 80271aa:	9305      	str	r3, [sp, #20]
 80271ac:	9b04      	ldr	r3, [sp, #16]
 80271ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80271b2:	af4e      	add	r7, sp, #312	; 0x138
 80271b4:	9308      	str	r3, [sp, #32]
 80271b6:	220a      	movs	r2, #10
 80271b8:	2300      	movs	r3, #0
 80271ba:	4628      	mov	r0, r5
 80271bc:	4631      	mov	r1, r6
 80271be:	f7d9 fd0b 	bl	8000bd8 <__aeabi_uldivmod>
 80271c2:	1e7b      	subs	r3, r7, #1
 80271c4:	9303      	str	r3, [sp, #12]
 80271c6:	9b05      	ldr	r3, [sp, #20]
 80271c8:	9010      	str	r0, [sp, #64]	; 0x40
 80271ca:	3301      	adds	r3, #1
 80271cc:	9305      	str	r3, [sp, #20]
 80271ce:	9b08      	ldr	r3, [sp, #32]
 80271d0:	3230      	adds	r2, #48	; 0x30
 80271d2:	468b      	mov	fp, r1
 80271d4:	f807 2c01 	strb.w	r2, [r7, #-1]
 80271d8:	b1d3      	cbz	r3, 8027210 <_svfprintf_r+0xc10>
 80271da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80271dc:	9a05      	ldr	r2, [sp, #20]
 80271de:	781b      	ldrb	r3, [r3, #0]
 80271e0:	429a      	cmp	r2, r3
 80271e2:	d115      	bne.n	8027210 <_svfprintf_r+0xc10>
 80271e4:	2aff      	cmp	r2, #255	; 0xff
 80271e6:	d013      	beq.n	8027210 <_svfprintf_r+0xc10>
 80271e8:	2d0a      	cmp	r5, #10
 80271ea:	f176 0300 	sbcs.w	r3, r6, #0
 80271ee:	d30f      	bcc.n	8027210 <_svfprintf_r+0xc10>
 80271f0:	9b03      	ldr	r3, [sp, #12]
 80271f2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80271f4:	9914      	ldr	r1, [sp, #80]	; 0x50
 80271f6:	1a9b      	subs	r3, r3, r2
 80271f8:	4618      	mov	r0, r3
 80271fa:	9303      	str	r3, [sp, #12]
 80271fc:	f000 fcf9 	bl	8027bf2 <strncpy>
 8027200:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027202:	785b      	ldrb	r3, [r3, #1]
 8027204:	b11b      	cbz	r3, 802720e <_svfprintf_r+0xc0e>
 8027206:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027208:	3301      	adds	r3, #1
 802720a:	9309      	str	r3, [sp, #36]	; 0x24
 802720c:	2300      	movs	r3, #0
 802720e:	9305      	str	r3, [sp, #20]
 8027210:	2d0a      	cmp	r5, #10
 8027212:	f176 0600 	sbcs.w	r6, r6, #0
 8027216:	d20b      	bcs.n	8027230 <_svfprintf_r+0xc30>
 8027218:	9b03      	ldr	r3, [sp, #12]
 802721a:	f8dd b010 	ldr.w	fp, [sp, #16]
 802721e:	aa4e      	add	r2, sp, #312	; 0x138
 8027220:	4647      	mov	r7, r8
 8027222:	eba2 0803 	sub.w	r8, r2, r3
 8027226:	2300      	movs	r3, #0
 8027228:	9304      	str	r3, [sp, #16]
 802722a:	461e      	mov	r6, r3
 802722c:	f7ff bbbc 	b.w	80269a8 <_svfprintf_r+0x3a8>
 8027230:	9d10      	ldr	r5, [sp, #64]	; 0x40
 8027232:	9f03      	ldr	r7, [sp, #12]
 8027234:	465e      	mov	r6, fp
 8027236:	e7be      	b.n	80271b6 <_svfprintf_r+0xbb6>
 8027238:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802723a:	f005 030f 	and.w	r3, r5, #15
 802723e:	092d      	lsrs	r5, r5, #4
 8027240:	5cd3      	ldrb	r3, [r2, r3]
 8027242:	9a03      	ldr	r2, [sp, #12]
 8027244:	ea45 7506 	orr.w	r5, r5, r6, lsl #28
 8027248:	f802 3d01 	strb.w	r3, [r2, #-1]!
 802724c:	0936      	lsrs	r6, r6, #4
 802724e:	ea55 0306 	orrs.w	r3, r5, r6
 8027252:	9203      	str	r2, [sp, #12]
 8027254:	d1f0      	bne.n	8027238 <_svfprintf_r+0xc38>
 8027256:	e7df      	b.n	8027218 <_svfprintf_r+0xc18>
 8027258:	b933      	cbnz	r3, 8027268 <_svfprintf_r+0xc68>
 802725a:	f01b 0f01 	tst.w	fp, #1
 802725e:	d003      	beq.n	8027268 <_svfprintf_r+0xc68>
 8027260:	2330      	movs	r3, #48	; 0x30
 8027262:	f88d 3137 	strb.w	r3, [sp, #311]	; 0x137
 8027266:	e79b      	b.n	80271a0 <_svfprintf_r+0xba0>
 8027268:	ab4e      	add	r3, sp, #312	; 0x138
 802726a:	e3b3      	b.n	80279d4 <_svfprintf_r+0x13d4>
 802726c:	9b07      	ldr	r3, [sp, #28]
 802726e:	2b00      	cmp	r3, #0
 8027270:	f000 837c 	beq.w	802796c <_svfprintf_r+0x136c>
 8027274:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8027278:	2300      	movs	r3, #0
 802727a:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 802727e:	9506      	str	r5, [sp, #24]
 8027280:	f7ff bb1f 	b.w	80268c2 <_svfprintf_r+0x2c2>
 8027284:	9f04      	ldr	r7, [sp, #16]
 8027286:	e72b      	b.n	80270e0 <_svfprintf_r+0xae0>
 8027288:	2010      	movs	r0, #16
 802728a:	4403      	add	r3, r0
 802728c:	2a07      	cmp	r2, #7
 802728e:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8027292:	6060      	str	r0, [r4, #4]
 8027294:	dd08      	ble.n	80272a8 <_svfprintf_r+0xca8>
 8027296:	aa22      	add	r2, sp, #136	; 0x88
 8027298:	4649      	mov	r1, r9
 802729a:	4650      	mov	r0, sl
 802729c:	f002 f8c3 	bl	8029426 <__ssprint_r>
 80272a0:	2800      	cmp	r0, #0
 80272a2:	f040 8341 	bne.w	8027928 <_svfprintf_r+0x1328>
 80272a6:	a925      	add	r1, sp, #148	; 0x94
 80272a8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80272aa:	3b10      	subs	r3, #16
 80272ac:	9312      	str	r3, [sp, #72]	; 0x48
 80272ae:	460c      	mov	r4, r1
 80272b0:	e4e7      	b.n	8026c82 <_svfprintf_r+0x682>
 80272b2:	460c      	mov	r4, r1
 80272b4:	e502      	b.n	8026cbc <_svfprintf_r+0x6bc>
 80272b6:	aa22      	add	r2, sp, #136	; 0x88
 80272b8:	4649      	mov	r1, r9
 80272ba:	4650      	mov	r0, sl
 80272bc:	f002 f8b3 	bl	8029426 <__ssprint_r>
 80272c0:	2800      	cmp	r0, #0
 80272c2:	f040 8331 	bne.w	8027928 <_svfprintf_r+0x1328>
 80272c6:	ac25      	add	r4, sp, #148	; 0x94
 80272c8:	e50a      	b.n	8026ce0 <_svfprintf_r+0x6e0>
 80272ca:	aa22      	add	r2, sp, #136	; 0x88
 80272cc:	4649      	mov	r1, r9
 80272ce:	4650      	mov	r0, sl
 80272d0:	f002 f8a9 	bl	8029426 <__ssprint_r>
 80272d4:	2800      	cmp	r0, #0
 80272d6:	f040 8327 	bne.w	8027928 <_svfprintf_r+0x1328>
 80272da:	ac25      	add	r4, sp, #148	; 0x94
 80272dc:	e510      	b.n	8026d00 <_svfprintf_r+0x700>
 80272de:	2010      	movs	r0, #16
 80272e0:	4403      	add	r3, r0
 80272e2:	2a07      	cmp	r2, #7
 80272e4:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 80272e8:	6060      	str	r0, [r4, #4]
 80272ea:	dd08      	ble.n	80272fe <_svfprintf_r+0xcfe>
 80272ec:	aa22      	add	r2, sp, #136	; 0x88
 80272ee:	4649      	mov	r1, r9
 80272f0:	4650      	mov	r0, sl
 80272f2:	f002 f898 	bl	8029426 <__ssprint_r>
 80272f6:	2800      	cmp	r0, #0
 80272f8:	f040 8316 	bne.w	8027928 <_svfprintf_r+0x1328>
 80272fc:	a925      	add	r1, sp, #148	; 0x94
 80272fe:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8027300:	3b10      	subs	r3, #16
 8027302:	9312      	str	r3, [sp, #72]	; 0x48
 8027304:	460c      	mov	r4, r1
 8027306:	e504      	b.n	8026d12 <_svfprintf_r+0x712>
 8027308:	460c      	mov	r4, r1
 802730a:	e51f      	b.n	8026d4c <_svfprintf_r+0x74c>
 802730c:	2010      	movs	r0, #16
 802730e:	4402      	add	r2, r0
 8027310:	2b07      	cmp	r3, #7
 8027312:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8027316:	6060      	str	r0, [r4, #4]
 8027318:	dd08      	ble.n	802732c <_svfprintf_r+0xd2c>
 802731a:	aa22      	add	r2, sp, #136	; 0x88
 802731c:	4649      	mov	r1, r9
 802731e:	4650      	mov	r0, sl
 8027320:	f002 f881 	bl	8029426 <__ssprint_r>
 8027324:	2800      	cmp	r0, #0
 8027326:	f040 82ff 	bne.w	8027928 <_svfprintf_r+0x1328>
 802732a:	a925      	add	r1, sp, #148	; 0x94
 802732c:	3f10      	subs	r7, #16
 802732e:	460c      	mov	r4, r1
 8027330:	e510      	b.n	8026d54 <_svfprintf_r+0x754>
 8027332:	460c      	mov	r4, r1
 8027334:	e536      	b.n	8026da4 <_svfprintf_r+0x7a4>
 8027336:	bf00      	nop
 8027338:	0803652d 	.word	0x0803652d
 802733c:	0803653e 	.word	0x0803653e
 8027340:	9b07      	ldr	r3, [sp, #28]
 8027342:	2b65      	cmp	r3, #101	; 0x65
 8027344:	f340 823a 	ble.w	80277bc <_svfprintf_r+0x11bc>
 8027348:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 802734c:	2200      	movs	r2, #0
 802734e:	2300      	movs	r3, #0
 8027350:	f7d9 fbd2 	bl	8000af8 <__aeabi_dcmpeq>
 8027354:	2800      	cmp	r0, #0
 8027356:	d068      	beq.n	802742a <_svfprintf_r+0xe2a>
 8027358:	4b6d      	ldr	r3, [pc, #436]	; (8027510 <_svfprintf_r+0xf10>)
 802735a:	6023      	str	r3, [r4, #0]
 802735c:	2301      	movs	r3, #1
 802735e:	441f      	add	r7, r3
 8027360:	6063      	str	r3, [r4, #4]
 8027362:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027364:	9724      	str	r7, [sp, #144]	; 0x90
 8027366:	3301      	adds	r3, #1
 8027368:	2b07      	cmp	r3, #7
 802736a:	9323      	str	r3, [sp, #140]	; 0x8c
 802736c:	dc37      	bgt.n	80273de <_svfprintf_r+0xdde>
 802736e:	3408      	adds	r4, #8
 8027370:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8027372:	9a05      	ldr	r2, [sp, #20]
 8027374:	4293      	cmp	r3, r2
 8027376:	db03      	blt.n	8027380 <_svfprintf_r+0xd80>
 8027378:	f01b 0f01 	tst.w	fp, #1
 802737c:	f43f ad23 	beq.w	8026dc6 <_svfprintf_r+0x7c6>
 8027380:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027382:	6023      	str	r3, [r4, #0]
 8027384:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027386:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027388:	6063      	str	r3, [r4, #4]
 802738a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802738c:	4413      	add	r3, r2
 802738e:	9324      	str	r3, [sp, #144]	; 0x90
 8027390:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027392:	3301      	adds	r3, #1
 8027394:	2b07      	cmp	r3, #7
 8027396:	9323      	str	r3, [sp, #140]	; 0x8c
 8027398:	dc2b      	bgt.n	80273f2 <_svfprintf_r+0xdf2>
 802739a:	3408      	adds	r4, #8
 802739c:	9b05      	ldr	r3, [sp, #20]
 802739e:	1e5d      	subs	r5, r3, #1
 80273a0:	2d00      	cmp	r5, #0
 80273a2:	f77f ad10 	ble.w	8026dc6 <_svfprintf_r+0x7c6>
 80273a6:	4e5b      	ldr	r6, [pc, #364]	; (8027514 <_svfprintf_r+0xf14>)
 80273a8:	2710      	movs	r7, #16
 80273aa:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80273ae:	2d10      	cmp	r5, #16
 80273b0:	f103 0301 	add.w	r3, r3, #1
 80273b4:	f104 0108 	add.w	r1, r4, #8
 80273b8:	6026      	str	r6, [r4, #0]
 80273ba:	dc24      	bgt.n	8027406 <_svfprintf_r+0xe06>
 80273bc:	6065      	str	r5, [r4, #4]
 80273be:	4415      	add	r5, r2
 80273c0:	9524      	str	r5, [sp, #144]	; 0x90
 80273c2:	2b07      	cmp	r3, #7
 80273c4:	9323      	str	r3, [sp, #140]	; 0x8c
 80273c6:	f340 828e 	ble.w	80278e6 <_svfprintf_r+0x12e6>
 80273ca:	aa22      	add	r2, sp, #136	; 0x88
 80273cc:	4649      	mov	r1, r9
 80273ce:	4650      	mov	r0, sl
 80273d0:	f002 f829 	bl	8029426 <__ssprint_r>
 80273d4:	2800      	cmp	r0, #0
 80273d6:	f040 82a7 	bne.w	8027928 <_svfprintf_r+0x1328>
 80273da:	ac25      	add	r4, sp, #148	; 0x94
 80273dc:	e4f3      	b.n	8026dc6 <_svfprintf_r+0x7c6>
 80273de:	aa22      	add	r2, sp, #136	; 0x88
 80273e0:	4649      	mov	r1, r9
 80273e2:	4650      	mov	r0, sl
 80273e4:	f002 f81f 	bl	8029426 <__ssprint_r>
 80273e8:	2800      	cmp	r0, #0
 80273ea:	f040 829d 	bne.w	8027928 <_svfprintf_r+0x1328>
 80273ee:	ac25      	add	r4, sp, #148	; 0x94
 80273f0:	e7be      	b.n	8027370 <_svfprintf_r+0xd70>
 80273f2:	aa22      	add	r2, sp, #136	; 0x88
 80273f4:	4649      	mov	r1, r9
 80273f6:	4650      	mov	r0, sl
 80273f8:	f002 f815 	bl	8029426 <__ssprint_r>
 80273fc:	2800      	cmp	r0, #0
 80273fe:	f040 8293 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027402:	ac25      	add	r4, sp, #148	; 0x94
 8027404:	e7ca      	b.n	802739c <_svfprintf_r+0xd9c>
 8027406:	3210      	adds	r2, #16
 8027408:	2b07      	cmp	r3, #7
 802740a:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 802740e:	6067      	str	r7, [r4, #4]
 8027410:	dd08      	ble.n	8027424 <_svfprintf_r+0xe24>
 8027412:	aa22      	add	r2, sp, #136	; 0x88
 8027414:	4649      	mov	r1, r9
 8027416:	4650      	mov	r0, sl
 8027418:	f002 f805 	bl	8029426 <__ssprint_r>
 802741c:	2800      	cmp	r0, #0
 802741e:	f040 8283 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027422:	a925      	add	r1, sp, #148	; 0x94
 8027424:	3d10      	subs	r5, #16
 8027426:	460c      	mov	r4, r1
 8027428:	e7bf      	b.n	80273aa <_svfprintf_r+0xdaa>
 802742a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 802742c:	2b00      	cmp	r3, #0
 802742e:	dc73      	bgt.n	8027518 <_svfprintf_r+0xf18>
 8027430:	4b37      	ldr	r3, [pc, #220]	; (8027510 <_svfprintf_r+0xf10>)
 8027432:	6023      	str	r3, [r4, #0]
 8027434:	2301      	movs	r3, #1
 8027436:	441f      	add	r7, r3
 8027438:	6063      	str	r3, [r4, #4]
 802743a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802743c:	9724      	str	r7, [sp, #144]	; 0x90
 802743e:	3301      	adds	r3, #1
 8027440:	2b07      	cmp	r3, #7
 8027442:	9323      	str	r3, [sp, #140]	; 0x8c
 8027444:	dc3d      	bgt.n	80274c2 <_svfprintf_r+0xec2>
 8027446:	3408      	adds	r4, #8
 8027448:	9905      	ldr	r1, [sp, #20]
 802744a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 802744c:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802744e:	430b      	orrs	r3, r1
 8027450:	f00b 0101 	and.w	r1, fp, #1
 8027454:	430b      	orrs	r3, r1
 8027456:	f43f acb6 	beq.w	8026dc6 <_svfprintf_r+0x7c6>
 802745a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802745c:	6023      	str	r3, [r4, #0]
 802745e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027460:	6063      	str	r3, [r4, #4]
 8027462:	441a      	add	r2, r3
 8027464:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027466:	9224      	str	r2, [sp, #144]	; 0x90
 8027468:	3301      	adds	r3, #1
 802746a:	2b07      	cmp	r3, #7
 802746c:	9323      	str	r3, [sp, #140]	; 0x8c
 802746e:	dc32      	bgt.n	80274d6 <_svfprintf_r+0xed6>
 8027470:	3408      	adds	r4, #8
 8027472:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8027474:	2d00      	cmp	r5, #0
 8027476:	da1b      	bge.n	80274b0 <_svfprintf_r+0xeb0>
 8027478:	4e26      	ldr	r6, [pc, #152]	; (8027514 <_svfprintf_r+0xf14>)
 802747a:	426d      	negs	r5, r5
 802747c:	4623      	mov	r3, r4
 802747e:	2710      	movs	r7, #16
 8027480:	e9dd 2123 	ldrd	r2, r1, [sp, #140]	; 0x8c
 8027484:	2d10      	cmp	r5, #16
 8027486:	f102 0201 	add.w	r2, r2, #1
 802748a:	f104 0408 	add.w	r4, r4, #8
 802748e:	601e      	str	r6, [r3, #0]
 8027490:	dc2b      	bgt.n	80274ea <_svfprintf_r+0xeea>
 8027492:	605d      	str	r5, [r3, #4]
 8027494:	2a07      	cmp	r2, #7
 8027496:	440d      	add	r5, r1
 8027498:	e9cd 2523 	strd	r2, r5, [sp, #140]	; 0x8c
 802749c:	dd08      	ble.n	80274b0 <_svfprintf_r+0xeb0>
 802749e:	aa22      	add	r2, sp, #136	; 0x88
 80274a0:	4649      	mov	r1, r9
 80274a2:	4650      	mov	r0, sl
 80274a4:	f001 ffbf 	bl	8029426 <__ssprint_r>
 80274a8:	2800      	cmp	r0, #0
 80274aa:	f040 823d 	bne.w	8027928 <_svfprintf_r+0x1328>
 80274ae:	ac25      	add	r4, sp, #148	; 0x94
 80274b0:	9b03      	ldr	r3, [sp, #12]
 80274b2:	6023      	str	r3, [r4, #0]
 80274b4:	9b05      	ldr	r3, [sp, #20]
 80274b6:	9a05      	ldr	r2, [sp, #20]
 80274b8:	6063      	str	r3, [r4, #4]
 80274ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80274bc:	4413      	add	r3, r2
 80274be:	9324      	str	r3, [sp, #144]	; 0x90
 80274c0:	e47a      	b.n	8026db8 <_svfprintf_r+0x7b8>
 80274c2:	aa22      	add	r2, sp, #136	; 0x88
 80274c4:	4649      	mov	r1, r9
 80274c6:	4650      	mov	r0, sl
 80274c8:	f001 ffad 	bl	8029426 <__ssprint_r>
 80274cc:	2800      	cmp	r0, #0
 80274ce:	f040 822b 	bne.w	8027928 <_svfprintf_r+0x1328>
 80274d2:	ac25      	add	r4, sp, #148	; 0x94
 80274d4:	e7b8      	b.n	8027448 <_svfprintf_r+0xe48>
 80274d6:	aa22      	add	r2, sp, #136	; 0x88
 80274d8:	4649      	mov	r1, r9
 80274da:	4650      	mov	r0, sl
 80274dc:	f001 ffa3 	bl	8029426 <__ssprint_r>
 80274e0:	2800      	cmp	r0, #0
 80274e2:	f040 8221 	bne.w	8027928 <_svfprintf_r+0x1328>
 80274e6:	ac25      	add	r4, sp, #148	; 0x94
 80274e8:	e7c3      	b.n	8027472 <_svfprintf_r+0xe72>
 80274ea:	3110      	adds	r1, #16
 80274ec:	2a07      	cmp	r2, #7
 80274ee:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
 80274f2:	605f      	str	r7, [r3, #4]
 80274f4:	dd08      	ble.n	8027508 <_svfprintf_r+0xf08>
 80274f6:	aa22      	add	r2, sp, #136	; 0x88
 80274f8:	4649      	mov	r1, r9
 80274fa:	4650      	mov	r0, sl
 80274fc:	f001 ff93 	bl	8029426 <__ssprint_r>
 8027500:	2800      	cmp	r0, #0
 8027502:	f040 8211 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027506:	ac25      	add	r4, sp, #148	; 0x94
 8027508:	3d10      	subs	r5, #16
 802750a:	4623      	mov	r3, r4
 802750c:	e7b8      	b.n	8027480 <_svfprintf_r+0xe80>
 802750e:	bf00      	nop
 8027510:	0803654f 	.word	0x0803654f
 8027514:	08036561 	.word	0x08036561
 8027518:	9b05      	ldr	r3, [sp, #20]
 802751a:	42ab      	cmp	r3, r5
 802751c:	bfa8      	it	ge
 802751e:	462b      	movge	r3, r5
 8027520:	2b00      	cmp	r3, #0
 8027522:	4698      	mov	r8, r3
 8027524:	dd0a      	ble.n	802753c <_svfprintf_r+0xf3c>
 8027526:	9b03      	ldr	r3, [sp, #12]
 8027528:	e9c4 3800 	strd	r3, r8, [r4]
 802752c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802752e:	3301      	adds	r3, #1
 8027530:	4447      	add	r7, r8
 8027532:	2b07      	cmp	r3, #7
 8027534:	9724      	str	r7, [sp, #144]	; 0x90
 8027536:	9323      	str	r3, [sp, #140]	; 0x8c
 8027538:	dc7b      	bgt.n	8027632 <_svfprintf_r+0x1032>
 802753a:	3408      	adds	r4, #8
 802753c:	f1b8 0f00 	cmp.w	r8, #0
 8027540:	bfac      	ite	ge
 8027542:	eba5 0708 	subge.w	r7, r5, r8
 8027546:	462f      	movlt	r7, r5
 8027548:	2f00      	cmp	r7, #0
 802754a:	dd1a      	ble.n	8027582 <_svfprintf_r+0xf82>
 802754c:	f8df 8368 	ldr.w	r8, [pc, #872]	; 80278b8 <_svfprintf_r+0x12b8>
 8027550:	f8c4 8000 	str.w	r8, [r4]
 8027554:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8027558:	2f10      	cmp	r7, #16
 802755a:	f103 0301 	add.w	r3, r3, #1
 802755e:	f104 0108 	add.w	r1, r4, #8
 8027562:	dc70      	bgt.n	8027646 <_svfprintf_r+0x1046>
 8027564:	6067      	str	r7, [r4, #4]
 8027566:	2b07      	cmp	r3, #7
 8027568:	4417      	add	r7, r2
 802756a:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 802756e:	dd7d      	ble.n	802766c <_svfprintf_r+0x106c>
 8027570:	aa22      	add	r2, sp, #136	; 0x88
 8027572:	4649      	mov	r1, r9
 8027574:	4650      	mov	r0, sl
 8027576:	f001 ff56 	bl	8029426 <__ssprint_r>
 802757a:	2800      	cmp	r0, #0
 802757c:	f040 81d4 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027580:	ac25      	add	r4, sp, #148	; 0x94
 8027582:	9b03      	ldr	r3, [sp, #12]
 8027584:	f41b 6f80 	tst.w	fp, #1024	; 0x400
 8027588:	441d      	add	r5, r3
 802758a:	d00a      	beq.n	80275a2 <_svfprintf_r+0xfa2>
 802758c:	9b08      	ldr	r3, [sp, #32]
 802758e:	2b00      	cmp	r3, #0
 8027590:	d16e      	bne.n	8027670 <_svfprintf_r+0x1070>
 8027592:	2e00      	cmp	r6, #0
 8027594:	d16e      	bne.n	8027674 <_svfprintf_r+0x1074>
 8027596:	9b03      	ldr	r3, [sp, #12]
 8027598:	9a05      	ldr	r2, [sp, #20]
 802759a:	4413      	add	r3, r2
 802759c:	429d      	cmp	r5, r3
 802759e:	bf28      	it	cs
 80275a0:	461d      	movcs	r5, r3
 80275a2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80275a4:	9a05      	ldr	r2, [sp, #20]
 80275a6:	4293      	cmp	r3, r2
 80275a8:	db02      	blt.n	80275b0 <_svfprintf_r+0xfb0>
 80275aa:	f01b 0f01 	tst.w	fp, #1
 80275ae:	d00e      	beq.n	80275ce <_svfprintf_r+0xfce>
 80275b0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80275b2:	6023      	str	r3, [r4, #0]
 80275b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80275b6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80275b8:	6063      	str	r3, [r4, #4]
 80275ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80275bc:	4413      	add	r3, r2
 80275be:	9324      	str	r3, [sp, #144]	; 0x90
 80275c0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80275c2:	3301      	adds	r3, #1
 80275c4:	2b07      	cmp	r3, #7
 80275c6:	9323      	str	r3, [sp, #140]	; 0x8c
 80275c8:	f300 80d2 	bgt.w	8027770 <_svfprintf_r+0x1170>
 80275cc:	3408      	adds	r4, #8
 80275ce:	9b05      	ldr	r3, [sp, #20]
 80275d0:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 80275d2:	9a05      	ldr	r2, [sp, #20]
 80275d4:	1b9e      	subs	r6, r3, r6
 80275d6:	9b03      	ldr	r3, [sp, #12]
 80275d8:	4413      	add	r3, r2
 80275da:	1b5b      	subs	r3, r3, r5
 80275dc:	429e      	cmp	r6, r3
 80275de:	bfa8      	it	ge
 80275e0:	461e      	movge	r6, r3
 80275e2:	2e00      	cmp	r6, #0
 80275e4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80275e6:	dd0a      	ble.n	80275fe <_svfprintf_r+0xffe>
 80275e8:	4433      	add	r3, r6
 80275ea:	9324      	str	r3, [sp, #144]	; 0x90
 80275ec:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80275ee:	3301      	adds	r3, #1
 80275f0:	2b07      	cmp	r3, #7
 80275f2:	e9c4 5600 	strd	r5, r6, [r4]
 80275f6:	9323      	str	r3, [sp, #140]	; 0x8c
 80275f8:	f300 80c4 	bgt.w	8027784 <_svfprintf_r+0x1184>
 80275fc:	3408      	adds	r4, #8
 80275fe:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8027600:	9b05      	ldr	r3, [sp, #20]
 8027602:	2e00      	cmp	r6, #0
 8027604:	eba3 0505 	sub.w	r5, r3, r5
 8027608:	bfa8      	it	ge
 802760a:	1bad      	subge	r5, r5, r6
 802760c:	2d00      	cmp	r5, #0
 802760e:	f77f abda 	ble.w	8026dc6 <_svfprintf_r+0x7c6>
 8027612:	4ea9      	ldr	r6, [pc, #676]	; (80278b8 <_svfprintf_r+0x12b8>)
 8027614:	2710      	movs	r7, #16
 8027616:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 802761a:	2d10      	cmp	r5, #16
 802761c:	f103 0301 	add.w	r3, r3, #1
 8027620:	f104 0108 	add.w	r1, r4, #8
 8027624:	6026      	str	r6, [r4, #0]
 8027626:	f300 80b7 	bgt.w	8027798 <_svfprintf_r+0x1198>
 802762a:	442a      	add	r2, r5
 802762c:	6065      	str	r5, [r4, #4]
 802762e:	9224      	str	r2, [sp, #144]	; 0x90
 8027630:	e6c7      	b.n	80273c2 <_svfprintf_r+0xdc2>
 8027632:	aa22      	add	r2, sp, #136	; 0x88
 8027634:	4649      	mov	r1, r9
 8027636:	4650      	mov	r0, sl
 8027638:	f001 fef5 	bl	8029426 <__ssprint_r>
 802763c:	2800      	cmp	r0, #0
 802763e:	f040 8173 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027642:	ac25      	add	r4, sp, #148	; 0x94
 8027644:	e77a      	b.n	802753c <_svfprintf_r+0xf3c>
 8027646:	2010      	movs	r0, #16
 8027648:	4402      	add	r2, r0
 802764a:	2b07      	cmp	r3, #7
 802764c:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8027650:	6060      	str	r0, [r4, #4]
 8027652:	dd08      	ble.n	8027666 <_svfprintf_r+0x1066>
 8027654:	aa22      	add	r2, sp, #136	; 0x88
 8027656:	4649      	mov	r1, r9
 8027658:	4650      	mov	r0, sl
 802765a:	f001 fee4 	bl	8029426 <__ssprint_r>
 802765e:	2800      	cmp	r0, #0
 8027660:	f040 8162 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027664:	a925      	add	r1, sp, #148	; 0x94
 8027666:	3f10      	subs	r7, #16
 8027668:	460c      	mov	r4, r1
 802766a:	e771      	b.n	8027550 <_svfprintf_r+0xf50>
 802766c:	460c      	mov	r4, r1
 802766e:	e788      	b.n	8027582 <_svfprintf_r+0xf82>
 8027670:	2e00      	cmp	r6, #0
 8027672:	d04d      	beq.n	8027710 <_svfprintf_r+0x1110>
 8027674:	3e01      	subs	r6, #1
 8027676:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8027678:	6023      	str	r3, [r4, #0]
 802767a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802767c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 802767e:	6063      	str	r3, [r4, #4]
 8027680:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8027682:	4413      	add	r3, r2
 8027684:	9324      	str	r3, [sp, #144]	; 0x90
 8027686:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027688:	3301      	adds	r3, #1
 802768a:	2b07      	cmp	r3, #7
 802768c:	9323      	str	r3, [sp, #140]	; 0x8c
 802768e:	dc46      	bgt.n	802771e <_svfprintf_r+0x111e>
 8027690:	3408      	adds	r4, #8
 8027692:	9b03      	ldr	r3, [sp, #12]
 8027694:	9a05      	ldr	r2, [sp, #20]
 8027696:	eb03 0802 	add.w	r8, r3, r2
 802769a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802769c:	781b      	ldrb	r3, [r3, #0]
 802769e:	eba8 0805 	sub.w	r8, r8, r5
 80276a2:	4598      	cmp	r8, r3
 80276a4:	bfa8      	it	ge
 80276a6:	4698      	movge	r8, r3
 80276a8:	f1b8 0f00 	cmp.w	r8, #0
 80276ac:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80276ae:	dd09      	ble.n	80276c4 <_svfprintf_r+0x10c4>
 80276b0:	4443      	add	r3, r8
 80276b2:	9324      	str	r3, [sp, #144]	; 0x90
 80276b4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80276b6:	3301      	adds	r3, #1
 80276b8:	2b07      	cmp	r3, #7
 80276ba:	e9c4 5800 	strd	r5, r8, [r4]
 80276be:	9323      	str	r3, [sp, #140]	; 0x8c
 80276c0:	dc37      	bgt.n	8027732 <_svfprintf_r+0x1132>
 80276c2:	3408      	adds	r4, #8
 80276c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80276c6:	781f      	ldrb	r7, [r3, #0]
 80276c8:	f1b8 0f00 	cmp.w	r8, #0
 80276cc:	bfa8      	it	ge
 80276ce:	eba7 0708 	subge.w	r7, r7, r8
 80276d2:	2f00      	cmp	r7, #0
 80276d4:	dd18      	ble.n	8027708 <_svfprintf_r+0x1108>
 80276d6:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80276da:	4877      	ldr	r0, [pc, #476]	; (80278b8 <_svfprintf_r+0x12b8>)
 80276dc:	6020      	str	r0, [r4, #0]
 80276de:	2f10      	cmp	r7, #16
 80276e0:	f103 0301 	add.w	r3, r3, #1
 80276e4:	f104 0108 	add.w	r1, r4, #8
 80276e8:	dc2d      	bgt.n	8027746 <_svfprintf_r+0x1146>
 80276ea:	443a      	add	r2, r7
 80276ec:	2b07      	cmp	r3, #7
 80276ee:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80276f2:	6067      	str	r7, [r4, #4]
 80276f4:	dd3a      	ble.n	802776c <_svfprintf_r+0x116c>
 80276f6:	aa22      	add	r2, sp, #136	; 0x88
 80276f8:	4649      	mov	r1, r9
 80276fa:	4650      	mov	r0, sl
 80276fc:	f001 fe93 	bl	8029426 <__ssprint_r>
 8027700:	2800      	cmp	r0, #0
 8027702:	f040 8111 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027706:	ac25      	add	r4, sp, #148	; 0x94
 8027708:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802770a:	781b      	ldrb	r3, [r3, #0]
 802770c:	441d      	add	r5, r3
 802770e:	e73d      	b.n	802758c <_svfprintf_r+0xf8c>
 8027710:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027712:	3b01      	subs	r3, #1
 8027714:	9309      	str	r3, [sp, #36]	; 0x24
 8027716:	9b08      	ldr	r3, [sp, #32]
 8027718:	3b01      	subs	r3, #1
 802771a:	9308      	str	r3, [sp, #32]
 802771c:	e7ab      	b.n	8027676 <_svfprintf_r+0x1076>
 802771e:	aa22      	add	r2, sp, #136	; 0x88
 8027720:	4649      	mov	r1, r9
 8027722:	4650      	mov	r0, sl
 8027724:	f001 fe7f 	bl	8029426 <__ssprint_r>
 8027728:	2800      	cmp	r0, #0
 802772a:	f040 80fd 	bne.w	8027928 <_svfprintf_r+0x1328>
 802772e:	ac25      	add	r4, sp, #148	; 0x94
 8027730:	e7af      	b.n	8027692 <_svfprintf_r+0x1092>
 8027732:	aa22      	add	r2, sp, #136	; 0x88
 8027734:	4649      	mov	r1, r9
 8027736:	4650      	mov	r0, sl
 8027738:	f001 fe75 	bl	8029426 <__ssprint_r>
 802773c:	2800      	cmp	r0, #0
 802773e:	f040 80f3 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027742:	ac25      	add	r4, sp, #148	; 0x94
 8027744:	e7be      	b.n	80276c4 <_svfprintf_r+0x10c4>
 8027746:	2010      	movs	r0, #16
 8027748:	4402      	add	r2, r0
 802774a:	2b07      	cmp	r3, #7
 802774c:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8027750:	6060      	str	r0, [r4, #4]
 8027752:	dd08      	ble.n	8027766 <_svfprintf_r+0x1166>
 8027754:	aa22      	add	r2, sp, #136	; 0x88
 8027756:	4649      	mov	r1, r9
 8027758:	4650      	mov	r0, sl
 802775a:	f001 fe64 	bl	8029426 <__ssprint_r>
 802775e:	2800      	cmp	r0, #0
 8027760:	f040 80e2 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027764:	a925      	add	r1, sp, #148	; 0x94
 8027766:	3f10      	subs	r7, #16
 8027768:	460c      	mov	r4, r1
 802776a:	e7b4      	b.n	80276d6 <_svfprintf_r+0x10d6>
 802776c:	460c      	mov	r4, r1
 802776e:	e7cb      	b.n	8027708 <_svfprintf_r+0x1108>
 8027770:	aa22      	add	r2, sp, #136	; 0x88
 8027772:	4649      	mov	r1, r9
 8027774:	4650      	mov	r0, sl
 8027776:	f001 fe56 	bl	8029426 <__ssprint_r>
 802777a:	2800      	cmp	r0, #0
 802777c:	f040 80d4 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027780:	ac25      	add	r4, sp, #148	; 0x94
 8027782:	e724      	b.n	80275ce <_svfprintf_r+0xfce>
 8027784:	aa22      	add	r2, sp, #136	; 0x88
 8027786:	4649      	mov	r1, r9
 8027788:	4650      	mov	r0, sl
 802778a:	f001 fe4c 	bl	8029426 <__ssprint_r>
 802778e:	2800      	cmp	r0, #0
 8027790:	f040 80ca 	bne.w	8027928 <_svfprintf_r+0x1328>
 8027794:	ac25      	add	r4, sp, #148	; 0x94
 8027796:	e732      	b.n	80275fe <_svfprintf_r+0xffe>
 8027798:	3210      	adds	r2, #16
 802779a:	2b07      	cmp	r3, #7
 802779c:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80277a0:	6067      	str	r7, [r4, #4]
 80277a2:	dd08      	ble.n	80277b6 <_svfprintf_r+0x11b6>
 80277a4:	aa22      	add	r2, sp, #136	; 0x88
 80277a6:	4649      	mov	r1, r9
 80277a8:	4650      	mov	r0, sl
 80277aa:	f001 fe3c 	bl	8029426 <__ssprint_r>
 80277ae:	2800      	cmp	r0, #0
 80277b0:	f040 80ba 	bne.w	8027928 <_svfprintf_r+0x1328>
 80277b4:	a925      	add	r1, sp, #148	; 0x94
 80277b6:	3d10      	subs	r5, #16
 80277b8:	460c      	mov	r4, r1
 80277ba:	e72c      	b.n	8027616 <_svfprintf_r+0x1016>
 80277bc:	9a05      	ldr	r2, [sp, #20]
 80277be:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80277c0:	2a01      	cmp	r2, #1
 80277c2:	9a03      	ldr	r2, [sp, #12]
 80277c4:	6022      	str	r2, [r4, #0]
 80277c6:	f107 0701 	add.w	r7, r7, #1
 80277ca:	f103 0301 	add.w	r3, r3, #1
 80277ce:	f04f 0201 	mov.w	r2, #1
 80277d2:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 80277d6:	f104 0508 	add.w	r5, r4, #8
 80277da:	6062      	str	r2, [r4, #4]
 80277dc:	dc02      	bgt.n	80277e4 <_svfprintf_r+0x11e4>
 80277de:	f01b 0f01 	tst.w	fp, #1
 80277e2:	d07b      	beq.n	80278dc <_svfprintf_r+0x12dc>
 80277e4:	2b07      	cmp	r3, #7
 80277e6:	dd08      	ble.n	80277fa <_svfprintf_r+0x11fa>
 80277e8:	aa22      	add	r2, sp, #136	; 0x88
 80277ea:	4649      	mov	r1, r9
 80277ec:	4650      	mov	r0, sl
 80277ee:	f001 fe1a 	bl	8029426 <__ssprint_r>
 80277f2:	2800      	cmp	r0, #0
 80277f4:	f040 8098 	bne.w	8027928 <_svfprintf_r+0x1328>
 80277f8:	ad25      	add	r5, sp, #148	; 0x94
 80277fa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80277fc:	602b      	str	r3, [r5, #0]
 80277fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027800:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027802:	606b      	str	r3, [r5, #4]
 8027804:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8027806:	4413      	add	r3, r2
 8027808:	9324      	str	r3, [sp, #144]	; 0x90
 802780a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802780c:	3301      	adds	r3, #1
 802780e:	2b07      	cmp	r3, #7
 8027810:	9323      	str	r3, [sp, #140]	; 0x8c
 8027812:	dc32      	bgt.n	802787a <_svfprintf_r+0x127a>
 8027814:	3508      	adds	r5, #8
 8027816:	9b05      	ldr	r3, [sp, #20]
 8027818:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 802781c:	1e5c      	subs	r4, r3, #1
 802781e:	2200      	movs	r2, #0
 8027820:	2300      	movs	r3, #0
 8027822:	e9dd 7623 	ldrd	r7, r6, [sp, #140]	; 0x8c
 8027826:	f7d9 f967 	bl	8000af8 <__aeabi_dcmpeq>
 802782a:	2800      	cmp	r0, #0
 802782c:	d12e      	bne.n	802788c <_svfprintf_r+0x128c>
 802782e:	9b03      	ldr	r3, [sp, #12]
 8027830:	3301      	adds	r3, #1
 8027832:	e9c5 3400 	strd	r3, r4, [r5]
 8027836:	9b05      	ldr	r3, [sp, #20]
 8027838:	3701      	adds	r7, #1
 802783a:	3e01      	subs	r6, #1
 802783c:	441e      	add	r6, r3
 802783e:	2f07      	cmp	r7, #7
 8027840:	e9cd 7623 	strd	r7, r6, [sp, #140]	; 0x8c
 8027844:	dd4d      	ble.n	80278e2 <_svfprintf_r+0x12e2>
 8027846:	aa22      	add	r2, sp, #136	; 0x88
 8027848:	4649      	mov	r1, r9
 802784a:	4650      	mov	r0, sl
 802784c:	f001 fdeb 	bl	8029426 <__ssprint_r>
 8027850:	2800      	cmp	r0, #0
 8027852:	d169      	bne.n	8027928 <_svfprintf_r+0x1328>
 8027854:	ad25      	add	r5, sp, #148	; 0x94
 8027856:	ab1e      	add	r3, sp, #120	; 0x78
 8027858:	602b      	str	r3, [r5, #0]
 802785a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802785c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802785e:	606b      	str	r3, [r5, #4]
 8027860:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8027862:	4413      	add	r3, r2
 8027864:	9324      	str	r3, [sp, #144]	; 0x90
 8027866:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027868:	3301      	adds	r3, #1
 802786a:	2b07      	cmp	r3, #7
 802786c:	9323      	str	r3, [sp, #140]	; 0x8c
 802786e:	f73f adac 	bgt.w	80273ca <_svfprintf_r+0xdca>
 8027872:	f105 0408 	add.w	r4, r5, #8
 8027876:	f7ff baa6 	b.w	8026dc6 <_svfprintf_r+0x7c6>
 802787a:	aa22      	add	r2, sp, #136	; 0x88
 802787c:	4649      	mov	r1, r9
 802787e:	4650      	mov	r0, sl
 8027880:	f001 fdd1 	bl	8029426 <__ssprint_r>
 8027884:	2800      	cmp	r0, #0
 8027886:	d14f      	bne.n	8027928 <_svfprintf_r+0x1328>
 8027888:	ad25      	add	r5, sp, #148	; 0x94
 802788a:	e7c4      	b.n	8027816 <_svfprintf_r+0x1216>
 802788c:	2c00      	cmp	r4, #0
 802788e:	dde2      	ble.n	8027856 <_svfprintf_r+0x1256>
 8027890:	4e09      	ldr	r6, [pc, #36]	; (80278b8 <_svfprintf_r+0x12b8>)
 8027892:	2710      	movs	r7, #16
 8027894:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8027898:	2c10      	cmp	r4, #16
 802789a:	f103 0301 	add.w	r3, r3, #1
 802789e:	f105 0108 	add.w	r1, r5, #8
 80278a2:	602e      	str	r6, [r5, #0]
 80278a4:	dc0a      	bgt.n	80278bc <_svfprintf_r+0x12bc>
 80278a6:	606c      	str	r4, [r5, #4]
 80278a8:	2b07      	cmp	r3, #7
 80278aa:	4414      	add	r4, r2
 80278ac:	e9cd 3423 	strd	r3, r4, [sp, #140]	; 0x8c
 80278b0:	dcc9      	bgt.n	8027846 <_svfprintf_r+0x1246>
 80278b2:	460d      	mov	r5, r1
 80278b4:	e7cf      	b.n	8027856 <_svfprintf_r+0x1256>
 80278b6:	bf00      	nop
 80278b8:	08036561 	.word	0x08036561
 80278bc:	3210      	adds	r2, #16
 80278be:	2b07      	cmp	r3, #7
 80278c0:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80278c4:	606f      	str	r7, [r5, #4]
 80278c6:	dd06      	ble.n	80278d6 <_svfprintf_r+0x12d6>
 80278c8:	aa22      	add	r2, sp, #136	; 0x88
 80278ca:	4649      	mov	r1, r9
 80278cc:	4650      	mov	r0, sl
 80278ce:	f001 fdaa 	bl	8029426 <__ssprint_r>
 80278d2:	bb48      	cbnz	r0, 8027928 <_svfprintf_r+0x1328>
 80278d4:	a925      	add	r1, sp, #148	; 0x94
 80278d6:	3c10      	subs	r4, #16
 80278d8:	460d      	mov	r5, r1
 80278da:	e7db      	b.n	8027894 <_svfprintf_r+0x1294>
 80278dc:	2b07      	cmp	r3, #7
 80278de:	ddba      	ble.n	8027856 <_svfprintf_r+0x1256>
 80278e0:	e7b1      	b.n	8027846 <_svfprintf_r+0x1246>
 80278e2:	3508      	adds	r5, #8
 80278e4:	e7b7      	b.n	8027856 <_svfprintf_r+0x1256>
 80278e6:	460c      	mov	r4, r1
 80278e8:	f7ff ba6d 	b.w	8026dc6 <_svfprintf_r+0x7c6>
 80278ec:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 80278f0:	1a9d      	subs	r5, r3, r2
 80278f2:	2d00      	cmp	r5, #0
 80278f4:	f77f aa6b 	ble.w	8026dce <_svfprintf_r+0x7ce>
 80278f8:	4e37      	ldr	r6, [pc, #220]	; (80279d8 <_svfprintf_r+0x13d8>)
 80278fa:	2710      	movs	r7, #16
 80278fc:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8027900:	2d10      	cmp	r5, #16
 8027902:	f103 0301 	add.w	r3, r3, #1
 8027906:	6026      	str	r6, [r4, #0]
 8027908:	dc18      	bgt.n	802793c <_svfprintf_r+0x133c>
 802790a:	6065      	str	r5, [r4, #4]
 802790c:	2b07      	cmp	r3, #7
 802790e:	4415      	add	r5, r2
 8027910:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 8027914:	f77f aa5b 	ble.w	8026dce <_svfprintf_r+0x7ce>
 8027918:	aa22      	add	r2, sp, #136	; 0x88
 802791a:	4649      	mov	r1, r9
 802791c:	4650      	mov	r0, sl
 802791e:	f001 fd82 	bl	8029426 <__ssprint_r>
 8027922:	2800      	cmp	r0, #0
 8027924:	f43f aa53 	beq.w	8026dce <_svfprintf_r+0x7ce>
 8027928:	9b04      	ldr	r3, [sp, #16]
 802792a:	2b00      	cmp	r3, #0
 802792c:	f43f a874 	beq.w	8026a18 <_svfprintf_r+0x418>
 8027930:	4619      	mov	r1, r3
 8027932:	4650      	mov	r0, sl
 8027934:	f7fe fb5e 	bl	8025ff4 <_free_r>
 8027938:	f7ff b86e 	b.w	8026a18 <_svfprintf_r+0x418>
 802793c:	3210      	adds	r2, #16
 802793e:	2b07      	cmp	r3, #7
 8027940:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8027944:	6067      	str	r7, [r4, #4]
 8027946:	dc02      	bgt.n	802794e <_svfprintf_r+0x134e>
 8027948:	3408      	adds	r4, #8
 802794a:	3d10      	subs	r5, #16
 802794c:	e7d6      	b.n	80278fc <_svfprintf_r+0x12fc>
 802794e:	aa22      	add	r2, sp, #136	; 0x88
 8027950:	4649      	mov	r1, r9
 8027952:	4650      	mov	r0, sl
 8027954:	f001 fd67 	bl	8029426 <__ssprint_r>
 8027958:	2800      	cmp	r0, #0
 802795a:	d1e5      	bne.n	8027928 <_svfprintf_r+0x1328>
 802795c:	ac25      	add	r4, sp, #148	; 0x94
 802795e:	e7f4      	b.n	802794a <_svfprintf_r+0x134a>
 8027960:	9904      	ldr	r1, [sp, #16]
 8027962:	4650      	mov	r0, sl
 8027964:	f7fe fb46 	bl	8025ff4 <_free_r>
 8027968:	f7ff ba49 	b.w	8026dfe <_svfprintf_r+0x7fe>
 802796c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802796e:	2b00      	cmp	r3, #0
 8027970:	f43f a852 	beq.w	8026a18 <_svfprintf_r+0x418>
 8027974:	aa22      	add	r2, sp, #136	; 0x88
 8027976:	4649      	mov	r1, r9
 8027978:	4650      	mov	r0, sl
 802797a:	f001 fd54 	bl	8029426 <__ssprint_r>
 802797e:	f7ff b84b 	b.w	8026a18 <_svfprintf_r+0x418>
 8027982:	ea55 0206 	orrs.w	r2, r5, r6
 8027986:	f8cd b010 	str.w	fp, [sp, #16]
 802798a:	f43f ab5e 	beq.w	802704a <_svfprintf_r+0xa4a>
 802798e:	2b01      	cmp	r3, #1
 8027990:	f43f abff 	beq.w	8027192 <_svfprintf_r+0xb92>
 8027994:	2b02      	cmp	r3, #2
 8027996:	ab4e      	add	r3, sp, #312	; 0x138
 8027998:	9303      	str	r3, [sp, #12]
 802799a:	f43f ac4d 	beq.w	8027238 <_svfprintf_r+0xc38>
 802799e:	9a03      	ldr	r2, [sp, #12]
 80279a0:	f005 0307 	and.w	r3, r5, #7
 80279a4:	4611      	mov	r1, r2
 80279a6:	3330      	adds	r3, #48	; 0x30
 80279a8:	f801 3d01 	strb.w	r3, [r1, #-1]!
 80279ac:	08ed      	lsrs	r5, r5, #3
 80279ae:	ea45 7546 	orr.w	r5, r5, r6, lsl #29
 80279b2:	08f6      	lsrs	r6, r6, #3
 80279b4:	9103      	str	r1, [sp, #12]
 80279b6:	ea55 0106 	orrs.w	r1, r5, r6
 80279ba:	d1f0      	bne.n	802799e <_svfprintf_r+0x139e>
 80279bc:	9904      	ldr	r1, [sp, #16]
 80279be:	07c9      	lsls	r1, r1, #31
 80279c0:	f57f ac2a 	bpl.w	8027218 <_svfprintf_r+0xc18>
 80279c4:	2b30      	cmp	r3, #48	; 0x30
 80279c6:	f43f ac27 	beq.w	8027218 <_svfprintf_r+0xc18>
 80279ca:	9903      	ldr	r1, [sp, #12]
 80279cc:	2330      	movs	r3, #48	; 0x30
 80279ce:	f801 3c01 	strb.w	r3, [r1, #-1]
 80279d2:	1e93      	subs	r3, r2, #2
 80279d4:	9303      	str	r3, [sp, #12]
 80279d6:	e41f      	b.n	8027218 <_svfprintf_r+0xc18>
 80279d8:	08036551 	.word	0x08036551

080279dc <_fclose_r>:
 80279dc:	b570      	push	{r4, r5, r6, lr}
 80279de:	4606      	mov	r6, r0
 80279e0:	460c      	mov	r4, r1
 80279e2:	b911      	cbnz	r1, 80279ea <_fclose_r+0xe>
 80279e4:	2500      	movs	r5, #0
 80279e6:	4628      	mov	r0, r5
 80279e8:	bd70      	pop	{r4, r5, r6, pc}
 80279ea:	b118      	cbz	r0, 80279f4 <_fclose_r+0x18>
 80279ec:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80279ee:	b90b      	cbnz	r3, 80279f4 <_fclose_r+0x18>
 80279f0:	f7fe f908 	bl	8025c04 <__sinit>
 80279f4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80279f6:	07d8      	lsls	r0, r3, #31
 80279f8:	d405      	bmi.n	8027a06 <_fclose_r+0x2a>
 80279fa:	89a3      	ldrh	r3, [r4, #12]
 80279fc:	0599      	lsls	r1, r3, #22
 80279fe:	d402      	bmi.n	8027a06 <_fclose_r+0x2a>
 8027a00:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027a02:	f7fe fa7b 	bl	8025efc <__retarget_lock_acquire_recursive>
 8027a06:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027a0a:	b93b      	cbnz	r3, 8027a1c <_fclose_r+0x40>
 8027a0c:	6e65      	ldr	r5, [r4, #100]	; 0x64
 8027a0e:	f015 0501 	ands.w	r5, r5, #1
 8027a12:	d1e7      	bne.n	80279e4 <_fclose_r+0x8>
 8027a14:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027a16:	f7fe fa72 	bl	8025efe <__retarget_lock_release_recursive>
 8027a1a:	e7e4      	b.n	80279e6 <_fclose_r+0xa>
 8027a1c:	4621      	mov	r1, r4
 8027a1e:	4630      	mov	r0, r6
 8027a20:	f000 f834 	bl	8027a8c <__sflush_r>
 8027a24:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8027a26:	4605      	mov	r5, r0
 8027a28:	b133      	cbz	r3, 8027a38 <_fclose_r+0x5c>
 8027a2a:	69e1      	ldr	r1, [r4, #28]
 8027a2c:	4630      	mov	r0, r6
 8027a2e:	4798      	blx	r3
 8027a30:	2800      	cmp	r0, #0
 8027a32:	bfb8      	it	lt
 8027a34:	f04f 35ff 	movlt.w	r5, #4294967295
 8027a38:	89a3      	ldrh	r3, [r4, #12]
 8027a3a:	061a      	lsls	r2, r3, #24
 8027a3c:	d503      	bpl.n	8027a46 <_fclose_r+0x6a>
 8027a3e:	6921      	ldr	r1, [r4, #16]
 8027a40:	4630      	mov	r0, r6
 8027a42:	f7fe fad7 	bl	8025ff4 <_free_r>
 8027a46:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8027a48:	b141      	cbz	r1, 8027a5c <_fclose_r+0x80>
 8027a4a:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8027a4e:	4299      	cmp	r1, r3
 8027a50:	d002      	beq.n	8027a58 <_fclose_r+0x7c>
 8027a52:	4630      	mov	r0, r6
 8027a54:	f7fe face 	bl	8025ff4 <_free_r>
 8027a58:	2300      	movs	r3, #0
 8027a5a:	6323      	str	r3, [r4, #48]	; 0x30
 8027a5c:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8027a5e:	b121      	cbz	r1, 8027a6a <_fclose_r+0x8e>
 8027a60:	4630      	mov	r0, r6
 8027a62:	f7fe fac7 	bl	8025ff4 <_free_r>
 8027a66:	2300      	movs	r3, #0
 8027a68:	6463      	str	r3, [r4, #68]	; 0x44
 8027a6a:	f7fe f8bf 	bl	8025bec <__sfp_lock_acquire>
 8027a6e:	2300      	movs	r3, #0
 8027a70:	81a3      	strh	r3, [r4, #12]
 8027a72:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8027a74:	07db      	lsls	r3, r3, #31
 8027a76:	d402      	bmi.n	8027a7e <_fclose_r+0xa2>
 8027a78:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027a7a:	f7fe fa40 	bl	8025efe <__retarget_lock_release_recursive>
 8027a7e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027a80:	f7fe fa3b 	bl	8025efa <__retarget_lock_close_recursive>
 8027a84:	f7fe f8b8 	bl	8025bf8 <__sfp_lock_release>
 8027a88:	e7ad      	b.n	80279e6 <_fclose_r+0xa>
	...

08027a8c <__sflush_r>:
 8027a8c:	898b      	ldrh	r3, [r1, #12]
 8027a8e:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8027a92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027a96:	4605      	mov	r5, r0
 8027a98:	0718      	lsls	r0, r3, #28
 8027a9a:	460c      	mov	r4, r1
 8027a9c:	d45f      	bmi.n	8027b5e <__sflush_r+0xd2>
 8027a9e:	684b      	ldr	r3, [r1, #4]
 8027aa0:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8027aa4:	2b00      	cmp	r3, #0
 8027aa6:	818a      	strh	r2, [r1, #12]
 8027aa8:	dc05      	bgt.n	8027ab6 <__sflush_r+0x2a>
 8027aaa:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8027aac:	2b00      	cmp	r3, #0
 8027aae:	dc02      	bgt.n	8027ab6 <__sflush_r+0x2a>
 8027ab0:	2000      	movs	r0, #0
 8027ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027ab6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8027ab8:	2e00      	cmp	r6, #0
 8027aba:	d0f9      	beq.n	8027ab0 <__sflush_r+0x24>
 8027abc:	2300      	movs	r3, #0
 8027abe:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8027ac2:	682f      	ldr	r7, [r5, #0]
 8027ac4:	69e1      	ldr	r1, [r4, #28]
 8027ac6:	602b      	str	r3, [r5, #0]
 8027ac8:	d036      	beq.n	8027b38 <__sflush_r+0xac>
 8027aca:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8027acc:	89a3      	ldrh	r3, [r4, #12]
 8027ace:	075a      	lsls	r2, r3, #29
 8027ad0:	d505      	bpl.n	8027ade <__sflush_r+0x52>
 8027ad2:	6863      	ldr	r3, [r4, #4]
 8027ad4:	1ac0      	subs	r0, r0, r3
 8027ad6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8027ad8:	b10b      	cbz	r3, 8027ade <__sflush_r+0x52>
 8027ada:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8027adc:	1ac0      	subs	r0, r0, r3
 8027ade:	2300      	movs	r3, #0
 8027ae0:	4602      	mov	r2, r0
 8027ae2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8027ae4:	69e1      	ldr	r1, [r4, #28]
 8027ae6:	4628      	mov	r0, r5
 8027ae8:	47b0      	blx	r6
 8027aea:	1c43      	adds	r3, r0, #1
 8027aec:	89a3      	ldrh	r3, [r4, #12]
 8027aee:	d106      	bne.n	8027afe <__sflush_r+0x72>
 8027af0:	6829      	ldr	r1, [r5, #0]
 8027af2:	291d      	cmp	r1, #29
 8027af4:	d82f      	bhi.n	8027b56 <__sflush_r+0xca>
 8027af6:	4a2b      	ldr	r2, [pc, #172]	; (8027ba4 <__sflush_r+0x118>)
 8027af8:	410a      	asrs	r2, r1
 8027afa:	07d6      	lsls	r6, r2, #31
 8027afc:	d42b      	bmi.n	8027b56 <__sflush_r+0xca>
 8027afe:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8027b02:	b21b      	sxth	r3, r3
 8027b04:	2200      	movs	r2, #0
 8027b06:	6062      	str	r2, [r4, #4]
 8027b08:	04d9      	lsls	r1, r3, #19
 8027b0a:	6922      	ldr	r2, [r4, #16]
 8027b0c:	81a3      	strh	r3, [r4, #12]
 8027b0e:	6022      	str	r2, [r4, #0]
 8027b10:	d504      	bpl.n	8027b1c <__sflush_r+0x90>
 8027b12:	1c42      	adds	r2, r0, #1
 8027b14:	d101      	bne.n	8027b1a <__sflush_r+0x8e>
 8027b16:	682b      	ldr	r3, [r5, #0]
 8027b18:	b903      	cbnz	r3, 8027b1c <__sflush_r+0x90>
 8027b1a:	6520      	str	r0, [r4, #80]	; 0x50
 8027b1c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8027b1e:	602f      	str	r7, [r5, #0]
 8027b20:	2900      	cmp	r1, #0
 8027b22:	d0c5      	beq.n	8027ab0 <__sflush_r+0x24>
 8027b24:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8027b28:	4299      	cmp	r1, r3
 8027b2a:	d002      	beq.n	8027b32 <__sflush_r+0xa6>
 8027b2c:	4628      	mov	r0, r5
 8027b2e:	f7fe fa61 	bl	8025ff4 <_free_r>
 8027b32:	2000      	movs	r0, #0
 8027b34:	6320      	str	r0, [r4, #48]	; 0x30
 8027b36:	e7bc      	b.n	8027ab2 <__sflush_r+0x26>
 8027b38:	2301      	movs	r3, #1
 8027b3a:	4628      	mov	r0, r5
 8027b3c:	47b0      	blx	r6
 8027b3e:	1c41      	adds	r1, r0, #1
 8027b40:	d1c4      	bne.n	8027acc <__sflush_r+0x40>
 8027b42:	682b      	ldr	r3, [r5, #0]
 8027b44:	2b00      	cmp	r3, #0
 8027b46:	d0c1      	beq.n	8027acc <__sflush_r+0x40>
 8027b48:	2b1d      	cmp	r3, #29
 8027b4a:	d001      	beq.n	8027b50 <__sflush_r+0xc4>
 8027b4c:	2b16      	cmp	r3, #22
 8027b4e:	d101      	bne.n	8027b54 <__sflush_r+0xc8>
 8027b50:	602f      	str	r7, [r5, #0]
 8027b52:	e7ad      	b.n	8027ab0 <__sflush_r+0x24>
 8027b54:	89a3      	ldrh	r3, [r4, #12]
 8027b56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8027b5a:	81a3      	strh	r3, [r4, #12]
 8027b5c:	e7a9      	b.n	8027ab2 <__sflush_r+0x26>
 8027b5e:	690f      	ldr	r7, [r1, #16]
 8027b60:	2f00      	cmp	r7, #0
 8027b62:	d0a5      	beq.n	8027ab0 <__sflush_r+0x24>
 8027b64:	079b      	lsls	r3, r3, #30
 8027b66:	680e      	ldr	r6, [r1, #0]
 8027b68:	bf08      	it	eq
 8027b6a:	694b      	ldreq	r3, [r1, #20]
 8027b6c:	600f      	str	r7, [r1, #0]
 8027b6e:	bf18      	it	ne
 8027b70:	2300      	movne	r3, #0
 8027b72:	eba6 0807 	sub.w	r8, r6, r7
 8027b76:	608b      	str	r3, [r1, #8]
 8027b78:	f1b8 0f00 	cmp.w	r8, #0
 8027b7c:	dd98      	ble.n	8027ab0 <__sflush_r+0x24>
 8027b7e:	69e1      	ldr	r1, [r4, #28]
 8027b80:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8027b82:	4643      	mov	r3, r8
 8027b84:	463a      	mov	r2, r7
 8027b86:	4628      	mov	r0, r5
 8027b88:	47b0      	blx	r6
 8027b8a:	2800      	cmp	r0, #0
 8027b8c:	dc06      	bgt.n	8027b9c <__sflush_r+0x110>
 8027b8e:	89a3      	ldrh	r3, [r4, #12]
 8027b90:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8027b94:	81a3      	strh	r3, [r4, #12]
 8027b96:	f04f 30ff 	mov.w	r0, #4294967295
 8027b9a:	e78a      	b.n	8027ab2 <__sflush_r+0x26>
 8027b9c:	4407      	add	r7, r0
 8027b9e:	eba8 0800 	sub.w	r8, r8, r0
 8027ba2:	e7e9      	b.n	8027b78 <__sflush_r+0xec>
 8027ba4:	dfbffffe 	.word	0xdfbffffe

08027ba8 <_fflush_r>:
 8027ba8:	b538      	push	{r3, r4, r5, lr}
 8027baa:	460c      	mov	r4, r1
 8027bac:	4605      	mov	r5, r0
 8027bae:	b118      	cbz	r0, 8027bb8 <_fflush_r+0x10>
 8027bb0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8027bb2:	b90b      	cbnz	r3, 8027bb8 <_fflush_r+0x10>
 8027bb4:	f7fe f826 	bl	8025c04 <__sinit>
 8027bb8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027bbc:	b1bb      	cbz	r3, 8027bee <_fflush_r+0x46>
 8027bbe:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8027bc0:	07d0      	lsls	r0, r2, #31
 8027bc2:	d404      	bmi.n	8027bce <_fflush_r+0x26>
 8027bc4:	0599      	lsls	r1, r3, #22
 8027bc6:	d402      	bmi.n	8027bce <_fflush_r+0x26>
 8027bc8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027bca:	f7fe f997 	bl	8025efc <__retarget_lock_acquire_recursive>
 8027bce:	4628      	mov	r0, r5
 8027bd0:	4621      	mov	r1, r4
 8027bd2:	f7ff ff5b 	bl	8027a8c <__sflush_r>
 8027bd6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8027bd8:	07da      	lsls	r2, r3, #31
 8027bda:	4605      	mov	r5, r0
 8027bdc:	d405      	bmi.n	8027bea <_fflush_r+0x42>
 8027bde:	89a3      	ldrh	r3, [r4, #12]
 8027be0:	059b      	lsls	r3, r3, #22
 8027be2:	d402      	bmi.n	8027bea <_fflush_r+0x42>
 8027be4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027be6:	f7fe f98a 	bl	8025efe <__retarget_lock_release_recursive>
 8027bea:	4628      	mov	r0, r5
 8027bec:	bd38      	pop	{r3, r4, r5, pc}
 8027bee:	461d      	mov	r5, r3
 8027bf0:	e7fb      	b.n	8027bea <_fflush_r+0x42>

08027bf2 <strncpy>:
 8027bf2:	b510      	push	{r4, lr}
 8027bf4:	3901      	subs	r1, #1
 8027bf6:	4603      	mov	r3, r0
 8027bf8:	b132      	cbz	r2, 8027c08 <strncpy+0x16>
 8027bfa:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8027bfe:	f803 4b01 	strb.w	r4, [r3], #1
 8027c02:	3a01      	subs	r2, #1
 8027c04:	2c00      	cmp	r4, #0
 8027c06:	d1f7      	bne.n	8027bf8 <strncpy+0x6>
 8027c08:	441a      	add	r2, r3
 8027c0a:	2100      	movs	r1, #0
 8027c0c:	4293      	cmp	r3, r2
 8027c0e:	d100      	bne.n	8027c12 <strncpy+0x20>
 8027c10:	bd10      	pop	{r4, pc}
 8027c12:	f803 1b01 	strb.w	r1, [r3], #1
 8027c16:	e7f9      	b.n	8027c0c <strncpy+0x1a>

08027c18 <__locale_mb_cur_max>:
 8027c18:	4b01      	ldr	r3, [pc, #4]	; (8027c20 <__locale_mb_cur_max+0x8>)
 8027c1a:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 8027c1e:	4770      	bx	lr
 8027c20:	20000798 	.word	0x20000798

08027c24 <_localeconv_r>:
 8027c24:	4800      	ldr	r0, [pc, #0]	; (8027c28 <_localeconv_r+0x4>)
 8027c26:	4770      	bx	lr
 8027c28:	20000888 	.word	0x20000888

08027c2c <_sbrk_r>:
 8027c2c:	b538      	push	{r3, r4, r5, lr}
 8027c2e:	4d06      	ldr	r5, [pc, #24]	; (8027c48 <_sbrk_r+0x1c>)
 8027c30:	2300      	movs	r3, #0
 8027c32:	4604      	mov	r4, r0
 8027c34:	4608      	mov	r0, r1
 8027c36:	602b      	str	r3, [r5, #0]
 8027c38:	f7d9 fe06 	bl	8001848 <_sbrk>
 8027c3c:	1c43      	adds	r3, r0, #1
 8027c3e:	d102      	bne.n	8027c46 <_sbrk_r+0x1a>
 8027c40:	682b      	ldr	r3, [r5, #0]
 8027c42:	b103      	cbz	r3, 8027c46 <_sbrk_r+0x1a>
 8027c44:	6023      	str	r3, [r4, #0]
 8027c46:	bd38      	pop	{r3, r4, r5, pc}
 8027c48:	20011ed8 	.word	0x20011ed8

08027c4c <__libc_fini_array>:
 8027c4c:	b538      	push	{r3, r4, r5, lr}
 8027c4e:	4d07      	ldr	r5, [pc, #28]	; (8027c6c <__libc_fini_array+0x20>)
 8027c50:	4c07      	ldr	r4, [pc, #28]	; (8027c70 <__libc_fini_array+0x24>)
 8027c52:	1b64      	subs	r4, r4, r5
 8027c54:	10a4      	asrs	r4, r4, #2
 8027c56:	b91c      	cbnz	r4, 8027c60 <__libc_fini_array+0x14>
 8027c58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8027c5c:	f002 bd28 	b.w	802a6b0 <_fini>
 8027c60:	3c01      	subs	r4, #1
 8027c62:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8027c66:	4798      	blx	r3
 8027c68:	e7f5      	b.n	8027c56 <__libc_fini_array+0xa>
 8027c6a:	bf00      	nop
 8027c6c:	080367b8 	.word	0x080367b8
 8027c70:	080367bc 	.word	0x080367bc

08027c74 <sysconf>:
 8027c74:	2808      	cmp	r0, #8
 8027c76:	b508      	push	{r3, lr}
 8027c78:	d006      	beq.n	8027c88 <sysconf+0x14>
 8027c7a:	f7fe f913 	bl	8025ea4 <__errno>
 8027c7e:	2316      	movs	r3, #22
 8027c80:	6003      	str	r3, [r0, #0]
 8027c82:	f04f 30ff 	mov.w	r0, #4294967295
 8027c86:	bd08      	pop	{r3, pc}
 8027c88:	2080      	movs	r0, #128	; 0x80
 8027c8a:	e7fc      	b.n	8027c86 <sysconf+0x12>

08027c8c <frexp>:
 8027c8c:	b570      	push	{r4, r5, r6, lr}
 8027c8e:	2100      	movs	r1, #0
 8027c90:	ec55 4b10 	vmov	r4, r5, d0
 8027c94:	6001      	str	r1, [r0, #0]
 8027c96:	4916      	ldr	r1, [pc, #88]	; (8027cf0 <frexp+0x64>)
 8027c98:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
 8027c9c:	428a      	cmp	r2, r1
 8027c9e:	4606      	mov	r6, r0
 8027ca0:	462b      	mov	r3, r5
 8027ca2:	dc22      	bgt.n	8027cea <frexp+0x5e>
 8027ca4:	ee10 1a10 	vmov	r1, s0
 8027ca8:	4311      	orrs	r1, r2
 8027caa:	d01e      	beq.n	8027cea <frexp+0x5e>
 8027cac:	4911      	ldr	r1, [pc, #68]	; (8027cf4 <frexp+0x68>)
 8027cae:	4029      	ands	r1, r5
 8027cb0:	b969      	cbnz	r1, 8027cce <frexp+0x42>
 8027cb2:	4b11      	ldr	r3, [pc, #68]	; (8027cf8 <frexp+0x6c>)
 8027cb4:	2200      	movs	r2, #0
 8027cb6:	ee10 0a10 	vmov	r0, s0
 8027cba:	4629      	mov	r1, r5
 8027cbc:	f7d8 fcb4 	bl	8000628 <__aeabi_dmul>
 8027cc0:	460b      	mov	r3, r1
 8027cc2:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 8027cc6:	f06f 0135 	mvn.w	r1, #53	; 0x35
 8027cca:	4604      	mov	r4, r0
 8027ccc:	6031      	str	r1, [r6, #0]
 8027cce:	6831      	ldr	r1, [r6, #0]
 8027cd0:	1512      	asrs	r2, r2, #20
 8027cd2:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8027cd6:	f2a2 32fe 	subw	r2, r2, #1022	; 0x3fe
 8027cda:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8027cde:	4411      	add	r1, r2
 8027ce0:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
 8027ce4:	6031      	str	r1, [r6, #0]
 8027ce6:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
 8027cea:	ec45 4b10 	vmov	d0, r4, r5
 8027cee:	bd70      	pop	{r4, r5, r6, pc}
 8027cf0:	7fefffff 	.word	0x7fefffff
 8027cf4:	7ff00000 	.word	0x7ff00000
 8027cf8:	43500000 	.word	0x43500000

08027cfc <__register_exitproc>:
 8027cfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8027d00:	f8df a074 	ldr.w	sl, [pc, #116]	; 8027d78 <__register_exitproc+0x7c>
 8027d04:	4606      	mov	r6, r0
 8027d06:	f8da 0000 	ldr.w	r0, [sl]
 8027d0a:	4698      	mov	r8, r3
 8027d0c:	460f      	mov	r7, r1
 8027d0e:	4691      	mov	r9, r2
 8027d10:	f7fe f8f4 	bl	8025efc <__retarget_lock_acquire_recursive>
 8027d14:	4b16      	ldr	r3, [pc, #88]	; (8027d70 <__register_exitproc+0x74>)
 8027d16:	681c      	ldr	r4, [r3, #0]
 8027d18:	b90c      	cbnz	r4, 8027d1e <__register_exitproc+0x22>
 8027d1a:	4c16      	ldr	r4, [pc, #88]	; (8027d74 <__register_exitproc+0x78>)
 8027d1c:	601c      	str	r4, [r3, #0]
 8027d1e:	6865      	ldr	r5, [r4, #4]
 8027d20:	f8da 0000 	ldr.w	r0, [sl]
 8027d24:	2d1f      	cmp	r5, #31
 8027d26:	dd05      	ble.n	8027d34 <__register_exitproc+0x38>
 8027d28:	f7fe f8e9 	bl	8025efe <__retarget_lock_release_recursive>
 8027d2c:	f04f 30ff 	mov.w	r0, #4294967295
 8027d30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027d34:	b19e      	cbz	r6, 8027d5e <__register_exitproc+0x62>
 8027d36:	eb04 0185 	add.w	r1, r4, r5, lsl #2
 8027d3a:	2201      	movs	r2, #1
 8027d3c:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
 8027d40:	f8d4 3188 	ldr.w	r3, [r4, #392]	; 0x188
 8027d44:	40aa      	lsls	r2, r5
 8027d46:	4313      	orrs	r3, r2
 8027d48:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
 8027d4c:	2e02      	cmp	r6, #2
 8027d4e:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
 8027d52:	bf02      	ittt	eq
 8027d54:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 8027d58:	4313      	orreq	r3, r2
 8027d5a:	f8c4 318c 	streq.w	r3, [r4, #396]	; 0x18c
 8027d5e:	1c6b      	adds	r3, r5, #1
 8027d60:	3502      	adds	r5, #2
 8027d62:	6063      	str	r3, [r4, #4]
 8027d64:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
 8027d68:	f7fe f8c9 	bl	8025efe <__retarget_lock_release_recursive>
 8027d6c:	2000      	movs	r0, #0
 8027d6e:	e7df      	b.n	8027d30 <__register_exitproc+0x34>
 8027d70:	20011ee0 	.word	0x20011ee0
 8027d74:	20011f18 	.word	0x20011f18
 8027d78:	20000384 	.word	0x20000384

08027d7c <quorem>:
 8027d7c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027d80:	6903      	ldr	r3, [r0, #16]
 8027d82:	690c      	ldr	r4, [r1, #16]
 8027d84:	42a3      	cmp	r3, r4
 8027d86:	4607      	mov	r7, r0
 8027d88:	db7e      	blt.n	8027e88 <quorem+0x10c>
 8027d8a:	3c01      	subs	r4, #1
 8027d8c:	f101 0814 	add.w	r8, r1, #20
 8027d90:	f100 0514 	add.w	r5, r0, #20
 8027d94:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8027d98:	9301      	str	r3, [sp, #4]
 8027d9a:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8027d9e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8027da2:	3301      	adds	r3, #1
 8027da4:	429a      	cmp	r2, r3
 8027da6:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 8027daa:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 8027dae:	fbb2 f6f3 	udiv	r6, r2, r3
 8027db2:	d331      	bcc.n	8027e18 <quorem+0x9c>
 8027db4:	f04f 0e00 	mov.w	lr, #0
 8027db8:	4640      	mov	r0, r8
 8027dba:	46ac      	mov	ip, r5
 8027dbc:	46f2      	mov	sl, lr
 8027dbe:	f850 2b04 	ldr.w	r2, [r0], #4
 8027dc2:	b293      	uxth	r3, r2
 8027dc4:	fb06 e303 	mla	r3, r6, r3, lr
 8027dc8:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 8027dcc:	0c1a      	lsrs	r2, r3, #16
 8027dce:	b29b      	uxth	r3, r3
 8027dd0:	ebaa 0303 	sub.w	r3, sl, r3
 8027dd4:	f8dc a000 	ldr.w	sl, [ip]
 8027dd8:	fa13 f38a 	uxtah	r3, r3, sl
 8027ddc:	fb06 220e 	mla	r2, r6, lr, r2
 8027de0:	9300      	str	r3, [sp, #0]
 8027de2:	9b00      	ldr	r3, [sp, #0]
 8027de4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 8027de8:	b292      	uxth	r2, r2
 8027dea:	ebc2 421a 	rsb	r2, r2, sl, lsr #16
 8027dee:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8027df2:	f8bd 3000 	ldrh.w	r3, [sp]
 8027df6:	4581      	cmp	r9, r0
 8027df8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8027dfc:	f84c 3b04 	str.w	r3, [ip], #4
 8027e00:	ea4f 4a22 	mov.w	sl, r2, asr #16
 8027e04:	d2db      	bcs.n	8027dbe <quorem+0x42>
 8027e06:	f855 300b 	ldr.w	r3, [r5, fp]
 8027e0a:	b92b      	cbnz	r3, 8027e18 <quorem+0x9c>
 8027e0c:	9b01      	ldr	r3, [sp, #4]
 8027e0e:	3b04      	subs	r3, #4
 8027e10:	429d      	cmp	r5, r3
 8027e12:	461a      	mov	r2, r3
 8027e14:	d32c      	bcc.n	8027e70 <quorem+0xf4>
 8027e16:	613c      	str	r4, [r7, #16]
 8027e18:	4638      	mov	r0, r7
 8027e1a:	f001 f84f 	bl	8028ebc <__mcmp>
 8027e1e:	2800      	cmp	r0, #0
 8027e20:	db22      	blt.n	8027e68 <quorem+0xec>
 8027e22:	3601      	adds	r6, #1
 8027e24:	4629      	mov	r1, r5
 8027e26:	2000      	movs	r0, #0
 8027e28:	f858 2b04 	ldr.w	r2, [r8], #4
 8027e2c:	f8d1 c000 	ldr.w	ip, [r1]
 8027e30:	b293      	uxth	r3, r2
 8027e32:	1ac3      	subs	r3, r0, r3
 8027e34:	0c12      	lsrs	r2, r2, #16
 8027e36:	fa13 f38c 	uxtah	r3, r3, ip
 8027e3a:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
 8027e3e:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8027e42:	b29b      	uxth	r3, r3
 8027e44:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8027e48:	45c1      	cmp	r9, r8
 8027e4a:	f841 3b04 	str.w	r3, [r1], #4
 8027e4e:	ea4f 4022 	mov.w	r0, r2, asr #16
 8027e52:	d2e9      	bcs.n	8027e28 <quorem+0xac>
 8027e54:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8027e58:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8027e5c:	b922      	cbnz	r2, 8027e68 <quorem+0xec>
 8027e5e:	3b04      	subs	r3, #4
 8027e60:	429d      	cmp	r5, r3
 8027e62:	461a      	mov	r2, r3
 8027e64:	d30a      	bcc.n	8027e7c <quorem+0x100>
 8027e66:	613c      	str	r4, [r7, #16]
 8027e68:	4630      	mov	r0, r6
 8027e6a:	b003      	add	sp, #12
 8027e6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027e70:	6812      	ldr	r2, [r2, #0]
 8027e72:	3b04      	subs	r3, #4
 8027e74:	2a00      	cmp	r2, #0
 8027e76:	d1ce      	bne.n	8027e16 <quorem+0x9a>
 8027e78:	3c01      	subs	r4, #1
 8027e7a:	e7c9      	b.n	8027e10 <quorem+0x94>
 8027e7c:	6812      	ldr	r2, [r2, #0]
 8027e7e:	3b04      	subs	r3, #4
 8027e80:	2a00      	cmp	r2, #0
 8027e82:	d1f0      	bne.n	8027e66 <quorem+0xea>
 8027e84:	3c01      	subs	r4, #1
 8027e86:	e7eb      	b.n	8027e60 <quorem+0xe4>
 8027e88:	2000      	movs	r0, #0
 8027e8a:	e7ee      	b.n	8027e6a <quorem+0xee>
 8027e8c:	0000      	movs	r0, r0
	...

08027e90 <_dtoa_r>:
 8027e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027e94:	ed2d 8b04 	vpush	{d8-d9}
 8027e98:	b093      	sub	sp, #76	; 0x4c
 8027e9a:	ed8d 0b02 	vstr	d0, [sp, #8]
 8027e9e:	9107      	str	r1, [sp, #28]
 8027ea0:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8027ea2:	9d20      	ldr	r5, [sp, #128]	; 0x80
 8027ea4:	920a      	str	r2, [sp, #40]	; 0x28
 8027ea6:	ec57 6b10 	vmov	r6, r7, d0
 8027eaa:	4604      	mov	r4, r0
 8027eac:	930d      	str	r3, [sp, #52]	; 0x34
 8027eae:	b141      	cbz	r1, 8027ec2 <_dtoa_r+0x32>
 8027eb0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8027eb2:	604a      	str	r2, [r1, #4]
 8027eb4:	2301      	movs	r3, #1
 8027eb6:	4093      	lsls	r3, r2
 8027eb8:	608b      	str	r3, [r1, #8]
 8027eba:	f000 fdf6 	bl	8028aaa <_Bfree>
 8027ebe:	2300      	movs	r3, #0
 8027ec0:	63a3      	str	r3, [r4, #56]	; 0x38
 8027ec2:	1e3b      	subs	r3, r7, #0
 8027ec4:	bfb9      	ittee	lt
 8027ec6:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 8027eca:	9303      	strlt	r3, [sp, #12]
 8027ecc:	2300      	movge	r3, #0
 8027ece:	602b      	strge	r3, [r5, #0]
 8027ed0:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8027ed4:	4ba2      	ldr	r3, [pc, #648]	; (8028160 <_dtoa_r+0x2d0>)
 8027ed6:	bfbc      	itt	lt
 8027ed8:	2201      	movlt	r2, #1
 8027eda:	602a      	strlt	r2, [r5, #0]
 8027edc:	ea33 0308 	bics.w	r3, r3, r8
 8027ee0:	d11b      	bne.n	8027f1a <_dtoa_r+0x8a>
 8027ee2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8027ee4:	f242 730f 	movw	r3, #9999	; 0x270f
 8027ee8:	6013      	str	r3, [r2, #0]
 8027eea:	f3c8 0313 	ubfx	r3, r8, #0, #20
 8027eee:	4333      	orrs	r3, r6
 8027ef0:	f000 858f 	beq.w	8028a12 <_dtoa_r+0xb82>
 8027ef4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8027ef6:	b90b      	cbnz	r3, 8027efc <_dtoa_r+0x6c>
 8027ef8:	4b9a      	ldr	r3, [pc, #616]	; (8028164 <_dtoa_r+0x2d4>)
 8027efa:	e027      	b.n	8027f4c <_dtoa_r+0xbc>
 8027efc:	4b99      	ldr	r3, [pc, #612]	; (8028164 <_dtoa_r+0x2d4>)
 8027efe:	9300      	str	r3, [sp, #0]
 8027f00:	3303      	adds	r3, #3
 8027f02:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8027f04:	6013      	str	r3, [r2, #0]
 8027f06:	9800      	ldr	r0, [sp, #0]
 8027f08:	b013      	add	sp, #76	; 0x4c
 8027f0a:	ecbd 8b04 	vpop	{d8-d9}
 8027f0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027f12:	4b95      	ldr	r3, [pc, #596]	; (8028168 <_dtoa_r+0x2d8>)
 8027f14:	9300      	str	r3, [sp, #0]
 8027f16:	3308      	adds	r3, #8
 8027f18:	e7f3      	b.n	8027f02 <_dtoa_r+0x72>
 8027f1a:	ed9d 7b02 	vldr	d7, [sp, #8]
 8027f1e:	2200      	movs	r2, #0
 8027f20:	ec51 0b17 	vmov	r0, r1, d7
 8027f24:	eeb0 8a47 	vmov.f32	s16, s14
 8027f28:	eef0 8a67 	vmov.f32	s17, s15
 8027f2c:	2300      	movs	r3, #0
 8027f2e:	f7d8 fde3 	bl	8000af8 <__aeabi_dcmpeq>
 8027f32:	4681      	mov	r9, r0
 8027f34:	b160      	cbz	r0, 8027f50 <_dtoa_r+0xc0>
 8027f36:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8027f38:	2301      	movs	r3, #1
 8027f3a:	6013      	str	r3, [r2, #0]
 8027f3c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8027f3e:	2b00      	cmp	r3, #0
 8027f40:	f000 8564 	beq.w	8028a0c <_dtoa_r+0xb7c>
 8027f44:	4b89      	ldr	r3, [pc, #548]	; (802816c <_dtoa_r+0x2dc>)
 8027f46:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8027f48:	6013      	str	r3, [r2, #0]
 8027f4a:	3b01      	subs	r3, #1
 8027f4c:	9300      	str	r3, [sp, #0]
 8027f4e:	e7da      	b.n	8027f06 <_dtoa_r+0x76>
 8027f50:	aa10      	add	r2, sp, #64	; 0x40
 8027f52:	a911      	add	r1, sp, #68	; 0x44
 8027f54:	4620      	mov	r0, r4
 8027f56:	eeb0 0a48 	vmov.f32	s0, s16
 8027f5a:	eef0 0a68 	vmov.f32	s1, s17
 8027f5e:	f001 f853 	bl	8029008 <__d2b>
 8027f62:	f3c8 550a 	ubfx	r5, r8, #20, #11
 8027f66:	4682      	mov	sl, r0
 8027f68:	2d00      	cmp	r5, #0
 8027f6a:	d07e      	beq.n	802806a <_dtoa_r+0x1da>
 8027f6c:	ee18 3a90 	vmov	r3, s17
 8027f70:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8027f74:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
 8027f78:	ec51 0b18 	vmov	r0, r1, d8
 8027f7c:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8027f80:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8027f84:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 8027f88:	4619      	mov	r1, r3
 8027f8a:	2200      	movs	r2, #0
 8027f8c:	4b78      	ldr	r3, [pc, #480]	; (8028170 <_dtoa_r+0x2e0>)
 8027f8e:	f7d8 f993 	bl	80002b8 <__aeabi_dsub>
 8027f92:	a36d      	add	r3, pc, #436	; (adr r3, 8028148 <_dtoa_r+0x2b8>)
 8027f94:	e9d3 2300 	ldrd	r2, r3, [r3]
 8027f98:	f7d8 fb46 	bl	8000628 <__aeabi_dmul>
 8027f9c:	a36c      	add	r3, pc, #432	; (adr r3, 8028150 <_dtoa_r+0x2c0>)
 8027f9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8027fa2:	f7d8 f98b 	bl	80002bc <__adddf3>
 8027fa6:	4606      	mov	r6, r0
 8027fa8:	4628      	mov	r0, r5
 8027faa:	460f      	mov	r7, r1
 8027fac:	f7d8 fad2 	bl	8000554 <__aeabi_i2d>
 8027fb0:	a369      	add	r3, pc, #420	; (adr r3, 8028158 <_dtoa_r+0x2c8>)
 8027fb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8027fb6:	f7d8 fb37 	bl	8000628 <__aeabi_dmul>
 8027fba:	4602      	mov	r2, r0
 8027fbc:	460b      	mov	r3, r1
 8027fbe:	4630      	mov	r0, r6
 8027fc0:	4639      	mov	r1, r7
 8027fc2:	f7d8 f97b 	bl	80002bc <__adddf3>
 8027fc6:	4606      	mov	r6, r0
 8027fc8:	460f      	mov	r7, r1
 8027fca:	f7d8 fddd 	bl	8000b88 <__aeabi_d2iz>
 8027fce:	2200      	movs	r2, #0
 8027fd0:	4683      	mov	fp, r0
 8027fd2:	2300      	movs	r3, #0
 8027fd4:	4630      	mov	r0, r6
 8027fd6:	4639      	mov	r1, r7
 8027fd8:	f7d8 fd98 	bl	8000b0c <__aeabi_dcmplt>
 8027fdc:	b148      	cbz	r0, 8027ff2 <_dtoa_r+0x162>
 8027fde:	4658      	mov	r0, fp
 8027fe0:	f7d8 fab8 	bl	8000554 <__aeabi_i2d>
 8027fe4:	4632      	mov	r2, r6
 8027fe6:	463b      	mov	r3, r7
 8027fe8:	f7d8 fd86 	bl	8000af8 <__aeabi_dcmpeq>
 8027fec:	b908      	cbnz	r0, 8027ff2 <_dtoa_r+0x162>
 8027fee:	f10b 3bff 	add.w	fp, fp, #4294967295
 8027ff2:	f1bb 0f16 	cmp.w	fp, #22
 8027ff6:	d856      	bhi.n	80280a6 <_dtoa_r+0x216>
 8027ff8:	4b5e      	ldr	r3, [pc, #376]	; (8028174 <_dtoa_r+0x2e4>)
 8027ffa:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8027ffe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028002:	ec51 0b18 	vmov	r0, r1, d8
 8028006:	f7d8 fd81 	bl	8000b0c <__aeabi_dcmplt>
 802800a:	2800      	cmp	r0, #0
 802800c:	d04d      	beq.n	80280aa <_dtoa_r+0x21a>
 802800e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8028012:	2300      	movs	r3, #0
 8028014:	930c      	str	r3, [sp, #48]	; 0x30
 8028016:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8028018:	1b5b      	subs	r3, r3, r5
 802801a:	1e5a      	subs	r2, r3, #1
 802801c:	bf45      	ittet	mi
 802801e:	f1c3 0301 	rsbmi	r3, r3, #1
 8028022:	9305      	strmi	r3, [sp, #20]
 8028024:	2300      	movpl	r3, #0
 8028026:	2300      	movmi	r3, #0
 8028028:	9206      	str	r2, [sp, #24]
 802802a:	bf54      	ite	pl
 802802c:	9305      	strpl	r3, [sp, #20]
 802802e:	9306      	strmi	r3, [sp, #24]
 8028030:	f1bb 0f00 	cmp.w	fp, #0
 8028034:	db3b      	blt.n	80280ae <_dtoa_r+0x21e>
 8028036:	9b06      	ldr	r3, [sp, #24]
 8028038:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 802803c:	445b      	add	r3, fp
 802803e:	9306      	str	r3, [sp, #24]
 8028040:	2300      	movs	r3, #0
 8028042:	9308      	str	r3, [sp, #32]
 8028044:	9b07      	ldr	r3, [sp, #28]
 8028046:	2b09      	cmp	r3, #9
 8028048:	d868      	bhi.n	802811c <_dtoa_r+0x28c>
 802804a:	2b05      	cmp	r3, #5
 802804c:	bfc4      	itt	gt
 802804e:	3b04      	subgt	r3, #4
 8028050:	9307      	strgt	r3, [sp, #28]
 8028052:	9b07      	ldr	r3, [sp, #28]
 8028054:	f1a3 0302 	sub.w	r3, r3, #2
 8028058:	bfcc      	ite	gt
 802805a:	2500      	movgt	r5, #0
 802805c:	2501      	movle	r5, #1
 802805e:	2b03      	cmp	r3, #3
 8028060:	d867      	bhi.n	8028132 <_dtoa_r+0x2a2>
 8028062:	e8df f003 	tbb	[pc, r3]
 8028066:	3b2e      	.short	0x3b2e
 8028068:	5939      	.short	0x5939
 802806a:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 802806e:	441d      	add	r5, r3
 8028070:	f205 4332 	addw	r3, r5, #1074	; 0x432
 8028074:	2b20      	cmp	r3, #32
 8028076:	bfc1      	itttt	gt
 8028078:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 802807c:	fa08 f803 	lslgt.w	r8, r8, r3
 8028080:	f205 4312 	addwgt	r3, r5, #1042	; 0x412
 8028084:	fa26 f303 	lsrgt.w	r3, r6, r3
 8028088:	bfd6      	itet	le
 802808a:	f1c3 0320 	rsble	r3, r3, #32
 802808e:	ea48 0003 	orrgt.w	r0, r8, r3
 8028092:	fa06 f003 	lslle.w	r0, r6, r3
 8028096:	f7d8 fa4d 	bl	8000534 <__aeabi_ui2d>
 802809a:	2201      	movs	r2, #1
 802809c:	f1a1 73f8 	sub.w	r3, r1, #32505856	; 0x1f00000
 80280a0:	3d01      	subs	r5, #1
 80280a2:	920e      	str	r2, [sp, #56]	; 0x38
 80280a4:	e770      	b.n	8027f88 <_dtoa_r+0xf8>
 80280a6:	2301      	movs	r3, #1
 80280a8:	e7b4      	b.n	8028014 <_dtoa_r+0x184>
 80280aa:	900c      	str	r0, [sp, #48]	; 0x30
 80280ac:	e7b3      	b.n	8028016 <_dtoa_r+0x186>
 80280ae:	9b05      	ldr	r3, [sp, #20]
 80280b0:	eba3 030b 	sub.w	r3, r3, fp
 80280b4:	9305      	str	r3, [sp, #20]
 80280b6:	f1cb 0300 	rsb	r3, fp, #0
 80280ba:	9308      	str	r3, [sp, #32]
 80280bc:	2300      	movs	r3, #0
 80280be:	930b      	str	r3, [sp, #44]	; 0x2c
 80280c0:	e7c0      	b.n	8028044 <_dtoa_r+0x1b4>
 80280c2:	2300      	movs	r3, #0
 80280c4:	9309      	str	r3, [sp, #36]	; 0x24
 80280c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80280c8:	2b00      	cmp	r3, #0
 80280ca:	dc35      	bgt.n	8028138 <_dtoa_r+0x2a8>
 80280cc:	2301      	movs	r3, #1
 80280ce:	9301      	str	r3, [sp, #4]
 80280d0:	9304      	str	r3, [sp, #16]
 80280d2:	461a      	mov	r2, r3
 80280d4:	920a      	str	r2, [sp, #40]	; 0x28
 80280d6:	e00b      	b.n	80280f0 <_dtoa_r+0x260>
 80280d8:	2301      	movs	r3, #1
 80280da:	e7f3      	b.n	80280c4 <_dtoa_r+0x234>
 80280dc:	2300      	movs	r3, #0
 80280de:	9309      	str	r3, [sp, #36]	; 0x24
 80280e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80280e2:	445b      	add	r3, fp
 80280e4:	9301      	str	r3, [sp, #4]
 80280e6:	3301      	adds	r3, #1
 80280e8:	2b01      	cmp	r3, #1
 80280ea:	9304      	str	r3, [sp, #16]
 80280ec:	bfb8      	it	lt
 80280ee:	2301      	movlt	r3, #1
 80280f0:	2100      	movs	r1, #0
 80280f2:	2204      	movs	r2, #4
 80280f4:	f102 0014 	add.w	r0, r2, #20
 80280f8:	4298      	cmp	r0, r3
 80280fa:	d921      	bls.n	8028140 <_dtoa_r+0x2b0>
 80280fc:	63e1      	str	r1, [r4, #60]	; 0x3c
 80280fe:	4620      	mov	r0, r4
 8028100:	f000 fcae 	bl	8028a60 <_Balloc>
 8028104:	9000      	str	r0, [sp, #0]
 8028106:	2800      	cmp	r0, #0
 8028108:	d13a      	bne.n	8028180 <_dtoa_r+0x2f0>
 802810a:	4b1b      	ldr	r3, [pc, #108]	; (8028178 <_dtoa_r+0x2e8>)
 802810c:	4602      	mov	r2, r0
 802810e:	f240 11af 	movw	r1, #431	; 0x1af
 8028112:	481a      	ldr	r0, [pc, #104]	; (802817c <_dtoa_r+0x2ec>)
 8028114:	f001 fa1e 	bl	8029554 <__assert_func>
 8028118:	2301      	movs	r3, #1
 802811a:	e7e0      	b.n	80280de <_dtoa_r+0x24e>
 802811c:	2501      	movs	r5, #1
 802811e:	2300      	movs	r3, #0
 8028120:	9307      	str	r3, [sp, #28]
 8028122:	9509      	str	r5, [sp, #36]	; 0x24
 8028124:	f04f 33ff 	mov.w	r3, #4294967295
 8028128:	9301      	str	r3, [sp, #4]
 802812a:	9304      	str	r3, [sp, #16]
 802812c:	2200      	movs	r2, #0
 802812e:	2312      	movs	r3, #18
 8028130:	e7d0      	b.n	80280d4 <_dtoa_r+0x244>
 8028132:	2301      	movs	r3, #1
 8028134:	9309      	str	r3, [sp, #36]	; 0x24
 8028136:	e7f5      	b.n	8028124 <_dtoa_r+0x294>
 8028138:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802813a:	9301      	str	r3, [sp, #4]
 802813c:	9304      	str	r3, [sp, #16]
 802813e:	e7d7      	b.n	80280f0 <_dtoa_r+0x260>
 8028140:	3101      	adds	r1, #1
 8028142:	0052      	lsls	r2, r2, #1
 8028144:	e7d6      	b.n	80280f4 <_dtoa_r+0x264>
 8028146:	bf00      	nop
 8028148:	636f4361 	.word	0x636f4361
 802814c:	3fd287a7 	.word	0x3fd287a7
 8028150:	8b60c8b3 	.word	0x8b60c8b3
 8028154:	3fc68a28 	.word	0x3fc68a28
 8028158:	509f79fb 	.word	0x509f79fb
 802815c:	3fd34413 	.word	0x3fd34413
 8028160:	7ff00000 	.word	0x7ff00000
 8028164:	08036584 	.word	0x08036584
 8028168:	0803657b 	.word	0x0803657b
 802816c:	08036550 	.word	0x08036550
 8028170:	3ff80000 	.word	0x3ff80000
 8028174:	08036678 	.word	0x08036678
 8028178:	08036588 	.word	0x08036588
 802817c:	08036599 	.word	0x08036599
 8028180:	9b00      	ldr	r3, [sp, #0]
 8028182:	63a3      	str	r3, [r4, #56]	; 0x38
 8028184:	9b04      	ldr	r3, [sp, #16]
 8028186:	2b0e      	cmp	r3, #14
 8028188:	f200 80a8 	bhi.w	80282dc <_dtoa_r+0x44c>
 802818c:	2d00      	cmp	r5, #0
 802818e:	f000 80a5 	beq.w	80282dc <_dtoa_r+0x44c>
 8028192:	f1bb 0f00 	cmp.w	fp, #0
 8028196:	dd38      	ble.n	802820a <_dtoa_r+0x37a>
 8028198:	4bbf      	ldr	r3, [pc, #764]	; (8028498 <_dtoa_r+0x608>)
 802819a:	f00b 020f 	and.w	r2, fp, #15
 802819e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80281a2:	f41b 7f80 	tst.w	fp, #256	; 0x100
 80281a6:	e9d3 6700 	ldrd	r6, r7, [r3]
 80281aa:	ea4f 182b 	mov.w	r8, fp, asr #4
 80281ae:	d019      	beq.n	80281e4 <_dtoa_r+0x354>
 80281b0:	4bba      	ldr	r3, [pc, #744]	; (802849c <_dtoa_r+0x60c>)
 80281b2:	ec51 0b18 	vmov	r0, r1, d8
 80281b6:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80281ba:	f7d8 fb5f 	bl	800087c <__aeabi_ddiv>
 80281be:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80281c2:	f008 080f 	and.w	r8, r8, #15
 80281c6:	2503      	movs	r5, #3
 80281c8:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 802849c <_dtoa_r+0x60c>
 80281cc:	f1b8 0f00 	cmp.w	r8, #0
 80281d0:	d10a      	bne.n	80281e8 <_dtoa_r+0x358>
 80281d2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80281d6:	4632      	mov	r2, r6
 80281d8:	463b      	mov	r3, r7
 80281da:	f7d8 fb4f 	bl	800087c <__aeabi_ddiv>
 80281de:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80281e2:	e02b      	b.n	802823c <_dtoa_r+0x3ac>
 80281e4:	2502      	movs	r5, #2
 80281e6:	e7ef      	b.n	80281c8 <_dtoa_r+0x338>
 80281e8:	f018 0f01 	tst.w	r8, #1
 80281ec:	d008      	beq.n	8028200 <_dtoa_r+0x370>
 80281ee:	4630      	mov	r0, r6
 80281f0:	4639      	mov	r1, r7
 80281f2:	e9d9 2300 	ldrd	r2, r3, [r9]
 80281f6:	f7d8 fa17 	bl	8000628 <__aeabi_dmul>
 80281fa:	3501      	adds	r5, #1
 80281fc:	4606      	mov	r6, r0
 80281fe:	460f      	mov	r7, r1
 8028200:	ea4f 0868 	mov.w	r8, r8, asr #1
 8028204:	f109 0908 	add.w	r9, r9, #8
 8028208:	e7e0      	b.n	80281cc <_dtoa_r+0x33c>
 802820a:	f000 809f 	beq.w	802834c <_dtoa_r+0x4bc>
 802820e:	f1cb 0600 	rsb	r6, fp, #0
 8028212:	4ba1      	ldr	r3, [pc, #644]	; (8028498 <_dtoa_r+0x608>)
 8028214:	4fa1      	ldr	r7, [pc, #644]	; (802849c <_dtoa_r+0x60c>)
 8028216:	f006 020f 	and.w	r2, r6, #15
 802821a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802821e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028222:	ec51 0b18 	vmov	r0, r1, d8
 8028226:	f7d8 f9ff 	bl	8000628 <__aeabi_dmul>
 802822a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802822e:	1136      	asrs	r6, r6, #4
 8028230:	2300      	movs	r3, #0
 8028232:	2502      	movs	r5, #2
 8028234:	2e00      	cmp	r6, #0
 8028236:	d17e      	bne.n	8028336 <_dtoa_r+0x4a6>
 8028238:	2b00      	cmp	r3, #0
 802823a:	d1d0      	bne.n	80281de <_dtoa_r+0x34e>
 802823c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802823e:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8028242:	2b00      	cmp	r3, #0
 8028244:	f000 8084 	beq.w	8028350 <_dtoa_r+0x4c0>
 8028248:	4b95      	ldr	r3, [pc, #596]	; (80284a0 <_dtoa_r+0x610>)
 802824a:	2200      	movs	r2, #0
 802824c:	4640      	mov	r0, r8
 802824e:	4649      	mov	r1, r9
 8028250:	f7d8 fc5c 	bl	8000b0c <__aeabi_dcmplt>
 8028254:	2800      	cmp	r0, #0
 8028256:	d07b      	beq.n	8028350 <_dtoa_r+0x4c0>
 8028258:	9b04      	ldr	r3, [sp, #16]
 802825a:	2b00      	cmp	r3, #0
 802825c:	d078      	beq.n	8028350 <_dtoa_r+0x4c0>
 802825e:	9b01      	ldr	r3, [sp, #4]
 8028260:	2b00      	cmp	r3, #0
 8028262:	dd39      	ble.n	80282d8 <_dtoa_r+0x448>
 8028264:	4b8f      	ldr	r3, [pc, #572]	; (80284a4 <_dtoa_r+0x614>)
 8028266:	2200      	movs	r2, #0
 8028268:	4640      	mov	r0, r8
 802826a:	4649      	mov	r1, r9
 802826c:	f7d8 f9dc 	bl	8000628 <__aeabi_dmul>
 8028270:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8028274:	9e01      	ldr	r6, [sp, #4]
 8028276:	f10b 37ff 	add.w	r7, fp, #4294967295
 802827a:	3501      	adds	r5, #1
 802827c:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8028280:	4628      	mov	r0, r5
 8028282:	f7d8 f967 	bl	8000554 <__aeabi_i2d>
 8028286:	4642      	mov	r2, r8
 8028288:	464b      	mov	r3, r9
 802828a:	f7d8 f9cd 	bl	8000628 <__aeabi_dmul>
 802828e:	4b86      	ldr	r3, [pc, #536]	; (80284a8 <_dtoa_r+0x618>)
 8028290:	2200      	movs	r2, #0
 8028292:	f7d8 f813 	bl	80002bc <__adddf3>
 8028296:	f1a1 7350 	sub.w	r3, r1, #54525952	; 0x3400000
 802829a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802829e:	9303      	str	r3, [sp, #12]
 80282a0:	2e00      	cmp	r6, #0
 80282a2:	d158      	bne.n	8028356 <_dtoa_r+0x4c6>
 80282a4:	4b81      	ldr	r3, [pc, #516]	; (80284ac <_dtoa_r+0x61c>)
 80282a6:	2200      	movs	r2, #0
 80282a8:	4640      	mov	r0, r8
 80282aa:	4649      	mov	r1, r9
 80282ac:	f7d8 f804 	bl	80002b8 <__aeabi_dsub>
 80282b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80282b4:	4680      	mov	r8, r0
 80282b6:	4689      	mov	r9, r1
 80282b8:	f7d8 fc46 	bl	8000b48 <__aeabi_dcmpgt>
 80282bc:	2800      	cmp	r0, #0
 80282be:	f040 8295 	bne.w	80287ec <_dtoa_r+0x95c>
 80282c2:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 80282c6:	4640      	mov	r0, r8
 80282c8:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80282cc:	4649      	mov	r1, r9
 80282ce:	f7d8 fc1d 	bl	8000b0c <__aeabi_dcmplt>
 80282d2:	2800      	cmp	r0, #0
 80282d4:	f040 8288 	bne.w	80287e8 <_dtoa_r+0x958>
 80282d8:	ed8d 8b02 	vstr	d8, [sp, #8]
 80282dc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80282de:	2b00      	cmp	r3, #0
 80282e0:	f2c0 814d 	blt.w	802857e <_dtoa_r+0x6ee>
 80282e4:	f1bb 0f0e 	cmp.w	fp, #14
 80282e8:	f300 8149 	bgt.w	802857e <_dtoa_r+0x6ee>
 80282ec:	4b6a      	ldr	r3, [pc, #424]	; (8028498 <_dtoa_r+0x608>)
 80282ee:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 80282f2:	e9d3 8900 	ldrd	r8, r9, [r3]
 80282f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80282f8:	2b00      	cmp	r3, #0
 80282fa:	f280 80db 	bge.w	80284b4 <_dtoa_r+0x624>
 80282fe:	9b04      	ldr	r3, [sp, #16]
 8028300:	2b00      	cmp	r3, #0
 8028302:	f300 80d7 	bgt.w	80284b4 <_dtoa_r+0x624>
 8028306:	f040 826e 	bne.w	80287e6 <_dtoa_r+0x956>
 802830a:	4b68      	ldr	r3, [pc, #416]	; (80284ac <_dtoa_r+0x61c>)
 802830c:	2200      	movs	r2, #0
 802830e:	4640      	mov	r0, r8
 8028310:	4649      	mov	r1, r9
 8028312:	f7d8 f989 	bl	8000628 <__aeabi_dmul>
 8028316:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802831a:	f7d8 fc0b 	bl	8000b34 <__aeabi_dcmpge>
 802831e:	9e04      	ldr	r6, [sp, #16]
 8028320:	4637      	mov	r7, r6
 8028322:	2800      	cmp	r0, #0
 8028324:	f040 8244 	bne.w	80287b0 <_dtoa_r+0x920>
 8028328:	9d00      	ldr	r5, [sp, #0]
 802832a:	2331      	movs	r3, #49	; 0x31
 802832c:	f805 3b01 	strb.w	r3, [r5], #1
 8028330:	f10b 0b01 	add.w	fp, fp, #1
 8028334:	e240      	b.n	80287b8 <_dtoa_r+0x928>
 8028336:	07f2      	lsls	r2, r6, #31
 8028338:	d505      	bpl.n	8028346 <_dtoa_r+0x4b6>
 802833a:	e9d7 2300 	ldrd	r2, r3, [r7]
 802833e:	f7d8 f973 	bl	8000628 <__aeabi_dmul>
 8028342:	3501      	adds	r5, #1
 8028344:	2301      	movs	r3, #1
 8028346:	1076      	asrs	r6, r6, #1
 8028348:	3708      	adds	r7, #8
 802834a:	e773      	b.n	8028234 <_dtoa_r+0x3a4>
 802834c:	2502      	movs	r5, #2
 802834e:	e775      	b.n	802823c <_dtoa_r+0x3ac>
 8028350:	9e04      	ldr	r6, [sp, #16]
 8028352:	465f      	mov	r7, fp
 8028354:	e792      	b.n	802827c <_dtoa_r+0x3ec>
 8028356:	9900      	ldr	r1, [sp, #0]
 8028358:	4b4f      	ldr	r3, [pc, #316]	; (8028498 <_dtoa_r+0x608>)
 802835a:	ed9d 7b02 	vldr	d7, [sp, #8]
 802835e:	4431      	add	r1, r6
 8028360:	9102      	str	r1, [sp, #8]
 8028362:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028364:	eeb0 9a47 	vmov.f32	s18, s14
 8028368:	eef0 9a67 	vmov.f32	s19, s15
 802836c:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8028370:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8028374:	2900      	cmp	r1, #0
 8028376:	d044      	beq.n	8028402 <_dtoa_r+0x572>
 8028378:	494d      	ldr	r1, [pc, #308]	; (80284b0 <_dtoa_r+0x620>)
 802837a:	2000      	movs	r0, #0
 802837c:	f7d8 fa7e 	bl	800087c <__aeabi_ddiv>
 8028380:	ec53 2b19 	vmov	r2, r3, d9
 8028384:	f7d7 ff98 	bl	80002b8 <__aeabi_dsub>
 8028388:	9d00      	ldr	r5, [sp, #0]
 802838a:	ec41 0b19 	vmov	d9, r0, r1
 802838e:	4649      	mov	r1, r9
 8028390:	4640      	mov	r0, r8
 8028392:	f7d8 fbf9 	bl	8000b88 <__aeabi_d2iz>
 8028396:	4606      	mov	r6, r0
 8028398:	f7d8 f8dc 	bl	8000554 <__aeabi_i2d>
 802839c:	4602      	mov	r2, r0
 802839e:	460b      	mov	r3, r1
 80283a0:	4640      	mov	r0, r8
 80283a2:	4649      	mov	r1, r9
 80283a4:	f7d7 ff88 	bl	80002b8 <__aeabi_dsub>
 80283a8:	3630      	adds	r6, #48	; 0x30
 80283aa:	f805 6b01 	strb.w	r6, [r5], #1
 80283ae:	ec53 2b19 	vmov	r2, r3, d9
 80283b2:	4680      	mov	r8, r0
 80283b4:	4689      	mov	r9, r1
 80283b6:	f7d8 fba9 	bl	8000b0c <__aeabi_dcmplt>
 80283ba:	2800      	cmp	r0, #0
 80283bc:	d164      	bne.n	8028488 <_dtoa_r+0x5f8>
 80283be:	4642      	mov	r2, r8
 80283c0:	464b      	mov	r3, r9
 80283c2:	4937      	ldr	r1, [pc, #220]	; (80284a0 <_dtoa_r+0x610>)
 80283c4:	2000      	movs	r0, #0
 80283c6:	f7d7 ff77 	bl	80002b8 <__aeabi_dsub>
 80283ca:	ec53 2b19 	vmov	r2, r3, d9
 80283ce:	f7d8 fb9d 	bl	8000b0c <__aeabi_dcmplt>
 80283d2:	2800      	cmp	r0, #0
 80283d4:	f040 80b5 	bne.w	8028542 <_dtoa_r+0x6b2>
 80283d8:	9b02      	ldr	r3, [sp, #8]
 80283da:	429d      	cmp	r5, r3
 80283dc:	f43f af7c 	beq.w	80282d8 <_dtoa_r+0x448>
 80283e0:	4b30      	ldr	r3, [pc, #192]	; (80284a4 <_dtoa_r+0x614>)
 80283e2:	ec51 0b19 	vmov	r0, r1, d9
 80283e6:	2200      	movs	r2, #0
 80283e8:	f7d8 f91e 	bl	8000628 <__aeabi_dmul>
 80283ec:	4b2d      	ldr	r3, [pc, #180]	; (80284a4 <_dtoa_r+0x614>)
 80283ee:	ec41 0b19 	vmov	d9, r0, r1
 80283f2:	2200      	movs	r2, #0
 80283f4:	4640      	mov	r0, r8
 80283f6:	4649      	mov	r1, r9
 80283f8:	f7d8 f916 	bl	8000628 <__aeabi_dmul>
 80283fc:	4680      	mov	r8, r0
 80283fe:	4689      	mov	r9, r1
 8028400:	e7c5      	b.n	802838e <_dtoa_r+0x4fe>
 8028402:	ec51 0b17 	vmov	r0, r1, d7
 8028406:	f7d8 f90f 	bl	8000628 <__aeabi_dmul>
 802840a:	9b02      	ldr	r3, [sp, #8]
 802840c:	9d00      	ldr	r5, [sp, #0]
 802840e:	930f      	str	r3, [sp, #60]	; 0x3c
 8028410:	ec41 0b19 	vmov	d9, r0, r1
 8028414:	4649      	mov	r1, r9
 8028416:	4640      	mov	r0, r8
 8028418:	f7d8 fbb6 	bl	8000b88 <__aeabi_d2iz>
 802841c:	4606      	mov	r6, r0
 802841e:	f7d8 f899 	bl	8000554 <__aeabi_i2d>
 8028422:	3630      	adds	r6, #48	; 0x30
 8028424:	4602      	mov	r2, r0
 8028426:	460b      	mov	r3, r1
 8028428:	4640      	mov	r0, r8
 802842a:	4649      	mov	r1, r9
 802842c:	f7d7 ff44 	bl	80002b8 <__aeabi_dsub>
 8028430:	f805 6b01 	strb.w	r6, [r5], #1
 8028434:	9b02      	ldr	r3, [sp, #8]
 8028436:	429d      	cmp	r5, r3
 8028438:	4680      	mov	r8, r0
 802843a:	4689      	mov	r9, r1
 802843c:	f04f 0200 	mov.w	r2, #0
 8028440:	d124      	bne.n	802848c <_dtoa_r+0x5fc>
 8028442:	4b1b      	ldr	r3, [pc, #108]	; (80284b0 <_dtoa_r+0x620>)
 8028444:	ec51 0b19 	vmov	r0, r1, d9
 8028448:	f7d7 ff38 	bl	80002bc <__adddf3>
 802844c:	4602      	mov	r2, r0
 802844e:	460b      	mov	r3, r1
 8028450:	4640      	mov	r0, r8
 8028452:	4649      	mov	r1, r9
 8028454:	f7d8 fb78 	bl	8000b48 <__aeabi_dcmpgt>
 8028458:	2800      	cmp	r0, #0
 802845a:	d172      	bne.n	8028542 <_dtoa_r+0x6b2>
 802845c:	ec53 2b19 	vmov	r2, r3, d9
 8028460:	4913      	ldr	r1, [pc, #76]	; (80284b0 <_dtoa_r+0x620>)
 8028462:	2000      	movs	r0, #0
 8028464:	f7d7 ff28 	bl	80002b8 <__aeabi_dsub>
 8028468:	4602      	mov	r2, r0
 802846a:	460b      	mov	r3, r1
 802846c:	4640      	mov	r0, r8
 802846e:	4649      	mov	r1, r9
 8028470:	f7d8 fb4c 	bl	8000b0c <__aeabi_dcmplt>
 8028474:	2800      	cmp	r0, #0
 8028476:	f43f af2f 	beq.w	80282d8 <_dtoa_r+0x448>
 802847a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 802847c:	1e6b      	subs	r3, r5, #1
 802847e:	930f      	str	r3, [sp, #60]	; 0x3c
 8028480:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8028484:	2b30      	cmp	r3, #48	; 0x30
 8028486:	d0f8      	beq.n	802847a <_dtoa_r+0x5ea>
 8028488:	46bb      	mov	fp, r7
 802848a:	e049      	b.n	8028520 <_dtoa_r+0x690>
 802848c:	4b05      	ldr	r3, [pc, #20]	; (80284a4 <_dtoa_r+0x614>)
 802848e:	f7d8 f8cb 	bl	8000628 <__aeabi_dmul>
 8028492:	4680      	mov	r8, r0
 8028494:	4689      	mov	r9, r1
 8028496:	e7bd      	b.n	8028414 <_dtoa_r+0x584>
 8028498:	08036678 	.word	0x08036678
 802849c:	08036650 	.word	0x08036650
 80284a0:	3ff00000 	.word	0x3ff00000
 80284a4:	40240000 	.word	0x40240000
 80284a8:	401c0000 	.word	0x401c0000
 80284ac:	40140000 	.word	0x40140000
 80284b0:	3fe00000 	.word	0x3fe00000
 80284b4:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80284b8:	9d00      	ldr	r5, [sp, #0]
 80284ba:	4642      	mov	r2, r8
 80284bc:	464b      	mov	r3, r9
 80284be:	4630      	mov	r0, r6
 80284c0:	4639      	mov	r1, r7
 80284c2:	f7d8 f9db 	bl	800087c <__aeabi_ddiv>
 80284c6:	f7d8 fb5f 	bl	8000b88 <__aeabi_d2iz>
 80284ca:	9001      	str	r0, [sp, #4]
 80284cc:	f7d8 f842 	bl	8000554 <__aeabi_i2d>
 80284d0:	4642      	mov	r2, r8
 80284d2:	464b      	mov	r3, r9
 80284d4:	f7d8 f8a8 	bl	8000628 <__aeabi_dmul>
 80284d8:	4602      	mov	r2, r0
 80284da:	460b      	mov	r3, r1
 80284dc:	4630      	mov	r0, r6
 80284de:	4639      	mov	r1, r7
 80284e0:	f7d7 feea 	bl	80002b8 <__aeabi_dsub>
 80284e4:	9e01      	ldr	r6, [sp, #4]
 80284e6:	9f04      	ldr	r7, [sp, #16]
 80284e8:	3630      	adds	r6, #48	; 0x30
 80284ea:	f805 6b01 	strb.w	r6, [r5], #1
 80284ee:	9e00      	ldr	r6, [sp, #0]
 80284f0:	1bae      	subs	r6, r5, r6
 80284f2:	42b7      	cmp	r7, r6
 80284f4:	4602      	mov	r2, r0
 80284f6:	460b      	mov	r3, r1
 80284f8:	d134      	bne.n	8028564 <_dtoa_r+0x6d4>
 80284fa:	f7d7 fedf 	bl	80002bc <__adddf3>
 80284fe:	4642      	mov	r2, r8
 8028500:	464b      	mov	r3, r9
 8028502:	4606      	mov	r6, r0
 8028504:	460f      	mov	r7, r1
 8028506:	f7d8 fb1f 	bl	8000b48 <__aeabi_dcmpgt>
 802850a:	b9c8      	cbnz	r0, 8028540 <_dtoa_r+0x6b0>
 802850c:	4642      	mov	r2, r8
 802850e:	464b      	mov	r3, r9
 8028510:	4630      	mov	r0, r6
 8028512:	4639      	mov	r1, r7
 8028514:	f7d8 faf0 	bl	8000af8 <__aeabi_dcmpeq>
 8028518:	b110      	cbz	r0, 8028520 <_dtoa_r+0x690>
 802851a:	9b01      	ldr	r3, [sp, #4]
 802851c:	07db      	lsls	r3, r3, #31
 802851e:	d40f      	bmi.n	8028540 <_dtoa_r+0x6b0>
 8028520:	4651      	mov	r1, sl
 8028522:	4620      	mov	r0, r4
 8028524:	f000 fac1 	bl	8028aaa <_Bfree>
 8028528:	2300      	movs	r3, #0
 802852a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802852c:	702b      	strb	r3, [r5, #0]
 802852e:	f10b 0301 	add.w	r3, fp, #1
 8028532:	6013      	str	r3, [r2, #0]
 8028534:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028536:	2b00      	cmp	r3, #0
 8028538:	f43f ace5 	beq.w	8027f06 <_dtoa_r+0x76>
 802853c:	601d      	str	r5, [r3, #0]
 802853e:	e4e2      	b.n	8027f06 <_dtoa_r+0x76>
 8028540:	465f      	mov	r7, fp
 8028542:	462b      	mov	r3, r5
 8028544:	461d      	mov	r5, r3
 8028546:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 802854a:	2a39      	cmp	r2, #57	; 0x39
 802854c:	d106      	bne.n	802855c <_dtoa_r+0x6cc>
 802854e:	9a00      	ldr	r2, [sp, #0]
 8028550:	429a      	cmp	r2, r3
 8028552:	d1f7      	bne.n	8028544 <_dtoa_r+0x6b4>
 8028554:	9900      	ldr	r1, [sp, #0]
 8028556:	2230      	movs	r2, #48	; 0x30
 8028558:	3701      	adds	r7, #1
 802855a:	700a      	strb	r2, [r1, #0]
 802855c:	781a      	ldrb	r2, [r3, #0]
 802855e:	3201      	adds	r2, #1
 8028560:	701a      	strb	r2, [r3, #0]
 8028562:	e791      	b.n	8028488 <_dtoa_r+0x5f8>
 8028564:	4ba3      	ldr	r3, [pc, #652]	; (80287f4 <_dtoa_r+0x964>)
 8028566:	2200      	movs	r2, #0
 8028568:	f7d8 f85e 	bl	8000628 <__aeabi_dmul>
 802856c:	2200      	movs	r2, #0
 802856e:	2300      	movs	r3, #0
 8028570:	4606      	mov	r6, r0
 8028572:	460f      	mov	r7, r1
 8028574:	f7d8 fac0 	bl	8000af8 <__aeabi_dcmpeq>
 8028578:	2800      	cmp	r0, #0
 802857a:	d09e      	beq.n	80284ba <_dtoa_r+0x62a>
 802857c:	e7d0      	b.n	8028520 <_dtoa_r+0x690>
 802857e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8028580:	2a00      	cmp	r2, #0
 8028582:	f000 80ca 	beq.w	802871a <_dtoa_r+0x88a>
 8028586:	9a07      	ldr	r2, [sp, #28]
 8028588:	2a01      	cmp	r2, #1
 802858a:	f300 80ad 	bgt.w	80286e8 <_dtoa_r+0x858>
 802858e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8028590:	2a00      	cmp	r2, #0
 8028592:	f000 80a5 	beq.w	80286e0 <_dtoa_r+0x850>
 8028596:	f203 4333 	addw	r3, r3, #1075	; 0x433
 802859a:	9e08      	ldr	r6, [sp, #32]
 802859c:	9d05      	ldr	r5, [sp, #20]
 802859e:	9a05      	ldr	r2, [sp, #20]
 80285a0:	441a      	add	r2, r3
 80285a2:	9205      	str	r2, [sp, #20]
 80285a4:	9a06      	ldr	r2, [sp, #24]
 80285a6:	2101      	movs	r1, #1
 80285a8:	441a      	add	r2, r3
 80285aa:	4620      	mov	r0, r4
 80285ac:	9206      	str	r2, [sp, #24]
 80285ae:	f000 fb19 	bl	8028be4 <__i2b>
 80285b2:	4607      	mov	r7, r0
 80285b4:	b165      	cbz	r5, 80285d0 <_dtoa_r+0x740>
 80285b6:	9b06      	ldr	r3, [sp, #24]
 80285b8:	2b00      	cmp	r3, #0
 80285ba:	dd09      	ble.n	80285d0 <_dtoa_r+0x740>
 80285bc:	42ab      	cmp	r3, r5
 80285be:	9a05      	ldr	r2, [sp, #20]
 80285c0:	bfa8      	it	ge
 80285c2:	462b      	movge	r3, r5
 80285c4:	1ad2      	subs	r2, r2, r3
 80285c6:	9205      	str	r2, [sp, #20]
 80285c8:	9a06      	ldr	r2, [sp, #24]
 80285ca:	1aed      	subs	r5, r5, r3
 80285cc:	1ad3      	subs	r3, r2, r3
 80285ce:	9306      	str	r3, [sp, #24]
 80285d0:	9b08      	ldr	r3, [sp, #32]
 80285d2:	b1f3      	cbz	r3, 8028612 <_dtoa_r+0x782>
 80285d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80285d6:	2b00      	cmp	r3, #0
 80285d8:	f000 80a3 	beq.w	8028722 <_dtoa_r+0x892>
 80285dc:	2e00      	cmp	r6, #0
 80285de:	dd10      	ble.n	8028602 <_dtoa_r+0x772>
 80285e0:	4639      	mov	r1, r7
 80285e2:	4632      	mov	r2, r6
 80285e4:	4620      	mov	r0, r4
 80285e6:	f000 fbbd 	bl	8028d64 <__pow5mult>
 80285ea:	4652      	mov	r2, sl
 80285ec:	4601      	mov	r1, r0
 80285ee:	4607      	mov	r7, r0
 80285f0:	4620      	mov	r0, r4
 80285f2:	f000 fb0d 	bl	8028c10 <__multiply>
 80285f6:	4651      	mov	r1, sl
 80285f8:	4680      	mov	r8, r0
 80285fa:	4620      	mov	r0, r4
 80285fc:	f000 fa55 	bl	8028aaa <_Bfree>
 8028600:	46c2      	mov	sl, r8
 8028602:	9b08      	ldr	r3, [sp, #32]
 8028604:	1b9a      	subs	r2, r3, r6
 8028606:	d004      	beq.n	8028612 <_dtoa_r+0x782>
 8028608:	4651      	mov	r1, sl
 802860a:	4620      	mov	r0, r4
 802860c:	f000 fbaa 	bl	8028d64 <__pow5mult>
 8028610:	4682      	mov	sl, r0
 8028612:	2101      	movs	r1, #1
 8028614:	4620      	mov	r0, r4
 8028616:	f000 fae5 	bl	8028be4 <__i2b>
 802861a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802861c:	2b00      	cmp	r3, #0
 802861e:	4606      	mov	r6, r0
 8028620:	f340 8081 	ble.w	8028726 <_dtoa_r+0x896>
 8028624:	461a      	mov	r2, r3
 8028626:	4601      	mov	r1, r0
 8028628:	4620      	mov	r0, r4
 802862a:	f000 fb9b 	bl	8028d64 <__pow5mult>
 802862e:	9b07      	ldr	r3, [sp, #28]
 8028630:	2b01      	cmp	r3, #1
 8028632:	4606      	mov	r6, r0
 8028634:	dd7a      	ble.n	802872c <_dtoa_r+0x89c>
 8028636:	f04f 0800 	mov.w	r8, #0
 802863a:	6933      	ldr	r3, [r6, #16]
 802863c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8028640:	6918      	ldr	r0, [r3, #16]
 8028642:	f000 fa81 	bl	8028b48 <__hi0bits>
 8028646:	f1c0 0020 	rsb	r0, r0, #32
 802864a:	9b06      	ldr	r3, [sp, #24]
 802864c:	4418      	add	r0, r3
 802864e:	f010 001f 	ands.w	r0, r0, #31
 8028652:	f000 8094 	beq.w	802877e <_dtoa_r+0x8ee>
 8028656:	f1c0 0320 	rsb	r3, r0, #32
 802865a:	2b04      	cmp	r3, #4
 802865c:	f340 8085 	ble.w	802876a <_dtoa_r+0x8da>
 8028660:	9b05      	ldr	r3, [sp, #20]
 8028662:	f1c0 001c 	rsb	r0, r0, #28
 8028666:	4403      	add	r3, r0
 8028668:	9305      	str	r3, [sp, #20]
 802866a:	9b06      	ldr	r3, [sp, #24]
 802866c:	4403      	add	r3, r0
 802866e:	4405      	add	r5, r0
 8028670:	9306      	str	r3, [sp, #24]
 8028672:	9b05      	ldr	r3, [sp, #20]
 8028674:	2b00      	cmp	r3, #0
 8028676:	dd05      	ble.n	8028684 <_dtoa_r+0x7f4>
 8028678:	4651      	mov	r1, sl
 802867a:	461a      	mov	r2, r3
 802867c:	4620      	mov	r0, r4
 802867e:	f000 fbb1 	bl	8028de4 <__lshift>
 8028682:	4682      	mov	sl, r0
 8028684:	9b06      	ldr	r3, [sp, #24]
 8028686:	2b00      	cmp	r3, #0
 8028688:	dd05      	ble.n	8028696 <_dtoa_r+0x806>
 802868a:	4631      	mov	r1, r6
 802868c:	461a      	mov	r2, r3
 802868e:	4620      	mov	r0, r4
 8028690:	f000 fba8 	bl	8028de4 <__lshift>
 8028694:	4606      	mov	r6, r0
 8028696:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028698:	2b00      	cmp	r3, #0
 802869a:	d072      	beq.n	8028782 <_dtoa_r+0x8f2>
 802869c:	4631      	mov	r1, r6
 802869e:	4650      	mov	r0, sl
 80286a0:	f000 fc0c 	bl	8028ebc <__mcmp>
 80286a4:	2800      	cmp	r0, #0
 80286a6:	da6c      	bge.n	8028782 <_dtoa_r+0x8f2>
 80286a8:	2300      	movs	r3, #0
 80286aa:	4651      	mov	r1, sl
 80286ac:	220a      	movs	r2, #10
 80286ae:	4620      	mov	r0, r4
 80286b0:	f000 fa04 	bl	8028abc <__multadd>
 80286b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80286b6:	f10b 3bff 	add.w	fp, fp, #4294967295
 80286ba:	4682      	mov	sl, r0
 80286bc:	2b00      	cmp	r3, #0
 80286be:	f000 81af 	beq.w	8028a20 <_dtoa_r+0xb90>
 80286c2:	2300      	movs	r3, #0
 80286c4:	4639      	mov	r1, r7
 80286c6:	220a      	movs	r2, #10
 80286c8:	4620      	mov	r0, r4
 80286ca:	f000 f9f7 	bl	8028abc <__multadd>
 80286ce:	9b01      	ldr	r3, [sp, #4]
 80286d0:	2b00      	cmp	r3, #0
 80286d2:	4607      	mov	r7, r0
 80286d4:	f300 8096 	bgt.w	8028804 <_dtoa_r+0x974>
 80286d8:	9b07      	ldr	r3, [sp, #28]
 80286da:	2b02      	cmp	r3, #2
 80286dc:	dc59      	bgt.n	8028792 <_dtoa_r+0x902>
 80286de:	e091      	b.n	8028804 <_dtoa_r+0x974>
 80286e0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80286e2:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80286e6:	e758      	b.n	802859a <_dtoa_r+0x70a>
 80286e8:	9b04      	ldr	r3, [sp, #16]
 80286ea:	1e5e      	subs	r6, r3, #1
 80286ec:	9b08      	ldr	r3, [sp, #32]
 80286ee:	42b3      	cmp	r3, r6
 80286f0:	bfbf      	itttt	lt
 80286f2:	9b08      	ldrlt	r3, [sp, #32]
 80286f4:	9a0b      	ldrlt	r2, [sp, #44]	; 0x2c
 80286f6:	9608      	strlt	r6, [sp, #32]
 80286f8:	1af3      	sublt	r3, r6, r3
 80286fa:	bfb4      	ite	lt
 80286fc:	18d2      	addlt	r2, r2, r3
 80286fe:	1b9e      	subge	r6, r3, r6
 8028700:	9b04      	ldr	r3, [sp, #16]
 8028702:	bfbc      	itt	lt
 8028704:	920b      	strlt	r2, [sp, #44]	; 0x2c
 8028706:	2600      	movlt	r6, #0
 8028708:	2b00      	cmp	r3, #0
 802870a:	bfb7      	itett	lt
 802870c:	e9dd 2304 	ldrdlt	r2, r3, [sp, #16]
 8028710:	e9dd 3504 	ldrdge	r3, r5, [sp, #16]
 8028714:	1a9d      	sublt	r5, r3, r2
 8028716:	2300      	movlt	r3, #0
 8028718:	e741      	b.n	802859e <_dtoa_r+0x70e>
 802871a:	9e08      	ldr	r6, [sp, #32]
 802871c:	9d05      	ldr	r5, [sp, #20]
 802871e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8028720:	e748      	b.n	80285b4 <_dtoa_r+0x724>
 8028722:	9a08      	ldr	r2, [sp, #32]
 8028724:	e770      	b.n	8028608 <_dtoa_r+0x778>
 8028726:	9b07      	ldr	r3, [sp, #28]
 8028728:	2b01      	cmp	r3, #1
 802872a:	dc19      	bgt.n	8028760 <_dtoa_r+0x8d0>
 802872c:	9b02      	ldr	r3, [sp, #8]
 802872e:	b9bb      	cbnz	r3, 8028760 <_dtoa_r+0x8d0>
 8028730:	9b03      	ldr	r3, [sp, #12]
 8028732:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8028736:	b99b      	cbnz	r3, 8028760 <_dtoa_r+0x8d0>
 8028738:	9b03      	ldr	r3, [sp, #12]
 802873a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802873e:	0d1b      	lsrs	r3, r3, #20
 8028740:	051b      	lsls	r3, r3, #20
 8028742:	b183      	cbz	r3, 8028766 <_dtoa_r+0x8d6>
 8028744:	9b05      	ldr	r3, [sp, #20]
 8028746:	3301      	adds	r3, #1
 8028748:	9305      	str	r3, [sp, #20]
 802874a:	9b06      	ldr	r3, [sp, #24]
 802874c:	3301      	adds	r3, #1
 802874e:	9306      	str	r3, [sp, #24]
 8028750:	f04f 0801 	mov.w	r8, #1
 8028754:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8028756:	2b00      	cmp	r3, #0
 8028758:	f47f af6f 	bne.w	802863a <_dtoa_r+0x7aa>
 802875c:	2001      	movs	r0, #1
 802875e:	e774      	b.n	802864a <_dtoa_r+0x7ba>
 8028760:	f04f 0800 	mov.w	r8, #0
 8028764:	e7f6      	b.n	8028754 <_dtoa_r+0x8c4>
 8028766:	4698      	mov	r8, r3
 8028768:	e7f4      	b.n	8028754 <_dtoa_r+0x8c4>
 802876a:	d082      	beq.n	8028672 <_dtoa_r+0x7e2>
 802876c:	9a05      	ldr	r2, [sp, #20]
 802876e:	331c      	adds	r3, #28
 8028770:	441a      	add	r2, r3
 8028772:	9205      	str	r2, [sp, #20]
 8028774:	9a06      	ldr	r2, [sp, #24]
 8028776:	441a      	add	r2, r3
 8028778:	441d      	add	r5, r3
 802877a:	9206      	str	r2, [sp, #24]
 802877c:	e779      	b.n	8028672 <_dtoa_r+0x7e2>
 802877e:	4603      	mov	r3, r0
 8028780:	e7f4      	b.n	802876c <_dtoa_r+0x8dc>
 8028782:	9b04      	ldr	r3, [sp, #16]
 8028784:	2b00      	cmp	r3, #0
 8028786:	dc37      	bgt.n	80287f8 <_dtoa_r+0x968>
 8028788:	9b07      	ldr	r3, [sp, #28]
 802878a:	2b02      	cmp	r3, #2
 802878c:	dd34      	ble.n	80287f8 <_dtoa_r+0x968>
 802878e:	9b04      	ldr	r3, [sp, #16]
 8028790:	9301      	str	r3, [sp, #4]
 8028792:	9b01      	ldr	r3, [sp, #4]
 8028794:	b963      	cbnz	r3, 80287b0 <_dtoa_r+0x920>
 8028796:	4631      	mov	r1, r6
 8028798:	2205      	movs	r2, #5
 802879a:	4620      	mov	r0, r4
 802879c:	f000 f98e 	bl	8028abc <__multadd>
 80287a0:	4601      	mov	r1, r0
 80287a2:	4606      	mov	r6, r0
 80287a4:	4650      	mov	r0, sl
 80287a6:	f000 fb89 	bl	8028ebc <__mcmp>
 80287aa:	2800      	cmp	r0, #0
 80287ac:	f73f adbc 	bgt.w	8028328 <_dtoa_r+0x498>
 80287b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80287b2:	9d00      	ldr	r5, [sp, #0]
 80287b4:	ea6f 0b03 	mvn.w	fp, r3
 80287b8:	f04f 0800 	mov.w	r8, #0
 80287bc:	4631      	mov	r1, r6
 80287be:	4620      	mov	r0, r4
 80287c0:	f000 f973 	bl	8028aaa <_Bfree>
 80287c4:	2f00      	cmp	r7, #0
 80287c6:	f43f aeab 	beq.w	8028520 <_dtoa_r+0x690>
 80287ca:	f1b8 0f00 	cmp.w	r8, #0
 80287ce:	d005      	beq.n	80287dc <_dtoa_r+0x94c>
 80287d0:	45b8      	cmp	r8, r7
 80287d2:	d003      	beq.n	80287dc <_dtoa_r+0x94c>
 80287d4:	4641      	mov	r1, r8
 80287d6:	4620      	mov	r0, r4
 80287d8:	f000 f967 	bl	8028aaa <_Bfree>
 80287dc:	4639      	mov	r1, r7
 80287de:	4620      	mov	r0, r4
 80287e0:	f000 f963 	bl	8028aaa <_Bfree>
 80287e4:	e69c      	b.n	8028520 <_dtoa_r+0x690>
 80287e6:	2600      	movs	r6, #0
 80287e8:	4637      	mov	r7, r6
 80287ea:	e7e1      	b.n	80287b0 <_dtoa_r+0x920>
 80287ec:	46bb      	mov	fp, r7
 80287ee:	4637      	mov	r7, r6
 80287f0:	e59a      	b.n	8028328 <_dtoa_r+0x498>
 80287f2:	bf00      	nop
 80287f4:	40240000 	.word	0x40240000
 80287f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80287fa:	2b00      	cmp	r3, #0
 80287fc:	f000 80c7 	beq.w	802898e <_dtoa_r+0xafe>
 8028800:	9b04      	ldr	r3, [sp, #16]
 8028802:	9301      	str	r3, [sp, #4]
 8028804:	2d00      	cmp	r5, #0
 8028806:	dd05      	ble.n	8028814 <_dtoa_r+0x984>
 8028808:	4639      	mov	r1, r7
 802880a:	462a      	mov	r2, r5
 802880c:	4620      	mov	r0, r4
 802880e:	f000 fae9 	bl	8028de4 <__lshift>
 8028812:	4607      	mov	r7, r0
 8028814:	f1b8 0f00 	cmp.w	r8, #0
 8028818:	d05a      	beq.n	80288d0 <_dtoa_r+0xa40>
 802881a:	6879      	ldr	r1, [r7, #4]
 802881c:	4620      	mov	r0, r4
 802881e:	f000 f91f 	bl	8028a60 <_Balloc>
 8028822:	4605      	mov	r5, r0
 8028824:	b920      	cbnz	r0, 8028830 <_dtoa_r+0x9a0>
 8028826:	4b82      	ldr	r3, [pc, #520]	; (8028a30 <_dtoa_r+0xba0>)
 8028828:	4602      	mov	r2, r0
 802882a:	f240 21ef 	movw	r1, #751	; 0x2ef
 802882e:	e470      	b.n	8028112 <_dtoa_r+0x282>
 8028830:	693a      	ldr	r2, [r7, #16]
 8028832:	3202      	adds	r2, #2
 8028834:	0092      	lsls	r2, r2, #2
 8028836:	f107 010c 	add.w	r1, r7, #12
 802883a:	300c      	adds	r0, #12
 802883c:	f7fd fb68 	bl	8025f10 <memcpy>
 8028840:	2201      	movs	r2, #1
 8028842:	4629      	mov	r1, r5
 8028844:	4620      	mov	r0, r4
 8028846:	f000 facd 	bl	8028de4 <__lshift>
 802884a:	9b00      	ldr	r3, [sp, #0]
 802884c:	3301      	adds	r3, #1
 802884e:	9304      	str	r3, [sp, #16]
 8028850:	e9dd 2300 	ldrd	r2, r3, [sp]
 8028854:	4413      	add	r3, r2
 8028856:	9308      	str	r3, [sp, #32]
 8028858:	9b02      	ldr	r3, [sp, #8]
 802885a:	f003 0301 	and.w	r3, r3, #1
 802885e:	46b8      	mov	r8, r7
 8028860:	9306      	str	r3, [sp, #24]
 8028862:	4607      	mov	r7, r0
 8028864:	9b04      	ldr	r3, [sp, #16]
 8028866:	4631      	mov	r1, r6
 8028868:	3b01      	subs	r3, #1
 802886a:	4650      	mov	r0, sl
 802886c:	9301      	str	r3, [sp, #4]
 802886e:	f7ff fa85 	bl	8027d7c <quorem>
 8028872:	4641      	mov	r1, r8
 8028874:	9002      	str	r0, [sp, #8]
 8028876:	f100 0930 	add.w	r9, r0, #48	; 0x30
 802887a:	4650      	mov	r0, sl
 802887c:	f000 fb1e 	bl	8028ebc <__mcmp>
 8028880:	463a      	mov	r2, r7
 8028882:	9005      	str	r0, [sp, #20]
 8028884:	4631      	mov	r1, r6
 8028886:	4620      	mov	r0, r4
 8028888:	f000 fb34 	bl	8028ef4 <__mdiff>
 802888c:	68c2      	ldr	r2, [r0, #12]
 802888e:	4605      	mov	r5, r0
 8028890:	bb02      	cbnz	r2, 80288d4 <_dtoa_r+0xa44>
 8028892:	4601      	mov	r1, r0
 8028894:	4650      	mov	r0, sl
 8028896:	f000 fb11 	bl	8028ebc <__mcmp>
 802889a:	4602      	mov	r2, r0
 802889c:	4629      	mov	r1, r5
 802889e:	4620      	mov	r0, r4
 80288a0:	9209      	str	r2, [sp, #36]	; 0x24
 80288a2:	f000 f902 	bl	8028aaa <_Bfree>
 80288a6:	9b07      	ldr	r3, [sp, #28]
 80288a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80288aa:	9d04      	ldr	r5, [sp, #16]
 80288ac:	ea43 0102 	orr.w	r1, r3, r2
 80288b0:	9b06      	ldr	r3, [sp, #24]
 80288b2:	4319      	orrs	r1, r3
 80288b4:	d110      	bne.n	80288d8 <_dtoa_r+0xa48>
 80288b6:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 80288ba:	d029      	beq.n	8028910 <_dtoa_r+0xa80>
 80288bc:	9b05      	ldr	r3, [sp, #20]
 80288be:	2b00      	cmp	r3, #0
 80288c0:	dd02      	ble.n	80288c8 <_dtoa_r+0xa38>
 80288c2:	9b02      	ldr	r3, [sp, #8]
 80288c4:	f103 0931 	add.w	r9, r3, #49	; 0x31
 80288c8:	9b01      	ldr	r3, [sp, #4]
 80288ca:	f883 9000 	strb.w	r9, [r3]
 80288ce:	e775      	b.n	80287bc <_dtoa_r+0x92c>
 80288d0:	4638      	mov	r0, r7
 80288d2:	e7ba      	b.n	802884a <_dtoa_r+0x9ba>
 80288d4:	2201      	movs	r2, #1
 80288d6:	e7e1      	b.n	802889c <_dtoa_r+0xa0c>
 80288d8:	9b05      	ldr	r3, [sp, #20]
 80288da:	2b00      	cmp	r3, #0
 80288dc:	db04      	blt.n	80288e8 <_dtoa_r+0xa58>
 80288de:	9907      	ldr	r1, [sp, #28]
 80288e0:	430b      	orrs	r3, r1
 80288e2:	9906      	ldr	r1, [sp, #24]
 80288e4:	430b      	orrs	r3, r1
 80288e6:	d120      	bne.n	802892a <_dtoa_r+0xa9a>
 80288e8:	2a00      	cmp	r2, #0
 80288ea:	dded      	ble.n	80288c8 <_dtoa_r+0xa38>
 80288ec:	4651      	mov	r1, sl
 80288ee:	2201      	movs	r2, #1
 80288f0:	4620      	mov	r0, r4
 80288f2:	f000 fa77 	bl	8028de4 <__lshift>
 80288f6:	4631      	mov	r1, r6
 80288f8:	4682      	mov	sl, r0
 80288fa:	f000 fadf 	bl	8028ebc <__mcmp>
 80288fe:	2800      	cmp	r0, #0
 8028900:	dc03      	bgt.n	802890a <_dtoa_r+0xa7a>
 8028902:	d1e1      	bne.n	80288c8 <_dtoa_r+0xa38>
 8028904:	f019 0f01 	tst.w	r9, #1
 8028908:	d0de      	beq.n	80288c8 <_dtoa_r+0xa38>
 802890a:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 802890e:	d1d8      	bne.n	80288c2 <_dtoa_r+0xa32>
 8028910:	9a01      	ldr	r2, [sp, #4]
 8028912:	2339      	movs	r3, #57	; 0x39
 8028914:	7013      	strb	r3, [r2, #0]
 8028916:	462b      	mov	r3, r5
 8028918:	461d      	mov	r5, r3
 802891a:	3b01      	subs	r3, #1
 802891c:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8028920:	2a39      	cmp	r2, #57	; 0x39
 8028922:	d06c      	beq.n	80289fe <_dtoa_r+0xb6e>
 8028924:	3201      	adds	r2, #1
 8028926:	701a      	strb	r2, [r3, #0]
 8028928:	e748      	b.n	80287bc <_dtoa_r+0x92c>
 802892a:	2a00      	cmp	r2, #0
 802892c:	dd07      	ble.n	802893e <_dtoa_r+0xaae>
 802892e:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 8028932:	d0ed      	beq.n	8028910 <_dtoa_r+0xa80>
 8028934:	9a01      	ldr	r2, [sp, #4]
 8028936:	f109 0301 	add.w	r3, r9, #1
 802893a:	7013      	strb	r3, [r2, #0]
 802893c:	e73e      	b.n	80287bc <_dtoa_r+0x92c>
 802893e:	9b04      	ldr	r3, [sp, #16]
 8028940:	9a08      	ldr	r2, [sp, #32]
 8028942:	f803 9c01 	strb.w	r9, [r3, #-1]
 8028946:	4293      	cmp	r3, r2
 8028948:	d043      	beq.n	80289d2 <_dtoa_r+0xb42>
 802894a:	4651      	mov	r1, sl
 802894c:	2300      	movs	r3, #0
 802894e:	220a      	movs	r2, #10
 8028950:	4620      	mov	r0, r4
 8028952:	f000 f8b3 	bl	8028abc <__multadd>
 8028956:	45b8      	cmp	r8, r7
 8028958:	4682      	mov	sl, r0
 802895a:	f04f 0300 	mov.w	r3, #0
 802895e:	f04f 020a 	mov.w	r2, #10
 8028962:	4641      	mov	r1, r8
 8028964:	4620      	mov	r0, r4
 8028966:	d107      	bne.n	8028978 <_dtoa_r+0xae8>
 8028968:	f000 f8a8 	bl	8028abc <__multadd>
 802896c:	4680      	mov	r8, r0
 802896e:	4607      	mov	r7, r0
 8028970:	9b04      	ldr	r3, [sp, #16]
 8028972:	3301      	adds	r3, #1
 8028974:	9304      	str	r3, [sp, #16]
 8028976:	e775      	b.n	8028864 <_dtoa_r+0x9d4>
 8028978:	f000 f8a0 	bl	8028abc <__multadd>
 802897c:	4639      	mov	r1, r7
 802897e:	4680      	mov	r8, r0
 8028980:	2300      	movs	r3, #0
 8028982:	220a      	movs	r2, #10
 8028984:	4620      	mov	r0, r4
 8028986:	f000 f899 	bl	8028abc <__multadd>
 802898a:	4607      	mov	r7, r0
 802898c:	e7f0      	b.n	8028970 <_dtoa_r+0xae0>
 802898e:	9b04      	ldr	r3, [sp, #16]
 8028990:	9301      	str	r3, [sp, #4]
 8028992:	9d00      	ldr	r5, [sp, #0]
 8028994:	4631      	mov	r1, r6
 8028996:	4650      	mov	r0, sl
 8028998:	f7ff f9f0 	bl	8027d7c <quorem>
 802899c:	f100 0930 	add.w	r9, r0, #48	; 0x30
 80289a0:	9b00      	ldr	r3, [sp, #0]
 80289a2:	f805 9b01 	strb.w	r9, [r5], #1
 80289a6:	1aea      	subs	r2, r5, r3
 80289a8:	9b01      	ldr	r3, [sp, #4]
 80289aa:	4293      	cmp	r3, r2
 80289ac:	dd07      	ble.n	80289be <_dtoa_r+0xb2e>
 80289ae:	4651      	mov	r1, sl
 80289b0:	2300      	movs	r3, #0
 80289b2:	220a      	movs	r2, #10
 80289b4:	4620      	mov	r0, r4
 80289b6:	f000 f881 	bl	8028abc <__multadd>
 80289ba:	4682      	mov	sl, r0
 80289bc:	e7ea      	b.n	8028994 <_dtoa_r+0xb04>
 80289be:	9b01      	ldr	r3, [sp, #4]
 80289c0:	2b00      	cmp	r3, #0
 80289c2:	bfc8      	it	gt
 80289c4:	461d      	movgt	r5, r3
 80289c6:	9b00      	ldr	r3, [sp, #0]
 80289c8:	bfd8      	it	le
 80289ca:	2501      	movle	r5, #1
 80289cc:	441d      	add	r5, r3
 80289ce:	f04f 0800 	mov.w	r8, #0
 80289d2:	4651      	mov	r1, sl
 80289d4:	2201      	movs	r2, #1
 80289d6:	4620      	mov	r0, r4
 80289d8:	f000 fa04 	bl	8028de4 <__lshift>
 80289dc:	4631      	mov	r1, r6
 80289de:	4682      	mov	sl, r0
 80289e0:	f000 fa6c 	bl	8028ebc <__mcmp>
 80289e4:	2800      	cmp	r0, #0
 80289e6:	dc96      	bgt.n	8028916 <_dtoa_r+0xa86>
 80289e8:	d102      	bne.n	80289f0 <_dtoa_r+0xb60>
 80289ea:	f019 0f01 	tst.w	r9, #1
 80289ee:	d192      	bne.n	8028916 <_dtoa_r+0xa86>
 80289f0:	462b      	mov	r3, r5
 80289f2:	461d      	mov	r5, r3
 80289f4:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 80289f8:	2a30      	cmp	r2, #48	; 0x30
 80289fa:	d0fa      	beq.n	80289f2 <_dtoa_r+0xb62>
 80289fc:	e6de      	b.n	80287bc <_dtoa_r+0x92c>
 80289fe:	9a00      	ldr	r2, [sp, #0]
 8028a00:	429a      	cmp	r2, r3
 8028a02:	d189      	bne.n	8028918 <_dtoa_r+0xa88>
 8028a04:	f10b 0b01 	add.w	fp, fp, #1
 8028a08:	2331      	movs	r3, #49	; 0x31
 8028a0a:	e796      	b.n	802893a <_dtoa_r+0xaaa>
 8028a0c:	4b09      	ldr	r3, [pc, #36]	; (8028a34 <_dtoa_r+0xba4>)
 8028a0e:	f7ff ba9d 	b.w	8027f4c <_dtoa_r+0xbc>
 8028a12:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028a14:	2b00      	cmp	r3, #0
 8028a16:	f47f aa7c 	bne.w	8027f12 <_dtoa_r+0x82>
 8028a1a:	4b07      	ldr	r3, [pc, #28]	; (8028a38 <_dtoa_r+0xba8>)
 8028a1c:	f7ff ba96 	b.w	8027f4c <_dtoa_r+0xbc>
 8028a20:	9b01      	ldr	r3, [sp, #4]
 8028a22:	2b00      	cmp	r3, #0
 8028a24:	dcb5      	bgt.n	8028992 <_dtoa_r+0xb02>
 8028a26:	9b07      	ldr	r3, [sp, #28]
 8028a28:	2b02      	cmp	r3, #2
 8028a2a:	f73f aeb2 	bgt.w	8028792 <_dtoa_r+0x902>
 8028a2e:	e7b0      	b.n	8028992 <_dtoa_r+0xb02>
 8028a30:	08036588 	.word	0x08036588
 8028a34:	0803654f 	.word	0x0803654f
 8028a38:	0803657b 	.word	0x0803657b

08028a3c <__ascii_mbtowc>:
 8028a3c:	b082      	sub	sp, #8
 8028a3e:	b901      	cbnz	r1, 8028a42 <__ascii_mbtowc+0x6>
 8028a40:	a901      	add	r1, sp, #4
 8028a42:	b142      	cbz	r2, 8028a56 <__ascii_mbtowc+0x1a>
 8028a44:	b14b      	cbz	r3, 8028a5a <__ascii_mbtowc+0x1e>
 8028a46:	7813      	ldrb	r3, [r2, #0]
 8028a48:	600b      	str	r3, [r1, #0]
 8028a4a:	7812      	ldrb	r2, [r2, #0]
 8028a4c:	1e10      	subs	r0, r2, #0
 8028a4e:	bf18      	it	ne
 8028a50:	2001      	movne	r0, #1
 8028a52:	b002      	add	sp, #8
 8028a54:	4770      	bx	lr
 8028a56:	4610      	mov	r0, r2
 8028a58:	e7fb      	b.n	8028a52 <__ascii_mbtowc+0x16>
 8028a5a:	f06f 0001 	mvn.w	r0, #1
 8028a5e:	e7f8      	b.n	8028a52 <__ascii_mbtowc+0x16>

08028a60 <_Balloc>:
 8028a60:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8028a62:	b570      	push	{r4, r5, r6, lr}
 8028a64:	4605      	mov	r5, r0
 8028a66:	460c      	mov	r4, r1
 8028a68:	b17b      	cbz	r3, 8028a8a <_Balloc+0x2a>
 8028a6a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8028a6c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8028a70:	b9a0      	cbnz	r0, 8028a9c <_Balloc+0x3c>
 8028a72:	2101      	movs	r1, #1
 8028a74:	fa01 f604 	lsl.w	r6, r1, r4
 8028a78:	1d72      	adds	r2, r6, #5
 8028a7a:	0092      	lsls	r2, r2, #2
 8028a7c:	4628      	mov	r0, r5
 8028a7e:	f000 fd87 	bl	8029590 <_calloc_r>
 8028a82:	b148      	cbz	r0, 8028a98 <_Balloc+0x38>
 8028a84:	e9c0 4601 	strd	r4, r6, [r0, #4]
 8028a88:	e00b      	b.n	8028aa2 <_Balloc+0x42>
 8028a8a:	2221      	movs	r2, #33	; 0x21
 8028a8c:	2104      	movs	r1, #4
 8028a8e:	f000 fd7f 	bl	8029590 <_calloc_r>
 8028a92:	6468      	str	r0, [r5, #68]	; 0x44
 8028a94:	2800      	cmp	r0, #0
 8028a96:	d1e8      	bne.n	8028a6a <_Balloc+0xa>
 8028a98:	2000      	movs	r0, #0
 8028a9a:	bd70      	pop	{r4, r5, r6, pc}
 8028a9c:	6802      	ldr	r2, [r0, #0]
 8028a9e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8028aa2:	2300      	movs	r3, #0
 8028aa4:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8028aa8:	e7f7      	b.n	8028a9a <_Balloc+0x3a>

08028aaa <_Bfree>:
 8028aaa:	b131      	cbz	r1, 8028aba <_Bfree+0x10>
 8028aac:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8028aae:	684a      	ldr	r2, [r1, #4]
 8028ab0:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8028ab4:	6008      	str	r0, [r1, #0]
 8028ab6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8028aba:	4770      	bx	lr

08028abc <__multadd>:
 8028abc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8028ac0:	690d      	ldr	r5, [r1, #16]
 8028ac2:	4607      	mov	r7, r0
 8028ac4:	460c      	mov	r4, r1
 8028ac6:	461e      	mov	r6, r3
 8028ac8:	f101 0c14 	add.w	ip, r1, #20
 8028acc:	2000      	movs	r0, #0
 8028ace:	f8dc 3000 	ldr.w	r3, [ip]
 8028ad2:	b299      	uxth	r1, r3
 8028ad4:	fb02 6101 	mla	r1, r2, r1, r6
 8028ad8:	0c1e      	lsrs	r6, r3, #16
 8028ada:	0c0b      	lsrs	r3, r1, #16
 8028adc:	fb02 3306 	mla	r3, r2, r6, r3
 8028ae0:	b289      	uxth	r1, r1
 8028ae2:	3001      	adds	r0, #1
 8028ae4:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8028ae8:	4285      	cmp	r5, r0
 8028aea:	f84c 1b04 	str.w	r1, [ip], #4
 8028aee:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8028af2:	dcec      	bgt.n	8028ace <__multadd+0x12>
 8028af4:	b30e      	cbz	r6, 8028b3a <__multadd+0x7e>
 8028af6:	68a3      	ldr	r3, [r4, #8]
 8028af8:	42ab      	cmp	r3, r5
 8028afa:	dc19      	bgt.n	8028b30 <__multadd+0x74>
 8028afc:	6861      	ldr	r1, [r4, #4]
 8028afe:	4638      	mov	r0, r7
 8028b00:	3101      	adds	r1, #1
 8028b02:	f7ff ffad 	bl	8028a60 <_Balloc>
 8028b06:	4680      	mov	r8, r0
 8028b08:	b928      	cbnz	r0, 8028b16 <__multadd+0x5a>
 8028b0a:	4602      	mov	r2, r0
 8028b0c:	4b0c      	ldr	r3, [pc, #48]	; (8028b40 <__multadd+0x84>)
 8028b0e:	480d      	ldr	r0, [pc, #52]	; (8028b44 <__multadd+0x88>)
 8028b10:	21ba      	movs	r1, #186	; 0xba
 8028b12:	f000 fd1f 	bl	8029554 <__assert_func>
 8028b16:	6922      	ldr	r2, [r4, #16]
 8028b18:	3202      	adds	r2, #2
 8028b1a:	f104 010c 	add.w	r1, r4, #12
 8028b1e:	0092      	lsls	r2, r2, #2
 8028b20:	300c      	adds	r0, #12
 8028b22:	f7fd f9f5 	bl	8025f10 <memcpy>
 8028b26:	4621      	mov	r1, r4
 8028b28:	4638      	mov	r0, r7
 8028b2a:	f7ff ffbe 	bl	8028aaa <_Bfree>
 8028b2e:	4644      	mov	r4, r8
 8028b30:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8028b34:	3501      	adds	r5, #1
 8028b36:	615e      	str	r6, [r3, #20]
 8028b38:	6125      	str	r5, [r4, #16]
 8028b3a:	4620      	mov	r0, r4
 8028b3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8028b40:	08036588 	.word	0x08036588
 8028b44:	080365f1 	.word	0x080365f1

08028b48 <__hi0bits>:
 8028b48:	0c03      	lsrs	r3, r0, #16
 8028b4a:	041b      	lsls	r3, r3, #16
 8028b4c:	b9d3      	cbnz	r3, 8028b84 <__hi0bits+0x3c>
 8028b4e:	0400      	lsls	r0, r0, #16
 8028b50:	2310      	movs	r3, #16
 8028b52:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 8028b56:	bf04      	itt	eq
 8028b58:	0200      	lsleq	r0, r0, #8
 8028b5a:	3308      	addeq	r3, #8
 8028b5c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8028b60:	bf04      	itt	eq
 8028b62:	0100      	lsleq	r0, r0, #4
 8028b64:	3304      	addeq	r3, #4
 8028b66:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8028b6a:	bf04      	itt	eq
 8028b6c:	0080      	lsleq	r0, r0, #2
 8028b6e:	3302      	addeq	r3, #2
 8028b70:	2800      	cmp	r0, #0
 8028b72:	db05      	blt.n	8028b80 <__hi0bits+0x38>
 8028b74:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8028b78:	f103 0301 	add.w	r3, r3, #1
 8028b7c:	bf08      	it	eq
 8028b7e:	2320      	moveq	r3, #32
 8028b80:	4618      	mov	r0, r3
 8028b82:	4770      	bx	lr
 8028b84:	2300      	movs	r3, #0
 8028b86:	e7e4      	b.n	8028b52 <__hi0bits+0xa>

08028b88 <__lo0bits>:
 8028b88:	6803      	ldr	r3, [r0, #0]
 8028b8a:	f013 0207 	ands.w	r2, r3, #7
 8028b8e:	d00c      	beq.n	8028baa <__lo0bits+0x22>
 8028b90:	07d9      	lsls	r1, r3, #31
 8028b92:	d422      	bmi.n	8028bda <__lo0bits+0x52>
 8028b94:	079a      	lsls	r2, r3, #30
 8028b96:	bf49      	itett	mi
 8028b98:	085b      	lsrmi	r3, r3, #1
 8028b9a:	089b      	lsrpl	r3, r3, #2
 8028b9c:	6003      	strmi	r3, [r0, #0]
 8028b9e:	2201      	movmi	r2, #1
 8028ba0:	bf5c      	itt	pl
 8028ba2:	6003      	strpl	r3, [r0, #0]
 8028ba4:	2202      	movpl	r2, #2
 8028ba6:	4610      	mov	r0, r2
 8028ba8:	4770      	bx	lr
 8028baa:	b299      	uxth	r1, r3
 8028bac:	b909      	cbnz	r1, 8028bb2 <__lo0bits+0x2a>
 8028bae:	0c1b      	lsrs	r3, r3, #16
 8028bb0:	2210      	movs	r2, #16
 8028bb2:	b2d9      	uxtb	r1, r3
 8028bb4:	b909      	cbnz	r1, 8028bba <__lo0bits+0x32>
 8028bb6:	3208      	adds	r2, #8
 8028bb8:	0a1b      	lsrs	r3, r3, #8
 8028bba:	0719      	lsls	r1, r3, #28
 8028bbc:	bf04      	itt	eq
 8028bbe:	091b      	lsreq	r3, r3, #4
 8028bc0:	3204      	addeq	r2, #4
 8028bc2:	0799      	lsls	r1, r3, #30
 8028bc4:	bf04      	itt	eq
 8028bc6:	089b      	lsreq	r3, r3, #2
 8028bc8:	3202      	addeq	r2, #2
 8028bca:	07d9      	lsls	r1, r3, #31
 8028bcc:	d403      	bmi.n	8028bd6 <__lo0bits+0x4e>
 8028bce:	085b      	lsrs	r3, r3, #1
 8028bd0:	f102 0201 	add.w	r2, r2, #1
 8028bd4:	d003      	beq.n	8028bde <__lo0bits+0x56>
 8028bd6:	6003      	str	r3, [r0, #0]
 8028bd8:	e7e5      	b.n	8028ba6 <__lo0bits+0x1e>
 8028bda:	2200      	movs	r2, #0
 8028bdc:	e7e3      	b.n	8028ba6 <__lo0bits+0x1e>
 8028bde:	2220      	movs	r2, #32
 8028be0:	e7e1      	b.n	8028ba6 <__lo0bits+0x1e>
	...

08028be4 <__i2b>:
 8028be4:	b510      	push	{r4, lr}
 8028be6:	460c      	mov	r4, r1
 8028be8:	2101      	movs	r1, #1
 8028bea:	f7ff ff39 	bl	8028a60 <_Balloc>
 8028bee:	4602      	mov	r2, r0
 8028bf0:	b928      	cbnz	r0, 8028bfe <__i2b+0x1a>
 8028bf2:	4b05      	ldr	r3, [pc, #20]	; (8028c08 <__i2b+0x24>)
 8028bf4:	4805      	ldr	r0, [pc, #20]	; (8028c0c <__i2b+0x28>)
 8028bf6:	f240 1145 	movw	r1, #325	; 0x145
 8028bfa:	f000 fcab 	bl	8029554 <__assert_func>
 8028bfe:	2301      	movs	r3, #1
 8028c00:	6144      	str	r4, [r0, #20]
 8028c02:	6103      	str	r3, [r0, #16]
 8028c04:	bd10      	pop	{r4, pc}
 8028c06:	bf00      	nop
 8028c08:	08036588 	.word	0x08036588
 8028c0c:	080365f1 	.word	0x080365f1

08028c10 <__multiply>:
 8028c10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028c14:	4691      	mov	r9, r2
 8028c16:	690a      	ldr	r2, [r1, #16]
 8028c18:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8028c1c:	429a      	cmp	r2, r3
 8028c1e:	bfb8      	it	lt
 8028c20:	460b      	movlt	r3, r1
 8028c22:	460c      	mov	r4, r1
 8028c24:	bfbc      	itt	lt
 8028c26:	464c      	movlt	r4, r9
 8028c28:	4699      	movlt	r9, r3
 8028c2a:	6927      	ldr	r7, [r4, #16]
 8028c2c:	f8d9 a010 	ldr.w	sl, [r9, #16]
 8028c30:	68a3      	ldr	r3, [r4, #8]
 8028c32:	6861      	ldr	r1, [r4, #4]
 8028c34:	eb07 060a 	add.w	r6, r7, sl
 8028c38:	42b3      	cmp	r3, r6
 8028c3a:	b085      	sub	sp, #20
 8028c3c:	bfb8      	it	lt
 8028c3e:	3101      	addlt	r1, #1
 8028c40:	f7ff ff0e 	bl	8028a60 <_Balloc>
 8028c44:	b930      	cbnz	r0, 8028c54 <__multiply+0x44>
 8028c46:	4602      	mov	r2, r0
 8028c48:	4b44      	ldr	r3, [pc, #272]	; (8028d5c <__multiply+0x14c>)
 8028c4a:	4845      	ldr	r0, [pc, #276]	; (8028d60 <__multiply+0x150>)
 8028c4c:	f44f 71b1 	mov.w	r1, #354	; 0x162
 8028c50:	f000 fc80 	bl	8029554 <__assert_func>
 8028c54:	f100 0514 	add.w	r5, r0, #20
 8028c58:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 8028c5c:	462b      	mov	r3, r5
 8028c5e:	2200      	movs	r2, #0
 8028c60:	4543      	cmp	r3, r8
 8028c62:	d321      	bcc.n	8028ca8 <__multiply+0x98>
 8028c64:	f104 0314 	add.w	r3, r4, #20
 8028c68:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8028c6c:	f109 0314 	add.w	r3, r9, #20
 8028c70:	eb03 028a 	add.w	r2, r3, sl, lsl #2
 8028c74:	9202      	str	r2, [sp, #8]
 8028c76:	1b3a      	subs	r2, r7, r4
 8028c78:	3a15      	subs	r2, #21
 8028c7a:	f022 0203 	bic.w	r2, r2, #3
 8028c7e:	3204      	adds	r2, #4
 8028c80:	f104 0115 	add.w	r1, r4, #21
 8028c84:	428f      	cmp	r7, r1
 8028c86:	bf38      	it	cc
 8028c88:	2204      	movcc	r2, #4
 8028c8a:	9201      	str	r2, [sp, #4]
 8028c8c:	9a02      	ldr	r2, [sp, #8]
 8028c8e:	9303      	str	r3, [sp, #12]
 8028c90:	429a      	cmp	r2, r3
 8028c92:	d80c      	bhi.n	8028cae <__multiply+0x9e>
 8028c94:	2e00      	cmp	r6, #0
 8028c96:	dd03      	ble.n	8028ca0 <__multiply+0x90>
 8028c98:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 8028c9c:	2b00      	cmp	r3, #0
 8028c9e:	d05b      	beq.n	8028d58 <__multiply+0x148>
 8028ca0:	6106      	str	r6, [r0, #16]
 8028ca2:	b005      	add	sp, #20
 8028ca4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028ca8:	f843 2b04 	str.w	r2, [r3], #4
 8028cac:	e7d8      	b.n	8028c60 <__multiply+0x50>
 8028cae:	f8b3 a000 	ldrh.w	sl, [r3]
 8028cb2:	f1ba 0f00 	cmp.w	sl, #0
 8028cb6:	d024      	beq.n	8028d02 <__multiply+0xf2>
 8028cb8:	f104 0e14 	add.w	lr, r4, #20
 8028cbc:	46a9      	mov	r9, r5
 8028cbe:	f04f 0c00 	mov.w	ip, #0
 8028cc2:	f85e 2b04 	ldr.w	r2, [lr], #4
 8028cc6:	f8d9 1000 	ldr.w	r1, [r9]
 8028cca:	fa1f fb82 	uxth.w	fp, r2
 8028cce:	b289      	uxth	r1, r1
 8028cd0:	fb0a 110b 	mla	r1, sl, fp, r1
 8028cd4:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 8028cd8:	f8d9 2000 	ldr.w	r2, [r9]
 8028cdc:	4461      	add	r1, ip
 8028cde:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 8028ce2:	fb0a c20b 	mla	r2, sl, fp, ip
 8028ce6:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 8028cea:	b289      	uxth	r1, r1
 8028cec:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8028cf0:	4577      	cmp	r7, lr
 8028cf2:	f849 1b04 	str.w	r1, [r9], #4
 8028cf6:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 8028cfa:	d8e2      	bhi.n	8028cc2 <__multiply+0xb2>
 8028cfc:	9a01      	ldr	r2, [sp, #4]
 8028cfe:	f845 c002 	str.w	ip, [r5, r2]
 8028d02:	9a03      	ldr	r2, [sp, #12]
 8028d04:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 8028d08:	3304      	adds	r3, #4
 8028d0a:	f1b9 0f00 	cmp.w	r9, #0
 8028d0e:	d021      	beq.n	8028d54 <__multiply+0x144>
 8028d10:	6829      	ldr	r1, [r5, #0]
 8028d12:	f104 0c14 	add.w	ip, r4, #20
 8028d16:	46ae      	mov	lr, r5
 8028d18:	f04f 0a00 	mov.w	sl, #0
 8028d1c:	f8bc b000 	ldrh.w	fp, [ip]
 8028d20:	f8be 2002 	ldrh.w	r2, [lr, #2]
 8028d24:	fb09 220b 	mla	r2, r9, fp, r2
 8028d28:	4452      	add	r2, sl
 8028d2a:	b289      	uxth	r1, r1
 8028d2c:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8028d30:	f84e 1b04 	str.w	r1, [lr], #4
 8028d34:	f85c 1b04 	ldr.w	r1, [ip], #4
 8028d38:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 8028d3c:	f8be 1000 	ldrh.w	r1, [lr]
 8028d40:	fb09 110a 	mla	r1, r9, sl, r1
 8028d44:	eb01 4112 	add.w	r1, r1, r2, lsr #16
 8028d48:	4567      	cmp	r7, ip
 8028d4a:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 8028d4e:	d8e5      	bhi.n	8028d1c <__multiply+0x10c>
 8028d50:	9a01      	ldr	r2, [sp, #4]
 8028d52:	50a9      	str	r1, [r5, r2]
 8028d54:	3504      	adds	r5, #4
 8028d56:	e799      	b.n	8028c8c <__multiply+0x7c>
 8028d58:	3e01      	subs	r6, #1
 8028d5a:	e79b      	b.n	8028c94 <__multiply+0x84>
 8028d5c:	08036588 	.word	0x08036588
 8028d60:	080365f1 	.word	0x080365f1

08028d64 <__pow5mult>:
 8028d64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8028d68:	4615      	mov	r5, r2
 8028d6a:	f012 0203 	ands.w	r2, r2, #3
 8028d6e:	4606      	mov	r6, r0
 8028d70:	460f      	mov	r7, r1
 8028d72:	d007      	beq.n	8028d84 <__pow5mult+0x20>
 8028d74:	4c1a      	ldr	r4, [pc, #104]	; (8028de0 <__pow5mult+0x7c>)
 8028d76:	3a01      	subs	r2, #1
 8028d78:	2300      	movs	r3, #0
 8028d7a:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8028d7e:	f7ff fe9d 	bl	8028abc <__multadd>
 8028d82:	4607      	mov	r7, r0
 8028d84:	10ad      	asrs	r5, r5, #2
 8028d86:	d027      	beq.n	8028dd8 <__pow5mult+0x74>
 8028d88:	6c34      	ldr	r4, [r6, #64]	; 0x40
 8028d8a:	b944      	cbnz	r4, 8028d9e <__pow5mult+0x3a>
 8028d8c:	f240 2171 	movw	r1, #625	; 0x271
 8028d90:	4630      	mov	r0, r6
 8028d92:	f7ff ff27 	bl	8028be4 <__i2b>
 8028d96:	2300      	movs	r3, #0
 8028d98:	6430      	str	r0, [r6, #64]	; 0x40
 8028d9a:	4604      	mov	r4, r0
 8028d9c:	6003      	str	r3, [r0, #0]
 8028d9e:	f04f 0900 	mov.w	r9, #0
 8028da2:	07eb      	lsls	r3, r5, #31
 8028da4:	d50a      	bpl.n	8028dbc <__pow5mult+0x58>
 8028da6:	4639      	mov	r1, r7
 8028da8:	4622      	mov	r2, r4
 8028daa:	4630      	mov	r0, r6
 8028dac:	f7ff ff30 	bl	8028c10 <__multiply>
 8028db0:	4639      	mov	r1, r7
 8028db2:	4680      	mov	r8, r0
 8028db4:	4630      	mov	r0, r6
 8028db6:	f7ff fe78 	bl	8028aaa <_Bfree>
 8028dba:	4647      	mov	r7, r8
 8028dbc:	106d      	asrs	r5, r5, #1
 8028dbe:	d00b      	beq.n	8028dd8 <__pow5mult+0x74>
 8028dc0:	6820      	ldr	r0, [r4, #0]
 8028dc2:	b938      	cbnz	r0, 8028dd4 <__pow5mult+0x70>
 8028dc4:	4622      	mov	r2, r4
 8028dc6:	4621      	mov	r1, r4
 8028dc8:	4630      	mov	r0, r6
 8028dca:	f7ff ff21 	bl	8028c10 <__multiply>
 8028dce:	6020      	str	r0, [r4, #0]
 8028dd0:	f8c0 9000 	str.w	r9, [r0]
 8028dd4:	4604      	mov	r4, r0
 8028dd6:	e7e4      	b.n	8028da2 <__pow5mult+0x3e>
 8028dd8:	4638      	mov	r0, r7
 8028dda:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8028dde:	bf00      	nop
 8028de0:	08036740 	.word	0x08036740

08028de4 <__lshift>:
 8028de4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028de8:	460c      	mov	r4, r1
 8028dea:	6849      	ldr	r1, [r1, #4]
 8028dec:	6923      	ldr	r3, [r4, #16]
 8028dee:	eb03 1862 	add.w	r8, r3, r2, asr #5
 8028df2:	68a3      	ldr	r3, [r4, #8]
 8028df4:	4607      	mov	r7, r0
 8028df6:	4691      	mov	r9, r2
 8028df8:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8028dfc:	f108 0601 	add.w	r6, r8, #1
 8028e00:	42b3      	cmp	r3, r6
 8028e02:	db0b      	blt.n	8028e1c <__lshift+0x38>
 8028e04:	4638      	mov	r0, r7
 8028e06:	f7ff fe2b 	bl	8028a60 <_Balloc>
 8028e0a:	4605      	mov	r5, r0
 8028e0c:	b948      	cbnz	r0, 8028e22 <__lshift+0x3e>
 8028e0e:	4602      	mov	r2, r0
 8028e10:	4b28      	ldr	r3, [pc, #160]	; (8028eb4 <__lshift+0xd0>)
 8028e12:	4829      	ldr	r0, [pc, #164]	; (8028eb8 <__lshift+0xd4>)
 8028e14:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 8028e18:	f000 fb9c 	bl	8029554 <__assert_func>
 8028e1c:	3101      	adds	r1, #1
 8028e1e:	005b      	lsls	r3, r3, #1
 8028e20:	e7ee      	b.n	8028e00 <__lshift+0x1c>
 8028e22:	2300      	movs	r3, #0
 8028e24:	f100 0114 	add.w	r1, r0, #20
 8028e28:	f100 0210 	add.w	r2, r0, #16
 8028e2c:	4618      	mov	r0, r3
 8028e2e:	4553      	cmp	r3, sl
 8028e30:	db33      	blt.n	8028e9a <__lshift+0xb6>
 8028e32:	6920      	ldr	r0, [r4, #16]
 8028e34:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8028e38:	f104 0314 	add.w	r3, r4, #20
 8028e3c:	f019 091f 	ands.w	r9, r9, #31
 8028e40:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8028e44:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8028e48:	d02b      	beq.n	8028ea2 <__lshift+0xbe>
 8028e4a:	f1c9 0e20 	rsb	lr, r9, #32
 8028e4e:	468a      	mov	sl, r1
 8028e50:	2200      	movs	r2, #0
 8028e52:	6818      	ldr	r0, [r3, #0]
 8028e54:	fa00 f009 	lsl.w	r0, r0, r9
 8028e58:	4310      	orrs	r0, r2
 8028e5a:	f84a 0b04 	str.w	r0, [sl], #4
 8028e5e:	f853 2b04 	ldr.w	r2, [r3], #4
 8028e62:	459c      	cmp	ip, r3
 8028e64:	fa22 f20e 	lsr.w	r2, r2, lr
 8028e68:	d8f3      	bhi.n	8028e52 <__lshift+0x6e>
 8028e6a:	ebac 0304 	sub.w	r3, ip, r4
 8028e6e:	3b15      	subs	r3, #21
 8028e70:	f023 0303 	bic.w	r3, r3, #3
 8028e74:	3304      	adds	r3, #4
 8028e76:	f104 0015 	add.w	r0, r4, #21
 8028e7a:	4584      	cmp	ip, r0
 8028e7c:	bf38      	it	cc
 8028e7e:	2304      	movcc	r3, #4
 8028e80:	50ca      	str	r2, [r1, r3]
 8028e82:	b10a      	cbz	r2, 8028e88 <__lshift+0xa4>
 8028e84:	f108 0602 	add.w	r6, r8, #2
 8028e88:	3e01      	subs	r6, #1
 8028e8a:	4638      	mov	r0, r7
 8028e8c:	612e      	str	r6, [r5, #16]
 8028e8e:	4621      	mov	r1, r4
 8028e90:	f7ff fe0b 	bl	8028aaa <_Bfree>
 8028e94:	4628      	mov	r0, r5
 8028e96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028e9a:	f842 0f04 	str.w	r0, [r2, #4]!
 8028e9e:	3301      	adds	r3, #1
 8028ea0:	e7c5      	b.n	8028e2e <__lshift+0x4a>
 8028ea2:	3904      	subs	r1, #4
 8028ea4:	f853 2b04 	ldr.w	r2, [r3], #4
 8028ea8:	f841 2f04 	str.w	r2, [r1, #4]!
 8028eac:	459c      	cmp	ip, r3
 8028eae:	d8f9      	bhi.n	8028ea4 <__lshift+0xc0>
 8028eb0:	e7ea      	b.n	8028e88 <__lshift+0xa4>
 8028eb2:	bf00      	nop
 8028eb4:	08036588 	.word	0x08036588
 8028eb8:	080365f1 	.word	0x080365f1

08028ebc <__mcmp>:
 8028ebc:	b530      	push	{r4, r5, lr}
 8028ebe:	6902      	ldr	r2, [r0, #16]
 8028ec0:	690c      	ldr	r4, [r1, #16]
 8028ec2:	1b12      	subs	r2, r2, r4
 8028ec4:	d10e      	bne.n	8028ee4 <__mcmp+0x28>
 8028ec6:	f100 0314 	add.w	r3, r0, #20
 8028eca:	3114      	adds	r1, #20
 8028ecc:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 8028ed0:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8028ed4:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 8028ed8:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 8028edc:	42a5      	cmp	r5, r4
 8028ede:	d003      	beq.n	8028ee8 <__mcmp+0x2c>
 8028ee0:	d305      	bcc.n	8028eee <__mcmp+0x32>
 8028ee2:	2201      	movs	r2, #1
 8028ee4:	4610      	mov	r0, r2
 8028ee6:	bd30      	pop	{r4, r5, pc}
 8028ee8:	4283      	cmp	r3, r0
 8028eea:	d3f3      	bcc.n	8028ed4 <__mcmp+0x18>
 8028eec:	e7fa      	b.n	8028ee4 <__mcmp+0x28>
 8028eee:	f04f 32ff 	mov.w	r2, #4294967295
 8028ef2:	e7f7      	b.n	8028ee4 <__mcmp+0x28>

08028ef4 <__mdiff>:
 8028ef4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028ef8:	460c      	mov	r4, r1
 8028efa:	4606      	mov	r6, r0
 8028efc:	4611      	mov	r1, r2
 8028efe:	4620      	mov	r0, r4
 8028f00:	4690      	mov	r8, r2
 8028f02:	f7ff ffdb 	bl	8028ebc <__mcmp>
 8028f06:	1e05      	subs	r5, r0, #0
 8028f08:	d110      	bne.n	8028f2c <__mdiff+0x38>
 8028f0a:	4629      	mov	r1, r5
 8028f0c:	4630      	mov	r0, r6
 8028f0e:	f7ff fda7 	bl	8028a60 <_Balloc>
 8028f12:	b930      	cbnz	r0, 8028f22 <__mdiff+0x2e>
 8028f14:	4b3a      	ldr	r3, [pc, #232]	; (8029000 <__mdiff+0x10c>)
 8028f16:	4602      	mov	r2, r0
 8028f18:	f240 2137 	movw	r1, #567	; 0x237
 8028f1c:	4839      	ldr	r0, [pc, #228]	; (8029004 <__mdiff+0x110>)
 8028f1e:	f000 fb19 	bl	8029554 <__assert_func>
 8028f22:	2301      	movs	r3, #1
 8028f24:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8028f28:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028f2c:	bfa4      	itt	ge
 8028f2e:	4643      	movge	r3, r8
 8028f30:	46a0      	movge	r8, r4
 8028f32:	4630      	mov	r0, r6
 8028f34:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8028f38:	bfa6      	itte	ge
 8028f3a:	461c      	movge	r4, r3
 8028f3c:	2500      	movge	r5, #0
 8028f3e:	2501      	movlt	r5, #1
 8028f40:	f7ff fd8e 	bl	8028a60 <_Balloc>
 8028f44:	b920      	cbnz	r0, 8028f50 <__mdiff+0x5c>
 8028f46:	4b2e      	ldr	r3, [pc, #184]	; (8029000 <__mdiff+0x10c>)
 8028f48:	4602      	mov	r2, r0
 8028f4a:	f240 2145 	movw	r1, #581	; 0x245
 8028f4e:	e7e5      	b.n	8028f1c <__mdiff+0x28>
 8028f50:	f8d8 7010 	ldr.w	r7, [r8, #16]
 8028f54:	6926      	ldr	r6, [r4, #16]
 8028f56:	60c5      	str	r5, [r0, #12]
 8028f58:	f104 0914 	add.w	r9, r4, #20
 8028f5c:	f108 0514 	add.w	r5, r8, #20
 8028f60:	f100 0e14 	add.w	lr, r0, #20
 8028f64:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
 8028f68:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 8028f6c:	f108 0210 	add.w	r2, r8, #16
 8028f70:	46f2      	mov	sl, lr
 8028f72:	2100      	movs	r1, #0
 8028f74:	f859 3b04 	ldr.w	r3, [r9], #4
 8028f78:	f852 bf04 	ldr.w	fp, [r2, #4]!
 8028f7c:	fa11 f88b 	uxtah	r8, r1, fp
 8028f80:	b299      	uxth	r1, r3
 8028f82:	0c1b      	lsrs	r3, r3, #16
 8028f84:	eba8 0801 	sub.w	r8, r8, r1
 8028f88:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 8028f8c:	eb03 4328 	add.w	r3, r3, r8, asr #16
 8028f90:	fa1f f888 	uxth.w	r8, r8
 8028f94:	1419      	asrs	r1, r3, #16
 8028f96:	454e      	cmp	r6, r9
 8028f98:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 8028f9c:	f84a 3b04 	str.w	r3, [sl], #4
 8028fa0:	d8e8      	bhi.n	8028f74 <__mdiff+0x80>
 8028fa2:	1b33      	subs	r3, r6, r4
 8028fa4:	3b15      	subs	r3, #21
 8028fa6:	f023 0303 	bic.w	r3, r3, #3
 8028faa:	3304      	adds	r3, #4
 8028fac:	3415      	adds	r4, #21
 8028fae:	42a6      	cmp	r6, r4
 8028fb0:	bf38      	it	cc
 8028fb2:	2304      	movcc	r3, #4
 8028fb4:	441d      	add	r5, r3
 8028fb6:	4473      	add	r3, lr
 8028fb8:	469e      	mov	lr, r3
 8028fba:	462e      	mov	r6, r5
 8028fbc:	4566      	cmp	r6, ip
 8028fbe:	d30e      	bcc.n	8028fde <__mdiff+0xea>
 8028fc0:	f10c 0203 	add.w	r2, ip, #3
 8028fc4:	1b52      	subs	r2, r2, r5
 8028fc6:	f022 0203 	bic.w	r2, r2, #3
 8028fca:	3d03      	subs	r5, #3
 8028fcc:	45ac      	cmp	ip, r5
 8028fce:	bf38      	it	cc
 8028fd0:	2200      	movcc	r2, #0
 8028fd2:	4413      	add	r3, r2
 8028fd4:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8028fd8:	b17a      	cbz	r2, 8028ffa <__mdiff+0x106>
 8028fda:	6107      	str	r7, [r0, #16]
 8028fdc:	e7a4      	b.n	8028f28 <__mdiff+0x34>
 8028fde:	f856 8b04 	ldr.w	r8, [r6], #4
 8028fe2:	fa11 f288 	uxtah	r2, r1, r8
 8028fe6:	1414      	asrs	r4, r2, #16
 8028fe8:	eb04 4418 	add.w	r4, r4, r8, lsr #16
 8028fec:	b292      	uxth	r2, r2
 8028fee:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 8028ff2:	f84e 2b04 	str.w	r2, [lr], #4
 8028ff6:	1421      	asrs	r1, r4, #16
 8028ff8:	e7e0      	b.n	8028fbc <__mdiff+0xc8>
 8028ffa:	3f01      	subs	r7, #1
 8028ffc:	e7ea      	b.n	8028fd4 <__mdiff+0xe0>
 8028ffe:	bf00      	nop
 8029000:	08036588 	.word	0x08036588
 8029004:	080365f1 	.word	0x080365f1

08029008 <__d2b>:
 8029008:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 802900c:	460f      	mov	r7, r1
 802900e:	2101      	movs	r1, #1
 8029010:	ec59 8b10 	vmov	r8, r9, d0
 8029014:	4616      	mov	r6, r2
 8029016:	f7ff fd23 	bl	8028a60 <_Balloc>
 802901a:	4604      	mov	r4, r0
 802901c:	b930      	cbnz	r0, 802902c <__d2b+0x24>
 802901e:	4602      	mov	r2, r0
 8029020:	4b24      	ldr	r3, [pc, #144]	; (80290b4 <__d2b+0xac>)
 8029022:	4825      	ldr	r0, [pc, #148]	; (80290b8 <__d2b+0xb0>)
 8029024:	f240 310f 	movw	r1, #783	; 0x30f
 8029028:	f000 fa94 	bl	8029554 <__assert_func>
 802902c:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8029030:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8029034:	bb2d      	cbnz	r5, 8029082 <__d2b+0x7a>
 8029036:	9301      	str	r3, [sp, #4]
 8029038:	f1b8 0300 	subs.w	r3, r8, #0
 802903c:	d026      	beq.n	802908c <__d2b+0x84>
 802903e:	4668      	mov	r0, sp
 8029040:	9300      	str	r3, [sp, #0]
 8029042:	f7ff fda1 	bl	8028b88 <__lo0bits>
 8029046:	e9dd 1200 	ldrd	r1, r2, [sp]
 802904a:	b1e8      	cbz	r0, 8029088 <__d2b+0x80>
 802904c:	f1c0 0320 	rsb	r3, r0, #32
 8029050:	fa02 f303 	lsl.w	r3, r2, r3
 8029054:	430b      	orrs	r3, r1
 8029056:	40c2      	lsrs	r2, r0
 8029058:	6163      	str	r3, [r4, #20]
 802905a:	9201      	str	r2, [sp, #4]
 802905c:	9b01      	ldr	r3, [sp, #4]
 802905e:	61a3      	str	r3, [r4, #24]
 8029060:	2b00      	cmp	r3, #0
 8029062:	bf14      	ite	ne
 8029064:	2202      	movne	r2, #2
 8029066:	2201      	moveq	r2, #1
 8029068:	6122      	str	r2, [r4, #16]
 802906a:	b1bd      	cbz	r5, 802909c <__d2b+0x94>
 802906c:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 8029070:	4405      	add	r5, r0
 8029072:	603d      	str	r5, [r7, #0]
 8029074:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8029078:	6030      	str	r0, [r6, #0]
 802907a:	4620      	mov	r0, r4
 802907c:	b003      	add	sp, #12
 802907e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8029082:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8029086:	e7d6      	b.n	8029036 <__d2b+0x2e>
 8029088:	6161      	str	r1, [r4, #20]
 802908a:	e7e7      	b.n	802905c <__d2b+0x54>
 802908c:	a801      	add	r0, sp, #4
 802908e:	f7ff fd7b 	bl	8028b88 <__lo0bits>
 8029092:	9b01      	ldr	r3, [sp, #4]
 8029094:	6163      	str	r3, [r4, #20]
 8029096:	3020      	adds	r0, #32
 8029098:	2201      	movs	r2, #1
 802909a:	e7e5      	b.n	8029068 <__d2b+0x60>
 802909c:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 80290a0:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 80290a4:	6038      	str	r0, [r7, #0]
 80290a6:	6918      	ldr	r0, [r3, #16]
 80290a8:	f7ff fd4e 	bl	8028b48 <__hi0bits>
 80290ac:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 80290b0:	e7e2      	b.n	8029078 <__d2b+0x70>
 80290b2:	bf00      	nop
 80290b4:	08036588 	.word	0x08036588
 80290b8:	080365f1 	.word	0x080365f1

080290bc <_realloc_r>:
 80290bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80290c0:	4682      	mov	sl, r0
 80290c2:	460c      	mov	r4, r1
 80290c4:	b929      	cbnz	r1, 80290d2 <_realloc_r+0x16>
 80290c6:	4611      	mov	r1, r2
 80290c8:	b003      	add	sp, #12
 80290ca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80290ce:	f7fd b851 	b.w	8026174 <_malloc_r>
 80290d2:	9201      	str	r2, [sp, #4]
 80290d4:	f7fd fa88 	bl	80265e8 <__malloc_lock>
 80290d8:	9a01      	ldr	r2, [sp, #4]
 80290da:	f854 5c04 	ldr.w	r5, [r4, #-4]
 80290de:	f102 080b 	add.w	r8, r2, #11
 80290e2:	f1b8 0f16 	cmp.w	r8, #22
 80290e6:	d90b      	bls.n	8029100 <_realloc_r+0x44>
 80290e8:	f038 0807 	bics.w	r8, r8, #7
 80290ec:	d50a      	bpl.n	8029104 <_realloc_r+0x48>
 80290ee:	230c      	movs	r3, #12
 80290f0:	f8ca 3000 	str.w	r3, [sl]
 80290f4:	f04f 0b00 	mov.w	fp, #0
 80290f8:	4658      	mov	r0, fp
 80290fa:	b003      	add	sp, #12
 80290fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029100:	f04f 0810 	mov.w	r8, #16
 8029104:	4590      	cmp	r8, r2
 8029106:	d3f2      	bcc.n	80290ee <_realloc_r+0x32>
 8029108:	f025 0603 	bic.w	r6, r5, #3
 802910c:	45b0      	cmp	r8, r6
 802910e:	f1a4 0908 	sub.w	r9, r4, #8
 8029112:	f340 8170 	ble.w	80293f6 <_realloc_r+0x33a>
 8029116:	499c      	ldr	r1, [pc, #624]	; (8029388 <_realloc_r+0x2cc>)
 8029118:	f8d1 c008 	ldr.w	ip, [r1, #8]
 802911c:	eb09 0306 	add.w	r3, r9, r6
 8029120:	459c      	cmp	ip, r3
 8029122:	6859      	ldr	r1, [r3, #4]
 8029124:	d005      	beq.n	8029132 <_realloc_r+0x76>
 8029126:	f021 0001 	bic.w	r0, r1, #1
 802912a:	4418      	add	r0, r3
 802912c:	6840      	ldr	r0, [r0, #4]
 802912e:	07c7      	lsls	r7, r0, #31
 8029130:	d447      	bmi.n	80291c2 <_realloc_r+0x106>
 8029132:	f021 0103 	bic.w	r1, r1, #3
 8029136:	459c      	cmp	ip, r3
 8029138:	eb06 0701 	add.w	r7, r6, r1
 802913c:	d119      	bne.n	8029172 <_realloc_r+0xb6>
 802913e:	f108 0010 	add.w	r0, r8, #16
 8029142:	42b8      	cmp	r0, r7
 8029144:	dc3f      	bgt.n	80291c6 <_realloc_r+0x10a>
 8029146:	eb09 0308 	add.w	r3, r9, r8
 802914a:	4a8f      	ldr	r2, [pc, #572]	; (8029388 <_realloc_r+0x2cc>)
 802914c:	eba7 0708 	sub.w	r7, r7, r8
 8029150:	f047 0701 	orr.w	r7, r7, #1
 8029154:	6093      	str	r3, [r2, #8]
 8029156:	605f      	str	r7, [r3, #4]
 8029158:	f854 3c04 	ldr.w	r3, [r4, #-4]
 802915c:	f003 0301 	and.w	r3, r3, #1
 8029160:	ea43 0308 	orr.w	r3, r3, r8
 8029164:	f844 3c04 	str.w	r3, [r4, #-4]
 8029168:	4650      	mov	r0, sl
 802916a:	f7fd fa43 	bl	80265f4 <__malloc_unlock>
 802916e:	46a3      	mov	fp, r4
 8029170:	e7c2      	b.n	80290f8 <_realloc_r+0x3c>
 8029172:	45b8      	cmp	r8, r7
 8029174:	dc27      	bgt.n	80291c6 <_realloc_r+0x10a>
 8029176:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 802917a:	60da      	str	r2, [r3, #12]
 802917c:	6093      	str	r3, [r2, #8]
 802917e:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8029182:	eba7 0008 	sub.w	r0, r7, r8
 8029186:	280f      	cmp	r0, #15
 8029188:	f003 0301 	and.w	r3, r3, #1
 802918c:	eb09 0207 	add.w	r2, r9, r7
 8029190:	f240 8133 	bls.w	80293fa <_realloc_r+0x33e>
 8029194:	eb09 0108 	add.w	r1, r9, r8
 8029198:	ea48 0303 	orr.w	r3, r8, r3
 802919c:	f040 0001 	orr.w	r0, r0, #1
 80291a0:	f8c9 3004 	str.w	r3, [r9, #4]
 80291a4:	6048      	str	r0, [r1, #4]
 80291a6:	6853      	ldr	r3, [r2, #4]
 80291a8:	f043 0301 	orr.w	r3, r3, #1
 80291ac:	6053      	str	r3, [r2, #4]
 80291ae:	3108      	adds	r1, #8
 80291b0:	4650      	mov	r0, sl
 80291b2:	f7fc ff1f 	bl	8025ff4 <_free_r>
 80291b6:	4650      	mov	r0, sl
 80291b8:	f7fd fa1c 	bl	80265f4 <__malloc_unlock>
 80291bc:	f109 0b08 	add.w	fp, r9, #8
 80291c0:	e79a      	b.n	80290f8 <_realloc_r+0x3c>
 80291c2:	2100      	movs	r1, #0
 80291c4:	460b      	mov	r3, r1
 80291c6:	07e8      	lsls	r0, r5, #31
 80291c8:	f100 80c6 	bmi.w	8029358 <_realloc_r+0x29c>
 80291cc:	f854 5c08 	ldr.w	r5, [r4, #-8]
 80291d0:	eba9 0505 	sub.w	r5, r9, r5
 80291d4:	6868      	ldr	r0, [r5, #4]
 80291d6:	f020 0003 	bic.w	r0, r0, #3
 80291da:	eb00 0b06 	add.w	fp, r0, r6
 80291de:	2b00      	cmp	r3, #0
 80291e0:	f000 8086 	beq.w	80292f0 <_realloc_r+0x234>
 80291e4:	459c      	cmp	ip, r3
 80291e6:	eb01 070b 	add.w	r7, r1, fp
 80291ea:	d149      	bne.n	8029280 <_realloc_r+0x1c4>
 80291ec:	f108 0310 	add.w	r3, r8, #16
 80291f0:	42bb      	cmp	r3, r7
 80291f2:	dc7d      	bgt.n	80292f0 <_realloc_r+0x234>
 80291f4:	46ab      	mov	fp, r5
 80291f6:	68eb      	ldr	r3, [r5, #12]
 80291f8:	f85b 2f08 	ldr.w	r2, [fp, #8]!
 80291fc:	60d3      	str	r3, [r2, #12]
 80291fe:	609a      	str	r2, [r3, #8]
 8029200:	1f32      	subs	r2, r6, #4
 8029202:	2a24      	cmp	r2, #36	; 0x24
 8029204:	d837      	bhi.n	8029276 <_realloc_r+0x1ba>
 8029206:	2a13      	cmp	r2, #19
 8029208:	d933      	bls.n	8029272 <_realloc_r+0x1b6>
 802920a:	6823      	ldr	r3, [r4, #0]
 802920c:	60ab      	str	r3, [r5, #8]
 802920e:	6863      	ldr	r3, [r4, #4]
 8029210:	60eb      	str	r3, [r5, #12]
 8029212:	2a1b      	cmp	r2, #27
 8029214:	d81b      	bhi.n	802924e <_realloc_r+0x192>
 8029216:	3408      	adds	r4, #8
 8029218:	f105 0310 	add.w	r3, r5, #16
 802921c:	6822      	ldr	r2, [r4, #0]
 802921e:	601a      	str	r2, [r3, #0]
 8029220:	6862      	ldr	r2, [r4, #4]
 8029222:	605a      	str	r2, [r3, #4]
 8029224:	68a2      	ldr	r2, [r4, #8]
 8029226:	609a      	str	r2, [r3, #8]
 8029228:	eb05 0308 	add.w	r3, r5, r8
 802922c:	4a56      	ldr	r2, [pc, #344]	; (8029388 <_realloc_r+0x2cc>)
 802922e:	eba7 0708 	sub.w	r7, r7, r8
 8029232:	f047 0701 	orr.w	r7, r7, #1
 8029236:	6093      	str	r3, [r2, #8]
 8029238:	605f      	str	r7, [r3, #4]
 802923a:	686b      	ldr	r3, [r5, #4]
 802923c:	f003 0301 	and.w	r3, r3, #1
 8029240:	ea43 0308 	orr.w	r3, r3, r8
 8029244:	606b      	str	r3, [r5, #4]
 8029246:	4650      	mov	r0, sl
 8029248:	f7fd f9d4 	bl	80265f4 <__malloc_unlock>
 802924c:	e754      	b.n	80290f8 <_realloc_r+0x3c>
 802924e:	68a3      	ldr	r3, [r4, #8]
 8029250:	612b      	str	r3, [r5, #16]
 8029252:	68e3      	ldr	r3, [r4, #12]
 8029254:	616b      	str	r3, [r5, #20]
 8029256:	2a24      	cmp	r2, #36	; 0x24
 8029258:	bf01      	itttt	eq
 802925a:	6923      	ldreq	r3, [r4, #16]
 802925c:	61ab      	streq	r3, [r5, #24]
 802925e:	6962      	ldreq	r2, [r4, #20]
 8029260:	61ea      	streq	r2, [r5, #28]
 8029262:	bf19      	ittee	ne
 8029264:	3410      	addne	r4, #16
 8029266:	f105 0318 	addne.w	r3, r5, #24
 802926a:	f105 0320 	addeq.w	r3, r5, #32
 802926e:	3418      	addeq	r4, #24
 8029270:	e7d4      	b.n	802921c <_realloc_r+0x160>
 8029272:	465b      	mov	r3, fp
 8029274:	e7d2      	b.n	802921c <_realloc_r+0x160>
 8029276:	4621      	mov	r1, r4
 8029278:	4658      	mov	r0, fp
 802927a:	f000 f951 	bl	8029520 <memmove>
 802927e:	e7d3      	b.n	8029228 <_realloc_r+0x16c>
 8029280:	45b8      	cmp	r8, r7
 8029282:	dc35      	bgt.n	80292f0 <_realloc_r+0x234>
 8029284:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8029288:	4628      	mov	r0, r5
 802928a:	60da      	str	r2, [r3, #12]
 802928c:	6093      	str	r3, [r2, #8]
 802928e:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8029292:	68eb      	ldr	r3, [r5, #12]
 8029294:	60d3      	str	r3, [r2, #12]
 8029296:	609a      	str	r2, [r3, #8]
 8029298:	1f32      	subs	r2, r6, #4
 802929a:	2a24      	cmp	r2, #36	; 0x24
 802929c:	d824      	bhi.n	80292e8 <_realloc_r+0x22c>
 802929e:	2a13      	cmp	r2, #19
 80292a0:	d908      	bls.n	80292b4 <_realloc_r+0x1f8>
 80292a2:	6823      	ldr	r3, [r4, #0]
 80292a4:	60ab      	str	r3, [r5, #8]
 80292a6:	6863      	ldr	r3, [r4, #4]
 80292a8:	60eb      	str	r3, [r5, #12]
 80292aa:	2a1b      	cmp	r2, #27
 80292ac:	d80a      	bhi.n	80292c4 <_realloc_r+0x208>
 80292ae:	3408      	adds	r4, #8
 80292b0:	f105 0010 	add.w	r0, r5, #16
 80292b4:	6823      	ldr	r3, [r4, #0]
 80292b6:	6003      	str	r3, [r0, #0]
 80292b8:	6863      	ldr	r3, [r4, #4]
 80292ba:	6043      	str	r3, [r0, #4]
 80292bc:	68a3      	ldr	r3, [r4, #8]
 80292be:	6083      	str	r3, [r0, #8]
 80292c0:	46a9      	mov	r9, r5
 80292c2:	e75c      	b.n	802917e <_realloc_r+0xc2>
 80292c4:	68a3      	ldr	r3, [r4, #8]
 80292c6:	612b      	str	r3, [r5, #16]
 80292c8:	68e3      	ldr	r3, [r4, #12]
 80292ca:	616b      	str	r3, [r5, #20]
 80292cc:	2a24      	cmp	r2, #36	; 0x24
 80292ce:	bf01      	itttt	eq
 80292d0:	6923      	ldreq	r3, [r4, #16]
 80292d2:	61ab      	streq	r3, [r5, #24]
 80292d4:	6963      	ldreq	r3, [r4, #20]
 80292d6:	61eb      	streq	r3, [r5, #28]
 80292d8:	bf19      	ittee	ne
 80292da:	3410      	addne	r4, #16
 80292dc:	f105 0018 	addne.w	r0, r5, #24
 80292e0:	f105 0020 	addeq.w	r0, r5, #32
 80292e4:	3418      	addeq	r4, #24
 80292e6:	e7e5      	b.n	80292b4 <_realloc_r+0x1f8>
 80292e8:	4621      	mov	r1, r4
 80292ea:	f000 f919 	bl	8029520 <memmove>
 80292ee:	e7e7      	b.n	80292c0 <_realloc_r+0x204>
 80292f0:	45d8      	cmp	r8, fp
 80292f2:	dc31      	bgt.n	8029358 <_realloc_r+0x29c>
 80292f4:	4628      	mov	r0, r5
 80292f6:	68eb      	ldr	r3, [r5, #12]
 80292f8:	f850 2f08 	ldr.w	r2, [r0, #8]!
 80292fc:	60d3      	str	r3, [r2, #12]
 80292fe:	609a      	str	r2, [r3, #8]
 8029300:	1f32      	subs	r2, r6, #4
 8029302:	2a24      	cmp	r2, #36	; 0x24
 8029304:	d824      	bhi.n	8029350 <_realloc_r+0x294>
 8029306:	2a13      	cmp	r2, #19
 8029308:	d908      	bls.n	802931c <_realloc_r+0x260>
 802930a:	6823      	ldr	r3, [r4, #0]
 802930c:	60ab      	str	r3, [r5, #8]
 802930e:	6863      	ldr	r3, [r4, #4]
 8029310:	60eb      	str	r3, [r5, #12]
 8029312:	2a1b      	cmp	r2, #27
 8029314:	d80a      	bhi.n	802932c <_realloc_r+0x270>
 8029316:	3408      	adds	r4, #8
 8029318:	f105 0010 	add.w	r0, r5, #16
 802931c:	6823      	ldr	r3, [r4, #0]
 802931e:	6003      	str	r3, [r0, #0]
 8029320:	6863      	ldr	r3, [r4, #4]
 8029322:	6043      	str	r3, [r0, #4]
 8029324:	68a3      	ldr	r3, [r4, #8]
 8029326:	6083      	str	r3, [r0, #8]
 8029328:	465f      	mov	r7, fp
 802932a:	e7c9      	b.n	80292c0 <_realloc_r+0x204>
 802932c:	68a3      	ldr	r3, [r4, #8]
 802932e:	612b      	str	r3, [r5, #16]
 8029330:	68e3      	ldr	r3, [r4, #12]
 8029332:	616b      	str	r3, [r5, #20]
 8029334:	2a24      	cmp	r2, #36	; 0x24
 8029336:	bf01      	itttt	eq
 8029338:	6923      	ldreq	r3, [r4, #16]
 802933a:	61ab      	streq	r3, [r5, #24]
 802933c:	6963      	ldreq	r3, [r4, #20]
 802933e:	61eb      	streq	r3, [r5, #28]
 8029340:	bf19      	ittee	ne
 8029342:	3410      	addne	r4, #16
 8029344:	f105 0018 	addne.w	r0, r5, #24
 8029348:	f105 0020 	addeq.w	r0, r5, #32
 802934c:	3418      	addeq	r4, #24
 802934e:	e7e5      	b.n	802931c <_realloc_r+0x260>
 8029350:	4621      	mov	r1, r4
 8029352:	f000 f8e5 	bl	8029520 <memmove>
 8029356:	e7e7      	b.n	8029328 <_realloc_r+0x26c>
 8029358:	4611      	mov	r1, r2
 802935a:	4650      	mov	r0, sl
 802935c:	f7fc ff0a 	bl	8026174 <_malloc_r>
 8029360:	4683      	mov	fp, r0
 8029362:	2800      	cmp	r0, #0
 8029364:	f43f af6f 	beq.w	8029246 <_realloc_r+0x18a>
 8029368:	f854 3c04 	ldr.w	r3, [r4, #-4]
 802936c:	f023 0301 	bic.w	r3, r3, #1
 8029370:	444b      	add	r3, r9
 8029372:	f1a0 0208 	sub.w	r2, r0, #8
 8029376:	4293      	cmp	r3, r2
 8029378:	d108      	bne.n	802938c <_realloc_r+0x2d0>
 802937a:	f850 7c04 	ldr.w	r7, [r0, #-4]
 802937e:	f027 0703 	bic.w	r7, r7, #3
 8029382:	4437      	add	r7, r6
 8029384:	e6fb      	b.n	802917e <_realloc_r+0xc2>
 8029386:	bf00      	nop
 8029388:	20000388 	.word	0x20000388
 802938c:	1f32      	subs	r2, r6, #4
 802938e:	2a24      	cmp	r2, #36	; 0x24
 8029390:	d82d      	bhi.n	80293ee <_realloc_r+0x332>
 8029392:	2a13      	cmp	r2, #19
 8029394:	d928      	bls.n	80293e8 <_realloc_r+0x32c>
 8029396:	6823      	ldr	r3, [r4, #0]
 8029398:	6003      	str	r3, [r0, #0]
 802939a:	6863      	ldr	r3, [r4, #4]
 802939c:	6043      	str	r3, [r0, #4]
 802939e:	2a1b      	cmp	r2, #27
 80293a0:	d80e      	bhi.n	80293c0 <_realloc_r+0x304>
 80293a2:	f104 0208 	add.w	r2, r4, #8
 80293a6:	f100 0308 	add.w	r3, r0, #8
 80293aa:	6811      	ldr	r1, [r2, #0]
 80293ac:	6019      	str	r1, [r3, #0]
 80293ae:	6851      	ldr	r1, [r2, #4]
 80293b0:	6059      	str	r1, [r3, #4]
 80293b2:	6892      	ldr	r2, [r2, #8]
 80293b4:	609a      	str	r2, [r3, #8]
 80293b6:	4621      	mov	r1, r4
 80293b8:	4650      	mov	r0, sl
 80293ba:	f7fc fe1b 	bl	8025ff4 <_free_r>
 80293be:	e742      	b.n	8029246 <_realloc_r+0x18a>
 80293c0:	68a3      	ldr	r3, [r4, #8]
 80293c2:	6083      	str	r3, [r0, #8]
 80293c4:	68e3      	ldr	r3, [r4, #12]
 80293c6:	60c3      	str	r3, [r0, #12]
 80293c8:	2a24      	cmp	r2, #36	; 0x24
 80293ca:	bf01      	itttt	eq
 80293cc:	6923      	ldreq	r3, [r4, #16]
 80293ce:	6103      	streq	r3, [r0, #16]
 80293d0:	6961      	ldreq	r1, [r4, #20]
 80293d2:	6141      	streq	r1, [r0, #20]
 80293d4:	bf19      	ittee	ne
 80293d6:	f104 0210 	addne.w	r2, r4, #16
 80293da:	f100 0310 	addne.w	r3, r0, #16
 80293de:	f104 0218 	addeq.w	r2, r4, #24
 80293e2:	f100 0318 	addeq.w	r3, r0, #24
 80293e6:	e7e0      	b.n	80293aa <_realloc_r+0x2ee>
 80293e8:	4603      	mov	r3, r0
 80293ea:	4622      	mov	r2, r4
 80293ec:	e7dd      	b.n	80293aa <_realloc_r+0x2ee>
 80293ee:	4621      	mov	r1, r4
 80293f0:	f000 f896 	bl	8029520 <memmove>
 80293f4:	e7df      	b.n	80293b6 <_realloc_r+0x2fa>
 80293f6:	4637      	mov	r7, r6
 80293f8:	e6c1      	b.n	802917e <_realloc_r+0xc2>
 80293fa:	431f      	orrs	r7, r3
 80293fc:	f8c9 7004 	str.w	r7, [r9, #4]
 8029400:	6853      	ldr	r3, [r2, #4]
 8029402:	f043 0301 	orr.w	r3, r3, #1
 8029406:	6053      	str	r3, [r2, #4]
 8029408:	e6d5      	b.n	80291b6 <_realloc_r+0xfa>
 802940a:	bf00      	nop

0802940c <__ascii_wctomb>:
 802940c:	b149      	cbz	r1, 8029422 <__ascii_wctomb+0x16>
 802940e:	2aff      	cmp	r2, #255	; 0xff
 8029410:	bf85      	ittet	hi
 8029412:	238a      	movhi	r3, #138	; 0x8a
 8029414:	6003      	strhi	r3, [r0, #0]
 8029416:	700a      	strbls	r2, [r1, #0]
 8029418:	f04f 30ff 	movhi.w	r0, #4294967295
 802941c:	bf98      	it	ls
 802941e:	2001      	movls	r0, #1
 8029420:	4770      	bx	lr
 8029422:	4608      	mov	r0, r1
 8029424:	4770      	bx	lr

08029426 <__ssprint_r>:
 8029426:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802942a:	6813      	ldr	r3, [r2, #0]
 802942c:	9301      	str	r3, [sp, #4]
 802942e:	6893      	ldr	r3, [r2, #8]
 8029430:	4680      	mov	r8, r0
 8029432:	460c      	mov	r4, r1
 8029434:	4617      	mov	r7, r2
 8029436:	2b00      	cmp	r3, #0
 8029438:	d157      	bne.n	80294ea <__ssprint_r+0xc4>
 802943a:	2000      	movs	r0, #0
 802943c:	2300      	movs	r3, #0
 802943e:	607b      	str	r3, [r7, #4]
 8029440:	b003      	add	sp, #12
 8029442:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029446:	9b01      	ldr	r3, [sp, #4]
 8029448:	e9d3 ab00 	ldrd	sl, fp, [r3]
 802944c:	3308      	adds	r3, #8
 802944e:	9301      	str	r3, [sp, #4]
 8029450:	68a6      	ldr	r6, [r4, #8]
 8029452:	6820      	ldr	r0, [r4, #0]
 8029454:	f1bb 0f00 	cmp.w	fp, #0
 8029458:	d0f5      	beq.n	8029446 <__ssprint_r+0x20>
 802945a:	45b3      	cmp	fp, r6
 802945c:	d32d      	bcc.n	80294ba <__ssprint_r+0x94>
 802945e:	89a2      	ldrh	r2, [r4, #12]
 8029460:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8029464:	d029      	beq.n	80294ba <__ssprint_r+0x94>
 8029466:	6921      	ldr	r1, [r4, #16]
 8029468:	6965      	ldr	r5, [r4, #20]
 802946a:	eba0 0901 	sub.w	r9, r0, r1
 802946e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8029472:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8029476:	f109 0001 	add.w	r0, r9, #1
 802947a:	106d      	asrs	r5, r5, #1
 802947c:	4458      	add	r0, fp
 802947e:	4285      	cmp	r5, r0
 8029480:	bf38      	it	cc
 8029482:	4605      	movcc	r5, r0
 8029484:	0553      	lsls	r3, r2, #21
 8029486:	d534      	bpl.n	80294f2 <__ssprint_r+0xcc>
 8029488:	4629      	mov	r1, r5
 802948a:	4640      	mov	r0, r8
 802948c:	f7fc fe72 	bl	8026174 <_malloc_r>
 8029490:	4606      	mov	r6, r0
 8029492:	2800      	cmp	r0, #0
 8029494:	d038      	beq.n	8029508 <__ssprint_r+0xe2>
 8029496:	464a      	mov	r2, r9
 8029498:	6921      	ldr	r1, [r4, #16]
 802949a:	f7fc fd39 	bl	8025f10 <memcpy>
 802949e:	89a2      	ldrh	r2, [r4, #12]
 80294a0:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 80294a4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80294a8:	81a2      	strh	r2, [r4, #12]
 80294aa:	6126      	str	r6, [r4, #16]
 80294ac:	6165      	str	r5, [r4, #20]
 80294ae:	444e      	add	r6, r9
 80294b0:	eba5 0509 	sub.w	r5, r5, r9
 80294b4:	6026      	str	r6, [r4, #0]
 80294b6:	60a5      	str	r5, [r4, #8]
 80294b8:	465e      	mov	r6, fp
 80294ba:	455e      	cmp	r6, fp
 80294bc:	bf28      	it	cs
 80294be:	465e      	movcs	r6, fp
 80294c0:	4632      	mov	r2, r6
 80294c2:	4651      	mov	r1, sl
 80294c4:	6820      	ldr	r0, [r4, #0]
 80294c6:	f000 f82b 	bl	8029520 <memmove>
 80294ca:	68a2      	ldr	r2, [r4, #8]
 80294cc:	1b92      	subs	r2, r2, r6
 80294ce:	60a2      	str	r2, [r4, #8]
 80294d0:	6822      	ldr	r2, [r4, #0]
 80294d2:	4432      	add	r2, r6
 80294d4:	6022      	str	r2, [r4, #0]
 80294d6:	68ba      	ldr	r2, [r7, #8]
 80294d8:	eba2 030b 	sub.w	r3, r2, fp
 80294dc:	44da      	add	sl, fp
 80294de:	60bb      	str	r3, [r7, #8]
 80294e0:	2b00      	cmp	r3, #0
 80294e2:	d0aa      	beq.n	802943a <__ssprint_r+0x14>
 80294e4:	f04f 0b00 	mov.w	fp, #0
 80294e8:	e7b2      	b.n	8029450 <__ssprint_r+0x2a>
 80294ea:	f04f 0a00 	mov.w	sl, #0
 80294ee:	46d3      	mov	fp, sl
 80294f0:	e7ae      	b.n	8029450 <__ssprint_r+0x2a>
 80294f2:	462a      	mov	r2, r5
 80294f4:	4640      	mov	r0, r8
 80294f6:	f7ff fde1 	bl	80290bc <_realloc_r>
 80294fa:	4606      	mov	r6, r0
 80294fc:	2800      	cmp	r0, #0
 80294fe:	d1d4      	bne.n	80294aa <__ssprint_r+0x84>
 8029500:	6921      	ldr	r1, [r4, #16]
 8029502:	4640      	mov	r0, r8
 8029504:	f7fc fd76 	bl	8025ff4 <_free_r>
 8029508:	230c      	movs	r3, #12
 802950a:	f8c8 3000 	str.w	r3, [r8]
 802950e:	89a3      	ldrh	r3, [r4, #12]
 8029510:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029514:	81a3      	strh	r3, [r4, #12]
 8029516:	2300      	movs	r3, #0
 8029518:	60bb      	str	r3, [r7, #8]
 802951a:	f04f 30ff 	mov.w	r0, #4294967295
 802951e:	e78d      	b.n	802943c <__ssprint_r+0x16>

08029520 <memmove>:
 8029520:	4288      	cmp	r0, r1
 8029522:	b510      	push	{r4, lr}
 8029524:	eb01 0402 	add.w	r4, r1, r2
 8029528:	d902      	bls.n	8029530 <memmove+0x10>
 802952a:	4284      	cmp	r4, r0
 802952c:	4623      	mov	r3, r4
 802952e:	d807      	bhi.n	8029540 <memmove+0x20>
 8029530:	1e43      	subs	r3, r0, #1
 8029532:	42a1      	cmp	r1, r4
 8029534:	d008      	beq.n	8029548 <memmove+0x28>
 8029536:	f811 2b01 	ldrb.w	r2, [r1], #1
 802953a:	f803 2f01 	strb.w	r2, [r3, #1]!
 802953e:	e7f8      	b.n	8029532 <memmove+0x12>
 8029540:	4402      	add	r2, r0
 8029542:	4601      	mov	r1, r0
 8029544:	428a      	cmp	r2, r1
 8029546:	d100      	bne.n	802954a <memmove+0x2a>
 8029548:	bd10      	pop	{r4, pc}
 802954a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 802954e:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8029552:	e7f7      	b.n	8029544 <memmove+0x24>

08029554 <__assert_func>:
 8029554:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8029556:	4614      	mov	r4, r2
 8029558:	461a      	mov	r2, r3
 802955a:	4b09      	ldr	r3, [pc, #36]	; (8029580 <__assert_func+0x2c>)
 802955c:	681b      	ldr	r3, [r3, #0]
 802955e:	4605      	mov	r5, r0
 8029560:	68d8      	ldr	r0, [r3, #12]
 8029562:	b14c      	cbz	r4, 8029578 <__assert_func+0x24>
 8029564:	4b07      	ldr	r3, [pc, #28]	; (8029584 <__assert_func+0x30>)
 8029566:	9100      	str	r1, [sp, #0]
 8029568:	e9cd 3401 	strd	r3, r4, [sp, #4]
 802956c:	4906      	ldr	r1, [pc, #24]	; (8029588 <__assert_func+0x34>)
 802956e:	462b      	mov	r3, r5
 8029570:	f000 f844 	bl	80295fc <fiprintf>
 8029574:	f000 ff65 	bl	802a442 <abort>
 8029578:	4b04      	ldr	r3, [pc, #16]	; (802958c <__assert_func+0x38>)
 802957a:	461c      	mov	r4, r3
 802957c:	e7f3      	b.n	8029566 <__assert_func+0x12>
 802957e:	bf00      	nop
 8029580:	20000380 	.word	0x20000380
 8029584:	0803674c 	.word	0x0803674c
 8029588:	08036759 	.word	0x08036759
 802958c:	08036787 	.word	0x08036787

08029590 <_calloc_r>:
 8029590:	b538      	push	{r3, r4, r5, lr}
 8029592:	fba1 1502 	umull	r1, r5, r1, r2
 8029596:	b92d      	cbnz	r5, 80295a4 <_calloc_r+0x14>
 8029598:	f7fc fdec 	bl	8026174 <_malloc_r>
 802959c:	4604      	mov	r4, r0
 802959e:	b938      	cbnz	r0, 80295b0 <_calloc_r+0x20>
 80295a0:	4620      	mov	r0, r4
 80295a2:	bd38      	pop	{r3, r4, r5, pc}
 80295a4:	f7fc fc7e 	bl	8025ea4 <__errno>
 80295a8:	230c      	movs	r3, #12
 80295aa:	6003      	str	r3, [r0, #0]
 80295ac:	2400      	movs	r4, #0
 80295ae:	e7f7      	b.n	80295a0 <_calloc_r+0x10>
 80295b0:	f850 2c04 	ldr.w	r2, [r0, #-4]
 80295b4:	f022 0203 	bic.w	r2, r2, #3
 80295b8:	3a04      	subs	r2, #4
 80295ba:	2a24      	cmp	r2, #36	; 0x24
 80295bc:	d819      	bhi.n	80295f2 <_calloc_r+0x62>
 80295be:	2a13      	cmp	r2, #19
 80295c0:	d915      	bls.n	80295ee <_calloc_r+0x5e>
 80295c2:	2a1b      	cmp	r2, #27
 80295c4:	e9c0 5500 	strd	r5, r5, [r0]
 80295c8:	d806      	bhi.n	80295d8 <_calloc_r+0x48>
 80295ca:	f100 0308 	add.w	r3, r0, #8
 80295ce:	2200      	movs	r2, #0
 80295d0:	e9c3 2200 	strd	r2, r2, [r3]
 80295d4:	609a      	str	r2, [r3, #8]
 80295d6:	e7e3      	b.n	80295a0 <_calloc_r+0x10>
 80295d8:	2a24      	cmp	r2, #36	; 0x24
 80295da:	e9c0 5502 	strd	r5, r5, [r0, #8]
 80295de:	bf11      	iteee	ne
 80295e0:	f100 0310 	addne.w	r3, r0, #16
 80295e4:	6105      	streq	r5, [r0, #16]
 80295e6:	f100 0318 	addeq.w	r3, r0, #24
 80295ea:	6145      	streq	r5, [r0, #20]
 80295ec:	e7ef      	b.n	80295ce <_calloc_r+0x3e>
 80295ee:	4603      	mov	r3, r0
 80295f0:	e7ed      	b.n	80295ce <_calloc_r+0x3e>
 80295f2:	4629      	mov	r1, r5
 80295f4:	f7fc fbaf 	bl	8025d56 <memset>
 80295f8:	e7d2      	b.n	80295a0 <_calloc_r+0x10>
	...

080295fc <fiprintf>:
 80295fc:	b40e      	push	{r1, r2, r3}
 80295fe:	b503      	push	{r0, r1, lr}
 8029600:	4601      	mov	r1, r0
 8029602:	ab03      	add	r3, sp, #12
 8029604:	4805      	ldr	r0, [pc, #20]	; (802961c <fiprintf+0x20>)
 8029606:	f853 2b04 	ldr.w	r2, [r3], #4
 802960a:	6800      	ldr	r0, [r0, #0]
 802960c:	9301      	str	r3, [sp, #4]
 802960e:	f000 f839 	bl	8029684 <_vfiprintf_r>
 8029612:	b002      	add	sp, #8
 8029614:	f85d eb04 	ldr.w	lr, [sp], #4
 8029618:	b003      	add	sp, #12
 802961a:	4770      	bx	lr
 802961c:	20000380 	.word	0x20000380

08029620 <__sprint_r>:
 8029620:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029624:	6893      	ldr	r3, [r2, #8]
 8029626:	4680      	mov	r8, r0
 8029628:	460f      	mov	r7, r1
 802962a:	4614      	mov	r4, r2
 802962c:	b343      	cbz	r3, 8029680 <__sprint_r+0x60>
 802962e:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8029630:	049d      	lsls	r5, r3, #18
 8029632:	d522      	bpl.n	802967a <__sprint_r+0x5a>
 8029634:	6815      	ldr	r5, [r2, #0]
 8029636:	3508      	adds	r5, #8
 8029638:	e955 b602 	ldrd	fp, r6, [r5, #-8]
 802963c:	f04f 0900 	mov.w	r9, #0
 8029640:	ea4f 0a96 	mov.w	sl, r6, lsr #2
 8029644:	45ca      	cmp	sl, r9
 8029646:	dc0d      	bgt.n	8029664 <__sprint_r+0x44>
 8029648:	68a3      	ldr	r3, [r4, #8]
 802964a:	f026 0603 	bic.w	r6, r6, #3
 802964e:	1b98      	subs	r0, r3, r6
 8029650:	60a0      	str	r0, [r4, #8]
 8029652:	3508      	adds	r5, #8
 8029654:	2800      	cmp	r0, #0
 8029656:	d1ef      	bne.n	8029638 <__sprint_r+0x18>
 8029658:	2300      	movs	r3, #0
 802965a:	60a3      	str	r3, [r4, #8]
 802965c:	2300      	movs	r3, #0
 802965e:	6063      	str	r3, [r4, #4]
 8029660:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029664:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
 8029668:	463a      	mov	r2, r7
 802966a:	4640      	mov	r0, r8
 802966c:	f000 febf 	bl	802a3ee <_fputwc_r>
 8029670:	1c43      	adds	r3, r0, #1
 8029672:	d0f1      	beq.n	8029658 <__sprint_r+0x38>
 8029674:	f109 0901 	add.w	r9, r9, #1
 8029678:	e7e4      	b.n	8029644 <__sprint_r+0x24>
 802967a:	f000 fcd5 	bl	802a028 <__sfvwrite_r>
 802967e:	e7eb      	b.n	8029658 <__sprint_r+0x38>
 8029680:	4618      	mov	r0, r3
 8029682:	e7eb      	b.n	802965c <__sprint_r+0x3c>

08029684 <_vfiprintf_r>:
 8029684:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029688:	ed2d 8b02 	vpush	{d8}
 802968c:	b0bb      	sub	sp, #236	; 0xec
 802968e:	460f      	mov	r7, r1
 8029690:	9201      	str	r2, [sp, #4]
 8029692:	461d      	mov	r5, r3
 8029694:	461c      	mov	r4, r3
 8029696:	4681      	mov	r9, r0
 8029698:	b118      	cbz	r0, 80296a2 <_vfiprintf_r+0x1e>
 802969a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802969c:	b90b      	cbnz	r3, 80296a2 <_vfiprintf_r+0x1e>
 802969e:	f7fc fab1 	bl	8025c04 <__sinit>
 80296a2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80296a4:	07d8      	lsls	r0, r3, #31
 80296a6:	d405      	bmi.n	80296b4 <_vfiprintf_r+0x30>
 80296a8:	89bb      	ldrh	r3, [r7, #12]
 80296aa:	0599      	lsls	r1, r3, #22
 80296ac:	d402      	bmi.n	80296b4 <_vfiprintf_r+0x30>
 80296ae:	6db8      	ldr	r0, [r7, #88]	; 0x58
 80296b0:	f7fc fc24 	bl	8025efc <__retarget_lock_acquire_recursive>
 80296b4:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80296b8:	049a      	lsls	r2, r3, #18
 80296ba:	d406      	bmi.n	80296ca <_vfiprintf_r+0x46>
 80296bc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80296c0:	81bb      	strh	r3, [r7, #12]
 80296c2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80296c4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80296c8:	667b      	str	r3, [r7, #100]	; 0x64
 80296ca:	89bb      	ldrh	r3, [r7, #12]
 80296cc:	071e      	lsls	r6, r3, #28
 80296ce:	d501      	bpl.n	80296d4 <_vfiprintf_r+0x50>
 80296d0:	693b      	ldr	r3, [r7, #16]
 80296d2:	b9bb      	cbnz	r3, 8029704 <_vfiprintf_r+0x80>
 80296d4:	4639      	mov	r1, r7
 80296d6:	4648      	mov	r0, r9
 80296d8:	f000 fdf0 	bl	802a2bc <__swsetup_r>
 80296dc:	b190      	cbz	r0, 8029704 <_vfiprintf_r+0x80>
 80296de:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80296e0:	07d8      	lsls	r0, r3, #31
 80296e2:	d508      	bpl.n	80296f6 <_vfiprintf_r+0x72>
 80296e4:	f04f 33ff 	mov.w	r3, #4294967295
 80296e8:	9302      	str	r3, [sp, #8]
 80296ea:	9802      	ldr	r0, [sp, #8]
 80296ec:	b03b      	add	sp, #236	; 0xec
 80296ee:	ecbd 8b02 	vpop	{d8}
 80296f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80296f6:	89bb      	ldrh	r3, [r7, #12]
 80296f8:	0599      	lsls	r1, r3, #22
 80296fa:	d4f3      	bmi.n	80296e4 <_vfiprintf_r+0x60>
 80296fc:	6db8      	ldr	r0, [r7, #88]	; 0x58
 80296fe:	f7fc fbfe 	bl	8025efe <__retarget_lock_release_recursive>
 8029702:	e7ef      	b.n	80296e4 <_vfiprintf_r+0x60>
 8029704:	89bb      	ldrh	r3, [r7, #12]
 8029706:	f003 021a 	and.w	r2, r3, #26
 802970a:	2a0a      	cmp	r2, #10
 802970c:	d116      	bne.n	802973c <_vfiprintf_r+0xb8>
 802970e:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8029712:	2a00      	cmp	r2, #0
 8029714:	db12      	blt.n	802973c <_vfiprintf_r+0xb8>
 8029716:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8029718:	07d2      	lsls	r2, r2, #31
 802971a:	d404      	bmi.n	8029726 <_vfiprintf_r+0xa2>
 802971c:	059e      	lsls	r6, r3, #22
 802971e:	d402      	bmi.n	8029726 <_vfiprintf_r+0xa2>
 8029720:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8029722:	f7fc fbec 	bl	8025efe <__retarget_lock_release_recursive>
 8029726:	9a01      	ldr	r2, [sp, #4]
 8029728:	462b      	mov	r3, r5
 802972a:	4639      	mov	r1, r7
 802972c:	4648      	mov	r0, r9
 802972e:	b03b      	add	sp, #236	; 0xec
 8029730:	ecbd 8b02 	vpop	{d8}
 8029734:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029738:	f000 bc36 	b.w	8029fa8 <__sbprintf>
 802973c:	2300      	movs	r3, #0
 802973e:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
 8029742:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8029746:	ae11      	add	r6, sp, #68	; 0x44
 8029748:	ee08 3a10 	vmov	s16, r3
 802974c:	960e      	str	r6, [sp, #56]	; 0x38
 802974e:	9307      	str	r3, [sp, #28]
 8029750:	9302      	str	r3, [sp, #8]
 8029752:	9b01      	ldr	r3, [sp, #4]
 8029754:	461d      	mov	r5, r3
 8029756:	f813 2b01 	ldrb.w	r2, [r3], #1
 802975a:	b10a      	cbz	r2, 8029760 <_vfiprintf_r+0xdc>
 802975c:	2a25      	cmp	r2, #37	; 0x25
 802975e:	d1f9      	bne.n	8029754 <_vfiprintf_r+0xd0>
 8029760:	9b01      	ldr	r3, [sp, #4]
 8029762:	ebb5 0803 	subs.w	r8, r5, r3
 8029766:	d00d      	beq.n	8029784 <_vfiprintf_r+0x100>
 8029768:	e9c6 3800 	strd	r3, r8, [r6]
 802976c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802976e:	4443      	add	r3, r8
 8029770:	9310      	str	r3, [sp, #64]	; 0x40
 8029772:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8029774:	3301      	adds	r3, #1
 8029776:	2b07      	cmp	r3, #7
 8029778:	930f      	str	r3, [sp, #60]	; 0x3c
 802977a:	dc76      	bgt.n	802986a <_vfiprintf_r+0x1e6>
 802977c:	3608      	adds	r6, #8
 802977e:	9b02      	ldr	r3, [sp, #8]
 8029780:	4443      	add	r3, r8
 8029782:	9302      	str	r3, [sp, #8]
 8029784:	782b      	ldrb	r3, [r5, #0]
 8029786:	2b00      	cmp	r3, #0
 8029788:	f000 83d0 	beq.w	8029f2c <_vfiprintf_r+0x8a8>
 802978c:	2300      	movs	r3, #0
 802978e:	f04f 32ff 	mov.w	r2, #4294967295
 8029792:	3501      	adds	r5, #1
 8029794:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 8029798:	9200      	str	r2, [sp, #0]
 802979a:	9303      	str	r3, [sp, #12]
 802979c:	469a      	mov	sl, r3
 802979e:	462a      	mov	r2, r5
 80297a0:	f812 3b01 	ldrb.w	r3, [r2], #1
 80297a4:	9201      	str	r2, [sp, #4]
 80297a6:	f1a3 0220 	sub.w	r2, r3, #32
 80297aa:	2a5a      	cmp	r2, #90	; 0x5a
 80297ac:	f200 831c 	bhi.w	8029de8 <_vfiprintf_r+0x764>
 80297b0:	e8df f012 	tbh	[pc, r2, lsl #1]
 80297b4:	031a007e 	.word	0x031a007e
 80297b8:	0086031a 	.word	0x0086031a
 80297bc:	031a031a 	.word	0x031a031a
 80297c0:	0065031a 	.word	0x0065031a
 80297c4:	031a031a 	.word	0x031a031a
 80297c8:	00930089 	.word	0x00930089
 80297cc:	0090031a 	.word	0x0090031a
 80297d0:	031a0095 	.word	0x031a0095
 80297d4:	00b300b0 	.word	0x00b300b0
 80297d8:	00b300b3 	.word	0x00b300b3
 80297dc:	00b300b3 	.word	0x00b300b3
 80297e0:	00b300b3 	.word	0x00b300b3
 80297e4:	00b300b3 	.word	0x00b300b3
 80297e8:	031a031a 	.word	0x031a031a
 80297ec:	031a031a 	.word	0x031a031a
 80297f0:	031a031a 	.word	0x031a031a
 80297f4:	031a031a 	.word	0x031a031a
 80297f8:	00dd031a 	.word	0x00dd031a
 80297fc:	031a00eb 	.word	0x031a00eb
 8029800:	031a031a 	.word	0x031a031a
 8029804:	031a031a 	.word	0x031a031a
 8029808:	031a031a 	.word	0x031a031a
 802980c:	031a031a 	.word	0x031a031a
 8029810:	013b031a 	.word	0x013b031a
 8029814:	031a031a 	.word	0x031a031a
 8029818:	0180031a 	.word	0x0180031a
 802981c:	025e031a 	.word	0x025e031a
 8029820:	031a031a 	.word	0x031a031a
 8029824:	031a027e 	.word	0x031a027e
 8029828:	031a031a 	.word	0x031a031a
 802982c:	031a031a 	.word	0x031a031a
 8029830:	031a031a 	.word	0x031a031a
 8029834:	031a031a 	.word	0x031a031a
 8029838:	00dd031a 	.word	0x00dd031a
 802983c:	031a00ed 	.word	0x031a00ed
 8029840:	031a031a 	.word	0x031a031a
 8029844:	00ed00c3 	.word	0x00ed00c3
 8029848:	031a00d7 	.word	0x031a00d7
 802984c:	031a00d0 	.word	0x031a00d0
 8029850:	013d0119 	.word	0x013d0119
 8029854:	00d70172 	.word	0x00d70172
 8029858:	0180031a 	.word	0x0180031a
 802985c:	0260007c 	.word	0x0260007c
 8029860:	031a031a 	.word	0x031a031a
 8029864:	031a029a 	.word	0x031a029a
 8029868:	007c      	.short	0x007c
 802986a:	aa0e      	add	r2, sp, #56	; 0x38
 802986c:	4639      	mov	r1, r7
 802986e:	4648      	mov	r0, r9
 8029870:	f7ff fed6 	bl	8029620 <__sprint_r>
 8029874:	2800      	cmp	r0, #0
 8029876:	f040 8338 	bne.w	8029eea <_vfiprintf_r+0x866>
 802987a:	ae11      	add	r6, sp, #68	; 0x44
 802987c:	e77f      	b.n	802977e <_vfiprintf_r+0xfa>
 802987e:	4648      	mov	r0, r9
 8029880:	f7fe f9d0 	bl	8027c24 <_localeconv_r>
 8029884:	6843      	ldr	r3, [r0, #4]
 8029886:	4618      	mov	r0, r3
 8029888:	ee08 3a10 	vmov	s16, r3
 802988c:	f7d6 fcb2 	bl	80001f4 <strlen>
 8029890:	9007      	str	r0, [sp, #28]
 8029892:	4648      	mov	r0, r9
 8029894:	f7fe f9c6 	bl	8027c24 <_localeconv_r>
 8029898:	6883      	ldr	r3, [r0, #8]
 802989a:	9306      	str	r3, [sp, #24]
 802989c:	9b07      	ldr	r3, [sp, #28]
 802989e:	b12b      	cbz	r3, 80298ac <_vfiprintf_r+0x228>
 80298a0:	9b06      	ldr	r3, [sp, #24]
 80298a2:	b11b      	cbz	r3, 80298ac <_vfiprintf_r+0x228>
 80298a4:	781b      	ldrb	r3, [r3, #0]
 80298a6:	b10b      	cbz	r3, 80298ac <_vfiprintf_r+0x228>
 80298a8:	f44a 6a80 	orr.w	sl, sl, #1024	; 0x400
 80298ac:	9d01      	ldr	r5, [sp, #4]
 80298ae:	e776      	b.n	802979e <_vfiprintf_r+0x11a>
 80298b0:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 80298b4:	2b00      	cmp	r3, #0
 80298b6:	d1f9      	bne.n	80298ac <_vfiprintf_r+0x228>
 80298b8:	2320      	movs	r3, #32
 80298ba:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 80298be:	e7f5      	b.n	80298ac <_vfiprintf_r+0x228>
 80298c0:	f04a 0a01 	orr.w	sl, sl, #1
 80298c4:	e7f2      	b.n	80298ac <_vfiprintf_r+0x228>
 80298c6:	f854 3b04 	ldr.w	r3, [r4], #4
 80298ca:	9303      	str	r3, [sp, #12]
 80298cc:	2b00      	cmp	r3, #0
 80298ce:	daed      	bge.n	80298ac <_vfiprintf_r+0x228>
 80298d0:	425b      	negs	r3, r3
 80298d2:	9303      	str	r3, [sp, #12]
 80298d4:	f04a 0a04 	orr.w	sl, sl, #4
 80298d8:	e7e8      	b.n	80298ac <_vfiprintf_r+0x228>
 80298da:	232b      	movs	r3, #43	; 0x2b
 80298dc:	e7ed      	b.n	80298ba <_vfiprintf_r+0x236>
 80298de:	9a01      	ldr	r2, [sp, #4]
 80298e0:	f812 3b01 	ldrb.w	r3, [r2], #1
 80298e4:	2b2a      	cmp	r3, #42	; 0x2a
 80298e6:	d112      	bne.n	802990e <_vfiprintf_r+0x28a>
 80298e8:	f854 3b04 	ldr.w	r3, [r4], #4
 80298ec:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 80298f0:	e9cd 3200 	strd	r3, r2, [sp]
 80298f4:	e7da      	b.n	80298ac <_vfiprintf_r+0x228>
 80298f6:	9b00      	ldr	r3, [sp, #0]
 80298f8:	200a      	movs	r0, #10
 80298fa:	fb00 1303 	mla	r3, r0, r3, r1
 80298fe:	9300      	str	r3, [sp, #0]
 8029900:	f812 3b01 	ldrb.w	r3, [r2], #1
 8029904:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8029908:	2909      	cmp	r1, #9
 802990a:	d9f4      	bls.n	80298f6 <_vfiprintf_r+0x272>
 802990c:	e74a      	b.n	80297a4 <_vfiprintf_r+0x120>
 802990e:	2100      	movs	r1, #0
 8029910:	9100      	str	r1, [sp, #0]
 8029912:	e7f7      	b.n	8029904 <_vfiprintf_r+0x280>
 8029914:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 8029918:	e7c8      	b.n	80298ac <_vfiprintf_r+0x228>
 802991a:	2100      	movs	r1, #0
 802991c:	9a01      	ldr	r2, [sp, #4]
 802991e:	9103      	str	r1, [sp, #12]
 8029920:	9903      	ldr	r1, [sp, #12]
 8029922:	3b30      	subs	r3, #48	; 0x30
 8029924:	200a      	movs	r0, #10
 8029926:	fb00 3301 	mla	r3, r0, r1, r3
 802992a:	9303      	str	r3, [sp, #12]
 802992c:	f812 3b01 	ldrb.w	r3, [r2], #1
 8029930:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8029934:	2909      	cmp	r1, #9
 8029936:	d9f3      	bls.n	8029920 <_vfiprintf_r+0x29c>
 8029938:	e734      	b.n	80297a4 <_vfiprintf_r+0x120>
 802993a:	9b01      	ldr	r3, [sp, #4]
 802993c:	781b      	ldrb	r3, [r3, #0]
 802993e:	2b68      	cmp	r3, #104	; 0x68
 8029940:	bf01      	itttt	eq
 8029942:	9b01      	ldreq	r3, [sp, #4]
 8029944:	3301      	addeq	r3, #1
 8029946:	9301      	streq	r3, [sp, #4]
 8029948:	f44a 7a00 	orreq.w	sl, sl, #512	; 0x200
 802994c:	bf18      	it	ne
 802994e:	f04a 0a40 	orrne.w	sl, sl, #64	; 0x40
 8029952:	e7ab      	b.n	80298ac <_vfiprintf_r+0x228>
 8029954:	9b01      	ldr	r3, [sp, #4]
 8029956:	781b      	ldrb	r3, [r3, #0]
 8029958:	2b6c      	cmp	r3, #108	; 0x6c
 802995a:	d105      	bne.n	8029968 <_vfiprintf_r+0x2e4>
 802995c:	9b01      	ldr	r3, [sp, #4]
 802995e:	3301      	adds	r3, #1
 8029960:	9301      	str	r3, [sp, #4]
 8029962:	f04a 0a20 	orr.w	sl, sl, #32
 8029966:	e7a1      	b.n	80298ac <_vfiprintf_r+0x228>
 8029968:	f04a 0a10 	orr.w	sl, sl, #16
 802996c:	e79e      	b.n	80298ac <_vfiprintf_r+0x228>
 802996e:	46a0      	mov	r8, r4
 8029970:	f858 3b04 	ldr.w	r3, [r8], #4
 8029974:	f88d 3084 	strb.w	r3, [sp, #132]	; 0x84
 8029978:	2300      	movs	r3, #0
 802997a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 802997e:	2201      	movs	r2, #1
 8029980:	9200      	str	r2, [sp, #0]
 8029982:	461d      	mov	r5, r3
 8029984:	f10d 0b84 	add.w	fp, sp, #132	; 0x84
 8029988:	e0a9      	b.n	8029ade <_vfiprintf_r+0x45a>
 802998a:	f04a 0a10 	orr.w	sl, sl, #16
 802998e:	f01a 0f20 	tst.w	sl, #32
 8029992:	d011      	beq.n	80299b8 <_vfiprintf_r+0x334>
 8029994:	3407      	adds	r4, #7
 8029996:	f024 0307 	bic.w	r3, r4, #7
 802999a:	4698      	mov	r8, r3
 802999c:	685d      	ldr	r5, [r3, #4]
 802999e:	f858 4b08 	ldr.w	r4, [r8], #8
 80299a2:	2d00      	cmp	r5, #0
 80299a4:	da06      	bge.n	80299b4 <_vfiprintf_r+0x330>
 80299a6:	4264      	negs	r4, r4
 80299a8:	f04f 032d 	mov.w	r3, #45	; 0x2d
 80299ac:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 80299b0:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 80299b4:	2301      	movs	r3, #1
 80299b6:	e04a      	b.n	8029a4e <_vfiprintf_r+0x3ca>
 80299b8:	46a0      	mov	r8, r4
 80299ba:	f01a 0f10 	tst.w	sl, #16
 80299be:	f858 5b04 	ldr.w	r5, [r8], #4
 80299c2:	d002      	beq.n	80299ca <_vfiprintf_r+0x346>
 80299c4:	462c      	mov	r4, r5
 80299c6:	17ed      	asrs	r5, r5, #31
 80299c8:	e7eb      	b.n	80299a2 <_vfiprintf_r+0x31e>
 80299ca:	f01a 0f40 	tst.w	sl, #64	; 0x40
 80299ce:	d003      	beq.n	80299d8 <_vfiprintf_r+0x354>
 80299d0:	b22c      	sxth	r4, r5
 80299d2:	f345 35c0 	sbfx	r5, r5, #15, #1
 80299d6:	e7e4      	b.n	80299a2 <_vfiprintf_r+0x31e>
 80299d8:	f41a 7f00 	tst.w	sl, #512	; 0x200
 80299dc:	d0f2      	beq.n	80299c4 <_vfiprintf_r+0x340>
 80299de:	b26c      	sxtb	r4, r5
 80299e0:	f345 15c0 	sbfx	r5, r5, #7, #1
 80299e4:	e7dd      	b.n	80299a2 <_vfiprintf_r+0x31e>
 80299e6:	f01a 0f20 	tst.w	sl, #32
 80299ea:	f104 0804 	add.w	r8, r4, #4
 80299ee:	d007      	beq.n	8029a00 <_vfiprintf_r+0x37c>
 80299f0:	9a02      	ldr	r2, [sp, #8]
 80299f2:	6823      	ldr	r3, [r4, #0]
 80299f4:	9902      	ldr	r1, [sp, #8]
 80299f6:	17d2      	asrs	r2, r2, #31
 80299f8:	e9c3 1200 	strd	r1, r2, [r3]
 80299fc:	4644      	mov	r4, r8
 80299fe:	e6a8      	b.n	8029752 <_vfiprintf_r+0xce>
 8029a00:	f01a 0f10 	tst.w	sl, #16
 8029a04:	d003      	beq.n	8029a0e <_vfiprintf_r+0x38a>
 8029a06:	6823      	ldr	r3, [r4, #0]
 8029a08:	9a02      	ldr	r2, [sp, #8]
 8029a0a:	601a      	str	r2, [r3, #0]
 8029a0c:	e7f6      	b.n	80299fc <_vfiprintf_r+0x378>
 8029a0e:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8029a12:	d003      	beq.n	8029a1c <_vfiprintf_r+0x398>
 8029a14:	6823      	ldr	r3, [r4, #0]
 8029a16:	9a02      	ldr	r2, [sp, #8]
 8029a18:	801a      	strh	r2, [r3, #0]
 8029a1a:	e7ef      	b.n	80299fc <_vfiprintf_r+0x378>
 8029a1c:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8029a20:	d0f1      	beq.n	8029a06 <_vfiprintf_r+0x382>
 8029a22:	6823      	ldr	r3, [r4, #0]
 8029a24:	9a02      	ldr	r2, [sp, #8]
 8029a26:	701a      	strb	r2, [r3, #0]
 8029a28:	e7e8      	b.n	80299fc <_vfiprintf_r+0x378>
 8029a2a:	f04a 0a10 	orr.w	sl, sl, #16
 8029a2e:	f01a 0320 	ands.w	r3, sl, #32
 8029a32:	d01f      	beq.n	8029a74 <_vfiprintf_r+0x3f0>
 8029a34:	3407      	adds	r4, #7
 8029a36:	f024 0307 	bic.w	r3, r4, #7
 8029a3a:	4698      	mov	r8, r3
 8029a3c:	685d      	ldr	r5, [r3, #4]
 8029a3e:	f858 4b08 	ldr.w	r4, [r8], #8
 8029a42:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 8029a46:	2300      	movs	r3, #0
 8029a48:	2200      	movs	r2, #0
 8029a4a:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
 8029a4e:	9a00      	ldr	r2, [sp, #0]
 8029a50:	3201      	adds	r2, #1
 8029a52:	f000 8278 	beq.w	8029f46 <_vfiprintf_r+0x8c2>
 8029a56:	f02a 0280 	bic.w	r2, sl, #128	; 0x80
 8029a5a:	9204      	str	r2, [sp, #16]
 8029a5c:	ea54 0205 	orrs.w	r2, r4, r5
 8029a60:	f040 8277 	bne.w	8029f52 <_vfiprintf_r+0x8ce>
 8029a64:	9a00      	ldr	r2, [sp, #0]
 8029a66:	2a00      	cmp	r2, #0
 8029a68:	f000 81b3 	beq.w	8029dd2 <_vfiprintf_r+0x74e>
 8029a6c:	2b01      	cmp	r3, #1
 8029a6e:	f040 8273 	bne.w	8029f58 <_vfiprintf_r+0x8d4>
 8029a72:	e151      	b.n	8029d18 <_vfiprintf_r+0x694>
 8029a74:	46a0      	mov	r8, r4
 8029a76:	f01a 0510 	ands.w	r5, sl, #16
 8029a7a:	f858 4b04 	ldr.w	r4, [r8], #4
 8029a7e:	d001      	beq.n	8029a84 <_vfiprintf_r+0x400>
 8029a80:	461d      	mov	r5, r3
 8029a82:	e7de      	b.n	8029a42 <_vfiprintf_r+0x3be>
 8029a84:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 8029a88:	d001      	beq.n	8029a8e <_vfiprintf_r+0x40a>
 8029a8a:	b2a4      	uxth	r4, r4
 8029a8c:	e7d9      	b.n	8029a42 <_vfiprintf_r+0x3be>
 8029a8e:	f41a 7500 	ands.w	r5, sl, #512	; 0x200
 8029a92:	d0d6      	beq.n	8029a42 <_vfiprintf_r+0x3be>
 8029a94:	b2e4      	uxtb	r4, r4
 8029a96:	e7f3      	b.n	8029a80 <_vfiprintf_r+0x3fc>
 8029a98:	46a0      	mov	r8, r4
 8029a9a:	f647 0330 	movw	r3, #30768	; 0x7830
 8029a9e:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
 8029aa2:	f858 4b04 	ldr.w	r4, [r8], #4
 8029aa6:	4b9f      	ldr	r3, [pc, #636]	; (8029d24 <_vfiprintf_r+0x6a0>)
 8029aa8:	9305      	str	r3, [sp, #20]
 8029aaa:	2500      	movs	r5, #0
 8029aac:	f04a 0a02 	orr.w	sl, sl, #2
 8029ab0:	2302      	movs	r3, #2
 8029ab2:	e7c9      	b.n	8029a48 <_vfiprintf_r+0x3c4>
 8029ab4:	9b00      	ldr	r3, [sp, #0]
 8029ab6:	46a0      	mov	r8, r4
 8029ab8:	2500      	movs	r5, #0
 8029aba:	1c5c      	adds	r4, r3, #1
 8029abc:	f858 bb04 	ldr.w	fp, [r8], #4
 8029ac0:	f88d 5033 	strb.w	r5, [sp, #51]	; 0x33
 8029ac4:	f000 80cf 	beq.w	8029c66 <_vfiprintf_r+0x5e2>
 8029ac8:	461a      	mov	r2, r3
 8029aca:	4629      	mov	r1, r5
 8029acc:	4658      	mov	r0, fp
 8029ace:	f7d6 fb9f 	bl	8000210 <memchr>
 8029ad2:	2800      	cmp	r0, #0
 8029ad4:	f000 8192 	beq.w	8029dfc <_vfiprintf_r+0x778>
 8029ad8:	eba0 030b 	sub.w	r3, r0, fp
 8029adc:	9300      	str	r3, [sp, #0]
 8029ade:	9b00      	ldr	r3, [sp, #0]
 8029ae0:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
 8029ae4:	42ab      	cmp	r3, r5
 8029ae6:	bfb8      	it	lt
 8029ae8:	462b      	movlt	r3, r5
 8029aea:	9304      	str	r3, [sp, #16]
 8029aec:	b10a      	cbz	r2, 8029af2 <_vfiprintf_r+0x46e>
 8029aee:	3301      	adds	r3, #1
 8029af0:	9304      	str	r3, [sp, #16]
 8029af2:	f01a 0302 	ands.w	r3, sl, #2
 8029af6:	9308      	str	r3, [sp, #32]
 8029af8:	bf1e      	ittt	ne
 8029afa:	9b04      	ldrne	r3, [sp, #16]
 8029afc:	3302      	addne	r3, #2
 8029afe:	9304      	strne	r3, [sp, #16]
 8029b00:	f01a 0384 	ands.w	r3, sl, #132	; 0x84
 8029b04:	9309      	str	r3, [sp, #36]	; 0x24
 8029b06:	d11f      	bne.n	8029b48 <_vfiprintf_r+0x4c4>
 8029b08:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8029b0c:	1a9c      	subs	r4, r3, r2
 8029b0e:	2c00      	cmp	r4, #0
 8029b10:	dd1a      	ble.n	8029b48 <_vfiprintf_r+0x4c4>
 8029b12:	4b85      	ldr	r3, [pc, #532]	; (8029d28 <_vfiprintf_r+0x6a4>)
 8029b14:	6033      	str	r3, [r6, #0]
 8029b16:	e9dd 2c0f 	ldrd	r2, ip, [sp, #60]	; 0x3c
 8029b1a:	2c10      	cmp	r4, #16
 8029b1c:	f102 0201 	add.w	r2, r2, #1
 8029b20:	f106 0008 	add.w	r0, r6, #8
 8029b24:	f300 816c 	bgt.w	8029e00 <_vfiprintf_r+0x77c>
 8029b28:	6074      	str	r4, [r6, #4]
 8029b2a:	2a07      	cmp	r2, #7
 8029b2c:	4464      	add	r4, ip
 8029b2e:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 8029b32:	f340 8178 	ble.w	8029e26 <_vfiprintf_r+0x7a2>
 8029b36:	aa0e      	add	r2, sp, #56	; 0x38
 8029b38:	4639      	mov	r1, r7
 8029b3a:	4648      	mov	r0, r9
 8029b3c:	f7ff fd70 	bl	8029620 <__sprint_r>
 8029b40:	2800      	cmp	r0, #0
 8029b42:	f040 81d2 	bne.w	8029eea <_vfiprintf_r+0x866>
 8029b46:	ae11      	add	r6, sp, #68	; 0x44
 8029b48:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
 8029b4c:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 8029b50:	b160      	cbz	r0, 8029b6c <_vfiprintf_r+0x4e8>
 8029b52:	f10d 0033 	add.w	r0, sp, #51	; 0x33
 8029b56:	3201      	adds	r2, #1
 8029b58:	6030      	str	r0, [r6, #0]
 8029b5a:	2001      	movs	r0, #1
 8029b5c:	4401      	add	r1, r0
 8029b5e:	2a07      	cmp	r2, #7
 8029b60:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 8029b64:	6070      	str	r0, [r6, #4]
 8029b66:	f300 8160 	bgt.w	8029e2a <_vfiprintf_r+0x7a6>
 8029b6a:	3608      	adds	r6, #8
 8029b6c:	9b08      	ldr	r3, [sp, #32]
 8029b6e:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 8029b72:	b15b      	cbz	r3, 8029b8c <_vfiprintf_r+0x508>
 8029b74:	a80d      	add	r0, sp, #52	; 0x34
 8029b76:	3201      	adds	r2, #1
 8029b78:	6030      	str	r0, [r6, #0]
 8029b7a:	2002      	movs	r0, #2
 8029b7c:	4401      	add	r1, r0
 8029b7e:	2a07      	cmp	r2, #7
 8029b80:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 8029b84:	6070      	str	r0, [r6, #4]
 8029b86:	f300 8159 	bgt.w	8029e3c <_vfiprintf_r+0x7b8>
 8029b8a:	3608      	adds	r6, #8
 8029b8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8029b8e:	2b80      	cmp	r3, #128	; 0x80
 8029b90:	d11f      	bne.n	8029bd2 <_vfiprintf_r+0x54e>
 8029b92:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8029b96:	1a9c      	subs	r4, r3, r2
 8029b98:	2c00      	cmp	r4, #0
 8029b9a:	dd1a      	ble.n	8029bd2 <_vfiprintf_r+0x54e>
 8029b9c:	4b63      	ldr	r3, [pc, #396]	; (8029d2c <_vfiprintf_r+0x6a8>)
 8029b9e:	6033      	str	r3, [r6, #0]
 8029ba0:	e9dd 2c0f 	ldrd	r2, ip, [sp, #60]	; 0x3c
 8029ba4:	2c10      	cmp	r4, #16
 8029ba6:	f102 0201 	add.w	r2, r2, #1
 8029baa:	f106 0008 	add.w	r0, r6, #8
 8029bae:	f300 814e 	bgt.w	8029e4e <_vfiprintf_r+0x7ca>
 8029bb2:	6074      	str	r4, [r6, #4]
 8029bb4:	2a07      	cmp	r2, #7
 8029bb6:	4464      	add	r4, ip
 8029bb8:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 8029bbc:	f340 815a 	ble.w	8029e74 <_vfiprintf_r+0x7f0>
 8029bc0:	aa0e      	add	r2, sp, #56	; 0x38
 8029bc2:	4639      	mov	r1, r7
 8029bc4:	4648      	mov	r0, r9
 8029bc6:	f7ff fd2b 	bl	8029620 <__sprint_r>
 8029bca:	2800      	cmp	r0, #0
 8029bcc:	f040 818d 	bne.w	8029eea <_vfiprintf_r+0x866>
 8029bd0:	ae11      	add	r6, sp, #68	; 0x44
 8029bd2:	9b00      	ldr	r3, [sp, #0]
 8029bd4:	1aec      	subs	r4, r5, r3
 8029bd6:	2c00      	cmp	r4, #0
 8029bd8:	dd1b      	ble.n	8029c12 <_vfiprintf_r+0x58e>
 8029bda:	4d54      	ldr	r5, [pc, #336]	; (8029d2c <_vfiprintf_r+0x6a8>)
 8029bdc:	2310      	movs	r3, #16
 8029bde:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 8029be2:	2c10      	cmp	r4, #16
 8029be4:	f102 0201 	add.w	r2, r2, #1
 8029be8:	f106 0008 	add.w	r0, r6, #8
 8029bec:	6035      	str	r5, [r6, #0]
 8029bee:	f300 8143 	bgt.w	8029e78 <_vfiprintf_r+0x7f4>
 8029bf2:	6074      	str	r4, [r6, #4]
 8029bf4:	2a07      	cmp	r2, #7
 8029bf6:	440c      	add	r4, r1
 8029bf8:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 8029bfc:	f340 814d 	ble.w	8029e9a <_vfiprintf_r+0x816>
 8029c00:	aa0e      	add	r2, sp, #56	; 0x38
 8029c02:	4639      	mov	r1, r7
 8029c04:	4648      	mov	r0, r9
 8029c06:	f7ff fd0b 	bl	8029620 <__sprint_r>
 8029c0a:	2800      	cmp	r0, #0
 8029c0c:	f040 816d 	bne.w	8029eea <_vfiprintf_r+0x866>
 8029c10:	ae11      	add	r6, sp, #68	; 0x44
 8029c12:	9b00      	ldr	r3, [sp, #0]
 8029c14:	9a00      	ldr	r2, [sp, #0]
 8029c16:	6073      	str	r3, [r6, #4]
 8029c18:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8029c1a:	f8c6 b000 	str.w	fp, [r6]
 8029c1e:	4413      	add	r3, r2
 8029c20:	9310      	str	r3, [sp, #64]	; 0x40
 8029c22:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8029c24:	3301      	adds	r3, #1
 8029c26:	2b07      	cmp	r3, #7
 8029c28:	930f      	str	r3, [sp, #60]	; 0x3c
 8029c2a:	f300 8138 	bgt.w	8029e9e <_vfiprintf_r+0x81a>
 8029c2e:	f106 0308 	add.w	r3, r6, #8
 8029c32:	f01a 0f04 	tst.w	sl, #4
 8029c36:	f040 813a 	bne.w	8029eae <_vfiprintf_r+0x82a>
 8029c3a:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8029c3e:	9904      	ldr	r1, [sp, #16]
 8029c40:	428a      	cmp	r2, r1
 8029c42:	bfac      	ite	ge
 8029c44:	189b      	addge	r3, r3, r2
 8029c46:	185b      	addlt	r3, r3, r1
 8029c48:	9302      	str	r3, [sp, #8]
 8029c4a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8029c4c:	b13b      	cbz	r3, 8029c5e <_vfiprintf_r+0x5da>
 8029c4e:	aa0e      	add	r2, sp, #56	; 0x38
 8029c50:	4639      	mov	r1, r7
 8029c52:	4648      	mov	r0, r9
 8029c54:	f7ff fce4 	bl	8029620 <__sprint_r>
 8029c58:	2800      	cmp	r0, #0
 8029c5a:	f040 8146 	bne.w	8029eea <_vfiprintf_r+0x866>
 8029c5e:	2300      	movs	r3, #0
 8029c60:	930f      	str	r3, [sp, #60]	; 0x3c
 8029c62:	ae11      	add	r6, sp, #68	; 0x44
 8029c64:	e6ca      	b.n	80299fc <_vfiprintf_r+0x378>
 8029c66:	4658      	mov	r0, fp
 8029c68:	f7d6 fac4 	bl	80001f4 <strlen>
 8029c6c:	9000      	str	r0, [sp, #0]
 8029c6e:	e736      	b.n	8029ade <_vfiprintf_r+0x45a>
 8029c70:	f04a 0a10 	orr.w	sl, sl, #16
 8029c74:	f01a 0320 	ands.w	r3, sl, #32
 8029c78:	d008      	beq.n	8029c8c <_vfiprintf_r+0x608>
 8029c7a:	3407      	adds	r4, #7
 8029c7c:	f024 0307 	bic.w	r3, r4, #7
 8029c80:	4698      	mov	r8, r3
 8029c82:	685d      	ldr	r5, [r3, #4]
 8029c84:	f858 4b08 	ldr.w	r4, [r8], #8
 8029c88:	2301      	movs	r3, #1
 8029c8a:	e6dd      	b.n	8029a48 <_vfiprintf_r+0x3c4>
 8029c8c:	46a0      	mov	r8, r4
 8029c8e:	f01a 0510 	ands.w	r5, sl, #16
 8029c92:	f858 4b04 	ldr.w	r4, [r8], #4
 8029c96:	d001      	beq.n	8029c9c <_vfiprintf_r+0x618>
 8029c98:	461d      	mov	r5, r3
 8029c9a:	e7f5      	b.n	8029c88 <_vfiprintf_r+0x604>
 8029c9c:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 8029ca0:	d001      	beq.n	8029ca6 <_vfiprintf_r+0x622>
 8029ca2:	b2a4      	uxth	r4, r4
 8029ca4:	e7f0      	b.n	8029c88 <_vfiprintf_r+0x604>
 8029ca6:	f41a 7500 	ands.w	r5, sl, #512	; 0x200
 8029caa:	d0ed      	beq.n	8029c88 <_vfiprintf_r+0x604>
 8029cac:	b2e4      	uxtb	r4, r4
 8029cae:	e7f3      	b.n	8029c98 <_vfiprintf_r+0x614>
 8029cb0:	4a1f      	ldr	r2, [pc, #124]	; (8029d30 <_vfiprintf_r+0x6ac>)
 8029cb2:	9205      	str	r2, [sp, #20]
 8029cb4:	f01a 0220 	ands.w	r2, sl, #32
 8029cb8:	d018      	beq.n	8029cec <_vfiprintf_r+0x668>
 8029cba:	3407      	adds	r4, #7
 8029cbc:	f024 0207 	bic.w	r2, r4, #7
 8029cc0:	4690      	mov	r8, r2
 8029cc2:	6855      	ldr	r5, [r2, #4]
 8029cc4:	f858 4b08 	ldr.w	r4, [r8], #8
 8029cc8:	f01a 0f01 	tst.w	sl, #1
 8029ccc:	d009      	beq.n	8029ce2 <_vfiprintf_r+0x65e>
 8029cce:	ea54 0205 	orrs.w	r2, r4, r5
 8029cd2:	bf1f      	itttt	ne
 8029cd4:	2230      	movne	r2, #48	; 0x30
 8029cd6:	f88d 2034 	strbne.w	r2, [sp, #52]	; 0x34
 8029cda:	f88d 3035 	strbne.w	r3, [sp, #53]	; 0x35
 8029cde:	f04a 0a02 	orrne.w	sl, sl, #2
 8029ce2:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 8029ce6:	e6e3      	b.n	8029ab0 <_vfiprintf_r+0x42c>
 8029ce8:	4a0e      	ldr	r2, [pc, #56]	; (8029d24 <_vfiprintf_r+0x6a0>)
 8029cea:	e7e2      	b.n	8029cb2 <_vfiprintf_r+0x62e>
 8029cec:	46a0      	mov	r8, r4
 8029cee:	f01a 0510 	ands.w	r5, sl, #16
 8029cf2:	f858 4b04 	ldr.w	r4, [r8], #4
 8029cf6:	d001      	beq.n	8029cfc <_vfiprintf_r+0x678>
 8029cf8:	4615      	mov	r5, r2
 8029cfa:	e7e5      	b.n	8029cc8 <_vfiprintf_r+0x644>
 8029cfc:	f01a 0240 	ands.w	r2, sl, #64	; 0x40
 8029d00:	d001      	beq.n	8029d06 <_vfiprintf_r+0x682>
 8029d02:	b2a4      	uxth	r4, r4
 8029d04:	e7e0      	b.n	8029cc8 <_vfiprintf_r+0x644>
 8029d06:	f41a 7500 	ands.w	r5, sl, #512	; 0x200
 8029d0a:	d0dd      	beq.n	8029cc8 <_vfiprintf_r+0x644>
 8029d0c:	b2e4      	uxtb	r4, r4
 8029d0e:	e7f3      	b.n	8029cf8 <_vfiprintf_r+0x674>
 8029d10:	2c0a      	cmp	r4, #10
 8029d12:	f175 0300 	sbcs.w	r3, r5, #0
 8029d16:	d20d      	bcs.n	8029d34 <_vfiprintf_r+0x6b0>
 8029d18:	3430      	adds	r4, #48	; 0x30
 8029d1a:	f88d 40e7 	strb.w	r4, [sp, #231]	; 0xe7
 8029d1e:	f10d 0be7 	add.w	fp, sp, #231	; 0xe7
 8029d22:	e135      	b.n	8029f90 <_vfiprintf_r+0x90c>
 8029d24:	0803652d 	.word	0x0803652d
 8029d28:	08036788 	.word	0x08036788
 8029d2c:	08036798 	.word	0x08036798
 8029d30:	0803653e 	.word	0x0803653e
 8029d34:	ab3a      	add	r3, sp, #232	; 0xe8
 8029d36:	9308      	str	r3, [sp, #32]
 8029d38:	9b04      	ldr	r3, [sp, #16]
 8029d3a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8029d3e:	f04f 0a00 	mov.w	sl, #0
 8029d42:	9309      	str	r3, [sp, #36]	; 0x24
 8029d44:	220a      	movs	r2, #10
 8029d46:	2300      	movs	r3, #0
 8029d48:	4620      	mov	r0, r4
 8029d4a:	4629      	mov	r1, r5
 8029d4c:	f7d6 ff44 	bl	8000bd8 <__aeabi_uldivmod>
 8029d50:	9b08      	ldr	r3, [sp, #32]
 8029d52:	3230      	adds	r2, #48	; 0x30
 8029d54:	f103 3bff 	add.w	fp, r3, #4294967295
 8029d58:	f803 2c01 	strb.w	r2, [r3, #-1]
 8029d5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8029d5e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8029d62:	f10a 0a01 	add.w	sl, sl, #1
 8029d66:	b1d3      	cbz	r3, 8029d9e <_vfiprintf_r+0x71a>
 8029d68:	9b06      	ldr	r3, [sp, #24]
 8029d6a:	781a      	ldrb	r2, [r3, #0]
 8029d6c:	4552      	cmp	r2, sl
 8029d6e:	d116      	bne.n	8029d9e <_vfiprintf_r+0x71a>
 8029d70:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 8029d74:	d013      	beq.n	8029d9e <_vfiprintf_r+0x71a>
 8029d76:	2c0a      	cmp	r4, #10
 8029d78:	f175 0200 	sbcs.w	r2, r5, #0
 8029d7c:	d30f      	bcc.n	8029d9e <_vfiprintf_r+0x71a>
 8029d7e:	9b07      	ldr	r3, [sp, #28]
 8029d80:	ebab 0b03 	sub.w	fp, fp, r3
 8029d84:	461a      	mov	r2, r3
 8029d86:	ee18 1a10 	vmov	r1, s16
 8029d8a:	4658      	mov	r0, fp
 8029d8c:	f7fd ff31 	bl	8027bf2 <strncpy>
 8029d90:	9b06      	ldr	r3, [sp, #24]
 8029d92:	785a      	ldrb	r2, [r3, #1]
 8029d94:	b16a      	cbz	r2, 8029db2 <_vfiprintf_r+0x72e>
 8029d96:	3301      	adds	r3, #1
 8029d98:	9306      	str	r3, [sp, #24]
 8029d9a:	f04f 0a00 	mov.w	sl, #0
 8029d9e:	2c0a      	cmp	r4, #10
 8029da0:	f175 0500 	sbcs.w	r5, r5, #0
 8029da4:	f0c0 80f4 	bcc.w	8029f90 <_vfiprintf_r+0x90c>
 8029da8:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
 8029dac:	f8cd b020 	str.w	fp, [sp, #32]
 8029db0:	e7c8      	b.n	8029d44 <_vfiprintf_r+0x6c0>
 8029db2:	4692      	mov	sl, r2
 8029db4:	e7f3      	b.n	8029d9e <_vfiprintf_r+0x71a>
 8029db6:	f004 020f 	and.w	r2, r4, #15
 8029dba:	9b05      	ldr	r3, [sp, #20]
 8029dbc:	0924      	lsrs	r4, r4, #4
 8029dbe:	5c9a      	ldrb	r2, [r3, r2]
 8029dc0:	f80b 2d01 	strb.w	r2, [fp, #-1]!
 8029dc4:	ea44 7405 	orr.w	r4, r4, r5, lsl #28
 8029dc8:	092d      	lsrs	r5, r5, #4
 8029dca:	ea54 0205 	orrs.w	r2, r4, r5
 8029dce:	d1f2      	bne.n	8029db6 <_vfiprintf_r+0x732>
 8029dd0:	e0de      	b.n	8029f90 <_vfiprintf_r+0x90c>
 8029dd2:	b933      	cbnz	r3, 8029de2 <_vfiprintf_r+0x75e>
 8029dd4:	f01a 0f01 	tst.w	sl, #1
 8029dd8:	d003      	beq.n	8029de2 <_vfiprintf_r+0x75e>
 8029dda:	2330      	movs	r3, #48	; 0x30
 8029ddc:	f88d 30e7 	strb.w	r3, [sp, #231]	; 0xe7
 8029de0:	e79d      	b.n	8029d1e <_vfiprintf_r+0x69a>
 8029de2:	f10d 0be8 	add.w	fp, sp, #232	; 0xe8
 8029de6:	e0d3      	b.n	8029f90 <_vfiprintf_r+0x90c>
 8029de8:	2b00      	cmp	r3, #0
 8029dea:	f000 809f 	beq.w	8029f2c <_vfiprintf_r+0x8a8>
 8029dee:	f88d 3084 	strb.w	r3, [sp, #132]	; 0x84
 8029df2:	2300      	movs	r3, #0
 8029df4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 8029df8:	46a0      	mov	r8, r4
 8029dfa:	e5c0      	b.n	802997e <_vfiprintf_r+0x2fa>
 8029dfc:	4605      	mov	r5, r0
 8029dfe:	e66e      	b.n	8029ade <_vfiprintf_r+0x45a>
 8029e00:	2110      	movs	r1, #16
 8029e02:	6071      	str	r1, [r6, #4]
 8029e04:	2a07      	cmp	r2, #7
 8029e06:	4461      	add	r1, ip
 8029e08:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 8029e0c:	dd08      	ble.n	8029e20 <_vfiprintf_r+0x79c>
 8029e0e:	aa0e      	add	r2, sp, #56	; 0x38
 8029e10:	4639      	mov	r1, r7
 8029e12:	4648      	mov	r0, r9
 8029e14:	f7ff fc04 	bl	8029620 <__sprint_r>
 8029e18:	2800      	cmp	r0, #0
 8029e1a:	d166      	bne.n	8029eea <_vfiprintf_r+0x866>
 8029e1c:	4b60      	ldr	r3, [pc, #384]	; (8029fa0 <_vfiprintf_r+0x91c>)
 8029e1e:	a811      	add	r0, sp, #68	; 0x44
 8029e20:	3c10      	subs	r4, #16
 8029e22:	4606      	mov	r6, r0
 8029e24:	e676      	b.n	8029b14 <_vfiprintf_r+0x490>
 8029e26:	4606      	mov	r6, r0
 8029e28:	e68e      	b.n	8029b48 <_vfiprintf_r+0x4c4>
 8029e2a:	aa0e      	add	r2, sp, #56	; 0x38
 8029e2c:	4639      	mov	r1, r7
 8029e2e:	4648      	mov	r0, r9
 8029e30:	f7ff fbf6 	bl	8029620 <__sprint_r>
 8029e34:	2800      	cmp	r0, #0
 8029e36:	d158      	bne.n	8029eea <_vfiprintf_r+0x866>
 8029e38:	ae11      	add	r6, sp, #68	; 0x44
 8029e3a:	e697      	b.n	8029b6c <_vfiprintf_r+0x4e8>
 8029e3c:	aa0e      	add	r2, sp, #56	; 0x38
 8029e3e:	4639      	mov	r1, r7
 8029e40:	4648      	mov	r0, r9
 8029e42:	f7ff fbed 	bl	8029620 <__sprint_r>
 8029e46:	2800      	cmp	r0, #0
 8029e48:	d14f      	bne.n	8029eea <_vfiprintf_r+0x866>
 8029e4a:	ae11      	add	r6, sp, #68	; 0x44
 8029e4c:	e69e      	b.n	8029b8c <_vfiprintf_r+0x508>
 8029e4e:	2110      	movs	r1, #16
 8029e50:	6071      	str	r1, [r6, #4]
 8029e52:	2a07      	cmp	r2, #7
 8029e54:	4461      	add	r1, ip
 8029e56:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 8029e5a:	dd08      	ble.n	8029e6e <_vfiprintf_r+0x7ea>
 8029e5c:	aa0e      	add	r2, sp, #56	; 0x38
 8029e5e:	4639      	mov	r1, r7
 8029e60:	4648      	mov	r0, r9
 8029e62:	f7ff fbdd 	bl	8029620 <__sprint_r>
 8029e66:	2800      	cmp	r0, #0
 8029e68:	d13f      	bne.n	8029eea <_vfiprintf_r+0x866>
 8029e6a:	4b4e      	ldr	r3, [pc, #312]	; (8029fa4 <_vfiprintf_r+0x920>)
 8029e6c:	a811      	add	r0, sp, #68	; 0x44
 8029e6e:	3c10      	subs	r4, #16
 8029e70:	4606      	mov	r6, r0
 8029e72:	e694      	b.n	8029b9e <_vfiprintf_r+0x51a>
 8029e74:	4606      	mov	r6, r0
 8029e76:	e6ac      	b.n	8029bd2 <_vfiprintf_r+0x54e>
 8029e78:	3110      	adds	r1, #16
 8029e7a:	2a07      	cmp	r2, #7
 8029e7c:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 8029e80:	6073      	str	r3, [r6, #4]
 8029e82:	dd07      	ble.n	8029e94 <_vfiprintf_r+0x810>
 8029e84:	aa0e      	add	r2, sp, #56	; 0x38
 8029e86:	4639      	mov	r1, r7
 8029e88:	4648      	mov	r0, r9
 8029e8a:	f7ff fbc9 	bl	8029620 <__sprint_r>
 8029e8e:	bb60      	cbnz	r0, 8029eea <_vfiprintf_r+0x866>
 8029e90:	a811      	add	r0, sp, #68	; 0x44
 8029e92:	2310      	movs	r3, #16
 8029e94:	3c10      	subs	r4, #16
 8029e96:	4606      	mov	r6, r0
 8029e98:	e6a1      	b.n	8029bde <_vfiprintf_r+0x55a>
 8029e9a:	4606      	mov	r6, r0
 8029e9c:	e6b9      	b.n	8029c12 <_vfiprintf_r+0x58e>
 8029e9e:	aa0e      	add	r2, sp, #56	; 0x38
 8029ea0:	4639      	mov	r1, r7
 8029ea2:	4648      	mov	r0, r9
 8029ea4:	f7ff fbbc 	bl	8029620 <__sprint_r>
 8029ea8:	b9f8      	cbnz	r0, 8029eea <_vfiprintf_r+0x866>
 8029eaa:	ab11      	add	r3, sp, #68	; 0x44
 8029eac:	e6c1      	b.n	8029c32 <_vfiprintf_r+0x5ae>
 8029eae:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 8029eb2:	1a54      	subs	r4, r2, r1
 8029eb4:	2c00      	cmp	r4, #0
 8029eb6:	f77f aec0 	ble.w	8029c3a <_vfiprintf_r+0x5b6>
 8029eba:	4d39      	ldr	r5, [pc, #228]	; (8029fa0 <_vfiprintf_r+0x91c>)
 8029ebc:	2610      	movs	r6, #16
 8029ebe:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 8029ec2:	2c10      	cmp	r4, #16
 8029ec4:	f102 0201 	add.w	r2, r2, #1
 8029ec8:	601d      	str	r5, [r3, #0]
 8029eca:	dc1d      	bgt.n	8029f08 <_vfiprintf_r+0x884>
 8029ecc:	605c      	str	r4, [r3, #4]
 8029ece:	2a07      	cmp	r2, #7
 8029ed0:	440c      	add	r4, r1
 8029ed2:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 8029ed6:	f77f aeb0 	ble.w	8029c3a <_vfiprintf_r+0x5b6>
 8029eda:	aa0e      	add	r2, sp, #56	; 0x38
 8029edc:	4639      	mov	r1, r7
 8029ede:	4648      	mov	r0, r9
 8029ee0:	f7ff fb9e 	bl	8029620 <__sprint_r>
 8029ee4:	2800      	cmp	r0, #0
 8029ee6:	f43f aea8 	beq.w	8029c3a <_vfiprintf_r+0x5b6>
 8029eea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8029eec:	07d9      	lsls	r1, r3, #31
 8029eee:	d405      	bmi.n	8029efc <_vfiprintf_r+0x878>
 8029ef0:	89bb      	ldrh	r3, [r7, #12]
 8029ef2:	059a      	lsls	r2, r3, #22
 8029ef4:	d402      	bmi.n	8029efc <_vfiprintf_r+0x878>
 8029ef6:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8029ef8:	f7fc f801 	bl	8025efe <__retarget_lock_release_recursive>
 8029efc:	89bb      	ldrh	r3, [r7, #12]
 8029efe:	065b      	lsls	r3, r3, #25
 8029f00:	f57f abf3 	bpl.w	80296ea <_vfiprintf_r+0x66>
 8029f04:	f7ff bbee 	b.w	80296e4 <_vfiprintf_r+0x60>
 8029f08:	3110      	adds	r1, #16
 8029f0a:	2a07      	cmp	r2, #7
 8029f0c:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 8029f10:	605e      	str	r6, [r3, #4]
 8029f12:	dc02      	bgt.n	8029f1a <_vfiprintf_r+0x896>
 8029f14:	3308      	adds	r3, #8
 8029f16:	3c10      	subs	r4, #16
 8029f18:	e7d1      	b.n	8029ebe <_vfiprintf_r+0x83a>
 8029f1a:	aa0e      	add	r2, sp, #56	; 0x38
 8029f1c:	4639      	mov	r1, r7
 8029f1e:	4648      	mov	r0, r9
 8029f20:	f7ff fb7e 	bl	8029620 <__sprint_r>
 8029f24:	2800      	cmp	r0, #0
 8029f26:	d1e0      	bne.n	8029eea <_vfiprintf_r+0x866>
 8029f28:	ab11      	add	r3, sp, #68	; 0x44
 8029f2a:	e7f4      	b.n	8029f16 <_vfiprintf_r+0x892>
 8029f2c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8029f2e:	b913      	cbnz	r3, 8029f36 <_vfiprintf_r+0x8b2>
 8029f30:	2300      	movs	r3, #0
 8029f32:	930f      	str	r3, [sp, #60]	; 0x3c
 8029f34:	e7d9      	b.n	8029eea <_vfiprintf_r+0x866>
 8029f36:	aa0e      	add	r2, sp, #56	; 0x38
 8029f38:	4639      	mov	r1, r7
 8029f3a:	4648      	mov	r0, r9
 8029f3c:	f7ff fb70 	bl	8029620 <__sprint_r>
 8029f40:	2800      	cmp	r0, #0
 8029f42:	d0f5      	beq.n	8029f30 <_vfiprintf_r+0x8ac>
 8029f44:	e7d1      	b.n	8029eea <_vfiprintf_r+0x866>
 8029f46:	ea54 0205 	orrs.w	r2, r4, r5
 8029f4a:	f8cd a010 	str.w	sl, [sp, #16]
 8029f4e:	f43f ad8d 	beq.w	8029a6c <_vfiprintf_r+0x3e8>
 8029f52:	2b01      	cmp	r3, #1
 8029f54:	f43f aedc 	beq.w	8029d10 <_vfiprintf_r+0x68c>
 8029f58:	2b02      	cmp	r3, #2
 8029f5a:	f10d 0be8 	add.w	fp, sp, #232	; 0xe8
 8029f5e:	f43f af2a 	beq.w	8029db6 <_vfiprintf_r+0x732>
 8029f62:	f004 0207 	and.w	r2, r4, #7
 8029f66:	08e4      	lsrs	r4, r4, #3
 8029f68:	ea44 7445 	orr.w	r4, r4, r5, lsl #29
 8029f6c:	08ed      	lsrs	r5, r5, #3
 8029f6e:	3230      	adds	r2, #48	; 0x30
 8029f70:	ea54 0005 	orrs.w	r0, r4, r5
 8029f74:	4659      	mov	r1, fp
 8029f76:	f80b 2d01 	strb.w	r2, [fp, #-1]!
 8029f7a:	d1f2      	bne.n	8029f62 <_vfiprintf_r+0x8de>
 8029f7c:	9b04      	ldr	r3, [sp, #16]
 8029f7e:	07d8      	lsls	r0, r3, #31
 8029f80:	d506      	bpl.n	8029f90 <_vfiprintf_r+0x90c>
 8029f82:	2a30      	cmp	r2, #48	; 0x30
 8029f84:	d004      	beq.n	8029f90 <_vfiprintf_r+0x90c>
 8029f86:	2230      	movs	r2, #48	; 0x30
 8029f88:	f80b 2c01 	strb.w	r2, [fp, #-1]
 8029f8c:	f1a1 0b02 	sub.w	fp, r1, #2
 8029f90:	ab3a      	add	r3, sp, #232	; 0xe8
 8029f92:	eba3 030b 	sub.w	r3, r3, fp
 8029f96:	9d00      	ldr	r5, [sp, #0]
 8029f98:	f8dd a010 	ldr.w	sl, [sp, #16]
 8029f9c:	9300      	str	r3, [sp, #0]
 8029f9e:	e59e      	b.n	8029ade <_vfiprintf_r+0x45a>
 8029fa0:	08036788 	.word	0x08036788
 8029fa4:	08036798 	.word	0x08036798

08029fa8 <__sbprintf>:
 8029fa8:	b570      	push	{r4, r5, r6, lr}
 8029faa:	460c      	mov	r4, r1
 8029fac:	8989      	ldrh	r1, [r1, #12]
 8029fae:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 8029fb2:	f021 0102 	bic.w	r1, r1, #2
 8029fb6:	f8ad 1014 	strh.w	r1, [sp, #20]
 8029fba:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8029fbc:	911b      	str	r1, [sp, #108]	; 0x6c
 8029fbe:	89e1      	ldrh	r1, [r4, #14]
 8029fc0:	f8ad 1016 	strh.w	r1, [sp, #22]
 8029fc4:	69e1      	ldr	r1, [r4, #28]
 8029fc6:	9109      	str	r1, [sp, #36]	; 0x24
 8029fc8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8029fca:	910b      	str	r1, [sp, #44]	; 0x2c
 8029fcc:	a91c      	add	r1, sp, #112	; 0x70
 8029fce:	9102      	str	r1, [sp, #8]
 8029fd0:	9106      	str	r1, [sp, #24]
 8029fd2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8029fd6:	4606      	mov	r6, r0
 8029fd8:	9104      	str	r1, [sp, #16]
 8029fda:	9107      	str	r1, [sp, #28]
 8029fdc:	a818      	add	r0, sp, #96	; 0x60
 8029fde:	2100      	movs	r1, #0
 8029fe0:	e9cd 3200 	strd	r3, r2, [sp]
 8029fe4:	9108      	str	r1, [sp, #32]
 8029fe6:	f7fb ff87 	bl	8025ef8 <__retarget_lock_init_recursive>
 8029fea:	e9dd 3200 	ldrd	r3, r2, [sp]
 8029fee:	a902      	add	r1, sp, #8
 8029ff0:	4630      	mov	r0, r6
 8029ff2:	f7ff fb47 	bl	8029684 <_vfiprintf_r>
 8029ff6:	1e05      	subs	r5, r0, #0
 8029ff8:	db07      	blt.n	802a00a <__sbprintf+0x62>
 8029ffa:	a902      	add	r1, sp, #8
 8029ffc:	4630      	mov	r0, r6
 8029ffe:	f7fd fdd3 	bl	8027ba8 <_fflush_r>
 802a002:	2800      	cmp	r0, #0
 802a004:	bf18      	it	ne
 802a006:	f04f 35ff 	movne.w	r5, #4294967295
 802a00a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 802a00e:	9818      	ldr	r0, [sp, #96]	; 0x60
 802a010:	065b      	lsls	r3, r3, #25
 802a012:	bf42      	ittt	mi
 802a014:	89a3      	ldrhmi	r3, [r4, #12]
 802a016:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 802a01a:	81a3      	strhmi	r3, [r4, #12]
 802a01c:	f7fb ff6d 	bl	8025efa <__retarget_lock_close_recursive>
 802a020:	4628      	mov	r0, r5
 802a022:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 802a026:	bd70      	pop	{r4, r5, r6, pc}

0802a028 <__sfvwrite_r>:
 802a028:	6893      	ldr	r3, [r2, #8]
 802a02a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a02e:	4606      	mov	r6, r0
 802a030:	460c      	mov	r4, r1
 802a032:	4691      	mov	r9, r2
 802a034:	b91b      	cbnz	r3, 802a03e <__sfvwrite_r+0x16>
 802a036:	2000      	movs	r0, #0
 802a038:	b003      	add	sp, #12
 802a03a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a03e:	898b      	ldrh	r3, [r1, #12]
 802a040:	0718      	lsls	r0, r3, #28
 802a042:	d54f      	bpl.n	802a0e4 <__sfvwrite_r+0xbc>
 802a044:	690b      	ldr	r3, [r1, #16]
 802a046:	2b00      	cmp	r3, #0
 802a048:	d04c      	beq.n	802a0e4 <__sfvwrite_r+0xbc>
 802a04a:	89a3      	ldrh	r3, [r4, #12]
 802a04c:	f8d9 8000 	ldr.w	r8, [r9]
 802a050:	f013 0702 	ands.w	r7, r3, #2
 802a054:	d16b      	bne.n	802a12e <__sfvwrite_r+0x106>
 802a056:	f013 0301 	ands.w	r3, r3, #1
 802a05a:	f000 809b 	beq.w	802a194 <__sfvwrite_r+0x16c>
 802a05e:	4638      	mov	r0, r7
 802a060:	46ba      	mov	sl, r7
 802a062:	46bb      	mov	fp, r7
 802a064:	f1bb 0f00 	cmp.w	fp, #0
 802a068:	f000 8102 	beq.w	802a270 <__sfvwrite_r+0x248>
 802a06c:	b950      	cbnz	r0, 802a084 <__sfvwrite_r+0x5c>
 802a06e:	465a      	mov	r2, fp
 802a070:	210a      	movs	r1, #10
 802a072:	4650      	mov	r0, sl
 802a074:	f7d6 f8cc 	bl	8000210 <memchr>
 802a078:	2800      	cmp	r0, #0
 802a07a:	f000 80ff 	beq.w	802a27c <__sfvwrite_r+0x254>
 802a07e:	3001      	adds	r0, #1
 802a080:	eba0 070a 	sub.w	r7, r0, sl
 802a084:	6820      	ldr	r0, [r4, #0]
 802a086:	6921      	ldr	r1, [r4, #16]
 802a088:	68a5      	ldr	r5, [r4, #8]
 802a08a:	6963      	ldr	r3, [r4, #20]
 802a08c:	455f      	cmp	r7, fp
 802a08e:	463a      	mov	r2, r7
 802a090:	bf28      	it	cs
 802a092:	465a      	movcs	r2, fp
 802a094:	4288      	cmp	r0, r1
 802a096:	f240 80f4 	bls.w	802a282 <__sfvwrite_r+0x25a>
 802a09a:	441d      	add	r5, r3
 802a09c:	42aa      	cmp	r2, r5
 802a09e:	f340 80f0 	ble.w	802a282 <__sfvwrite_r+0x25a>
 802a0a2:	4651      	mov	r1, sl
 802a0a4:	462a      	mov	r2, r5
 802a0a6:	f7ff fa3b 	bl	8029520 <memmove>
 802a0aa:	6823      	ldr	r3, [r4, #0]
 802a0ac:	442b      	add	r3, r5
 802a0ae:	6023      	str	r3, [r4, #0]
 802a0b0:	4621      	mov	r1, r4
 802a0b2:	4630      	mov	r0, r6
 802a0b4:	f7fd fd78 	bl	8027ba8 <_fflush_r>
 802a0b8:	2800      	cmp	r0, #0
 802a0ba:	d166      	bne.n	802a18a <__sfvwrite_r+0x162>
 802a0bc:	1b7f      	subs	r7, r7, r5
 802a0be:	f040 80f8 	bne.w	802a2b2 <__sfvwrite_r+0x28a>
 802a0c2:	4621      	mov	r1, r4
 802a0c4:	4630      	mov	r0, r6
 802a0c6:	f7fd fd6f 	bl	8027ba8 <_fflush_r>
 802a0ca:	2800      	cmp	r0, #0
 802a0cc:	d15d      	bne.n	802a18a <__sfvwrite_r+0x162>
 802a0ce:	f8d9 3008 	ldr.w	r3, [r9, #8]
 802a0d2:	1b5b      	subs	r3, r3, r5
 802a0d4:	44aa      	add	sl, r5
 802a0d6:	ebab 0b05 	sub.w	fp, fp, r5
 802a0da:	f8c9 3008 	str.w	r3, [r9, #8]
 802a0de:	2b00      	cmp	r3, #0
 802a0e0:	d1c0      	bne.n	802a064 <__sfvwrite_r+0x3c>
 802a0e2:	e7a8      	b.n	802a036 <__sfvwrite_r+0xe>
 802a0e4:	4621      	mov	r1, r4
 802a0e6:	4630      	mov	r0, r6
 802a0e8:	f000 f8e8 	bl	802a2bc <__swsetup_r>
 802a0ec:	2800      	cmp	r0, #0
 802a0ee:	d0ac      	beq.n	802a04a <__sfvwrite_r+0x22>
 802a0f0:	f04f 30ff 	mov.w	r0, #4294967295
 802a0f4:	e7a0      	b.n	802a038 <__sfvwrite_r+0x10>
 802a0f6:	e9d8 a500 	ldrd	sl, r5, [r8]
 802a0fa:	f108 0808 	add.w	r8, r8, #8
 802a0fe:	f8d4 b024 	ldr.w	fp, [r4, #36]	; 0x24
 802a102:	69e1      	ldr	r1, [r4, #28]
 802a104:	2d00      	cmp	r5, #0
 802a106:	d0f6      	beq.n	802a0f6 <__sfvwrite_r+0xce>
 802a108:	42bd      	cmp	r5, r7
 802a10a:	462b      	mov	r3, r5
 802a10c:	4652      	mov	r2, sl
 802a10e:	bf28      	it	cs
 802a110:	463b      	movcs	r3, r7
 802a112:	4630      	mov	r0, r6
 802a114:	47d8      	blx	fp
 802a116:	2800      	cmp	r0, #0
 802a118:	dd37      	ble.n	802a18a <__sfvwrite_r+0x162>
 802a11a:	f8d9 3008 	ldr.w	r3, [r9, #8]
 802a11e:	1a1b      	subs	r3, r3, r0
 802a120:	4482      	add	sl, r0
 802a122:	1a2d      	subs	r5, r5, r0
 802a124:	f8c9 3008 	str.w	r3, [r9, #8]
 802a128:	2b00      	cmp	r3, #0
 802a12a:	d1e8      	bne.n	802a0fe <__sfvwrite_r+0xd6>
 802a12c:	e783      	b.n	802a036 <__sfvwrite_r+0xe>
 802a12e:	f04f 0a00 	mov.w	sl, #0
 802a132:	4f61      	ldr	r7, [pc, #388]	; (802a2b8 <__sfvwrite_r+0x290>)
 802a134:	4655      	mov	r5, sl
 802a136:	e7e2      	b.n	802a0fe <__sfvwrite_r+0xd6>
 802a138:	e9d8 7a00 	ldrd	r7, sl, [r8]
 802a13c:	f108 0808 	add.w	r8, r8, #8
 802a140:	6820      	ldr	r0, [r4, #0]
 802a142:	68a2      	ldr	r2, [r4, #8]
 802a144:	f1ba 0f00 	cmp.w	sl, #0
 802a148:	d0f6      	beq.n	802a138 <__sfvwrite_r+0x110>
 802a14a:	89a3      	ldrh	r3, [r4, #12]
 802a14c:	0599      	lsls	r1, r3, #22
 802a14e:	d563      	bpl.n	802a218 <__sfvwrite_r+0x1f0>
 802a150:	4552      	cmp	r2, sl
 802a152:	d836      	bhi.n	802a1c2 <__sfvwrite_r+0x19a>
 802a154:	f413 6f90 	tst.w	r3, #1152	; 0x480
 802a158:	d033      	beq.n	802a1c2 <__sfvwrite_r+0x19a>
 802a15a:	6921      	ldr	r1, [r4, #16]
 802a15c:	6965      	ldr	r5, [r4, #20]
 802a15e:	eba0 0b01 	sub.w	fp, r0, r1
 802a162:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802a166:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802a16a:	f10b 0201 	add.w	r2, fp, #1
 802a16e:	106d      	asrs	r5, r5, #1
 802a170:	4452      	add	r2, sl
 802a172:	4295      	cmp	r5, r2
 802a174:	bf38      	it	cc
 802a176:	4615      	movcc	r5, r2
 802a178:	055b      	lsls	r3, r3, #21
 802a17a:	d53d      	bpl.n	802a1f8 <__sfvwrite_r+0x1d0>
 802a17c:	4629      	mov	r1, r5
 802a17e:	4630      	mov	r0, r6
 802a180:	f7fb fff8 	bl	8026174 <_malloc_r>
 802a184:	b948      	cbnz	r0, 802a19a <__sfvwrite_r+0x172>
 802a186:	230c      	movs	r3, #12
 802a188:	6033      	str	r3, [r6, #0]
 802a18a:	89a3      	ldrh	r3, [r4, #12]
 802a18c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a190:	81a3      	strh	r3, [r4, #12]
 802a192:	e7ad      	b.n	802a0f0 <__sfvwrite_r+0xc8>
 802a194:	461f      	mov	r7, r3
 802a196:	469a      	mov	sl, r3
 802a198:	e7d2      	b.n	802a140 <__sfvwrite_r+0x118>
 802a19a:	465a      	mov	r2, fp
 802a19c:	6921      	ldr	r1, [r4, #16]
 802a19e:	9001      	str	r0, [sp, #4]
 802a1a0:	f7fb feb6 	bl	8025f10 <memcpy>
 802a1a4:	89a2      	ldrh	r2, [r4, #12]
 802a1a6:	9b01      	ldr	r3, [sp, #4]
 802a1a8:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 802a1ac:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802a1b0:	81a2      	strh	r2, [r4, #12]
 802a1b2:	6123      	str	r3, [r4, #16]
 802a1b4:	6165      	str	r5, [r4, #20]
 802a1b6:	445b      	add	r3, fp
 802a1b8:	eba5 050b 	sub.w	r5, r5, fp
 802a1bc:	6023      	str	r3, [r4, #0]
 802a1be:	4652      	mov	r2, sl
 802a1c0:	60a5      	str	r5, [r4, #8]
 802a1c2:	4552      	cmp	r2, sl
 802a1c4:	bf28      	it	cs
 802a1c6:	4652      	movcs	r2, sl
 802a1c8:	6820      	ldr	r0, [r4, #0]
 802a1ca:	9201      	str	r2, [sp, #4]
 802a1cc:	4639      	mov	r1, r7
 802a1ce:	f7ff f9a7 	bl	8029520 <memmove>
 802a1d2:	68a3      	ldr	r3, [r4, #8]
 802a1d4:	9a01      	ldr	r2, [sp, #4]
 802a1d6:	1a9b      	subs	r3, r3, r2
 802a1d8:	60a3      	str	r3, [r4, #8]
 802a1da:	6823      	ldr	r3, [r4, #0]
 802a1dc:	4413      	add	r3, r2
 802a1de:	4655      	mov	r5, sl
 802a1e0:	6023      	str	r3, [r4, #0]
 802a1e2:	f8d9 3008 	ldr.w	r3, [r9, #8]
 802a1e6:	1b5b      	subs	r3, r3, r5
 802a1e8:	442f      	add	r7, r5
 802a1ea:	ebaa 0a05 	sub.w	sl, sl, r5
 802a1ee:	f8c9 3008 	str.w	r3, [r9, #8]
 802a1f2:	2b00      	cmp	r3, #0
 802a1f4:	d1a4      	bne.n	802a140 <__sfvwrite_r+0x118>
 802a1f6:	e71e      	b.n	802a036 <__sfvwrite_r+0xe>
 802a1f8:	462a      	mov	r2, r5
 802a1fa:	4630      	mov	r0, r6
 802a1fc:	f7fe ff5e 	bl	80290bc <_realloc_r>
 802a200:	4603      	mov	r3, r0
 802a202:	2800      	cmp	r0, #0
 802a204:	d1d5      	bne.n	802a1b2 <__sfvwrite_r+0x18a>
 802a206:	6921      	ldr	r1, [r4, #16]
 802a208:	4630      	mov	r0, r6
 802a20a:	f7fb fef3 	bl	8025ff4 <_free_r>
 802a20e:	89a3      	ldrh	r3, [r4, #12]
 802a210:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802a214:	81a3      	strh	r3, [r4, #12]
 802a216:	e7b6      	b.n	802a186 <__sfvwrite_r+0x15e>
 802a218:	6923      	ldr	r3, [r4, #16]
 802a21a:	4283      	cmp	r3, r0
 802a21c:	d302      	bcc.n	802a224 <__sfvwrite_r+0x1fc>
 802a21e:	6961      	ldr	r1, [r4, #20]
 802a220:	4551      	cmp	r1, sl
 802a222:	d915      	bls.n	802a250 <__sfvwrite_r+0x228>
 802a224:	4552      	cmp	r2, sl
 802a226:	bf28      	it	cs
 802a228:	4652      	movcs	r2, sl
 802a22a:	4639      	mov	r1, r7
 802a22c:	4615      	mov	r5, r2
 802a22e:	f7ff f977 	bl	8029520 <memmove>
 802a232:	68a3      	ldr	r3, [r4, #8]
 802a234:	6822      	ldr	r2, [r4, #0]
 802a236:	1b5b      	subs	r3, r3, r5
 802a238:	442a      	add	r2, r5
 802a23a:	60a3      	str	r3, [r4, #8]
 802a23c:	6022      	str	r2, [r4, #0]
 802a23e:	2b00      	cmp	r3, #0
 802a240:	d1cf      	bne.n	802a1e2 <__sfvwrite_r+0x1ba>
 802a242:	4621      	mov	r1, r4
 802a244:	4630      	mov	r0, r6
 802a246:	f7fd fcaf 	bl	8027ba8 <_fflush_r>
 802a24a:	2800      	cmp	r0, #0
 802a24c:	d0c9      	beq.n	802a1e2 <__sfvwrite_r+0x1ba>
 802a24e:	e79c      	b.n	802a18a <__sfvwrite_r+0x162>
 802a250:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 802a254:	459a      	cmp	sl, r3
 802a256:	bf38      	it	cc
 802a258:	4653      	movcc	r3, sl
 802a25a:	6a65      	ldr	r5, [r4, #36]	; 0x24
 802a25c:	fb93 f3f1 	sdiv	r3, r3, r1
 802a260:	463a      	mov	r2, r7
 802a262:	434b      	muls	r3, r1
 802a264:	4630      	mov	r0, r6
 802a266:	69e1      	ldr	r1, [r4, #28]
 802a268:	47a8      	blx	r5
 802a26a:	1e05      	subs	r5, r0, #0
 802a26c:	dcb9      	bgt.n	802a1e2 <__sfvwrite_r+0x1ba>
 802a26e:	e78c      	b.n	802a18a <__sfvwrite_r+0x162>
 802a270:	e9d8 ab00 	ldrd	sl, fp, [r8]
 802a274:	2000      	movs	r0, #0
 802a276:	f108 0808 	add.w	r8, r8, #8
 802a27a:	e6f3      	b.n	802a064 <__sfvwrite_r+0x3c>
 802a27c:	f10b 0701 	add.w	r7, fp, #1
 802a280:	e700      	b.n	802a084 <__sfvwrite_r+0x5c>
 802a282:	4293      	cmp	r3, r2
 802a284:	dc08      	bgt.n	802a298 <__sfvwrite_r+0x270>
 802a286:	6a65      	ldr	r5, [r4, #36]	; 0x24
 802a288:	69e1      	ldr	r1, [r4, #28]
 802a28a:	4652      	mov	r2, sl
 802a28c:	4630      	mov	r0, r6
 802a28e:	47a8      	blx	r5
 802a290:	1e05      	subs	r5, r0, #0
 802a292:	f73f af13 	bgt.w	802a0bc <__sfvwrite_r+0x94>
 802a296:	e778      	b.n	802a18a <__sfvwrite_r+0x162>
 802a298:	4651      	mov	r1, sl
 802a29a:	9201      	str	r2, [sp, #4]
 802a29c:	f7ff f940 	bl	8029520 <memmove>
 802a2a0:	9a01      	ldr	r2, [sp, #4]
 802a2a2:	68a3      	ldr	r3, [r4, #8]
 802a2a4:	1a9b      	subs	r3, r3, r2
 802a2a6:	60a3      	str	r3, [r4, #8]
 802a2a8:	6823      	ldr	r3, [r4, #0]
 802a2aa:	4413      	add	r3, r2
 802a2ac:	6023      	str	r3, [r4, #0]
 802a2ae:	4615      	mov	r5, r2
 802a2b0:	e704      	b.n	802a0bc <__sfvwrite_r+0x94>
 802a2b2:	2001      	movs	r0, #1
 802a2b4:	e70b      	b.n	802a0ce <__sfvwrite_r+0xa6>
 802a2b6:	bf00      	nop
 802a2b8:	7ffffc00 	.word	0x7ffffc00

0802a2bc <__swsetup_r>:
 802a2bc:	b538      	push	{r3, r4, r5, lr}
 802a2be:	4b2a      	ldr	r3, [pc, #168]	; (802a368 <__swsetup_r+0xac>)
 802a2c0:	4605      	mov	r5, r0
 802a2c2:	6818      	ldr	r0, [r3, #0]
 802a2c4:	460c      	mov	r4, r1
 802a2c6:	b118      	cbz	r0, 802a2d0 <__swsetup_r+0x14>
 802a2c8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802a2ca:	b90b      	cbnz	r3, 802a2d0 <__swsetup_r+0x14>
 802a2cc:	f7fb fc9a 	bl	8025c04 <__sinit>
 802a2d0:	89a3      	ldrh	r3, [r4, #12]
 802a2d2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802a2d6:	0718      	lsls	r0, r3, #28
 802a2d8:	d422      	bmi.n	802a320 <__swsetup_r+0x64>
 802a2da:	06d9      	lsls	r1, r3, #27
 802a2dc:	d407      	bmi.n	802a2ee <__swsetup_r+0x32>
 802a2de:	2309      	movs	r3, #9
 802a2e0:	602b      	str	r3, [r5, #0]
 802a2e2:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 802a2e6:	81a3      	strh	r3, [r4, #12]
 802a2e8:	f04f 30ff 	mov.w	r0, #4294967295
 802a2ec:	e034      	b.n	802a358 <__swsetup_r+0x9c>
 802a2ee:	0758      	lsls	r0, r3, #29
 802a2f0:	d512      	bpl.n	802a318 <__swsetup_r+0x5c>
 802a2f2:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802a2f4:	b141      	cbz	r1, 802a308 <__swsetup_r+0x4c>
 802a2f6:	f104 0340 	add.w	r3, r4, #64	; 0x40
 802a2fa:	4299      	cmp	r1, r3
 802a2fc:	d002      	beq.n	802a304 <__swsetup_r+0x48>
 802a2fe:	4628      	mov	r0, r5
 802a300:	f7fb fe78 	bl	8025ff4 <_free_r>
 802a304:	2300      	movs	r3, #0
 802a306:	6323      	str	r3, [r4, #48]	; 0x30
 802a308:	89a3      	ldrh	r3, [r4, #12]
 802a30a:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 802a30e:	81a3      	strh	r3, [r4, #12]
 802a310:	2300      	movs	r3, #0
 802a312:	6063      	str	r3, [r4, #4]
 802a314:	6923      	ldr	r3, [r4, #16]
 802a316:	6023      	str	r3, [r4, #0]
 802a318:	89a3      	ldrh	r3, [r4, #12]
 802a31a:	f043 0308 	orr.w	r3, r3, #8
 802a31e:	81a3      	strh	r3, [r4, #12]
 802a320:	6923      	ldr	r3, [r4, #16]
 802a322:	b94b      	cbnz	r3, 802a338 <__swsetup_r+0x7c>
 802a324:	89a3      	ldrh	r3, [r4, #12]
 802a326:	f403 7320 	and.w	r3, r3, #640	; 0x280
 802a32a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802a32e:	d003      	beq.n	802a338 <__swsetup_r+0x7c>
 802a330:	4621      	mov	r1, r4
 802a332:	4628      	mov	r0, r5
 802a334:	f000 f8ca 	bl	802a4cc <__smakebuf_r>
 802a338:	89a0      	ldrh	r0, [r4, #12]
 802a33a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802a33e:	f010 0301 	ands.w	r3, r0, #1
 802a342:	d00a      	beq.n	802a35a <__swsetup_r+0x9e>
 802a344:	2300      	movs	r3, #0
 802a346:	60a3      	str	r3, [r4, #8]
 802a348:	6963      	ldr	r3, [r4, #20]
 802a34a:	425b      	negs	r3, r3
 802a34c:	61a3      	str	r3, [r4, #24]
 802a34e:	6923      	ldr	r3, [r4, #16]
 802a350:	b943      	cbnz	r3, 802a364 <__swsetup_r+0xa8>
 802a352:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 802a356:	d1c4      	bne.n	802a2e2 <__swsetup_r+0x26>
 802a358:	bd38      	pop	{r3, r4, r5, pc}
 802a35a:	0781      	lsls	r1, r0, #30
 802a35c:	bf58      	it	pl
 802a35e:	6963      	ldrpl	r3, [r4, #20]
 802a360:	60a3      	str	r3, [r4, #8]
 802a362:	e7f4      	b.n	802a34e <__swsetup_r+0x92>
 802a364:	2000      	movs	r0, #0
 802a366:	e7f7      	b.n	802a358 <__swsetup_r+0x9c>
 802a368:	20000380 	.word	0x20000380

0802a36c <__fputwc>:
 802a36c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 802a370:	4680      	mov	r8, r0
 802a372:	460e      	mov	r6, r1
 802a374:	4615      	mov	r5, r2
 802a376:	f7fd fc4f 	bl	8027c18 <__locale_mb_cur_max>
 802a37a:	2801      	cmp	r0, #1
 802a37c:	d11c      	bne.n	802a3b8 <__fputwc+0x4c>
 802a37e:	1e73      	subs	r3, r6, #1
 802a380:	2bfe      	cmp	r3, #254	; 0xfe
 802a382:	d819      	bhi.n	802a3b8 <__fputwc+0x4c>
 802a384:	f88d 6004 	strb.w	r6, [sp, #4]
 802a388:	4604      	mov	r4, r0
 802a38a:	2700      	movs	r7, #0
 802a38c:	f10d 0904 	add.w	r9, sp, #4
 802a390:	42a7      	cmp	r7, r4
 802a392:	d020      	beq.n	802a3d6 <__fputwc+0x6a>
 802a394:	68ab      	ldr	r3, [r5, #8]
 802a396:	f817 1009 	ldrb.w	r1, [r7, r9]
 802a39a:	3b01      	subs	r3, #1
 802a39c:	2b00      	cmp	r3, #0
 802a39e:	60ab      	str	r3, [r5, #8]
 802a3a0:	da04      	bge.n	802a3ac <__fputwc+0x40>
 802a3a2:	69aa      	ldr	r2, [r5, #24]
 802a3a4:	4293      	cmp	r3, r2
 802a3a6:	db1a      	blt.n	802a3de <__fputwc+0x72>
 802a3a8:	290a      	cmp	r1, #10
 802a3aa:	d018      	beq.n	802a3de <__fputwc+0x72>
 802a3ac:	682b      	ldr	r3, [r5, #0]
 802a3ae:	1c5a      	adds	r2, r3, #1
 802a3b0:	602a      	str	r2, [r5, #0]
 802a3b2:	7019      	strb	r1, [r3, #0]
 802a3b4:	3701      	adds	r7, #1
 802a3b6:	e7eb      	b.n	802a390 <__fputwc+0x24>
 802a3b8:	a901      	add	r1, sp, #4
 802a3ba:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 802a3be:	4632      	mov	r2, r6
 802a3c0:	4640      	mov	r0, r8
 802a3c2:	f000 f845 	bl	802a450 <_wcrtomb_r>
 802a3c6:	1c41      	adds	r1, r0, #1
 802a3c8:	4604      	mov	r4, r0
 802a3ca:	d1de      	bne.n	802a38a <__fputwc+0x1e>
 802a3cc:	89ab      	ldrh	r3, [r5, #12]
 802a3ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a3d2:	81ab      	strh	r3, [r5, #12]
 802a3d4:	4606      	mov	r6, r0
 802a3d6:	4630      	mov	r0, r6
 802a3d8:	b003      	add	sp, #12
 802a3da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802a3de:	462a      	mov	r2, r5
 802a3e0:	4640      	mov	r0, r8
 802a3e2:	f000 f8af 	bl	802a544 <__swbuf_r>
 802a3e6:	1c42      	adds	r2, r0, #1
 802a3e8:	d1e4      	bne.n	802a3b4 <__fputwc+0x48>
 802a3ea:	4606      	mov	r6, r0
 802a3ec:	e7f3      	b.n	802a3d6 <__fputwc+0x6a>

0802a3ee <_fputwc_r>:
 802a3ee:	6e53      	ldr	r3, [r2, #100]	; 0x64
 802a3f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802a3f2:	4614      	mov	r4, r2
 802a3f4:	07da      	lsls	r2, r3, #31
 802a3f6:	4605      	mov	r5, r0
 802a3f8:	d407      	bmi.n	802a40a <_fputwc_r+0x1c>
 802a3fa:	89a3      	ldrh	r3, [r4, #12]
 802a3fc:	059b      	lsls	r3, r3, #22
 802a3fe:	d404      	bmi.n	802a40a <_fputwc_r+0x1c>
 802a400:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802a402:	9101      	str	r1, [sp, #4]
 802a404:	f7fb fd7a 	bl	8025efc <__retarget_lock_acquire_recursive>
 802a408:	9901      	ldr	r1, [sp, #4]
 802a40a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a40e:	0498      	lsls	r0, r3, #18
 802a410:	d406      	bmi.n	802a420 <_fputwc_r+0x32>
 802a412:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802a416:	81a3      	strh	r3, [r4, #12]
 802a418:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802a41a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802a41e:	6663      	str	r3, [r4, #100]	; 0x64
 802a420:	4622      	mov	r2, r4
 802a422:	4628      	mov	r0, r5
 802a424:	f7ff ffa2 	bl	802a36c <__fputwc>
 802a428:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802a42a:	07da      	lsls	r2, r3, #31
 802a42c:	4605      	mov	r5, r0
 802a42e:	d405      	bmi.n	802a43c <_fputwc_r+0x4e>
 802a430:	89a3      	ldrh	r3, [r4, #12]
 802a432:	059b      	lsls	r3, r3, #22
 802a434:	d402      	bmi.n	802a43c <_fputwc_r+0x4e>
 802a436:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802a438:	f7fb fd61 	bl	8025efe <__retarget_lock_release_recursive>
 802a43c:	4628      	mov	r0, r5
 802a43e:	b003      	add	sp, #12
 802a440:	bd30      	pop	{r4, r5, pc}

0802a442 <abort>:
 802a442:	b508      	push	{r3, lr}
 802a444:	2006      	movs	r0, #6
 802a446:	f000 f8ef 	bl	802a628 <raise>
 802a44a:	2001      	movs	r0, #1
 802a44c:	f7d7 f9cc 	bl	80017e8 <_exit>

0802a450 <_wcrtomb_r>:
 802a450:	b5f0      	push	{r4, r5, r6, r7, lr}
 802a452:	4c09      	ldr	r4, [pc, #36]	; (802a478 <_wcrtomb_r+0x28>)
 802a454:	b085      	sub	sp, #20
 802a456:	f8d4 70e0 	ldr.w	r7, [r4, #224]	; 0xe0
 802a45a:	4605      	mov	r5, r0
 802a45c:	461e      	mov	r6, r3
 802a45e:	b909      	cbnz	r1, 802a464 <_wcrtomb_r+0x14>
 802a460:	460a      	mov	r2, r1
 802a462:	a901      	add	r1, sp, #4
 802a464:	47b8      	blx	r7
 802a466:	1c43      	adds	r3, r0, #1
 802a468:	bf01      	itttt	eq
 802a46a:	2300      	moveq	r3, #0
 802a46c:	6033      	streq	r3, [r6, #0]
 802a46e:	238a      	moveq	r3, #138	; 0x8a
 802a470:	602b      	streq	r3, [r5, #0]
 802a472:	b005      	add	sp, #20
 802a474:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802a476:	bf00      	nop
 802a478:	20000798 	.word	0x20000798

0802a47c <__swhatbuf_r>:
 802a47c:	b570      	push	{r4, r5, r6, lr}
 802a47e:	460c      	mov	r4, r1
 802a480:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802a484:	2900      	cmp	r1, #0
 802a486:	b096      	sub	sp, #88	; 0x58
 802a488:	4615      	mov	r5, r2
 802a48a:	461e      	mov	r6, r3
 802a48c:	da07      	bge.n	802a49e <__swhatbuf_r+0x22>
 802a48e:	89a1      	ldrh	r1, [r4, #12]
 802a490:	f011 0180 	ands.w	r1, r1, #128	; 0x80
 802a494:	d017      	beq.n	802a4c6 <__swhatbuf_r+0x4a>
 802a496:	2100      	movs	r1, #0
 802a498:	2340      	movs	r3, #64	; 0x40
 802a49a:	4608      	mov	r0, r1
 802a49c:	e00f      	b.n	802a4be <__swhatbuf_r+0x42>
 802a49e:	466a      	mov	r2, sp
 802a4a0:	f000 f8ca 	bl	802a638 <_fstat_r>
 802a4a4:	2800      	cmp	r0, #0
 802a4a6:	dbf2      	blt.n	802a48e <__swhatbuf_r+0x12>
 802a4a8:	9901      	ldr	r1, [sp, #4]
 802a4aa:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 802a4ae:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 802a4b2:	4259      	negs	r1, r3
 802a4b4:	4159      	adcs	r1, r3
 802a4b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802a4ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802a4be:	6031      	str	r1, [r6, #0]
 802a4c0:	602b      	str	r3, [r5, #0]
 802a4c2:	b016      	add	sp, #88	; 0x58
 802a4c4:	bd70      	pop	{r4, r5, r6, pc}
 802a4c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802a4ca:	e7e6      	b.n	802a49a <__swhatbuf_r+0x1e>

0802a4cc <__smakebuf_r>:
 802a4cc:	898b      	ldrh	r3, [r1, #12]
 802a4ce:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802a4d0:	079d      	lsls	r5, r3, #30
 802a4d2:	4606      	mov	r6, r0
 802a4d4:	460c      	mov	r4, r1
 802a4d6:	d507      	bpl.n	802a4e8 <__smakebuf_r+0x1c>
 802a4d8:	f104 0343 	add.w	r3, r4, #67	; 0x43
 802a4dc:	6023      	str	r3, [r4, #0]
 802a4de:	6123      	str	r3, [r4, #16]
 802a4e0:	2301      	movs	r3, #1
 802a4e2:	6163      	str	r3, [r4, #20]
 802a4e4:	b002      	add	sp, #8
 802a4e6:	bd70      	pop	{r4, r5, r6, pc}
 802a4e8:	ab01      	add	r3, sp, #4
 802a4ea:	466a      	mov	r2, sp
 802a4ec:	f7ff ffc6 	bl	802a47c <__swhatbuf_r>
 802a4f0:	9900      	ldr	r1, [sp, #0]
 802a4f2:	4605      	mov	r5, r0
 802a4f4:	4630      	mov	r0, r6
 802a4f6:	f7fb fe3d 	bl	8026174 <_malloc_r>
 802a4fa:	b948      	cbnz	r0, 802a510 <__smakebuf_r+0x44>
 802a4fc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a500:	059a      	lsls	r2, r3, #22
 802a502:	d4ef      	bmi.n	802a4e4 <__smakebuf_r+0x18>
 802a504:	f023 0303 	bic.w	r3, r3, #3
 802a508:	f043 0302 	orr.w	r3, r3, #2
 802a50c:	81a3      	strh	r3, [r4, #12]
 802a50e:	e7e3      	b.n	802a4d8 <__smakebuf_r+0xc>
 802a510:	89a3      	ldrh	r3, [r4, #12]
 802a512:	6020      	str	r0, [r4, #0]
 802a514:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802a518:	81a3      	strh	r3, [r4, #12]
 802a51a:	9b00      	ldr	r3, [sp, #0]
 802a51c:	6163      	str	r3, [r4, #20]
 802a51e:	9b01      	ldr	r3, [sp, #4]
 802a520:	6120      	str	r0, [r4, #16]
 802a522:	b15b      	cbz	r3, 802a53c <__smakebuf_r+0x70>
 802a524:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802a528:	4630      	mov	r0, r6
 802a52a:	f000 f897 	bl	802a65c <_isatty_r>
 802a52e:	b128      	cbz	r0, 802a53c <__smakebuf_r+0x70>
 802a530:	89a3      	ldrh	r3, [r4, #12]
 802a532:	f023 0303 	bic.w	r3, r3, #3
 802a536:	f043 0301 	orr.w	r3, r3, #1
 802a53a:	81a3      	strh	r3, [r4, #12]
 802a53c:	89a3      	ldrh	r3, [r4, #12]
 802a53e:	431d      	orrs	r5, r3
 802a540:	81a5      	strh	r5, [r4, #12]
 802a542:	e7cf      	b.n	802a4e4 <__smakebuf_r+0x18>

0802a544 <__swbuf_r>:
 802a544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a546:	460e      	mov	r6, r1
 802a548:	4614      	mov	r4, r2
 802a54a:	4605      	mov	r5, r0
 802a54c:	b118      	cbz	r0, 802a556 <__swbuf_r+0x12>
 802a54e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802a550:	b90b      	cbnz	r3, 802a556 <__swbuf_r+0x12>
 802a552:	f7fb fb57 	bl	8025c04 <__sinit>
 802a556:	69a3      	ldr	r3, [r4, #24]
 802a558:	60a3      	str	r3, [r4, #8]
 802a55a:	89a3      	ldrh	r3, [r4, #12]
 802a55c:	0719      	lsls	r1, r3, #28
 802a55e:	d529      	bpl.n	802a5b4 <__swbuf_r+0x70>
 802a560:	6923      	ldr	r3, [r4, #16]
 802a562:	b33b      	cbz	r3, 802a5b4 <__swbuf_r+0x70>
 802a564:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a568:	b2f6      	uxtb	r6, r6
 802a56a:	049a      	lsls	r2, r3, #18
 802a56c:	4637      	mov	r7, r6
 802a56e:	d52a      	bpl.n	802a5c6 <__swbuf_r+0x82>
 802a570:	6823      	ldr	r3, [r4, #0]
 802a572:	6922      	ldr	r2, [r4, #16]
 802a574:	1a98      	subs	r0, r3, r2
 802a576:	6963      	ldr	r3, [r4, #20]
 802a578:	4283      	cmp	r3, r0
 802a57a:	dc04      	bgt.n	802a586 <__swbuf_r+0x42>
 802a57c:	4621      	mov	r1, r4
 802a57e:	4628      	mov	r0, r5
 802a580:	f7fd fb12 	bl	8027ba8 <_fflush_r>
 802a584:	b9e0      	cbnz	r0, 802a5c0 <__swbuf_r+0x7c>
 802a586:	68a3      	ldr	r3, [r4, #8]
 802a588:	3b01      	subs	r3, #1
 802a58a:	60a3      	str	r3, [r4, #8]
 802a58c:	6823      	ldr	r3, [r4, #0]
 802a58e:	1c5a      	adds	r2, r3, #1
 802a590:	6022      	str	r2, [r4, #0]
 802a592:	701e      	strb	r6, [r3, #0]
 802a594:	6962      	ldr	r2, [r4, #20]
 802a596:	1c43      	adds	r3, r0, #1
 802a598:	429a      	cmp	r2, r3
 802a59a:	d004      	beq.n	802a5a6 <__swbuf_r+0x62>
 802a59c:	89a3      	ldrh	r3, [r4, #12]
 802a59e:	07db      	lsls	r3, r3, #31
 802a5a0:	d506      	bpl.n	802a5b0 <__swbuf_r+0x6c>
 802a5a2:	2e0a      	cmp	r6, #10
 802a5a4:	d104      	bne.n	802a5b0 <__swbuf_r+0x6c>
 802a5a6:	4621      	mov	r1, r4
 802a5a8:	4628      	mov	r0, r5
 802a5aa:	f7fd fafd 	bl	8027ba8 <_fflush_r>
 802a5ae:	b938      	cbnz	r0, 802a5c0 <__swbuf_r+0x7c>
 802a5b0:	4638      	mov	r0, r7
 802a5b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a5b4:	4621      	mov	r1, r4
 802a5b6:	4628      	mov	r0, r5
 802a5b8:	f7ff fe80 	bl	802a2bc <__swsetup_r>
 802a5bc:	2800      	cmp	r0, #0
 802a5be:	d0d1      	beq.n	802a564 <__swbuf_r+0x20>
 802a5c0:	f04f 37ff 	mov.w	r7, #4294967295
 802a5c4:	e7f4      	b.n	802a5b0 <__swbuf_r+0x6c>
 802a5c6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802a5ca:	81a3      	strh	r3, [r4, #12]
 802a5cc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802a5ce:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802a5d2:	6663      	str	r3, [r4, #100]	; 0x64
 802a5d4:	e7cc      	b.n	802a570 <__swbuf_r+0x2c>

0802a5d6 <_raise_r>:
 802a5d6:	291f      	cmp	r1, #31
 802a5d8:	b538      	push	{r3, r4, r5, lr}
 802a5da:	4604      	mov	r4, r0
 802a5dc:	460d      	mov	r5, r1
 802a5de:	d904      	bls.n	802a5ea <_raise_r+0x14>
 802a5e0:	2316      	movs	r3, #22
 802a5e2:	6003      	str	r3, [r0, #0]
 802a5e4:	f04f 30ff 	mov.w	r0, #4294967295
 802a5e8:	bd38      	pop	{r3, r4, r5, pc}
 802a5ea:	f8d0 2118 	ldr.w	r2, [r0, #280]	; 0x118
 802a5ee:	b112      	cbz	r2, 802a5f6 <_raise_r+0x20>
 802a5f0:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802a5f4:	b94b      	cbnz	r3, 802a60a <_raise_r+0x34>
 802a5f6:	4620      	mov	r0, r4
 802a5f8:	f000 f852 	bl	802a6a0 <_getpid_r>
 802a5fc:	462a      	mov	r2, r5
 802a5fe:	4601      	mov	r1, r0
 802a600:	4620      	mov	r0, r4
 802a602:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802a606:	f000 b839 	b.w	802a67c <_kill_r>
 802a60a:	2b01      	cmp	r3, #1
 802a60c:	d00a      	beq.n	802a624 <_raise_r+0x4e>
 802a60e:	1c59      	adds	r1, r3, #1
 802a610:	d103      	bne.n	802a61a <_raise_r+0x44>
 802a612:	2316      	movs	r3, #22
 802a614:	6003      	str	r3, [r0, #0]
 802a616:	2001      	movs	r0, #1
 802a618:	e7e6      	b.n	802a5e8 <_raise_r+0x12>
 802a61a:	2400      	movs	r4, #0
 802a61c:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 802a620:	4628      	mov	r0, r5
 802a622:	4798      	blx	r3
 802a624:	2000      	movs	r0, #0
 802a626:	e7df      	b.n	802a5e8 <_raise_r+0x12>

0802a628 <raise>:
 802a628:	4b02      	ldr	r3, [pc, #8]	; (802a634 <raise+0xc>)
 802a62a:	4601      	mov	r1, r0
 802a62c:	6818      	ldr	r0, [r3, #0]
 802a62e:	f7ff bfd2 	b.w	802a5d6 <_raise_r>
 802a632:	bf00      	nop
 802a634:	20000380 	.word	0x20000380

0802a638 <_fstat_r>:
 802a638:	b538      	push	{r3, r4, r5, lr}
 802a63a:	4d07      	ldr	r5, [pc, #28]	; (802a658 <_fstat_r+0x20>)
 802a63c:	2300      	movs	r3, #0
 802a63e:	4604      	mov	r4, r0
 802a640:	4608      	mov	r0, r1
 802a642:	4611      	mov	r1, r2
 802a644:	602b      	str	r3, [r5, #0]
 802a646:	f7d7 f8f6 	bl	8001836 <_fstat>
 802a64a:	1c43      	adds	r3, r0, #1
 802a64c:	d102      	bne.n	802a654 <_fstat_r+0x1c>
 802a64e:	682b      	ldr	r3, [r5, #0]
 802a650:	b103      	cbz	r3, 802a654 <_fstat_r+0x1c>
 802a652:	6023      	str	r3, [r4, #0]
 802a654:	bd38      	pop	{r3, r4, r5, pc}
 802a656:	bf00      	nop
 802a658:	20011ed8 	.word	0x20011ed8

0802a65c <_isatty_r>:
 802a65c:	b538      	push	{r3, r4, r5, lr}
 802a65e:	4d06      	ldr	r5, [pc, #24]	; (802a678 <_isatty_r+0x1c>)
 802a660:	2300      	movs	r3, #0
 802a662:	4604      	mov	r4, r0
 802a664:	4608      	mov	r0, r1
 802a666:	602b      	str	r3, [r5, #0]
 802a668:	f7d7 f8ea 	bl	8001840 <_isatty>
 802a66c:	1c43      	adds	r3, r0, #1
 802a66e:	d102      	bne.n	802a676 <_isatty_r+0x1a>
 802a670:	682b      	ldr	r3, [r5, #0]
 802a672:	b103      	cbz	r3, 802a676 <_isatty_r+0x1a>
 802a674:	6023      	str	r3, [r4, #0]
 802a676:	bd38      	pop	{r3, r4, r5, pc}
 802a678:	20011ed8 	.word	0x20011ed8

0802a67c <_kill_r>:
 802a67c:	b538      	push	{r3, r4, r5, lr}
 802a67e:	4d07      	ldr	r5, [pc, #28]	; (802a69c <_kill_r+0x20>)
 802a680:	2300      	movs	r3, #0
 802a682:	4604      	mov	r4, r0
 802a684:	4608      	mov	r0, r1
 802a686:	4611      	mov	r1, r2
 802a688:	602b      	str	r3, [r5, #0]
 802a68a:	f7d7 f8a5 	bl	80017d8 <_kill>
 802a68e:	1c43      	adds	r3, r0, #1
 802a690:	d102      	bne.n	802a698 <_kill_r+0x1c>
 802a692:	682b      	ldr	r3, [r5, #0]
 802a694:	b103      	cbz	r3, 802a698 <_kill_r+0x1c>
 802a696:	6023      	str	r3, [r4, #0]
 802a698:	bd38      	pop	{r3, r4, r5, pc}
 802a69a:	bf00      	nop
 802a69c:	20011ed8 	.word	0x20011ed8

0802a6a0 <_getpid_r>:
 802a6a0:	f7d7 b898 	b.w	80017d4 <_getpid>

0802a6a4 <_init>:
 802a6a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a6a6:	bf00      	nop
 802a6a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802a6aa:	bc08      	pop	{r3}
 802a6ac:	469e      	mov	lr, r3
 802a6ae:	4770      	bx	lr

0802a6b0 <_fini>:
 802a6b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a6b2:	bf00      	nop
 802a6b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802a6b6:	bc08      	pop	{r3}
 802a6b8:	469e      	mov	lr, r3
 802a6ba:	4770      	bx	lr
